{
  "1": {
    "id": 1,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 1,
    "buggy_line_location": 1563,
    "buggy_line_content": "if (dataset != null) {",
    "fixed_line_location": 1564,
    "fixed_line_content": "if (dataset == null) {",
    "bug_description_link": "https://sourceforge.net/p/jfreechart/bugs/983",
    "in_function": true,
    "commit": {
      "commit_id": "19998781c35b4f68a509f6b630f4815392769f38",
      "commit_message": "2010-02-09  David Gilbert  <david.gilbert@object-refinery.com>\n\n    Bug 2947660:\n    * source/org/jfree/chart/renderer/category/AbstractCategoryRenderer.java\n    (getLegendItems): Fix null check.",
      "commit_author": "David Gilbert",
      "commit_parent": "a1b908b52210369cde2e953281d7b98b862ec672",
      "commit_date": "2010-02-09 21:13:39",
      "commit_file_diff": "@@ -2,7 +2,7 @@\n  * JFreeChart : a free chart library for the Java(tm) platform\r\n  * ===========================================================\r\n  *\r\n- * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\r\n+ * (C) Copyright 2000-2010, by Object Refinery Limited and Contributors.\r\n  *\r\n  * Project Info:  http://www.jfree.org/jfreechart/index.html\r\n  *\r\n@@ -27,7 +27,7 @@\n  * ---------------------------------\r\n  * AbstractCategoryItemRenderer.java\r\n  * ---------------------------------\r\n- * (C) Copyright 2002-2009, by Object Refinery Limited.\r\n+ * (C) Copyright 2002-2010, by Object Refinery Limited.\r\n  *\r\n  * Original Author:  David Gilbert (for Object Refinery Limited);\r\n  * Contributor(s):   Richard Atkinson;\r\n@@ -102,6 +102,7 @@\n  * 27-Mar-2009 : Added new findRangeBounds() method to account for hidden\r\n  *               series (DG);\r\n  * 01-Apr-2009 : Added new addEntity() method (DG);\r\n+ * 09-Feb-2010 : Fixed bug 2947660 (DG);\r\n  * \r\n  */\r\n \r\n@@ -1560,7 +1561,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\r\n         int index = this.plot.getIndexOf(this);\r\n         CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n+        if (dataset == null) {\r\n             return result;\r\n         }\r\n         int seriesCount = dataset.getRowCount();\r\n"
    },
    "function": {
      "function_name": "getLegendItems",
      "function_parent": "AbstractCategoryItemRenderer::getLegendItems()",
      "function_before_start_line": 1556,
      "function_before_end_line": 1588,
      "function_after_start_line": 1557,
      "function_after_end_line": 1589,
      "function_before_token_count": 195,
      "function_after_token_count": 195,
      "function_before": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset != null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        for (int i = 0; i < seriesCount; i++) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    else {\n        for (int i = seriesCount - 1; i >= 0; i--) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "function_after": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        for (int i = 0; i < seriesCount; i++) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    else {\n        for (int i = seriesCount - 1; i >= 0; i--) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    return result;\n}"
    },
    "file": {
      "file_name": "AbstractCategoryItemRenderer.java",
      "file_path": "source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java",
      "file_nloc": 970,
      "file_complexity": 178,
      "file_token_count": 6160,
      "file_before": "",
      "file_after": ""
    }
  },
  "2": {
    "id": 2,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 8,
    "buggy_line_location": 174,
    "buggy_line_content": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
    "fixed_line_location": 175,
    "fixed_line_content": "this(time, zone, Locale.getDefault());",
    "bug_description_link": "",
    "in_function": true,
    "commit": {
      "commit_id": "6e70e821a0aa8b1dd4c905fa1d51f85b4d941067",
      "commit_message": "2007-12-19  David Gilbert  <david.gilbert@object-refinery.com>\n\n    * source/org/jfree/data/time/Week.java\n    (Week(Date, TimeZone)): Hand on the zone,\n    * tests/org/jfree/data/time/junit/WeekTests.java\n    (testBug1448828): Control the default locale,\n    (testBug1498805): Likewise,\n    (testGetFirstMillisecondWithTimeZone): Control the default locale, and\n    modify expected result accordingly,\n    (testGetLastMillisecondWithTimeZone): Likewise.",
      "commit_author": "David Gilbert",
      "commit_parent": "71afeabd172edb15d95f125b8a59783edc923362",
      "commit_date": "2007-12-19 17:30:19",
      "commit_file_diff": "@@ -65,6 +65,7 @@\n  * 09-Jan-2007 : Fixed bug in next() (DG);\r\n  * 28-Aug-2007 : Added new constructor to avoid problem in creating new \r\n  *               instances (DG);\r\n+ * 19-Dec-2007 : Fixed bug in deprecated constructor (DG);\r\n  *\r\n  */\r\n \r\n@@ -171,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\r\n     public Week(Date time, TimeZone zone) {\r\n         // defer argument checking...\r\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\r\n+        this(time, zone, Locale.getDefault());\r\n     }\r\n     \r\n     /**\r\n"
    },
    "function": {
      "function_name": "Week",
      "function_parent": "Week::Week( Date time , TimeZone zone)",
      "function_before_start_line": 172,
      "function_before_end_line": 175,
      "function_after_start_line": 173,
      "function_after_end_line": 176,
      "function_before_token_count": 25,
      "function_after_token_count": 23,
      "function_before": "public Week(Date time, TimeZone zone) {\n    // defer argument checking...\n    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n}",
      "function_after": "public Week(Date time, TimeZone zone) {\n    // defer argument checking...\n    this(time, zone, Locale.getDefault());\n}"
    },
    "file": {
      "file_name": "Week.java",
      "file_path": "source/org/jfree/data/time/Week.java",
      "file_nloc": 279,
      "file_complexity": 61,
      "file_token_count": 1723,
      "file_before": "",
      "file_after": ""
    }
  },
  "3": {
    "id": 3,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 9,
    "buggy_line_location": 937,
    "buggy_line_content": "if (endIndex < 0) {",
    "fixed_line_location": 941,
    "fixed_line_content": "if ((endIndex < 0)  || (endIndex < startIndex)) {",
    "bug_description_link": "https://sourceforge.net/p/jfreechart/bugs/818",
    "in_function": true,
    "commit": {
      "commit_id": "5e9c71aac26d533bd99c13f70d8c0e195d28865c",
      "commit_message": "2008-01-10  David Gilbert  <david.gilbert@object-refinery.com>\n\n\tBug 1864222:\n\t* source/org/jfree/data/time/TimeSeries.java\n\t(createCopy(RegularTimePeriod, RegularTimePeriod)): Handle empty range,\n\t* tests/org/jfree/data/time/junit/TimeSeriesTests.java\n\t(testBug1864222): New test method.",
      "commit_author": "David Gilbert",
      "commit_parent": "0ca96cca00ddff278ff210945425df060b5eb5c7",
      "commit_date": "2008-01-10 16:12:33",
      "commit_file_diff": "@@ -2,7 +2,7 @@\n  * JFreeChart : a free chart library for the Java(tm) platform\r\n  * ===========================================================\r\n  *\r\n- * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\r\n+ * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\r\n  *\r\n  * Project Info:  http://www.jfree.org/jfreechart/index.html\r\n  *\r\n@@ -27,7 +27,7 @@\n  * ---------------\r\n  * TimeSeries.java\r\n  * ---------------\r\n- * (C) Copyright 2001-2007, by Object Refinery Limited.\r\n+ * (C) Copyright 2001-2008, by Object Refinery Limited.\r\n  *\r\n  * Original Author:  David Gilbert (for Object Refinery Limited);\r\n  * Contributor(s):   Bryan Scott;\r\n@@ -72,6 +72,8 @@\n  *               by Nick Guenther (DG);\r\n  * 31-Oct-2007 : Implemented faster hashCode() (DG);\r\n  * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\r\n+ * 10-Jan-2008 : Fixed createCopy(RegularTimePeriod, RegularTimePeriod) (bug\r\n+ *               1864222) (DG);\r\n  * \r\n  */\r\n \r\n@@ -900,8 +902,10 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n      * Creates a new timeseries by copying a subset of the data in this time \r\n      * series.\r\n      *\r\n-     * @param start  the first time period to copy.\r\n-     * @param end  the last time period to copy.\r\n+     * @param start  the first time period to copy (<code>null</code> not\r\n+     *         permitted).\r\n+     * @param end  the last time period to copy (<code>null</code> not \r\n+     *         permitted).\r\n      *\r\n      * @return A time series containing a copy of this time series from start \r\n      *         until end.\r\n@@ -934,7 +938,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\r\n             endIndex = endIndex - 1;    // so this is last item BEFORE end \r\n         }\r\n-        if (endIndex < 0) {\r\n+        if ((endIndex < 0)  || (endIndex < startIndex)) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r\n@@ -963,15 +967,13 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             return false;\r\n         }\r\n         TimeSeries s = (TimeSeries) object;\r\n-        if (!ObjectUtilities.equal(\r\n-            getDomainDescription(), s.getDomainDescription()\r\n-        )) {\r\n+        if (!ObjectUtilities.equal(getDomainDescription(), \r\n+                s.getDomainDescription())) {\r\n             return false;\r\n         }\r\n \r\n-        if (!ObjectUtilities.equal(\r\n-            getRangeDescription(), s.getRangeDescription()\r\n-        )) {\r\n+        if (!ObjectUtilities.equal(getRangeDescription(), \r\n+                s.getRangeDescription())) {\r\n             return false;\r\n         }\r\n \r\n"
    },
    "function": {
      "function_name": "createCopy",
      "function_parent": "TimeSeries::createCopy( RegularTimePeriod start , RegularTimePeriod end)",
      "function_before_start_line": 911,
      "function_before_end_line": 949,
      "function_after_start_line": 915,
      "function_after_end_line": 953,
      "function_before_token_count": 198,
      "function_after_token_count": 206,
      "function_before": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  // start is after last data item\n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             // end period is not in original series\n        endIndex = -(endIndex + 1); // this is first item AFTER end period\n        endIndex = endIndex - 1;    // so this is last item BEFORE end \n    }\n    if (endIndex < 0) {\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        return copy;\n    }\n    else {\n        return createCopy(startIndex, endIndex);\n    }\n\n}",
      "function_after": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  // start is after last data item\n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             // end period is not in original series\n        endIndex = -(endIndex + 1); // this is first item AFTER end period\n        endIndex = endIndex - 1;    // so this is last item BEFORE end \n    }\n    if ((endIndex < 0)  || (endIndex < startIndex)) {\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        return copy;\n    }\n    else {\n        return createCopy(startIndex, endIndex);\n    }\n\n}"
    },
    "file": {
      "file_name": "TimeSeries.java",
      "file_path": "source/org/jfree/data/time/TimeSeries.java",
      "file_nloc": 473,
      "file_complexity": 113,
      "file_token_count": 2992,
      "file_before": "",
      "file_after": ""
    }
  },
  "4": {
    "id": 4,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 10,
    "buggy_line_location": 56,
    "buggy_line_content": "return \" title=\\\"\" + toolTipText",
    "fixed_line_location": 65,
    "fixed_line_content": "return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText)",
    "bug_description_link": "",
    "in_function": true,
    "commit": {
      "commit_id": "3c01d6426e7c3bad2bfd3ea6d4645644fe36904e",
      "commit_message": "2007-12-04  David Gilbert  <david.gilbert@object-refinery.com>\n\n    * source/org/jfree/chart/imagemap/DynamicDriveToolTipFragmentGenerator.java\n    (generateToolTipFragment): Escape text,\n    * source/org/jfree/chart/imagemap/OverLIBToolTipFragmentGenerator.java\n    (generateToolTipFragment): Likewise,\n    * source/org/jfree/chart/imagemap/StandardToolTipFragmentGenerator.java\n    (generateToolTipFragment): Likewise,\n    * source/org/jfree/chart/imagemap/StandardURLTagFragmentGenerator.java\n    (generateURLFragment): Likewise.",
      "commit_author": "David Gilbert",
      "commit_parent": "4ec8d7c2a21218aef06946262ae33d4ca2e91d83",
      "commit_date": "2007-12-04 22:02:56",
      "commit_file_diff": "@@ -30,10 +30,12 @@\n  * (C) Copyright 2003-2007, by Richard Atkinson and Contributors.\r\n  *\r\n  * Original Author:  Richard Atkinson;\r\n+ * Contributors:     David Gilbert (for Object Refinery Limited);\r\n  *\r\n  * Changes\r\n  * -------\r\n  * 12-Aug-2003 : Version 1 (RA);\r\n+ * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);\r\n  * \r\n  */\r\n  \r\n@@ -43,8 +45,15 @@ package org.jfree.chart.imagemap;\n  * Generates tooltips using the HTML title attribute for image map area tags.\r\n  */\r\n public class StandardToolTipTagFragmentGenerator \r\n-    implements ToolTipTagFragmentGenerator {\r\n+        implements ToolTipTagFragmentGenerator {\r\n \r\n+\t/**\r\n+\t * Creates a new instance.\r\n+\t */\r\n+\tpublic StandardToolTipTagFragmentGenerator() {\r\n+\t\tsuper();\r\n+\t}\r\n+\t\r\n     /**\r\n      * Generates a tooltip string to go in an HTML image map.\r\n      *\r\n@@ -53,7 +62,8 @@ public class StandardToolTipTagFragmentGenerator\n      * @return The formatted HTML area tag attribute(s).\r\n      */\r\n     public String generateToolTipFragment(String toolTipText) {\r\n-        return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";\r\n+        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \r\n+            + \"\\\" alt=\\\"\\\"\";\r\n     }\r\n \r\n }\r\n"
    },
    "function": {
      "function_name": "generateToolTipFragment",
      "function_parent": "StandardToolTipTagFragmentGenerator::generateToolTipFragment( String toolTipText)",
      "function_before_start_line": 55,
      "function_before_end_line": 57,
      "function_after_start_line": 64,
      "function_after_end_line": 67,
      "function_before_token_count": 14,
      "function_after_token_count": 19,
      "function_before": "public String generateToolTipFragment(String toolTipText) {\n    return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";\n}",
      "function_after": "public String generateToolTipFragment(String toolTipText) {\n    return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n        + \"\\\" alt=\\\"\\\"\";\n}"
    },
    "file": {
      "file_name": "StandardToolTipTagFragmentGenerator.java",
      "file_path": "source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java",
      "file_nloc": 11,
      "file_complexity": 2,
      "file_token_count": 47,
      "file_before": "",
      "file_after": ""
    }
  },
  "5": {
    "id": 5,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 12,
    "buggy_line_location": 142,
    "buggy_line_content": "this.dataset = dataset;",
    "fixed_line_location": 144,
    "fixed_line_content": "setDataset(dataset);",
    "bug_description_link": "https://sourceforge.net/p/jfreechart/patches/213",
    "in_function": true,
    "commit": {
      "commit_id": "abd98c7bf320b4224ab61359b73fdcbcb517a0ad",
      "commit_message": "2008-04-18  David Gilbert  <david.gilbert@object-refinery.com>\n\n    Patch 1943021 (Brian Cabana):\n    * source/org/jfree/chart/plot/MultiplePiePlot.java\n    (MultiplePiePlot(CategoryDataset)): Call setDataset() to ensure that\n    plot registers as a dataset listener,\n    * tests/org/jfree/chart/plot/junit/MultiplePiePlotTests.java\n    (testConstructors): New test method.",
      "commit_author": "David Gilbert",
      "commit_parent": "ce7b0375a70fddec9b4da46ce028434dbecac8bc",
      "commit_date": "2008-04-18 13:05:19",
      "commit_file_diff": "@@ -2,35 +2,35 @@\n  * JFreeChart : a free chart library for the Java(tm) platform\r\n  * ===========================================================\r\n  *\r\n- * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\r\n+ * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\r\n  *\r\n  * Project Info:  http://www.jfree.org/jfreechart/index.html\r\n  *\r\n- * This library is free software; you can redistribute it and/or modify it \r\n- * under the terms of the GNU Lesser General Public License as published by \r\n- * the Free Software Foundation; either version 2.1 of the License, or \r\n+ * This library is free software; you can redistribute it and/or modify it\r\n+ * under the terms of the GNU Lesser General Public License as published by\r\n+ * the Free Software Foundation; either version 2.1 of the License, or\r\n  * (at your option) any later version.\r\n  *\r\n- * This library is distributed in the hope that it will be useful, but \r\n- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n- * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n+ * This library is distributed in the hope that it will be useful, but\r\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\r\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\r\n  * License for more details.\r\n  *\r\n  * You should have received a copy of the GNU Lesser General Public\r\n  * License along with this library; if not, write to the Free Software\r\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n- * USA.  \r\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\r\n+ * USA.\r\n  *\r\n- * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n+ * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\r\n  * in the United States and other countries.]\r\n  *\r\n  * --------------------\r\n  * MultiplePiePlot.java\r\n  * --------------------\r\n- * (C) Copyright 2004-2007, by Object Refinery Limited.\r\n+ * (C) Copyright 2004-2008, by Object Refinery Limited.\r\n  *\r\n  * Original Author:  David Gilbert (for Object Refinery Limited);\r\n- * Contributor(s):   -;\r\n+ * Contributor(s):   Brian Cabana (patch 1943021);\r\n  *\r\n  * Changes\r\n  * -------\r\n@@ -47,6 +47,8 @@\n  *               underlying PiePlot (DG);\r\n  * 17-May-2007 : Added argument check to setPieChart() (DG);\r\n  * 18-May-2007 : Set dataset for LegendItem (DG);\r\n+ * 18-Apr-2008 : In the constructor, register the plot as a dataset listener -\r\n+ *               see patch 1943021 from Brian Cabana (DG);\r\n  *\r\n  */\r\n \r\n@@ -87,65 +89,65 @@ import org.jfree.util.PaintUtilities;\n import org.jfree.util.TableOrder;\r\n \r\n /**\r\n- * A plot that displays multiple pie plots using data from a \r\n+ * A plot that displays multiple pie plots using data from a\r\n  * {@link CategoryDataset}.\r\n  */\r\n public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\r\n-    \r\n+\r\n     /** For serialization. */\r\n     private static final long serialVersionUID = -355377800470807389L;\r\n-    \r\n+\r\n     /** The chart object that draws the individual pie charts. */\r\n     private JFreeChart pieChart;\r\n-    \r\n+\r\n     /** The dataset. */\r\n     private CategoryDataset dataset;\r\n-    \r\n+\r\n     /** The data extract order (by row or by column). */\r\n     private TableOrder dataExtractOrder;\r\n-    \r\n+\r\n     /** The pie section limit percentage. */\r\n     private double limit = 0.0;\r\n-    \r\n-    /** \r\n-     * The key for the aggregated items. \r\n+\r\n+    /**\r\n+     * The key for the aggregated items.\r\n      * @since 1.0.2\r\n      */\r\n     private Comparable aggregatedItemsKey;\r\n-    \r\n-    /** \r\n-     * The paint for the aggregated items. \r\n+\r\n+    /**\r\n+     * The paint for the aggregated items.\r\n      * @since 1.0.2\r\n      */\r\n     private transient Paint aggregatedItemsPaint;\r\n-    \r\n-    /** \r\n-     * The colors to use for each section. \r\n+\r\n+    /**\r\n+     * The colors to use for each section.\r\n      * @since 1.0.2\r\n      */\r\n     private transient Map sectionPaints;\r\n-    \r\n+\r\n     /**\r\n      * Creates a new plot with no data.\r\n      */\r\n     public MultiplePiePlot() {\r\n         this(null);\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Creates a new plot.\r\n-     * \r\n+     *\r\n      * @param dataset  the dataset (<code>null</code> permitted).\r\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n-        this.dataset = dataset;\r\n+        setDataset(dataset);\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n         this.pieChart.setBackgroundPaint(null);\r\n-        TextTitle seriesTitle = new TextTitle(\"Series Title\", \r\n+        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                 new Font(\"SansSerif\", Font.BOLD, 12));\r\n         seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n         this.pieChart.setTitle(seriesTitle);\r\n@@ -153,24 +155,24 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         this.aggregatedItemsPaint = Color.lightGray;\r\n         this.sectionPaints = new HashMap();\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Returns the dataset used by the plot.\r\n-     * \r\n+     *\r\n      * @return The dataset (possibly <code>null</code>).\r\n      */\r\n     public CategoryDataset getDataset() {\r\n-        return this.dataset;   \r\n+        return this.dataset;\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}\r\n      * to all registered listeners.\r\n-     * \r\n+     *\r\n      * @param dataset  the dataset (<code>null</code> permitted).\r\n      */\r\n     public void setDataset(CategoryDataset dataset) {\r\n-        // if there is an existing dataset, remove the plot from the list of \r\n+        // if there is an existing dataset, remove the plot from the list of\r\n         // change listeners...\r\n         if (this.dataset != null) {\r\n             this.dataset.removeChangeListener(this);\r\n@@ -186,22 +188,22 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         // send a dataset change event to self to trigger plot change event\r\n         datasetChanged(new DatasetChangeEvent(this, dataset));\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Returns the pie chart that is used to draw the individual pie plots.\r\n-     * \r\n+     *\r\n      * @return The pie chart (never <code>null</code>).\r\n-     * \r\n+     *\r\n      * @see #setPieChart(JFreeChart)\r\n      */\r\n     public JFreeChart getPieChart() {\r\n         return this.pieChart;\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Sets the chart that is used to draw the individual pie plots.  The\r\n      * chart's plot must be an instance of {@link PiePlot}.\r\n-     * \r\n+     *\r\n      * @param pieChart  the pie chart (<code>null</code> not permitted).\r\n      *\r\n      * @see #getPieChart()\r\n@@ -217,20 +219,20 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         this.pieChart = pieChart;\r\n         fireChangeEvent();\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Returns the data extract order (by row or by column).\r\n-     * \r\n+     *\r\n      * @return The data extract order (never <code>null</code>).\r\n      */\r\n     public TableOrder getDataExtractOrder() {\r\n         return this.dataExtractOrder;\r\n     }\r\n-    \r\n+\r\n     /**\r\n-     * Sets the data extract order (by row or by column) and sends a \r\n+     * Sets the data extract order (by row or by column) and sends a\r\n      * {@link PlotChangeEvent} to all registered listeners.\r\n-     * \r\n+     *\r\n      * @param order  the order (<code>null</code> not permitted).\r\n      */\r\n     public void setDataExtractOrder(TableOrder order) {\r\n@@ -240,46 +242,46 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         this.dataExtractOrder = order;\r\n         fireChangeEvent();\r\n     }\r\n-    \r\n+\r\n     /**\r\n-     * Returns the limit (as a percentage) below which small pie sections are \r\n+     * Returns the limit (as a percentage) below which small pie sections are\r\n      * aggregated.\r\n-     * \r\n+     *\r\n      * @return The limit percentage.\r\n      */\r\n     public double getLimit() {\r\n         return this.limit;\r\n     }\r\n-    \r\n+\r\n     /**\r\n-     * Sets the limit below which pie sections are aggregated.  \r\n+     * Sets the limit below which pie sections are aggregated.\r\n      * Set this to 0.0 if you don't want any aggregation to occur.\r\n-     * \r\n+     *\r\n      * @param limit  the limit percent.\r\n      */\r\n     public void setLimit(double limit) {\r\n         this.limit = limit;\r\n         fireChangeEvent();\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Returns the key for aggregated items in the pie plots, if there are any.\r\n      * The default value is \"Other\".\r\n-     * \r\n+     *\r\n      * @return The aggregated items key.\r\n-     * \r\n+     *\r\n      * @since 1.0.2\r\n      */\r\n     public Comparable getAggregatedItemsKey() {\r\n         return this.aggregatedItemsKey;\r\n     }\r\n-    \r\n+\r\n     /**\r\n-     * Sets the key for aggregated items in the pie plots.  You must ensure \r\n+     * Sets the key for aggregated items in the pie plots.  You must ensure\r\n      * that this doesn't clash with any keys in the dataset.\r\n-     * \r\n+     *\r\n      * @param key  the key (<code>null</code> not permitted).\r\n-     * \r\n+     *\r\n      * @since 1.0.2\r\n      */\r\n     public void setAggregatedItemsKey(Comparable key) {\r\n@@ -289,25 +291,25 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         this.aggregatedItemsKey = key;\r\n         fireChangeEvent();\r\n     }\r\n-    \r\n+\r\n     /**\r\n-     * Returns the paint used to draw the pie section representing the \r\n+     * Returns the paint used to draw the pie section representing the\r\n      * aggregated items.  The default value is <code>Color.lightGray</code>.\r\n-     * \r\n+     *\r\n      * @return The paint.\r\n-     * \r\n+     *\r\n      * @since 1.0.2\r\n      */\r\n     public Paint getAggregatedItemsPaint() {\r\n         return this.aggregatedItemsPaint;\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Sets the paint used to draw the pie section representing the aggregated\r\n      * items and sends a {@link PlotChangeEvent} to all registered listeners.\r\n-     * \r\n+     *\r\n      * @param paint  the paint (<code>null</code> not permitted).\r\n-     * \r\n+     *\r\n      * @since 1.0.2\r\n      */\r\n     public void setAggregatedItemsPaint(Paint paint) {\r\n@@ -317,19 +319,19 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         this.aggregatedItemsPaint = paint;\r\n         fireChangeEvent();\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Returns a short string describing the type of plot.\r\n      *\r\n      * @return The plot type.\r\n      */\r\n     public String getPlotType() {\r\n-        return \"Multiple Pie Plot\";  \r\n+        return \"Multiple Pie Plot\";\r\n          // TODO: need to fetch this from localised resources\r\n     }\r\n \r\n     /**\r\n-     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n+     * Draws the plot on a Java 2D graphics device (such as the screen or a\r\n      * printer).\r\n      *\r\n      * @param g2  the graphics device.\r\n@@ -338,19 +340,19 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      * @param parentState  the state from the parent plot, if there is one.\r\n      * @param info  collects info about the drawing.\r\n      */\r\n-    public void draw(Graphics2D g2, \r\n+    public void draw(Graphics2D g2,\r\n                      Rectangle2D area,\r\n                      Point2D anchor,\r\n                      PlotState parentState,\r\n                      PlotRenderingInfo info) {\r\n-        \r\n-       \r\n+\r\n+\r\n         // adjust the drawing area for the plot insets (if any)...\r\n         RectangleInsets insets = getInsets();\r\n         insets.trim(area);\r\n         drawBackground(g2, area);\r\n         drawOutline(g2, area);\r\n-        \r\n+\r\n         // check that there is some data to display...\r\n         if (DatasetUtilities.isEmptyOrNull(this.dataset)) {\r\n             drawNoDataMessage(g2, area);\r\n@@ -367,7 +369,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n \r\n         // the columns variable is always >= rows\r\n         int displayCols = (int) Math.ceil(Math.sqrt(pieCount));\r\n-        int displayRows \r\n+        int displayRows\r\n             = (int) Math.ceil((double) pieCount / (double) displayCols);\r\n \r\n         // swap rows and columns to match plotArea shape\r\n@@ -378,7 +380,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         }\r\n \r\n         prefetchSectionPaints();\r\n-        \r\n+\r\n         int x = (int) area.getX();\r\n         int y = (int) area.getY();\r\n         int width = ((int) area.getWidth()) / displayCols;\r\n@@ -390,7 +392,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         Rectangle rect = new Rectangle();\r\n \r\n         for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {\r\n-            rect.setBounds(x + xoffset + (width * column), y + (height * row), \r\n+            rect.setBounds(x + xoffset + (width * column), y + (height * row),\r\n                     width, height);\r\n \r\n             String title = null;\r\n@@ -401,9 +403,9 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n                 title = this.dataset.getColumnKey(pieIndex).toString();\r\n             }\r\n             this.pieChart.setTitle(title);\r\n-            \r\n+\r\n             PieDataset piedataset = null;\r\n-            PieDataset dd = new CategoryToPieDataset(this.dataset, \r\n+            PieDataset dd = new CategoryToPieDataset(this.dataset,\r\n                     this.dataExtractOrder, pieIndex);\r\n             if (this.limit > 0.0) {\r\n                 piedataset = DatasetUtilities.createConsolidatedPieDataset(\r\n@@ -415,7 +417,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n             PiePlot piePlot = (PiePlot) this.pieChart.getPlot();\r\n             piePlot.setDataset(piedataset);\r\n             piePlot.setPieIndex(pieIndex);\r\n-            \r\n+\r\n             // update the section colors to match the global colors...\r\n             for (int i = 0; i < piedataset.getItemCount(); i++) {\r\n                 Comparable key = piedataset.getKey(i);\r\n@@ -428,7 +430,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n                 }\r\n                 piePlot.setSectionPaint(key, p);\r\n             }\r\n-            \r\n+\r\n             ChartRenderingInfo subinfo = null;\r\n             if (info != null) {\r\n                 subinfo = new ChartRenderingInfo();\r\n@@ -439,7 +441,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n                         subinfo.getEntityCollection());\r\n                 info.addSubplotInfo(subinfo.getPlotInfo());\r\n             }\r\n-            \r\n+\r\n             ++column;\r\n             if (column == displayCols) {\r\n                 column = 0;\r\n@@ -452,26 +454,26 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n         }\r\n \r\n     }\r\n-    \r\n+\r\n     /**\r\n      * For each key in the dataset, check the <code>sectionPaints</code>\r\n-     * cache to see if a paint is associated with that key and, if not, \r\n+     * cache to see if a paint is associated with that key and, if not,\r\n      * fetch one from the drawing supplier.  These colors are cached so that\r\n      * the legend and all the subplots use consistent colors.\r\n      */\r\n     private void prefetchSectionPaints() {\r\n-        \r\n+\r\n         // pre-fetch the colors for each key...this is because the subplots\r\n         // may not display every key, but we need the coloring to be\r\n         // consistent...\r\n-        \r\n+\r\n         PiePlot piePlot = (PiePlot) getPieChart().getPlot();\r\n-        \r\n+\r\n         if (this.dataExtractOrder == TableOrder.BY_ROW) {\r\n             // column keys provide potential keys for individual pies\r\n             for (int c = 0; c < this.dataset.getColumnCount(); c++) {\r\n                 Comparable key = this.dataset.getColumnKey(c);\r\n-                Paint p = piePlot.getSectionPaint(key); \r\n+                Paint p = piePlot.getSectionPaint(key);\r\n                 if (p == null) {\r\n                     p = (Paint) this.sectionPaints.get(key);\r\n                     if (p == null) {\r\n@@ -482,10 +484,10 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n             }\r\n         }\r\n         else {\r\n-            // row keys provide potential keys for individual pies            \r\n+            // row keys provide potential keys for individual pies\r\n             for (int r = 0; r < this.dataset.getRowCount(); r++) {\r\n                 Comparable key = this.dataset.getRowKey(r);\r\n-                Paint p = piePlot.getSectionPaint(key); \r\n+                Paint p = piePlot.getSectionPaint(key);\r\n                 if (p == null) {\r\n                     p = (Paint) this.sectionPaints.get(key);\r\n                     if (p == null) {\r\n@@ -495,9 +497,9 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n                 this.sectionPaints.put(key, p);\r\n             }\r\n         }\r\n-        \r\n+\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Returns a collection of legend items for the pie chart.\r\n      *\r\n@@ -506,10 +508,10 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n     public LegendItemCollection getLegendItems() {\r\n \r\n         LegendItemCollection result = new LegendItemCollection();\r\n-        \r\n+\r\n         if (this.dataset != null) {\r\n             List keys = null;\r\n-      \r\n+\r\n             prefetchSectionPaints();\r\n             if (this.dataExtractOrder == TableOrder.BY_ROW) {\r\n                 keys = this.dataset.getColumnKeys();\r\n@@ -526,8 +528,8 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n                     String label = key.toString();\r\n                     String description = label;\r\n                     Paint paint = (Paint) this.sectionPaints.get(key);\r\n-                    LegendItem item = new LegendItem(label, description, \r\n-                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE, \r\n+                    LegendItem item = new LegendItem(label, description,\r\n+                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\r\n                             paint, Plot.DEFAULT_OUTLINE_STROKE, paint);\r\n                     item.setDataset(getDataset());\r\n                     result.add(item);\r\n@@ -535,56 +537,56 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n                 }\r\n             }\r\n             if (this.limit > 0.0) {\r\n-                result.add(new LegendItem(this.aggregatedItemsKey.toString(), \r\n-                        this.aggregatedItemsKey.toString(), null, null, \r\n-                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE, \r\n+                result.add(new LegendItem(this.aggregatedItemsKey.toString(),\r\n+                        this.aggregatedItemsKey.toString(), null, null,\r\n+                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\r\n                         this.aggregatedItemsPaint,\r\n-                        Plot.DEFAULT_OUTLINE_STROKE, \r\n+                        Plot.DEFAULT_OUTLINE_STROKE,\r\n                         this.aggregatedItemsPaint));\r\n             }\r\n         }\r\n         return result;\r\n     }\r\n-    \r\n+\r\n     /**\r\n-     * Tests this plot for equality with an arbitrary object.  Note that the \r\n+     * Tests this plot for equality with an arbitrary object.  Note that the\r\n      * plot's dataset is not considered in the equality test.\r\n-     * \r\n+     *\r\n      * @param obj  the object (<code>null</code> permitted).\r\n-     * \r\n+     *\r\n      * @return <code>true</code> if this plot is equal to <code>obj</code>, and\r\n      *     <code>false</code> otherwise.\r\n      */\r\n     public boolean equals(Object obj) {\r\n         if (obj == this) {\r\n-            return true;   \r\n+            return true;\r\n         }\r\n         if (!(obj instanceof MultiplePiePlot)) {\r\n-            return false;   \r\n+            return false;\r\n         }\r\n         MultiplePiePlot that = (MultiplePiePlot) obj;\r\n         if (this.dataExtractOrder != that.dataExtractOrder) {\r\n-            return false;   \r\n+            return false;\r\n         }\r\n         if (this.limit != that.limit) {\r\n-            return false;   \r\n+            return false;\r\n         }\r\n         if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {\r\n             return false;\r\n         }\r\n-        if (!PaintUtilities.equal(this.aggregatedItemsPaint, \r\n+        if (!PaintUtilities.equal(this.aggregatedItemsPaint,\r\n                 that.aggregatedItemsPaint)) {\r\n             return false;\r\n         }\r\n         if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {\r\n-            return false;   \r\n+            return false;\r\n         }\r\n         if (!super.equals(obj)) {\r\n-            return false;   \r\n+            return false;\r\n         }\r\n         return true;\r\n     }\r\n-    \r\n+\r\n     /**\r\n      * Provides serialization support.\r\n      *\r\n@@ -605,12 +607,12 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      * @throws IOException  if there is an I/O error.\r\n      * @throws ClassNotFoundException  if there is a classpath problem.\r\n      */\r\n-    private void readObject(ObjectInputStream stream) \r\n+    private void readObject(ObjectInputStream stream)\r\n         throws IOException, ClassNotFoundException {\r\n         stream.defaultReadObject();\r\n         this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);\r\n         this.sectionPaints = new HashMap();\r\n     }\r\n \r\n-    \r\n+\r\n }\r\n"
    },
    "function": {
      "function_name": "MultiplePiePlot",
      "function_parent": "MultiplePiePlot::MultiplePiePlot( CategoryDataset dataset)",
      "function_before_start_line": 140,
      "function_before_end_line": 155,
      "function_after_start_line": 142,
      "function_after_end_line": 157,
      "function_before_token_count": 123,
      "function_after_token_count": 122,
      "function_before": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n    PiePlot piePlot = new PiePlot(null);\n    this.pieChart = new JFreeChart(piePlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle seriesTitle = new TextTitle(\"Series Title\", \n            new Font(\"SansSerif\", Font.BOLD, 12));\n    seriesTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(seriesTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}",
      "function_after": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n    PiePlot piePlot = new PiePlot(null);\n    this.pieChart = new JFreeChart(piePlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle seriesTitle = new TextTitle(\"Series Title\",\n            new Font(\"SansSerif\", Font.BOLD, 12));\n    seriesTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(seriesTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}"
    },
    "file": {
      "file_name": "MultiplePiePlot.java",
      "file_path": "source/org/jfree/chart/plot/MultiplePiePlot.java",
      "file_nloc": 329,
      "file_complexity": 63,
      "file_token_count": 2161,
      "file_before": "",
      "file_after": ""
    }
  },
  "6": {
    "id": 6,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 13,
    "buggy_line_location": 452,
    "buggy_line_content": "new Range(0.0, constraint.getWidth() - w[2]),",
    "fixed_line_location": 454,
    "fixed_line_content": "new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),",
    "bug_description_link": "",
    "in_function": true,
    "commit": {
      "commit_id": "7d10866f34bb6bd1eef8a1ab50f210adf0fd52cc",
      "commit_message": "2008-04-08  David Gilbert  <david.gilbert@object-refinery.com>\n\n    * source/org/jfree/chart/block/BorderArrangement.java\n    (arrangeFF): Check for negative width remaining.",
      "commit_author": "David Gilbert",
      "commit_parent": "22a16d1029dddc1735c8f7e97e061b1abf8c92d8",
      "commit_date": "2008-04-08 19:10:33",
      "commit_file_diff": "@@ -2,7 +2,7 @@\n  * JFreeChart : a free chart library for the Java(tm) platform\r\n  * ===========================================================\r\n  *\r\n- * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\r\n+ * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\r\n  *\r\n  * Project Info:  http://www.jfree.org/jfreechart/index.html\r\n  *\r\n@@ -27,7 +27,7 @@\n  * ----------------------\r\n  * BorderArrangement.java\r\n  * ----------------------\r\n- * (C) Copyright 2004-2007, by Object Refinery Limited.\r\n+ * (C) Copyright 2004-2008, by Object Refinery Limited.\r\n  *\r\n  * Original Author:  David Gilbert (for Object Refinery Limited);\r\n  * Contributor(s):   -;\r\n@@ -39,6 +39,8 @@\n  * 24-Feb-2005 : Improved arrangeRR() method (DG);\r\n  * 03-May-2005 : Implemented Serializable and added equals() method (DG);\r\n  * 13-May-2005 : Fixed bugs in the arrange() method (DG);\r\n+ * 08-Apr-2008 : Fixed bug in arrangeFF() method where width is too small for\r\n+ *               left and right blocks (DG);\r\n  * \r\n  */\r\n \r\n@@ -449,7 +451,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\r\n         if (this.rightBlock != null) {\r\n             RectangleConstraint c4 = new RectangleConstraint(0.0, \r\n-            \t\tnew Range(0.0, constraint.getWidth() - w[2]), \r\n+            \t\tnew Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), \r\n             \t\tLengthConstraintType.RANGE, h[2], null, \r\n             \t\tLengthConstraintType.FIXED);\r\n             Size2D size = this.rightBlock.arrange(g2, c4);\r\n"
    },
    "function": {
      "function_name": "arrangeFF",
      "function_parent": "BorderArrangement::arrangeFF( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint)",
      "function_before_start_line": 419,
      "function_before_end_line": 486,
      "function_after_start_line": 421,
      "function_after_end_line": 488,
      "function_before_token_count": 696,
      "function_after_token_count": 705,
      "function_before": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null, \n        \t\tLengthConstraintType.FIXED, 0.0, \n        \t\tnew Range(0.0, constraint.getHeight()), \n        \t\tLengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null, \n        \t\tLengthConstraintType.FIXED, 0.0, new Range(0.0, \n        \t\tconstraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0, \n        \t\tnew Range(0.0, constraint.getWidth()), \n        \t\tLengthConstraintType.RANGE, h[2], null, \n        \t\tLengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;            \n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, \n        \t\tnew Range(0.0, constraint.getWidth() - w[2]), \n        \t\tLengthConstraintType.RANGE, h[2], null, \n        \t\tLengthConstraintType.FIXED);\n        Size2D size = this.rightBlock.arrange(g2, c4);\n        w[3] = size.width;            \n    }\n    h[4] = h[2];\n    w[4] = constraint.getWidth() - w[3] - w[2];\n    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n    if (this.centerBlock != null) {\n        this.centerBlock.arrange(g2, c5);   \n    }\n\n    if (this.topBlock != null) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], \n        \t\th[0]));\n    }\n    if (this.bottomBlock != null) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n        \t\tw[1], h[1]));\n    }\n    if (this.leftBlock != null) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], \n        \t\th[2]));\n    }\n    if (this.rightBlock != null) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n        \t\tw[3], h[3]));\n    }\n    if (this.centerBlock != null) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n        \t\th[4]));\n    }\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\n}",
      "function_after": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null, \n        \t\tLengthConstraintType.FIXED, 0.0, \n        \t\tnew Range(0.0, constraint.getHeight()), \n        \t\tLengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null, \n        \t\tLengthConstraintType.FIXED, 0.0, new Range(0.0, \n        \t\tconstraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0, \n        \t\tnew Range(0.0, constraint.getWidth()), \n        \t\tLengthConstraintType.RANGE, h[2], null, \n        \t\tLengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;            \n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0, \n        \t\tnew Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), \n        \t\tLengthConstraintType.RANGE, h[2], null, \n        \t\tLengthConstraintType.FIXED);\n        Size2D size = this.rightBlock.arrange(g2, c4);\n        w[3] = size.width;            \n    }\n    h[4] = h[2];\n    w[4] = constraint.getWidth() - w[3] - w[2];\n    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n    if (this.centerBlock != null) {\n        this.centerBlock.arrange(g2, c5);   \n    }\n\n    if (this.topBlock != null) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], \n        \t\th[0]));\n    }\n    if (this.bottomBlock != null) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n        \t\tw[1], h[1]));\n    }\n    if (this.leftBlock != null) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], \n        \t\th[2]));\n    }\n    if (this.rightBlock != null) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n        \t\tw[3], h[3]));\n    }\n    if (this.centerBlock != null) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n        \t\th[4]));\n    }\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\n}"
    },
    "file": {
      "file_name": "BorderArrangement.java",
      "file_path": "source/org/jfree/chart/block/BorderArrangement.java",
      "file_nloc": 369,
      "file_complexity": 70,
      "file_token_count": 3297,
      "file_before": "",
      "file_after": ""
    }
  },
  "7": {
    "id": 7,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 20,
    "buggy_line_location": 93,
    "buggy_line_content": "super(paint, stroke, paint, stroke, alpha);",
    "fixed_line_location": 95,
    "fixed_line_content": "super(paint, stroke, outlinePaint, outlineStroke, alpha);",
    "bug_description_link": "",
    "in_function": true,
    "commit": {
      "commit_id": "0729f818d543b46669c2c586af381cada81f99ad",
      "commit_message": "2007-10-08\tDavid Gilbert  <david.gilbert@object-refinery.com>\n\n\t* source/org/jfree/chart/plot/ValueMarker.java\n\t(ValueMarker(double, Paint, Stroke, Paint, Stroke, float)): Fixed call\n\tto super,\n\t* tests/org/jfree/chart/plot/junit/ValueMarkerTests.java\n\t(test1808376): New test method.",
      "commit_author": "David Gilbert",
      "commit_parent": "38a289435530ac21325a22804a8b5bfe2fb2e1bb",
      "commit_date": "2007-10-08 09:29:58",
      "commit_file_diff": "@@ -38,6 +38,8 @@\n  * 16-Feb-2005 : Added new constructor (DG);\r\n  * ------------- JFREECHART 1.0.x ---------------------------------------------\r\n  * 05-Sep-2006 : Added setValue() method (DG);\r\n+ * 08-Oct-2007 : Fixed bug 1808376, constructor calling super with incorrect\r\n+ *               values (DG);\r\n  * \r\n  */\r\n \r\n@@ -86,11 +88,11 @@ public class ValueMarker extends Marker {\n      * @param stroke  the stroke (<code>null</code> not permitted).\r\n      * @param outlinePaint  the outline paint (<code>null</code> permitted).\r\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\r\n-     * @param alpha  the alpha transparency.\r\n+     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\r\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n-        super(paint, stroke, paint, stroke, alpha);\r\n+        super(paint, stroke, outlinePaint, outlineStroke, alpha);\r\n         this.value = value;\r\n     }\r\n     \r\n@@ -98,6 +100,8 @@ public class ValueMarker extends Marker {\n      * Returns the value.\r\n      *\r\n      * @return The value.\r\n+     * \r\n+     * @see #setValue(double)\r\n      */\r\n     public double getValue() {\r\n         return this.value;\r\n@@ -109,6 +113,8 @@ public class ValueMarker extends Marker {\n      * \r\n      * @param value  the value.\r\n      * \r\n+     * @see #getValue()\r\n+     * \r\n      * @since 1.0.3\r\n      */\r\n     public void setValue(double value) { \r\n"
    },
    "function": {
      "function_name": "ValueMarker",
      "function_parent": "ValueMarker::ValueMarker( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha)",
      "function_before_start_line": 91,
      "function_before_end_line": 95,
      "function_after_start_line": 93,
      "function_after_end_line": 97,
      "function_before_token_count": 41,
      "function_after_token_count": 41,
      "function_before": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    super(paint, stroke, paint, stroke, alpha);\n    this.value = value;\n}",
      "function_after": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    super(paint, stroke, outlinePaint, outlineStroke, alpha);\n    this.value = value;\n}"
    },
    "file": {
      "file_name": "ValueMarker.java",
      "file_path": "source/org/jfree/chart/plot/ValueMarker.java",
      "file_nloc": 42,
      "file_complexity": 10,
      "file_token_count": 247,
      "file_before": "",
      "file_after": ""
    }
  },
  "8": {
    "id": 8,
    "project_name": "jfreechart",
    "project_url": "https://github.com/jfree/jfreechart.git",
    "defects4j_id": 24,
    "buggy_line_location": 116,
    "buggy_line_content": "int g = (int) ((value - this.lowerBound) / (this.upperBound",
    "fixed_line_location": 125,
    "fixed_line_content": "int g = (int) ((v - this.lowerBound) / (this.upperBound",
    "bug_description_link": "",
    "in_function": true,
    "commit": {
      "commit_id": "fdb1ad7a3bf7e9a6390b9de9a71a9ced0147c09d",
      "commit_message": "2007-09-26  David Gilbert  <david.gilbert@object-refinery.com>\n\n\t* source/org/jfree/chart/renderer/GrayPaintScale.java\n\t(getPaint): Use constrained value to calculate gray scale value,\n\t* tests/org/jfree/chart/renderer/junit/GrayPaintScaleTests.java\n\t(testConstructor): New test method,\n\t(testGetPaint): Likewise.",
      "commit_author": "David Gilbert",
      "commit_parent": "91f7c842282774be49a5f128469878879a2ae3ae",
      "commit_date": "2007-09-26 13:55:12",
      "commit_file_diff": "@@ -38,6 +38,7 @@\n  * -------\r\n  * 05-Jul-2006 : Version 1 (DG);\r\n  * 31-Jan-2007 : Renamed min and max to lowerBound and upperBound (DG);\r\n+ * 26-Sep-2007 : Fixed bug 1767315, problem in getPaint() method (DG);\r\n  * \r\n  */\r\n \r\n@@ -75,6 +76,9 @@ public class GrayPaintScale\n      * \r\n      * @param lowerBound  the lower bound.\r\n      * @param upperBound  the upper bound.\r\n+     * \r\n+     * @throws IllegalArgumentException if <code>lowerBound</code> is not\r\n+     *       less than <code>upperBound</code>.\r\n      */\r\n     public GrayPaintScale(double lowerBound, double upperBound) {\r\n         if (lowerBound >= upperBound) {\r\n@@ -89,6 +93,8 @@ public class GrayPaintScale\n      * Returns the lower bound.\r\n      * \r\n      * @return The lower bound.\r\n+     * \r\n+     * @see #getUpperBound()\r\n      */\r\n     public double getLowerBound() {\r\n         return this.lowerBound;\r\n@@ -98,6 +104,8 @@ public class GrayPaintScale\n      * Returns the upper bound.\r\n      * \r\n      * @return The upper bound.\r\n+     * \r\n+     * @see #getLowerBound()\r\n      */\r\n     public double getUpperBound() {\r\n         return this.upperBound;\r\n@@ -106,14 +114,15 @@ public class GrayPaintScale\n     /**\r\n      * Returns a paint for the specified value.\r\n      * \r\n-     * @param value  the value.\r\n+     * @param value  the value (must be within the range specified by the\r\n+     *         lower and upper bounds for the scale).\r\n      * \r\n      * @return A paint for the specified value.\r\n      */\r\n     public Paint getPaint(double value) {\r\n         double v = Math.max(value, this.lowerBound);\r\n         v = Math.min(v, this.upperBound);\r\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \r\n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \r\n                 - this.lowerBound) * 255.0);\r\n         return new Color(g, g, g);\r\n     }\r\n"
    },
    "function": {
      "function_name": "getPaint",
      "function_parent": "GrayPaintScale::getPaint( double value)",
      "function_before_start_line": 113,
      "function_before_end_line": 119,
      "function_after_start_line": 122,
      "function_after_end_line": 128,
      "function_before_token_count": 75,
      "function_after_token_count": 75,
      "function_before": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound \n            - this.lowerBound) * 255.0);\n    return new Color(g, g, g);\n}",
      "function_after": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound \n            - this.lowerBound) * 255.0);\n    return new Color(g, g, g);\n}"
    },
    "file": {
      "file_name": "GrayPaintScale.java",
      "file_path": "source/org/jfree/chart/renderer/GrayPaintScale.java",
      "file_nloc": 53,
      "file_complexity": 12,
      "file_token_count": 305,
      "file_before": "",
      "file_after": ""
    }
  },
  "9": {
    "id": 9,
    "project_name": "commons-cli",
    "project_url": "https://github.com/apache/commons-cli.git",
    "defects4j_id": 8,
    "buggy_line_location": 812,
    "buggy_line_content": "pos = findWrapPos(text, width, nextLineTabStop);",
    "fixed_line_location": 812,
    "fixed_line_content": "pos = findWrapPos(text, width, 0);",
    "bug_description_link": "https://issues.apache.org/jira/browse/CLI-151",
    "in_function": true,
    "commit": {
      "commit_id": "4f407378c93b9e2a8e24c855e8bed5eb12bf7a06",
      "commit_message": "Applying J. Lewis Muir's patch from CLI-151 fixing HelpFormatter so it wraps properly on multiple lines\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/cli/branches/cli-1.x@654428 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Henri Yandell",
      "commit_parent": "6a6bb48840aa0043200a5d9f6fffea47aea1a8db",
      "commit_date": "2008-05-08 06:40:58",
      "commit_file_diff": "@@ -809,7 +809,7 @@ public class HelpFormatter {\n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+            pos = findWrapPos(text, width, 0);\n \n             if (pos == -1)\n             {\n"
    },
    "function": {
      "function_name": "renderWrappedText",
      "function_parent": "HelpFormatter::renderWrappedText( StringBuffer sb , int width , int nextLineTabStop , String text)",
      "function_before_start_line": 792,
      "function_before_end_line": 823,
      "function_after_start_line": 792,
      "function_after_end_line": 823,
      "function_before_token_count": 154,
      "function_after_token_count": 154,
      "function_before": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "function_after": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}"
    },
    "file": {
      "file_name": "HelpFormatter.java",
      "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "file_nloc": 412,
      "file_complexity": 90,
      "file_token_count": 2476,
      "file_before": "",
      "file_after": ""
    }
  },
  "10": {
    "id": 10,
    "project_name": "commons-cli",
    "project_url": "https://github.com/apache/commons-cli.git",
    "defects4j_id": 11,
    "buggy_line_location": 632,
    "buggy_line_content": "if (option.hasArg() && (option.getArgName() != null))",
    "fixed_line_location": 632,
    "fixed_line_content": "if (option.hasArg() && option.hasArgName())",
    "bug_description_link": "https://issues.apache.org/jira/browse/CLI-1",
    "in_function": true,
    "commit": {
      "commit_id": "d36adebd3547279b709960c902c3fb7b89a9a4ef",
      "commit_message": "Added a formatter test for options with a null or empty named argument\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/cli/branches/cli-1.x@661634 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Emmanuel Bourg",
      "commit_parent": "33abc034037e3ef5d85d1b03010122617c386827",
      "commit_date": "2008-05-30 10:22:49",
      "commit_file_diff": "@@ -629,7 +629,7 @@ public class HelpFormatter {\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+        if (option.hasArg() && option.hasArgName())\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n"
    },
    "function": {
      "function_name": "appendOption",
      "function_parent": "HelpFormatter::appendOption( final StringBuffer buff , final Option option , final boolean required)",
      "function_before_start_line": 613,
      "function_before_end_line": 642,
      "function_after_start_line": 613,
      "function_after_end_line": 642,
      "function_before_token_count": 132,
      "function_after_token_count": 128,
      "function_before": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n\n    // if the Option has a value\n    if (option.hasArg() && (option.getArgName() != null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n\n    // if the Option is not a required option\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
      "function_after": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n\n    // if the Option has a value\n    if (option.hasArg() && option.hasArgName())\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n\n    // if the Option is not a required option\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}"
    },
    "file": {
      "file_name": "HelpFormatter.java",
      "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "file_nloc": 428,
      "file_complexity": 93,
      "file_token_count": 2524,
      "file_before": "",
      "file_after": ""
    }
  },
  "11": {
    "id": 11,
    "project_name": "commons-cli",
    "project_url": "https://github.com/apache/commons-cli.git",
    "defects4j_id": 25,
    "buggy_line_location": 825,
    "buggy_line_content": "nextLineTabStop = width - 1;",
    "fixed_line_location": 825,
    "fixed_line_content": "nextLineTabStop = 1;",
    "bug_description_link": "https://issues.apache.org/jira/browse/CLI-162",
    "in_function": true,
    "commit": {
      "commit_id": "6a585453d385449dc23d90479488f92f02cd6b83",
      "commit_message": "Adjusting - best is to switch to an indent of 1 than do silly things like having every line have 1 character. CLI-162\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/cli/branches/cli-1.x@748463 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Henri Yandell",
      "commit_parent": "02dd7c20646bf67dcfb6f7da6beeb7cdffc6ac22",
      "commit_date": "2009-02-27 09:38:10",
      "commit_file_diff": "@@ -822,7 +822,7 @@ public class HelpFormatter\n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+            nextLineTabStop = 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n"
    },
    "function": {
      "function_name": "renderWrappedText",
      "function_parent": "HelpFormatter::renderWrappedText( StringBuffer sb , int width , int nextLineTabStop , String text)",
      "function_before_start_line": 809,
      "function_before_end_line": 851,
      "function_after_start_line": 809,
      "function_after_end_line": 851,
      "function_before_token_count": 194,
      "function_after_token_count": 192,
      "function_before": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    if (nextLineTabStop >= width)\n    {\n        // stops infinite loop happening\n        nextLineTabStop = width - 1;\n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "function_after": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    if (nextLineTabStop >= width)\n    {\n        // stops infinite loop happening\n        nextLineTabStop = 1;\n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(text);\n\n            return sb;\n        }\n\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}"
    },
    "file": {
      "file_name": "HelpFormatter.java",
      "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java",
      "file_nloc": 416,
      "file_complexity": 96,
      "file_token_count": 2541,
      "file_before": "",
      "file_after": ""
    }
  },
  "12": {
    "id": 12,
    "project_name": "commons-cli",
    "project_url": "https://github.com/apache/commons-cli.git",
    "defects4j_id": 28,
    "buggy_line_location": 290,
    "buggy_line_content": "break;",
    "fixed_line_location": 290,
    "fixed_line_content": "continue;",
    "bug_description_link": "https://issues.apache.org/jira/browse/CLI-201",
    "in_function": true,
    "commit": {
      "commit_id": "3433f467554985a6bd9bf530a4810376be6fe250",
      "commit_message": "The processing of the default options is no longer stopped by a flag with a false value (CLI-201)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/cli/trunk@955096 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Emmanuel Bourg",
      "commit_parent": "10b14afb9ff42a3f216296f526f65d001b545e3f",
      "commit_date": "2010-06-16 00:00:14",
      "commit_file_diff": "@@ -287,7 +287,7 @@ public abstract class Parser implements CommandLineParser\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+                    continue;\n                 }\n \n                 cmd.addOption(opt);\n"
    },
    "function": {
      "function_name": "processProperties",
      "function_parent": "Parser::processProperties( Properties properties)",
      "function_before_start_line": 252,
      "function_before_end_line": 296,
      "function_after_start_line": 252,
      "function_after_end_line": 296,
      "function_before_token_count": 171,
      "function_after_token_count": 171,
      "function_before": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n\n            // get the value from the properties instance\n            String value = properties.getProperty(option);\n\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                        // if we cannot add the value don't worry about it\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                // if the value is not yes, true or 1 then don't add the\n                // option to the CommandLine\n                break;\n            }\n\n            cmd.addOption(opt);\n        }\n    }\n}",
      "function_after": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n\n            // get the value from the properties instance\n            String value = properties.getProperty(option);\n\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                        // if we cannot add the value don't worry about it\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                // if the value is not yes, true or 1 then don't add the\n                // option to the CommandLine\n                continue;\n            }\n\n            cmd.addOption(opt);\n        }\n    }\n}"
    },
    "file": {
      "file_name": "Parser.java",
      "file_path": "src/java/org/apache/commons/cli/Parser.java",
      "file_nloc": 211,
      "file_complexity": 47,
      "file_token_count": 1091,
      "file_before": "",
      "file_after": ""
    }
  },
  "13": {
    "id": 13,
    "project_name": "commons-cli",
    "project_url": "https://github.com/apache/commons-cli.git",
    "defects4j_id": 40,
    "buggy_line_location": 103,
    "buggy_line_content": "return null;",
    "fixed_line_location": 103,
    "fixed_line_content": "throw new ParseException(\"Unable to handle the class: \" + clazz);",
    "bug_description_link": "https://issues.apache.org/jira/browse/CLI-282",
    "in_function": true,
    "commit": {
      "commit_id": "b0024d482050a08efc36c3cabee37c0af0e57a10",
      "commit_message": "[CLI-282] TypeHandler should throw ParseException for an unsupported\nclass.",
      "commit_author": "Alex Nordlund",
      "commit_parent": "e400f9256a2af526e9a06b9d5d2965965109a8db",
      "commit_date": "2018-02-26 10:23:40",
      "commit_file_diff": "@@ -100,7 +100,7 @@ public class TypeHandler\n         }\n         else\n         {\n-            return null;\n+            throw new ParseException(\"Unable to handle the class: \" + clazz);\n         }\n     }\n \n"
    },
    "function": {
      "function_name": "createValue",
      "function_parent": "TypeHandler::createValue( final String str , final Class<T> clazz)",
      "function_before_start_line": 63,
      "function_before_end_line": 105,
      "function_after_start_line": 63,
      "function_after_end_line": 105,
      "function_before_token_count": 199,
      "function_after_token_count": 205,
      "function_before": "public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}",
      "function_after": "public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        throw new ParseException(\"Unable to handle the class: \" + clazz);\n    }\n}"
    },
    "file": {
      "file_name": "TypeHandler.java",
      "file_path": "src/main/java/org/apache/commons/cli/TypeHandler.java",
      "file_nloc": 138,
      "file_complexity": 26,
      "file_token_count": 625,
      "file_before": "",
      "file_after": ""
    }
  },
  "14": {
    "id": 14,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 10,
    "buggy_line_location": 1396,
    "buggy_line_content": "return valueCheck(n, MAY_BE_STRING_PREDICATE);",
    "fixed_line_location": 1417,
    "fixed_line_content": "return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-821.json",
    "in_function": true,
    "commit": {
      "commit_id": "0884a4cbef1c82153ef306477a12af0480385a35",
      "commit_message": "Properly determine if any possible results may be a string.\nFixes issue 821\n\nR=nicksantos\nDELTA=36  (27 added, 0 deleted, 9 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=5531\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2206 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "johnlenz@google.com",
      "commit_parent": "f681fd8045bfa4a41f3a66c942b97fb04335b7cc",
      "commit_date": "2012-09-21 17:50:43",
      "commit_file_diff": "@@ -1258,18 +1258,39 @@ public final class NodeUtil {\n    * Apply the supplied predicate against\n    * all possible result Nodes of the expression.\n    */\n-  static boolean valueCheck(Node n, Predicate<Node> p) {\n+  static boolean allResultsMatch(Node n, Predicate<Node> p) {\n     switch (n.getType()) {\n       case Token.ASSIGN:\n       case Token.COMMA:\n-        return valueCheck(n.getLastChild(), p);\n+        return allResultsMatch(n.getLastChild(), p);\n       case Token.AND:\n       case Token.OR:\n-        return valueCheck(n.getFirstChild(), p)\n-            && valueCheck(n.getLastChild(), p);\n+        return allResultsMatch(n.getFirstChild(), p)\n+            && allResultsMatch(n.getLastChild(), p);\n       case Token.HOOK:\n-        return valueCheck(n.getFirstChild().getNext(), p)\n-            && valueCheck(n.getLastChild(), p);\n+        return allResultsMatch(n.getFirstChild().getNext(), p)\n+            && allResultsMatch(n.getLastChild(), p);\n+      default:\n+        return p.apply(n);\n+    }\n+  }\n+\n+  /**\n+   * Apply the supplied predicate against\n+   * all possible result Nodes of the expression.\n+   */\n+  static boolean anyResultsMatch(Node n, Predicate<Node> p) {\n+    switch (n.getType()) {\n+      case Token.ASSIGN:\n+      case Token.COMMA:\n+        return anyResultsMatch(n.getLastChild(), p);\n+      case Token.AND:\n+      case Token.OR:\n+        return anyResultsMatch(n.getFirstChild(), p)\n+            || anyResultsMatch(n.getLastChild(), p);\n+      case Token.HOOK:\n+        return anyResultsMatch(n.getFirstChild().getNext(), p)\n+            || anyResultsMatch(n.getLastChild(), p);\n       default:\n         return p.apply(n);\n     }\n@@ -1289,7 +1310,7 @@ public final class NodeUtil {\n    * Returns true if the result of node evaluation is always a number\n    */\n   static boolean isNumericResult(Node n) {\n-    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);\n+    return allResultsMatch(n, NUMBERIC_RESULT_PREDICATE);\n   }\n \n   static boolean isNumericResultHelper(Node n) {\n@@ -1342,7 +1363,7 @@ public final class NodeUtil {\n    * @return Whether the result of node evaluation is always a boolean\n    */\n   static boolean isBooleanResult(Node n) {\n-    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);\n+    return allResultsMatch(n, BOOLEAN_RESULT_PREDICATE);\n   }\n \n   static boolean isBooleanResultHelper(Node n) {\n@@ -1393,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return valueCheck(n, MAY_BE_STRING_PREDICATE);\n+      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n"
    },
    "function": {
      "function_name": "mayBeString",
      "function_parent": "NodeUtil::mayBeString( Node n , boolean recurse)",
      "function_before_start_line": 1394,
      "function_before_end_line": 1400,
      "function_after_start_line": 1415,
      "function_after_end_line": 1421,
      "function_before_token_count": 33,
      "function_after_token_count": 33,
      "function_before": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return valueCheck(n, MAY_BE_STRING_PREDICATE);\n  } else {\n    return mayBeStringHelper(n);\n  }\n}",
      "function_after": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n  } else {\n    return mayBeStringHelper(n);\n  }\n}"
    },
    "file": {
      "file_name": "NodeUtil.java",
      "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "file_nloc": 2089,
      "file_complexity": 946,
      "file_token_count": 12838,
      "file_before": "",
      "file_after": ""
    }
  },
  "15": {
    "id": 15,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 14,
    "buggy_line_location": 767,
    "buggy_line_content": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);",
    "fixed_line_location": 767,
    "fixed_line_content": "cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-779.json",
    "in_function": true,
    "commit": {
      "commit_id": "4b15b25f400335b6e2820cb690430324748372f9",
      "commit_message": "when handling a finally block like so,\ntry { alert(1) } finally { }\nThere needs to be 2 edges: an unconditional edge to the statement\nafter the 'finally', and an edge for the code path that continues\nhandling the exception. Label the second edge with ON_EX instead of UNCOND.\nFixes issue 779\n\nR=acleung\nDELTA=18  (14 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=5214\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2101 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "b7c2861bf45b358b26ebc5ee1be9b6ce96bec78a",
      "commit_date": "2012-07-24 21:04:32",
      "commit_file_diff": "@@ -764,7 +764,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n"
    },
    "function": {
      "function_name": "computeFollowNode",
      "function_parent": "ControlFlowAnalysis::computeFollowNode( Node fromNode , Node node , ControlFlowAnalysis cfa)",
      "function_before_start_line": 692,
      "function_before_end_line": 789,
      "function_after_start_line": 692,
      "function_after_end_line": 789,
      "function_before_token_count": 447,
      "function_after_token_count": 447,
      "function_before": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  /*\n   * This is the case where:\n   *\n   * 1. Parent is null implies that we are transferring control to the end of\n   * the script.\n   *\n   * 2. Parent is a function implies that we are transferring control back to\n   * the caller of the function.\n   *\n   * 3. If the node is a return statement, we should also transfer control\n   * back to the caller of the function.\n   *\n   * 4. If the node is root then we have reached the end of what we have been\n   * asked to traverse.\n   *\n   * In all cases we should transfer control to a \"symbolic return\" node.\n   * This will make life easier for DFAs.\n   */\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n\n  // If we are just before a IF/WHILE/DO/FOR:\n  switch (parent.getType()) {\n    // The follow() of any of the path from IF would be what follows IF.\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      // After the body of a CASE, the control goes to the body of the next\n      // case, without having to go to the case condition.\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      // If we are coming out of the TRY block...\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(parent.getLastChild());\n        } else { // and have no FINALLY.\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // CATCH block.\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // If we are coming out of the FINALLY block...\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n\n  // Now that we are done with the special cases follow should be its\n  // immediate sibling, unless its sibling is a function\n  Node nextSibling = node.getNext();\n\n  // Skip function declarations because control doesn't get pass into it.\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    // If there are no more siblings, control is transferred up the AST.\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
      "function_after": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  /*\n   * This is the case where:\n   *\n   * 1. Parent is null implies that we are transferring control to the end of\n   * the script.\n   *\n   * 2. Parent is a function implies that we are transferring control back to\n   * the caller of the function.\n   *\n   * 3. If the node is a return statement, we should also transfer control\n   * back to the caller of the function.\n   *\n   * 4. If the node is root then we have reached the end of what we have been\n   * asked to traverse.\n   *\n   * In all cases we should transfer control to a \"symbolic return\" node.\n   * This will make life easier for DFAs.\n   */\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n\n  // If we are just before a IF/WHILE/DO/FOR:\n  switch (parent.getType()) {\n    // The follow() of any of the path from IF would be what follows IF.\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      // After the body of a CASE, the control goes to the body of the next\n      // case, without having to go to the case condition.\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      // If we are coming out of the TRY block...\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(parent.getLastChild());\n        } else { // and have no FINALLY.\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // CATCH block.\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // If we are coming out of the FINALLY block...\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n\n  // Now that we are done with the special cases follow should be its\n  // immediate sibling, unless its sibling is a function\n  Node nextSibling = node.getNext();\n\n  // Skip function declarations because control doesn't get pass into it.\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    // If there are no more siblings, control is transferred up the AST.\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}"
    },
    "file": {
      "file_name": "ControlFlowAnalysis.java",
      "file_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
      "file_nloc": 704,
      "file_complexity": 214,
      "file_token_count": 4666,
      "file_before": "",
      "file_after": ""
    }
  },
  "16": {
    "id": 16,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 18,
    "buggy_line_location": 1288,
    "buggy_line_content": "if (options.dependencyOptions.needsManagement() && options.closurePass) {",
    "fixed_line_location": 1288,
    "fixed_line_content": "if (options.dependencyOptions.needsManagement()) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-768.json",
    "in_function": true,
    "commit": {
      "commit_id": "ea119a2d06328852763f9ee447c3bf74fa1f83dc",
      "commit_message": "Allow dependency sorting even when closure pass is off.\nFixes issue 768\n\nR=johnlenz\nDELTA=23  (21 added, 1 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=5100\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2073 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "686146c4de7d2bd985156ae15175365633dd0f94",
      "commit_date": "2012-07-03 04:44:08",
      "commit_file_diff": "@@ -1285,8 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() &&\n-          options.closurePass) {\n+      if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n"
    },
    "function": {
      "function_name": "parseInputs",
      "function_parent": "Compiler::parseInputs()",
      "function_before_start_line": 1240,
      "function_before_end_line": 1363,
      "function_after_start_line": 1240,
      "function_after_end_line": 1362,
      "function_before_token_count": 491,
      "function_after_token_count": 487,
      "function_before": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main JS sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    hoistExterns(externsRoot);\n\n    // Check if the sources need to be re-ordered.\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    hoistNoCompileFiles();\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
      "function_after": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main JS sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    hoistExterns(externsRoot);\n\n    // Check if the sources need to be re-ordered.\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement()) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    hoistNoCompileFiles();\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}"
    },
    "file": {
      "file_name": "Compiler.java",
      "file_path": "src/com/google/javascript/jscomp/Compiler.java",
      "file_nloc": 1677,
      "file_complexity": 367,
      "file_token_count": 10077,
      "file_before": "",
      "file_after": ""
    }
  },
  "17": {
    "id": 17,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 38,
    "buggy_line_location": 244,
    "buggy_line_content": "if (x < 0 && prev == '-') {",
    "fixed_line_location": 245,
    "fixed_line_content": "if ((x < 0 || negativeZero) && prev == '-') {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-657.json",
    "in_function": true,
    "commit": {
      "commit_id": "8cf08115c6b252f8c6b54348a4089dccc45a01fb",
      "commit_message": "Negative zero is a special case, and needs to be handled\ndifferently to prevent it from getting confused with decrement\nfixes issue 657\n\nR=johnlenz\nDELTA=9  (7 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=4211\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1775 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "f067d0e1d84d631ec0c1e8e8cd812bbda1497958",
      "commit_date": "2012-02-13 16:07:52",
      "commit_file_diff": "@@ -241,11 +241,12 @@ abstract class CodeConsumer {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n-    if (x < 0 && prev == '-') {\n+    boolean negativeZero = isNegativeZero(x);\n+    if ((x < 0 || negativeZero) && prev == '-') {\n       add(\" \");\n     }\n \n-    if ((long) x == x && !isNegativeZero(x)) {\n+    if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;\n"
    },
    "function": {
      "function_name": "addNumber",
      "function_parent": "CodeConsumer::addNumber( double x)",
      "function_before_start_line": 240,
      "function_before_end_line": 266,
      "function_after_start_line": 240,
      "function_after_end_line": 267,
      "function_before_token_count": 161,
      "function_after_token_count": 170,
      "function_before": "void addNumber(double x) {\n  // This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char prev = getLastChar();\n  if (x < 0 && prev == '-') {\n    add(\" \");\n  }\n\n  if ((long) x == x && !isNegativeZero(x)) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}",
      "function_after": "void addNumber(double x) {\n  // This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if ((x < 0 || negativeZero) && prev == '-') {\n    add(\" \");\n  }\n\n  if ((long) x == x && !negativeZero) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}"
    },
    "file": {
      "file_name": "CodeConsumer.java",
      "file_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
      "file_nloc": 168,
      "file_complexity": 62,
      "file_token_count": 838,
      "file_before": "",
      "file_after": ""
    }
  },
  "18": {
    "id": 18,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 52,
    "buggy_line_location": 745,
    "buggy_line_content": "return len > 0;",
    "fixed_line_location": 745,
    "fixed_line_content": "return len > 0 && s.charAt(0) != '0';",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-569.json",
    "in_function": true,
    "commit": {
      "commit_id": "5909c3db59b16886917456ab950ef9661a7fe6b1",
      "commit_message": "numbers are hard!\nfixes issue 569\n\nR=johnlenz\nDELTA=15  (14 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=3410\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1491 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "d79072969c2f31860ea1f55e392a146c49bc2d0f",
      "commit_date": "2011-10-05 01:25:00",
      "commit_file_diff": "@@ -742,7 +742,7 @@ class CodeGenerator {\n         return false;\n       }\n     }\n-    return len > 0;\n+    return len > 0 && s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {\n"
    },
    "function": {
      "function_name": "isSimpleNumber",
      "function_parent": "CodeGenerator::isSimpleNumber( String s)",
      "function_before_start_line": 737,
      "function_before_end_line": 746,
      "function_after_start_line": 737,
      "function_after_end_line": 746,
      "function_before_token_count": 62,
      "function_after_token_count": 71,
      "function_before": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len > 0;\n}",
      "function_after": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len > 0 && s.charAt(0) != '0';\n}"
    },
    "file": {
      "file_name": "CodeGenerator.java",
      "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "file_nloc": 889,
      "file_complexity": 243,
      "file_token_count": 5745,
      "file_before": "",
      "file_after": ""
    }
  },
  "19": {
    "id": 19,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 62,
    "buggy_line_location": 96,
    "buggy_line_content": "&& 0 <= charno && charno < sourceExcerpt.length()) {",
    "fixed_line_location": 98,
    "fixed_line_content": "&& 0 <= charno && charno <= sourceExcerpt.length()) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-487.json",
    "in_function": true,
    "commit": {
      "commit_id": "b12d1d6489329c989b15635f6f7f06681b3f6582",
      "commit_message": "Automated g4 rollback.\n\n*** Reason for rollback ***\n\nFixes test case\n\n*** Original change description ***\n\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\n\n\n*** Original change description ***\n\nColumn-indicating caret can be in the end of a line. \nFixes issue 487.\n\nR=kennberg,nicksantos\nDELTA=24  (21 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=2423\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1220 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "zhuyi@google.com",
      "commit_parent": "1e07047234938543ea364f68ec0f29686dbc12f1",
      "commit_date": "2011-06-28 17:08:53",
      "commit_file_diff": "@@ -92,8 +92,10 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       int charno = error.getCharno();\n \n       // padding equal to the excerpt and arrow at the end\n+      // charno == sourceExpert.length() means something is missing\n+      // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n"
    },
    "function": {
      "function_name": "format",
      "function_parent": "LightweightMessageFormatter::format( JSError error , boolean warning)",
      "function_before_start_line": 66,
      "function_before_end_line": 109,
      "function_after_start_line": 66,
      "function_after_end_line": 111,
      "function_before_token_count": 266,
      "function_after_token_count": 266,
      "function_before": "private String format(JSError error, boolean warning) {\n  // extract source excerpt\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n\n  // formatting the message\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n\n    // padding equal to the excerpt and arrow at the end\n    if (excerpt.equals(LINE)\n        && 0 <= charno && charno < sourceExcerpt.length()) {\n      for (int i = 0; i < charno; i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (Character.isWhitespace(c)) {\n          b.append(c);\n        } else {\n          b.append(' ');\n        }\n      }\n      b.append(\"^\\n\");\n    }\n  }\n  return b.toString();\n}",
      "function_after": "private String format(JSError error, boolean warning) {\n  // extract source excerpt\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n\n  // formatting the message\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n\n    // padding equal to the excerpt and arrow at the end\n    // charno == sourceExpert.length() means something is missing\n    // at the end of the line\n    if (excerpt.equals(LINE)\n        && 0 <= charno && charno <= sourceExcerpt.length()) {\n      for (int i = 0; i < charno; i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (Character.isWhitespace(c)) {\n          b.append(c);\n        } else {\n          b.append(' ');\n        }\n      }\n      b.append(\"^\\n\");\n    }\n  }\n  return b.toString();\n}"
    },
    "file": {
      "file_name": "LightweightMessageFormatter.java",
      "file_path": "src/com/google/javascript/jscomp/LightweightMessageFormatter.java",
      "file_nloc": 117,
      "file_complexity": 25,
      "file_token_count": 781,
      "file_before": "",
      "file_after": ""
    }
  },
  "20": {
    "id": 20,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 65,
    "buggy_line_location": 1015,
    "buggy_line_content": "case '\\0': sb.append(\"\\\\0\"); break;",
    "fixed_line_location": 1015,
    "fixed_line_content": "case '\\0': sb.append(\"\\\\000\"); break;",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-486.json",
    "in_function": true,
    "commit": {
      "commit_id": "48aea0ff7d027507362007415963a4b662fb10a7",
      "commit_message": "Encode the null byte more correctly, because we have to be careful\nof look ahead.\nContributed by kosmo.zb\nFixes issue 486\n\nR=acleung\nDELTA=9  (4 added, 1 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=2280\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1179 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "9465f9139201814dc532adc33fe44a169a101937",
      "commit_date": "2011-06-15 00:09:44",
      "commit_file_diff": "@@ -1012,7 +1012,7 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+        case '\\0': sb.append(\"\\\\000\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n"
    },
    "function": {
      "function_name": "strEscape",
      "function_parent": "CodeGenerator::strEscape( String s , char quote , String doublequoteEscape , String singlequoteEscape , String backslashEscape , CharsetEncoder outputCharsetEncoder)",
      "function_before_start_line": 1005,
      "function_before_end_line": 1075,
      "function_after_start_line": 1005,
      "function_after_end_line": 1075,
      "function_before_token_count": 420,
      "function_after_token_count": 420,
      "function_before": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "function_after": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}"
    },
    "file": {
      "file_name": "CodeGenerator.java",
      "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "file_nloc": 889,
      "file_complexity": 242,
      "file_token_count": 5736,
      "file_before": "",
      "file_after": ""
    }
  },
  "21": {
    "id": 21,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 67,
    "buggy_line_location": 316,
    "buggy_line_content": ") {",
    "fixed_line_location": 318,
    "fixed_line_content": "&& assign.getParent().getType() == Token.EXPR_RESULT) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-459.json",
    "in_function": true,
    "commit": {
      "commit_id": "aa89d05b48332d68b8e6ebcee427b2ac3b4e3184",
      "commit_message": "Only remove prototype properties defined with simple assigment\nstatements.\nFixes issue 459.\n\nR=acleung\nDELTA=90  (86 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=2195\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1160 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "johnlenz@google.com",
      "commit_parent": "8777edb959dfea307495e667c2c01834adabb906",
      "commit_date": "2011-06-06 22:36:17",
      "commit_file_diff": "@@ -313,8 +313,9 @@ class AnalyzePrototypeProperties implements CompilerPass {\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n-      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) &&\n-          n.getType() == Token.GETPROP) {\n+      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n+          && n.getType() == Token.GETPROP\n+          && assign.getParent().getType() == Token.EXPR_RESULT) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n"
    },
    "function": {
      "function_name": "isPrototypePropertyAssign",
      "function_parent": "AnalyzePrototypeProperties::ProcessProperties::isPrototypePropertyAssign( Node assign)",
      "function_before_start_line": 314,
      "function_before_end_line": 333,
      "function_after_start_line": 314,
      "function_after_end_line": 334,
      "function_before_token_count": 114,
      "function_after_token_count": 128,
      "function_before": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) &&\n      n.getType() == Token.GETPROP) {\n    // We want to exclude the assignment itself from the usage list\n    boolean isChainedProperty =\n        n.getFirstChild().getType() == Token.GETPROP;\n\n    if (isChainedProperty) {\n      Node child = n.getFirstChild().getFirstChild().getNext();\n\n      if (child.getType() == Token.STRING &&\n          child.getString().equals(\"prototype\")) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}",
      "function_after": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && assign.getParent().getType() == Token.EXPR_RESULT) {\n    // We want to exclude the assignment itself from the usage list\n    boolean isChainedProperty =\n        n.getFirstChild().getType() == Token.GETPROP;\n\n    if (isChainedProperty) {\n      Node child = n.getFirstChild().getFirstChild().getNext();\n\n      if (child.getType() == Token.STRING &&\n          child.getString().equals(\"prototype\")) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}"
    },
    "file": {
      "file_name": "AnalyzePrototypeProperties.java",
      "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java",
      "file_nloc": 437,
      "file_complexity": 110,
      "file_token_count": 2914,
      "file_before": "",
      "file_after": ""
    }
  },
  "22": {
    "id": 22,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 70,
    "buggy_line_location": 1745,
    "buggy_line_content": "jsDocParameter.getJSType(), true);",
    "fixed_line_location": 1745,
    "fixed_line_content": "jsDocParameter.getJSType(), false);",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-433.json",
    "in_function": true,
    "commit": {
      "commit_id": "ec4a34c2bd87ba54fa8770affdeeea4f3c42089b",
      "commit_message": "Parameter types should be declared, rather than inferred.\nThis means that if the programmer re-assignes the argument\nto a different type, they will get a type warning.\nFixes issue 433.\n\n\nR=zhuyi\nDELTA=91  (62 added, 14 deleted, 15 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=1963\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1120 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "7433d30ac4cb2334d22e66299846118686efe939",
      "commit_date": "2011-05-20 19:48:47",
      "commit_file_diff": "@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n"
    },
    "function": {
      "function_name": "declareArguments",
      "function_parent": "TypedScopeCreator::LocalScopeBuilder::declareArguments( Node functionNode)",
      "function_before_start_line": 1734,
      "function_before_end_line": 1753,
      "function_after_start_line": 1734,
      "function_after_end_line": 1753,
      "function_before_token_count": 133,
      "function_after_token_count": 133,
      "function_before": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n} // end declareArguments",
      "function_after": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSType(), false);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n} // end declareArguments"
    },
    "file": {
      "file_name": "TypedScopeCreator.java",
      "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "file_nloc": 1216,
      "file_complexity": 357,
      "file_token_count": 8606,
      "file_before": "",
      "file_after": ""
    }
  },
  "23": {
    "id": 23,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 71,
    "buggy_line_location": 420,
    "buggy_line_content": "boolean isOverride = t.inGlobalScope() &&",
    "fixed_line_location": 416,
    "fixed_line_content": "boolean isOverride = parent.getJSDocInfo() != null &&",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-254.json",
    "in_function": true,
    "commit": {
      "commit_id": "db1fdf97454a6e4ff2d29cab5f1ef2273b54c0b4",
      "commit_message": "Emit a warning when a private property overrides another private\nproperty, with both defined in the ctor.\nFixes issue 254\n\n\n\nR=zhuyi,pupius\nDELTA=152  (134 added, 10 deleted, 8 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=1860\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1089 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "c498ecb791f2dd8a1b37e74f94c1c119549607bc",
      "commit_date": "2011-05-12 18:49:05",
      "commit_file_diff": "@@ -35,15 +35,11 @@ import com.google.common.collect.HashMultimap;\n  * control restrictions indicated by JSDoc annotations, like\n  * {@code @private} and {@code @deprecated}.\n  *\n- * There are two parts to this pass:\n- * 1) JSDoc Inference: Attaching the appropriate JSDoc to\n- *    all programmer-defined types and properties.\n- * 2) Access Control Enforcement: Emitting warnings when the code does not\n- *    obey the restrictions attached to JSTypes in step 1.\n- *\n  * Because access control restrictions are attached to type information,\n- * it's important that TypeCheck runs before this pass, so that all types\n- * are correctly resolved and propagated before this pass runs.\n+ * it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo\n+ * all run before this pass. TypedScopeCreator creates and resolves types,\n+ * TypeInference propagates those types across the AST, and InferJSDocInfo\n+ * propagates JSDoc across the types.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n@@ -417,7 +413,7 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+      boolean isOverride = parent.getJSDocInfo() != null &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n"
    },
    "function": {
      "function_name": "checkPropertyVisibility",
      "function_parent": "CheckAccessControls::checkPropertyVisibility( NodeTraversal t , Node getprop , Node parent)",
      "function_before_start_line": 411,
      "function_before_end_line": 504,
      "function_after_start_line": 407,
      "function_after_end_line": 500,
      "function_before_token_count": 445,
      "function_after_token_count": 447,
      "function_before": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}",
      "function_after": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = parent.getJSDocInfo() != null &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}"
    },
    "file": {
      "file_name": "CheckAccessControls.java",
      "file_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
      "file_nloc": 424,
      "file_complexity": 129,
      "file_token_count": 2772,
      "file_before": "",
      "file_after": ""
    }
  },
  "24": {
    "id": 24,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 73,
    "buggy_line_location": 1045,
    "buggy_line_content": "if (c > 0x1f && c <= 0x7f) {",
    "fixed_line_location": 1045,
    "fixed_line_content": "if (c > 0x1f && c < 0x7f) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-416.json",
    "in_function": true,
    "commit": {
      "commit_id": "ee8344091722c28c9351e78dcb4155fbfddfd1af",
      "commit_message": "Codepoint U+007f should not appear raw in output\nFixes issue 416\nhttp://code.google.com/p/closure-compiler/issues/detail?id=416\n\nR=johnlenz\nDELTA=7  (6 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=1489\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1014 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "zhuyi@google.com",
      "commit_parent": "760bded3242093d86611a82e81fdca302a1487f1",
      "commit_date": "2011-04-15 16:10:54",
      "commit_file_diff": "@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n"
    },
    "function": {
      "function_name": "strEscape",
      "function_parent": "CodeGenerator::strEscape( String s , char quote , String doublequoteEscape , String singlequoteEscape , String backslashEscape , CharsetEncoder outputCharsetEncoder)",
      "function_before_start_line": 988,
      "function_before_end_line": 1058,
      "function_after_start_line": 988,
      "function_after_end_line": 1058,
      "function_before_token_count": 420,
      "function_after_token_count": 420,
      "function_before": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "function_after": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}"
    },
    "file": {
      "file_name": "CodeGenerator.java",
      "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "file_nloc": 875,
      "file_complexity": 239,
      "file_token_count": 5659,
      "file_before": "",
      "file_after": ""
    }
  },
  "25": {
    "id": 25,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 86,
    "buggy_line_location": 2462,
    "buggy_line_content": "return true;",
    "fixed_line_location": 2465,
    "fixed_line_content": "return false;",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-303.json",
    "in_function": true,
    "commit": {
      "commit_id": "0907b6618a60b2de23c8f7ec2217a37dc5e9a091",
      "commit_message": "Fix improper analysis of NEW, the bad way:\nby assuming NEW always returns a non-local result.\nFixes issue 303.\n\nR=johnlenz\nDELTA=68  (56 added, 0 deleted, 12 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=161\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@647 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "5cd9c1efe90dc7c1be33cd7f8c1dcbaa9225909e",
      "commit_date": "2010-12-18 00:47:28",
      "commit_file_diff": "@@ -2459,7 +2459,10 @@ public final class NodeUtil {\n             || isToStringMethodCall(value)\n             || locals.apply(value);\n       case Token.NEW:\n-        return true;\n+        // TODO(nicksantos): This needs to be changed so that it\n+        // returns true iff we're sure the value was never aliased from inside\n+        // the constructor (similar to callHasLocalResult)\n+        return false;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n"
    },
    "function": {
      "function_name": "evaluatesToLocalValue",
      "function_parent": "NodeUtil::evaluatesToLocalValue( Node value , Predicate<Node> locals)",
      "function_before_start_line": 2424,
      "function_before_end_line": 2486,
      "function_after_start_line": 2424,
      "function_after_end_line": 2489,
      "function_before_token_count": 335,
      "function_after_token_count": 335,
      "function_before": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // A result that is aliased by a non-local name, is the effectively the\n      // same as returning a non-local name, but this doesn't matter if the\n      // value is immutable.\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      // There is no information about the locality of object properties.\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return true;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}",
      "function_after": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // A result that is aliased by a non-local name, is the effectively the\n      // same as returning a non-local name, but this doesn't matter if the\n      // value is immutable.\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      // There is no information about the locality of object properties.\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      // TODO(nicksantos): This needs to be changed so that it\n      // returns true iff we're sure the value was never aliased from inside\n      // the constructor (similar to callHasLocalResult)\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}"
    },
    "file": {
      "file_name": "NodeUtil.java",
      "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "file_nloc": 1542,
      "file_complexity": 678,
      "file_token_count": 9760,
      "file_before": "",
      "file_after": ""
    }
  },
  "26": {
    "id": 26,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 92,
    "buggy_line_location": 789,
    "buggy_line_content": "int indexOfDot = namespace.indexOf('.');",
    "fixed_line_location": 789,
    "fixed_line_content": "int indexOfDot = namespace.lastIndexOf('.');",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-261.json",
    "in_function": true,
    "commit": {
      "commit_id": "8980b60033b1c6853cbca593ec89d3d332adf7dc",
      "commit_message": "Fix bug with implicit namespaces across modules.\nContributed by bolinfest\nFixes issue 261\n\nRevision created by MOE tool push_codebase.\n\nR=johnlenz\nDELTA=17  (15 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=337977\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@491 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "39dde4ca5df6263d7058029e081a710d7fa13de9",
      "commit_date": "2010-10-15 17:51:45",
      "commit_file_diff": "@@ -786,7 +786,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n"
    },
    "function": {
      "function_name": "replace",
      "function_parent": "ProcessClosurePrimitives::ProvidedName::replace()",
      "function_before_start_line": 747,
      "function_before_end_line": 809,
      "function_after_start_line": 747,
      "function_after_end_line": 809,
      "function_before_token_count": 322,
      "function_after_token_count": 322,
      "function_before": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        // Need to convert this assign to a var declaration.\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // In this case, the name was implicitly provided by two independent\n      // modules. We need to move this code up to a common module.\n      int indexOfDot = namespace.indexOf('.');\n      if (indexOfDot == -1) {\n        // Any old place is fine.\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        // Add it after the parent namespace.\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
      "function_after": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        // Need to convert this assign to a var declaration.\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // In this case, the name was implicitly provided by two independent\n      // modules. We need to move this code up to a common module.\n      int indexOfDot = namespace.lastIndexOf('.');\n      if (indexOfDot == -1) {\n        // Any old place is fine.\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        // Add it after the parent namespace.\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}"
    },
    "file": {
      "file_name": "ProcessClosurePrimitives.java",
      "file_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "file_nloc": 615,
      "file_complexity": 152,
      "file_token_count": 4136,
      "file_before": "",
      "file_after": ""
    }
  },
  "27": {
    "id": 27,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 104,
    "buggy_line_location": 292,
    "buggy_line_content": "if (result != null) {",
    "fixed_line_location": 291,
    "fixed_line_content": "if (!result.isNoType()) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-114.json",
    "in_function": true,
    "commit": {
      "commit_id": "67289ae4cbaba3ae70cd2e8fb92f3f2898039dfb",
      "commit_message": "Fixes a bug in getGreatestSubtype (Andrew)\n\nFixes some typos in html5 externs. Fixes issue 114. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@113 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "Nicholas.J.Santos",
      "commit_parent": "1be1c2636ef14071afa7da5cb8988972bd90149f",
      "commit_date": "2010-02-22 22:55:41",
      "commit_file_diff": "@@ -43,7 +43,6 @@ import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.ErrorReporter;\n-import com.google.javascript.rhino.jstype.JSType.TypePair;\n \n import java.util.Set;\n import java.util.SortedSet;\n@@ -289,7 +288,7 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+    if (!result.isNoType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n"
    },
    "function": {
      "function_name": "meet",
      "function_parent": "UnionType::meet( JSType that)",
      "function_before_start_line": 274,
      "function_before_end_line": 299,
      "function_after_start_line": 273,
      "function_after_end_line": 298,
      "function_before_token_count": 160,
      "function_after_token_count": 163,
      "function_before": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (result != null) {\n    return result;\n  } else if (this.isObject() && that.isObject()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}",
      "function_after": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (!result.isNoType()) {\n    return result;\n  } else if (this.isObject() && that.isObject()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}"
    },
    "file": {
      "file_name": "UnionType.java",
      "file_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
      "file_nloc": 318,
      "file_complexity": 91,
      "file_token_count": 1687,
      "file_before": "",
      "file_after": ""
    }
  },
  "28": {
    "id": 28,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 113,
    "buggy_line_location": 329,
    "buggy_line_content": "if (provided != null) {",
    "fixed_line_location": 329,
    "fixed_line_content": "if (provided != null || requiresLevel.isOn()) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1079.json",
    "in_function": true,
    "commit": {
      "commit_id": "0fb76a81bbdd8ab84a00b8be2099abfb83c88668",
      "commit_message": "This change had to be rolled-back, since it breaks some users of the Java API.\nSee the updated comment and new test case for reasoning.\n\nThe error level shouldn't effect compiler output. Fixes issue 1079\n\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=53756243",
      "commit_author": "Ben Lickly",
      "commit_parent": "fa1e469dde0bdfd6978a3266db7803b8d39d1d69",
      "commit_date": "2013-10-04 16:50:10",
      "commit_file_diff": "@@ -321,12 +321,12 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n       maybeAddToSymbolTable(left);\n       maybeAddStringNodeToSymbolTable(arg);\n \n-      // Requires should be removed before runtime.  The one\n-      // exception is if the type has not been provided yet, in which case,\n-      // we will be doing a later pass that may error, so we can\n-      // leave this here this time and let it error next time if it\n-      // is still not provided.\n-      if (provided != null) {\n+      // Requires should be removed before further processing.\n+      // Some clients run closure pass multiple times, first with\n+      // the checks for broken requires turned off. In these cases, we\n+      // allow broken requires to be preserved by the first run to\n+      // let them be caught in the subsequent run.\n+      if (provided != null || requiresLevel.isOn()) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n"
    },
    "function": {
      "function_name": "processRequireCall",
      "function_parent": "ProcessClosurePrimitives::processRequireCall( NodeTraversal t , Node n , Node parent)",
      "function_before_start_line": 295,
      "function_before_end_line": 334,
      "function_after_start_line": 295,
      "function_after_end_line": 334,
      "function_before_token_count": 203,
      "function_after_token_count": 209,
      "function_before": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n\n      // This must be non-null, because there was an explicit provide.\n      Preconditions.checkNotNull(providedModule);\n\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n\n    // Requires should be removed before runtime.  The one\n    // exception is if the type has not been provided yet, in which case,\n    // we will be doing a later pass that may error, so we can\n    // leave this here this time and let it error next time if it\n    // is still not provided.\n    if (provided != null) {\n      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}",
      "function_after": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n\n      // This must be non-null, because there was an explicit provide.\n      Preconditions.checkNotNull(providedModule);\n\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n\n    // Requires should be removed before further processing.\n    // Some clients run closure pass multiple times, first with\n    // the checks for broken requires turned off. In these cases, we\n    // allow broken requires to be preserved by the first run to\n    // let them be caught in the subsequent run.\n    if (provided != null || requiresLevel.isOn()) {\n      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}"
    },
    "file": {
      "file_name": "ProcessClosurePrimitives.java",
      "file_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "file_nloc": 844,
      "file_complexity": 201,
      "file_token_count": 5564,
      "file_before": "",
      "file_after": ""
    }
  },
  "29": {
    "id": 29,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 114,
    "buggy_line_location": 578,
    "buggy_line_content": "} else {",
    "fixed_line_location": 578,
    "fixed_line_content": "} else if (!(parent.isCall() && parent.getFirstChild() == n)) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1085.json",
    "in_function": true,
    "commit": {
      "commit_id": "5f03c6817341d39d8dead76c7511fd6bb0b9009f",
      "commit_message": "SmartNamePass shouldn't record assignment dependencies if the rhs is a call. The rhs is used by the context, so we don't want it removed if the lhs isn't used.\n\nFixes issue 1085.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=53691900",
      "commit_author": "Ben Lickly",
      "commit_parent": "a44af4540d0f2bf5fc5ecd0a34c9fea656ee574c",
      "commit_date": "2013-10-03 18:21:15",
      "commit_file_diff": "@@ -575,7 +575,13 @@ final class NameAnalyzer implements CompilerPass {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n+          // The rhs of the assignment is the caller, so it's used by the\n+          // context. Don't associate it w/ the lhs.\n+          // FYI: this fixes only the specific case where the assignment is the\n+          // caller expression, but it could be nested deeper in the caller and\n+          // we would still get a bug.\n+          // See testAssignWithCall2 for an example of this.\n           recordDepScope(recordNode, ns);\n         }\n       }\n@@ -845,8 +851,7 @@ final class NameAnalyzer implements CompilerPass {\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (!(n.isName() ||\n-            NodeUtil.isGet(n) && !parent.isGetProp())) {\n+      if (!(n.isName() || (NodeUtil.isGet(n) && !parent.isGetProp()))) {\n         // This is not a simple or qualified name.\n         return;\n       }\n@@ -914,7 +919,7 @@ final class NameAnalyzer implements CompilerPass {\n \n       // A value whose result is the return value of a function call\n       // can be an alias to global object.\n-      // Here we add a alias to the general \"global\" object\n+      // Here we add an alias to the general \"global\" object\n       // to act as a placeholder for the actual (unnamed) value.\n       if (maybeHiddenAlias(n)) {\n         recordAlias(name, WINDOW);\n"
    },
    "function": {
      "function_name": "recordAssignment",
      "function_parent": "NameAnalyzer::FindDependencyScopes::recordAssignment( NodeTraversal t , Node n , Node recordNode)",
      "function_before_start_line": 558,
      "function_before_end_line": 582,
      "function_after_start_line": 558,
      "function_after_end_line": 588,
      "function_before_token_count": 110,
      "function_after_token_count": 129,
      "function_before": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.  Without\n      // this change, all 3 of those parts try to claim the for\n      // loop as their dependency scope.  The last assignment in\n      // those three fields wins, which can result in incorrect\n      // reference edges between referenced and assigned variables.\n      //\n      // TODO(user) revisit the dependency scope calculation\n      // logic.\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
      "function_after": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.  Without\n      // this change, all 3 of those parts try to claim the for\n      // loop as their dependency scope.  The last assignment in\n      // those three fields wins, which can result in incorrect\n      // reference edges between referenced and assigned variables.\n      //\n      // TODO(user) revisit the dependency scope calculation\n      // logic.\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n      // The rhs of the assignment is the caller, so it's used by the\n      // context. Don't associate it w/ the lhs.\n      // FYI: this fixes only the specific case where the assignment is the\n      // caller expression, but it could be nested deeper in the caller and\n      // we would still get a bug.\n      // See testAssignWithCall2 for an example of this.\n      recordDepScope(recordNode, ns);\n    }\n  }\n}"
    },
    "file": {
      "file_name": "NameAnalyzer.java",
      "file_path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "file_nloc": 1163,
      "file_complexity": 312,
      "file_token_count": 7567,
      "file_before": "",
      "file_after": ""
    }
  },
  "30": {
    "id": 30,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 125,
    "buggy_line_location": 1661,
    "buggy_line_content": "if (fnType != null) {",
    "fixed_line_location": 1661,
    "fixed_line_content": "if (fnType != null && fnType.hasInstanceType()) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1002.json",
    "in_function": true,
    "commit": {
      "commit_id": "8cef00180a5cf67d047919c89668a6405030dbab",
      "commit_message": "Skip checks if constructor has no instance type.\n\nFixes issue 1002\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=47053164",
      "commit_author": "Ben Lickly",
      "commit_parent": "ddc1299802e88b9814250c369e3fe6f7ee07d4e5",
      "commit_date": "2013-05-23 18:49:49",
      "commit_file_diff": "@@ -1176,7 +1176,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * Returns true if any type in the chain has an implicitCast annotation for\n    * the given property.\n    */\n-  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n+  private static boolean propertyIsImplicitCast(ObjectType type, String prop) {\n     for (; type != null; type = type.getImplicitPrototype()) {\n       JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n       if (docInfo != null && docInfo.isImplicitCast()) {\n@@ -1658,7 +1658,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+      if (fnType != null && fnType.hasInstanceType()) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n"
    },
    "function": {
      "function_name": "visitNew",
      "function_parent": "TypeCheck::visitNew( NodeTraversal t , Node n)",
      "function_before_start_line": 1656,
      "function_before_end_line": 1671,
      "function_after_start_line": 1656,
      "function_after_end_line": 1671,
      "function_before_token_count": 121,
      "function_after_token_count": 127,
      "function_before": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}",
      "function_after": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}"
    },
    "file": {
      "file_name": "TypeCheck.java",
      "file_path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "file_nloc": 1486,
      "file_complexity": 436,
      "file_token_count": 9430,
      "file_before": "",
      "file_after": ""
    }
  },
  "31": {
    "id": 31,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 130,
    "buggy_line_location": 172,
    "buggy_line_content": "if (name.globalSets == 1 && name.localSets == 0 &&",
    "fixed_line_location": 172,
    "fixed_line_content": "if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-931.json",
    "in_function": true,
    "commit": {
      "commit_id": "9fac3ccd2fa9e6137584f079db1a6f5962a65cf4",
      "commit_message": "Don't attempt to inline aliases of external names during collapse properties as all the sets can not be accounted for.\nFixes issue 931\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=43187988",
      "commit_author": "Ben Lickly",
      "commit_parent": "8a37f1089f62deaebc29fe5c8a22f48d04a6c8b1",
      "commit_date": "2013-02-27 15:08:53",
      "commit_file_diff": "@@ -169,7 +169,7 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n"
    },
    "function": {
      "function_name": "inlineAliases",
      "function_parent": "CollapseProperties::inlineAliases( GlobalNamespace namespace)",
      "function_before_start_line": 161,
      "function_before_end_line": 197,
      "function_after_start_line": 161,
      "function_after_end_line": 197,
      "function_before_token_count": 205,
      "function_after_token_count": 210,
      "function_before": "private void inlineAliases(GlobalNamespace namespace) {\n  // Invariant: All the names in the worklist meet condition (a).\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n\n    // Don't attempt to inline a getter or setter property as a variable.\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n\n    if (name.globalSets == 1 && name.localSets == 0 &&\n        name.aliasingGets > 0) {\n      // {@code name} meets condition (b). Find all of its local aliases\n      // and try to inline them.\n      List<Ref> refs = Lists.newArrayList(name.getRefs());\n      for (Ref ref : refs) {\n        if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n          // {@code name} meets condition (c). Try to inline it.\n          if (inlineAliasIfPossible(ref, namespace)) {\n            name.removeRef(ref);\n          }\n        }\n      }\n    }\n\n    // Check if {@code name} has any aliases left after the\n    // local-alias-inlining above.\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      // All of {@code name}'s children meet condition (a), so they can be\n      // added to the worklist.\n      workList.addAll(name.props);\n    }\n  }\n}",
      "function_after": "private void inlineAliases(GlobalNamespace namespace) {\n  // Invariant: All the names in the worklist meet condition (a).\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n\n    // Don't attempt to inline a getter or setter property as a variable.\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n\n    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n        name.aliasingGets > 0) {\n      // {@code name} meets condition (b). Find all of its local aliases\n      // and try to inline them.\n      List<Ref> refs = Lists.newArrayList(name.getRefs());\n      for (Ref ref : refs) {\n        if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n          // {@code name} meets condition (c). Try to inline it.\n          if (inlineAliasIfPossible(ref, namespace)) {\n            name.removeRef(ref);\n          }\n        }\n      }\n    }\n\n    // Check if {@code name} has any aliases left after the\n    // local-alias-inlining above.\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      // All of {@code name}'s children meet condition (a), so they can be\n      // added to the worklist.\n      workList.addAll(name.props);\n    }\n  }\n}"
    },
    "file": {
      "file_name": "CollapseProperties.java",
      "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java",
      "file_nloc": 536,
      "file_complexity": 152,
      "file_token_count": 3907,
      "file_before": "",
      "file_after": ""
    }
  },
  "32": {
    "id": 32,
    "project_name": "closure-compiler",
    "project_url": "https://github.com/google/closure-compiler.git",
    "defects4j_id": 168,
    "buggy_line_location": 1986,
    "buggy_line_content": "if (t.getScopeDepth() <= 2) {",
    "fixed_line_location": 1996,
    "fixed_line_content": "if (t.getScopeDepth() <= 1) {",
    "bug_description_link": "https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-726.json",
    "in_function": true,
    "commit": {
      "commit_id": "b675d1da9d5f8b36849db4943f580969105901a4",
      "commit_message": "Add a heuristic for figuring out the type of an inferred variable\nthat is read across multiple scopes. This isn't perfect, but it should\ncatch a lot of common cases.\nFixes issue 726\n\nTested:\nyes\n\nQA: yes\n\nR=johnlenz,dimvar\nDELTA=254  (211 added, 17 deleted, 26 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=5338\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2137 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_parent": "d06ac163013a3779fcec7c2f544ba99d08f69f58",
      "commit_date": "2012-08-10 19:49:41",
      "commit_file_diff": "@@ -51,6 +51,7 @@ import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Multiset;\n import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;\n import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n@@ -1871,6 +1872,15 @@ final class TypedScopeCreator implements ScopeCreator {\n           Preconditions.checkState(v.getScope() == scope);\n           v.markEscaped();\n         }\n+\n+        for (Multiset.Entry<String> entry :\n+                 contents.getAssignedNameCounts().entrySet()) {\n+          Var v = scope.getVar(entry.getElement());\n+          Preconditions.checkState(v.getScope() == scope);\n+          if (entry.getCount() == 1) {\n+            v.markAssignedExactlyOnce();\n+          }\n+        }\n       }\n     }\n \n@@ -1983,20 +1993,31 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n-        // We only need to worry about escaped variables at depth 3.\n-        // An variable escaped at depth 2 is, by definition, a global variable.\n+      if (t.getScopeDepth() <= 1) {\n+        // The first-order function analyzer looks at two types of variables:\n+        //\n+        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n+        //\n+        // 2) Local variables that are assigned more than once.\n+        //\n         // We treat all global variables as escaped by default, so there's\n         // no reason to do this extra computation for them.\n         return;\n       }\n \n-      if (n.isName() && NodeUtil.isLValue(n)) {\n+      if (n.isName() && NodeUtil.isLValue(n) &&\n+          // Be careful of bleeding functions, which create variables\n+          // in the inner scope, not the scope where the name appears.\n+          !NodeUtil.isBleedingFunctionName(n)) {\n         String name = n.getString();\n         Scope scope = t.getScope();\n         Var var = scope.getVar(name);\n         if (var != null) {\n           Scope ownerScope = var.getScope();\n+          if (ownerScope.isLocal()) {\n+            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n+          }\n+\n           if (scope != ownerScope && ownerScope.isLocal()) {\n             data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n           }\n"
    },
    "function": {
      "function_name": "visit",
      "function_parent": "TypedScopeCreator::FirstOrderFunctionAnalyzer::visit( NodeTraversal t , Node n , Node parent)",
      "function_before_start_line": 1977,
      "function_before_end_line": 2017,
      "function_after_start_line": 1987,
      "function_after_end_line": 2038,
      "function_before_token_count": 272,
      "function_after_token_count": 306,
      "function_before": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n\n  if (t.getScopeDepth() <= 2) {\n    // We only need to worry about escaped variables at depth 3.\n    // An variable escaped at depth 2 is, by definition, a global variable.\n    // We treat all global variables as escaped by default, so there's\n    // no reason to do this extra computation for them.\n    return;\n  }\n\n  if (n.isName() && NodeUtil.isLValue(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n      NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode())\n            .recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  }\n}",
      "function_after": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n\n  if (t.getScopeDepth() <= 1) {\n    // The first-order function analyzer looks at two types of variables:\n    //\n    // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n    //\n    // 2) Local variables that are assigned more than once.\n    //\n    // We treat all global variables as escaped by default, so there's\n    // no reason to do this extra computation for them.\n    return;\n  }\n\n  if (n.isName() && NodeUtil.isLValue(n) &&\n      // Be careful of bleeding functions, which create variables\n      // in the inner scope, not the scope where the name appears.\n      !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordAssignedName(name);\n      }\n\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n      NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode())\n            .recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  }\n}"
    },
    "file": {
      "file_name": "TypedScopeCreator.java",
      "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "file_nloc": 1338,
      "file_complexity": 399,
      "file_token_count": 9396,
      "file_before": "",
      "file_after": ""
    }
  },
  "33": {
    "id": 33,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 2,
    "buggy_line_location": 446,
    "buggy_line_content": "if (lineLength > 0) {",
    "fixed_line_location": 446,
    "fixed_line_content": "if (lineLength > 0 && pos > 0) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-77",
    "in_function": true,
    "commit": {
      "commit_id": "b8c2d9d9dc9aab45f83cf49ac93cfa8546e4c08e",
      "commit_message": "[CODEC-77] Base64 bug with empty input (new byte[0])\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@793734 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_parent": "2f7454a01e4c2992bffc3d86137e632e80c5027f",
      "commit_date": "2009-07-13 22:33:28",
      "commit_file_diff": "@@ -443,7 +443,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+            if (lineLength > 0 && pos > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n"
    },
    "function": {
      "function_name": "encode",
      "function_parent": "Base64::encode( byte [ ] in , int inPos , int inAvail)",
      "function_before_start_line": 414,
      "function_before_end_line": 473,
      "function_after_start_line": 414,
      "function_after_end_line": 473,
      "function_before_token_count": 430,
      "function_after_token_count": 434,
      "function_before": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) { b += 256; }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++] = encodeTable[x & MASK_6BITS];\n                currentLinePos += 4;\n                if (lineLength > 0 && lineLength <= currentLinePos) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n        }\n    }\n}",
      "function_after": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                // URL-SAFE skips the padding to further reduce size.\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0 && pos > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) { b += 256; }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++] = encodeTable[x & MASK_6BITS];\n                currentLinePos += 4;\n                if (lineLength > 0 && lineLength <= currentLinePos) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n        }\n    }\n}"
    },
    "file": {
      "file_name": "Base64.java",
      "file_path": "src/java/org/apache/commons/codec/binary/Base64.java",
      "file_nloc": 387,
      "file_complexity": 111,
      "file_token_count": 3219,
      "file_before": "",
      "file_after": ""
    }
  },
  "34": {
    "id": 34,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 3,
    "buggy_line_location": 455,
    "buggy_line_content": "} else if (contains(value, index + 1, 4, \"IER\")) {",
    "fixed_line_location": 455,
    "fixed_line_content": "} else if (contains(value, index + 1, 3, \"IER\")) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-84",
    "in_function": true,
    "commit": {
      "commit_id": "a5dfe5cbc95d7f3ce0b4829756690c2cb8439f4c",
      "commit_message": "[CODEC-84] Double Metaphone bugs in alternative encoding. Apply patch. Thank you Niall.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@800153 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_parent": "d7b01850ef418b1d261cdb2029f8f85ab4031553",
      "commit_date": "2009-08-02 22:45:30",
      "commit_file_diff": "@@ -452,7 +452,7 @@ public class DoubleMetaphone implements StringEncoder {\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+            } else if (contains(value, index + 1, 3, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n@@ -561,14 +561,16 @@ public class DoubleMetaphone implements StringEncoder {\n     private int handleL(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n-        result.append('L');\n         if (charAt(value, index + 1) == 'L') {\n             if (conditionL0(value, index)) {\n-                result.appendAlternate(' ');\n+                result.appendPrimary('L');\n+            } else {\n+                result.append('L');\n             }\n             index += 2;\n         } else {\n             index++;\n+            result.append('L');\n         }\n         return index;\n     }\n@@ -857,7 +859,7 @@ public class DoubleMetaphone implements StringEncoder {\n         if (index == value.length() - 3 && \n             contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n             return true;\n-        } else if ((contains(value, index - 1, 2, \"AS\", \"OS\") || \n+        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") || \n                     contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n                    contains(value, index - 1, 4, \"ALLE\")) {\n             return true;\n@@ -1002,10 +1004,9 @@ public class DoubleMetaphone implements StringEncoder {\n     }\n     \n     /**\n-     * Determines whether <code>value</code> contains any of the criteria \n-     starting\n-     * at index <code>start</code> and matching up to length <code>length</code>\n-     */    \n+     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n+     * matching up to length <code>length</code>\n+     */\n     protected static boolean contains(String value, int start, int length, \n                                       String[] criteria) {\n         boolean result = false;\n"
    },
    "function": {
      "function_name": "handleG",
      "function_parent": "DoubleMetaphone::handleG( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic)",
      "function_before_start_line": 418,
      "function_before_end_line": 469,
      "function_after_start_line": 418,
      "function_after_end_line": 469,
      "function_before_token_count": 491,
      "function_after_token_count": 491,
      "function_before": "private int handleG(String value, \n                    DoubleMetaphoneResult result, \n                    int index, \n                    boolean slavoGermanic) {\n    if (charAt(value, index + 1) == 'H') {\n        index = handleGH(value, result, index);\n    } else if (charAt(value, index + 1) == 'N') {\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n            result.append(\"KN\", \"N\");\n        } else if (!contains(value, index + 2, 2, \"EY\") && \n                   charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n            result.append(\"N\", \"KN\");\n        } else {\n            result.append(\"KN\");\n        }\n        index = index + 2;\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n        result.append(\"KL\", \"L\");\n        index += 2;\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n        //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n        result.append('K', 'J');\n        index += 2;\n    } else if ((contains(value, index + 1, 2, \"ER\") || \n                charAt(value, index + 1) == 'Y') &&\n               !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n               !contains(value, index - 1, 1, \"E\", \"I\") && \n               !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n        //-- -ger-, -gy- --//\n        result.append('K', 'J');\n        index += 2;\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n               contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n        //-- Italian \"biaggi\" --//\n        if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n            //-- obvious germanic --//\n            result.append('K');\n        } else if (contains(value, index + 1, 4, \"IER\")) {\n            result.append('J');\n        } else {\n            result.append('J', 'K');\n        }\n        index += 2;\n    } else if (charAt(value, index + 1) == 'G') {\n        index += 2;\n        result.append('K');\n    } else {\n        index++;\n        result.append('K');\n    }\n    return index;\n}",
      "function_after": "private int handleG(String value, \n                    DoubleMetaphoneResult result, \n                    int index, \n                    boolean slavoGermanic) {\n    if (charAt(value, index + 1) == 'H') {\n        index = handleGH(value, result, index);\n    } else if (charAt(value, index + 1) == 'N') {\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n            result.append(\"KN\", \"N\");\n        } else if (!contains(value, index + 2, 2, \"EY\") && \n                   charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n            result.append(\"N\", \"KN\");\n        } else {\n            result.append(\"KN\");\n        }\n        index = index + 2;\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n        result.append(\"KL\", \"L\");\n        index += 2;\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n        //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n        result.append('K', 'J');\n        index += 2;\n    } else if ((contains(value, index + 1, 2, \"ER\") || \n                charAt(value, index + 1) == 'Y') &&\n               !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n               !contains(value, index - 1, 1, \"E\", \"I\") && \n               !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n        //-- -ger-, -gy- --//\n        result.append('K', 'J');\n        index += 2;\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n               contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n        //-- Italian \"biaggi\" --//\n        if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n            //-- obvious germanic --//\n            result.append('K');\n        } else if (contains(value, index + 1, 3, \"IER\")) {\n            result.append('J');\n        } else {\n            result.append('J', 'K');\n        }\n        index += 2;\n    } else if (charAt(value, index + 1) == 'G') {\n        index += 2;\n        result.append('K');\n    } else {\n        index++;\n        result.append('K');\n    }\n    return index;\n}"
    },
    "file": {
      "file_name": "DoubleMetaphone.java",
      "file_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
      "file_nloc": 769,
      "file_complexity": 291,
      "file_token_count": 5907,
      "file_before": "",
      "file_after": ""
    }
  },
  "35": {
    "id": 35,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 4,
    "buggy_line_location": 225,
    "buggy_line_content": "this(false);",
    "fixed_line_location": 225,
    "fixed_line_content": "this(0);",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-89",
    "in_function": true,
    "commit": {
      "commit_id": "bcfef8906931a7929a6db14b9d82d387fd3f17f6",
      "commit_message": "JIRA: CODEC-89 new Base64().encode() appends a CRLF, and chunks results into 76 character lines\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@928107 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Sebastian Bazley",
      "commit_parent": "38ba13232cb37374e3c333e2121ebad8a793935c",
      "commit_date": "2010-03-27 00:02:22",
      "commit_file_diff": "@@ -214,7 +214,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n      * <p>\n-     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n+     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n      * </p>\n      * \n      * <p>\n@@ -222,7 +222,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+        this(0);\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "Base64",
      "function_parent": "Base64::Base64()",
      "function_before_start_line": 224,
      "function_before_end_line": 226,
      "function_after_start_line": 224,
      "function_after_end_line": 226,
      "function_before_token_count": 10,
      "function_after_token_count": 10,
      "function_before": "public Base64() {\n    this(false);\n}",
      "function_after": "public Base64() {\n    this(0);\n}"
    },
    "file": {
      "file_name": "Base64.java",
      "file_path": "src/java/org/apache/commons/codec/binary/Base64.java",
      "file_nloc": 421,
      "file_complexity": 121,
      "file_token_count": 3410,
      "file_before": "",
      "file_after": ""
    }
  },
  "36": {
    "id": 36,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 7,
    "buggy_line_location": 670,
    "buggy_line_content": "return StringUtils.newStringUtf8(encodeBase64(binaryData, true));",
    "fixed_line_location": 670,
    "fixed_line_content": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false));",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-99",
    "in_function": true,
    "commit": {
      "commit_id": "954d995c5603b616c3c4a9ffb1823f36dd7ebcb0",
      "commit_message": "CODEC-99 - Base64.encodeBase64String() should not chunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1062330 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Julius Davies",
      "commit_parent": "f7966c1b374ebdd3fccb28370d9cb80a2115d807",
      "commit_date": "2011-01-23 05:52:42",
      "commit_file_diff": "@@ -667,7 +667,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n     }\n     \n     /**\n"
    },
    "function": {
      "function_name": "encodeBase64String",
      "function_parent": "Base64::encodeBase64String( byte [ ] binaryData)",
      "function_before_start_line": 669,
      "function_before_end_line": 671,
      "function_after_start_line": 669,
      "function_after_end_line": 671,
      "function_before_token_count": 22,
      "function_after_token_count": 22,
      "function_before": "public static String encodeBase64String(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}",
      "function_after": "public static String encodeBase64String(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n}"
    },
    "file": {
      "file_name": "Base64.java",
      "file_path": "src/java/org/apache/commons/codec/binary/Base64.java",
      "file_nloc": 425,
      "file_complexity": 123,
      "file_token_count": 3439,
      "file_before": "",
      "file_after": ""
    }
  },
  "37": {
    "id": 37,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 9,
    "buggy_line_location": 827,
    "buggy_line_content": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);",
    "fixed_line_location": 827,
    "fixed_line_content": "long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-112",
    "in_function": true,
    "commit": {
      "commit_id": "c5291ab1ca4d4d7a041874a66b1c05b7d5c02ccb",
      "commit_message": "CODEC-112 Base64.encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) throws IAE for valid maxResultSize if isChunked is false\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1063922 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Sebastian Bazley",
      "commit_parent": "b396c535ff143cf94ea0d11f50739da1709ec290",
      "commit_date": "2011-01-26 23:40:25",
      "commit_file_diff": "@@ -824,7 +824,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n"
    },
    "function": {
      "function_name": "encodeBase64",
      "function_parent": "Base64::encodeBase64( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize)",
      "function_before_start_line": 822,
      "function_before_end_line": 837,
      "function_after_start_line": 822,
      "function_after_end_line": 837,
      "function_before_token_count": 97,
      "function_after_token_count": 101,
      "function_before": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}",
      "function_after": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}"
    },
    "file": {
      "file_name": "Base64.java",
      "file_path": "src/java/org/apache/commons/codec/binary/Base64.java",
      "file_nloc": 409,
      "file_complexity": 120,
      "file_token_count": 3326,
      "file_before": "",
      "file_after": ""
    }
  },
  "38": {
    "id": 38,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 10,
    "buggy_line_location": 74,
    "buggy_line_content": "txt = txt.replaceAll(\"^mb\", \"m2\");",
    "fixed_line_location": 76,
    "fixed_line_content": "txt = txt.replaceAll(\"mb$\", \"m2\");",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-117",
    "in_function": true,
    "commit": {
      "commit_id": "41c68e9ef470696009d72133c7f05a20e2728e34",
      "commit_message": "[CODEC-117] Caverphone encodes names starting and ending with \"mb\" incorrectly.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1075947 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_parent": "2a8fd84f1f380fc472ecf415b771cb5fd789719b",
      "commit_date": "2011-03-01 17:56:14",
      "commit_file_diff": "@@ -71,7 +71,9 @@ public class Caverphone implements StringEncoder {\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+\n+        // End \n+        txt = txt.replaceAll(\"mb$\", \"m2\");\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n"
    },
    "function": {
      "function_name": "caverphone",
      "function_parent": "Caverphone::caverphone( String txt)",
      "function_before_start_line": 50,
      "function_before_end_line": 140,
      "function_after_start_line": 50,
      "function_after_end_line": 142,
      "function_before_token_count": 686,
      "function_after_token_count": 686,
      "function_before": "public String caverphone(String txt) {\n    // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n    // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n\n    // 1. Convert to lowercase\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n    // 2. Remove anything not A-Z\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n    // 2.5. Remove final e\n    txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n    // 3. Handle various start options\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n\n    // 4. Handle replacements\n    txt = txt.replaceAll(\"cq\", \"2q\");\n    txt = txt.replaceAll(\"ci\", \"si\");\n    txt = txt.replaceAll(\"ce\", \"se\");\n    txt = txt.replaceAll(\"cy\", \"sy\");\n    txt = txt.replaceAll(\"tch\", \"2ch\");\n    txt = txt.replaceAll(\"c\", \"k\");\n    txt = txt.replaceAll(\"q\", \"k\");\n    txt = txt.replaceAll(\"x\", \"k\");\n    txt = txt.replaceAll(\"v\", \"f\");\n    txt = txt.replaceAll(\"dg\", \"2g\");\n    txt = txt.replaceAll(\"tio\", \"sio\");\n    txt = txt.replaceAll(\"tia\", \"sia\");\n    txt = txt.replaceAll(\"d\", \"t\");\n    txt = txt.replaceAll(\"ph\", \"fh\");\n    txt = txt.replaceAll(\"b\", \"p\");\n    txt = txt.replaceAll(\"sh\", \"s2\");\n    txt = txt.replaceAll(\"z\", \"s\");\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\n    txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n    txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n    txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n    txt = txt.replaceAll(\"gh\", \"22\");\n    txt = txt.replaceAll(\"g\", \"k\");\n    txt = txt.replaceAll(\"s+\", \"S\");\n    txt = txt.replaceAll(\"t+\", \"T\");\n    txt = txt.replaceAll(\"p+\", \"P\");\n    txt = txt.replaceAll(\"k+\", \"K\");\n    txt = txt.replaceAll(\"f+\", \"F\");\n    txt = txt.replaceAll(\"m+\", \"M\");\n    txt = txt.replaceAll(\"n+\", \"N\");\n    txt = txt.replaceAll(\"w3\", \"W3\");\n    //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\n    txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n    txt = txt.replaceAll(\"w\", \"2\");\n    txt = txt.replaceAll(\"^h\", \"A\");\n    txt = txt.replaceAll(\"h\", \"2\");\n    txt = txt.replaceAll(\"r3\", \"R3\");\n    txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n    txt = txt.replaceAll(\"r\", \"2\");\n    txt = txt.replaceAll(\"l3\", \"L3\");\n    txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n    txt = txt.replaceAll(\"l\", \"2\");\n    //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n    //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n    //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n    // 5. Handle removals\n    txt = txt.replaceAll(\"2\", \"\");\n    txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"3\", \"\");\n\n    // 6. put ten 1s on the end\n    txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n    // 7. take the first six characters as the code\n    return txt.substring(0, 10);          // 1.0 truncates to 6\n}",
      "function_after": "public String caverphone(String txt) {\n    // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n    // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n\n    // 1. Convert to lowercase\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n    // 2. Remove anything not A-Z\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n    // 2.5. Remove final e\n    txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n    // 3. Handle various start options\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n\n    // End \n    txt = txt.replaceAll(\"mb$\", \"m2\");\n\n    // 4. Handle replacements\n    txt = txt.replaceAll(\"cq\", \"2q\");\n    txt = txt.replaceAll(\"ci\", \"si\");\n    txt = txt.replaceAll(\"ce\", \"se\");\n    txt = txt.replaceAll(\"cy\", \"sy\");\n    txt = txt.replaceAll(\"tch\", \"2ch\");\n    txt = txt.replaceAll(\"c\", \"k\");\n    txt = txt.replaceAll(\"q\", \"k\");\n    txt = txt.replaceAll(\"x\", \"k\");\n    txt = txt.replaceAll(\"v\", \"f\");\n    txt = txt.replaceAll(\"dg\", \"2g\");\n    txt = txt.replaceAll(\"tio\", \"sio\");\n    txt = txt.replaceAll(\"tia\", \"sia\");\n    txt = txt.replaceAll(\"d\", \"t\");\n    txt = txt.replaceAll(\"ph\", \"fh\");\n    txt = txt.replaceAll(\"b\", \"p\");\n    txt = txt.replaceAll(\"sh\", \"s2\");\n    txt = txt.replaceAll(\"z\", \"s\");\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\n    txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n    txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n    txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n    txt = txt.replaceAll(\"gh\", \"22\");\n    txt = txt.replaceAll(\"g\", \"k\");\n    txt = txt.replaceAll(\"s+\", \"S\");\n    txt = txt.replaceAll(\"t+\", \"T\");\n    txt = txt.replaceAll(\"p+\", \"P\");\n    txt = txt.replaceAll(\"k+\", \"K\");\n    txt = txt.replaceAll(\"f+\", \"F\");\n    txt = txt.replaceAll(\"m+\", \"M\");\n    txt = txt.replaceAll(\"n+\", \"N\");\n    txt = txt.replaceAll(\"w3\", \"W3\");\n    //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\n    txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n    txt = txt.replaceAll(\"w\", \"2\");\n    txt = txt.replaceAll(\"^h\", \"A\");\n    txt = txt.replaceAll(\"h\", \"2\");\n    txt = txt.replaceAll(\"r3\", \"R3\");\n    txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n    txt = txt.replaceAll(\"r\", \"2\");\n    txt = txt.replaceAll(\"l3\", \"L3\");\n    txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n    txt = txt.replaceAll(\"l\", \"2\");\n    //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n    //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n    //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n    // 5. Handle removals\n    txt = txt.replaceAll(\"2\", \"\");\n    txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n    txt = txt.replaceAll(\"3\", \"\");\n\n    // 6. put ten 1s on the end\n    txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n    // 7. take the first six characters as the code\n    return txt.substring(0, 10);          // 1.0 truncates to 6\n}"
    },
    "file": {
      "file_name": "Caverphone.java",
      "file_path": "src/java/org/apache/commons/codec/language/Caverphone.java",
      "file_nloc": 85,
      "file_complexity": 8,
      "file_token_count": 817,
      "file_before": "",
      "file_after": ""
    }
  },
  "39": {
    "id": 39,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 17,
    "buggy_line_location": 339,
    "buggy_line_content": "return new String(bytes, Charsets.ISO_8859_1);",
    "fixed_line_location": 339,
    "fixed_line_content": "return newString(bytes, Charsets.ISO_8859_1);",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-229",
    "in_function": true,
    "commit": {
      "commit_id": "d2f27093d7d95a07da901902f894d88b4ecc3e95",
      "commit_message": "CODEC-229 StringUtils.newStringxxx(null) should return null, not NPE\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1788755 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Sebastian Bazley",
      "commit_parent": "1a4d9cc2572d220664f1b7c377cd318cd253052e",
      "commit_date": "2017-03-26 17:22:08",
      "commit_file_diff": "@@ -336,7 +336,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+        return newString(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**\n@@ -352,7 +352,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringUsAscii(final byte[] bytes) {\n-        return new String(bytes, Charsets.US_ASCII);\n+        return newString(bytes, Charsets.US_ASCII);\n     }\n \n     /**\n@@ -368,7 +368,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringUtf16(final byte[] bytes) {\n-        return new String(bytes, Charsets.UTF_16);\n+        return newString(bytes, Charsets.UTF_16);\n     }\n \n     /**\n@@ -384,7 +384,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringUtf16Be(final byte[] bytes) {\n-        return new String(bytes, Charsets.UTF_16BE);\n+        return newString(bytes, Charsets.UTF_16BE);\n     }\n \n     /**\n@@ -400,7 +400,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringUtf16Le(final byte[] bytes) {\n-        return new String(bytes, Charsets.UTF_16LE);\n+        return newString(bytes, Charsets.UTF_16LE);\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "newStringIso8859_1",
      "function_parent": "StringUtils::newStringIso8859_1( final byte [ ] bytes)",
      "function_before_start_line": 338,
      "function_before_end_line": 340,
      "function_after_start_line": 338,
      "function_after_end_line": 340,
      "function_before_token_count": 21,
      "function_after_token_count": 20,
      "function_before": "public static String newStringIso8859_1(final byte[] bytes) {\n    return new String(bytes, Charsets.ISO_8859_1);\n}",
      "function_after": "public static String newStringIso8859_1(final byte[] bytes) {\n    return newString(bytes, Charsets.ISO_8859_1);\n}"
    },
    "file": {
      "file_name": "StringUtils.java",
      "file_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
      "file_nloc": 98,
      "file_complexity": 32,
      "file_token_count": 700,
      "file_before": "",
      "file_after": ""
    }
  },
  "40": {
    "id": 40,
    "project_name": "commons-codec",
    "project_url": "https://github.com/apache/commons-codec.git",
    "defects4j_id": 18,
    "buggy_line_location": 81,
    "buggy_line_content": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
    "fixed_line_location": 81,
    "fixed_line_content": "return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());",
    "bug_description_link": "https://issues.apache.org/jira/browse/CODEC-231",
    "in_function": true,
    "commit": {
      "commit_id": "5ef5bd199a4e3df74479b4b363fa29b0b3092547",
      "commit_message": "CODEC-231 StringUtils.equals(CharSequence cs1, CharSequence cs2) can fail with String Index OBE\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1788777 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Sebastian Bazley",
      "commit_parent": "ca30fae3acb59a5caef3c3c21eecae7c928827e0",
      "commit_date": "2017-03-26 21:43:36",
      "commit_file_diff": "@@ -78,7 +78,7 @@ public class StringUtils {\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "equals",
      "function_parent": "StringUtils::equals( final CharSequence cs1 , final CharSequence cs2)",
      "function_before_start_line": 71,
      "function_before_end_line": 82,
      "function_after_start_line": 71,
      "function_after_end_line": 82,
      "function_before_token_count": 91,
      "function_after_token_count": 92,
      "function_before": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}",
      "function_after": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n}"
    },
    "file": {
      "file_name": "StringUtils.java",
      "file_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
      "file_nloc": 98,
      "file_complexity": 33,
      "file_token_count": 701,
      "file_before": "",
      "file_after": ""
    }
  },
  "41": {
    "id": 41,
    "project_name": "commons-collections",
    "project_url": "https://github.com/apache/commons-collections.git",
    "defects4j_id": 3,
    "buggy_line_location": 1121,
    "buggy_line_content": "return ListUtils.retainAll(collection, remove);",
    "fixed_line_location": 1121,
    "fixed_line_content": "return ListUtils.removeAll(collection, remove);",
    "bug_description_link": "",
    "in_function": true,
    "commit": {
      "commit_id": "66c4b99ddc7daea806c1318a40736d0f5c8fa7bd",
      "commit_message": "COLLECTIONS-219 - CollectionUtils - Fix removeAll() method which was completely broken\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/collections/trunk@428130 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Stephen Colebourne",
      "commit_parent": "3f09772b742d7886c5a18427c9838fb267cc335b",
      "commit_date": "2006-08-02 20:24:02",
      "commit_file_diff": "@@ -1,5 +1,5 @@\n /*\n- *  Copyright 2001-2005 The Apache Software Foundation\n+ *  Copyright 2001-2006 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n@@ -1115,10 +1115,10 @@ public class CollectionUtils {\n      * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n      * any elements that also occur in <code>remove</code>.\n      * @throws NullPointerException if either parameter is null\n-     * @since Commons Collections 3.2\n+     * @since Commons Collections 3.3 (method existed in 3.2 but was completely broken)\n      */\n     public static Collection removeAll(Collection collection, Collection remove) {\n-        return ListUtils.retainAll(collection, remove);\n+        return ListUtils.removeAll(collection, remove);\n     }\n \n     //-----------------------------------------------------------------------\n"
    },
    "function": {
      "function_name": "removeAll",
      "function_parent": "CollectionUtils::removeAll( Collection collection , Collection remove)",
      "function_before_start_line": 1120,
      "function_before_end_line": 1122,
      "function_after_start_line": 1120,
      "function_after_end_line": 1122,
      "function_before_token_count": 20,
      "function_after_token_count": 20,
      "function_before": "public static Collection removeAll(Collection collection, Collection remove) {\n    return ListUtils.retainAll(collection, remove);\n}",
      "function_after": "public static Collection removeAll(Collection collection, Collection remove) {\n    return ListUtils.removeAll(collection, remove);\n}"
    },
    "file": {
      "file_name": "CollectionUtils.java",
      "file_path": "src/java/org/apache/commons/collections/CollectionUtils.java",
      "file_nloc": 531,
      "file_complexity": 168,
      "file_token_count": 3821,
      "file_before": "",
      "file_after": ""
    }
  },
  "42": {
    "id": 42,
    "project_name": "commons-collections",
    "project_url": "https://github.com/apache/commons-collections.git",
    "defects4j_id": 9,
    "buggy_line_location": 816,
    "buggy_line_content": "setProperty(key, props.get(key));",
    "fixed_line_location": 816,
    "fixed_line_content": "super.put(key, props.get(key));",
    "bug_description_link": "",
    "in_function": true,
    "commit": {
      "commit_id": "8a5d3acab88bb2ef7416f3141d63f10b79d318cf",
      "commit_message": "Applying the patch from Alexander Borovsky for COLLECTIONS-271\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/collections/trunk@637503 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Henri Yandell",
      "commit_parent": "7cf943172b154019d7c6a66f4290272b2144e29a",
      "commit_date": "2008-03-16 01:39:13",
      "commit_file_diff": "@@ -813,7 +813,7 @@ public class ExtendedProperties extends Hashtable {\n     public void combine(ExtendedProperties props) {\n         for (Iterator it = props.getKeys(); it.hasNext();) {\n             String key = (String) it.next();\n-            setProperty(key, props.get(key));\n+            super.put(key, props.get(key));\n         }\n     }\n     \n"
    },
    "function": {
      "function_name": "combine",
      "function_parent": "ExtendedProperties::combine( ExtendedProperties props)",
      "function_before_start_line": 813,
      "function_before_end_line": 818,
      "function_after_start_line": 813,
      "function_after_end_line": 818,
      "function_before_token_count": 51,
      "function_after_token_count": 53,
      "function_before": "public void combine(ExtendedProperties props) {\n    for (Iterator it = props.getKeys(); it.hasNext();) {\n        String key = (String) it.next();\n        setProperty(key, props.get(key));\n    }\n}",
      "function_after": "public void combine(ExtendedProperties props) {\n    for (Iterator it = props.getKeys(); it.hasNext();) {\n        String key = (String) it.next();\n        super.put(key, props.get(key));\n    }\n}"
    },
    "file": {
      "file_name": "ExtendedProperties.java",
      "file_path": "src/java/org/apache/commons/collections/ExtendedProperties.java",
      "file_nloc": 776,
      "file_complexity": 211,
      "file_token_count": 5248,
      "file_before": "",
      "file_after": ""
    }
  },
  "43": {
    "id": 43,
    "project_name": "commons-collections",
    "project_url": "https://github.com/apache/commons-collections.git",
    "defects4j_id": 26,
    "buggy_line_location": 277,
    "buggy_line_content": "private Object readResolve() {",
    "fixed_line_location": 277,
    "fixed_line_content": "protected Object readResolve() {",
    "bug_description_link": "https://issues.apache.org/jira/browse/COLLECTIONS-576",
    "in_function": true,
    "commit": {
      "commit_id": "f8bd75d37ca12c5d49c1b628c33c0b45e2d082eb",
      "commit_message": "[COLLECTIONS-576] Fix de-serialization of MultiKey subclasses: hashcode was not re-calculated. Thanks to Stephan Roch.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/collections/trunk@1705620 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Thomas Neidhart",
      "commit_parent": "3a9c4718ee0fd2eeef8b3ce151ee829fadbef5ae",
      "commit_date": "2015-09-28 08:53:44",
      "commit_file_diff": "@@ -274,7 +274,7 @@ public class MultiKey<K> implements Serializable {\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+    protected Object readResolve() {\n         calculateHashCode(keys);\n         return this;\n     }\n"
    },
    "function": {
      "function_name": "readResolve",
      "function_parent": "MultiKey::readResolve()",
      "function_before_start_line": 277,
      "function_before_end_line": 280,
      "function_after_start_line": 277,
      "function_after_end_line": 280,
      "function_before_token_count": 13,
      "function_after_token_count": 13,
      "function_before": "private Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}",
      "function_after": "protected Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}"
    },
    "file": {
      "file_name": "MultiKey.java",
      "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java",
      "file_nloc": 81,
      "file_complexity": 20,
      "file_token_count": 519,
      "file_before": "",
      "file_after": ""
    }
  },
  "44": {
    "id": 44,
    "project_name": "commons-compress",
    "project_url": "https://github.com/apache/commons-compress.git",
    "defects4j_id": 19,
    "buggy_line_location": 259,
    "buggy_line_content": "if (rawCentralDirectoryData.length != expectedLength) {",
    "fixed_line_location": 259,
    "fixed_line_content": "if (rawCentralDirectoryData.length < expectedLength) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/COMPRESS-228",
    "in_function": true,
    "commit": {
      "commit_id": "e860d2f3eb16d84e146a8a700d9dbd3af01df4ba",
      "commit_message": "COMPRESS-228 be more lenient when parsing zip64 extra field\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/compress/trunk@1486437 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Stefan Bodewig",
      "commit_parent": "ed534048b12afcffd45a53f7b0945f49d929a29a",
      "commit_date": "2013-05-26 17:36:35",
      "commit_file_diff": "@@ -242,7 +242,7 @@ public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n      * field with knowledge which fields are expected to be there.\n      *\n      * <p>All four fields inside the zip64 extended information extra\n-     * field are optional and only present if their corresponding\n+     * field are optional and must only be present if their corresponding\n      * entry inside the central directory contains the correct magic\n      * value.</p>\n      */\n@@ -256,7 +256,7 @@ public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                 + (hasCompressedSize ? DWORD : 0)\n                 + (hasRelativeHeaderOffset ? DWORD : 0)\n                 + (hasDiskStart ? WORD : 0);\n-            if (rawCentralDirectoryData.length != expectedLength) {\n+            if (rawCentralDirectoryData.length < expectedLength) {\n                 throw new ZipException(\"central directory zip64 extended\"\n                                        + \" information extra field's length\"\n                                        + \" doesn't match central directory\"\n"
    },
    "function": {
      "function_name": "reparseCentralDirectoryData",
      "function_parent": "Zip64ExtendedInformationExtraField::reparseCentralDirectoryData( boolean hasUncompressedSize , boolean hasCompressedSize , boolean hasRelativeHeaderOffset , boolean hasDiskStart)",
      "function_before_start_line": 249,
      "function_before_end_line": 287,
      "function_after_start_line": 249,
      "function_after_end_line": 287,
      "function_before_token_count": 177,
      "function_after_token_count": 177,
      "function_before": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length != expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + expectedLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}",
      "function_after": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length < expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + expectedLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}"
    },
    "file": {
      "file_name": "Zip64ExtendedInformationExtraField.java",
      "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java",
      "file_nloc": 180,
      "file_complexity": 50,
      "file_token_count": 1062,
      "file_before": "",
      "file_after": ""
    }
  },
  "45": {
    "id": 45,
    "project_name": "commons-compress",
    "project_url": "https://github.com/apache/commons-compress.git",
    "defects4j_id": 23,
    "buggy_line_location": 112,
    "buggy_line_content": "dictSize |= (coder.properties[i + 1] << (8 * i));",
    "fixed_line_location": 112,
    "fixed_line_content": "dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);",
    "bug_description_link": "https://issues.apache.org/jira/browse/COMPRESS-256",
    "in_function": true,
    "commit": {
      "commit_id": "cbb5a1ad9b0b80f717ee71dc0fc765afdc1601c0",
      "commit_message": "COMPRESS-256 bad calculation of LZMA dictionary sizes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/compress/trunk@1560252 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Stefan Bodewig",
      "commit_parent": "71e4eeadcfc5eb390eca1142fc1f6ee5b1b4d5c1",
      "commit_date": "2014-01-22 05:13:34",
      "commit_file_diff": "@@ -109,7 +109,7 @@ InputStream decode(final InputStream in, final Coder coder,\n             byte propsByte = coder.properties[0];\n             long dictSize = coder.properties[1];\n             for (int i = 1; i < 4; i++) {\n-                dictSize |= (coder.properties[i + 1] << (8 * i));\n+                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n             }\n             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                 throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n"
    },
    "function": {
      "function_name": "decode",
      "function_parent": "Coders::LZMADecoder::decode( final InputStream in , final Coder coder , byte [ ] password)",
      "function_before_start_line": 107,
      "function_before_end_line": 118,
      "function_after_start_line": 107,
      "function_after_end_line": 118,
      "function_before_token_count": 109,
      "function_after_token_count": 111,
      "function_before": "InputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] << (8 * i));\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}",
      "function_after": "InputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}"
    },
    "file": {
      "file_name": "Coders.java",
      "file_path": "src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java",
      "file_nloc": 224,
      "file_complexity": 34,
      "file_token_count": 1563,
      "file_before": "",
      "file_after": ""
    }
  },
  "46": {
    "id": 46,
    "project_name": "commons-compress",
    "project_url": "https://github.com/apache/commons-compress.git",
    "defects4j_id": 38,
    "buggy_line_location": 859,
    "buggy_line_content": "if (getName().endsWith(\"/\")) {",
    "fixed_line_location": 859,
    "fixed_line_content": "if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/COMPRESS-356",
    "in_function": true,
    "commit": {
      "commit_id": "823cdee9b18508e9e51913d110a20a406f55582b",
      "commit_message": "COMPRESS-356 properly deal with PAX header entries ending in slash\n\nSuggested-by: Jeremy Gustie <jeremy at gustie dot com>",
      "commit_author": "Stefan Bodewig",
      "commit_parent": "19a620c904587dc0397b43bfe9071ff60033c097",
      "commit_date": "2016-05-20 18:42:10",
      "commit_file_diff": "@@ -856,7 +856,7 @@ public boolean isDirectory() {\n             return true;\n         }\n \n-        if (getName().endsWith(\"/\")) {\n+        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n             return true;\n         }\n \n"
    },
    "function": {
      "function_name": "isDirectory",
      "function_parent": "TarArchiveEntry::isDirectory()",
      "function_before_start_line": 850,
      "function_before_end_line": 864,
      "function_after_start_line": 850,
      "function_after_end_line": 864,
      "function_before_token_count": 50,
      "function_after_token_count": 60,
      "function_before": "public boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n\n    return false;\n}",
      "function_after": "public boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n\n    if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n        return true;\n    }\n\n    return false;\n}"
    },
    "file": {
      "file_name": "TarArchiveEntry.java",
      "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java",
      "file_nloc": 523,
      "file_complexity": 141,
      "file_token_count": 3262,
      "file_before": "",
      "file_after": ""
    }
  },
  "47": {
    "id": 47,
    "project_name": "commons-csv",
    "project_url": "https://github.com/apache/commons-csv.git",
    "defects4j_id": 4,
    "buggy_line_location": 288,
    "buggy_line_content": "return new LinkedHashMap<String, Integer>(this.headerMap);",
    "fixed_line_location": 288,
    "fixed_line_content": "return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);",
    "bug_description_link": "https://issues.apache.org/jira/browse/CSV-100",
    "in_function": true,
    "commit": {
      "commit_id": "22601f647f2ce9a05fa4ce20ea356492c670940c",
      "commit_message": "[CSV-100] CSVParser: getHeaderMap throws NPE.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1524435 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_parent": "2b5f84ede12cfadd7946ffb07a56709b8322a02f",
      "commit_date": "2013-09-18 14:57:57",
      "commit_file_diff": "@@ -281,11 +281,11 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * Returns a copy of the header map that iterates in column order.\n      * <p>\n      * The map keys are column names. The map values are 0-based indices.\n-     *\n+     * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "getHeaderMap",
      "function_parent": "CSVParser::getHeaderMap()",
      "function_before_start_line": 287,
      "function_before_end_line": 289,
      "function_after_start_line": 287,
      "function_after_end_line": 289,
      "function_before_token_count": 19,
      "function_after_token_count": 27,
      "function_before": "public Map<String, Integer> getHeaderMap() {\n    return new LinkedHashMap<String, Integer>(this.headerMap);\n}",
      "function_after": "public Map<String, Integer> getHeaderMap() {\n    return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n}"
    },
    "file": {
      "file_name": "CSVParser.java",
      "file_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "file_nloc": 187,
      "file_complexity": 42,
      "file_token_count": 1287,
      "file_before": "",
      "file_after": ""
    }
  },
  "48": {
    "id": 48,
    "project_name": "commons-csv",
    "project_url": "https://github.com/apache/commons-csv.git",
    "defects4j_id": 11,
    "buggy_line_location": 384,
    "buggy_line_content": "final boolean emptyHeader = header.trim().isEmpty();",
    "fixed_line_location": 384,
    "fixed_line_content": "final boolean emptyHeader = header == null || header.trim().isEmpty();",
    "bug_description_link": "https://issues.apache.org/jira/browse/CSV-122",
    "in_function": true,
    "commit": {
      "commit_id": "b67524da7fd146634c7112b23e95d1d45c398b82",
      "commit_message": "CSV-122: NullPointerException when empty header string and and null string of \"\". Thanks to Mike Lewis.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1609768 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Benedikt Ritter",
      "commit_parent": "d3afa156e4ddf8ec76847504988e7979146d9fd6",
      "commit_date": "2014-07-11 18:42:48",
      "commit_file_diff": "@@ -381,7 +381,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n"
    },
    "function": {
      "function_name": "initializeHeader",
      "function_parent": "CSVParser::initializeHeader()",
      "function_before_start_line": 359,
      "function_before_end_line": 394,
      "function_after_start_line": 359,
      "function_after_end_line": 394,
      "function_before_token_count": 238,
      "function_after_token_count": 242,
      "function_before": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}",
      "function_after": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header == null || header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}"
    },
    "file": {
      "file_name": "CSVParser.java",
      "file_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
      "file_nloc": 199,
      "file_complexity": 47,
      "file_token_count": 1414,
      "file_before": "",
      "file_after": ""
    }
  },
  "49": {
    "id": 49,
    "project_name": "commons-csv",
    "project_url": "https://github.com/apache/commons-csv.git",
    "defects4j_id": 14,
    "buggy_line_location": 1039,
    "buggy_line_content": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
    "fixed_line_location": 1039,
    "fixed_line_content": "if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/CSV-171",
    "in_function": true,
    "commit": {
      "commit_id": "190390bf5dd83d6137ca3045902fcecbeafa3227",
      "commit_message": "[CSV-171] Negative numeric values in the first column are always quoted\nin minimal mode.",
      "commit_author": "Gary Gregory",
      "commit_parent": "1023690dc284afaf380b0cf3eb74c411e0663465",
      "commit_date": "2016-07-31 00:21:35",
      "commit_file_diff": "@@ -1035,8 +1035,8 @@ public final class CSVFormat implements Serializable {\n             } else {\n                 char c = value.charAt(pos);\n \n-                // TODO where did this rule come from?\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n+                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n"
    },
    "function": {
      "function_name": "printAndQuote",
      "function_parent": "CSVFormat::printAndQuote( final Object object , final CharSequence value , final int offset , final int len , final Appendable out , final boolean newRecord)",
      "function_before_start_line": 1001,
      "function_before_end_line": 1106,
      "function_after_start_line": 1001,
      "function_after_end_line": 1106,
      "function_before_token_count": 430,
      "function_after_token_count": 430,
      "function_before": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // TODO where did this rule come from?\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
      "function_after": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}"
    },
    "file": {
      "file_name": "CSVFormat.java",
      "file_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
      "file_nloc": 678,
      "file_complexity": 206,
      "file_token_count": 4824,
      "file_before": "",
      "file_after": ""
    }
  },
  "50": {
    "id": 50,
    "project_name": "gson",
    "project_url": "https://github.com/google/gson.git",
    "defects4j_id": 13,
    "buggy_line_location": 731,
    "buggy_line_content": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {",
    "fixed_line_location": 731,
    "fixed_line_content": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {",
    "bug_description_link": "https://github.com/google/gson/issues/1053",
    "in_function": true,
    "commit": {
      "commit_id": "9a2421997e83ec803c88ea370a2d102052699d3b",
      "commit_message": "negative zero test and fix (#1069)",
      "commit_author": "Michele Vivoda",
      "commit_parent": "41e48f7aa3a686778e95328693b830856538e9e3",
      "commit_date": "2017-04-19 14:26:36",
      "commit_file_diff": "@@ -728,7 +728,7 @@ public class JsonReader implements Closeable {\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n"
    },
    "function": {
      "function_name": "peekNumber",
      "function_parent": "JsonReader::peekNumber()",
      "function_before_start_line": 641,
      "function_before_end_line": 742,
      "function_after_start_line": 641,
      "function_after_end_line": 742,
      "function_before_token_count": 438,
      "function_after_token_count": 448,
      "function_before": "private int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}",
      "function_after": "private int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}"
    },
    "file": {
      "file_name": "JsonReader.java",
      "file_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
      "file_nloc": 1081,
      "file_complexity": 365,
      "file_token_count": 5932,
      "file_before": "",
      "file_after": ""
    }
  },
  "51": {
    "id": 51,
    "project_name": "gson",
    "project_url": "https://github.com/google/gson.git",
    "defects4j_id": 15,
    "buggy_line_location": 494,
    "buggy_line_content": "if (Double.isNaN(value) || Double.isInfinite(value)) {",
    "fixed_line_location": 495,
    "fixed_line_content": "if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {",
    "bug_description_link": "https://github.com/google/gson/issues/1090",
    "in_function": true,
    "commit": {
      "commit_id": "ada597e69a78b8b99f79f79493cbf51e16045202",
      "commit_message": "value(double) can write NaN and infinite values when lenient, as value(Number) does (#1093)\n\n* Added test which shows that lenient JsonWriter fails writing infinite primitive doubles, but does not fail writing boxed doubles, as stated in #1090.\r\n\r\n* Fixed JsonWriter#value(double) to write infinite and NaN values when lenient, as JsonWriter#value(Number) does. (fixes #1090)",
      "commit_author": "Mike",
      "commit_parent": "0aaef0fd1bb1b9729543dc40168adfb829eb75a4",
      "commit_date": "2017-05-31 09:50:44",
      "commit_file_diff": "@@ -491,10 +491,10 @@ public class JsonWriter implements Closeable, Flushable {\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+    writeDeferredName();\n+    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n-    writeDeferredName();\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n"
    },
    "function": {
      "function_name": "value",
      "function_parent": "JsonWriter::value( double value)",
      "function_before_start_line": 493,
      "function_before_end_line": 501,
      "function_after_start_line": 493,
      "function_after_end_line": 501,
      "function_before_token_count": 59,
      "function_after_token_count": 64,
      "function_before": "public JsonWriter value(double value) throws IOException {\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  writeDeferredName();\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}",
      "function_after": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}"
    },
    "file": {
      "file_name": "JsonWriter.java",
      "file_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
      "file_nloc": 319,
      "file_complexity": 83,
      "file_token_count": 1797,
      "file_before": "",
      "file_after": ""
    }
  },
  "52": {
    "id": 52,
    "project_name": "jackson-core",
    "project_url": "https://github.com/FasterXML/jackson-core.git",
    "defects4j_id": 5,
    "buggy_line_location": 193,
    "buggy_line_content": "char c = str.charAt(i++);",
    "fixed_line_location": 193,
    "fixed_line_content": "char c = str.charAt(i);",
    "bug_description_link": "https://github.com/FasterXML/jackson-core/issues/173",
    "in_function": true,
    "commit": {
      "commit_id": "0d9cd9fa434c0070638332b7f2243af0277461eb",
      "commit_message": "Fix #173",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "bfdc2852923f671452c66ddf261c87e7e2e5b497",
      "commit_date": "2014-12-07 10:16:55",
      "commit_file_diff": "@@ -190,7 +190,7 @@ public class JsonPointer\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+            char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n"
    },
    "function": {
      "function_name": "_parseIndex",
      "function_parent": "JsonPointer::_parseIndex( String str)",
      "function_before_start_line": 185,
      "function_before_end_line": 205,
      "function_after_start_line": 185,
      "function_after_end_line": 205,
      "function_before_token_count": 116,
      "function_after_token_count": 115,
      "function_before": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    // [Issue#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i++);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
      "function_after": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    // [Issue#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}"
    },
    "file": {
      "file_name": "JsonPointer.java",
      "file_path": "src/main/java/com/fasterxml/jackson/core/JsonPointer.java",
      "file_nloc": 127,
      "file_complexity": 47,
      "file_token_count": 872,
      "file_before": "",
      "file_after": ""
    }
  },
  "53": {
    "id": 53,
    "project_name": "jackson-core",
    "project_url": "https://github.com/FasterXML/jackson-core.git",
    "defects4j_id": 8,
    "buggy_line_location": 307,
    "buggy_line_content": "if (!_hasSegments)  return _currentSegment;",
    "fixed_line_location": 307,
    "fixed_line_content": "if (!_hasSegments && _currentSegment != null)  return _currentSegment;",
    "bug_description_link": "https://github.com/FasterXML/jackson-core/issues/182",
    "in_function": true,
    "commit": {
      "commit_id": "11f0b4090937b2aa998734aa2bf032ee8c428e84",
      "commit_message": "Always return empty array instead of null for empty buffer\n\nFixes #182",
      "commit_author": "Masaru Hasegawa",
      "commit_parent": "ac6d8e22847c19b2695cbd7d1f418e07a9a3dbb2",
      "commit_date": "2015-02-19 10:59:06",
      "commit_file_diff": "@@ -304,7 +304,7 @@ public final class TextBuffer\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n"
    },
    "function": {
      "function_name": "getTextBuffer",
      "function_parent": "TextBuffer::getTextBuffer()",
      "function_before_start_line": 298,
      "function_before_end_line": 310,
      "function_after_start_line": 298,
      "function_after_end_line": 310,
      "function_before_token_count": 55,
      "function_after_token_count": 59,
      "function_before": "public char[] getTextBuffer()\n{\n    // Are we just using shared input buffer?\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!_hasSegments)  return _currentSegment;\n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}",
      "function_after": "public char[] getTextBuffer()\n{\n    // Are we just using shared input buffer?\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}"
    },
    "file": {
      "file_name": "TextBuffer.java",
      "file_path": "src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java",
      "file_nloc": 411,
      "file_complexity": 103,
      "file_token_count": 2308,
      "file_before": "",
      "file_after": ""
    }
  },
  "54": {
    "id": 54,
    "project_name": "jackson-core",
    "project_url": "https://github.com/FasterXML/jackson-core.git",
    "defects4j_id": 25,
    "buggy_line_location": 1963,
    "buggy_line_content": "if (i <= maxCode) {",
    "fixed_line_location": 1963,
    "fixed_line_content": "if (i < maxCode) {",
    "bug_description_link": "https://github.com/FasterXML/jackson-core/pull/510",
    "in_function": true,
    "commit": {
      "commit_id": "ad47c206f4fbf22f439f3d66871757891f549f6a",
      "commit_message": "Fix #510",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "3d3dedc656e331ab1a9e28efcde96bf71c347daa",
      "commit_date": "2019-01-16 23:06:00",
      "commit_file_diff": "@@ -1960,7 +1960,7 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+            if (i < maxCode) {\n                 if (codes[i] != 0) {\n                     break;\n                 }\n"
    },
    "function": {
      "function_name": "_handleOddName2",
      "function_parent": "ReaderBasedJsonParser::_handleOddName2( int startPtr , int hash , int [ ] codes)",
      "function_before_start_line": 1948,
      "function_before_end_line": 1990,
      "function_after_start_line": 1948,
      "function_after_end_line": 1990,
      "function_before_token_count": 239,
      "function_after_token_count": 239,
      "function_before": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}",
      "function_after": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}"
    },
    "file": {
      "file_name": "ReaderBasedJsonParser.java",
      "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
      "file_nloc": 2239,
      "file_complexity": 715,
      "file_token_count": 11908,
      "file_before": "",
      "file_after": ""
    }
  },
  "55": {
    "id": 55,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 16,
    "buggy_line_location": 109,
    "buggy_line_content": "return (previous != null) && previous.equals(ann);",
    "fixed_line_location": 112,
    "fixed_line_content": "return (previous == null) || !previous.equals(ann);",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/771",
    "in_function": true,
    "commit": {
      "commit_id": "db612bb3839581d0a88297667880cad548c018b1",
      "commit_message": "Fix #771",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "6dcb13f70fb1c68b0c055bfb1dae2b296ae67b03",
      "commit_date": "2015-04-26 22:42:17",
      "commit_file_diff": "@@ -82,6 +82,9 @@ public final class AnnotationMap implements Annotations\n \n     /**\n      * Method called to add specified annotation in the Map.\n+     * \n+     * @return True if the addition changed the contents, that is, this map did not\n+     *   already have specified annotation\n      */\n     public boolean add(Annotation ann) {\n         return _add(ann);\n@@ -106,7 +109,7 @@ public final class AnnotationMap implements Annotations\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+        return (previous == null) || !previous.equals(ann);\n     }\n }\n \n"
    },
    "function": {
      "function_name": "_add",
      "function_parent": "AnnotationMap::_add( Annotation ann)",
      "function_before_start_line": 104,
      "function_before_end_line": 110,
      "function_after_start_line": 107,
      "function_after_end_line": 113,
      "function_before_token_count": 58,
      "function_after_token_count": 59,
      "function_before": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return (previous != null) && previous.equals(ann);\n}",
      "function_after": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return (previous == null) || !previous.equals(ann);\n}"
    },
    "file": {
      "file_name": "AnnotationMap.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java",
      "file_nloc": 74,
      "file_complexity": 27,
      "file_token_count": 482,
      "file_before": "",
      "file_after": ""
    }
  },
  "56": {
    "id": 56,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 17,
    "buggy_line_location": 178,
    "buggy_line_content": "|| TreeNode.class.isAssignableFrom(t.getRawClass());",
    "fixed_line_location": 180,
    "fixed_line_content": "&& !TreeNode.class.isAssignableFrom(t.getRawClass()));",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/793",
    "in_function": true,
    "commit": {
      "commit_id": "a143c05db7a911f98f8bf59beb13cfcb7689395d",
      "commit_message": "Fix #793",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "7db1f44069bbcac9d884d829f8052a89b5ec271b",
      "commit_date": "2015-05-14 20:56:50",
      "commit_file_diff": "@@ -173,9 +173,12 @@ public class ObjectMapper\n                 }\n                 // fall through\n             case OBJECT_AND_NON_CONCRETE:\n-                return (t.getRawClass() == Object.class) || !t.isConcrete()\n-                        // [Issue#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass());\n+//                return t.isJavaLangObject() || \n+                return (t.getRawClass() == Object.class)\n+                        || (!t.isConcrete()\n+                                // [databind#88] Should not apply to JSON tree models:\n+                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n+\n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n@@ -184,6 +187,7 @@ public class ObjectMapper\n                 return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n             default:\n             //case JAVA_LANG_OBJECT:\n+//                return t.isJavaLangObject();\n                 return (t.getRawClass() == Object.class);\n             }\n         }\n"
    },
    "function": {
      "function_name": "useForType",
      "function_parent": "ObjectMapper::DefaultTypeResolverBuilder::useForType( JavaType t)",
      "function_before_start_line": 167,
      "function_before_end_line": 189,
      "function_after_start_line": 167,
      "function_after_end_line": 193,
      "function_before_token_count": 128,
      "function_after_token_count": 131,
      "function_before": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        // fall through\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class) || !t.isConcrete()\n                // [Issue#88] Should not apply to JSON tree models:\n                || TreeNode.class.isAssignableFrom(t.getRawClass());\n    case NON_FINAL:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        // [Issue#88] Should not apply to JSON tree models:\n        return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n    default:\n    //case JAVA_LANG_OBJECT:\n        return (t.getRawClass() == Object.class);\n    }\n}",
      "function_after": "        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }"
    },
    "file": {
      "file_name": "ObjectMapper.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
      "file_nloc": 1424,
      "file_complexity": 294,
      "file_token_count": 9216,
      "file_before": "",
      "file_after": ""
    }
  },
  "57": {
    "id": 57,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 27,
    "buggy_line_location": 792,
    "buggy_line_content": "if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {",
    "fixed_line_location": 794,
    "fixed_line_content": "if (ext.handlePropertyValue(p, ctxt, propName, null)) {",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/928",
    "in_function": true,
    "commit": {
      "commit_id": "f2f611e701c63c8e98e59f315641bd2bf2921aea",
      "commit_message": "Fix #928",
      "commit_author": "Cowtowncoder",
      "commit_parent": "d485ea7da49ed949c81f23513d01d67e170d2a1b",
      "commit_date": "2015-09-11 17:29:17",
      "commit_file_diff": "@@ -789,7 +789,9 @@ public class BeanDeserializer\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n+                //   since it is not the bean\n+                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n"
    },
    "function": {
      "function_name": "deserializeUsingPropertyBasedWithExternalTypeId",
      "function_parent": "BeanDeserializer::deserializeUsingPropertyBasedWithExternalTypeId( JsonParser p , DeserializationContext ctxt)",
      "function_before_start_line": 774,
      "function_before_end_line": 855,
      "function_after_start_line": 774,
      "function_after_end_line": 857,
      "function_before_token_count": 435,
      "function_after_token_count": 435,
      "function_before": "protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // first: let's check to see if this might be part of value with external type id:\n            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                ;\n            } else {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; // never gets here\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                        //   it's too complicated, so bail out\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return ext.complete(p, ctxt, bean);\n                }\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        // external type id (or property that depends on it)?\n        if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n            continue;\n        }\n        /* As per [JACKSON-313], things marked as ignorable should not be\n         * passed to any setter\n         */\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        // \"any property\"?\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n\n    // We hit END_OBJECT; resolve the pieces:\n    try {\n        return ext.complete(p, ctxt, buffer, creator);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; // never gets here\n    }\n}",
      "function_after": "protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // first: let's check to see if this might be part of value with external type id:\n            // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n            //   since it is not the bean\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                ;\n            } else {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; // never gets here\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                        //   it's too complicated, so bail out\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return ext.complete(p, ctxt, bean);\n                }\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        // external type id (or property that depends on it)?\n        if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n            continue;\n        }\n        /* As per [JACKSON-313], things marked as ignorable should not be\n         * passed to any setter\n         */\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        // \"any property\"?\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n\n    // We hit END_OBJECT; resolve the pieces:\n    try {\n        return ext.complete(p, ctxt, buffer, creator);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; // never gets here\n    }\n}"
    },
    "file": {
      "file_name": "BeanDeserializer.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java",
      "file_nloc": 632,
      "file_complexity": 159,
      "file_token_count": 3980,
      "file_before": "",
      "file_after": ""
    }
  },
  "58": {
    "id": 58,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 34,
    "buggy_line_location": 81,
    "buggy_line_content": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
    "fixed_line_location": 81,
    "fixed_line_content": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/1045",
    "in_function": true,
    "commit": {
      "commit_id": "6b471c37efce0a3205dff387efd3473980be648f",
      "commit_message": "Fix #1045",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "5e924b21f6f55a918aed08927f8088ddd35ccfa5",
      "commit_date": "2015-12-12 11:29:04",
      "commit_file_diff": "@@ -78,7 +78,7 @@ public class NumberSerializer\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n"
    },
    "function": {
      "function_name": "acceptJsonFormatVisitor",
      "function_parent": "NumberSerializer::acceptJsonFormatVisitor( JsonFormatVisitorWrapper visitor , JavaType typeHint)",
      "function_before_start_line": 74,
      "function_before_end_line": 87,
      "function_after_start_line": 74,
      "function_after_end_line": 87,
      "function_before_token_count": 75,
      "function_after_token_count": 75,
      "function_before": "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            // otherwise bit unclear what to call... but let's try:\n            /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n        }\n    }\n}",
      "function_after": "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else {\n            // otherwise bit unclear what to call... but let's try:\n            /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n        }\n    }\n}"
    },
    "file": {
      "file_name": "NumberSerializer.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java",
      "file_nloc": 61,
      "file_complexity": 15,
      "file_token_count": 447,
      "file_before": "",
      "file_after": ""
    }
  },
  "59": {
    "id": 59,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 37,
    "buggy_line_location": 126,
    "buggy_line_content": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,",
    "fixed_line_location": 135,
    "fixed_line_content": "return new SimpleType(subclass, _bindings, this, _superInterfaces,",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/1083",
    "in_function": true,
    "commit": {
      "commit_id": "dbf0c6f4c93d922a2ebb4d744661e7090fef2aac",
      "commit_message": "Fix #1083",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "d5e12f74d2224574ef1e220decc514073303ac5c",
      "commit_date": "2016-01-15 21:02:56",
      "commit_file_diff": "@@ -123,7 +123,16 @@ public class SimpleType // note: until 2.6 was final\n             return this;\n         }\n         // Should we check that there is a sub-class relationship?\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n+        //    placeholder values, so no.\n+        /*\n+        if (!_class.isAssignableFrom(subclass)) {\n+            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n+                    +_class.getName());\n+        }\n+        */\n+        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n+        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n"
    },
    "function": {
      "function_name": "_narrow",
      "function_parent": "SimpleType::_narrow( Class <?> subclass)",
      "function_before_start_line": 120,
      "function_before_end_line": 128,
      "function_after_start_line": 120,
      "function_after_end_line": 137,
      "function_before_token_count": 38,
      "function_after_token_count": 38,
      "function_before": "protected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n            _valueHandler, _typeHandler, _asStatic);\n}",
      "function_after": "protected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values, so no.\n    /*\n    if (!_class.isAssignableFrom(subclass)) {\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n    }\n    */\n    // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n    return new SimpleType(subclass, _bindings, this, _superInterfaces,\n            _valueHandler, _typeHandler, _asStatic);\n}"
    },
    "file": {
      "file_name": "SimpleType.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java",
      "file_nloc": 154,
      "file_complexity": 37,
      "file_token_count": 953,
      "file_before": "",
      "file_after": ""
    }
  },
  "60": {
    "id": 60,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 46,
    "buggy_line_location": 156,
    "buggy_line_content": "sb.append(';');",
    "fixed_line_location": 156,
    "fixed_line_content": "sb.append(\">;\");",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/1194",
    "in_function": true,
    "commit": {
      "commit_id": "cb6717764c0460f560e1b09478faa4dac692e8f3",
      "commit_message": "Fix #1194",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "d32563c559da846e386b86bbf664b82eadab7c82",
      "commit_date": "2016-04-11 21:01:14",
      "commit_file_diff": "@@ -153,7 +153,7 @@ public class ReferenceType extends SimpleType\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+        sb.append(\">;\");\n         return sb;\n     }\n     \n"
    },
    "function": {
      "function_name": "getGenericSignature",
      "function_parent": "ReferenceType::getGenericSignature( StringBuilder sb)",
      "function_before_start_line": 151,
      "function_before_end_line": 158,
      "function_after_start_line": 151,
      "function_after_end_line": 158,
      "function_before_token_count": 42,
      "function_after_token_count": 42,
      "function_before": "public StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(';');\n    return sb;\n}",
      "function_after": "public StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}"
    },
    "file": {
      "file_name": "ReferenceType.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java",
      "file_nloc": 133,
      "file_complexity": 30,
      "file_token_count": 693,
      "file_before": "",
      "file_after": ""
    }
  },
  "61": {
    "id": 61,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 57,
    "buggy_line_location": 1441,
    "buggy_line_content": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),",
    "fixed_line_location": 1441,
    "fixed_line_content": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/1362",
    "in_function": true,
    "commit": {
      "commit_id": "bbd8190030022df404a8f7c47c1bc32e990cb0d2",
      "commit_message": "Fix #1362",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "1d930db6a1407a873af65deecf4290e4c4238e94",
      "commit_date": "2016-09-01 18:36:27",
      "commit_file_diff": "@@ -1438,7 +1438,8 @@ public class ObjectReader\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n+        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n+                true));\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "readValues",
      "function_parent": "ObjectReader::readValues( byte [ ] src , int offset , int length)",
      "function_before_start_line": 1435,
      "function_before_end_line": 1442,
      "function_after_start_line": 1435,
      "function_after_end_line": 1443,
      "function_before_token_count": 60,
      "function_after_token_count": 64,
      "function_before": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n}",
      "function_after": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n            true));\n}"
    },
    "file": {
      "file_name": "ObjectReader.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectReader.java",
      "file_nloc": 894,
      "file_complexity": 203,
      "file_token_count": 5722,
      "file_before": "",
      "file_after": ""
    }
  },
  "62": {
    "id": 62,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 70,
    "buggy_line_location": 437,
    "buggy_line_content": "found = key.equals(prop.getName());",
    "fixed_line_location": 440,
    "fixed_line_content": "found = key.equals(_hashArea[i-1]);",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/1493",
    "in_function": true,
    "commit": {
      "commit_id": "d7155de6c37db3301b92b755bd0a02388f7dd07f",
      "commit_message": "Fix #1493",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "7fe2d4f1aaab61e41f31f792f8a988157a34b34c",
      "commit_date": "2017-01-09 21:38:36",
      "commit_file_diff": "@@ -92,7 +92,7 @@ public class BeanPropertyMap\n     protected void init(Collection<SettableBeanProperty> props)\n     {\n         _size = props.size();\n-        \n+\n         // First: calculate size of primary hash area\n         final int hashSize = findSize(_size);\n         _hashMask = hashSize-1;\n@@ -423,7 +423,8 @@ System.err.println(\"And new propr #\"+slot+\" '\"+key+\"'\");\n      * Specialized method for removing specified existing entry.\n      * NOTE: entry MUST exist, otherwise an exception is thrown.\n      */\n-    public void remove(SettableBeanProperty propToRm) {\n+    public void remove(SettableBeanProperty propToRm)\n+    {\n         ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n         String key = getPropertyName(propToRm);\n         boolean found = false;\n@@ -434,7 +435,9 @@ System.err.println(\"And new propr #\"+slot+\" '\"+key+\"'\");\n                 continue;\n             }\n             if (!found) {\n-                found = key.equals(prop.getName());\n+                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n+                //   as only former is lower-case in case-insensitive case\n+                found = key.equals(_hashArea[i-1]);\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n"
    },
    "function": {
      "function_name": "remove",
      "function_parent": "BeanPropertyMap::remove( SettableBeanProperty propToRm)",
      "function_before_start_line": 426,
      "function_before_end_line": 450,
      "function_after_start_line": 426,
      "function_after_end_line": 453,
      "function_before_token_count": 151,
      "function_after_token_count": 152,
      "function_before": "public void remove(SettableBeanProperty propToRm) {\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            found = key.equals(prop.getName());\n            if (found) {\n                // need to leave a hole here\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}",
      "function_after": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n            //   as only former is lower-case in case-insensitive case\n            found = key.equals(_hashArea[i-1]);\n            if (found) {\n                // need to leave a hole here\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}"
    },
    "file": {
      "file_name": "BeanPropertyMap.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java",
      "file_nloc": 376,
      "file_complexity": 96,
      "file_token_count": 2530,
      "file_before": "",
      "file_after": ""
    }
  },
  "63": {
    "id": 63,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 71,
    "buggy_line_location": 75,
    "buggy_line_content": "if (raw == String.class || raw == Object.class) {",
    "fixed_line_location": 75,
    "fixed_line_content": "if (raw == String.class || raw == Object.class || raw == CharSequence.class) {",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/1506",
    "in_function": true,
    "commit": {
      "commit_id": "23a733207bc88a06ee486a5896b7b0c4ebbbfef4",
      "commit_message": "Fix #1506",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "d44600d3750e5dba9fac68aee7248ed2a80a2225",
      "commit_date": "2017-01-24 18:58:19",
      "commit_file_diff": "@@ -72,7 +72,7 @@ public class StdKeyDeserializer extends KeyDeserializer\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n"
    },
    "function": {
      "function_name": "forType",
      "function_parent": "StdKeyDeserializer::forType( Class <?> raw)",
      "function_before_start_line": 70,
      "function_before_end_line": 116,
      "function_after_start_line": 70,
      "function_after_end_line": 116,
      "function_before_token_count": 330,
      "function_after_token_count": 336,
      "function_before": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n\n    // first common types:\n    if (raw == String.class || raw == Object.class) {\n        return StringKD.forType(raw);\n    } else if (raw == UUID.class) {\n        kind = TYPE_UUID;\n    } else if (raw == Integer.class) {\n        kind = TYPE_INT;\n    } else if (raw == Long.class) {\n        kind = TYPE_LONG;\n    } else if (raw == Date.class) {\n        kind = TYPE_DATE;\n    } else if (raw == Calendar.class) {\n        kind = TYPE_CALENDAR;\n    // then less common ones...\n    } else if (raw == Boolean.class) {\n        kind = TYPE_BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = TYPE_BYTE;\n    } else if (raw == Character.class) {\n        kind = TYPE_CHAR;\n    } else if (raw == Short.class) {\n        kind = TYPE_SHORT;\n    } else if (raw == Float.class) {\n        kind = TYPE_FLOAT;\n    } else if (raw == Double.class) {\n        kind = TYPE_DOUBLE;\n    } else if (raw == URI.class) {\n        kind = TYPE_URI;\n    } else if (raw == URL.class) {\n        kind = TYPE_URL;\n    } else if (raw == Class.class) {\n        kind = TYPE_CLASS;\n    } else if (raw == Locale.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n    } else if (raw == Currency.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(kind, raw);\n}",
      "function_after": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n\n    // first common types:\n    if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n        return StringKD.forType(raw);\n    } else if (raw == UUID.class) {\n        kind = TYPE_UUID;\n    } else if (raw == Integer.class) {\n        kind = TYPE_INT;\n    } else if (raw == Long.class) {\n        kind = TYPE_LONG;\n    } else if (raw == Date.class) {\n        kind = TYPE_DATE;\n    } else if (raw == Calendar.class) {\n        kind = TYPE_CALENDAR;\n    // then less common ones...\n    } else if (raw == Boolean.class) {\n        kind = TYPE_BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = TYPE_BYTE;\n    } else if (raw == Character.class) {\n        kind = TYPE_CHAR;\n    } else if (raw == Short.class) {\n        kind = TYPE_SHORT;\n    } else if (raw == Float.class) {\n        kind = TYPE_FLOAT;\n    } else if (raw == Double.class) {\n        kind = TYPE_DOUBLE;\n    } else if (raw == URI.class) {\n        kind = TYPE_URI;\n    } else if (raw == URL.class) {\n        kind = TYPE_URL;\n    } else if (raw == Class.class) {\n        kind = TYPE_CLASS;\n    } else if (raw == Locale.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n    } else if (raw == Currency.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(kind, raw);\n}"
    },
    "file": {
      "file_name": "StdKeyDeserializer.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
      "file_nloc": 319,
      "file_complexity": 84,
      "file_token_count": 2007,
      "file_before": "",
      "file_after": ""
    }
  },
  "64": {
    "id": 64,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 82,
    "buggy_line_location": 495,
    "buggy_line_content": "ignored = ignorals.getIgnored();",
    "fixed_line_location": 495,
    "fixed_line_content": "ignored = ignorals.findIgnoredForDeserialization();",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/1595",
    "in_function": true,
    "commit": {
      "commit_id": "4a2b1ae08ded66b77e05bf8fa0ac8a2e8c60709d",
      "commit_message": "Fix #1595 for 2.8.9",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "dec4a483d9d70a8e7d14e28474058ef50df1204d",
      "commit_date": "2017-05-04 12:48:52",
      "commit_file_diff": "@@ -492,7 +492,7 @@ public class BeanDeserializerFactory\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+            ignored = ignorals.findIgnoredForDeserialization();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n"
    },
    "function": {
      "function_name": "addBeanProps",
      "function_parent": "BeanDeserializerFactory::addBeanProps( DeserializationContext ctxt , BeanDescription beanDesc , BeanDeserializerBuilder builder)",
      "function_before_start_line": 472,
      "function_before_end_line": 615,
      "function_after_start_line": 472,
      "function_after_end_line": 615,
      "function_before_token_count": 731,
      "function_after_token_count": 731,
      "function_before": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    }\n    else {\n    \tanySetterField = beanDesc.findAnySetterField();\n    \tif(anySetterField != null) {\n    \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n    \t}\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            /* If property is passed via constructor parameter, we must\n             * handle things in special way. Not sure what is the most optimal way...\n             * for now, let's just call a (new) method in builder, which does nothing.\n             */\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                        \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                        name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}",
      "function_after": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.findIgnoredForDeserialization();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    }\n    else {\n    \tanySetterField = beanDesc.findAnySetterField();\n    \tif(anySetterField != null) {\n    \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n    \t}\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            /* If property is passed via constructor parameter, we must\n             * handle things in special way. Not sure what is the most optimal way...\n             * for now, let's just call a (new) method in builder, which does nothing.\n             */\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                        \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                        name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}"
    },
    "file": {
      "file_name": "BeanDeserializerFactory.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
      "file_nloc": 574,
      "file_complexity": 125,
      "file_token_count": 4026,
      "file_before": "",
      "file_after": ""
    }
  },
  "65": {
    "id": 65,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 96,
    "buggy_line_location": 731,
    "buggy_line_content": "paramName = candidate.findImplicitParamName(0);",
    "fixed_line_location": 735,
    "fixed_line_content": "paramName = candidate.paramName(0);",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/2051",
    "in_function": true,
    "commit": {
      "commit_id": "dd57a2dd576a77423553c197df109a5b60c1c669",
      "commit_message": "Fix #2051",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "31153568b58a29979dd0c416d14833886f9216a9",
      "commit_date": "2018-05-25 15:46:15",
      "commit_file_diff": "@@ -728,7 +728,11 @@ nonAnnotatedParamIndex, ctor);\n         if (!useProps && (paramDef != null)) {\n             // One more thing: if implicit name matches property with a getter\n             // or field, we'll consider it property-based as well\n-            paramName = candidate.findImplicitParamName(0);\n+\n+            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n+            //    not implicit name, but name with possible strategy-based-rename\n+//            paramName = candidate.findImplicitParamName(0);\n+            paramName = candidate.paramName(0);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n"
    },
    "function": {
      "function_name": "_addExplicitAnyCreator",
      "function_parent": "BasicDeserializerFactory::_addExplicitAnyCreator( DeserializationContext ctxt , BeanDescription beanDesc , CreatorCollector creators , CreatorCandidate candidate)",
      "function_before_start_line": 701,
      "function_before_end_line": 748,
      "function_after_start_line": 701,
      "function_after_end_line": 752,
      "function_before_token_count": 262,
      "function_after_token_count": 262,
      "function_before": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n    if (1 != candidate.paramCount()) {\n        // Ok: for delegates, we want one and exactly one parameter without\n        // injection AND without name\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            // getting close; but most not have name\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n    // If there's injection or explicit name, should be properties-based\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n        // One more thing: if implicit name matches property with a getter\n        // or field, we'll consider it property-based as well\n        paramName = candidate.findImplicitParamName(0);\n        useProps = (paramName != null) && paramDef.couldSerialize();\n    }\n    if (useProps) {\n        SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n        };\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n    // one more thing: sever link to creator property, to avoid possible later\n    // problems with \"unresolved\" constructor property\n    if (paramDef != null) {\n        ((POJOPropertyBuilder) paramDef).removeConstructors();\n    }\n}",
      "function_after": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }"
    },
    "file": {
      "file_name": "BasicDeserializerFactory.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
      "file_nloc": 1514,
      "file_complexity": 368,
      "file_token_count": 10017,
      "file_before": "",
      "file_after": ""
    }
  },
  "66": {
    "id": 66,
    "project_name": "jackson-databind",
    "project_url": "https://github.com/FasterXML/jackson-databind.git",
    "defects4j_id": 107,
    "buggy_line_location": 165,
    "buggy_line_content": "return null;",
    "fixed_line_location": 165,
    "fixed_line_content": "return NullifyingDeserializer.instance;",
    "bug_description_link": "https://github.com/FasterXML/jackson-databind/issues/2221",
    "in_function": true,
    "commit": {
      "commit_id": "f3a1798076d9dc71883d317c8e97c4e033fcee98",
      "commit_message": "Fix #2221",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "96ec23b2bb19b4d4b4530fee6ff08cd248d32a33",
      "commit_date": "2019-01-17 22:38:33",
      "commit_file_diff": "@@ -161,8 +161,8 @@ public abstract class TypeDeserializerBase\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n-                        // TODO: try to figure out something better\n-                        return null;\n+                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n+                        return NullifyingDeserializer.instance;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n"
    },
    "function": {
      "function_name": "_findDeserializer",
      "function_parent": "TypeDeserializerBase::_findDeserializer( DeserializationContext ctxt , String typeId)",
      "function_before_start_line": 146,
      "function_before_end_line": 199,
      "function_after_start_line": 146,
      "function_after_end_line": 199,
      "function_before_token_count": 178,
      "function_after_token_count": 180,
      "function_before": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
      "function_after": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return NullifyingDeserializer.instance;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}"
    },
    "file": {
      "file_name": "TypeDeserializerBase.java",
      "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
      "file_nloc": 165,
      "file_complexity": 30,
      "file_token_count": 1058,
      "file_before": "",
      "file_after": ""
    }
  },
  "67": {
    "id": 67,
    "project_name": "jackson-dataformat-xml",
    "project_url": "https://github.com/FasterXML/jackson-dataformat-xml.git",
    "defects4j_id": 5,
    "buggy_line_location": 57,
    "buggy_line_content": "_rootNameLookup = src._rootNameLookup;",
    "fixed_line_location": 59,
    "fixed_line_content": "_rootNameLookup = new XmlRootNameLookup();",
    "bug_description_link": "https://github.com/FasterXML/jackson-dataformat-xml/issues/282",
    "in_function": true,
    "commit": {
      "commit_id": "8aa276ba6b2092a562195f9a94eb562686a3352c",
      "commit_message": "Fix #282",
      "commit_author": "Tatu Saloranta",
      "commit_parent": "ce61138456e10580c6bf78bc4009de926105c4d6",
      "commit_date": "2018-05-21 12:28:21",
      "commit_file_diff": "@@ -54,7 +54,9 @@ public class XmlSerializerProvider extends DefaultSerializerProvider\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n-        _rootNameLookup = src._rootNameLookup;\n+        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n+        //    root name lookup as that may link back to diff version, configuration\n+        _rootNameLookup = new XmlRootNameLookup();\n     }\n \n     /*\n"
    },
    "function": {
      "function_name": "XmlSerializerProvider",
      "function_parent": "XmlSerializerProvider::XmlSerializerProvider( XmlSerializerProvider src)",
      "function_before_start_line": 55,
      "function_before_end_line": 58,
      "function_after_start_line": 55,
      "function_after_end_line": 60,
      "function_before_token_count": 18,
      "function_after_token_count": 19,
      "function_before": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    _rootNameLookup = src._rootNameLookup;\n}",
      "function_after": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n    //    root name lookup as that may link back to diff version, configuration\n    _rootNameLookup = new XmlRootNameLookup();\n}"
    },
    "file": {
      "file_name": "XmlSerializerProvider.java",
      "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java",
      "file_nloc": 183,
      "file_complexity": 40,
      "file_token_count": 1095,
      "file_before": "",
      "file_after": ""
    }
  },
  "68": {
    "id": 68,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 32,
    "buggy_line_location": 1138,
    "buggy_line_content": "clone.classNames();",
    "fixed_line_location": 1138,
    "fixed_line_content": "clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/278",
    "in_function": true,
    "commit": {
      "commit_id": "0e37cba87eea9d89156c144e3d4298c9c9ed04d4",
      "commit_message": "Don't clone the element's classnames\n\nFixes #278",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "fa87a8fe2838e80ae0eeba6e2978815ef5533e91",
      "commit_date": "2012-12-23 14:03:05",
      "commit_file_diff": "@@ -1135,7 +1135,7 @@ public class Element extends Node {\n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames(); // creates linked set of class names from class attribute\n+        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n         return clone;\n     }\n }\n"
    },
    "function": {
      "function_name": "clone",
      "function_parent": "Element::clone()",
      "function_before_start_line": 1136,
      "function_before_end_line": 1140,
      "function_after_start_line": 1136,
      "function_after_end_line": 1140,
      "function_before_token_count": 26,
      "function_after_token_count": 26,
      "function_before": "public Element clone() {\n    Element clone = (Element) super.clone();\n    clone.classNames(); // creates linked set of class names from class attribute\n    return clone;\n}",
      "function_after": "public Element clone() {\n    Element clone = (Element) super.clone();\n    clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n    return clone;\n}"
    },
    "file": {
      "file_name": "Element.java",
      "file_path": "src/main/java/org/jsoup/nodes/Element.java",
      "file_nloc": 520,
      "file_complexity": 160,
      "file_token_count": 3601,
      "file_before": "",
      "file_after": ""
    }
  },
  "69": {
    "id": 69,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 34,
    "buggy_line_location": 89,
    "buggy_line_content": "if (offset < length) {",
    "fixed_line_location": 91,
    "fixed_line_content": "if (offset < length && last <= length) {",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/349",
    "in_function": true,
    "commit": {
      "commit_id": "88730bf9f399aab6a150212faeea012598be9ec6",
      "commit_message": "Fixed a crash when reading an unterminated CDATA section.\n\nFixes #349",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "2518e92a052d922d81d11e28b8e5205639fed9a7",
      "commit_date": "2013-10-06 15:36:25",
      "commit_file_diff": "@@ -86,9 +86,9 @@ class CharacterReader {\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n-            if (offset < length) {\n-                int i = offset + 1;\n-                int last = i + seq.length()-1;\n+            int i = offset + 1;\n+            int last = i + seq.length()-1;\n+            if (offset < length && last <= length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n"
    },
    "function": {
      "function_name": "nextIndexOf",
      "function_parent": "CharacterReader::nextIndexOf( CharSequence seq)",
      "function_before_start_line": 82,
      "function_before_end_line": 98,
      "function_after_start_line": 82,
      "function_after_end_line": 98,
      "function_before_token_count": 130,
      "function_after_token_count": 134,
      "function_before": "int nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        if (offset < length) {\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}",
      "function_after": "int nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}"
    },
    "file": {
      "file_name": "CharacterReader.java",
      "file_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
      "file_nloc": 224,
      "file_complexity": 91,
      "file_token_count": 1349,
      "file_before": "",
      "file_after": ""
    }
  },
  "70": {
    "id": 70,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 37,
    "buggy_line_location": 1101,
    "buggy_line_content": "return accum.toString().trim();",
    "fixed_line_location": 1101,
    "fixed_line_content": "return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/368",
    "in_function": true,
    "commit": {
      "commit_id": "c07ba8a34b6a6d6665928e106fea67bd9144e4e0",
      "commit_message": "If pretty-print is disabled, don't trim outer whitespace in Element.html()\n\nFixes #368",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "be64f746f9f034e524f8d9bfb9748d19054c8772",
      "commit_date": "2013-11-16 16:48:43",
      "commit_file_diff": "@@ -1097,8 +1097,8 @@ public class Element extends Node {\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n-        html(accum); \n-        return accum.toString().trim();\n+        html(accum);\n+        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n     }\n \n     private void html(StringBuilder accum) {\n"
    },
    "function": {
      "function_name": "html",
      "function_parent": "Element::html()",
      "function_before_start_line": 1098,
      "function_before_end_line": 1102,
      "function_after_start_line": 1098,
      "function_after_end_line": 1102,
      "function_before_token_count": 29,
      "function_after_token_count": 43,
      "function_before": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum); \n    return accum.toString().trim();\n}",
      "function_after": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n}"
    },
    "file": {
      "file_name": "Element.java",
      "file_path": "src/main/java/org/jsoup/nodes/Element.java",
      "file_nloc": 523,
      "file_complexity": 166,
      "file_token_count": 3682,
      "file_before": "",
      "file_after": ""
    }
  },
  "71": {
    "id": 71,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 43,
    "buggy_line_location": 574,
    "buggy_line_content": "if (element.equals(search))",
    "fixed_line_location": 574,
    "fixed_line_content": "if (element == search)",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/554",
    "in_function": true,
    "commit": {
      "commit_id": "11f7c1bd7a2d12f0b1150aa246c61afefd11991f",
      "commit_message": "Search for element siblings by identity not content\n\nFixes #554, #561",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "373ea35b2cb227b56694aa50589c853b68caa03a",
      "commit_date": "2015-04-21 22:11:28",
      "commit_file_diff": "@@ -571,7 +571,7 @@ public class Element extends Node {\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+            if (element == search)\n                 return i;\n         }\n         return null;\n"
    },
    "function": {
      "function_name": "indexInList",
      "function_parent": "Element::indexInList( Element search , List<E> elements)",
      "function_before_start_line": 568,
      "function_before_end_line": 578,
      "function_after_start_line": 568,
      "function_after_end_line": 578,
      "function_before_token_count": 72,
      "function_after_token_count": 69,
      "function_before": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search))\n            return i;\n    }\n    return null;\n}",
      "function_after": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element == search)\n            return i;\n    }\n    return null;\n}"
    },
    "file": {
      "file_name": "Element.java",
      "file_path": "src/main/java/org/jsoup/nodes/Element.java",
      "file_nloc": 547,
      "file_complexity": 178,
      "file_token_count": 3977,
      "file_before": "",
      "file_after": ""
    }
  },
  "72": {
    "id": 72,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 45,
    "buggy_line_location": 394,
    "buggy_line_content": "} else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {",
    "fixed_line_location": 394,
    "fixed_line_content": "} else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/575",
    "in_function": true,
    "commit": {
      "commit_id": "3b4f9dfa91b6f1852c35baf79c4a13eacc6112c3",
      "commit_message": "Fix table insertion into TH tags\n\nFixes #575",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "5be8b081ce931865d46b49ed44e19d3eafde748d",
      "commit_date": "2015-07-05 21:21:02",
      "commit_file_diff": "@@ -391,7 +391,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n"
    },
    "function": {
      "function_name": "resetInsertionMode",
      "function_parent": "HtmlTreeBuilder::resetInsertionMode()",
      "function_before_start_line": 382,
      "function_before_end_line": 429,
      "function_after_start_line": 382,
      "function_after_end_line": 429,
      "function_before_token_count": 339,
      "function_after_token_count": 339,
      "function_before": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; // frag\n        } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; // frag\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; // frag\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; // frag\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        }\n    }\n}",
      "function_after": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; // frag\n        } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; // frag\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; // frag\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; // frag\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        }\n    }\n}"
    },
    "file": {
      "file_name": "HtmlTreeBuilder.java",
      "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
      "file_nloc": 568,
      "file_complexity": 175,
      "file_token_count": 3918,
      "file_before": "",
      "file_after": ""
    }
  },
  "73": {
    "id": 73,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 46,
    "buggy_line_location": 118,
    "buggy_line_content": "accum.append(c);",
    "fixed_line_location": 118,
    "fixed_line_content": "accum.append(\"&#xa0;\");",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/523",
    "in_function": true,
    "commit": {
      "commit_id": "3ba88d8c2ab500c07f9e2ddbc07a4bd01fadbd78",
      "commit_message": "Fixed &nbsp; for XHTML in Shift_JS\n\nFixes #523",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "ddf4c1bcae69ad48c01eea207e3f3c24d2eda208",
      "commit_date": "2015-07-05 23:45:23",
      "commit_file_diff": "@@ -115,7 +115,7 @@ public class Entities {\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+                            accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         if (!inAttribute)\n"
    },
    "function": {
      "function_name": "escape",
      "function_parent": "Entities::escape( StringBuilder accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite)",
      "function_before_start_line": 79,
      "function_before_end_line": 154,
      "function_after_start_line": 79,
      "function_after_end_line": 154,
      "function_before_token_count": 457,
      "function_after_token_count": 457,
      "function_before": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
      "function_after": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}"
    },
    "file": {
      "file_name": "Entities.java",
      "file_path": "src/main/java/org/jsoup/nodes/Entities.java",
      "file_nloc": 186,
      "file_complexity": 43,
      "file_token_count": 1298,
      "file_before": "",
      "file_after": ""
    }
  },
  "74": {
    "id": 74,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 47,
    "buggy_line_location": 121,
    "buggy_line_content": "if (!inAttribute)",
    "fixed_line_location": 122,
    "fixed_line_content": "if (!inAttribute || escapeMode == EscapeMode.xhtml)",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/528",
    "in_function": true,
    "commit": {
      "commit_id": "a025d87deb9cc4cda49ae1b77feb0f29805dd7c5",
      "commit_message": "Escape < in XML attributes\n\nFixes #528",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "1e09df66f0302958d547037e7258913b3069f2b6",
      "commit_date": "2015-07-13 23:11:21",
      "commit_file_diff": "@@ -118,7 +118,8 @@ public class Entities {\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n-                        if (!inAttribute)\n+                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n+                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n"
    },
    "function": {
      "function_name": "escape",
      "function_parent": "Entities::escape( StringBuilder accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite)",
      "function_before_start_line": 79,
      "function_before_end_line": 154,
      "function_after_start_line": 79,
      "function_after_end_line": 155,
      "function_before_token_count": 457,
      "function_after_token_count": 463,
      "function_before": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
      "function_after": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}"
    },
    "file": {
      "file_name": "Entities.java",
      "file_path": "src/main/java/org/jsoup/nodes/Entities.java",
      "file_nloc": 186,
      "file_complexity": 44,
      "file_token_count": 1304,
      "file_before": "",
      "file_after": ""
    }
  },
  "75": {
    "id": 75,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 51,
    "buggy_line_location": 300,
    "buggy_line_content": "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');",
    "fixed_line_location": 300,
    "fixed_line_content": "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/667",
    "in_function": true,
    "commit": {
      "commit_id": "25e0e1e9ffca9a350d060db7d2179c5c9e459055",
      "commit_message": "Added support for unicode letters in tags\n\nFixes #667",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "8b38cd812802397dfcbaddb34cde9ac27f0fde22",
      "commit_date": "2016-04-05 17:05:20",
      "commit_file_diff": "@@ -297,7 +297,7 @@ final class CharacterReader {\n         if (isEmpty())\n             return false;\n         char c = input[pos];\n-        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n     }\n \n     boolean matchesDigit() {\n"
    },
    "function": {
      "function_name": "matchesLetter",
      "function_parent": "CharacterReader::matchesLetter()",
      "function_before_start_line": 296,
      "function_before_end_line": 301,
      "function_after_start_line": 296,
      "function_after_end_line": 301,
      "function_before_token_count": 43,
      "function_after_token_count": 50,
      "function_before": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
      "function_after": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n}"
    },
    "file": {
      "file_name": "CharacterReader.java",
      "file_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
      "file_nloc": 305,
      "file_complexity": 124,
      "file_token_count": 1906,
      "file_before": "",
      "file_after": ""
    }
  },
  "76": {
    "id": 76,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 57,
    "buggy_line_location": 124,
    "buggy_line_content": "attributes.remove(attrKey);",
    "fixed_line_location": 125,
    "fixed_line_content": "it.remove();",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/759",
    "in_function": true,
    "commit": {
      "commit_id": "2c58e975ab00eb369ee3dfbba07a4a78a1ef9e19",
      "commit_message": "Remove attributes using iterator to avoid CMEs.\n\nFixes #759",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "c28e5bf53a9ce9e32ab84ce2e6eba87ec747d1a0",
      "commit_date": "2016-10-26 12:58:24",
      "commit_file_diff": "@@ -119,9 +119,10 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n         Validate.notEmpty(key);\n         if (attributes == null)\n             return;\n-        for (String attrKey : attributes.keySet()) {\n+        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n+            String attrKey = it.next();\n             if (attrKey.equalsIgnoreCase(key))\n-                attributes.remove(attrKey);\n+                it.remove();\n         }\n     }\n \n"
    },
    "function": {
      "function_name": "removeIgnoreCase",
      "function_parent": "Attributes::removeIgnoreCase( String key)",
      "function_before_start_line": 118,
      "function_before_end_line": 126,
      "function_after_start_line": 118,
      "function_after_end_line": 127,
      "function_before_token_count": 51,
      "function_after_token_count": 73,
      "function_before": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (String attrKey : attributes.keySet()) {\n        if (attrKey.equalsIgnoreCase(key))\n            attributes.remove(attrKey);\n    }\n}",
      "function_after": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}"
    },
    "file": {
      "file_name": "Attributes.java",
      "file_path": "src/main/java/org/jsoup/nodes/Attributes.java",
      "file_nloc": 208,
      "file_complexity": 66,
      "file_token_count": 1414,
      "file_before": "",
      "file_after": ""
    }
  },
  "77": {
    "id": 77,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 61,
    "buggy_line_location": 1092,
    "buggy_line_content": "final String classAttr = attributes.get(\"class\");",
    "fixed_line_location": 1092,
    "fixed_line_content": "final String classAttr = attributes.getIgnoreCase(\"class\");",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/814",
    "in_function": true,
    "commit": {
      "commit_id": "83f01fd864e59fa69c894da06f4a15489222d401",
      "commit_message": "Access the class attribute case-insensitiviely\n\nFixes #814",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "b6dda00bc19f6d3bc4009a6b9a4a932de9640bd4",
      "commit_date": "2017-01-21 15:26:56",
      "commit_file_diff": "@@ -1089,7 +1089,7 @@ public class Element extends Node {\n      */\n     // performance sensitive\n     public boolean hasClass(String className) {\n-        final String classAttr = attributes.get(\"class\");\n+        final String classAttr = attributes.getIgnoreCase(\"class\");\n         final int len = classAttr.length();\n         final int wantLen = className.length();\n \n"
    },
    "function": {
      "function_name": "hasClass",
      "function_parent": "Element::hasClass( String className)",
      "function_before_start_line": 1091,
      "function_before_end_line": 1132,
      "function_after_start_line": 1091,
      "function_after_end_line": 1132,
      "function_before_token_count": 198,
      "function_after_token_count": 198,
      "function_before": "public boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}",
      "function_after": "public boolean hasClass(String className) {\n    final String classAttr = attributes.getIgnoreCase(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}"
    },
    "file": {
      "file_name": "Element.java",
      "file_path": "src/main/java/org/jsoup/nodes/Element.java",
      "file_nloc": 601,
      "file_complexity": 186,
      "file_token_count": 4320,
      "file_before": "",
      "file_after": ""
    }
  },
  "78": {
    "id": 78,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 62,
    "buggy_line_location": 764,
    "buggy_line_content": "String name = t.asEndTag().normalName();",
    "fixed_line_location": 764,
    "fixed_line_content": "String name = t.asEndTag().name(); // matches with case sensitivity if enabled",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/819",
    "in_function": true,
    "commit": {
      "commit_id": "b934c5d3e30917de86796c89fcb7cd000f642a80",
      "commit_message": "Make sure unkown tags close correctly when in insensitive case mode\n\nFixes #819",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "2f6eabc9f0999421acf032c79f3106215c013580",
      "commit_date": "2017-06-10 15:51:45",
      "commit_file_diff": "@@ -761,7 +761,7 @@ enum HtmlTreeBuilderState {\n         }\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n-            String name = t.asEndTag().normalName();\n+            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n             ArrayList<Element> stack = tb.getStack();\n             for (int pos = stack.size() -1; pos >= 0; pos--) {\n                 Element node = stack.get(pos);\n"
    },
    "function": {
      "function_name": "anyOtherEndTag",
      "function_parent": "anyOtherEndTag( Token t , HtmlTreeBuilder tb)",
      "function_before_start_line": 763,
      "function_before_end_line": 782,
      "function_after_start_line": 763,
      "function_after_end_line": 782,
      "function_before_token_count": 150,
      "function_after_token_count": 150,
      "function_before": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n    String name = t.asEndTag().normalName();\n    ArrayList<Element> stack = tb.getStack();\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (node.nodeName().equals(name)) {\n            tb.generateImpliedEndTags(name);\n            if (!name.equals(tb.currentElement().nodeName()))\n                tb.error(this);\n            tb.popStackToClose(name);\n            break;\n        } else {\n            if (tb.isSpecial(node)) {\n                tb.error(this);\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "function_after": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n    String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n    ArrayList<Element> stack = tb.getStack();\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (node.nodeName().equals(name)) {\n            tb.generateImpliedEndTags(name);\n            if (!name.equals(tb.currentElement().nodeName()))\n                tb.error(this);\n            tb.popStackToClose(name);\n            break;\n        } else {\n            if (tb.isSpecial(node)) {\n                tb.error(this);\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    },
    "file": {
      "file_name": "HtmlTreeBuilderState.java",
      "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
      "file_nloc": 1414,
      "file_complexity": 429,
      "file_token_count": 11382,
      "file_before": "",
      "file_after": ""
    }
  },
  "79": {
    "id": 79,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 77,
    "buggy_line_location": 117,
    "buggy_line_content": "String elName = endTag.name();",
    "fixed_line_location": 117,
    "fixed_line_content": "String elName = endTag.normalName();",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/998",
    "in_function": true,
    "commit": {
      "commit_id": "df272b77c2cf89e9cbe2512bbddf8a3bc28a704b",
      "commit_message": "In XML parse mode set to lowercase, normalize closing tags\n\nFixes #998",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "bf4f99c72ba3d59486e0decb59a2b87edee4f1ff",
      "commit_date": "2017-12-22 10:25:08",
      "commit_file_diff": "@@ -114,7 +114,7 @@ public class XmlTreeBuilder extends TreeBuilder {\n      * @param endTag tag to close\n      */\n     private void popStackToClose(Token.EndTag endTag) {\n-        String elName = endTag.name();\n+        String elName = endTag.normalName();\n         Element firstFound = null;\n \n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n"
    },
    "function": {
      "function_name": "popStackToClose",
      "function_parent": "XmlTreeBuilder::popStackToClose( Token . EndTag endTag)",
      "function_before_start_line": 116,
      "function_before_end_line": 136,
      "function_after_start_line": 116,
      "function_after_end_line": 136,
      "function_before_token_count": 131,
      "function_after_token_count": 131,
      "function_before": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}",
      "function_after": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.normalName();\n    Element firstFound = null;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}"
    },
    "file": {
      "file_name": "XmlTreeBuilder.java",
      "file_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
      "file_nloc": 111,
      "file_complexity": 30,
      "file_token_count": 845,
      "file_before": "",
      "file_after": ""
    }
  },
  "80": {
    "id": 80,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 86,
    "buggy_line_location": 78,
    "buggy_line_content": "if (doc.childNodeSize() > 0) {",
    "fixed_line_location": 78,
    "fixed_line_content": "if (doc.children().size() > 0) {",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/1139",
    "in_function": true,
    "commit": {
      "commit_id": "38c13b5ae97c294afb859c49ded903beb7b9b100",
      "commit_message": "Correct check for element children\n\nFixes #1139",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "973234bc842b0de2febea195f7819236b57fd992",
      "commit_date": "2018-12-22 18:19:31",
      "commit_file_diff": "@@ -75,7 +75,7 @@ public class Comment extends LeafNode {\n         String data = getData();\n         Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n         XmlDeclaration decl = null;\n-        if (doc.childNodeSize() > 0) {\n+        if (doc.children().size() > 0) {\n             Element el = doc.child(0);\n             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n             decl.attributes().addAll(el.attributes());\n"
    },
    "function": {
      "function_name": "asXmlDeclaration",
      "function_parent": "Comment::asXmlDeclaration()",
      "function_before_start_line": 74,
      "function_before_end_line": 84,
      "function_after_start_line": 74,
      "function_after_end_line": 84,
      "function_before_token_count": 127,
      "function_after_token_count": 131,
      "function_before": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    if (doc.childNodeSize() > 0) {\n        Element el = doc.child(0);\n        decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n        decl.attributes().addAll(el.attributes());\n    }\n    return decl;\n}",
      "function_after": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    if (doc.children().size() > 0) {\n        Element el = doc.child(0);\n        decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n        decl.attributes().addAll(el.attributes());\n    }\n    return decl;\n}"
    },
    "file": {
      "file_name": "Comment.java",
      "file_path": "src/main/java/org/jsoup/nodes/Comment.java",
      "file_nloc": 47,
      "file_complexity": 13,
      "file_token_count": 353,
      "file_before": "",
      "file_after": ""
    }
  },
  "81": {
    "id": 81,
    "project_name": "jsoup",
    "project_url": "https://github.com/jhy/jsoup.git",
    "defects4j_id": 88,
    "buggy_line_location": 80,
    "buggy_line_content": "return val;",
    "fixed_line_location": 80,
    "fixed_line_content": "return Attributes.checkNotNull(val);",
    "bug_description_link": "https://github.com/jhy/jsoup/issues/1065",
    "in_function": true,
    "commit": {
      "commit_id": "8b837a43cbe2c12624ab2088dc4ff9a725af5f4d",
      "commit_message": "Return null attribute values as empty string\n\nPrevious / defined behaviour.\n\nFixes #1065",
      "commit_author": "Jonathan Hedley",
      "commit_parent": "8adcd55d8abe4c84ae2dcffb9a882abc4143bb93",
      "commit_date": "2018-12-23 22:02:59",
      "commit_file_diff": "@@ -77,7 +77,7 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      @return the attribute value\n      */\n     public String getValue() {\n-        return val;\n+        return Attributes.checkNotNull(val);\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "getValue",
      "function_parent": "Attribute::getValue()",
      "function_before_start_line": 79,
      "function_before_end_line": 81,
      "function_after_start_line": 79,
      "function_after_end_line": 81,
      "function_before_token_count": 8,
      "function_after_token_count": 13,
      "function_before": "public String getValue() {\n    return val;\n}",
      "function_after": "public String getValue() {\n    return Attributes.checkNotNull(val);\n}"
    },
    "file": {
      "file_name": "Attribute.java",
      "file_path": "src/main/java/org/jsoup/nodes/Attribute.java",
      "file_nloc": 126,
      "file_complexity": 41,
      "file_token_count": 962,
      "file_before": "",
      "file_after": ""
    }
  },
  "82": {
    "id": 82,
    "project_name": "commons-jxpath",
    "project_url": "https://github.com/apache/commons-jxpath.git",
    "defects4j_id": 10,
    "buggy_line_location": 42,
    "buggy_line_content": "return compute(args[0].computeValue(context), args[1].computeValue(context))",
    "fixed_line_location": 42,
    "fixed_line_content": "return compute(args[0].compute(context), args[1].compute(context))",
    "bug_description_link": "https://issues.apache.org/jira/browse/JXPATH-93",
    "in_function": true,
    "commit": {
      "commit_id": "3b3e58d3d35aaa7e8e35c0856611f4bfc3f291c7",
      "commit_message": "[JXPATH-93] fix nodeset handling for <,>,<=,>=\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@556124 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Matthew Jason Benson",
      "commit_parent": "1860d750670f46e64c276bae92d93f545dfb5bd5",
      "commit_date": "2007-07-13 19:43:38",
      "commit_file_diff": "@@ -39,8 +39,8 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1]\n-                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n+        return compute(args[0].compute(context), args[1].compute(context))\n+                ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n"
    },
    "function": {
      "function_name": "computeValue",
      "function_parent": "CoreOperationRelationalExpression::computeValue( EvalContext context)",
      "function_before_start_line": 41,
      "function_before_end_line": 44,
      "function_after_start_line": 41,
      "function_after_end_line": 44,
      "function_before_token_count": 39,
      "function_after_token_count": 39,
      "function_before": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].computeValue(context), args[1]\n            .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n}",
      "function_after": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].compute(context), args[1].compute(context))\n            ? Boolean.TRUE : Boolean.FALSE;\n}"
    },
    "file": {
      "file_name": "CoreOperationRelationalExpression.java",
      "file_path": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java",
      "file_nloc": 82,
      "file_complexity": 26,
      "file_token_count": 559,
      "file_before": "",
      "file_after": ""
    }
  },
  "83": {
    "id": 83,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 6,
    "buggy_line_location": 95,
    "buggy_line_content": "pos += Character.charCount(Character.codePointAt(input, pos));",
    "fixed_line_location": 95,
    "fixed_line_content": "pos += Character.charCount(Character.codePointAt(input, pt));",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-857",
    "in_function": true,
    "commit": {
      "commit_id": "52bcd9b8e82d4d1d287b0d75df1e161aff8c65ab",
      "commit_message": "[LANG-857] StringIndexOutOfBoundsException in CharSequenceTranslator.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1411850 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_parent": "f5a83bb90cf7b318ac72823e6b99d01d060abe41",
      "commit_date": "2012-11-20 20:45:50",
      "commit_file_diff": "@@ -92,7 +92,7 @@ public final void translate(CharSequence input, Writer out) throws IOException {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }\n"
    },
    "function": {
      "function_name": "translate",
      "function_parent": "CharSequenceTranslator::translate( CharSequence input , Writer out)",
      "function_before_start_line": 75,
      "function_before_end_line": 98,
      "function_after_start_line": 75,
      "function_after_end_line": 98,
      "function_before_token_count": 145,
      "function_after_token_count": 145,
      "function_before": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }",
      "function_after": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pt));\n            }\n        }\n    }"
    },
    "file": {
      "file_name": "CharSequenceTranslator.java",
      "file_path": "src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java",
      "file_nloc": 51,
      "file_complexity": 11,
      "file_token_count": 361,
      "file_before": "",
      "file_after": ""
    }
  },
  "84": {
    "id": 84,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 16,
    "buggy_line_location": 458,
    "buggy_line_content": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
    "fixed_line_location": 458,
    "fixed_line_content": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-746",
    "in_function": true,
    "commit": {
      "commit_id": "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
      "commit_message": "LANG-746 NumberUtils does not handle upper-case hex: 0X and -0X\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1160660 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Sebastian Bazley",
      "commit_parent": "c98fbe27b2822e669461a061ee916e7ce5bf188f",
      "commit_date": "2011-08-23 12:32:52",
      "commit_file_diff": "@@ -428,7 +428,7 @@ public static short toShort(String str, short defaultValue) {\n      * <code>BigInteger</code> and from <code>Float</code> to\n      * <code>BigDecimal</code>.</p>\n      *\n-     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n+     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n      * will be interpreted as a hexadecimal integer.  Values with leading\n      * <code>0</code>'s will not be interpreted as octal.</p>\n      *\n@@ -438,7 +438,7 @@ public static short toShort(String str, short defaultValue) {\n      * or trailing spaces will generate NumberFormatExceptions.</p>\n      *\n      * @param str  String containing a number, may be null\n-     * @return Number created from the string\n+     * @return Number created from the string (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n     public static Number createNumber(String str) throws NumberFormatException {\n@@ -455,7 +455,7 @@ public static Number createNumber(String str) throws NumberFormatException {\n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n"
    },
    "function": {
      "function_name": "createNumber",
      "function_parent": "NumberUtils::createNumber( String str)",
      "function_before_start_line": 444,
      "function_before_end_line": 594,
      "function_after_start_line": 444,
      "function_after_end_line": 594,
      "function_before_token_count": 796,
      "function_after_token_count": 810,
      "function_before": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
      "function_after": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) { // NOPMD\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}"
    },
    "file": {
      "file_name": "NumberUtils.java",
      "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "file_nloc": 636,
      "file_complexity": 241,
      "file_token_count": 4024,
      "file_before": "",
      "file_after": ""
    }
  },
  "85": {
    "id": 85,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 21,
    "buggy_line_location": 265,
    "buggy_line_content": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
    "fixed_line_location": 265,
    "fixed_line_content": "cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-677",
    "in_function": true,
    "commit": {
      "commit_id": "3e5d5dc9c0a5047152eedb802bc008ce78b8de0c",
      "commit_message": "LANG-677 DateUtils isSameLocalTime() compares the hour using 12hour Calendar.HOUR instead of 24hour Calendar.HOUR_OF_DAY - thanks to Christian\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1066645 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Niall Pemberton",
      "commit_parent": "a655a3fafbc535b09fa0596635d2c87cf48c428e",
      "commit_date": "2011-02-02 21:55:15",
      "commit_file_diff": "@@ -262,7 +262,7 @@ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n"
    },
    "function": {
      "function_name": "isSameLocalTime",
      "function_parent": "DateUtils::isSameLocalTime( Calendar cal1 , Calendar cal2)",
      "function_before_start_line": 258,
      "function_before_end_line": 270,
      "function_after_start_line": 258,
      "function_after_end_line": 270,
      "function_before_token_count": 170,
      "function_after_token_count": 170,
      "function_before": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n            cal1.getClass() == cal2.getClass());\n}",
      "function_after": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n            cal1.getClass() == cal2.getClass());\n}"
    },
    "file": {
      "file_name": "DateUtils.java",
      "file_path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "file_nloc": 582,
      "file_complexity": 176,
      "file_token_count": 4239,
      "file_before": "",
      "file_after": ""
    }
  },
  "86": {
    "id": 86,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 24,
    "buggy_line_location": 1413,
    "buggy_line_content": "return foundDigit && !hasExp;",
    "fixed_line_location": 1413,
    "fixed_line_content": "return foundDigit && !hasExp && !hasDecPoint;",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-664",
    "in_function": true,
    "commit": {
      "commit_id": "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036",
      "commit_message": "Fixing NumberUtils.isNumber so that 1.1L is not considered a number. LANG-664\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1054202 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Henri Yandell",
      "commit_parent": "7df70a8c6b14452767ac932a14640e32a1dc16da",
      "commit_date": "2011-01-01 06:56:59",
      "commit_file_diff": "@@ -1409,8 +1409,8 @@ public static boolean isNumber(String str) {\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n-                // not allowing L with an exponent\n-                return foundDigit && !hasExp;\n+                // not allowing L with an exponent or decimal point\n+                return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n"
    },
    "function": {
      "function_name": "isNumber",
      "function_parent": "NumberUtils::isNumber( String str)",
      "function_before_start_line": 1319,
      "function_before_end_line": 1421,
      "function_after_start_line": 1319,
      "function_after_end_line": 1421,
      "function_before_token_count": 519,
      "function_after_token_count": 522,
      "function_before": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; // str == \"0x\"\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; // don't want to loop to the last char, check it afterwords\n          // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent   \n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; // we need a digit after the E\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return foundDigit;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            // not allowing L with an exponent\n            return foundDigit && !hasExp;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}",
      "function_after": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; // str == \"0x\"\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; // don't want to loop to the last char, check it afterwords\n          // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent   \n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; // we need a digit after the E\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return foundDigit;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            // not allowing L with an exponent or decimal point\n            return foundDigit && !hasExp && !hasDecPoint;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}"
    },
    "file": {
      "file_name": "NumberUtils.java",
      "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "file_nloc": 638,
      "file_complexity": 239,
      "file_token_count": 3999,
      "file_before": "",
      "file_after": ""
    }
  },
  "87": {
    "id": 87,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 26,
    "buggy_line_location": 820,
    "buggy_line_content": "Calendar c = new GregorianCalendar(mTimeZone);",
    "fixed_line_location": 820,
    "fixed_line_content": "Calendar c = new GregorianCalendar(mTimeZone, mLocale);",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-645",
    "in_function": true,
    "commit": {
      "commit_id": "14a0cc2a9baf84a97348263975082ef3857daf97",
      "commit_message": "Applying my fix to LANG-645, and Mikael's test case; fixing the FastDateFormat to properly include the locale when formatting a Date\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@993620 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Henri Yandell",
      "commit_parent": "f7f19a3d2f98f48924d38fec2308dc3db83445d8",
      "commit_date": "2010-09-08 06:09:57",
      "commit_file_diff": "@@ -817,7 +817,7 @@ public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n"
    },
    "function": {
      "function_name": "format",
      "function_parent": "FastDateFormat::format( Date date)",
      "function_before_start_line": 819,
      "function_before_end_line": 823,
      "function_after_start_line": 819,
      "function_after_end_line": 823,
      "function_before_token_count": 39,
      "function_after_token_count": 41,
      "function_before": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(mTimeZone);\n    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
      "function_after": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}"
    },
    "file": {
      "file_name": "FastDateFormat.java",
      "file_path": "src/main/java/org/apache/commons/lang3/time/FastDateFormat.java",
      "file_nloc": 832,
      "file_complexity": 215,
      "file_token_count": 5348,
      "file_before": "",
      "file_after": ""
    }
  },
  "88": {
    "id": 88,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 29,
    "buggy_line_location": 1672,
    "buggy_line_content": "static float toJavaVersionInt(String version) {",
    "fixed_line_location": 1672,
    "fixed_line_content": "static int toJavaVersionInt(String version) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-624",
    "in_function": true,
    "commit": {
      "commit_id": "eb79f7c6f37d0d9c4d9252b1020bc19a617a4d23",
      "commit_message": "(LANG-624) SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM. Oops, fix return type.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@949223 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_parent": "2d9a9ae59fd3b753e05903f63641eff1203f1bd1",
      "commit_date": "2010-05-28 16:33:23",
      "commit_file_diff": "@@ -1669,7 +1669,7 @@ static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n-    static float toJavaVersionInt(String version) {\n+    static int toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }\n \n"
    },
    "function": {
      "function_name": "toJavaVersionInt",
      "function_parent": "SystemUtils::toJavaVersionInt( String version)",
      "function_before_start_line": 1672,
      "function_before_end_line": 1674,
      "function_after_start_line": 1672,
      "function_after_end_line": 1674,
      "function_before_token_count": 18,
      "function_after_token_count": 18,
      "function_before": "static float toJavaVersionInt(String version) {\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}",
      "function_after": "static int toJavaVersionInt(String version) {\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}"
    },
    "file": {
      "file_name": "SystemUtils.java",
      "file_path": "src/main/java/org/apache/commons/lang3/SystemUtils.java",
      "file_nloc": 221,
      "file_complexity": 48,
      "file_token_count": 1775,
      "file_before": "",
      "file_after": ""
    }
  },
  "89": {
    "id": 89,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 33,
    "buggy_line_location": 909,
    "buggy_line_content": "classes[i] = array[i].getClass();",
    "fixed_line_location": 910,
    "fixed_line_content": "classes[i] = array[i] == null ? null : array[i].getClass();",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-587",
    "in_function": true,
    "commit": {
      "commit_id": "8f675dd3cbfb8f552bdbbe1cfc646ba5b367983b",
      "commit_message": "[LANG-587] avoid NPE in ClassUtils.toClass(Object[])\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@907102 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Matthew Jason Benson",
      "commit_parent": "5d5a31a8274ff7e8219ee87fdd15b48c2184ccc0",
      "commit_date": "2010-02-05 21:31:38",
      "commit_file_diff": "@@ -890,7 +890,8 @@ private static String toCanonicalName(String className) {\n     }\n \n     /**\n-     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.</p>\n+     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n+     * If any of these objects is null, a null element will be inserted into the array.</p>\n      *\n      * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n      *\n@@ -906,7 +907,7 @@ public static Class<?>[] toClass(Object[] array) {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            classes[i] = array[i] == null ? null : array[i].getClass();\n         }\n         return classes;\n     }\n"
    },
    "function": {
      "function_name": "toClass",
      "function_parent": "ClassUtils::toClass( Object [ ] array)",
      "function_before_start_line": 901,
      "function_before_end_line": 912,
      "function_after_start_line": 902,
      "function_after_end_line": 913,
      "function_before_token_count": 85,
      "function_after_token_count": 94,
      "function_before": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
      "function_after": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null ? null : array[i].getClass();\n    }\n    return classes;\n}"
    },
    "file": {
      "file_name": "ClassUtils.java",
      "file_path": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
      "file_nloc": 459,
      "file_complexity": 142,
      "file_token_count": 3259,
      "file_before": "",
      "file_after": ""
    }
  },
  "90": {
    "id": 90,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 57,
    "buggy_line_location": 223,
    "buggy_line_content": "return cAvailableLocaleSet.contains(locale);",
    "fixed_line_location": 223,
    "fixed_line_content": "return availableLocaleList().contains(locale);",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-304",
    "in_function": true,
    "commit": {
      "commit_id": "cf20d13c64da51becd1351befe02a06144fd6fc1",
      "commit_message": "Applying test for LANG-304 and fix to LocaleUtils\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@489749 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Henri Yandell",
      "commit_parent": "848a8144bc42fddbbc466a38a897f5c09f0d49e2",
      "commit_date": "2006-12-22 20:34:37",
      "commit_file_diff": "@@ -220,7 +220,7 @@ public static Set availableLocaleSet() {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return availableLocaleList().contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n"
    },
    "function": {
      "function_name": "isAvailableLocale",
      "function_parent": "LocaleUtils::isAvailableLocale( Locale locale)",
      "function_before_start_line": 222,
      "function_before_end_line": 224,
      "function_after_start_line": 222,
      "function_after_end_line": 224,
      "function_before_token_count": 15,
      "function_after_token_count": 17,
      "function_before": "public static boolean isAvailableLocale(Locale locale) {\n    return cAvailableLocaleSet.contains(locale);\n}",
      "function_after": "public static boolean isAvailableLocale(Locale locale) {\n    return availableLocaleList().contains(locale);\n}"
    },
    "file": {
      "file_name": "LocaleUtils.java",
      "file_path": "src/java/org/apache/commons/lang/LocaleUtils.java",
      "file_nloc": 134,
      "file_complexity": 41,
      "file_token_count": 980,
      "file_before": "",
      "file_after": ""
    }
  },
  "91": {
    "id": 91,
    "project_name": "commons-lang",
    "project_url": "https://github.com/apache/commons-lang.git",
    "defects4j_id": 59,
    "buggy_line_location": 884,
    "buggy_line_content": "str.getChars(0, strLen, buffer, size);",
    "fixed_line_location": 884,
    "fixed_line_content": "str.getChars(0, width, buffer, size);",
    "bug_description_link": "https://issues.apache.org/jira/browse/LANG-299",
    "in_function": true,
    "commit": {
      "commit_id": "9b0b19a9162ae8d217b06716962b982703ab4d1b",
      "commit_message": "Applying a unit test for LANG-299 and the fix that Francisco Benavent suggests. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@486377 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Henri Yandell",
      "commit_parent": "aaaa779108e445c028e91372a8c8709c7746cf72",
      "commit_date": "2006-12-12 22:34:39",
      "commit_file_diff": "@@ -881,7 +881,7 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n"
    },
    "function": {
      "function_name": "appendFixedWidthPadRight",
      "function_parent": "StrBuilder::appendFixedWidthPadRight( Object obj , int width , char padChar)",
      "function_before_start_line": 878,
      "function_before_end_line": 895,
      "function_after_start_line": 878,
      "function_after_end_line": 895,
      "function_before_token_count": 134,
      "function_after_token_count": 134,
      "function_before": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "function_after": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    },
    "file": {
      "file_name": "StrBuilder.java",
      "file_path": "src/java/org/apache/commons/lang/text/StrBuilder.java",
      "file_nloc": 1104,
      "file_complexity": 358,
      "file_token_count": 6959,
      "file_before": "",
      "file_after": ""
    }
  },
  "92": {
    "id": 92,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 2,
    "buggy_line_location": 268,
    "buggy_line_content": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
    "fixed_line_location": 268,
    "fixed_line_content": "return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-1021",
    "in_function": true,
    "commit": {
      "commit_id": "f1467e45ab538789090f968f549f88bd0b8c26c7",
      "commit_message": "MATH-1021\nReordering can prevent some overflow occurrences (fix suggested by\nBrian Bloniarz).\nAdded unit test.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1512546 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gilles Sadowski",
      "commit_parent": "6d66a863b5c0049926330ef217accba4e022a1db",
      "commit_date": "2013-08-10 00:57:48",
      "commit_file_diff": "@@ -265,7 +265,7 @@ public class HypergeometricDistribution extends AbstractIntegerDistribution {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "getNumericalMean",
      "function_parent": "HypergeometricDistribution::getNumericalMean()",
      "function_before_start_line": 267,
      "function_before_end_line": 269,
      "function_after_start_line": 267,
      "function_after_end_line": 269,
      "function_before_token_count": 26,
      "function_after_token_count": 23,
      "function_before": "public double getNumericalMean() {\n    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n}",
      "function_after": "public double getNumericalMean() {\n    return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n}"
    },
    "file": {
      "file_name": "HypergeometricDistribution.java",
      "file_path": "src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java",
      "file_nloc": 145,
      "file_complexity": 31,
      "file_token_count": 987,
      "file_before": "",
      "file_after": ""
    }
  },
  "93": {
    "id": 93,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 5,
    "buggy_line_location": 305,
    "buggy_line_content": "return NaN;",
    "fixed_line_location": 305,
    "fixed_line_content": "return INF;",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-934",
    "in_function": true,
    "commit": {
      "commit_id": "724795b5513651e1e34fae3904d1b58229ce9c17",
      "commit_message": "Fixed Complex.reciprocal() for zero argument.\n\nJIRA: MATH-934\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1459927 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_parent": "8c2199df0f613c63bd362303c953cee66712d56c",
      "commit_date": "2013-03-22 18:55:58",
      "commit_file_diff": "@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {\n"
    },
    "function": {
      "function_name": "reciprocal",
      "function_parent": "Complex::reciprocal()",
      "function_before_start_line": 299,
      "function_before_end_line": 321,
      "function_after_start_line": 299,
      "function_after_end_line": 321,
      "function_before_token_count": 127,
      "function_after_token_count": 127,
      "function_before": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n\n    if (isInfinite) {\n        return ZERO;\n    }\n\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}",
      "function_after": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n\n    if (real == 0.0 && imaginary == 0.0) {\n        return INF;\n    }\n\n    if (isInfinite) {\n        return ZERO;\n    }\n\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}"
    },
    "file": {
      "file_name": "Complex.java",
      "file_path": "src/main/java/org/apache/commons/math3/complex/Complex.java",
      "file_nloc": 401,
      "file_complexity": 126,
      "file_token_count": 2689,
      "file_before": "",
      "file_after": ""
    }
  },
  "94": {
    "id": 94,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 11,
    "buggy_line_location": 183,
    "buggy_line_content": "return FastMath.pow(2 * FastMath.PI, -dim / 2) *",
    "fixed_line_location": 183,
    "fixed_line_content": "return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-929",
    "in_function": true,
    "commit": {
      "commit_id": "cedf0d27f9e9341a9e9fa8a192735a0c2e11be40",
      "commit_message": "MATH-929\nFixed truncated value. Thanks to Piotr Wydrych.\nAdded unit test: comparing density values with univariate\nnormal distribution.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1433367 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gilles Sadowski",
      "commit_parent": "fea4dd914bebc7eb4f2b4ec8086f4241a9bd28e6",
      "commit_date": "2013-01-15 12:15:50",
      "commit_file_diff": "@@ -180,7 +180,7 @@ public class MultivariateNormalDistribution\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n"
    },
    "function": {
      "function_name": "density",
      "function_parent": "MultivariateNormalDistribution::density( final double [ ] vals)",
      "function_before_start_line": 177,
      "function_before_end_line": 186,
      "function_after_start_line": 177,
      "function_after_end_line": 186,
      "function_before_token_count": 75,
      "function_after_token_count": 77,
      "function_before": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(vals);\n}",
      "function_after": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n\n    return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(vals);\n}"
    },
    "file": {
      "file_name": "MultivariateNormalDistribution.java",
      "file_path": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java",
      "file_nloc": 115,
      "file_complexity": 22,
      "file_token_count": 965,
      "file_before": "",
      "file_after": ""
    }
  },
  "95": {
    "id": 95,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 27,
    "buggy_line_location": 597,
    "buggy_line_content": "return multiply(100).doubleValue();",
    "fixed_line_location": 597,
    "fixed_line_content": "return 100 * doubleValue();",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-835",
    "in_function": true,
    "commit": {
      "commit_id": "63a48705a496bf2506121dcddbd8cac2a78f877c",
      "commit_message": "MATH-835\nAvoid overflow.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1367593 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gilles Sadowski",
      "commit_parent": "a49e443c44766df45d254e13bea377d4133f5ee6",
      "commit_date": "2012-07-31 14:58:01",
      "commit_file_diff": "@@ -594,7 +594,7 @@ public class Fraction\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+        return 100 * doubleValue();\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "percentageValue",
      "function_parent": "Fraction::percentageValue()",
      "function_before_start_line": 596,
      "function_before_end_line": 598,
      "function_after_start_line": 596,
      "function_after_end_line": 598,
      "function_before_token_count": 15,
      "function_after_token_count": 12,
      "function_before": "public double percentageValue() {\n    return multiply(100).doubleValue();\n}",
      "function_after": "public double percentageValue() {\n    return 100 * doubleValue();\n}"
    },
    "file": {
      "file_name": "Fraction.java",
      "file_path": "src/main/java/org/apache/commons/math3/fraction/Fraction.java",
      "file_nloc": 306,
      "file_complexity": 77,
      "file_token_count": 2084,
      "file_before": "",
      "file_after": ""
    }
  },
  "96": {
    "id": 96,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 30,
    "buggy_line_location": 173,
    "buggy_line_content": "final int n1n2prod = n1 * n2;",
    "fixed_line_location": 173,
    "fixed_line_content": "final double n1n2prod = n1 * n2;",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-790",
    "in_function": true,
    "commit": {
      "commit_id": "33169dcf75724f6190b5c14148553b52899936e0",
      "commit_message": "MATH-790: Patch applied to fix the overflow issue.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1348024 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Mikkel Meyer Andersen",
      "commit_parent": "a40ad8af53e6607a1dec7364cb9fdca03ac44b59",
      "commit_date": "2012-06-08 11:04:11",
      "commit_file_diff": "@@ -170,11 +170,11 @@ public class MannWhitneyUTest {\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+        final double n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n-        final double EU = (double) n1n2prod / 2.0;\n-        final double VarU = (double) (n1n2prod * (n1 + n2 + 1)) / 12.0;\n+        final double EU = n1n2prod / 2.0;\n+        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n         final double z = (Umin - EU) / FastMath.sqrt(VarU);\n \n"
    },
    "function": {
      "function_name": "calculateAsymptoticPValue",
      "function_parent": "MannWhitneyUTest::calculateAsymptoticPValue( final double Umin , final int n1 , final int n2)",
      "function_before_start_line": 168,
      "function_before_end_line": 184,
      "function_after_start_line": 168,
      "function_after_end_line": 184,
      "function_before_token_count": 103,
      "function_after_token_count": 95,
      "function_before": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n\n    final int n1n2prod = n1 * n2;\n\n    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n    final double EU = (double) n1n2prod / 2.0;\n    final double VarU = (double) (n1n2prod * (n1 + n2 + 1)) / 12.0;\n\n    final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n    return 2 * standardNormal.cumulativeProbability(z);\n}",
      "function_after": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n\n    final double n1n2prod = n1 * n2;\n\n    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n    final double EU = n1n2prod / 2.0;\n    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n    final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n    return 2 * standardNormal.cumulativeProbability(z);\n}"
    },
    "file": {
      "file_name": "MannWhitneyUTest.java",
      "file_path": "src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java",
      "file_nloc": 70,
      "file_complexity": 12,
      "file_token_count": 627,
      "file_before": "",
      "file_after": ""
    }
  },
  "97": {
    "id": 97,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 32,
    "buggy_line_location": 135,
    "buggy_line_content": "if ((Boolean) getTree(false).getAttribute()) {",
    "fixed_line_location": 136,
    "fixed_line_content": "if (tree.getCut() == null && (Boolean) tree.getAttribute()) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-780",
    "in_function": true,
    "commit": {
      "commit_id": "dd6cefb0ccb596d0597e2a9991766e109153ab25",
      "commit_message": "Fixed a wrong assumption on BSP tree attributes.\n\nThe assumption was that the attribute was always a boolean when boundary\nwas empty. This assumption was false when emptiness resulted from a\ncollapsed boundary. Boolean attributes occur only at leaf nodes, so it\nis the cut sub-hyperplane that needed to be checked.\n\nJIRA: MATH-780\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1337929 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_parent": "8f423828e0d9f34896f87d803c559adf2d953f30",
      "commit_date": "2012-05-13 15:51:56",
      "commit_file_diff": "@@ -132,7 +132,9 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n-            if ((Boolean) getTree(false).getAttribute()) {\n+            final BSPTree<Euclidean2D> tree = getTree(false);\n+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n+                // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n"
    },
    "function": {
      "function_name": "computeGeometricalProperties",
      "function_parent": "PolygonsSet::computeGeometricalProperties()",
      "function_before_start_line": 130,
      "function_before_end_line": 179,
      "function_after_start_line": 130,
      "function_after_end_line": 181,
      "function_before_token_count": 295,
      "function_after_token_count": 312,
      "function_before": "protected void computeGeometricalProperties() {\n\n    final Vector2D[][] v = getVertices();\n\n    if (v.length == 0) {\n        if ((Boolean) getTree(false).getAttribute()) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        // there is at least one open-loop: the polygon is infinite\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        // all loops are closed, we compute some integrals around the shape\n\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n\n        for (Vector2D[] loop : v) {\n            double x1 = loop[loop.length - 1].getX();\n            double y1 = loop[loop.length - 1].getY();\n            for (final Vector2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.getX();\n                y1 = point.getY();\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n\n        if (sum < 0) {\n            // the polygon as a finite outside surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n\n    }\n\n}",
      "function_after": "protected void computeGeometricalProperties() {\n\n    final Vector2D[][] v = getVertices();\n\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n            // the instance covers the whole space\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        // there is at least one open-loop: the polygon is infinite\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        // all loops are closed, we compute some integrals around the shape\n\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n\n        for (Vector2D[] loop : v) {\n            double x1 = loop[loop.length - 1].getX();\n            double y1 = loop[loop.length - 1].getY();\n            for (final Vector2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.getX();\n                y1 = point.getY();\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n\n        if (sum < 0) {\n            // the polygon as a finite outside surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n\n    }\n\n}"
    },
    "file": {
      "file_name": "PolygonsSet.java",
      "file_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
      "file_nloc": 266,
      "file_complexity": 59,
      "file_token_count": 2319,
      "file_before": "",
      "file_after": ""
    }
  },
  "98": {
    "id": 98,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 33,
    "buggy_line_location": 338,
    "buggy_line_content": "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {",
    "fixed_line_location": 338,
    "fixed_line_content": "if (Precision.compareTo(entry, 0d, epsilon) > 0) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-781",
    "in_function": true,
    "commit": {
      "commit_id": "3c4cb189cc91c5ca78cab3ba95dc82bee715d39a",
      "commit_message": "[MATH-781] use epsilon criteria when deciding to drop columns after phase 1.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1333146 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Thomas Neidhart",
      "commit_parent": "450456208cf75b865fd3c0878b6b4f70f6b329b1",
      "commit_date": "2012-05-02 18:28:37",
      "commit_file_diff": "@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n"
    },
    "function": {
      "function_name": "dropPhase1Objective",
      "function_parent": "SimplexTableau::dropPhase1Objective()",
      "function_before_start_line": 327,
      "function_before_end_line": 367,
      "function_after_start_line": 327,
      "function_after_end_line": 367,
      "function_before_token_count": 294,
      "function_after_token_count": 294,
      "function_before": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n\n    // positive cost non-artificial variables\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n\n    // non-basic artificial variables\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n      int col = i + getArtificialVariableOffset();\n      if (getBasicRow(col) == null) {\n        columnsToDrop.add(col);\n      }\n    }\n\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n      int col = 0;\n      for (int j = 0; j < getWidth(); j++) {\n        if (!columnsToDrop.contains(j)) {\n          matrix[i - 1][col++] = tableau.getEntry(i, j);\n        }\n      }\n    }\n\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n      columnLabels.remove((int) columnsToDrop.get(i));\n    }\n\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}",
      "function_after": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n\n    // positive cost non-artificial variables\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n\n    // non-basic artificial variables\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n      int col = i + getArtificialVariableOffset();\n      if (getBasicRow(col) == null) {\n        columnsToDrop.add(col);\n      }\n    }\n\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n      int col = 0;\n      for (int j = 0; j < getWidth(); j++) {\n        if (!columnsToDrop.contains(j)) {\n          matrix[i - 1][col++] = tableau.getEntry(i, j);\n        }\n      }\n    }\n\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n      columnLabels.remove((int) columnsToDrop.get(i));\n    }\n\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}"
    },
    "file": {
      "file_name": "SimplexTableau.java",
      "file_path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java",
      "file_nloc": 326,
      "file_complexity": 92,
      "file_token_count": 2519,
      "file_before": "",
      "file_after": ""
    }
  },
  "99": {
    "id": 99,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 34,
    "buggy_line_location": 208,
    "buggy_line_content": "return chromosomes.iterator();",
    "fixed_line_location": 209,
    "fixed_line_content": "return getChromosomes().iterator();",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-779",
    "in_function": true,
    "commit": {
      "commit_id": "ebadb558aaac32dd82e1355a915d42c521a3e740",
      "commit_message": "[MATH-779] Fixed iterator() method in ListPopulation to return an iterator of the unmodifiable list, thanks to Reid Hochstedler.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1325427 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Thomas Neidhart",
      "commit_parent": "0d61a96330afa923801c585c7d60be48b26e99b2",
      "commit_date": "2012-04-12 18:32:53",
      "commit_file_diff": "@@ -200,11 +200,12 @@ public abstract class ListPopulation implements Population {\n     }\n \n     /**\n-     * Chromosome list iterator\n+     * Returns an iterator over the unmodifiable list of chromosomes.\n+     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n     }\n }\n"
    },
    "function": {
      "function_name": "iterator",
      "function_parent": "ListPopulation::iterator()",
      "function_before_start_line": 207,
      "function_before_end_line": 209,
      "function_after_start_line": 208,
      "function_after_end_line": 210,
      "function_before_token_count": 12,
      "function_after_token_count": 14,
      "function_before": "public Iterator<Chromosome> iterator() {\n    return chromosomes.iterator();\n}",
      "function_after": "public Iterator<Chromosome> iterator() {\n    return getChromosomes().iterator();\n}"
    },
    "file": {
      "file_name": "ListPopulation.java",
      "file_path": "src/main/java/org/apache/commons/math3/genetics/ListPopulation.java",
      "file_nloc": 95,
      "file_complexity": 24,
      "file_token_count": 655,
      "file_before": "",
      "file_after": ""
    }
  },
  "100": {
    "id": 100,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 41,
    "buggy_line_location": 520,
    "buggy_line_content": "for (int i = 0; i < weights.length; i++) {",
    "fixed_line_location": 520,
    "fixed_line_content": "for (int i = begin; i < begin + length; i++) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-704",
    "in_function": true,
    "commit": {
      "commit_id": "3f645310b52358ebdd36e8afa0f8ee98aadfabdd",
      "commit_message": "Fixed array indexing error in Variance evaluate method for\ncomputing the weighted variance of an array segment.\n\nJIRA: MATH-704\nReported by Leonid Ilyevsky\nPatched by Thomas Niedhart\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1208291 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Phil Steitz",
      "commit_parent": "d099c7c3436bd43094e7b3087c64e0552cfbec5b",
      "commit_date": "2011-11-30 06:24:04",
      "commit_file_diff": "@@ -517,7 +517,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }\n \n"
    },
    "function": {
      "function_name": "evaluate",
      "function_parent": "Variance::evaluate( final double [ ] values , final double [ ] weights , final double mean , final int begin , final int length)",
      "function_before_start_line": 501,
      "function_before_end_line": 532,
      "function_after_start_line": 501,
      "function_after_end_line": 532,
      "function_before_token_count": 223,
      "function_after_token_count": 223,
      "function_before": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n\n    double var = Double.NaN;\n\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}",
      "function_after": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n\n    double var = Double.NaN;\n\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}"
    },
    "file": {
      "file_name": "Variance.java",
      "file_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java",
      "file_nloc": 181,
      "file_complexity": 44,
      "file_token_count": 1252,
      "file_before": "",
      "file_after": ""
    }
  },
  "101": {
    "id": 101,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 57,
    "buggy_line_location": 175,
    "buggy_line_content": "int sum = 0;",
    "fixed_line_location": 175,
    "fixed_line_content": "double sum = 0;",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-546",
    "in_function": true,
    "commit": {
      "commit_id": "b6bf8f418ade5fc981f66109c0a2e5af512ac9c0",
      "commit_message": "MATH-546\nWrong  variable type (\"int\" instead of \"double\").\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1081744 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gilles Sadowski",
      "commit_parent": "35a0923edfe498c58bfb1e86099fed85fde0c353",
      "commit_date": "2011-03-15 12:15:02",
      "commit_file_diff": "@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n"
    },
    "function": {
      "function_name": "chooseInitialCenters",
      "function_parent": "KMeansPlusPlusClusterer::chooseInitialCenters( final Collection<T> points , final int k , final Random random)",
      "function_before_start_line": 162,
      "function_before_end_line": 198,
      "function_after_start_line": 162,
      "function_after_end_line": 198,
      "function_before_token_count": 267,
      "function_after_token_count": 267,
      "function_before": "    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n    // Choose one center uniformly at random from among the data points.\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        // For each data point x, compute D(x), the distance between x and\n        // the nearest center that has already been chosen.\n        int sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n\n        // Add one new data point as a center. Each point x is chosen with\n        // probability proportional to D(x)2\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n\n    return resultSet;\n\n}",
      "function_after": "    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n    // Choose one center uniformly at random from among the data points.\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        // For each data point x, compute D(x), the distance between x and\n        // the nearest center that has already been chosen.\n        double sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n\n        // Add one new data point as a center. Each point x is chosen with\n        // probability proportional to D(x)2\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n\n    return resultSet;\n\n}"
    },
    "file": {
      "file_name": "KMeansPlusPlusClusterer.java",
      "file_path": "src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
      "file_nloc": 173,
      "file_complexity": 37,
      "file_token_count": 1334,
      "file_before": "",
      "file_after": ""
    }
  },
  "102": {
    "id": 102,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 59,
    "buggy_line_location": 3482,
    "buggy_line_content": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);",
    "fixed_line_location": 3482,
    "fixed_line_content": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-482",
    "in_function": true,
    "commit": {
      "commit_id": "6d6649ef6932053a9cb1854cec65b60b1e445999",
      "commit_message": "MATH-482 FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1060060 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Sebastian Bazley",
      "commit_parent": "30d4ad86064c749ced4579cb5602f90c1d7ac80c",
      "commit_date": "2011-01-17 19:55:01",
      "commit_file_diff": "@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n \n     /** Compute the maximum of two values\n"
    },
    "function": {
      "function_name": "max",
      "function_parent": "FastMath::max(final float a,final float b)",
      "function_before_start_line": 3481,
      "function_before_end_line": 3483,
      "function_after_start_line": 3481,
      "function_after_end_line": 3483,
      "function_before_token_count": 38,
      "function_after_token_count": 38,
      "function_before": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n}",
      "function_after": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n}"
    },
    "file": {
      "file_name": "FastMath.java",
      "file_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
      "file_nloc": 2032,
      "file_complexity": 382,
      "file_token_count": 17129,
      "file_before": "",
      "file_after": ""
    }
  },
  "103": {
    "id": 103,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 63,
    "buggy_line_location": 423,
    "buggy_line_content": "return (Double.isNaN(x) && Double.isNaN(y)) || x == y;",
    "fixed_line_location": 417,
    "fixed_line_content": "return equals(x, y, 1);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-370",
    "in_function": true,
    "commit": {
      "commit_id": "495f04bcda902b73118cc6b30afd36465762b259",
      "commit_message": "MATH-370\nRemoved deprecated methods.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@991535 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gilles Sadowski",
      "commit_parent": "9f631fecc80e69a15db3f92e3301fed9836ec8e3",
      "commit_date": "2010-09-01 13:45:55",
      "commit_file_diff": "@@ -407,20 +407,14 @@ public final class MathUtils {\n \n     /**\n      * Returns true iff they are equal as defined by\n-     * {@link #equals(double,double,int) this method}.\n+     * {@link #equals(double,double,int) equals(x, y, 1)}.\n      *\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double,double)\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x, y, 1);\n     }\n \n     /**\n@@ -524,12 +518,6 @@ public final class MathUtils {\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n      * and equal elements.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n@@ -1101,29 +1089,6 @@ public final class MathUtils {\n         return ret;\n     }\n \n-    /**\n-     * Get the next machine representable number after a number, moving\n-     * in the direction of another number.\n-     * <p>\n-     * If <code>direction</code> is greater than or equal to<code>d</code>,\n-     * the smallest machine representable number strictly greater than\n-     * <code>d</code> is returned; otherwise the largest representable number\n-     * strictly less than <code>d</code> is returned.</p>\n-     * <p>\n-     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n-     *\n-     * @param d base number\n-     * @param direction (the only important thing is whether\n-     * direction is greater or smaller than d)\n-     * @return the next machine representable number in the specified direction\n-     * @since 1.2\n-     * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\n-     */\n-    @Deprecated\n-    public static double nextAfter(double d, double direction) {\n-        return FastMath.nextAfter(d, direction);\n-    }\n-\n     /**\n      * Scale a number by 2<sup>scaleFactor</sup>.\n      * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n@@ -1318,23 +1283,23 @@ public final class MathUtils {\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_DOWN :\n-            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             break;\n         case BigDecimal.ROUND_FLOOR :\n             if (sign == -1) {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_HALF_DOWN : {\n-            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction > 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1361,7 +1326,7 @@ public final class MathUtils {\n             break;\n         }\n         case BigDecimal.ROUND_HALF_UP : {\n-            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction >= 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1376,7 +1341,7 @@ public final class MathUtils {\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n-            unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n             throw MathRuntimeException.createIllegalArgumentException(\n@@ -1904,24 +1869,6 @@ public final class MathUtils {\n         checkOrder(val, OrderDirection.INCREASING, true);\n     }\n \n-    /**\n-     * Checks that the given array is sorted.\n-     *\n-     * @param val Values\n-     * @param dir Order direction (-1 for decreasing, 1 for increasing)\n-     * @param strict Whether the order should be strict\n-     * @throws NonMonotonousSequenceException if the array is not sorted.\n-     * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)\n-     * checkOrder} method). To be removed in 3.0.\n-     */\n-    public static void checkOrder(double[] val, int dir, boolean strict) {\n-        if (dir > 0) {\n-            checkOrder(val, OrderDirection.INCREASING, strict);\n-        } else {\n-            checkOrder(val, OrderDirection.DECREASING, strict);\n-        }\n-    }\n-\n     /**\n      * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n      * Translation of the minpack enorm subroutine.\n"
    },
    "function": {
      "function_name": "equals",
      "function_parent": "MathUtils::equals( double x , double y)",
      "function_before_start_line": 422,
      "function_before_end_line": 424,
      "function_after_start_line": 416,
      "function_after_end_line": 418,
      "function_before_token_count": 31,
      "function_after_token_count": 20,
      "function_before": "public static boolean equals(double x, double y) {\n    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n}",
      "function_after": "public static boolean equals(double x, double y) {\n    return equals(x, y, 1);\n}"
    },
    "file": {
      "file_name": "MathUtils.java",
      "file_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "file_nloc": 905,
      "file_complexity": 278,
      "file_token_count": 6183,
      "file_before": "",
      "file_after": ""
    }
  },
  "104": {
    "id": 104,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 69,
    "buggy_line_location": 171,
    "buggy_line_content": "out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));",
    "fixed_line_location": 171,
    "fixed_line_content": "out[i][j] = 2 * tDistribution.cumulativeProbability(-t);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-371",
    "in_function": true,
    "commit": {
      "commit_id": "bb005b56ca0739c4c212804ba7a483c8164e78f1",
      "commit_message": "Fixed loss of significance error in PersonsCorrelation p-value computation\ncausing p-values smaller than the machine epsilon (~1E-16) to be reported as 0.\nJIRA: MATH-371\nReported and patched by Kevin Childs\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@944939 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Phil Steitz",
      "commit_parent": "eb74f8f418f9da4adb52628fe775022efc4b0467",
      "commit_date": "2010-05-16 23:48:07",
      "commit_file_diff": "@@ -168,7 +168,7 @@ public class PearsonsCorrelation {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                 }\n             }\n         }\n"
    },
    "function": {
      "function_name": "getCorrelationPValues",
      "function_parent": "PearsonsCorrelation::getCorrelationPValues()",
      "function_before_start_line": 160,
      "function_before_end_line": 176,
      "function_after_start_line": 160,
      "function_after_end_line": 176,
      "function_before_token_count": 165,
      "function_after_token_count": 162,
      "function_before": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}",
      "function_after": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}"
    },
    "file": {
      "file_name": "PearsonsCorrelation.java",
      "file_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
      "file_nloc": 122,
      "file_complexity": 28,
      "file_token_count": 979,
      "file_before": "",
      "file_after": ""
    }
  },
  "105": {
    "id": 105,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 70,
    "buggy_line_location": 72,
    "buggy_line_content": "return solve(min, max);",
    "fixed_line_location": 72,
    "fixed_line_content": "return solve(f, min, max);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-369",
    "in_function": true,
    "commit": {
      "commit_id": "f4a4464beea8118386b84bace4b08e6c16443dab",
      "commit_message": "Fix NullPointerException in BisectionSolver.solve(f, min, max, initial)\nJIRA: MATH-369\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@940565 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_parent": "58f8b21d3587e1419f0a421731280f84a8c0afe4",
      "commit_date": "2010-05-03 18:42:27",
      "commit_file_diff": "@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n"
    },
    "function": {
      "function_name": "solve",
      "function_parent": "BisectionSolver::solve( final UnivariateRealFunction f , double min , double max , double initial)",
      "function_before_start_line": 70,
      "function_before_end_line": 73,
      "function_after_start_line": 70,
      "function_after_end_line": 73,
      "function_before_token_count": 29,
      "function_after_token_count": 31,
      "function_before": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}",
      "function_after": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(f, min, max);\n}"
    },
    "file": {
      "file_name": "BisectionSolver.java",
      "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java",
      "file_nloc": 53,
      "file_complexity": 9,
      "file_token_count": 334,
      "file_before": "",
      "file_after": ""
    }
  },
  "106": {
    "id": 106,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 75,
    "buggy_line_location": 303,
    "buggy_line_content": "return getCumPct((Comparable<?>) v);",
    "fixed_line_location": 303,
    "fixed_line_content": "return getPct((Comparable<?>) v);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-329",
    "in_function": true,
    "commit": {
      "commit_id": "6dd3724b9b5e29a9bd9f404d28d0cf6d43ccfe95",
      "commit_message": "Fixed regression in Frequency.getPct(Object) introduced in 2.0. Cumulative\npercent was being returned for Object arguments in place of percent.\n\nJIRA: MATH-329\nReported by Will Wu\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@900016 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Phil Steitz",
      "commit_parent": "b2f3f6db411099f91a5436a4f88344ccc1f8d166",
      "commit_date": "2010-01-16 20:01:17",
      "commit_file_diff": "@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "getPct",
      "function_parent": "Frequency::getPct( Object v)",
      "function_before_start_line": 302,
      "function_before_end_line": 304,
      "function_after_start_line": 302,
      "function_after_end_line": 304,
      "function_before_token_count": 17,
      "function_after_token_count": 17,
      "function_before": "public double getPct(Object v) {\n    return getCumPct((Comparable<?>) v);\n}",
      "function_after": "public double getPct(Object v) {\n    return getPct((Comparable<?>) v);\n}"
    },
    "file": {
      "file_name": "Frequency.java",
      "file_path": "src/main/java/org/apache/commons/math/stat/Frequency.java",
      "file_nloc": 240,
      "file_complexity": 63,
      "file_token_count": 1563,
      "file_before": "",
      "file_after": ""
    }
  },
  "107": {
    "id": 107,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 80,
    "buggy_line_location": 1135,
    "buggy_line_content": "int j = 4 * n - 1;",
    "fixed_line_location": 1135,
    "fixed_line_content": "int j = 4 * (n - 1);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-318",
    "in_function": true,
    "commit": {
      "commit_id": "83f18d5299fbadf91ec792c95ee96bcd916ca9af",
      "commit_message": "Fixed an index computation error in eigen decomposition.\nOnce again, kudos to Dimitri for debugging this.\nJIRA: MATH-318\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@833433 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_parent": "c78a0e3b003ac36d57a3c895fc8240ef66546a56",
      "commit_date": "2009-11-06 15:11:57",
      "commit_file_diff": "@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n"
    },
    "function": {
      "function_name": "flipIfWarranted",
      "function_parent": "EigenDecompositionImpl::flipIfWarranted( final int n , final int step)",
      "function_before_start_line": 1132,
      "function_before_end_line": 1147,
      "function_after_start_line": 1132,
      "function_after_end_line": 1147,
      "function_before_token_count": 125,
      "function_after_token_count": 127,
      "function_before": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        // flip array\n        int j = 4 * n - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
      "function_after": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        // flip array\n        int j = 4 * (n - 1);\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}"
    },
    "file": {
      "file_name": "EigenDecompositionImpl.java",
      "file_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
      "file_nloc": 1178,
      "file_complexity": 250,
      "file_token_count": 10187,
      "file_before": "",
      "file_after": ""
    }
  },
  "108": {
    "id": 108,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 85,
    "buggy_line_location": 198,
    "buggy_line_content": "if (fa * fb >= 0.0 ) {",
    "fixed_line_location": 198,
    "fixed_line_content": "if (fa * fb > 0.0 ) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-280",
    "in_function": true,
    "commit": {
      "commit_id": "b9d8c68e2f5f7f3a13773140a7ee4bf62972f17c",
      "commit_message": "fixed a bracketing issue due to inconsistent checks\nJIRA: MATH-280\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@791766 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_parent": "26281773d85fa96594c16aee56e36805f3254064",
      "commit_date": "2009-07-07 09:19:46",
      "commit_file_diff": "@@ -131,7 +131,7 @@ public class UnivariateRealSolverUtils {\n      /**\n      * This method attempts to find two values a and b satisfying <ul>\n      * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n-     * <li> <code> f(a) * f(b) < 0 </code> </li>\n+     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n      * </ul>\n      * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n      * and <code>b</code> bracket a root of f.\n@@ -141,7 +141,7 @@ public class UnivariateRealSolverUtils {\n      * function at <code>a</code> and <code>b</code> and keeps moving\n      * the endpoints out by one unit each time through a loop that terminates \n      * when one of the following happens: <ul>\n-     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n      * <li> <code> a = lower </code> and <code> b = upper</code> \n      * -- ConvergenceException </li>\n      * <li> <code> maximumIterations</code> iterations elapse \n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n"
    },
    "function": {
      "function_name": "bracket",
      "function_parent": "UnivariateRealSolverUtils::bracket( UnivariateRealFunction function , double initial , double lowerBound , double upperBound , int maximumIterations)",
      "function_before_start_line": 165,
      "function_before_end_line": 208,
      "function_after_start_line": 165,
      "function_after_end_line": 208,
      "function_before_token_count": 247,
      "function_after_token_count": 247,
      "function_before": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n\n    if (fa * fb >= 0.0 ) {\n        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  numIterations, maximumIterations, initial,\n                  lowerBound, upperBound, a, b, fa, fb);\n    }\n\n    return new double[]{a, b};\n}",
      "function_after": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n\n    if (fa * fb > 0.0 ) {\n        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  numIterations, maximumIterations, initial,\n                  lowerBound, upperBound, a, b, fa, fb);\n    }\n\n    return new double[]{a, b};\n}"
    },
    "file": {
      "file_name": "UnivariateRealSolverUtils.java",
      "file_path": "src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
      "file_nloc": 80,
      "file_complexity": 18,
      "file_token_count": 535,
      "file_before": "",
      "file_after": ""
    }
  },
  "109": {
    "id": 109,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 94,
    "buggy_line_location": 412,
    "buggy_line_content": "if (u * v == 0) {",
    "fixed_line_location": 412,
    "fixed_line_content": "if ((u == 0) || (v == 0)) {",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-238",
    "in_function": true,
    "commit": {
      "commit_id": "dabf3a5beb9ab697d570154b9961078a8586c787",
      "commit_message": "fixed overflow error in gdc computation\nJIRA: MATH-238\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@735178 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_parent": "4564adbf19ebc6da19befcc7dbef310a00b4de13",
      "commit_date": "2009-01-16 23:06:32",
      "commit_file_diff": "@@ -409,7 +409,7 @@ public final class MathUtils {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+        if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n"
    },
    "function": {
      "function_name": "gcd",
      "function_parent": "MathUtils::gcd( int u , int v)",
      "function_before_start_line": 411,
      "function_before_end_line": 460,
      "function_after_start_line": 411,
      "function_after_end_line": 460,
      "function_before_token_count": 210,
      "function_after_token_count": 216,
      "function_before": "public static int gcd(int u, int v) {\n    if (u * v == 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    } // make u negative\n    if (v > 0) {\n        v = -v;\n    } // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                        // both even...\n        u /= 2;\n        v /= 2;\n        k++; // cast out twos.\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) { // while t is even..\n            t /= 2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    return -u * (1 << k); // gcd is u*2^k\n}",
      "function_after": "public static int gcd(int u, int v) {\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    } // make u negative\n    if (v > 0) {\n        v = -v;\n    } // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                        // both even...\n        u /= 2;\n        v /= 2;\n        k++; // cast out twos.\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) { // while t is even..\n            t /= 2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    return -u * (1 << k); // gcd is u*2^k\n}"
    },
    "file": {
      "file_name": "MathUtils.java",
      "file_path": "src/java/org/apache/commons/math/util/MathUtils.java",
      "file_nloc": 439,
      "file_complexity": 152,
      "file_token_count": 3085,
      "file_before": "",
      "file_after": ""
    }
  },
  "110": {
    "id": 110,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 96,
    "buggy_line_location": 258,
    "buggy_line_content": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
    "fixed_line_location": 258,
    "fixed_line_content": "ret = (real == rhs.real) && (imaginary == rhs.imaginary);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-221",
    "in_function": true,
    "commit": {
      "commit_id": "94cf29c4e3b6a7f37ad9d85ba572409691ed7f23",
      "commit_message": "Changed the Complex.equals() method so that it considers +0 and -0 are equal,\nas required by IEEE-754 standard.\nJIRA: MATH-221\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/branches/MATH_2_0@690308 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_parent": "a48a97b37fa591427f95e158beb33031daf06196",
      "commit_date": "2008-08-29 15:46:22",
      "commit_file_diff": "@@ -255,10 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                ret = (Double.doubleToRawLongBits(real) ==\n-                        Double.doubleToRawLongBits(rhs.getReal())) &&\n-                    (Double.doubleToRawLongBits(imaginary) ==\n-                        Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n"
    },
    "function": {
      "function_name": "equals",
      "function_parent": "Complex::equals( Object other)",
      "function_before_start_line": 245,
      "function_before_end_line": 270,
      "function_after_start_line": 245,
      "function_after_end_line": 267,
      "function_before_token_count": 126,
      "function_after_token_count": 102,
      "function_before": "public boolean equals(Object other) {\n    boolean ret;\n\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n            ret = (Double.doubleToRawLongBits(real) ==\n                    Double.doubleToRawLongBits(rhs.getReal())) &&\n                (Double.doubleToRawLongBits(imaginary) ==\n                    Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException ex) {\n            // ignore exception\n            ret = false;\n        }\n    }\n\n    return ret;\n}",
      "function_after": "public boolean equals(Object other) {\n    boolean ret;\n\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n            }\n        } catch (ClassCastException ex) {\n            // ignore exception\n            ret = false;\n        }\n    }\n\n    return ret;\n}"
    },
    "file": {
      "file_name": "Complex.java",
      "file_path": "src/java/org/apache/commons/math/complex/Complex.java",
      "file_nloc": 251,
      "file_complexity": 78,
      "file_token_count": 1837,
      "file_before": "",
      "file_after": ""
    }
  },
  "111": {
    "id": 111,
    "project_name": "commons-math",
    "project_url": "https://github.com/apache/commons-math.git",
    "defects4j_id": 105,
    "buggy_line_location": 249,
    "buggy_line_content": "return sumYY - sumXY * sumXY / sumXX;",
    "fixed_line_location": 264,
    "fixed_line_content": "return Math.max(0d, sumYY - sumXY * sumXY / sumXX);",
    "bug_description_link": "https://issues.apache.org/jira/browse/MATH-85",
    "in_function": true,
    "commit": {
      "commit_id": "075008dcd42adcc6924d048a376e611f9219e52b",
      "commit_message": "Modified getSumSquaredErrors method in SimpleRegression to always \nreturn a non-negative result.\nJIRA: MATH-85\nReported by Mark Osborn\nPatched by Luc Maisonobe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@419439 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Phil Steitz",
      "commit_parent": "00b139a1c49c230bfb7b0f1ec5b8c22d560d3447",
      "commit_date": "2006-07-06 05:10:49",
      "commit_file_diff": "@@ -236,6 +236,21 @@ public class SimpleRegression implements Serializable {\n      * sum of squared errors</a> (SSE) associated with the regression \n      * model.\n      * <p>\n+     * The sum is computed using the computational formula\n+     * <p>\n+     * <code>SSE = SYY - (SXY * SXY / SXX)</code>\n+     * <p>\n+     * where <code>SYY</code> is the sum of the squared deviations of the y\n+     * values about their mean, <code>SXX</code> is similarly defined and\n+     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n+     * <p>\n+     * The sums are accumulated using the updating algorithm referenced in \n+     * {@link #addData}.  \n+     * <p>\n+     * The return value is constrained to be non-negative - i.e., if due to \n+     * rounding errors the computational formula returns a negative result, \n+     * 0 is returned.\n+     * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n      * must have been added before invoking this method. If this method is \n@@ -246,7 +261,7 @@ public class SimpleRegression implements Serializable {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n     }\n \n     /**\n"
    },
    "function": {
      "function_name": "getSumSquaredErrors",
      "function_parent": "SimpleRegression::getSumSquaredErrors()",
      "function_before_start_line": 248,
      "function_before_end_line": 250,
      "function_after_start_line": 263,
      "function_after_end_line": 265,
      "function_before_token_count": 14,
      "function_after_token_count": 21,
      "function_before": "public double getSumSquaredErrors() {\n    return sumYY - sumXY * sumXY / sumXX;\n}",
      "function_after": "public double getSumSquaredErrors() {\n    return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n}"
    },
    "file": {
      "file_name": "SimpleRegression.java",
      "file_path": "src/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
      "file_nloc": 129,
      "file_complexity": 31,
      "file_token_count": 843,
      "file_before": "",
      "file_after": ""
    }
  },
  "112": {
    "id": 112,
    "project_name": "mockito",
    "project_url": "https://github.com/mockito/mockito.git",
    "defects4j_id": 8,
    "buggy_line_location": 79,
    "buggy_line_content": "} else {",
    "fixed_line_location": 79,
    "fixed_line_content": "} else if (typeParameter != actualTypeArgument) {",
    "bug_description_link": "https://github.com/mockito/mockito/issues/114",
    "in_function": true,
    "commit": {
      "commit_id": "5a03bf5d0c9aedac9cfbf074833167c1eca6439f",
      "commit_message": "Fixes issue #114",
      "commit_author": "pbielicki",
      "commit_parent": "9fb7d8b62814f959ceca6096d785b96c11bdfd0a",
      "commit_date": "2014-12-29 22:59:47",
      "commit_file_diff": "@@ -76,7 +76,7 @@ public abstract class GenericMetadataSupport {\n \r\n             if (actualTypeArgument instanceof WildcardType) {\r\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n-            } else {\r\n+            } else if (typeParameter != actualTypeArgument) {\r\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n             }\r\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\r\n"
    },
    "function": {
      "function_name": "registerTypeVariablesOn",
      "function_parent": "GenericMetadataSupport::registerTypeVariablesOn( Type classType)",
      "function_before_start_line": 66,
      "function_before_end_line": 84,
      "function_after_start_line": 66,
      "function_after_end_line": 84,
      "function_before_token_count": 129,
      "function_after_token_count": 135,
      "function_before": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n        // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n    }\n}",
      "function_after": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (typeParameter != actualTypeArgument) {\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n        // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n    }\n}"
    },
    "file": {
      "file_name": "GenericMetadataSupport.java",
      "file_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
      "file_nloc": 322,
      "file_complexity": 87,
      "file_token_count": 2045,
      "file_before": "",
      "file_after": ""
    }
  },
  "113": {
    "id": 113,
    "project_name": "mockito",
    "project_url": "https://github.com/mockito/mockito.git",
    "defects4j_id": 29,
    "buggy_line_location": 29,
    "buggy_line_content": "description.appendText(wanted.toString());",
    "fixed_line_location": 29,
    "fixed_line_content": "description.appendText(wanted == null ? \"null\" : wanted.toString());",
    "bug_description_link": "https://github.com/mockito/mockito/issues/229",
    "in_function": true,
    "commit": {
      "commit_id": "918f0a5aed6454b307004b6c9c86afc8e96353ff",
      "commit_message": "Fix for issue 229 in the describeTo phase of the Same matcher, when match is failing",
      "commit_author": "Brice Dutheil",
      "commit_parent": "df41fbe00b1300cfe5076bb4e9242214fbe677f9",
      "commit_date": "2010-11-18 17:54:14",
      "commit_file_diff": "@@ -4,11 +4,11 @@\n  */\n package org.mockito.internal.matchers;\n \n-import java.io.Serializable;\n-\n import org.hamcrest.Description;\n import org.mockito.ArgumentMatcher;\n \n+import java.io.Serializable;\n+\n \n public class Same extends ArgumentMatcher<Object> implements Serializable {\n \n@@ -26,7 +26,7 @@ public class Same extends ArgumentMatcher<Object> implements Serializable {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+        description.appendText(wanted == null ? \"null\" : wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n"
    },
    "function": {
      "function_name": "describeTo",
      "function_parent": "Same::describeTo( Description description)",
      "function_before_start_line": 26,
      "function_before_end_line": 32,
      "function_after_start_line": 26,
      "function_after_end_line": 32,
      "function_before_token_count": 42,
      "function_after_token_count": 48,
      "function_before": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    appendQuoting(description);\n    description.appendText(\")\");\n}",
      "function_after": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted == null ? \"null\" : wanted.toString());\n    appendQuoting(description);\n    description.appendText(\")\");\n}"
    },
    "file": {
      "file_name": "Same.java",
      "file_path": "src/org/mockito/internal/matchers/Same.java",
      "file_nloc": 28,
      "file_complexity": 7,
      "file_token_count": 174,
      "file_before": "",
      "file_after": ""
    }
  },
  "114": {
    "id": 114,
    "project_name": "mockito",
    "project_url": "https://github.com/mockito/mockito.git",
    "defects4j_id": 34,
    "buggy_line_location": 106,
    "buggy_line_content": "if (m instanceof CapturesArguments) {",
    "fixed_line_location": 106,
    "fixed_line_content": "if (m instanceof CapturesArguments && i.getArguments().length > k) {",
    "bug_description_link": "https://github.com/mockito/mockito/issues/157",
    "in_function": true,
    "commit": {
      "commit_id": "e8cebe01abae49a09aadd6a26c6f7e2f90e5e772",
      "commit_message": "Fixed issue 157\nIn order to avoid ArrayIndexOutOfBoundsException when anyvarag() matcher in use\n\n--HG--\nextra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401790",
      "commit_author": "Szczepan Faber",
      "commit_parent": "0ebc2ea06b5abdb441a57a8e0f01305a7839c3d9",
      "commit_date": "2009-12-11 20:30:44",
      "commit_file_diff": "@@ -103,7 +103,7 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n"
    },
    "function": {
      "function_name": "captureArgumentsFrom",
      "function_parent": "InvocationMatcher::captureArgumentsFrom( Invocation i)",
      "function_before_start_line": 103,
      "function_before_end_line": 111,
      "function_after_start_line": 103,
      "function_after_end_line": 111,
      "function_before_token_count": 51,
      "function_after_token_count": 61,
      "function_before": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n        if (m instanceof CapturesArguments) {\n            ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n        }\n        k++;\n    }\n}",
      "function_after": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n        if (m instanceof CapturesArguments && i.getArguments().length > k) {\n            ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n        }\n        k++;\n    }\n}"
    },
    "file": {
      "file_name": "InvocationMatcher.java",
      "file_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
      "file_nloc": 83,
      "file_complexity": 24,
      "file_token_count": 589,
      "file_before": "",
      "file_after": ""
    }
  },
  "115": {
    "id": 115,
    "project_name": "mockito",
    "project_url": "https://github.com/mockito/mockito.git",
    "defects4j_id": 38,
    "buggy_line_location": 48,
    "buggy_line_content": "return StringDescription.toString(m).equals(arg.toString());",
    "fixed_line_location": 48,
    "fixed_line_content": "return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());",
    "bug_description_link": "https://github.com/mockito/mockito/issues/79",
    "in_function": true,
    "commit": {
      "commit_id": "c1f2c4e6b5bab4cfc004f22999e11e8ac140d377",
      "commit_message": "In order to fixed issue 79 (NPE) added null handling code\n\n--HG--\nextra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401549",
      "commit_author": "Szczepan Faber",
      "commit_parent": "a663d2fe76bf1ff54bbe59bddcb52f9badec3f2a",
      "commit_date": "2009-07-09 11:23:58",
      "commit_file_diff": "@@ -45,6 +45,6 @@ public class ArgumentMatchingTool {\n     }\r\n \r\n     private boolean toStringEquals(Matcher m, Object arg) {\r\n-        return StringDescription.toString(m).equals(arg.toString());\r\n+        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\r\n     }\r\n }\r\n"
    },
    "function": {
      "function_name": "toStringEquals",
      "function_parent": "ArgumentMatchingTool::toStringEquals( Matcher m , Object arg)",
      "function_before_start_line": 47,
      "function_before_end_line": 49,
      "function_after_start_line": 47,
      "function_after_end_line": 49,
      "function_before_token_count": 27,
      "function_after_token_count": 33,
      "function_before": "private boolean toStringEquals(Matcher m, Object arg) {\n    return StringDescription.toString(m).equals(arg.toString());\n}",
      "function_after": "private boolean toStringEquals(Matcher m, Object arg) {\n    return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n}"
    },
    "file": {
      "file_name": "ArgumentMatchingTool.java",
      "file_path": "src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java",
      "file_nloc": 36,
      "file_complexity": 11,
      "file_token_count": 263,
      "file_before": "",
      "file_after": ""
    }
  },
  "116": {
    "id": 116,
    "project_name": "joda-time",
    "project_url": "https://github.com/JodaOrg/joda-time.git",
    "defects4j_id": 4,
    "buggy_line_location": 463,
    "buggy_line_content": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
    "fixed_line_location": 464,
    "fixed_line_content": "Partial newPartial = new Partial(newTypes, newValues, iChronology);",
    "bug_description_link": "https://github.com/JodaOrg/joda-time/issues/88",
    "in_function": true,
    "commit": {
      "commit_id": "3ba9ba799b3261b7332a467a88be142c83b298fd",
      "commit_message": "Prevent creation of invalid partials via Partial.with(DateTimeFieldType,int)\n\nValidation in this method was not as thorough as that in the constructor\nThis allowed invalid partials to be created\nFixes #88",
      "commit_author": "Stephen Colebourne",
      "commit_parent": "bcb044669b4d1f8d334861ccbd169924d6ef3b54",
      "commit_date": "2013-11-27 12:36:35",
      "commit_file_diff": "@@ -1,5 +1,5 @@\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n@@ -459,8 +459,9 @@ public final class Partial\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n-            \n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            // use public constructor to ensure full validation\n+            // this isn't overly efficient, but is safe\n+            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n"
    },
    "function": {
      "function_name": "with",
      "function_parent": "Partial::with( DateTimeFieldType fieldType , int value)",
      "function_before_start_line": 426,
      "function_before_end_line": 473,
      "function_after_start_line": 426,
      "function_after_end_line": 474,
      "function_before_token_count": 382,
      "function_after_token_count": 382,
      "function_before": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n\n        // find correct insertion point to keep largest-smallest order\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}",
      "function_after": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n\n        // find correct insertion point to keep largest-smallest order\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        // use public constructor to ensure full validation\n        // this isn't overly efficient, but is safe\n        Partial newPartial = new Partial(newTypes, newValues, iChronology);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}"
    },
    "file": {
      "file_name": "Partial.java",
      "file_path": "src/main/java/org/joda/time/Partial.java",
      "file_nloc": 410,
      "file_complexity": 99,
      "file_token_count": 2974,
      "file_before": "",
      "file_after": ""
    }
  },
  "117": {
    "id": 117,
    "project_name": "joda-time",
    "project_url": "https://github.com/JodaOrg/joda-time.git",
    "defects4j_id": 16,
    "buggy_line_location": 705,
    "buggy_line_content": "instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
    "fixed_line_location": 709,
    "fixed_line_content": "instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));",
    "bug_description_link": "https://sourceforge.net/p/joda-time/bugs/148",
    "in_function": true,
    "commit": {
      "commit_id": "706513d59425e7a9dc6bdb972f25b03b02e48558",
      "commit_message": "Fix DateTimeFormatter.parseInto() [3522138]\n\nRevert behaviour back to v1.x when parseInto month/day only",
      "commit_author": "Stephen Colebourne",
      "commit_parent": "dba7c37ea3d83b32779d3bb13cb184aedf761a8a",
      "commit_date": "2012-04-30 12:14:37",
      "commit_file_diff": "@@ -21,6 +21,7 @@ import java.util.Locale;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.LocalDate;\n@@ -679,6 +680,9 @@ public class DateTimeFormatter {\n      * modified. To determine the position where the parse failed, apply the\n      * one's complement operator (~) on the return value.\n      * <p>\n+     * This parse method ignores the {@link #getDefaultYear() default year} and\n+     * parses using the year from the supplied instant as the default.\n+     * <p>\n      * The parse will use the chronology of the instant.\n      *\n      * @param instant  an instant that will be modified, not null\n@@ -702,7 +706,7 @@ public class DateTimeFormatter {\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n"
    },
    "function": {
      "function_name": "parseInto",
      "function_parent": "DateTimeFormatter::parseInto( ReadWritableInstant instant , String text , int position)",
      "function_before_start_line": 693,
      "function_before_end_line": 720,
      "function_after_start_line": 697,
      "function_after_end_line": 724,
      "function_before_token_count": 214,
      "function_after_token_count": 223,
      "function_before": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
      "function_after": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}"
    },
    "file": {
      "file_name": "DateTimeFormatter.java",
      "file_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "file_nloc": 356,
      "file_complexity": 87,
      "file_token_count": 2419,
      "file_before": "",
      "file_after": ""
    }
  },
  "118": {
    "id": 118,
    "project_name": "joda-time",
    "project_url": "https://github.com/JodaOrg/joda-time.git",
    "defects4j_id": 19,
    "buggy_line_location": 900,
    "buggy_line_content": "} else if (offsetLocal > 0) {",
    "fixed_line_location": 900,
    "fixed_line_content": "} else if (offsetLocal >= 0) {",
    "bug_description_link": "https://sourceforge.net/p/joda-time/bugs/124",
    "in_function": true,
    "commit": {
      "commit_id": "82c5e4f9550e4df36e07b66f35f7c3e9d7eb5eba",
      "commit_message": "Ambiguous date-time when in zone with offset of 00:00 [3424669]",
      "commit_author": "Stephen Colebourne",
      "commit_parent": "a92450e88df85d6b7a0fa53517da46286c24f53f",
      "commit_date": "2011-10-24 00:16:21",
      "commit_file_diff": "@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n"
    },
    "function": {
      "function_name": "getOffsetFromLocal",
      "function_parent": "DateTimeZone::getOffsetFromLocal( long instantLocal)",
      "function_before_start_line": 880,
      "function_before_end_line": 911,
      "function_after_start_line": 880,
      "function_after_end_line": 911,
      "function_before_token_count": 138,
      "function_after_token_count": 138,
      "function_before": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal > 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
      "function_after": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal >= 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}"
    },
    "file": {
      "file_name": "DateTimeZone.java",
      "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
      "file_nloc": 566,
      "file_complexity": 133,
      "file_token_count": 3529,
      "file_before": "",
      "file_after": ""
    }
  }
}
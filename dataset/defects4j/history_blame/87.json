{
  "id": "87",
  "blame_commit": {
    "commit": {
      "commit_id": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
      "commit_message": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Stephen Colebourne",
      "commit_date": "2003-06-08 23:14:23",
      "commit_parent": "9bb3f9b9a3e513cbac7f02d6ee97995d741d09de"
    },
    "function": {
      "function_name": "format",
      "function_code_before": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(cDefaultTimeZone);\n    c.setTime(date);\n    if (mTimeZone != null) {\n        c.setTimeZone(mTimeZone);\n    }\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
      "function_code_after": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(mTimeZone);\n    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
      "function_before_start_line": 607,
      "function_before_end_line": 614,
      "function_after_start_line": 636,
      "function_after_end_line": 640,
      "function_before_token_count": 54,
      "function_after_token_count": 39,
      "functions_name_modified_file": [
        "getInstance",
        "getPattern",
        "TextField",
        "TwelveHourField",
        "getLocale",
        "toString",
        "TwentyFourHourField",
        "getDateTimeInstance",
        "hashCode",
        "PaddedNumberField",
        "TimeZoneDisplayKey",
        "getTimeZone",
        "TwoDigitYearField",
        "estimateLength",
        "TwoDigitMonthField",
        "StringLiteral",
        "getTimeZoneDisplay",
        "TimeZoneNumberRule",
        "format",
        "TimeZoneNameRule",
        "getDateInstance",
        "getDefaultPattern",
        "getMaxLengthEstimate",
        "parseToken",
        "applyRules",
        "UnpaddedNumberField",
        "selectNumberRule",
        "Pair",
        "CharacterLiteral",
        "init",
        "equals",
        "parsePattern",
        "getTimeInstance",
        "parseObject",
        "TwoDigitNumberField",
        "FastDateFormat",
        "getTimeZoneOverridesCalendar",
        "UnpaddedMonthField",
        "appendTo"
      ],
      "functions_name_all_files": [
        "TwelveHourField",
        "suspend",
        "toString",
        "StopWatchTest",
        "TwentyFourHourField",
        "DateFormatUtilsTest",
        "PaddedNumberField",
        "TimeZoneDisplayKey",
        "estimateLength",
        "FastDateFormatTest",
        "main",
        "setUp",
        "start",
        "testWeekIterator",
        "init",
        "DurationFormatUtilsTest",
        "testDateISO",
        "parseObject",
        "testTrunc",
        "tearDown",
        "getCalendarIterator",
        "getInstance",
        "unsplit",
        "getLocale",
        "formatWords",
        "testFormat",
        "getTimeZone",
        "TwoDigitYearField",
        "TwoDigitMonthField",
        "StringLiteral",
        "formatISO",
        "getTimeZoneDisplay",
        "trunc",
        "TimeZoneNameRule",
        "getDateInstance",
        "getDefaultPattern",
        "test_getInstance",
        "testTimeISO",
        "selectNumberRule",
        "DurationFormatUtils",
        "DateFormatUtils",
        "equals",
        "getTimeInstance",
        "FastDateFormat",
        "TextField",
        "testFormatISOStyle",
        "test_getInstance_String_TimeZone",
        "TimeTestSuite",
        "testRound",
        "getDateTimeInstance",
        "testStopWatchSplit",
        "TimeZoneNumberRule",
        "formatUTC",
        "resume",
        "modify",
        "assertEquals",
        "applyRules",
        "UnpaddedNumberField",
        "testTimeNoTISO",
        "stop",
        "CharacterLiteral",
        "DateUtilsTest",
        "testStopWatchSimple",
        "testDateTimeISO",
        "testStopWatchSuspend",
        "getTimeZoneOverridesCalendar",
        "getPattern",
        "getTime",
        "test_getInstance_String_Locale",
        "testSMTP",
        "hashCode",
        "round",
        "test_getInstance_String_TimeZone_Locale",
        "assertWeekIterator",
        "testMonthIterator",
        "parse",
        "format",
        "testFormatWords",
        "test_getInstance_String",
        "getMaxLengthEstimate",
        "parseToken",
        "Pair",
        "suite",
        "StopWatch",
        "testParse",
        "split",
        "parsePattern",
        "TwoDigitNumberField",
        "UnpaddedMonthField",
        "reset",
        "appendTo"
      ],
      "functions_name_co_evolved_modified_file": [
        "getInstance",
        "toString",
        "hashCode",
        "compareTo",
        "estimateLength",
        "parse",
        "TimeZoneNumberRule",
        "format",
        "TimeZoneNameRule",
        "parseToken",
        "applyRules",
        "TimeZoneRule",
        "selectNumberRule",
        "init",
        "equals",
        "parsePattern",
        "FastDateFormat",
        "getTimeZoneOverridesCalendar",
        "appendTo"
      ],
      "functions_name_co_evolved_all_files": [
        "getInstance",
        "toString",
        "formatWords",
        "testFormatISOStyle",
        "test_getInstance_String_TimeZone",
        "DateUtils",
        "testRound",
        "testSMTP",
        "hashCode",
        "DateFormatUtilsTest",
        "testFormat",
        "getPhaseOfMoon",
        "round",
        "compareTo",
        "testElapsedTime",
        "test_getInstance_String_TimeZone_Locale",
        "assertWeekIterator",
        "estimateLength",
        "testMonthIterator",
        "parse",
        "testTimeISODate",
        "formatISO",
        "main",
        "setUp",
        "TimeZoneNumberRule",
        "formatUTC",
        "format",
        "formatElapsedTime",
        "modify",
        "assertEquals",
        "trunc",
        "TimeZoneNameRule",
        "testFormatWords",
        "test_getInstance_String",
        "CalendarUtilsTest",
        "tearDown",
        "parseToken",
        "applyRules",
        "testTimeISO",
        "getDateForHeader",
        "selectNumberRule",
        "TimeZoneRule",
        "suite",
        "testTimeNoTISO",
        "testPhaseOfMoon",
        "createDateFormat",
        "testWeekIterator",
        "DurationFormatUtils",
        "init",
        "testParse",
        "DateUtilsTest",
        "DurationFormatUtilsTest",
        "DateFormatUtils",
        "equals",
        "testDateISO",
        "parsePattern",
        "testDateTimeISO",
        "testToString",
        "FastDateFormat",
        "getTimeZoneOverridesCalendar",
        "testTrunc",
        "appendTo",
        "getCalendarIterator"
      ]
    },
    "file": {
      "file_name": "FastDateFormat.java",
      "file_nloc": 776,
      "file_complexity": 204,
      "file_token_count": 4948,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -53,7 +53,6 @@\n  */\n package org.apache.commons.lang.time;\n \n-import java.io.Serializable;\n import java.text.DateFormat;\n import java.text.DateFormatSymbols;\n import java.text.FieldPosition;\n@@ -71,11 +70,18 @@\n import java.util.TimeZone;\n \n /**\n- * FastDateFormat is similar to {@link java.text.SimpleDateFormat}, but \n- * faster and thread-safe.\n+ * FastDateFormat is a fast and thread-safe version of {@link java.text.SimpleDateFormat}.\n  * <p>\n  * Only formatting is supported, but all patterns are compatible with\n- * SimpleDateFormat.\n+ * SimpleDateFormat (except timezones - see below).\n+ * <p>\n+ * Java 1.4 introduced a new pattern letter, 'Z', to represent time zones in\n+ * RFC822 format (eg. +0800 or -1100). This pattern letter can be used here (on\n+ * all JDK versions).\n+ * <p>\n+ * In addition, the pattern 'ZZ' has been made to represent ISO8601 full format\n+ * time zones (eg. +08:00 or -11:00). This introduces a minor incompatability with\n+ * Java 1.4, but at a gain of useful functionality.\n  * <p>\n  * NOTE: Code originally taken from the open source TreeTrove project.\n  *\n@@ -84,24 +90,34 @@\n  * @author Gary Gregory\n  * @author Stephen Colebourne\n  * @since 2.0\n- * @version $Id: FastDateFormat.java,v 1.5 2003/05/21 23:39:53 scolebourne Exp $\n+ * @version $Id: FastDateFormat.java,v 1.6 2003/06/08 23:14:23 scolebourne Exp $\n  */\n public class FastDateFormat extends Format {\n+    // A lot of the speed in this class comes from caching, but some comes\n+    // from the special int to StringBuffer conversion.\n+    //\n+    // The following produces a padded 2 digit number:\n+    //   buffer.append((char)(value / 10 + '0'));\n+    //   buffer.append((char)(value % 10 + '0'));\n+    //\n+    // Note that the fastest append to StringBuffer is a single char (used here).\n+    // Note that Integer.toString() is not called, the conversion is simply\n+    // taking the value and adding (mathematically) the ASCII value for '0'.\n+    // So, don't change this code! It works and is vary fast.\n     \n-    /** FULL date or time style */\n+    /** FULL locale dependent date or time style */\n     public static final int FULL = SimpleDateFormat.FULL;\n-    /** LONG date or time style */\n+    /** LONG locale dependent date or time style */\n     public static final int LONG = SimpleDateFormat.LONG;\n-    /** MEDIUM date or time style */\n+    /** MEDIUM locale dependent date or time style */\n     public static final int MEDIUM = SimpleDateFormat.MEDIUM;\n-    /** SHORT date or time style */\n+    /** SHORT locale dependent date or time style */\n     public static final int SHORT = SimpleDateFormat.SHORT;\n     \n     // package scoped as used by inner class\n     static final double LOG_10 = Math.log(10);\n \n     private static String cDefaultPattern;\n-    private static TimeZone cDefaultTimeZone = TimeZone.getDefault();\n \n     private static Map cInstanceCache = new HashMap(7);\n     private static Map cDateInstanceCache = new HashMap(7);\n@@ -113,12 +129,16 @@ public class FastDateFormat extends Format {\n     private final String mPattern;\n     /** The time zone */\n     private final TimeZone mTimeZone;\n+    /** Whether the time zone overrides any on Calendars */\n+    private final boolean mTimeZoneForced;\n     /** The locale */\n     private final Locale mLocale;\n+    /** Whether the locale overrides the default */\n+    private final boolean mLocaleForced;\n     /** The parsed rules */\n-    private final Rule[] mRules;\n+    private Rule[] mRules;\n     /** The estimated maximum length */\n-    private final int mMaxLengthEstimate;\n+    private int mMaxLengthEstimate;\n \n     //-----------------------------------------------------------------------\n     /**\n@@ -172,25 +192,15 @@ public static FastDateFormat getInstance(String pattern, Locale locale) {\n      * @param timeZone  optional time zone, overrides time zone of formatted date\n      * @param locale  optional locale, overrides system locale\n      * @return a pattern based date/time formatter\n-     * @throws IllegalArgumentException if pattern is invalid\n+     * @throws IllegalArgumentException if pattern is invalid or null\n      */\n     public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n-        Object key = pattern;\n-        if (timeZone != null) {\n-            key = new Pair(key, timeZone);\n-        }\n-        if (locale != null) {\n-            key = new Pair(key, locale);\n-        }\n-\n-        FastDateFormat format = (FastDateFormat) cInstanceCache.get(key);\n+        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n+        FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\n         if (format == null) {\n-            if (locale == null) {\n-                locale = Locale.getDefault();\n-            }\n-\n-            format = new FastDateFormat(pattern, timeZone, locale, new DateFormatSymbols(locale));\n-            cInstanceCache.put(key, format);\n+            format = emptyFormat;\n+            format.init();  // convert shell format into usable one\n+            cInstanceCache.put(format, format);  // this is OK!\n         }\n         return format;\n     }\n@@ -342,17 +352,62 @@ private static synchronized String getDefaultPattern() {\n         return cDefaultPattern;\n     }\n \n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new FastDateFormat.\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone  time zone to use, null means use default for Date and\n+     *                  value within for Calendar\n+     * @param locale  locale, null means use system default\n+     * @throws IllegalArgumentException if pattern is invalid or null\n+     */\n+    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n+        super();\n+        if (pattern == null) {\n+            throw new IllegalArgumentException(\"The pattern must not be null\");\n+        }\n+        mPattern = pattern;\n+        \n+        mTimeZoneForced = (timeZone != null);\n+        if (timeZone == null) {\n+            timeZone = TimeZone.getDefault();\n+        }\n+        mTimeZone = timeZone;\n+        \n+        mLocaleForced = (locale != null);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        mLocale = locale;\n+    }\n+\n+    /**\n+     * Initialise the instance for first use.\n+     */\n+    protected void init() {\n+        List rulesList = parsePattern();\n+        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n+\n+        int len = 0;\n+        for (int i=mRules.length; --i >= 0; ) {\n+            len += mRules[i].estimateLength();\n+        }\n+\n+        mMaxLengthEstimate = len;\n+    }\n+\n+    // Parse the pattern\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a list of Rules given a pattern.\n      * \n-     * @param pattern  the pattern to parse\n-     * @param timeZone  the time zone to use\n-     * @param locale  the locale to use\n-     * @param symbols  the symbols to use\n      * @return a List of Rule objects\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    private static List parse(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n+    protected List parsePattern() {\n+        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n         List rules = new ArrayList();\n \n         String[] ERAs = symbols.getEras();\n@@ -362,12 +417,12 @@ private static List parse(String pattern, TimeZone timeZone, Locale locale, Date\n         String[] shortWeekdays = symbols.getShortWeekdays();\n         String[] AmPmStrings = symbols.getAmPmStrings();\n \n-        int length = pattern.length();\n+        int length = mPattern.length();\n         int[] indexRef = new int[1];\n \n         for (int i = 0; i < length; i++) {\n             indexRef[0] = i;\n-            String token = parseToken(pattern, indexRef);\n+            String token = parseToken(mPattern, indexRef);\n             i = indexRef[0];\n \n             int tokenLen = token.length();\n@@ -384,9 +439,9 @@ private static List parse(String pattern, TimeZone timeZone, Locale locale, Date\n                 break;\n             case 'y': // year (number)\n                 if (tokenLen >= 4) {\n-                    rule = new UnpaddedNumberField(Calendar.YEAR);\n+                    rule = UnpaddedNumberField.INSTANCE_YEAR;\n                 } else {\n-                    rule = new TwoDigitYearField();\n+                    rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n@@ -395,9 +450,9 @@ private static List parse(String pattern, TimeZone timeZone, Locale locale, Date\n                 } else if (tokenLen == 3) {\n                     rule = new TextField(Calendar.MONTH, shortMonths);\n                 } else if (tokenLen == 2) {\n-                    rule = new TwoDigitMonthField();\n+                    rule = TwoDigitMonthField.INSTANCE;\n                 } else {\n-                    rule = new UnpaddedMonthField();\n+                    rule = UnpaddedMonthField.INSTANCE;\n                 }\n                 break;\n             case 'd': // day in month (number)\n@@ -444,9 +499,16 @@ private static List parse(String pattern, TimeZone timeZone, Locale locale, Date\n                 break;\n             case 'z': // time zone (text)\n                 if (tokenLen >= 4) {\n-                    rule = new TimeZoneRule(timeZone, locale, TimeZone.LONG);\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n                 } else {\n-                    rule = new TimeZoneRule(timeZone, locale, TimeZone.SHORT);\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n+                }\n+                break;\n+            case 'Z': // time zone (value)\n+                if (tokenLen == 1) {\n+                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n+                } else {\n+                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                 }\n                 break;\n             case '\\'': // literal text\n@@ -474,7 +536,7 @@ private static List parse(String pattern, TimeZone timeZone, Locale locale, Date\n      * @param indexRef  index references\n      * @return parsed token\n      */\n-    private static String parseToken(String pattern, int[] indexRef) {\n+    protected String parseToken(String pattern, int[] indexRef) {\n         StringBuffer buf = new StringBuffer();\n \n         int i = indexRef[0];\n@@ -533,7 +595,7 @@ private static String parseToken(String pattern, int[] indexRef) {\n      * @param padding  the padding required\n      * @return a new rule with the correct padding\n      */\n-    private static NumberRule selectNumberRule(int field, int padding) {\n+    protected NumberRule selectNumberRule(int field, int padding) {\n         switch (padding) {\n         case 1:\n             return new UnpaddedNumberField(field);\n@@ -544,40 +606,7 @@ private static NumberRule selectNumberRule(int field, int padding) {\n         }\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a new FastDateFormat.\n-     * \n-     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone  optional time zone, overrides time zone of formatted date\n-     * @param locale  optional locale, overrides system locale\n-     * @param symbols  optional date format symbols, overrides symbols for provided locale\n-     * @throws IllegalArgumentException if pattern is invalid\n-     */\n-    private FastDateFormat(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-\n-        mPattern = pattern;\n-        mTimeZone = timeZone;\n-        mLocale = locale;\n-\n-        if (symbols == null) {\n-            symbols = new DateFormatSymbols(locale);\n-        }\n-\n-        List rulesList = parse(pattern, timeZone, locale, symbols);\n-        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n-\n-        int len = 0;\n-        for (int i=mRules.length; --i >= 0; ) {\n-            len += mRules[i].estimateLength();\n-        }\n-\n-        mMaxLengthEstimate = len;\n-    }\n-\n+    // Format methods\n     //-----------------------------------------------------------------------\n     /**\n      * Format either a Date or a Calendar object.\n@@ -605,11 +634,8 @@ public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition po\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(cDefaultTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n-        if (mTimeZone != null) {\n-            c.setTimeZone(mTimeZone);\n-        }\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n@@ -631,11 +657,8 @@ public String format(Calendar calendar) {\n      * @return the specified string buffer\n      */\n     public StringBuffer format(Date date, StringBuffer buf) {\n-        Calendar c = new GregorianCalendar(cDefaultTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n-        if (mTimeZone != null) {\n-            c.setTimeZone(mTimeZone);\n-        }\n         return applyRules(c, buf);\n     }\n \n@@ -647,8 +670,8 @@ public StringBuffer format(Date date, StringBuffer buf) {\n      * @return the specified string buffer\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n-        if (mTimeZone != null) {\n-            calendar = (Calendar)calendar.clone();\n+        if (mTimeZoneForced) {\n+            calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }\n         return applyRules(calendar, buf);\n@@ -661,7 +684,7 @@ public StringBuffer format(Calendar calendar, StringBuffer buf) {\n      * @param buf  the buffer to format into\n      * @return the specified string buffer\n      */\n-    private StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n         Rule[] rules = mRules;\n         int len = mRules.length;\n         for (int i = 0; i < len; i++) {\n@@ -670,6 +693,7 @@ private StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n         return buf;\n     }\n \n+    // Parsing\n     //-----------------------------------------------------------------------\n     /**\n      * Parsing not supported.\n@@ -684,6 +708,7 @@ public Object parseObject(String source, ParsePosition pos) {\n         return null;\n     }\n     \n+    // Accessors\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the pattern used by this formatter.\n@@ -695,8 +720,11 @@ public String getPattern() {\n     }\n \n     /**\n-     * Gets the time zone used by this formatter, or null if time zone of\n-     * formatted dates is used instead.\n+     * Gets the time zone used by this formatter.\n+     * <p>\n+     * This zone is always used for Date formatting.\n+     * If a Calendar is passed in to be formatted, the time zone on that may\n+     * be used depending on {@link #getTimeZoneOverridesCalendar()}.\n      * \n      * @return the time zone\n      */\n@@ -704,6 +732,16 @@ public TimeZone getTimeZone() {\n         return mTimeZone;\n     }\n \n+    /**\n+     * Returns true if the time zone of the calendar overrides the time zone\n+     * of the formatter\n+     * \n+     * @return true if time zone of formatter overridden for calendars\n+     */\n+    public boolean getTimeZoneOverridesCalendar() {\n+        return mTimeZoneForced;\n+    }\n+\n     /**\n      * Gets the locale used by this formatter.\n      * \n@@ -723,6 +761,56 @@ public int getMaxLengthEstimate() {\n         return mMaxLengthEstimate;\n     }\n \n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare two objects for equality.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof FastDateFormat == false) {\n+            return false;\n+        }\n+        FastDateFormat other = (FastDateFormat) obj;\n+        if (\n+            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n+            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n+            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n+            (mTimeZoneForced == other.mTimeZoneForced) &&\n+            (mLocaleForced == other.mLocaleForced)\n+            ) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * A suitable hashcode.\n+     * \n+     * @return a hashcode compatable with equals\n+     */\n+    public int hashCode() {\n+        int total = 0;\n+        total += mPattern.hashCode();\n+        total += mTimeZone.hashCode();\n+        total += (mTimeZoneForced ? 1 : 0);\n+        total += mLocale.hashCode();\n+        total += (mLocaleForced ? 1 : 0);\n+        return total;\n+    }\n+\n+    /**\n+     * Gets a debugging string version of this formatter.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        return \"FastDateFormat[\" + mPattern + \"]\";\n+    }\n+    \n+    // Rules\n     //-----------------------------------------------------------------------\n     /**\n      * Inner class defining a rule.\n@@ -809,6 +897,8 @@ public void appendTo(StringBuffer buffer, Calendar calendar) {\n      * Inner class to output an unpadded number.\n      */\n     private static class UnpaddedNumberField implements NumberRule {\n+        static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);\n+        \n         private final int mField;\n \n         UnpaddedNumberField(int field) {\n@@ -826,12 +916,10 @@ public void appendTo(StringBuffer buffer, Calendar calendar) {\n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n-            }\n-            else if (value < 100) {\n+            } else if (value < 100) {\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n-            }\n-            else {\n+            } else {\n                 buffer.append(Integer.toString(value));\n             }\n         }\n@@ -841,6 +929,8 @@ else if (value < 100) {\n      * Inner class to output an unpadded month.\n      */\n     private static class UnpaddedMonthField implements NumberRule {\n+        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n+        \n         UnpaddedMonthField() {\n         }\n \n@@ -855,8 +945,7 @@ public void appendTo(StringBuffer buffer, Calendar calendar) {\n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n-            }\n-            else {\n+            } else {\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n             }\n@@ -894,13 +983,11 @@ public final void appendTo(StringBuffer buffer, int value) {\n                 }\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n-            }\n-            else {\n+            } else {\n                 int digits;\n                 if (value < 1000) {\n                     digits = 3;\n-                }\n-                else {\n+                } else {\n                     digits = (int)(Math.log(value) / LOG_10) + 1;\n                 }\n                 for (int i = mSize; --i >= digits; ) {\n@@ -933,8 +1020,7 @@ public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 100) {\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n-            }\n-            else {\n+            } else {\n                 buffer.append(Integer.toString(value));\n             }\n         }\n@@ -944,6 +1030,8 @@ public final void appendTo(StringBuffer buffer, int value) {\n      * Inner class to output a two digit year.\n      */\n     private static class TwoDigitYearField implements NumberRule {\n+        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n+        \n         TwoDigitYearField() {\n         }\n \n@@ -965,6 +1053,8 @@ public final void appendTo(StringBuffer buffer, int value) {\n      * Inner class to output a two digit month.\n      */\n     private static class TwoDigitMonthField implements NumberRule {\n+        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n+        \n         TwoDigitMonthField() {\n         }\n \n@@ -1037,71 +1127,101 @@ public void appendTo(StringBuffer buffer, int value) {\n     }\n \n     /**\n-     * Inner class to output a time zone.\n+     * Inner class to output a time zone name.\n      */\n-    private static class TimeZoneRule implements Rule {\n+    private static class TimeZoneNameRule implements Rule {\n         private final TimeZone mTimeZone;\n+        private final boolean mTimeZoneForced;\n         private final Locale mLocale;\n         private final int mStyle;\n         private final String mStandard;\n         private final String mDaylight;\n \n-        TimeZoneRule(TimeZone timeZone, Locale locale, int style) {\n+        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n             mTimeZone = timeZone;\n+            mTimeZoneForced = timeZoneForced;\n             mLocale = locale;\n             mStyle = style;\n \n-            if (timeZone != null) {\n+            if (timeZoneForced) {\n                 mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n                 mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n-            }\n-            else {\n+            } else {\n                 mStandard = null;\n                 mDaylight = null;\n             }\n         }\n \n         public int estimateLength() {\n-            if (mTimeZone != null) {\n+            if (mTimeZoneForced) {\n                 return Math.max(mStandard.length(), mDaylight.length());\n-            }\n-            else if (mStyle == TimeZone.SHORT) {\n+            } else if (mStyle == TimeZone.SHORT) {\n                 return 4;\n-            }\n-            else {\n+            } else {\n                 return 40;\n             }\n         }\n \n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            TimeZone timeZone;\n-            if ((timeZone = mTimeZone) != null) {\n-                if (timeZone.useDaylightTime() &&\n-                    calendar.get(Calendar.DST_OFFSET) != 0) {\n-\n+            if (mTimeZoneForced) {\n+                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                     buffer.append(mDaylight);\n-                }\n-                else {\n+                } else {\n                     buffer.append(mStandard);\n                 }\n-            }\n-            else {\n-                timeZone = calendar.getTimeZone();\n-                if (timeZone.useDaylightTime() &&\n-                    calendar.get(Calendar.DST_OFFSET) != 0) {\n-\n-                    buffer.append(getTimeZoneDisplay\n-                                  (timeZone, true, mStyle, mLocale));\n-                }\n-                else {\n-                    buffer.append(getTimeZoneDisplay\n-                                  (timeZone, false, mStyle, mLocale));\n+            } else {\n+                TimeZone timeZone = calendar.getTimeZone();\n+                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n+                } else {\n+                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n                 }\n             }\n         }\n     }\n \n-    // ----------------------------------------------------------------------------------\n+    /**\n+     * Inner class to output a time zone as a number +/-HHMM or +/-HH:MM.\n+     */\n+    private static class TimeZoneNumberRule implements Rule {\n+        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n+        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n+        \n+        final boolean mColon;\n+        \n+        TimeZoneNumberRule(boolean colon) {\n+            mColon = colon;\n+        }\n+\n+        public int estimateLength() {\n+            return 5;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n+            \n+            if (offset < 0) {\n+                buffer.append('-');\n+                offset = -offset;\n+            } else {\n+                buffer.append('+');\n+            }\n+            \n+            int hours = offset / (60 * 60 * 1000);\n+            buffer.append((char)(hours / 10 + '0'));\n+            buffer.append((char)(hours % 10 + '0'));\n+            \n+            if (mColon) {\n+                buffer.append(':');\n+            }\n+            \n+            int minutes = offset / (60 * 1000) - 60 * hours;\n+            buffer.append((char)(minutes / 10 + '0'));\n+            buffer.append((char)(minutes % 10 + '0'));\n+        }            \n+    }\n+\n+    // ----------------------------------------------------------------------\n     /**\n      * Inner class that acts as a compound key for time zone names.\n      */\n@@ -1139,12 +1259,12 @@ public boolean equals(Object obj) {\n         }\n     }\n \n-    // ----------------------------------------------------------------------------------\n+    // ----------------------------------------------------------------------\n     /**\n      * Helper class for creating compound objects.  One use for this class is to create a\n      * hashtable key out of multiple objects.\n      */\n-    private static class Pair implements Comparable, Serializable {\n+    private static class Pair {\n         private final Object mObj1;\n         private final Object mObj2;\n \n@@ -1153,56 +1273,6 @@ public Pair(Object obj1, Object obj2) {\n             mObj2 = obj2;\n         }\n \n-        public int compareTo(Object obj) {\n-            if (this == obj) {\n-                return 0;\n-            }\n-\n-            Pair other = (Pair)obj;\n-\n-            Object a = mObj1;\n-            Object b = other.mObj1;\n-\n-            firstTest: {\n-                if (a == null) {\n-                    if (b != null) {\n-                        return 1;\n-                    }\n-                    // Both a and b are null.\n-                    break firstTest;\n-                }\n-                else {\n-                    if (b == null) {\n-                        return -1;\n-                    }\n-                }\n-\n-                int result = ((Comparable)a).compareTo(b);\n-\n-                if (result != 0) {\n-                    return result;\n-                }\n-            }\n-\n-            a = mObj2;\n-            b = other.mObj2;\n-\n-            if (a == null) {\n-                if (b != null) {\n-                    return 1;\n-                }\n-                // Both a and b are null.\n-                return 0;\n-            }\n-            else {\n-                if (b == null) {\n-                    return -1;\n-                }\n-            }\n-\n-            return ((Comparable)a).compareTo(b);\n-        }\n-\n         public boolean equals(Object obj) {\n             if (this == obj) {\n                 return true;\n",
      "files_name_in_blame_commit": [
        "FastDateFormat.java",
        "DurationFormatUtils.java",
        "CalendarUtilsTest.java",
        "StopWatch.java",
        "DurationFormatUtilsTest.java",
        "StopWatchTest.java",
        "DateUtilsTest.java",
        "FastDateFormatTest.java",
        "TimeTestSuite.java",
        "DateUtils.java",
        "DateFormatUtilsTest.java",
        "DateFormatUtils.java",
        "CalendarUtils.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 51
  }
}
{
  "id": "35",
  "blame_commit": {
    "commit": {
      "commit_id": "2f7454a01e4c2992bffc3d86137e632e80c5027f",
      "commit_message": "[#CODEC-75] Make Base64 URL-safe. Applied patch (https://issues.apache.org/jira/secure/attachment/12408898/codec75.patch) and make other clean ups.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@793704 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_date": "2009-07-13 20:37:32",
      "commit_parent": "875e5cfbc1a13550387262293ccdf450bded8b56"
    },
    "function": {
      "function_name": "Base64",
      "function_code_before": "public Base64() {\n    this(CHUNK_SIZE, CHUNK_SEPARATOR);\n}",
      "function_code_after": "public Base64() {\n    this(false);\n}",
      "function_before_start_line": 181,
      "function_before_end_line": 183,
      "function_after_start_line": 210,
      "function_after_end_line": 212,
      "function_before_token_count": 12,
      "function_after_token_count": 10,
      "functions_name_modified_file": [
        "encodeBase64",
        "setInitialBuffer",
        "decodeInteger",
        "encodeBase64URLSafe",
        "decode",
        "isUrlSafe",
        "resizeBuf",
        "containsBase64Byte",
        "decodeBase64",
        "avail",
        "isArrayByteBase64",
        "Base64",
        "isBase64",
        "readResults",
        "isWhiteSpace",
        "encodeInteger",
        "toIntegerBytes",
        "hasData",
        "discardNonBase64",
        "encode",
        "encodeBase64Chunked",
        "discardWhitespace"
      ],
      "functions_name_all_files": [
        "encodeBase64",
        "testDiscardWhitespace",
        "testDecodePadOnlyChunked",
        "testCodeInteger3",
        "toString",
        "setInitialBuffer",
        "decodeInteger",
        "encodeBase64URLSafe",
        "testObjectDecodeWithInvalidParameter",
        "decode",
        "testDecodePadMarkerIndex3",
        "isUrlSafe",
        "testRfc2045Section2Dot1CrLfDefinition",
        "testTripletsChunked",
        "testIgnoringNonBase64InDecode",
        "resizeBuf",
        "testTriplets",
        "testCodeIntegerNull",
        "testCodeIntegerEdgeCases",
        "testCodeInteger4",
        "containsBase64Byte",
        "decodeBase64",
        "testKnownEncodings",
        "testObjectEncodeWithValidParameter",
        "avail",
        "isArrayByteBase64",
        "Base64",
        "testEncodeDecodeSmall",
        "isBase64",
        "testRfc2045Section6Dot8ChunkSizeDefinition",
        "testObjectDecodeWithValidParameter",
        "testConstructors",
        "testObjectEncodeWithInvalidParameter",
        "readResults",
        "testBase64",
        "Base64Test",
        "testDecodePadOnly",
        "testUUID",
        "testSingletonsChunked",
        "testNonBase64Test",
        "testSingletons",
        "isWhiteSpace",
        "encodeInteger",
        "testCodec68",
        "toIntegerBytes",
        "testEncodeDecodeRandom",
        "getRandom",
        "hasData",
        "testPairs",
        "discardNonBase64",
        "testIsArrayByteBase64",
        "testKnownDecodings",
        "encode",
        "testDecodeWithWhitespace",
        "encodeBase64Chunked",
        "testCodeInteger2",
        "discardWhitespace",
        "testCodeInteger1",
        "testDecodePadMarkerIndex2"
      ],
      "functions_name_co_evolved_modified_file": [
        "readResults",
        "hasData",
        "encodeBase64",
        "discardNonBase64",
        "encodeInteger",
        "encode",
        "decodeBase64",
        "isBase64",
        "avail",
        "encodeBase64URLSafe",
        "Base64",
        "discardWhitespace",
        "isWhiteSpace",
        "decode",
        "isUrlSafe",
        "toIntegerBytes"
      ],
      "functions_name_co_evolved_all_files": [
        "readResults",
        "hasData",
        "encodeBase64",
        "discardNonBase64",
        "encodeInteger",
        "encode",
        "testUUID",
        "decodeBase64",
        "isBase64",
        "avail",
        "encodeBase64URLSafe",
        "Base64",
        "discardWhitespace",
        "isWhiteSpace",
        "decode",
        "isUrlSafe",
        "toIntegerBytes"
      ]
    },
    "file": {
      "file_name": "Base64.java",
      "file_nloc": 387,
      "file_complexity": 110,
      "file_token_count": 3215,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -66,7 +66,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * Thanks to \"commons\" project in ws.apache.org for this code. \n      * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n      */\n-    private static final byte[] intToBase64 = {\n+    private static final byte[] STANDARD_ENCODE_TABLE = {\n             'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n             'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n             'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n@@ -74,28 +74,45 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n     };\n \n+    /**\n+     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n+     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n+     * This table is only used when the Base64's mode is set to URL-SAFE.\n+     */    \n+    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+    };\n+\n     /**\n      * Byte used to pad output.\n      */\n     private static final byte PAD = '=';\n \n     /**\n-     * This array is a lookup table that translates unicode characters\n+     * This array is a lookup table that translates Unicode characters\n      * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n      * into their 6-bit positive integer equivalents.  Characters that\n      * are not in the Base64 alphabet but fall within the bounds of the\n      * array are translated to -1.\n      *\n+     * Note:  '+' and '-' both decode to 62.  '/' and '_' both decode to 63.\n+     * This means decoder seamlessly handles both URL_SAFE and STANDARD base64.\n+     * (The encoder, on the other hand, needs to know ahead of time what to emit).\n+     *\n      * Thanks to \"commons\" project in ws.apache.org for this code.\n      * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n      */\n-    private static final byte[] base64ToInt = {\n+    private static final byte[] DECODE_TABLE = {\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n             55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n             5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-            24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n             35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n     };\n \n@@ -109,6 +126,12 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n     // The private member fields below are used with the new streaming approach, which requires\n     // some state be preserved between calls of encode() and decode().\n \n+    /**\n+     * Encode table to use:  either STANDARD or URL_SAFE.  Note:  the DECODE_TABLE above remains static\n+     * because it is able to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member\n+     * variable so we can switch between the two modes.\n+     */\n+    private final byte[] encodeTable;\n \n     /**\n      * Line length for encoding.  Not used when decoding.  A value of zero or less implies\n@@ -175,27 +198,44 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n     private int x;\n \n     /**\n-     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF\n-     * when encoding, and all forms can be decoded.\n+     * Sets state for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 76, the line separator is CRLF, and we use the STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * \n+     * <p>\n+     * When decoding all variants can be decoded.\n+     * </p>\n      */\n     public Base64() {\n-        this(CHUNK_SIZE, CHUNK_SEPARATOR);\n+        this(false);\n+    }\n+\n+    /**\n+     * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is\n+     * supplied.\n+     * \n+     * When decoding: all variants can be decoded.\n+     * \n+     * @param urlSafe\n+     *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.\n+     */\n+    public Base64(boolean urlSafe) {\n+        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n     }\n \n     /**\n      * <p>\n-     * Consumer can use this constructor to choose a different lineLength\n-     * when encoding (lineSeparator is still CRLF).  All forms of data can\n-     * be decoded.\n-     * </p><p>\n-     * Note:  lineLengths that aren't multiples of 4 will still essentially\n-     * end up being multiples of 4 in the encoded data.\n+     * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.\n      * </p>\n-     *\n-     * @param lineLength each line of encoded data will be at most this long\n-     * (rounded up to nearest multiple of 4). \n-     * If lineLength <= 0, then the output will not be divided into lines (chunks).  \n-     * Ignored when decoding.\n+     * <p>\n+     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n+     * data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If\n+     *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      */\n     public Base64(int lineLength) {\n         this(lineLength, CHUNK_SEPARATOR);\n@@ -203,9 +243,30 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n \n     /**\n      * <p>\n-     * Consumer can use this constructor to choose a different lineLength\n-     * and lineSeparator when encoding.  All forms of data can\n-     * be decoded.\n+     * Sets the line length and line separator when encoding. All forms of data can be decoded.\n+     * </p>\n+     * <p>\n+     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n+     * data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most this long (rounded up to nearest multiple of 4). Ignored\n+     *            when decoding. If <= 0, then output will not be divided into lines (chunks).\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some base64 characters. That's not going to work!\n+     */\n+    public Base64(int lineLength, byte[] lineSeparator) {\n+        this(lineLength, lineSeparator, false);\n+    }\n+\n+    /**\n+     * <p>\n+     * Consumer can use this constructor to choose a different lineLength,\n+     * lineSeparator, and whether to use URL-SAFE mode when encoding.\n+     * All forms of data can be decoded.\n      * </p><p>\n      * Note:  lineLengths that aren't multiples of 4 will still essentially\n      * end up being multiples of 4 in the encoded data.\n@@ -216,10 +277,14 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * @param lineSeparator Each line of encoded data will end with this\n      *                      sequence of bytes.\n      *                      If lineLength <= 0, then the lineSeparator is not used.\n+     * @param urlSafe       Instead of emitting '+' and '/' we emit '-' and '_' respectively.\n+     *                      urlSafe is only applied to \"encode\" operations.  Decoding seamlessly\n+     *                      handles both modes.\n+     *\n      * @throws IllegalArgumentException The provided lineSeparator included\n      *                                  some base64 characters.  That's not going to work!\n      */\n-    public Base64(int lineLength, byte[] lineSeparator) {\n+    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n         this.lineLength = lineLength;\n         this.lineSeparator = new byte[lineSeparator.length];\n         System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n@@ -228,7 +293,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         } else {\n             this.encodeSize = 4;\n         }\n-        this.decodeSize = encodeSize - 1;\n+        this.decodeSize = this.encodeSize - 1;\n         if (containsBase64Byte(lineSeparator)) {\n             String sep;\n             try {\n@@ -238,21 +303,35 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             }\n             throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n         }\n+        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n+    }\n+\n+    /**\n+     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n+     * \n+     * @return true if we're in URL-SAFE mode, false otherwise.\n+     */\n+    public boolean isUrlSafe() {\n+        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n     }\n \n     /**\n      * Returns true if this Base64 object has buffered data for reading.\n-     *\n+     * \n      * @return true if there is Base64 object still available for reading.\n      */\n-    boolean hasData() { return buf != null; }\n+    boolean hasData() {\n+        return this.buf != null;\n+    }\n \n     /**\n      * Returns the amount of buffered data available for reading.\n-     *\n+     * \n      * @return The amount of buffered data available for reading.\n      */\n-    int avail() { return buf != null ? pos - readPos : 0; }\n+    int avail() {\n+        return buf != null ? pos - readPos : 0;\n+    }\n \n     /** Doubles our buffer. */\n     private void resizeBuf() {\n@@ -294,9 +373,8 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n                 buf = null;\n             }\n             return len;\n-        } else {\n-            return eof ? -1 : 0;\n         }\n+        return eof ? -1 : 0;\n     }\n \n     /**\n@@ -337,7 +415,6 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         if (eof) {\n             return;\n         }\n-\n         // inAvail < 0 is how we're informed of EOF in the underlying data we're\n         // encoding.\n         if (inAvail < 0) {\n@@ -347,17 +424,23 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             }\n             switch (modulus) {\n                 case 1:\n-                    buf[pos++] = intToBase64[(x >> 2) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x << 4) & MASK_6BITS];\n-                    buf[pos++] = PAD;\n-                    buf[pos++] = PAD;\n+                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n+                    // URL-SAFE skips the padding to further reduce size.\n+                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n+                        buf[pos++] = PAD;\n+                        buf[pos++] = PAD;\n+                    }\n                     break;\n \n                 case 2:\n-                    buf[pos++] = intToBase64[(x >> 10) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x >> 4) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x << 2) & MASK_6BITS];\n-                    buf[pos++] = PAD;\n+                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n+                    // URL-SAFE skips the padding to further reduce size.\n+                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n+                        buf[pos++] = PAD;\n+                    }\n                     break;\n             }\n             if (lineLength > 0) {\n@@ -374,10 +457,10 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n                 if (b < 0) { b += 256; }\n                 x = (x << 8) + b;\n                 if (0 == modulus) {\n-                    buf[pos++] = intToBase64[(x >> 18) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x >> 12) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x >> 6) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[x & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                     currentLinePos += 4;\n                     if (lineLength > 0 && lineLength <= currentLinePos) {\n                         System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n@@ -423,23 +506,12 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             }\n             byte b = in[inPos++];\n             if (b == PAD) {\n-                x = x << 6;\n-                switch (modulus) {\n-                    case 2:\n-                        x = x << 6;\n-                        buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                        break;\n-                    case 3:\n-                        buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                        buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                        break;\n-                }\n                 // WE'RE DONE!!!!\n                 eof = true;\n-                return;\n+                break;\n             } else {\n-                if (b >= 0 && b < base64ToInt.length) {\n-                    int result = base64ToInt[b];\n+                if (b >= 0 && b < DECODE_TABLE.length) {\n+                    int result = DECODE_TABLE[b];\n                     if (result >= 0) {\n                         modulus = (++modulus) % 4;\n                         x = (x << 6) + result;\n@@ -452,6 +524,23 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n                 }\n             }\n         }\n+\n+        // Two forms of EOF as far as base64 decoder is concerned:  actual\n+        // EOF (-1) and first time '=' character is encountered in stream.\n+        // This approach makes the '=' padding characters completely optional.\n+        if (eof && modulus != 0) {\n+            x = x << 6;\n+            switch (modulus) {\n+                case 2:\n+                    x = x << 6;\n+                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    break;\n+                case 3:\n+                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                    break;\n+            }\n+        }\n     }\n \n     /**\n@@ -462,7 +551,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n      */\n     public static boolean isBase64(byte octet) {\n-        return octet == PAD || (octet >= 0 && octet < base64ToInt.length && base64ToInt[octet] != -1);\n+        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n     }\n \n     /**\n@@ -483,7 +572,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         return true;\n     }\n \n-    /*\n+    /**\n      * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n      * \n      * @param arrayOctet\n@@ -510,6 +599,19 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         return encodeBase64(binaryData, false);\n     }\n \n+    /**\n+     * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.\n+     * The url-safe variation emits - and _ instead of + and / characters.\n+     *\n+     * @param binaryData\n+     *            binary data to encode\n+     * @return Base64 characters\n+     */\n+    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n+        return encodeBase64(binaryData, false, true);\n+    }\n+    \n+\n     /**\n      * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n      * \n@@ -561,11 +663,27 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      */\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n+        return encodeBase64(binaryData, isChunked, false);\n+    }\n+\n+    /**\n+     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n+     *\n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n+     * @param urlSafe\n+     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n+     * @return Base64-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n+     */\n+    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n-        Base64 b64 = isChunked ? new Base64() : new Base64(0);\n-\n+        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n         long len = (binaryData.length * 4) / 3;\n         long mod = len % 4;\n         if (mod != 0) {\n@@ -574,7 +692,6 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         if (isChunked) {\n             len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n         }\n-\n         if (len > Integer.MAX_VALUE) {\n             throw new IllegalArgumentException(\n                     \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n@@ -583,11 +700,17 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         b64.setInitialBuffer(buf, 0, buf.length);\n         b64.encode(binaryData, 0, binaryData.length);\n         b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n-\n         // Encoder might have resized, even though it was unnecessary.\n         if (b64.buf != buf) {\n             b64.readResults(buf, 0, buf.length);\n         }\n+        // In URL-SAFE mode we skip the padding characters, so sometimes our\n+        // final length is a bit smaller.\n+        if (urlSafe && b64.pos < buf.length) {\n+            byte[] smallerBuf = new byte[b64.pos];\n+            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n+            buf = smallerBuf;\n+        }\n         return buf;\n     }\n \n@@ -602,13 +725,11 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             return base64Data;\n         }\n         Base64 b64 = new Base64();\n-\n         long len = (base64Data.length * 3) / 4;\n         byte[] buf = new byte[(int) len];\n         b64.setInitialBuffer(buf, 0, buf.length);\n         b64.decode(base64Data, 0, base64Data.length);\n         b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n-\n         // We have no idea what the line-length was, so we\n         // cannot know how much of our array wasn't used.\n         byte[] result = new byte[b64.pos];\n@@ -627,7 +748,6 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n     static byte[] discardWhitespace(byte[] data) {\n         byte groomedData[] = new byte[data.length];\n         int bytesCopied = 0;\n-\n         for (int i = 0; i < data.length; i++) {\n             switch (data[i]) {\n                 case ' ' :\n@@ -639,30 +759,28 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n                     groomedData[bytesCopied++] = data[i];\n             }\n         }\n-\n         byte packedData[] = new byte[bytesCopied];\n-\n         System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n-\n         return packedData;\n     }\n \n \n     /**\n-     * Check if a byte value is whitespace or not.\n+     * Checks if a byte value is whitespace or not.\n      * \n-     * @param byteToCheck the byte to check\n+     * @param byteToCheck\n+     *            the byte to check\n      * @return true if byte is whitespace, false otherwise\n      */\n-    private static boolean isWhiteSpace(byte byteToCheck){\n+    private static boolean isWhiteSpace(byte byteToCheck) {\n         switch (byteToCheck) {\n-        case ' ' :\n-        case '\\n' :\n-        case '\\r' :\n-        case '\\t' :\n-            return true;\n-        default :\n-            return false;\n+            case ' ' :\n+            case '\\n' :\n+            case '\\r' :\n+            case '\\t' :\n+                return true;\n+            default :\n+                return false;\n         }\n     }\n \n@@ -677,17 +795,13 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n     static byte[] discardNonBase64(byte[] data) {\n         byte groomedData[] = new byte[data.length];\n         int bytesCopied = 0;\n-\n         for (int i = 0; i < data.length; i++) {\n             if (isBase64(data[i])) {\n                 groomedData[bytesCopied++] = data[i];\n             }\n         }\n-\n         byte packedData[] = new byte[bytesCopied];\n-\n         System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n-\n         return packedData;\n     }\n \n@@ -718,12 +832,12 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * @return A byte array containing only Base64 character data\n      */\n     public byte[] encode(byte[] pArray) {\n-        return encodeBase64(pArray, false);\n+        return encodeBase64(pArray, false, isUrlSafe());\n     }\n \n     // Implementation of integer encoding used for crypto\n     /**\n-     * Decode a byte64-encoded integer according to crypto\n+     * Decodes a byte64-encoded integer according to crypto\n      * standards such as W3C's XML-Signature\n      * \n      * @param pArray a byte array containing base64 character data\n@@ -734,7 +848,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n     }\n \n     /**\n-     * Encode to a byte64-encoded integer according to crypto\n+     * Encodes to a byte64-encoded integer according to crypto\n      * standards such as W3C's XML-Signature\n      * \n      * @param bigInt a BigInteger\n@@ -745,7 +859,6 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         if(bigInt == null)  {\n             throw new NullPointerException(\"encodeInteger called with null parameter\");\n         }\n-\n         return encodeBase64(toIntegerBytes(bigInt), false);\n     }\n \n@@ -766,7 +879,6 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n             return bigBytes;\n         }\n-\n         // set up params for copying everything but sign bit\n         int startSrc = 0;\n         int len = bigBytes.length;\n@@ -776,12 +888,9 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             startSrc = 1;\n             len--;\n         }\n-\n         int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n         byte[] resizedBytes = new byte[bitlen / 8];\n-\n         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n-\n         return resizedBytes;\n     }\n }\n",
      "files_name_in_blame_commit": [
        "Base64.java",
        "Base64Test.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 62
  }
}
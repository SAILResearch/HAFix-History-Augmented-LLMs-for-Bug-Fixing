{
  "id": "77",
  "blame_commit": {
    "commit": {
      "commit_id": "4f5a56459a98e21780d813919da66de9eee91b74",
      "commit_message": "Changelog for #753 and tidied up comments a little\n\nFixes #753",
      "commit_author": "Jonathan Hedley",
      "commit_date": "2016-08-24 17:04:45",
      "commit_parent": "6e295d4428e4f04baf65c704f00f3142b46f34ff"
    },
    "function": {
      "function_name": "hasClass",
      "function_code_before": "public boolean hasClass(String className) {\n    String classAttr = attributes.get(\"class\");\n    final int end = classAttr.length();\n    final int classNameLength = className.length();\n\n    // class attribute is empty or the requested class name is 'too' long\n    if (end == 0 || end < classNameLength) {\n        return false;\n    }\n\n    // if both length are equals, just compare the className with the attribute\n    if(end == classNameLength) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // manually split the different class names in the class attibute\n    // DO NOT allocate the string but use regionMatches and length comparaison to make the check\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < end; i ++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if(inClass) {\n                // the white space ends a class name\n                // compare it with the requested one\n                if(i-start == classNameLength && classAttr.regionMatches(true, start, className, 0, classNameLength)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        }\n        else {\n            if(!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // the attribute may not end by a white space\n    // check the current class name\n    if(inClass && end-start == classNameLength) {\n        return classAttr.regionMatches(true, start, className, 0, classNameLength);  \n    }\n\n    return false;\n}",
      "function_code_after": "public boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}",
      "function_before_start_line": 1068,
      "function_before_end_line": 1114,
      "function_after_start_line": 1061,
      "function_after_end_line": 1102,
      "function_before_token_count": 197,
      "function_after_token_count": 198,
      "functions_name_modified_file": [
        "prependElement",
        "hasClass",
        "before",
        "accumulateParents",
        "elementSiblingIndex",
        "id",
        "firstElementSibling",
        "toString",
        "removeClass",
        "child",
        "clone",
        "isBlock",
        "getElementsByAttributeValueEnding",
        "getElementsByAttributeValue",
        "getElementsByAttribute",
        "getElementsByAttributeValueMatching",
        "appendNormalisedText",
        "appendWhitespaceIfBr",
        "textNodes",
        "getElementsByAttributeStarting",
        "getElementsByIndexGreaterThan",
        "val",
        "getElementsByIndexEquals",
        "getElementsByIndexLessThan",
        "select",
        "html",
        "getElementsByAttributeValueStarting",
        "getAllElements",
        "appendChild",
        "append",
        "prepend",
        "getElementsByTag",
        "dataNodes",
        "after",
        "toggleClass",
        "outerHtmlTail",
        "tag",
        "getElementById",
        "prependChild",
        "getElementsContainingOwnText",
        "getElementsMatchingText",
        "insertChildren",
        "parents",
        "getElementsByAttributeValueNot",
        "getElementsByAttributeValueContaining",
        "getElementsMatchingOwnText",
        "wrap",
        "classNames",
        "attr",
        "lastElementSibling",
        "dataset",
        "outerHtmlHead",
        "parent",
        "nextElementSibling",
        "cssSelector",
        "previousElementSibling",
        "text",
        "empty",
        "preserveWhitespace",
        "tagName",
        "data",
        "prependText",
        "nodeName",
        "siblingElements",
        "getElementsByClass",
        "children",
        "ownText",
        "indexInList",
        "hasText",
        "className",
        "appendElement",
        "Element",
        "getElementsContainingText",
        "appendText",
        "addClass"
      ],
      "functions_name_all_files": [
        "prependElement",
        "hasClass",
        "before",
        "accumulateParents",
        "elementSiblingIndex",
        "id",
        "firstElementSibling",
        "toString",
        "removeClass",
        "child",
        "clone",
        "isBlock",
        "getElementsByAttributeValueEnding",
        "getElementsByAttributeValue",
        "getElementsByAttribute",
        "getElementsByAttributeValueMatching",
        "appendNormalisedText",
        "appendWhitespaceIfBr",
        "textNodes",
        "getElementsByAttributeStarting",
        "getElementsByIndexGreaterThan",
        "val",
        "getElementsByIndexEquals",
        "getElementsByIndexLessThan",
        "select",
        "html",
        "getElementsByAttributeValueStarting",
        "getAllElements",
        "appendChild",
        "append",
        "prepend",
        "getElementsByTag",
        "dataNodes",
        "after",
        "toggleClass",
        "outerHtmlTail",
        "tag",
        "getElementById",
        "prependChild",
        "getElementsContainingOwnText",
        "getElementsMatchingText",
        "insertChildren",
        "parents",
        "getElementsByAttributeValueNot",
        "getElementsByAttributeValueContaining",
        "getElementsMatchingOwnText",
        "wrap",
        "classNames",
        "attr",
        "lastElementSibling",
        "dataset",
        "outerHtmlHead",
        "parent",
        "nextElementSibling",
        "cssSelector",
        "previousElementSibling",
        "text",
        "empty",
        "preserveWhitespace",
        "tagName",
        "data",
        "prependText",
        "nodeName",
        "siblingElements",
        "getElementsByClass",
        "children",
        "ownText",
        "indexInList",
        "hasText",
        "className",
        "appendElement",
        "Element",
        "getElementsContainingText",
        "appendText",
        "addClass"
      ],
      "functions_name_co_evolved_modified_file": [
        "hasClass"
      ],
      "functions_name_co_evolved_all_files": [
        "hasClass"
      ]
    },
    "file": {
      "file_name": "Element.java",
      "file_nloc": 588,
      "file_complexity": 182,
      "file_token_count": 4212,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -1057,59 +1057,47 @@ public class Element extends Node {\n      * @param className name of class to check for\n      * @return true if it does, false if not\n      */\n-    /*\n-    Used by common .class selector, so perf tweaked to reduce object creation vs hitting classnames().\n-\n-    Wiki: 71, 13 (5.4x)\n-    CNN: 227, 91 (2.5x)\n-    Alterslash: 59, 4 (14.8x)\n-    Jsoup: 14, 1 (14x)\n-    */\n+    // performance sensitive\n     public boolean hasClass(String className) {\n-        String classAttr = attributes.get(\"class\");\n-        final int end = classAttr.length();\n-        final int classNameLength = className.length();\n+        final String classAttr = attributes.get(\"class\");\n+        final int len = classAttr.length();\n+        final int wantLen = className.length();\n \n-        // class attribute is empty or the requested class name is 'too' long\n-        if (end == 0 || end < classNameLength) {\n+        if (len == 0 || len < wantLen) {\n             return false;\n         }\n-        \n-        // if both length are equals, just compare the className with the attribute\n-        if(end == classNameLength) {\n+\n+        // if both lengths are equal, only need compare the className with the attribute\n+        if (len == wantLen) {\n             return className.equalsIgnoreCase(classAttr);\n         }\n \n-        // manually split the different class names in the class attibute\n-        // DO NOT allocate the string but use regionMatches and length comparaison to make the check\n+        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n         boolean inClass = false;\n         int start = 0;\n-        for (int i = 0; i < end; i ++) {\n+        for (int i = 0; i < len; i++) {\n             if (Character.isWhitespace(classAttr.charAt(i))) {\n-                if(inClass) {\n-                    // the white space ends a class name\n-                    // compare it with the requested one\n-                    if(i-start == classNameLength && classAttr.regionMatches(true, start, className, 0, classNameLength)) {\n+                if (inClass) {\n+                    // white space ends a class name, compare it with the requested one, ignore case\n+                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                         return true;\n                     }\n                     inClass = false;\n                 }\n-            }\n-            else {\n-                if(!inClass) {\n+            } else {\n+                if (!inClass) {\n                     // we're in a class name : keep the start of the substring\n                     inClass = true;\n                     start = i;\n                 }\n             }\n         }\n-        \n-        // the attribute may not end by a white space\n-        // check the current class name\n-        if(inClass && end-start == classNameLength) {\n-            return classAttr.regionMatches(true, start, className, 0, classNameLength);  \n+\n+        // check the last entry\n+        if (inClass && len - start == wantLen) {\n+            return classAttr.regionMatches(true, start, className, 0, wantLen);\n         }\n-        \n+\n         return false;\n     }\n \n",
      "files_name_in_blame_commit": [
        "Element.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 118
  }
}
{
  "id": "69",
  "blame_commit": {
    "commit": {
      "commit_id": "231aab61e228513853d08374e188217933f70986",
      "commit_message": "Replaced Strings with char array in CharacterReader, for well improved parse times.\n\nFaster to scan, and less garbage created.",
      "commit_author": "Jonathan Hedley",
      "commit_date": "2012-06-03 18:44:14",
      "commit_parent": "07a3c08a7ddb06711c3d1b5b1126076a43efa6e1"
    },
    "function": {
      "function_name": "nextIndexOf",
      "function_code_before": "",
      "function_code_after": "int nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        if (offset < length) {\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 82,
      "function_after_end_line": 98,
      "function_before_token_count": 0,
      "function_after_token_count": 130,
      "functions_name_modified_file": [
        "toString",
        "consumeAsString",
        "matchConsume",
        "CharacterReader",
        "matchesAny",
        "consumeTo",
        "unconsume",
        "matchesLetter",
        "consumeDigitSequence",
        "pos",
        "consumeLetterThenDigitSequence",
        "consume",
        "consumeToEnd",
        "matches",
        "consumeHexSequence",
        "consumeToAny",
        "matchConsumeIgnoreCase",
        "isEmpty",
        "containsIgnoreCase",
        "matchesDigit",
        "consumeLetterSequence",
        "rewindToMark",
        "matchesIgnoreCase",
        "nextIndexOf",
        "advance",
        "current",
        "mark"
      ],
      "functions_name_all_files": [
        "toString",
        "consumeAsString",
        "matchConsume",
        "CharacterReader",
        "matchesAny",
        "consumeTo",
        "unconsume",
        "matchesLetter",
        "consumeDigitSequence",
        "pos",
        "nextIndexOfChar",
        "nextIndexOfString",
        "consumeLetterThenDigitSequence",
        "consume",
        "consumeToEnd",
        "matches",
        "consumeHexSequence",
        "consumeToAny",
        "matchConsumeIgnoreCase",
        "consumeToChar",
        "isEmpty",
        "containsIgnoreCase",
        "matchesDigit",
        "consumeLetterSequence",
        "rewindToMark",
        "matchesIgnoreCase",
        "consumeToString",
        "nextIndexOf",
        "advance",
        "current",
        "mark"
      ],
      "functions_name_co_evolved_modified_file": [
        "toString",
        "consumeAsString",
        "CharacterReader",
        "matchesAny",
        "consumeTo",
        "matchesLetter",
        "consumeDigitSequence",
        "consumeLetterThenDigitSequence",
        "consume",
        "consumeHexSequence",
        "matches",
        "consumeToEnd",
        "consumeToAny",
        "containsIgnoreCase",
        "matchesDigit",
        "consumeLetterSequence",
        "matchesIgnoreCase",
        "nextIndexOf",
        "current"
      ],
      "functions_name_co_evolved_all_files": [
        "toString",
        "consumeAsString",
        "CharacterReader",
        "matchesAny",
        "consumeTo",
        "matchesLetter",
        "consumeDigitSequence",
        "nextIndexOfChar",
        "nextIndexOfString",
        "consumeLetterThenDigitSequence",
        "consume",
        "consumeHexSequence",
        "matches",
        "consumeToEnd",
        "consumeToAny",
        "consumeToChar",
        "containsIgnoreCase",
        "matchesDigit",
        "consumeLetterSequence",
        "matchesIgnoreCase",
        "consumeToString",
        "nextIndexOf",
        "advance",
        "current"
      ]
    },
    "file": {
      "file_name": "CharacterReader.java",
      "file_nloc": 224,
      "file_complexity": 90,
      "file_token_count": 1345,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -10,15 +10,15 @@ import java.util.Locale;\n class CharacterReader {\n     static final char EOF = (char) -1;\n \n-    private final String input;\n+    private final char[] input;\n     private final int length;\n     private int pos = 0;\n     private int mark = 0;\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n-        this.input = input;\n-        this.length = input.length();\n+        this.input = input.toCharArray();\n+        this.length = this.input.length;\n     }\n \n     int pos() {\n@@ -30,11 +30,11 @@ class CharacterReader {\n     }\n \n     char current() {\n-        return isEmpty() ? EOF : input.charAt(pos);\n+        return isEmpty() ? EOF : input[pos];\n     }\n \n     char consume() {\n-        char val = isEmpty() ? EOF : input.charAt(pos);\n+        char val = isEmpty() ? EOF : input[pos];\n         pos++;\n         return val;\n     }\n@@ -56,14 +56,52 @@ class CharacterReader {\n     }\n \n     String consumeAsString() {\n-        return new String(input.substring(pos, pos++));\n+        return new String(input, pos++, 1);\n+    }\n+\n+    /**\n+     * Returns the number of characters between the current position and the next instance of the input char\n+     * @param c scan target\n+     * @return offset between current position and next instance of target. -1 if not found.\n+     */\n+    int nextIndexOf(char c) {\n+        // doesn't handle scanning for surrogates\n+        for (int i = pos; i < length; i++) {\n+            if (c == input[i])\n+                return i - pos;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns the number of characters between the current position and the next instance of the input sequence\n+     *\n+     * @param seq scan target\n+     * @return offset between current position and next instance of target. -1 if not found.\n+     */\n+    int nextIndexOf(CharSequence seq) {\n+        // doesn't handle scanning for surrogates\n+        char startChar = seq.charAt(0);\n+        for (int offset = pos; offset < length; offset++) {\n+            // scan to first instance of startchar:\n+            if (startChar != input[offset])\n+                while(++offset < length && startChar != input[offset]);\n+            if (offset < length) {\n+                int i = offset + 1;\n+                int last = i + seq.length()-1;\n+                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n+                if (i == last) // found full sequence\n+                    return offset - pos;\n+            }\n+        }\n+        return -1;\n     }\n \n     String consumeTo(char c) {\n-        int offset = input.indexOf(c, pos);\n+        int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = new String(input.substring(pos, offset));\n-            pos += consumed.length();\n+            String consumed = new String(input, pos, offset);\n+            pos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n@@ -71,112 +109,128 @@ class CharacterReader {\n     }\n \n     String consumeTo(String seq) {\n-        int offset = input.indexOf(seq, pos);\n+        int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = new String(input.substring(pos, offset));\n-            pos += consumed.length();\n+            String consumed = new String(input, pos, offset);\n+            pos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n         }\n     }\n \n-    String consumeToAny(char... seq) {\n+    String consumeToAny(final char... chars) {\n         int start = pos;\n \n-        OUTER: while (!isEmpty()) {\n-            char c = input.charAt(pos);\n-            for (char seek : seq) {\n-                if (seek == c)\n+        OUTER: while (pos < length) {\n+            for (int i = 0; i < chars.length; i++) {\n+                if (input[pos] == chars[i])\n                     break OUTER;\n             }\n             pos++;\n         }\n \n-        return pos > start ? new String(input.substring(start, pos)) : \"\";\n+        return pos > start ? new String(input, start, pos-start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = new String(input.substring(pos, input.length()));\n-        pos = input.length();\n+        String data = new String(input, pos, length-pos);\n+        pos = length;\n         return data;\n     }\n \n     String consumeLetterSequence() {\n         int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+        while (pos < length) {\n+            char c = input[pos];\n             if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                 pos++;\n             else\n                 break;\n         }\n \n-        return new String(input.substring(start, pos));\n+        return new String(input, start, pos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n         int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+        while (pos < length) {\n+            char c = input[pos];\n             if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                 pos++;\n             else\n                 break;\n         }\n         while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+            char c = input[pos];\n             if (c >= '0' && c <= '9')\n                 pos++;\n             else\n                 break;\n         }\n \n-        return new String(input.substring(start, pos));\n+        return new String(input, start, pos - start);\n     }\n \n     String consumeHexSequence() {\n         int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+        while (pos < length) {\n+            char c = input[pos];\n             if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                 pos++;\n             else\n                 break;\n         }\n-        return new String(input.substring(start, pos));\n+        return new String(input, start, pos - start);\n     }\n \n     String consumeDigitSequence() {\n         int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+        while (pos < length) {\n+            char c = input[pos];\n             if (c >= '0' && c <= '9')\n                 pos++;\n             else\n                 break;\n         }\n-        return new String(input.substring(start, pos));\n+        return new String(input, start, pos - start);\n     }\n \n     boolean matches(char c) {\n-        return !isEmpty() && input.charAt(pos) == c;\n+        return !isEmpty() && input[pos] == c;\n \n     }\n \n     boolean matches(String seq) {\n-        return input.startsWith(seq, pos);\n+        int scanLength = seq.length();\n+        if (scanLength > length - pos)\n+            return false;\n+\n+        for (int offset = 0; offset < scanLength; offset++)\n+            if (seq.charAt(offset) != input[pos+offset])\n+                return false;\n+        return true;\n     }\n \n     boolean matchesIgnoreCase(String seq) {\n-        return input.regionMatches(true, pos, seq, 0, seq.length());\n+        int scanLength = seq.length();\n+        if (scanLength > length - pos)\n+            return false;\n+\n+        for (int offset = 0; offset < scanLength; offset++) {\n+            char upScan = Character.toUpperCase(seq.charAt(offset));\n+            char upTarget = Character.toUpperCase(input[pos + offset]);\n+            if (upScan != upTarget)\n+                return false;\n+        }\n+        return true;\n     }\n \n     boolean matchesAny(char... seq) {\n         if (isEmpty())\n             return false;\n \n-        char c = input.charAt(pos);\n+        char c = input[pos];\n         for (char seek : seq) {\n             if (seek == c)\n                 return true;\n@@ -187,14 +241,14 @@ class CharacterReader {\n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n-        char c = input.charAt(pos);\n+        char c = input[pos];\n         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n     }\n \n     boolean matchesDigit() {\n         if (isEmpty())\n             return false;\n-        char c = input.charAt(pos);\n+        char c = input[pos];\n         return (c >= '0' && c <= '9');\n     }\n \n@@ -220,11 +274,11 @@ class CharacterReader {\n         // used to check presence of </title>, </style>. only finds consistent case.\n         String loScan = seq.toLowerCase(Locale.ENGLISH);\n         String hiScan = seq.toUpperCase(Locale.ENGLISH);\n-        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n+        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n     }\n \n     @Override\n     public String toString() {\n-        return input.substring(pos);\n+        return new String(input, pos, length - pos);\n     }\n }\n",
      "files_name_in_blame_commit": [
        "CharacterReaderTest.java",
        "CharacterReader.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 11
  }
}
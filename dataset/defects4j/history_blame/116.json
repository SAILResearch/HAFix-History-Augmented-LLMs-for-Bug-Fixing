{
  "id": "116",
  "blame_commit": {
    "commit": {
      "commit_id": "b86efe73e72ece8e5ceeed48d05228aa1725c9ad",
      "commit_message": "Add Partial, new immutable implementation of ReadablePartial\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@796 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1",
      "commit_author": "Stephen Colebourne",
      "commit_date": "2005-06-26 23:29:36",
      "commit_parent": "17eb41943b7289bb9607e0f840076b61a3e3c707"
    },
    "function": {
      "function_name": "with",
      "function_code_before": "",
      "function_code_after": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n\n        // find correct insertion point to keep largest-smallest order\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 418,
      "function_after_end_line": 465,
      "function_before_token_count": 0,
      "function_after_token_count": 382,
      "functions_name_modified_file": [
        "getChronology",
        "toString",
        "Partial",
        "getReadablePartial",
        "getFieldTypes",
        "withFieldAddWrapped",
        "withChronologyRetainFields",
        "minus",
        "getPartial",
        "compareTo",
        "plus",
        "isAfter",
        "withPeriodAdded",
        "isBefore",
        "get",
        "addWrapFieldToCopy",
        "getFormatter",
        "Property",
        "size",
        "without",
        "property",
        "setCopy",
        "withFieldAdded",
        "getValues",
        "getFieldType",
        "addToCopy",
        "getValue",
        "with",
        "isEqual",
        "toStringList",
        "withField",
        "getField"
      ],
      "functions_name_all_files": [
        "getChronology",
        "testWithFieldAdded5",
        "testWithFieldAddWrapped4",
        "testWith3b",
        "toString",
        "testPropertyGetMaxMinValuesMinute",
        "getReadablePartial",
        "testPropertySetTextHour",
        "testWithFieldAddWrapped6",
        "withChronologyRetainFields",
        "testWithField4",
        "testWith3e",
        "minus",
        "compareTo",
        "testGetFormatter3",
        "TestAll",
        "testPropertyAddMinute",
        "isBefore",
        "testPropertyAddHour",
        "testPropertyGetHour",
        "main",
        "setUp",
        "testGetValue",
        "testWithFieldAddWrapped8",
        "property",
        "testConstructorEx2_Type_int_Chrono",
        "testWithField3",
        "createHourMinPartial",
        "check",
        "testIsBefore_TOD",
        "createTODPartial",
        "getValue",
        "with",
        "testConstructor_TypeArray_intArray_Chrono",
        "testGetField",
        "testToDateTime_nullRI",
        "testWithout2",
        "testConstructorEx2_Type_int",
        "testSerialization",
        "testConstructorEx5_TypeArray_intArray",
        "testWithFieldAdded7",
        "TestPartial_Constructors",
        "tearDown",
        "testToString_String_Locale",
        "testPropertySetMinute",
        "testToString_String",
        "testGet",
        "testCompareTo",
        "testWith4",
        "plus",
        "testConstructor_Partial",
        "testToString_DTFormatter",
        "testWithFieldAddWrapped7",
        "testPropertyGetMaxMinValuesHour",
        "testWith3f",
        "testProperty",
        "get",
        "testPropertyCompareToMinute",
        "addWrapFieldToCopy",
        "testWithChronologyRetainFields_sameChrono",
        "testWithChronologyRetainFields_nullChrono",
        "testWith3a",
        "getFormatter",
        "Property",
        "testConstructorEx8_TypeArray_intArray",
        "testWithField2",
        "testWithFieldAdded1",
        "testConstructorEx9_TypeArray_intArray",
        "without",
        "testConstructorEx6_TypeArray_intArray",
        "setCopy",
        "withFieldAdded",
        "testWith1",
        "testConstructor_Type_int_Chrono",
        "testWithFieldAdded3",
        "testWithFieldAdded4",
        "addToCopy",
        "createHourMinPartial2",
        "testToString2",
        "testIsSupported",
        "testGetValues",
        "withField",
        "testWithField1",
        "testMinus_RP",
        "testWith3c",
        "testWithFieldAddWrapped1",
        "testPropertyCompareToHour",
        "testPropertyGetMinute",
        "testWith3d",
        "testPropertySetHour",
        "testWithFieldAddWrapped3",
        "testConstructor_Type_int",
        "testConstructorEx1_Type_int",
        "getFieldTypes",
        "withFieldAddWrapped",
        "assertMessageContains",
        "testSize",
        "testGetFields",
        "withPeriodAdded",
        "testToString5",
        "testConstructorEx_Type_int_Chrono",
        "testConstructorEx7_TypeArray_intArray",
        "testWithChronologyRetainFields_Chrono",
        "testPlus_RP",
        "testWithFieldAddWrapped2",
        "testToDateTime_RI",
        "testWithout1",
        "testPropertyAddWrapFieldHour",
        "testGetFormatter1",
        "testIsAfter_TOD",
        "testConstructorEx1_TypeArray_intArray",
        "testWithFieldAdded8",
        "testGetFormatter2",
        "testConstructor",
        "testConstructor_Chrono",
        "getFieldType",
        "testWithout5",
        "testPropertyAddWrapFieldMinute",
        "TestPartial_Properties",
        "getField",
        "Partial",
        "testConstructorEx_Partial",
        "testToString1",
        "testGetFieldTypes",
        "testWithout3",
        "testConstructor2_TypeArray_intArray",
        "getPartial",
        "testWithFieldAdded2",
        "isAfter",
        "testIsEqual_TOD",
        "TestPartial_Basics",
        "testToString4",
        "testWithFieldAddWrapped5",
        "testWithout4",
        "size",
        "testWithFieldAdded6",
        "getValues",
        "suite",
        "testEqualsHashCode",
        "testPropertySetTextMinute",
        "isEqual",
        "testConstructor_TypeArray_intArray",
        "toStringList",
        "testGetFieldType",
        "testConstructorEx3_TypeArray_intArray",
        "testToString3",
        "testWith2"
      ],
      "functions_name_co_evolved_modified_file": [
        "getChronology",
        "toString",
        "Partial",
        "getReadablePartial",
        "getFieldTypes",
        "withFieldAddWrapped",
        "withChronologyRetainFields",
        "minus",
        "getPartial",
        "compareTo",
        "plus",
        "isAfter",
        "withPeriodAdded",
        "isBefore",
        "get",
        "addWrapFieldToCopy",
        "getFormatter",
        "Property",
        "size",
        "without",
        "property",
        "setCopy",
        "withFieldAdded",
        "getValues",
        "getFieldType",
        "addToCopy",
        "with",
        "getValue",
        "isEqual",
        "toStringList",
        "withField",
        "getField"
      ],
      "functions_name_co_evolved_all_files": [
        "getChronology",
        "testWithFieldAdded5",
        "testWithFieldAddWrapped4",
        "testWith3b",
        "toString",
        "testPropertyGetMaxMinValuesMinute",
        "getReadablePartial",
        "testPropertySetTextHour",
        "testWithFieldAddWrapped6",
        "withChronologyRetainFields",
        "testWithField4",
        "testWith3e",
        "minus",
        "compareTo",
        "testGetFormatter3",
        "testPropertyAddMinute",
        "isBefore",
        "testPropertyAddHour",
        "testPropertyGetHour",
        "main",
        "setUp",
        "testGetValue",
        "testWithFieldAddWrapped8",
        "property",
        "testConstructorEx2_Type_int_Chrono",
        "testWithField3",
        "createHourMinPartial",
        "check",
        "testIsBefore_TOD",
        "createTODPartial",
        "with",
        "getValue",
        "testConstructor_TypeArray_intArray_Chrono",
        "testGetField",
        "testToDateTime_nullRI",
        "testWithout2",
        "testConstructorEx2_Type_int",
        "testSerialization",
        "testConstructorEx5_TypeArray_intArray",
        "testWithFieldAdded7",
        "TestPartial_Constructors",
        "tearDown",
        "testToString_String_Locale",
        "testPropertySetMinute",
        "testToString_String",
        "testGet",
        "testCompareTo",
        "testWith4",
        "plus",
        "testConstructor_Partial",
        "testToString_DTFormatter",
        "testWithFieldAddWrapped7",
        "testPropertyGetMaxMinValuesHour",
        "testProperty",
        "testWith3f",
        "get",
        "testPropertyCompareToMinute",
        "addWrapFieldToCopy",
        "testWithChronologyRetainFields_sameChrono",
        "testWith3a",
        "testWithChronologyRetainFields_nullChrono",
        "getFormatter",
        "Property",
        "testConstructorEx8_TypeArray_intArray",
        "testWithField2",
        "testWithFieldAdded1",
        "testConstructorEx9_TypeArray_intArray",
        "without",
        "testConstructorEx6_TypeArray_intArray",
        "setCopy",
        "withFieldAdded",
        "testWith1",
        "testConstructor_Type_int_Chrono",
        "testWithFieldAdded3",
        "testWithFieldAdded4",
        "addToCopy",
        "createHourMinPartial2",
        "testToString2",
        "testIsSupported",
        "testGetValues",
        "withField",
        "testMinus_RP",
        "testWithField1",
        "testWith3c",
        "testWithFieldAddWrapped1",
        "testPropertyCompareToHour",
        "testPropertyGetMinute",
        "testWith3d",
        "testPropertySetHour",
        "testWithFieldAddWrapped3",
        "testConstructor_Type_int",
        "testConstructorEx1_Type_int",
        "getFieldTypes",
        "withFieldAddWrapped",
        "assertMessageContains",
        "testSize",
        "testGetFields",
        "withPeriodAdded",
        "testToString5",
        "testConstructorEx_Type_int_Chrono",
        "testConstructorEx7_TypeArray_intArray",
        "testWithChronologyRetainFields_Chrono",
        "testPlus_RP",
        "testWithFieldAddWrapped2",
        "testToDateTime_RI",
        "testWithout1",
        "testPropertyAddWrapFieldHour",
        "testGetFormatter1",
        "testIsAfter_TOD",
        "testConstructorEx1_TypeArray_intArray",
        "testWithFieldAdded8",
        "testGetFormatter2",
        "testConstructor",
        "testConstructor_Chrono",
        "getFieldType",
        "testWithout5",
        "testPropertyAddWrapFieldMinute",
        "TestPartial_Properties",
        "getField",
        "Partial",
        "testConstructorEx_Partial",
        "testToString1",
        "testGetFieldTypes",
        "testWithout3",
        "testConstructor2_TypeArray_intArray",
        "getPartial",
        "testWithFieldAdded2",
        "isAfter",
        "testToString4",
        "testIsEqual_TOD",
        "TestPartial_Basics",
        "testWithFieldAddWrapped5",
        "testWithout4",
        "size",
        "testWithFieldAdded6",
        "getValues",
        "suite",
        "testEqualsHashCode",
        "testPropertySetTextMinute",
        "isEqual",
        "testConstructor_TypeArray_intArray",
        "toStringList",
        "testGetFieldType",
        "testConstructorEx3_TypeArray_intArray",
        "testToString3",
        "testWith2"
      ]
    },
    "file": {
      "file_name": "Partial.java",
      "file_nloc": 422,
      "file_complexity": 104,
      "file_token_count": 3038,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,1006 @@\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.joda.time.base.AbstractPartial;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Partial is an immutable partial datetime where the fields supported\n+ * are defined by the constructor.\n+ * <p>\n+ * Calculations on Partial are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n+ * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * Partial is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.1\n+ */\n+public final class Partial\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 12324121189002L;\n+\n+    /** The chronology in use. */\n+    private final Chronology iChronology;\n+    /** The set of field types. */\n+    private final DateTimeFieldType[] iTypes;\n+    /** The values of each field in this partial. */\n+    private final int[] iValues;\n+    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n+    private transient DateTimeFormatter[] iFormatter;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * <p>\n+     * This is most useful when constructing partials, for example:\n+     * <pre>\n+     * Partial p = new Partial()\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * </pre>\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     * <p>\n+     * The constructor uses the default ISO chronology.\n+     */\n+    public Partial() {\n+        this((Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * <p>\n+     * This is most useful when constructing partials, for example:\n+     * <pre>\n+     * Partial p = new Partial(chrono)\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * </pre>\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     *\n+     * @param chronology  the chronology, null means ISO\n+     */\n+    public Partial(Chronology chrono) {\n+        super();\n+        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n+        iTypes = new DateTimeFieldType[0];\n+        iValues = new int[0];\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * <p>\n+     * The constructor uses the default ISO chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value) {\n+        this(type, value, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology = chronology;\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        iTypes = new DateTimeFieldType[] {type};\n+        iValues = new int[] {value};\n+        chronology.validate(this, iValues);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values) {\n+        this(types, values, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology = chronology;\n+        if (types == null) {\n+            throw new IllegalArgumentException(\"Types array must not be null\");\n+        }\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"Values array must not be null\");\n+        }\n+        if (values.length != types.length) {\n+            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n+        }\n+        if (types.length == 0) {\n+            iTypes = types;\n+            iValues = values;\n+            return;\n+        }\n+        for (int i = 0; i < types.length; i++) {\n+            if (types[i] == null) {\n+                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n+            }\n+        }\n+        DurationField lastUnitField = null;\n+        for (int i = 0; i < types.length; i++) {\n+            DateTimeFieldType loopType = types[i];\n+            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+            if (i > 0) {\n+                int compare = lastUnitField.compareTo(loopUnitField);\n+                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n+                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                            types[i - 1].getName() + \" < \" + loopType.getName());\n+                } else if (compare == 0) {\n+                    if (types[i - 1].getRangeDurationType() == null) {\n+                        if (loopType.getRangeDurationType() == null) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    } else {\n+                        if (loopType.getRangeDurationType() == null) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" < \" + loopType.getName());\n+                        }\n+                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n+                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" < \" + loopType.getName());\n+                        }\n+                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    }\n+                }\n+            }\n+            lastUnitField = loopUnitField;\n+        }\n+        \n+        iTypes = (DateTimeFieldType[]) types.clone();\n+        chronology.validate(this, values);\n+        iValues = (int[]) values.clone();\n+    }\n+\n+    /**\n+     * Constructs a Partial by copying all the fields and types from\n+     * another partial.\n+     * <p>\n+     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n+     */\n+    public Partial(ReadablePartial partial) {\n+        super();\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n+        iTypes = new DateTimeFieldType[partial.size()];\n+        iValues = new int[partial.size()];\n+        for (int i = 0; i < partial.size(); i++) {\n+            iTypes[i] = partial.getFieldType(i);\n+            iValues[i] = partial.getValue(i);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param partial  the partial to copy\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Partial partial, int[] values) {\n+        super();\n+        iChronology = partial.iChronology;\n+        iTypes = partial.iTypes;\n+        iValues = values;\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified chronology, fields and values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param chronology  the chronology\n+     * @param types  the types to create the partial from\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n+        super();\n+        iChronology = chronology;\n+        iTypes = types;\n+        iValues = values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return iTypes.length;\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        return iTypes[index].getField(chrono);\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return iTypes[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that\n+     * this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest.\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) iTypes.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that\n+     * this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest.\n+     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Partial instance with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as Partial\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public Partial withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n+            newChronology.validate(newPartial, iValues);\n+            return newPartial;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * If this partial did not previously support the field, the new one will.\n+     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed/added in the returned instance.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial with(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        int index = indexOf(fieldType);\n+        if (index == -1) {\n+            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n+            int[] newValues = new int[newTypes.length];\n+            \n+            // find correct insertion point to keep largest-smallest order\n+            int i = 0;\n+            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n+            if (unitField.isSupported()) {\n+                for (; i < iTypes.length; i++) {\n+                    DateTimeFieldType loopType = iTypes[i];\n+                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+                    if (loopUnitField.isSupported()) {\n+                        int compare = unitField.compareTo(loopUnitField);\n+                        if (compare > 0) {\n+                            break;\n+                        } else if (compare == 0) {\n+                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n+                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                            if (rangeField.compareTo(loopRangeField) > 0) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            System.arraycopy(iTypes, 0, newTypes, 0, i);\n+            System.arraycopy(iValues, 0, newValues, 0, i);\n+            newTypes[i] = fieldType;\n+            newValues[i] = value;\n+            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n+            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n+            \n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified field removed.\n+     * <p>\n+     * If this partial did not previously support the field, no error occurs.\n+     *\n+     * @param fieldType  the field type to remove, may be null\n+     * @return a copy of this instance with the field removed\n+     */\n+    public Partial without(DateTimeFieldType fieldType) {\n+        int index = indexOf(fieldType);\n+        if (index != -1) {\n+            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n+            int[] newValues = new int[size() - 1];\n+            System.arraycopy(iTypes, 0, newTypes, 0, index);\n+            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n+            System.arraycopy(iValues, 0, newValues, 0, index);\n+            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this Partial with the specified field set to a new value.\n+     * <p>\n+     * If this partial does not support the field, an exception is thrown.\n+     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance if supported.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * However, it will not wrap around if the top maximum is reached.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * If the maximum is reached, the addition will wra.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using the method\n+     * {@link #withFieldAdded(DurationFieldType, int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiplyToInt(period.getValue(i), scalar));\n+            }\n+        }\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods for getting and manipulating the partial.\n+     * <p>\n+     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n+     *\n+     * @param type  the field type to get the property for, not null\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The specified object must be a ReadablePartial whose field types\n+     * match those of this partial. Normally that means that the partials\n+     * must be the same class.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(Object partial) {\n+        if (this == partial) {\n+            return 0;\n+        }\n+        ReadablePartial other = (ReadablePartial) partial;\n+        if (size() != other.size()) {\n+            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) != other.getFieldType(i)) {\n+                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+            }\n+        }\n+        // fields are ordered largest first\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) > other.getValue(i)) {\n+                return 1;\n+            }\n+            if (getValue(i) < other.getValue(i)) {\n+                return -1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is this partial later than the specified partial.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is after the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isAfter(Partial date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(date) > 0;\n+    }\n+\n+    /**\n+     * Is this partial earlier than the specified partial.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is before the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isBefore(Partial date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(date) < 0;\n+    }\n+\n+    /**\n+     * Is this partial the same as the specified partial.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is the same as the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isEqual(Partial date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(date) == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a formatter suitable for the fields in this partial.\n+     * <p>\n+     * If there is no appropriate ISO format, null is returned.\n+     * This method may return a formatter that does not display all the\n+     * fields of the partial. This might occur when you have overlapping\n+     * fields, such as dayOfWeek and dayOfMonth.\n+     *\n+     * @return a formatter suitable for the fields in this partial, null\n+     *  if none is suitable\n+     */\n+    public DateTimeFormatter getFormatter() {\n+        DateTimeFormatter[] f = iFormatter;\n+        if (f == null) {\n+            if (size() == 0) {\n+                return null;\n+            }\n+            f = new DateTimeFormatter[2];\n+            try {\n+                List list = new ArrayList(Arrays.asList(iTypes));\n+                f[0] = ISODateTimeFormat.forFields(list, true, false);\n+                if (list.size() == 0) {\n+                    f[1] = f[0];\n+                }\n+            } catch (IllegalArgumentException ex) {\n+                // ignore\n+            }\n+            iFormatter = f;\n+        }\n+        return f[0];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in an appropriate ISO8601 format.\n+     * <p>\n+     * This method will output the partial in one of two ways.\n+     * If {@link #getFormatter()}\n+     * \n+     * If there is no appropriate ISO format a dump of the fields is output\n+     * via {@link #toStringList()}. An appropr\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        DateTimeFormatter[] f = iFormatter;\n+        if (f == null) {\n+            getFormatter();\n+            f = iFormatter;\n+            if (f == null) {\n+                return toStringList();\n+            }\n+        }\n+        DateTimeFormatter f1 = f[1];\n+        if (f1 == null) {\n+            return toStringList();\n+        }\n+        return f1.print(this);\n+    }\n+\n+    /**\n+     * Gets a string version of the partial that lists all the fields.\n+     * <p>\n+     * This method exists to provide a better debugging toString than\n+     * the standard toString. This method lists all the fields and their\n+     * values in a style similar to the collections framework.\n+     *\n+     * @return a toString format that lists all the fields\n+     */\n+    public String toStringList() {\n+        int size = size();\n+        StringBuffer buf = new StringBuffer(20 * size);\n+        buf.append('[');\n+        for (int i = 0; i < size; i++) {\n+            if (i > 0) {\n+                buf.append(',').append(' ');\n+            }\n+            buf.append(iTypes[i].getName());\n+            buf.append('=');\n+            buf.append(iValues[i]);\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>YearMonthDay</code>.\n+     * <p>\n+     * This class binds a <code>YearMonthDay</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 53278362873888L;\n+\n+        /** The partial */\n+        private final Partial iPartial;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(Partial partial, int fieldIndex) {\n+            super();\n+            iPartial = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iPartial.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public Partial getPartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iPartial.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this Partial.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial addToCopy(int valueToAdd) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this Partial wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the Partial.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial setCopy(int value) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public Partial setCopy(String text, Locale locale) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public Partial setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n",
      "files_name_in_blame_commit": [
        "Partial.java",
        "TestAll.java",
        "TestPartial_Basics.java",
        "TestPartial_Constructors.java",
        "TestPartial_Properties.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 18
  }
}
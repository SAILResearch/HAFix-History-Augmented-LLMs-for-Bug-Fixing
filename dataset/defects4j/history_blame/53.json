{
  "id": "53",
  "blame_commit": {
    "commit": {
      "commit_id": "0c8d86eab3670535dfcb5ad4d80f090f001aca14",
      "commit_message": "minor addition to TextBuffer",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2014-01-19 19:28:41",
      "commit_parent": "ed4098cf0bd2e0a66b860db7bdaaf5f3756102a7"
    },
    "function": {
      "function_name": "getTextBuffer",
      "function_code_before": "public char[] getTextBuffer()\n{\n    // Are we just using shared input buffer?\n    if (_inputStart >= 0) {\n        return _inputBuffer;\n    }\n    if (_resultArray != null) {\n        return _resultArray;\n    }\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!_hasSegments) {\n        return _currentSegment;\n    }\n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}",
      "function_code_after": "public char[] getTextBuffer()\n{\n    // Are we just using shared input buffer?\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!_hasSegments)  return _currentSegment;\n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}",
      "function_before_start_line": 304,
      "function_before_end_line": 322,
      "function_after_start_line": 298,
      "function_after_end_line": 310,
      "function_before_token_count": 61,
      "function_after_token_count": 55,
      "functions_name_modified_file": [
        "contentsAsDecimal",
        "resetWithEmpty",
        "toString",
        "resultArray",
        "resetWithString",
        "finishCurrentSegment",
        "resetWithShared",
        "contentsAsString",
        "contentsAsDouble",
        "releaseBuffers",
        "getTextBuffer",
        "append",
        "getCurrentSegment",
        "emptyAndGetCurrentSegment",
        "resetWithCopy",
        "expandCurrentSegment",
        "buf",
        "getCurrentSegmentSize",
        "size",
        "clearSegments",
        "contentsAsArray",
        "hasTextAsCharacters",
        "unshare",
        "carr",
        "ensureNotShared",
        "getTextOffset",
        "expand",
        "TextBuffer",
        "setCurrentLength"
      ],
      "functions_name_all_files": [
        "contentsAsDecimal",
        "resetWithEmpty",
        "toString",
        "resultArray",
        "resetWithString",
        "finishCurrentSegment",
        "resetWithShared",
        "contentsAsString",
        "contentsAsDouble",
        "releaseBuffers",
        "getTextBuffer",
        "append",
        "getCurrentSegment",
        "emptyAndGetCurrentSegment",
        "resetWithCopy",
        "expandCurrentSegment",
        "buf",
        "getCurrentSegmentSize",
        "size",
        "clearSegments",
        "contentsAsArray",
        "hasTextAsCharacters",
        "unshare",
        "carr",
        "ensureNotShared",
        "getTextOffset",
        "expand",
        "TextBuffer",
        "setCurrentLength"
      ],
      "functions_name_co_evolved_modified_file": [
        "contentsAsDecimal",
        "buildResultArray",
        "resultArray",
        "finishCurrentSegment",
        "findBuffer",
        "getTextBuffer",
        "getCurrentSegment",
        "emptyAndGetCurrentSegment",
        "expandCurrentSegment",
        "resetWithCopy",
        "buf",
        "contentsAsArray",
        "hasTextAsCharacters",
        "unshare",
        "_charArray",
        "carr",
        "getTextOffset",
        "expand",
        "TextBuffer"
      ],
      "functions_name_co_evolved_all_files": [
        "contentsAsDecimal",
        "buildResultArray",
        "resultArray",
        "finishCurrentSegment",
        "findBuffer",
        "getTextBuffer",
        "getCurrentSegment",
        "emptyAndGetCurrentSegment",
        "expandCurrentSegment",
        "resetWithCopy",
        "buf",
        "contentsAsArray",
        "hasTextAsCharacters",
        "unshare",
        "_charArray",
        "carr",
        "getTextOffset",
        "expand",
        "TextBuffer"
      ]
    },
    "file": {
      "file_name": "TextBuffer.java",
      "file_nloc": 391,
      "file_complexity": 96,
      "file_token_count": 2224,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -118,8 +118,7 @@ public final class TextBuffer\n     /**********************************************************\n      */\n \n-    public TextBuffer(BufferRecycler allocator)\n-    {\n+    public TextBuffer(BufferRecycler allocator) {\n         _allocator = allocator;\n     }\n \n@@ -204,7 +203,7 @@ public final class TextBuffer\n         if (_hasSegments) {\n             clearSegments();\n         } else if (_currentSegment == null) {\n-            _currentSegment = findBuffer(len);\n+            _currentSegment = buf(len);\n         }\n         _currentSize = _segmentSize = 0;\n         append(buf, start, len);\n@@ -230,7 +229,7 @@ public final class TextBuffer\n      * Helper method used to find a buffer to use, ideally one\n      * recycled earlier.\n      */\n-    private char[] findBuffer(int needed)\n+    private char[] buf(int needed)\n     {\n         if (_allocator != null) {\n             return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n@@ -275,8 +274,7 @@ public final class TextBuffer\n         return _segmentSize + _currentSize;\n     }\n \n-    public int getTextOffset()\n-    {\n+    public int getTextOffset() {\n         /* Only shared input buffer can have non-zero offset; buffer\n          * segments start at 0, and if we have to create a combo buffer,\n          * that too will start from beginning of the buffer\n@@ -291,32 +289,22 @@ public final class TextBuffer\n     public boolean hasTextAsCharacters()\n     {\n         // if we have array in some form, sure\n-        if (_inputStart >= 0 || _resultArray != null) {\n-            return true;\n-        }\n+        if (_inputStart >= 0 || _resultArray != null)  return true;\n         // not if we have String as value\n-        if (_resultString != null) {\n-            return false;\n-        }\n+        if (_resultString != null) return false;\n         return true;\n     }\n     \n     public char[] getTextBuffer()\n     {\n         // Are we just using shared input buffer?\n-        if (_inputStart >= 0) {\n-            return _inputBuffer;\n-        }\n-        if (_resultArray != null) {\n-            return _resultArray;\n-        }\n+        if (_inputStart >= 0) return _inputBuffer;\n+        if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments) {\n-            return _currentSegment;\n-        }\n+        if (!_hasSegments)  return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n@@ -366,11 +354,10 @@ public final class TextBuffer\n         return _resultString;\n     }\n  \n-    public char[] contentsAsArray()\n-    {\n+    public char[] contentsAsArray() {\n         char[] result = _resultArray;\n         if (result == null) {\n-            _resultArray = result = buildResultArray();\n+            _resultArray = result = resultArray();\n         }\n         return result;\n     }\n@@ -379,8 +366,7 @@ public final class TextBuffer\n      * Convenience method for converting contents of the buffer\n      * into a {@link BigDecimal}.\n      */\n-    public BigDecimal contentsAsDecimal()\n-        throws NumberFormatException\n+    public BigDecimal contentsAsDecimal() throws NumberFormatException\n     {\n         // Already got a pre-cut array?\n         if (_resultArray != null) {\n@@ -530,7 +516,7 @@ public final class TextBuffer\n         } else {\n             char[] curr = _currentSegment;\n             if (curr == null) {\n-                _currentSegment = findBuffer(0);\n+                _currentSegment = buf(0);\n             } else if (_currentSize >= curr.length) {\n                 // Plus, we better have room for at least one more char\n                 expand(1);\n@@ -556,7 +542,7 @@ public final class TextBuffer\n         }\n         char[] curr = _currentSegment;\n         if (curr == null) {\n-            _currentSegment = curr = findBuffer(0);\n+            _currentSegment = curr = buf(0);\n         }\n         return curr;\n     }\n@@ -574,7 +560,7 @@ public final class TextBuffer\n         _segmentSize += oldLen;\n         // Let's grow segments by 50%\n         int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN);\n-        char[] curr = _charArray(newLen);\n+        char[] curr = carr(newLen);\n         _currentSize = 0;\n         _currentSegment = curr;\n         return curr;\n@@ -591,11 +577,26 @@ public final class TextBuffer\n         // Let's grow by 50%\n         final int len = curr.length;\n         // Must grow by at least 1 char, no matter what\n-        int newLen = (len == MAX_SEGMENT_LEN) ?\n-            (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n+    /**\n+     * Method called to expand size of the current segment, to\n+     * accommodate for more contiguous content. Usually only\n+     * used when parsing tokens like names if even then.\n+     * \n+     * @param minSize Required minimum strength of the current segment\n+     *\n+     * @since 2.4.0\n+     */\n+    public char[] expandCurrentSegment(int minSize) {\n+        char[] curr = _currentSegment;\n+        if (curr.length >= minSize) return curr;\n+        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n+        return curr;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Standard methods:\n@@ -631,7 +632,7 @@ public final class TextBuffer\n         // Is buffer big enough, or do we need to reallocate?\n         int needed = sharedLen+needExtra;\n         if (_currentSegment == null || needed > _currentSegment.length) {\n-            _currentSegment = findBuffer(needed);\n+            _currentSegment = buf(needed);\n         }\n         if (sharedLen > 0) {\n             System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n@@ -661,10 +662,10 @@ public final class TextBuffer\n             sizeAddition = minNewSegmentSize;\n         }\n         _currentSize = 0;\n-        _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n+        _currentSegment = carr(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n     }\n \n-    private char[] buildResultArray()\n+    private char[] resultArray()\n     {\n         if (_resultString != null) { // Can take a shortcut...\n             return _resultString.toCharArray();\n@@ -687,7 +688,7 @@ public final class TextBuffer\n             return NO_CHARS;\n         }\n         int offset = 0;\n-        final char[] result = _charArray(size);\n+        final char[] result = carr(size);\n         if (_segments != null) {\n             for (int i = 0, len = _segments.size(); i < len; ++i) {\n                 char[] curr = (char[]) _segments.get(i);\n@@ -700,5 +701,5 @@ public final class TextBuffer\n         return result;\n     }\n \n-    private char[] _charArray(int len) { return new char[len]; }\n+    private char[] carr(int len) { return new char[len]; }\n }\n",
      "files_name_in_blame_commit": [
        "TextBuffer.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 15
  }
}
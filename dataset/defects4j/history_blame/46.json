{
  "id": "46",
  "blame_commit": {
    "commit": {
      "commit_id": "ce9e0cefd5be63ca46ff45460464d0d391d037db",
      "commit_message": "fixed line endings",
      "commit_author": "Torsten Curdt",
      "commit_date": "2016-01-15 15:31:59",
      "commit_parent": "633f9c9533e6df8b457634c75a1f45fdb85a07d8"
    },
    "function": {
      "function_name": "isDirectory",
      "function_code_before": "public boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n\n    return false;\n}",
      "function_code_after": "public boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n\n    return false;\n}",
      "function_before_start_line": 772,
      "function_before_end_line": 786,
      "function_after_start_line": 772,
      "function_after_end_line": 786,
      "function_before_token_count": 50,
      "function_after_token_count": 50,
      "functions_name_modified_file": [
        "setUserName",
        "setNames",
        "getSize",
        "setDevMinor",
        "getUserId",
        "normalizeFileName",
        "getDevMajor",
        "TarArchiveEntry",
        "isGlobalPaxHeader",
        "isBlockDevice",
        "getName",
        "getLongUserId",
        "hashCode",
        "isDescendent",
        "writeEntryHeaderField",
        "isFile",
        "setMode",
        "getGroupId",
        "isExtended",
        "setName",
        "isGNULongLinkEntry",
        "evaluateType",
        "getRealSize",
        "isDirectory",
        "isLink",
        "getDirectoryEntries",
        "setSize",
        "isGNUSparse",
        "getUserName",
        "setGroupName",
        "setModTime",
        "isCheckSumOK",
        "isCharacterDevice",
        "setIds",
        "isSymbolicLink",
        "getMode",
        "getDevMinor",
        "getLinkName",
        "getGroupName",
        "isFIFO",
        "setDevMajor",
        "setUserId",
        "setGroupId",
        "getLongGroupId",
        "equals",
        "setLinkName",
        "writeEntryHeader",
        "getFile",
        "getModTime",
        "isPaxHeader",
        "getLastModifiedDate",
        "isGNULongNameEntry",
        "parseTarHeader"
      ],
      "functions_name_all_files": [
        "setUserName",
        "setNames",
        "getSize",
        "setDevMinor",
        "getUserId",
        "normalizeFileName",
        "getDevMajor",
        "TarArchiveEntry",
        "isGlobalPaxHeader",
        "isBlockDevice",
        "getName",
        "getLongUserId",
        "hashCode",
        "isDescendent",
        "writeEntryHeaderField",
        "isFile",
        "setMode",
        "getGroupId",
        "isExtended",
        "setName",
        "isGNULongLinkEntry",
        "evaluateType",
        "getRealSize",
        "isDirectory",
        "isLink",
        "getDirectoryEntries",
        "setSize",
        "isGNUSparse",
        "getUserName",
        "setGroupName",
        "setModTime",
        "isCheckSumOK",
        "isCharacterDevice",
        "setIds",
        "isSymbolicLink",
        "getMode",
        "getDevMinor",
        "getLinkName",
        "getGroupName",
        "isFIFO",
        "setDevMajor",
        "setUserId",
        "setGroupId",
        "getLongGroupId",
        "equals",
        "setLinkName",
        "writeEntryHeader",
        "getFile",
        "getModTime",
        "isPaxHeader",
        "getLastModifiedDate",
        "isGNULongNameEntry",
        "parseTarHeader"
      ],
      "functions_name_co_evolved_modified_file": [
        "setNames",
        "setDevMinor",
        "setUserName",
        "getSize",
        "getUserId",
        "normalizeFileName",
        "getDevMajor",
        "TarArchiveEntry",
        "isGlobalPaxHeader",
        "isBlockDevice",
        "getName",
        "getLongUserId",
        "hashCode",
        "isDescendent",
        "writeEntryHeaderField",
        "isFile",
        "setMode",
        "getGroupId",
        "isExtended",
        "setName",
        "isGNULongLinkEntry",
        "evaluateType",
        "getRealSize",
        "isDirectory",
        "isLink",
        "getDirectoryEntries",
        "setSize",
        "isGNUSparse",
        "getUserName",
        "setGroupName",
        "setModTime",
        "isCheckSumOK",
        "isCharacterDevice",
        "setIds",
        "isSymbolicLink",
        "getMode",
        "getDevMinor",
        "getLinkName",
        "getGroupName",
        "isFIFO",
        "setDevMajor",
        "setUserId",
        "setGroupId",
        "getLongGroupId",
        "equals",
        "setLinkName",
        "writeEntryHeader",
        "getFile",
        "getModTime",
        "isPaxHeader",
        "getLastModifiedDate",
        "isGNULongNameEntry",
        "parseTarHeader"
      ],
      "functions_name_co_evolved_all_files": [
        "setNames",
        "setDevMinor",
        "setUserName",
        "getSize",
        "getUserId",
        "normalizeFileName",
        "getDevMajor",
        "TarArchiveEntry",
        "isGlobalPaxHeader",
        "isBlockDevice",
        "getName",
        "getLongUserId",
        "hashCode",
        "isDescendent",
        "writeEntryHeaderField",
        "isFile",
        "setMode",
        "getGroupId",
        "isExtended",
        "setName",
        "isGNULongLinkEntry",
        "evaluateType",
        "getRealSize",
        "isDirectory",
        "isLink",
        "getDirectoryEntries",
        "setSize",
        "isGNUSparse",
        "getUserName",
        "setGroupName",
        "setModTime",
        "isCheckSumOK",
        "isCharacterDevice",
        "setIds",
        "isSymbolicLink",
        "getMode",
        "getDevMinor",
        "getLinkName",
        "getGroupName",
        "isFIFO",
        "setDevMajor",
        "setUserId",
        "setGroupId",
        "getLongGroupId",
        "equals",
        "setLinkName",
        "writeEntryHeader",
        "getFile",
        "getModTime",
        "isPaxHeader",
        "getLastModifiedDate",
        "isGNULongNameEntry",
        "parseTarHeader"
      ]
    },
    "file": {
      "file_name": "TarArchiveEntry.java",
      "file_nloc": 467,
      "file_complexity": 124,
      "file_token_count": 2870,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -1,1127 +1,1127 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.commons.compress.archivers.tar;\r\n-\r\n-import java.io.File;\r\n-import java.io.IOException;\r\n-import java.util.Date;\r\n-import java.util.Locale;\r\n-\r\n-import org.apache.commons.compress.archivers.ArchiveEntry;\r\n-import org.apache.commons.compress.archivers.zip.ZipEncoding;\r\n-import org.apache.commons.compress.utils.ArchiveUtils;\r\n-\r\n-/**\r\n- * This class represents an entry in a Tar archive. It consists\r\n- * of the entry's header, as well as the entry's File. Entries\r\n- * can be instantiated in one of three ways, depending on how\r\n- * they are to be used.\r\n- * <p>\r\n- * TarEntries that are created from the header bytes read from\r\n- * an archive are instantiated with the TarEntry( byte[] )\r\n- * constructor. These entries will be used when extracting from\r\n- * or listing the contents of an archive. These entries have their\r\n- * header filled in using the header bytes. They also set the File\r\n- * to null, since they reference an archive entry not a file.\r\n- * <p>\r\n- * TarEntries that are created from Files that are to be written\r\n- * into an archive are instantiated with the TarEntry( File )\r\n- * constructor. These entries have their header filled in using\r\n- * the File's information. They also keep a reference to the File\r\n- * for convenience when writing entries.\r\n- * <p>\r\n- * Finally, TarEntries can be constructed from nothing but a name.\r\n- * This allows the programmer to construct the entry by hand, for\r\n- * instance when only an InputStream is available for writing to\r\n- * the archive, and the header information is constructed from\r\n- * other information. In this case the header fields are set to\r\n- * defaults and the File is set to null.\r\n- *\r\n- * <p>\r\n- * The C structure for a Tar Entry's header is:\r\n- * <pre>\r\n- * struct header {\r\n- * char name[100];     // TarConstants.NAMELEN    - offset   0\r\n- * char mode[8];       // TarConstants.MODELEN    - offset 100\r\n- * char uid[8];        // TarConstants.UIDLEN     - offset 108\r\n- * char gid[8];        // TarConstants.GIDLEN     - offset 116\r\n- * char size[12];      // TarConstants.SIZELEN    - offset 124\r\n- * char mtime[12];     // TarConstants.MODTIMELEN - offset 136\r\n- * char chksum[8];     // TarConstants.CHKSUMLEN  - offset 148\r\n- * char linkflag[1];   //                         - offset 156\r\n- * char linkname[100]; // TarConstants.NAMELEN    - offset 157\r\n- * The following fields are only present in new-style POSIX tar archives:\r\n- * char magic[6];      // TarConstants.MAGICLEN   - offset 257\r\n- * char version[2];    // TarConstants.VERSIONLEN - offset 263\r\n- * char uname[32];     // TarConstants.UNAMELEN   - offset 265\r\n- * char gname[32];     // TarConstants.GNAMELEN   - offset 297\r\n- * char devmajor[8];   // TarConstants.DEVLEN     - offset 329\r\n- * char devminor[8];   // TarConstants.DEVLEN     - offset 337\r\n- * char prefix[155];   // TarConstants.PREFIXLEN  - offset 345\r\n- * // Used if \"name\" field is not long enough to hold the path\r\n- * char pad[12];       // NULs                    - offset 500\r\n- * } header;\r\n- * All unused bytes are set to null.\r\n- * New-style GNU tar files are slightly different from the above.\r\n- * For values of size larger than 077777777777L (11 7s)\r\n- * or uid and gid larger than 07777777L (7 7s)\r\n- * the sign bit of the first byte is set, and the rest of the\r\n- * field is the binary representation of the number.\r\n- * See TarUtils.parseOctalOrBinary.\r\n- * </pre>\r\n- * \r\n- * <p>\r\n- * The C structure for a old GNU Tar Entry's header is:\r\n- * <pre>\r\n- * struct oldgnu_header {\r\n- * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\r\n- * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\r\n- * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\r\n- * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\r\n- * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\r\n- * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\r\n- * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\r\n- * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\r\n- * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\r\n- * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\r\n- * };\r\n- * </pre>\r\n- * Whereas, \"struct sparse\" is:\r\n- * <pre>\r\n- * struct sparse {\r\n- * char offset[12];   // offset 0\r\n- * char numbytes[12]; // offset 12\r\n- * };\r\n- * </pre>\r\n- *\r\n- * @NotThreadSafe\r\n- */\r\n-\r\n-public class TarArchiveEntry implements TarConstants, ArchiveEntry {\r\n-    /** The entry's name. */\r\n-    private String name = \"\";\r\n-\r\n-    /** The entry's permission mode. */\r\n-    private int mode;\r\n-\r\n-    /** The entry's user id. */\r\n-    private long userId = 0;\r\n-\r\n-    /** The entry's group id. */\r\n-    private long groupId = 0;\r\n-\r\n-    /** The entry's size. */\r\n-    private long size = 0;\r\n-\r\n-    /** The entry's modification time. */\r\n-    private long modTime;\r\n-\r\n-    /** If the header checksum is reasonably correct. */\r\n-    private boolean checkSumOK;\r\n-\r\n-    /** The entry's link flag. */\r\n-    private byte linkFlag;\r\n-\r\n-    /** The entry's link name. */\r\n-    private String linkName = \"\";\r\n-\r\n-    /** The entry's magic tag. */\r\n-    private String magic = MAGIC_POSIX;\r\n-    /** The version of the format */\r\n-    private String version = VERSION_POSIX;\r\n-\r\n-    /** The entry's user name. */\r\n-    private String userName;\r\n-\r\n-    /** The entry's group name. */\r\n-    private String groupName = \"\";\r\n-\r\n-    /** The entry's major device number. */\r\n-    private int devMajor = 0;\r\n-\r\n-    /** The entry's minor device number. */\r\n-    private int devMinor = 0;\r\n-\r\n-    /** If an extension sparse header follows. */\r\n-    private boolean isExtended;\r\n-\r\n-    /** The entry's real size in case of a sparse file. */\r\n-    private long realSize;\r\n-\r\n-    /** The entry's file reference */\r\n-    private final File file;\r\n-\r\n-    /** Maximum length of a user's name in the tar file */\r\n-    public static final int MAX_NAMELEN = 31;\r\n-\r\n-    /** Default permissions bits for directories */\r\n-    public static final int DEFAULT_DIR_MODE = 040755;\r\n-\r\n-    /** Default permissions bits for files */\r\n-    public static final int DEFAULT_FILE_MODE = 0100644;\r\n-\r\n-    /** Convert millis to seconds */\r\n-    public static final int MILLIS_PER_SECOND = 1000;\r\n-\r\n-    /**\r\n-     * Construct an empty entry and prepares the header values.\r\n-     */\r\n-    private TarArchiveEntry() {\r\n-        String user = System.getProperty(\"user.name\", \"\");\r\n-\r\n-        if (user.length() > MAX_NAMELEN) {\r\n-            user = user.substring(0, MAX_NAMELEN);\r\n-        }\r\n-\r\n-        this.userName = user;\r\n-        this.file = null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry with only a name. This allows the programmer\r\n-     * to construct the entry's header \"by hand\". File is set to null.\r\n-     *\r\n-     * @param name the entry name\r\n-     */\r\n-    public TarArchiveEntry(String name) {\r\n-        this(name, false);\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry with only a name. This allows the programmer\r\n-     * to construct the entry's header \"by hand\". File is set to null.\r\n-     *\r\n-     * @param name the entry name\r\n-     * @param preserveLeadingSlashes whether to allow leading slashes\r\n-     * in the name.\r\n-     * \r\n-     * @since 1.1\r\n-     */\r\n-    public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\r\n-        this();\r\n-\r\n-        name = normalizeFileName(name, preserveLeadingSlashes);\r\n-        boolean isDir = name.endsWith(\"/\");\r\n-\r\n-        this.name = name;\r\n-        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\r\n-        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\r\n-        this.modTime = new Date().getTime() / MILLIS_PER_SECOND;\r\n-        this.userName = \"\";\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry with a name and a link flag.\r\n-     *\r\n-     * @param name the entry name\r\n-     * @param linkFlag the entry link flag.\r\n-     */\r\n-    public TarArchiveEntry(String name, byte linkFlag) {\r\n-        this(name, linkFlag, false);\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry with a name and a link flag.\r\n-     *\r\n-     * @param name the entry name\r\n-     * @param linkFlag the entry link flag.\r\n-     * @param preserveLeadingSlashes whether to allow leading slashes\r\n-     * in the name.\r\n-     * \r\n-     * @since 1.5\r\n-     */\r\n-    public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\r\n-        this(name, preserveLeadingSlashes);\r\n-        this.linkFlag = linkFlag;\r\n-        if (linkFlag == LF_GNUTYPE_LONGNAME) {\r\n-            magic = MAGIC_GNU;\r\n-            version = VERSION_GNU_SPACE;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry for a file. File is set to file, and the\r\n-     * header is constructed from information from the file.\r\n-     * The name is set from the normalized file path.\r\n-     *\r\n-     * @param file The file that the entry represents.\r\n-     */\r\n-    public TarArchiveEntry(File file) {\r\n-        this(file, file.getPath());\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry for a file. File is set to file, and the\r\n-     * header is constructed from information from the file.\r\n-     *\r\n-     * @param file The file that the entry represents.\r\n-     * @param fileName the name to be used for the entry.\r\n-     */\r\n-    public TarArchiveEntry(File file, String fileName) {\r\n-        String normalizedName = normalizeFileName(fileName, false);\r\n-        this.file = file;\r\n-\r\n-        if (file.isDirectory()) {\r\n-            this.mode = DEFAULT_DIR_MODE;\r\n-            this.linkFlag = LF_DIR;\r\n-\r\n-            int nameLength = normalizedName.length();\r\n-            if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\r\n-                this.name = normalizedName + \"/\";\r\n-            } else {\r\n-                this.name = normalizedName;\r\n-            }\r\n-        } else {\r\n-            this.mode = DEFAULT_FILE_MODE;\r\n-            this.linkFlag = LF_NORMAL;\r\n-            this.size = file.length();\r\n-            this.name = normalizedName;\r\n-        }\r\n-\r\n-        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\r\n-        this.userName = \"\";\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry from an archive's header bytes. File is set\r\n-     * to null.\r\n-     *\r\n-     * @param headerBuf The header bytes from a tar archive entry.\r\n-     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\r\n-     */\r\n-    public TarArchiveEntry(byte[] headerBuf) {\r\n-        this();\r\n-        parseTarHeader(headerBuf);\r\n-    }\r\n-\r\n-    /**\r\n-     * Construct an entry from an archive's header bytes. File is set\r\n-     * to null.\r\n-     *\r\n-     * @param headerBuf The header bytes from a tar archive entry.\r\n-     * @param encoding encoding to use for file names\r\n-     * @since 1.4\r\n-     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\r\n-     * @throws IOException on error\r\n-     */\r\n-    public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\r\n-        throws IOException {\r\n-        this();\r\n-        parseTarHeader(headerBuf, encoding);\r\n-    }\r\n-\r\n-    /**\r\n-     * Determine if the two entries are equal. Equality is determined\r\n-     * by the header names being equal.\r\n-     *\r\n-     * @param it Entry to be checked for equality.\r\n-     * @return True if the entries are equal.\r\n-     */\r\n-    public boolean equals(TarArchiveEntry it) {\r\n-        return getName().equals(it.getName());\r\n-    }\r\n-\r\n-    /**\r\n-     * Determine if the two entries are equal. Equality is determined\r\n-     * by the header names being equal.\r\n-     *\r\n-     * @param it Entry to be checked for equality.\r\n-     * @return True if the entries are equal.\r\n-     */\r\n-    @Override\r\n-    public boolean equals(Object it) {\r\n-        if (it == null || getClass() != it.getClass()) {\r\n-            return false;\r\n-        }\r\n-        return equals((TarArchiveEntry) it);\r\n-    }\r\n-\r\n-    /**\r\n-     * Hashcodes are based on entry names.\r\n-     *\r\n-     * @return the entry hashcode\r\n-     */\r\n-    @Override\r\n-    public int hashCode() {\r\n-        return getName().hashCode();\r\n-    }\r\n-\r\n-    /**\r\n-     * Determine if the given entry is a descendant of this entry.\r\n-     * Descendancy is determined by the name of the descendant\r\n-     * starting with this entry's name.\r\n-     *\r\n-     * @param desc Entry to be checked as a descendent of this.\r\n-     * @return True if entry is a descendant of this.\r\n-     */\r\n-    public boolean isDescendent(TarArchiveEntry desc) {\r\n-        return desc.getName().startsWith(getName());\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's name.\r\n-     *\r\n-     * @return This entry's name.\r\n-     */\r\n-    public String getName() {\r\n-        return name;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's name.\r\n-     *\r\n-     * @param name This entry's new name.\r\n-     */\r\n-    public void setName(String name) {\r\n-        this.name = normalizeFileName(name, false);\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the mode for this entry\r\n-     *\r\n-     * @param mode the mode for this entry\r\n-     */\r\n-    public void setMode(int mode) {\r\n-        this.mode = mode;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's link name.\r\n-     *\r\n-     * @return This entry's link name.\r\n-     */\r\n-    public String getLinkName() {\r\n-        return linkName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's link name.\r\n-     * \r\n-     * @param link the link name to use.\r\n-     * \r\n-     * @since 1.1\r\n-     */\r\n-    public void setLinkName(String link) {\r\n-        this.linkName = link;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's user id.\r\n-     *\r\n-     * @return This entry's user id.\r\n-     * @deprecated use #getLongUserId instead as user ids can be\r\n-     * bigger than {@link Integer#MAX_VALUE}\r\n-     */\r\n-    @Deprecated\r\n-    public int getUserId() {\r\n-        return (int) (userId & 0xffffffff);\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's user id.\r\n-     *\r\n-     * @param userId This entry's new user id.\r\n-     */\r\n-    public void setUserId(int userId) {\r\n-        setUserId((long) userId);\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's user id.\r\n-     *\r\n-     * @return This entry's user id.\r\n-     * @since 1.10\r\n-     */\r\n-    public long getLongUserId() {\r\n-        return userId;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's user id.\r\n-     *\r\n-     * @param userId This entry's new user id.\r\n-     * @since 1.10\r\n-     */\r\n-    public void setUserId(long userId) {\r\n-        this.userId = userId;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's group id.\r\n-     *\r\n-     * @return This entry's group id.\r\n-     * @deprecated use #getLongGroupId instead as group ids can be\r\n-     * bigger than {@link Integer#MAX_VALUE}\r\n-     */\r\n-    @Deprecated\r\n-    public int getGroupId() {\r\n-        return (int) (groupId & 0xffffffff);\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's group id.\r\n-     *\r\n-     * @param groupId This entry's new group id.\r\n-     */\r\n-    public void setGroupId(int groupId) {\r\n-        setGroupId((long) groupId);\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's group id.\r\n-     *\r\n-     * @since 1.10\r\n-     * @return This entry's group id.\r\n-     */\r\n-    public long getLongGroupId() {\r\n-        return groupId;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's group id.\r\n-     *\r\n-     * @since 1.10\r\n-     * @param groupId This entry's new group id.\r\n-     */\r\n-    public void setGroupId(long groupId) {\r\n-        this.groupId = groupId;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's user name.\r\n-     *\r\n-     * @return This entry's user name.\r\n-     */\r\n-    public String getUserName() {\r\n-        return userName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's user name.\r\n-     *\r\n-     * @param userName This entry's new user name.\r\n-     */\r\n-    public void setUserName(String userName) {\r\n-        this.userName = userName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's group name.\r\n-     *\r\n-     * @return This entry's group name.\r\n-     */\r\n-    public String getGroupName() {\r\n-        return groupName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's group name.\r\n-     *\r\n-     * @param groupName This entry's new group name.\r\n-     */\r\n-    public void setGroupName(String groupName) {\r\n-        this.groupName = groupName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Convenience method to set this entry's group and user ids.\r\n-     *\r\n-     * @param userId This entry's new user id.\r\n-     * @param groupId This entry's new group id.\r\n-     */\r\n-    public void setIds(int userId, int groupId) {\r\n-        setUserId(userId);\r\n-        setGroupId(groupId);\r\n-    }\r\n-\r\n-    /**\r\n-     * Convenience method to set this entry's group and user names.\r\n-     *\r\n-     * @param userName This entry's new user name.\r\n-     * @param groupName This entry's new group name.\r\n-     */\r\n-    public void setNames(String userName, String groupName) {\r\n-        setUserName(userName);\r\n-        setGroupName(groupName);\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's modification time. The parameter passed\r\n-     * to this method is in \"Java time\".\r\n-     *\r\n-     * @param time This entry's new modification time.\r\n-     */\r\n-    public void setModTime(long time) {\r\n-        modTime = time / MILLIS_PER_SECOND;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's modification time.\r\n-     *\r\n-     * @param time This entry's new modification time.\r\n-     */\r\n-    public void setModTime(Date time) {\r\n-        modTime = time.getTime() / MILLIS_PER_SECOND;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's modification time.\r\n-     *\r\n-     * @return time This entry's new modification time.\r\n-     */\r\n-    public Date getModTime() {\r\n-        return new Date(modTime * MILLIS_PER_SECOND);\r\n-    }\r\n-\r\n-    public Date getLastModifiedDate() {\r\n-        return getModTime();\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's checksum status.\r\n-     *\r\n-     * @return if the header checksum is reasonably correct\r\n-     * @see TarUtils#verifyCheckSum(byte[])\r\n-     * @since 1.5\r\n-     */\r\n-    public boolean isCheckSumOK() {\r\n-        return checkSumOK;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's file.\r\n-     *\r\n-     * @return This entry's file.\r\n-     */\r\n-    public File getFile() {\r\n-        return file;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's mode.\r\n-     *\r\n-     * @return This entry's mode.\r\n-     */\r\n-    public int getMode() {\r\n-        return mode;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's file size.\r\n-     *\r\n-     * @return This entry's file size.\r\n-     */\r\n-    public long getSize() {\r\n-        return size;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's file size.\r\n-     *\r\n-     * @param size This entry's new file size.\r\n-     * @throws IllegalArgumentException if the size is &lt; 0.\r\n-     */\r\n-    public void setSize(long size) {\r\n-        if (size < 0){\r\n-            throw new IllegalArgumentException(\"Size is out of range: \"+size);\r\n-        }\r\n-        this.size = size;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's major device number.\r\n-     *\r\n-     * @return This entry's major device number.\r\n-     * @since 1.4\r\n-     */\r\n-    public int getDevMajor() {\r\n-        return devMajor;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's major device number.\r\n-     *\r\n-     * @param devNo This entry's major device number.\r\n-     * @throws IllegalArgumentException if the devNo is &lt; 0.\r\n-     * @since 1.4\r\n-     */\r\n-    public void setDevMajor(int devNo) {\r\n-        if (devNo < 0){\r\n-            throw new IllegalArgumentException(\"Major device number is out of \"\r\n-                                               + \"range: \" + devNo);\r\n-        }\r\n-        this.devMajor = devNo;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's minor device number.\r\n-     *\r\n-     * @return This entry's minor device number.\r\n-     * @since 1.4\r\n-     */\r\n-    public int getDevMinor() {\r\n-        return devMinor;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set this entry's minor device number.\r\n-     *\r\n-     * @param devNo This entry's minor device number.\r\n-     * @throws IllegalArgumentException if the devNo is &lt; 0.\r\n-     * @since 1.4\r\n-     */\r\n-    public void setDevMinor(int devNo) {\r\n-        if (devNo < 0){\r\n-            throw new IllegalArgumentException(\"Minor device number is out of \"\r\n-                                               + \"range: \" + devNo);\r\n-        }\r\n-        this.devMinor = devNo;\r\n-    }\r\n-\r\n-    /**\r\n-     * Indicates in case of a sparse file if an extension sparse header\r\n-     * follows.\r\n-     *\r\n-     * @return true if an extension sparse header follows.\r\n-     */\r\n-    public boolean isExtended() {\r\n-        return isExtended;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get this entry's real file size in case of a sparse file.\r\n-     *\r\n-     * @return This entry's real file size.\r\n-     */\r\n-    public long getRealSize() {\r\n-        return realSize;\r\n-    }\r\n-\r\n-    /**\r\n-     * Indicate if this entry is a GNU sparse block \r\n-     *\r\n-     * @return true if this is a sparse extension provided by GNU tar\r\n-     */\r\n-    public boolean isGNUSparse() {\r\n-        return linkFlag == LF_GNUTYPE_SPARSE;\r\n-    }\r\n-\r\n-    /**\r\n-     * Indicate if this entry is a GNU long linkname block\r\n-     *\r\n-     * @return true if this is a long name extension provided by GNU tar\r\n-     */\r\n-    public boolean isGNULongLinkEntry() {\r\n-        return linkFlag == LF_GNUTYPE_LONGLINK;\r\n-    }\r\n-\r\n-    /**\r\n-     * Indicate if this entry is a GNU long name block\r\n-     *\r\n-     * @return true if this is a long name extension provided by GNU tar\r\n-     */\r\n-    public boolean isGNULongNameEntry() {\r\n-        return linkFlag == LF_GNUTYPE_LONGNAME;\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a Pax header.\r\n-     * \r\n-     * @return {@code true} if this is a Pax header.\r\n-     * \r\n-     * @since 1.1\r\n-     * \r\n-     */\r\n-    public boolean isPaxHeader(){\r\n-        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\r\n-            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a Pax header.\r\n-     * \r\n-     * @return {@code true} if this is a Pax header.\r\n-     * \r\n-     * @since 1.1\r\n-     */\r\n-    public boolean isGlobalPaxHeader(){\r\n-        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether or not this entry represents a directory.\r\n-     *\r\n-     * @return True if this entry is a directory.\r\n-     */\r\n-    public boolean isDirectory() {\r\n-        if (file != null) {\r\n-            return file.isDirectory();\r\n-        }\r\n-\r\n-        if (linkFlag == LF_DIR) {\r\n-            return true;\r\n-        }\r\n-\r\n-        if (getName().endsWith(\"/\")) {\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a \"normal file\"\r\n-     *\r\n-     * @since 1.2\r\n-     * @return whether this is a \"normal file\"\r\n-     */\r\n-    public boolean isFile() {\r\n-        if (file != null) {\r\n-            return file.isFile();\r\n-        }\r\n-        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\r\n-            return true;\r\n-        }\r\n-        return !getName().endsWith(\"/\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a symbolic link entry.\r\n-     *\r\n-     * @since 1.2\r\n-     * @return whether this is a symbolic link\r\n-     */\r\n-    public boolean isSymbolicLink() {\r\n-        return linkFlag == LF_SYMLINK;\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a link entry.\r\n-     *\r\n-     * @since 1.2\r\n-     * @return whether this is a link entry\r\n-     */\r\n-    public boolean isLink() {\r\n-        return linkFlag == LF_LINK;\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a character device entry.\r\n-     *\r\n-     * @since 1.2\r\n-     * @return whether this is a character device\r\n-     */\r\n-    public boolean isCharacterDevice() {\r\n-        return linkFlag == LF_CHR;\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a block device entry.\r\n-     *\r\n-     * @since 1.2\r\n-     * @return whether this is a block device\r\n-     */\r\n-    public boolean isBlockDevice() {\r\n-        return linkFlag == LF_BLK;\r\n-    }\r\n-\r\n-    /**\r\n-     * Check if this is a FIFO (pipe) entry.\r\n-     *\r\n-     * @since 1.2\r\n-     * @return whether this is a FIFO entry\r\n-     */\r\n-    public boolean isFIFO() {\r\n-        return linkFlag == LF_FIFO;\r\n-    }\r\n-\r\n-    /**\r\n-     * If this entry represents a file, and the file is a directory, return\r\n-     * an array of TarEntries for this entry's children.\r\n-     *\r\n-     * @return An array of TarEntry's for this entry's children.\r\n-     */\r\n-    public TarArchiveEntry[] getDirectoryEntries() {\r\n-        if (file == null || !file.isDirectory()) {\r\n-            return new TarArchiveEntry[0];\r\n-        }\r\n-\r\n-        String[] list = file.list();\r\n-        TarArchiveEntry[] result = new TarArchiveEntry[list == null ? 0 : list.length];\r\n-\r\n-        for (int i = 0; i < result.length; ++i) {\r\n-            result[i] = new TarArchiveEntry(new File(file, list[i]));\r\n-        }\r\n-\r\n-        return result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Write an entry's header information to a header buffer.\r\n-     *\r\n-     * <p>This method does not use the star/GNU tar/BSD tar extensions.</p>\r\n-     *\r\n-     * @param outbuf The tar entry header buffer to fill in.\r\n-     */\r\n-    public void writeEntryHeader(byte[] outbuf) {\r\n-        try {\r\n-            writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\r\n-        } catch (IOException ex) {\r\n-            try {\r\n-                writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\r\n-            } catch (IOException ex2) {\r\n-                // impossible\r\n-                throw new RuntimeException(ex2);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Write an entry's header information to a header buffer.\r\n-     *\r\n-     * @param outbuf The tar entry header buffer to fill in.\r\n-     * @param encoding encoding to use when writing the file name.\r\n-     * @param starMode whether to use the star/GNU tar/BSD tar\r\n-     * extension for numeric fields if their value doesn't fit in the\r\n-     * maximum size of standard tar archives\r\n-     * @since 1.4\r\n-     * @throws IOException on error\r\n-     */\r\n-    public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\r\n-                                 boolean starMode) throws IOException {\r\n-        int offset = 0;\r\n-\r\n-        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\r\n-                                          encoding);\r\n-        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\r\n-        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\r\n-                                       starMode);\r\n-        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\r\n-                                       starMode);\r\n-        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\r\n-        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\r\n-                                       starMode);\r\n-\r\n-        int csOffset = offset;\r\n-\r\n-        for (int c = 0; c < CHKSUMLEN; ++c) {\r\n-            outbuf[offset++] = (byte) ' ';\r\n-        }\r\n-\r\n-        outbuf[offset++] = linkFlag;\r\n-        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\r\n-                                          encoding);\r\n-        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\r\n-        offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\r\n-        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\r\n-                                          encoding);\r\n-        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\r\n-                                          encoding);\r\n-        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\r\n-                                       starMode);\r\n-        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\r\n-                                       starMode);\r\n-\r\n-        while (offset < outbuf.length) {\r\n-            outbuf[offset++] = 0;\r\n-        }\r\n-\r\n-        long chk = TarUtils.computeCheckSum(outbuf);\r\n-\r\n-        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\r\n-    }\r\n-\r\n-    private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\r\n-                                      int length, boolean starMode) {\r\n-        if (!starMode && (value < 0\r\n-                          || value >= 1l << 3 * (length - 1))) {\r\n-            // value doesn't fit into field when written as octal\r\n-            // number, will be written to PAX header or causes an\r\n-            // error\r\n-            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\r\n-        }\r\n-        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\r\n-                                                     length);\r\n-    }\r\n-\r\n-    /**\r\n-     * Parse an entry's header information from a header buffer.\r\n-     *\r\n-     * @param header The tar entry header buffer to get information from.\r\n-     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\r\n-     */\r\n-    public void parseTarHeader(byte[] header) {\r\n-        try {\r\n-            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\r\n-        } catch (IOException ex) {\r\n-            try {\r\n-                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\r\n-            } catch (IOException ex2) {\r\n-                // not really possible\r\n-                throw new RuntimeException(ex2);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Parse an entry's header information from a header buffer.\r\n-     *\r\n-     * @param header The tar entry header buffer to get information from.\r\n-     * @param encoding encoding to use for file names\r\n-     * @since 1.4\r\n-     * @throws IllegalArgumentException if any of the numeric fields\r\n-     * have an invalid format\r\n-     * @throws IOException on error\r\n-     */\r\n-    public void parseTarHeader(byte[] header, ZipEncoding encoding)\r\n-        throws IOException {\r\n-        parseTarHeader(header, encoding, false);\r\n-    }\r\n-\r\n-    private void parseTarHeader(byte[] header, ZipEncoding encoding,\r\n-                                final boolean oldStyle)\r\n-        throws IOException {\r\n-        int offset = 0;\r\n-\r\n-        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\r\n-            : TarUtils.parseName(header, offset, NAMELEN, encoding);\r\n-        offset += NAMELEN;\r\n-        mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\r\n-        offset += MODELEN;\r\n-        userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\r\n-        offset += UIDLEN;\r\n-        groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\r\n-        offset += GIDLEN;\r\n-        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\r\n-        offset += SIZELEN;\r\n-        modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\r\n-        offset += MODTIMELEN;\r\n-        checkSumOK = TarUtils.verifyCheckSum(header);\r\n-        offset += CHKSUMLEN;\r\n-        linkFlag = header[offset++];\r\n-        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\r\n-            : TarUtils.parseName(header, offset, NAMELEN, encoding);\r\n-        offset += NAMELEN;\r\n-        magic = TarUtils.parseName(header, offset, MAGICLEN);\r\n-        offset += MAGICLEN;\r\n-        version = TarUtils.parseName(header, offset, VERSIONLEN);\r\n-        offset += VERSIONLEN;\r\n-        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\r\n-            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\r\n-        offset += UNAMELEN;\r\n-        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\r\n-            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\r\n-        offset += GNAMELEN;\r\n-        devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\r\n-        offset += DEVLEN;\r\n-        devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\r\n-        offset += DEVLEN;\r\n-\r\n-        int type = evaluateType(header);\r\n-        switch (type) {\r\n-        case FORMAT_OLDGNU: {\r\n-            offset += ATIMELEN_GNU;\r\n-            offset += CTIMELEN_GNU;\r\n-            offset += OFFSETLEN_GNU;\r\n-            offset += LONGNAMESLEN_GNU;\r\n-            offset += PAD2LEN_GNU;\r\n-            offset += SPARSELEN_GNU;\r\n-            isExtended = TarUtils.parseBoolean(header, offset);\r\n-            offset += ISEXTENDEDLEN_GNU;\r\n-            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\r\n-            offset += REALSIZELEN_GNU;\r\n-            break;\r\n-        }\r\n-        case FORMAT_POSIX:\r\n-        default: {\r\n-            String prefix = oldStyle\r\n-                ? TarUtils.parseName(header, offset, PREFIXLEN)\r\n-                : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\r\n-            // SunOS tar -E does not add / to directory names, so fix\r\n-            // up to be consistent\r\n-            if (isDirectory() && !name.endsWith(\"/\")){\r\n-                name = name + \"/\";\r\n-            }\r\n-            if (prefix.length() > 0){\r\n-                name = prefix + \"/\" + name;\r\n-            }\r\n-        }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Strips Windows' drive letter as well as any leading slashes,\r\n-     * turns path separators into forward slahes.\r\n-     */\r\n-    private static String normalizeFileName(String fileName,\r\n-                                            boolean preserveLeadingSlashes) {\r\n-        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\r\n-\r\n-        if (osname != null) {\r\n-\r\n-            // Strip off drive letters!\r\n-            // REVIEW Would a better check be \"(File.separator == '\\')\"?\r\n-\r\n-            if (osname.startsWith(\"windows\")) {\r\n-                if (fileName.length() > 2) {\r\n-                    char ch1 = fileName.charAt(0);\r\n-                    char ch2 = fileName.charAt(1);\r\n-\r\n-                    if (ch2 == ':'\r\n-                        && (ch1 >= 'a' && ch1 <= 'z'\r\n-                            || ch1 >= 'A' && ch1 <= 'Z')) {\r\n-                        fileName = fileName.substring(2);\r\n-                    }\r\n-                }\r\n-            } else if (osname.contains(\"netware\")) {\r\n-                int colon = fileName.indexOf(':');\r\n-                if (colon != -1) {\r\n-                    fileName = fileName.substring(colon + 1);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        fileName = fileName.replace(File.separatorChar, '/');\r\n-\r\n-        // No absolute pathnames\r\n-        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\r\n-        // so we loop on starting /'s.\r\n-        while (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\r\n-            fileName = fileName.substring(1);\r\n-        }\r\n-        return fileName;\r\n-    }\r\n-\r\n-    /**\r\n-     * Evaluate an entry's header format from a header buffer.\r\n-     *\r\n-     * @param header The tar entry header buffer to evaluate the format for.\r\n-     * @return format type\r\n-     */\r\n-    private int evaluateType(byte[] header) {\r\n-        if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\r\n-            return FORMAT_OLDGNU;\r\n-        }\r\n-        if (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\r\n-            return FORMAT_POSIX;\r\n-        }\r\n-        return 0;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n+import org.apache.commons.compress.utils.ArchiveUtils;\n+\n+/**\n+ * This class represents an entry in a Tar archive. It consists\n+ * of the entry's header, as well as the entry's File. Entries\n+ * can be instantiated in one of three ways, depending on how\n+ * they are to be used.\n+ * <p>\n+ * TarEntries that are created from the header bytes read from\n+ * an archive are instantiated with the TarEntry( byte[] )\n+ * constructor. These entries will be used when extracting from\n+ * or listing the contents of an archive. These entries have their\n+ * header filled in using the header bytes. They also set the File\n+ * to null, since they reference an archive entry not a file.\n+ * <p>\n+ * TarEntries that are created from Files that are to be written\n+ * into an archive are instantiated with the TarEntry( File )\n+ * constructor. These entries have their header filled in using\n+ * the File's information. They also keep a reference to the File\n+ * for convenience when writing entries.\n+ * <p>\n+ * Finally, TarEntries can be constructed from nothing but a name.\n+ * This allows the programmer to construct the entry by hand, for\n+ * instance when only an InputStream is available for writing to\n+ * the archive, and the header information is constructed from\n+ * other information. In this case the header fields are set to\n+ * defaults and the File is set to null.\n+ *\n+ * <p>\n+ * The C structure for a Tar Entry's header is:\n+ * <pre>\n+ * struct header {\n+ * char name[100];     // TarConstants.NAMELEN    - offset   0\n+ * char mode[8];       // TarConstants.MODELEN    - offset 100\n+ * char uid[8];        // TarConstants.UIDLEN     - offset 108\n+ * char gid[8];        // TarConstants.GIDLEN     - offset 116\n+ * char size[12];      // TarConstants.SIZELEN    - offset 124\n+ * char mtime[12];     // TarConstants.MODTIMELEN - offset 136\n+ * char chksum[8];     // TarConstants.CHKSUMLEN  - offset 148\n+ * char linkflag[1];   //                         - offset 156\n+ * char linkname[100]; // TarConstants.NAMELEN    - offset 157\n+ * The following fields are only present in new-style POSIX tar archives:\n+ * char magic[6];      // TarConstants.MAGICLEN   - offset 257\n+ * char version[2];    // TarConstants.VERSIONLEN - offset 263\n+ * char uname[32];     // TarConstants.UNAMELEN   - offset 265\n+ * char gname[32];     // TarConstants.GNAMELEN   - offset 297\n+ * char devmajor[8];   // TarConstants.DEVLEN     - offset 329\n+ * char devminor[8];   // TarConstants.DEVLEN     - offset 337\n+ * char prefix[155];   // TarConstants.PREFIXLEN  - offset 345\n+ * // Used if \"name\" field is not long enough to hold the path\n+ * char pad[12];       // NULs                    - offset 500\n+ * } header;\n+ * All unused bytes are set to null.\n+ * New-style GNU tar files are slightly different from the above.\n+ * For values of size larger than 077777777777L (11 7s)\n+ * or uid and gid larger than 07777777L (7 7s)\n+ * the sign bit of the first byte is set, and the rest of the\n+ * field is the binary representation of the number.\n+ * See TarUtils.parseOctalOrBinary.\n+ * </pre>\n+ *\n+ * <p>\n+ * The C structure for a old GNU Tar Entry's header is:\n+ * <pre>\n+ * struct oldgnu_header {\n+ * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\n+ * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\n+ * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\n+ * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\n+ * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\n+ * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\n+ * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\n+ * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\n+ * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\n+ * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\n+ * };\n+ * </pre>\n+ * Whereas, \"struct sparse\" is:\n+ * <pre>\n+ * struct sparse {\n+ * char offset[12];   // offset 0\n+ * char numbytes[12]; // offset 12\n+ * };\n+ * </pre>\n+ *\n+ * @NotThreadSafe\n+ */\n+\n+public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n+    /** The entry's name. */\n+    private String name = \"\";\n+\n+    /** The entry's permission mode. */\n+    private int mode;\n+\n+    /** The entry's user id. */\n+    private long userId = 0;\n+\n+    /** The entry's group id. */\n+    private long groupId = 0;\n+\n+    /** The entry's size. */\n+    private long size = 0;\n+\n+    /** The entry's modification time. */\n+    private long modTime;\n+\n+    /** If the header checksum is reasonably correct. */\n+    private boolean checkSumOK;\n+\n+    /** The entry's link flag. */\n+    private byte linkFlag;\n+\n+    /** The entry's link name. */\n+    private String linkName = \"\";\n+\n+    /** The entry's magic tag. */\n+    private String magic = MAGIC_POSIX;\n+    /** The version of the format */\n+    private String version = VERSION_POSIX;\n+\n+    /** The entry's user name. */\n+    private String userName;\n+\n+    /** The entry's group name. */\n+    private String groupName = \"\";\n+\n+    /** The entry's major device number. */\n+    private int devMajor = 0;\n+\n+    /** The entry's minor device number. */\n+    private int devMinor = 0;\n+\n+    /** If an extension sparse header follows. */\n+    private boolean isExtended;\n+\n+    /** The entry's real size in case of a sparse file. */\n+    private long realSize;\n+\n+    /** The entry's file reference */\n+    private final File file;\n+\n+    /** Maximum length of a user's name in the tar file */\n+    public static final int MAX_NAMELEN = 31;\n+\n+    /** Default permissions bits for directories */\n+    public static final int DEFAULT_DIR_MODE = 040755;\n+\n+    /** Default permissions bits for files */\n+    public static final int DEFAULT_FILE_MODE = 0100644;\n+\n+    /** Convert millis to seconds */\n+    public static final int MILLIS_PER_SECOND = 1000;\n+\n+    /**\n+     * Construct an empty entry and prepares the header values.\n+     */\n+    private TarArchiveEntry() {\n+        String user = System.getProperty(\"user.name\", \"\");\n+\n+        if (user.length() > MAX_NAMELEN) {\n+            user = user.substring(0, MAX_NAMELEN);\n+        }\n+\n+        this.userName = user;\n+        this.file = null;\n+    }\n+\n+    /**\n+     * Construct an entry with only a name. This allows the programmer\n+     * to construct the entry's header \"by hand\". File is set to null.\n+     *\n+     * @param name the entry name\n+     */\n+    public TarArchiveEntry(String name) {\n+        this(name, false);\n+    }\n+\n+    /**\n+     * Construct an entry with only a name. This allows the programmer\n+     * to construct the entry's header \"by hand\". File is set to null.\n+     *\n+     * @param name the entry name\n+     * @param preserveLeadingSlashes whether to allow leading slashes\n+     * in the name.\n+     *\n+     * @since 1.1\n+     */\n+    public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\n+        this();\n+\n+        name = normalizeFileName(name, preserveLeadingSlashes);\n+        boolean isDir = name.endsWith(\"/\");\n+\n+        this.name = name;\n+        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n+        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n+        this.modTime = new Date().getTime() / MILLIS_PER_SECOND;\n+        this.userName = \"\";\n+    }\n+\n+    /**\n+     * Construct an entry with a name and a link flag.\n+     *\n+     * @param name the entry name\n+     * @param linkFlag the entry link flag.\n+     */\n+    public TarArchiveEntry(String name, byte linkFlag) {\n+        this(name, linkFlag, false);\n+    }\n+\n+    /**\n+     * Construct an entry with a name and a link flag.\n+     *\n+     * @param name the entry name\n+     * @param linkFlag the entry link flag.\n+     * @param preserveLeadingSlashes whether to allow leading slashes\n+     * in the name.\n+     *\n+     * @since 1.5\n+     */\n+    public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\n+        this(name, preserveLeadingSlashes);\n+        this.linkFlag = linkFlag;\n+        if (linkFlag == LF_GNUTYPE_LONGNAME) {\n+            magic = MAGIC_GNU;\n+            version = VERSION_GNU_SPACE;\n+        }\n+    }\n+\n+    /**\n+     * Construct an entry for a file. File is set to file, and the\n+     * header is constructed from information from the file.\n+     * The name is set from the normalized file path.\n+     *\n+     * @param file The file that the entry represents.\n+     */\n+    public TarArchiveEntry(File file) {\n+        this(file, file.getPath());\n+    }\n+\n+    /**\n+     * Construct an entry for a file. File is set to file, and the\n+     * header is constructed from information from the file.\n+     *\n+     * @param file The file that the entry represents.\n+     * @param fileName the name to be used for the entry.\n+     */\n+    public TarArchiveEntry(File file, String fileName) {\n+        String normalizedName = normalizeFileName(fileName, false);\n+        this.file = file;\n+\n+        if (file.isDirectory()) {\n+            this.mode = DEFAULT_DIR_MODE;\n+            this.linkFlag = LF_DIR;\n+\n+            int nameLength = normalizedName.length();\n+            if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\n+                this.name = normalizedName + \"/\";\n+            } else {\n+                this.name = normalizedName;\n+            }\n+        } else {\n+            this.mode = DEFAULT_FILE_MODE;\n+            this.linkFlag = LF_NORMAL;\n+            this.size = file.length();\n+            this.name = normalizedName;\n+        }\n+\n+        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n+        this.userName = \"\";\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     */\n+    public TarArchiveEntry(byte[] headerBuf) {\n+        this();\n+        parseTarHeader(headerBuf);\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     * @param encoding encoding to use for file names\n+     * @since 1.4\n+     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     * @throws IOException on error\n+     */\n+    public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\n+        throws IOException {\n+        this();\n+        parseTarHeader(headerBuf, encoding);\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined\n+     * by the header names being equal.\n+     *\n+     * @param it Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    public boolean equals(TarArchiveEntry it) {\n+        return getName().equals(it.getName());\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined\n+     * by the header names being equal.\n+     *\n+     * @param it Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    @Override\n+    public boolean equals(Object it) {\n+        if (it == null || getClass() != it.getClass()) {\n+            return false;\n+        }\n+        return equals((TarArchiveEntry) it);\n+    }\n+\n+    /**\n+     * Hashcodes are based on entry names.\n+     *\n+     * @return the entry hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        return getName().hashCode();\n+    }\n+\n+    /**\n+     * Determine if the given entry is a descendant of this entry.\n+     * Descendancy is determined by the name of the descendant\n+     * starting with this entry's name.\n+     *\n+     * @param desc Entry to be checked as a descendent of this.\n+     * @return True if entry is a descendant of this.\n+     */\n+    public boolean isDescendent(TarArchiveEntry desc) {\n+        return desc.getName().startsWith(getName());\n+    }\n+\n+    /**\n+     * Get this entry's name.\n+     *\n+     * @return This entry's name.\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Set this entry's name.\n+     *\n+     * @param name This entry's new name.\n+     */\n+    public void setName(String name) {\n+        this.name = normalizeFileName(name, false);\n+    }\n+\n+    /**\n+     * Set the mode for this entry\n+     *\n+     * @param mode the mode for this entry\n+     */\n+    public void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+\n+    /**\n+     * Get this entry's link name.\n+     *\n+     * @return This entry's link name.\n+     */\n+    public String getLinkName() {\n+        return linkName;\n+    }\n+\n+    /**\n+     * Set this entry's link name.\n+     *\n+     * @param link the link name to use.\n+     *\n+     * @since 1.1\n+     */\n+    public void setLinkName(String link) {\n+        this.linkName = link;\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     * @deprecated use #getLongUserId instead as user ids can be\n+     * bigger than {@link Integer#MAX_VALUE}\n+     */\n+    @Deprecated\n+    public int getUserId() {\n+        return (int) (userId & 0xffffffff);\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     */\n+    public void setUserId(int userId) {\n+        setUserId((long) userId);\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     * @since 1.10\n+     */\n+    public long getLongUserId() {\n+        return userId;\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     * @since 1.10\n+     */\n+    public void setUserId(long userId) {\n+        this.userId = userId;\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @return This entry's group id.\n+     * @deprecated use #getLongGroupId instead as group ids can be\n+     * bigger than {@link Integer#MAX_VALUE}\n+     */\n+    @Deprecated\n+    public int getGroupId() {\n+        return (int) (groupId & 0xffffffff);\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setGroupId(int groupId) {\n+        setGroupId((long) groupId);\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @since 1.10\n+     * @return This entry's group id.\n+     */\n+    public long getLongGroupId() {\n+        return groupId;\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @since 1.10\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setGroupId(long groupId) {\n+        this.groupId = groupId;\n+    }\n+\n+    /**\n+     * Get this entry's user name.\n+     *\n+     * @return This entry's user name.\n+     */\n+    public String getUserName() {\n+        return userName;\n+    }\n+\n+    /**\n+     * Set this entry's user name.\n+     *\n+     * @param userName This entry's new user name.\n+     */\n+    public void setUserName(String userName) {\n+        this.userName = userName;\n+    }\n+\n+    /**\n+     * Get this entry's group name.\n+     *\n+     * @return This entry's group name.\n+     */\n+    public String getGroupName() {\n+        return groupName;\n+    }\n+\n+    /**\n+     * Set this entry's group name.\n+     *\n+     * @param groupName This entry's new group name.\n+     */\n+    public void setGroupName(String groupName) {\n+        this.groupName = groupName;\n+    }\n+\n+    /**\n+     * Convenience method to set this entry's group and user ids.\n+     *\n+     * @param userId This entry's new user id.\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setIds(int userId, int groupId) {\n+        setUserId(userId);\n+        setGroupId(groupId);\n+    }\n+\n+    /**\n+     * Convenience method to set this entry's group and user names.\n+     *\n+     * @param userName This entry's new user name.\n+     * @param groupName This entry's new group name.\n+     */\n+    public void setNames(String userName, String groupName) {\n+        setUserName(userName);\n+        setGroupName(groupName);\n+    }\n+\n+    /**\n+     * Set this entry's modification time. The parameter passed\n+     * to this method is in \"Java time\".\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime(long time) {\n+        modTime = time / MILLIS_PER_SECOND;\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime(Date time) {\n+        modTime = time.getTime() / MILLIS_PER_SECOND;\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @return time This entry's new modification time.\n+     */\n+    public Date getModTime() {\n+        return new Date(modTime * MILLIS_PER_SECOND);\n+    }\n+\n+    public Date getLastModifiedDate() {\n+        return getModTime();\n+    }\n+\n+    /**\n+     * Get this entry's checksum status.\n+     *\n+     * @return if the header checksum is reasonably correct\n+     * @see TarUtils#verifyCheckSum(byte[])\n+     * @since 1.5\n+     */\n+    public boolean isCheckSumOK() {\n+        return checkSumOK;\n+    }\n+\n+    /**\n+     * Get this entry's file.\n+     *\n+     * @return This entry's file.\n+     */\n+    public File getFile() {\n+        return file;\n+    }\n+\n+    /**\n+     * Get this entry's mode.\n+     *\n+     * @return This entry's mode.\n+     */\n+    public int getMode() {\n+        return mode;\n+    }\n+\n+    /**\n+     * Get this entry's file size.\n+     *\n+     * @return This entry's file size.\n+     */\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Set this entry's file size.\n+     *\n+     * @param size This entry's new file size.\n+     * @throws IllegalArgumentException if the size is &lt; 0.\n+     */\n+    public void setSize(long size) {\n+        if (size < 0){\n+            throw new IllegalArgumentException(\"Size is out of range: \"+size);\n+        }\n+        this.size = size;\n+    }\n+\n+    /**\n+     * Get this entry's major device number.\n+     *\n+     * @return This entry's major device number.\n+     * @since 1.4\n+     */\n+    public int getDevMajor() {\n+        return devMajor;\n+    }\n+\n+    /**\n+     * Set this entry's major device number.\n+     *\n+     * @param devNo This entry's major device number.\n+     * @throws IllegalArgumentException if the devNo is &lt; 0.\n+     * @since 1.4\n+     */\n+    public void setDevMajor(int devNo) {\n+        if (devNo < 0){\n+            throw new IllegalArgumentException(\"Major device number is out of \"\n+                                               + \"range: \" + devNo);\n+        }\n+        this.devMajor = devNo;\n+    }\n+\n+    /**\n+     * Get this entry's minor device number.\n+     *\n+     * @return This entry's minor device number.\n+     * @since 1.4\n+     */\n+    public int getDevMinor() {\n+        return devMinor;\n+    }\n+\n+    /**\n+     * Set this entry's minor device number.\n+     *\n+     * @param devNo This entry's minor device number.\n+     * @throws IllegalArgumentException if the devNo is &lt; 0.\n+     * @since 1.4\n+     */\n+    public void setDevMinor(int devNo) {\n+        if (devNo < 0){\n+            throw new IllegalArgumentException(\"Minor device number is out of \"\n+                                               + \"range: \" + devNo);\n+        }\n+        this.devMinor = devNo;\n+    }\n+\n+    /**\n+     * Indicates in case of a sparse file if an extension sparse header\n+     * follows.\n+     *\n+     * @return true if an extension sparse header follows.\n+     */\n+    public boolean isExtended() {\n+        return isExtended;\n+    }\n+\n+    /**\n+     * Get this entry's real file size in case of a sparse file.\n+     *\n+     * @return This entry's real file size.\n+     */\n+    public long getRealSize() {\n+        return realSize;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU sparse block\n+     *\n+     * @return true if this is a sparse extension provided by GNU tar\n+     */\n+    public boolean isGNUSparse() {\n+        return linkFlag == LF_GNUTYPE_SPARSE;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU long linkname block\n+     *\n+     * @return true if this is a long name extension provided by GNU tar\n+     */\n+    public boolean isGNULongLinkEntry() {\n+        return linkFlag == LF_GNUTYPE_LONGLINK;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU long name block\n+     *\n+     * @return true if this is a long name extension provided by GNU tar\n+     */\n+    public boolean isGNULongNameEntry() {\n+        return linkFlag == LF_GNUTYPE_LONGNAME;\n+    }\n+\n+    /**\n+     * Check if this is a Pax header.\n+     *\n+     * @return {@code true} if this is a Pax header.\n+     *\n+     * @since 1.1\n+     *\n+     */\n+    public boolean isPaxHeader(){\n+        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n+            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n+    }\n+\n+    /**\n+     * Check if this is a Pax header.\n+     *\n+     * @return {@code true} if this is a Pax header.\n+     *\n+     * @since 1.1\n+     */\n+    public boolean isGlobalPaxHeader(){\n+        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n+    }\n+\n+    /**\n+     * Return whether or not this entry represents a directory.\n+     *\n+     * @return True if this entry is a directory.\n+     */\n+    public boolean isDirectory() {\n+        if (file != null) {\n+            return file.isDirectory();\n+        }\n+\n+        if (linkFlag == LF_DIR) {\n+            return true;\n+        }\n+\n+        if (getName().endsWith(\"/\")) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Check if this is a \"normal file\"\n+     *\n+     * @since 1.2\n+     * @return whether this is a \"normal file\"\n+     */\n+    public boolean isFile() {\n+        if (file != null) {\n+            return file.isFile();\n+        }\n+        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n+            return true;\n+        }\n+        return !getName().endsWith(\"/\");\n+    }\n+\n+    /**\n+     * Check if this is a symbolic link entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a symbolic link\n+     */\n+    public boolean isSymbolicLink() {\n+        return linkFlag == LF_SYMLINK;\n+    }\n+\n+    /**\n+     * Check if this is a link entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a link entry\n+     */\n+    public boolean isLink() {\n+        return linkFlag == LF_LINK;\n+    }\n+\n+    /**\n+     * Check if this is a character device entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a character device\n+     */\n+    public boolean isCharacterDevice() {\n+        return linkFlag == LF_CHR;\n+    }\n+\n+    /**\n+     * Check if this is a block device entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a block device\n+     */\n+    public boolean isBlockDevice() {\n+        return linkFlag == LF_BLK;\n+    }\n+\n+    /**\n+     * Check if this is a FIFO (pipe) entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a FIFO entry\n+     */\n+    public boolean isFIFO() {\n+        return linkFlag == LF_FIFO;\n+    }\n+\n+    /**\n+     * If this entry represents a file, and the file is a directory, return\n+     * an array of TarEntries for this entry's children.\n+     *\n+     * @return An array of TarEntry's for this entry's children.\n+     */\n+    public TarArchiveEntry[] getDirectoryEntries() {\n+        if (file == null || !file.isDirectory()) {\n+            return new TarArchiveEntry[0];\n+        }\n+\n+        String[] list = file.list();\n+        TarArchiveEntry[] result = new TarArchiveEntry[list == null ? 0 : list.length];\n+\n+        for (int i = 0; i < result.length; ++i) {\n+            result[i] = new TarArchiveEntry(new File(file, list[i]));\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * <p>This method does not use the star/GNU tar/BSD tar extensions.</p>\n+     *\n+     * @param outbuf The tar entry header buffer to fill in.\n+     */\n+    public void writeEntryHeader(byte[] outbuf) {\n+        try {\n+            writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n+        } catch (IOException ex) {\n+            try {\n+                writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n+            } catch (IOException ex2) {\n+                // impossible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * @param outbuf The tar entry header buffer to fill in.\n+     * @param encoding encoding to use when writing the file name.\n+     * @param starMode whether to use the star/GNU tar/BSD tar\n+     * extension for numeric fields if their value doesn't fit in the\n+     * maximum size of standard tar archives\n+     * @since 1.4\n+     * @throws IOException on error\n+     */\n+    public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\n+                                 boolean starMode) throws IOException {\n+        int offset = 0;\n+\n+        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\n+                                          encoding);\n+        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\n+        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\n+        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n+                                       starMode);\n+\n+        int csOffset = offset;\n+\n+        for (int c = 0; c < CHKSUMLEN; ++c) {\n+            outbuf[offset++] = (byte) ' ';\n+        }\n+\n+        outbuf[offset++] = linkFlag;\n+        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\n+                                          encoding);\n+        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\n+        offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\n+        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\n+                                          encoding);\n+        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\n+                                          encoding);\n+        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\n+                                       starMode);\n+\n+        while (offset < outbuf.length) {\n+            outbuf[offset++] = 0;\n+        }\n+\n+        long chk = TarUtils.computeCheckSum(outbuf);\n+\n+        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n+    }\n+\n+    private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\n+                                      int length, boolean starMode) {\n+        if (!starMode && (value < 0\n+                          || value >= 1l << 3 * (length - 1))) {\n+            // value doesn't fit into field when written as octal\n+            // number, will be written to PAX header or causes an\n+            // error\n+            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n+        }\n+        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n+                                                     length);\n+    }\n+\n+    /**\n+     * Parse an entry's header information from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to get information from.\n+     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     */\n+    public void parseTarHeader(byte[] header) {\n+        try {\n+            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n+        } catch (IOException ex) {\n+            try {\n+                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n+            } catch (IOException ex2) {\n+                // not really possible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parse an entry's header information from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to get information from.\n+     * @param encoding encoding to use for file names\n+     * @since 1.4\n+     * @throws IllegalArgumentException if any of the numeric fields\n+     * have an invalid format\n+     * @throws IOException on error\n+     */\n+    public void parseTarHeader(byte[] header, ZipEncoding encoding)\n+        throws IOException {\n+        parseTarHeader(header, encoding, false);\n+    }\n+\n+    private void parseTarHeader(byte[] header, ZipEncoding encoding,\n+                                final boolean oldStyle)\n+        throws IOException {\n+        int offset = 0;\n+\n+        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n+            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n+        offset += NAMELEN;\n+        mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\n+        offset += MODELEN;\n+        userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\n+        offset += UIDLEN;\n+        groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n+        offset += GIDLEN;\n+        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\n+        offset += SIZELEN;\n+        modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\n+        offset += MODTIMELEN;\n+        checkSumOK = TarUtils.verifyCheckSum(header);\n+        offset += CHKSUMLEN;\n+        linkFlag = header[offset++];\n+        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n+            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n+        offset += NAMELEN;\n+        magic = TarUtils.parseName(header, offset, MAGICLEN);\n+        offset += MAGICLEN;\n+        version = TarUtils.parseName(header, offset, VERSIONLEN);\n+        offset += VERSIONLEN;\n+        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n+            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\n+        offset += UNAMELEN;\n+        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n+            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\n+        offset += GNAMELEN;\n+        devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n+        offset += DEVLEN;\n+        devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n+        offset += DEVLEN;\n+\n+        int type = evaluateType(header);\n+        switch (type) {\n+        case FORMAT_OLDGNU: {\n+            offset += ATIMELEN_GNU;\n+            offset += CTIMELEN_GNU;\n+            offset += OFFSETLEN_GNU;\n+            offset += LONGNAMESLEN_GNU;\n+            offset += PAD2LEN_GNU;\n+            offset += SPARSELEN_GNU;\n+            isExtended = TarUtils.parseBoolean(header, offset);\n+            offset += ISEXTENDEDLEN_GNU;\n+            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\n+            offset += REALSIZELEN_GNU;\n+            break;\n+        }\n+        case FORMAT_POSIX:\n+        default: {\n+            String prefix = oldStyle\n+                ? TarUtils.parseName(header, offset, PREFIXLEN)\n+                : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n+            // SunOS tar -E does not add / to directory names, so fix\n+            // up to be consistent\n+            if (isDirectory() && !name.endsWith(\"/\")){\n+                name = name + \"/\";\n+            }\n+            if (prefix.length() > 0){\n+                name = prefix + \"/\" + name;\n+            }\n+        }\n+        }\n+    }\n+\n+    /**\n+     * Strips Windows' drive letter as well as any leading slashes,\n+     * turns path separators into forward slahes.\n+     */\n+    private static String normalizeFileName(String fileName,\n+                                            boolean preserveLeadingSlashes) {\n+        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n+\n+        if (osname != null) {\n+\n+            // Strip off drive letters!\n+            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n+\n+            if (osname.startsWith(\"windows\")) {\n+                if (fileName.length() > 2) {\n+                    char ch1 = fileName.charAt(0);\n+                    char ch2 = fileName.charAt(1);\n+\n+                    if (ch2 == ':'\n+                        && (ch1 >= 'a' && ch1 <= 'z'\n+                            || ch1 >= 'A' && ch1 <= 'Z')) {\n+                        fileName = fileName.substring(2);\n+                    }\n+                }\n+            } else if (osname.contains(\"netware\")) {\n+                int colon = fileName.indexOf(':');\n+                if (colon != -1) {\n+                    fileName = fileName.substring(colon + 1);\n+                }\n+            }\n+        }\n+\n+        fileName = fileName.replace(File.separatorChar, '/');\n+\n+        // No absolute pathnames\n+        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n+        // so we loop on starting /'s.\n+        while (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\n+            fileName = fileName.substring(1);\n+        }\n+        return fileName;\n+    }\n+\n+    /**\n+     * Evaluate an entry's header format from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to evaluate the format for.\n+     * @return format type\n+     */\n+    private int evaluateType(byte[] header) {\n+        if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\n+            return FORMAT_OLDGNU;\n+        }\n+        if (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\n+            return FORMAT_POSIX;\n+        }\n+        return 0;\n+    }\n+}\n+\n",
      "files_name_in_blame_commit": [
        "TarArchiveEntry.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 75
  }
}
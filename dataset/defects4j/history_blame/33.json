{
  "id": "33",
  "blame_commit": {
    "commit": {
      "commit_id": "e2df85024e2ab99645a788b4b2836ba1cfdb87f5",
      "commit_message": "PR: CODED-69\nSubmitted-By: Julius Davies <juliusdavies@gmail.com>\nAdded the Base64InputStream and the Base64OutputStream.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@669256 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Jochen Wiedmann",
      "commit_date": "2008-06-18 19:16:03",
      "commit_parent": "a7a30fac492f9f72bc2970d145691a7357674839"
    },
    "function": {
      "function_name": "encode",
      "function_code_before": "",
      "function_code_after": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = intToBase64[(x >> 2) & 0x3f];\n                buf[pos++] = intToBase64[(x << 4) & 0x3f];\n                buf[pos++] = PAD;\n                buf[pos++] = PAD;\n                break;\n\n            case 2:\n                buf[pos++] = intToBase64[(x >> 10) & 0x3f];\n                buf[pos++] = intToBase64[(x >> 4) & 0x3f];\n                buf[pos++] = intToBase64[(x << 2) & 0x3f];\n                buf[pos++] = PAD;\n                break;\n        }\n        if (lineLength > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) { b += 256; }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = intToBase64[(x >> 18) & 0x3f];\n                buf[pos++] = intToBase64[(x >> 12) & 0x3f];\n                buf[pos++] = intToBase64[(x >> 6) & 0x3f];\n                buf[pos++] = intToBase64[x & 0x3f];\n                currentLinePos += 4;\n                if (lineLength > 0 && lineLength <= currentLinePos) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n        }\n    }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 328,
      "function_after_end_line": 382,
      "function_before_token_count": 0,
      "function_after_token_count": 414,
      "functions_name_modified_file": [
        "readResults",
        "hasData",
        "resizeBuf",
        "encodeBase64",
        "discardNonBase64",
        "encodeInteger",
        "setInitialBuffer",
        "encode",
        "decodeBase64",
        "isBase64",
        "avail",
        "isArrayByteBase64",
        "Base64",
        "encodeBase64Chunked",
        "discardWhitespace",
        "decode",
        "decodeInteger",
        "toIntegerBytes"
      ],
      "functions_name_all_files": [
        "Base64InputStreamTest",
        "encodeBase64",
        "Base64OutputStream",
        "setInitialBuffer",
        "testByChunk",
        "decodeInteger",
        "decode",
        "Base64InputStream",
        "resizeBuf",
        "fill",
        "testBase64InputStreamByChunk",
        "decodeBase64",
        "close",
        "testBase64InputStreamByteByByte",
        "avail",
        "isArrayByteBase64",
        "Base64",
        "isBase64",
        "readResults",
        "read",
        "encodeInteger",
        "flush",
        "toIntegerBytes",
        "hasData",
        "discardNonBase64",
        "Base64OutputStreamTest",
        "write",
        "encode",
        "streamToBytes",
        "encodeBase64Chunked",
        "testByteByByte",
        "discardWhitespace",
        "resizeArray"
      ],
      "functions_name_co_evolved_modified_file": [
        "readResults",
        "hasData",
        "resizeBuf",
        "encodeBase64",
        "setInitialBuffer",
        "encode",
        "decode",
        "decodeBase64",
        "avail",
        "Base64",
        "isBase64",
        "for"
      ],
      "functions_name_co_evolved_all_files": [
        "Base64InputStreamTest",
        "encodeBase64",
        "Base64OutputStream",
        "setInitialBuffer",
        "testByChunk",
        "decode",
        "for",
        "Base64InputStream",
        "resizeBuf",
        "fill",
        "testBase64InputStreamByChunk",
        "decodeBase64",
        "close",
        "testBase64InputStreamByteByByte",
        "avail",
        "Base64",
        "isBase64",
        "readResults",
        "read",
        "flush",
        "hasData",
        "Base64OutputStreamTest",
        "write",
        "encode",
        "streamToBytes",
        "testByteByByte",
        "resizeArray"
      ]
    },
    "file": {
      "file_name": "Base64.java",
      "file_nloc": 334,
      "file_complexity": 92,
      "file_token_count": 2792,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -22,6 +22,7 @@ import org.apache.commons.codec.BinaryEncoder;\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n \n+import java.io.UnsupportedEncodingException;\n import java.math.BigInteger;\n \n /**\n@@ -38,7 +39,6 @@ import java.math.BigInteger;\n  * @version $Id$\n  */\n public class Base64 implements BinaryEncoder, BinaryDecoder {\n-\n     /**\n      * Chunk size per RFC 2045 section 6.8.\n      * \n@@ -59,104 +59,392 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n     static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n \n     /**\n-     * The base length.\n+     * Byte used to pad output.\n      */\n-    private static final int BASELENGTH = 255;\n+    private static final byte PAD = (byte) '=';\n+\n+\n+    // The static final fields above are used for the original static byte[] methods on Base64.\n+    // The private member fields below are used with the new streaming approach, which requires\n+    // some state be preserved between calls of encode() and decode().\n+\n \n     /**\n-     * Lookup length.\n+     * Line length for encoding.  Not used when decoding.  Any value of zero or less implies\n+     * so chunking of the base64 encoded data.\n      */\n-    private static final int LOOKUPLENGTH = 64;\n+    private final int lineLength;\n \n     /**\n-     * Used to calculate the number of bits in a byte.\n+     * Line separator for encoding.  Not used when decoding.  Only used if lineLength >= 1.\n      */\n-    private static final int EIGHTBIT = 8;\n+    private final byte[] lineSeparator;\n \n     /**\n-     * Used when encoding something which has fewer than 24 bits.\n+     * Convenience variable to help us determine when our buffer is going to run out of\n+     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>\n      */\n-    private static final int SIXTEENBIT = 16;\n+    private final int decodeSize;\n \n     /**\n-     * Used to determine how many bits data contains.\n+     * Convenience variable to help us determine when our buffer is going to run out of\n+     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>\n      */\n-    private static final int TWENTYFOURBITGROUP = 24;\n+    private final int encodeSize;\n \n     /**\n-     * Used to get the number of Quadruples.\n+     * Buffer for streaming. \n      */\n-    private static final int FOURBYTE = 4;\n+    private byte[] buf;\n \n     /**\n-     * Used to test the sign of a byte.\n+     * Position where next character should be written in the buffer.\n      */\n-    private static final int SIGN = -128;\n+    private int pos;\n \n     /**\n-     * Byte used to pad output.\n+     * Position where next character should be read from the buffer.\n      */\n-    private static final byte PAD = (byte) '=';\n+    private int readPos;\n \n     /**\n-     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n-     * indices.\n-     * <p>\n-     * For example, <code>base64Alphabet['+']</code> returns <code>62</code>.\n-     * </p>\n-     * <p>\n-     * The value of undefined encodings is <code>-1</code>.\n-     * </p>\n+     * Variable tracks how many characters have been written to the current line.\n+     * Only used when encoding.  We use it to make sure each encoded line never\n+     * goes beyond lineLength (if lineLength >= 0).\n      */\n-    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n+    private int currentLinePos;\n+\n+    /**\n+     * Writes to the buffer only occur after every 3 reads when encoding, an\n+     * every 4 reads when decoding.  This variable helps track that.\n+     */\n+    private int modulus;\n+\n+    /**\n+     * Boolean flag to indicate the EOF has been reached.  Once EOF has been\n+     * reached, this Base64 object becomes useless, and must be thrown away.\n+     */\n+    private boolean eof;\n+\n+    /**\n+     * Place holder for the 3 bytes we're dealing with for our base64 logic.\n+     * Bitwise operations store and extract the base64 encoding or decoding from\n+     * this variable.\n+     */\n+    private int x;\n+\n+    /**\n+     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF\n+     * when encoding, and all forms can be decoded.\n+     */\n+    Base64() {\n+        this(CHUNK_SIZE, CHUNK_SEPARATOR);\n+    }\n \n     /**\n      * <p>\n-     * Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n-     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n-     * <code>/</code>.\n-     * </p>\n-     * <p>\n-     * This array is accessed by using character values as indices.\n+     * Consumer can use this constructor to choose a different lineLength\n+     * when encoding (lineSeparator is still CRLF).  All forms of data can\n+     * be decoded.\n+     * </p><p>\n+     * Note:  lineLengths that aren't multiples of 4 will still essentially\n+     * end up being multiples of 4 in the encoded data.\n      * </p>\n+     *\n+     * @param lineLength each line of encoded data will be at most this long\n+     * (rounded up to nearest multiple of 4).  Ignored when decoding.\n+     */\n+    Base64(int lineLength) {\n+        this(lineLength, CHUNK_SEPARATOR);\n+    }\n+\n+    /**\n      * <p>\n-     * For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.\n+     * Consumer can use this constructor to choose a different lineLength\n+     * and lineSeparator when encoding.  All forms of data can\n+     * be decoded.\n+     * </p><p>\n+     * Note:  lineLengths that aren't multiples of 4 will still essentially\n+     * end up being multiples of 4 in the encoded data.\n      * </p>\n+     * @param lineLength    Each line of encoded data will be at most this long\n+     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.\n+     * @param lineSeparator Each line of encoded data will end with this\n+     *                      sequence of bytes.\n+     * @throws IllegalArgumentException The provided lineSeparator included\n+     *                                  some base64 characters.  That's not going to work!\n      */\n-    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n-\n-    // Populating the lookup and character arrays\n-    static {\n-        for (int i = 0; i < BASELENGTH; i++) {\n-            base64Alphabet[i] = (byte) -1;\n-        }\n-        for (int i = 'Z'; i >= 'A'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'A');\n+    Base64(int lineLength, byte[] lineSeparator) {\n+        this.lineLength = lineLength;\n+        this.lineSeparator = lineSeparator;\n+        if (lineLength > 0) {\n+            this.encodeSize = (byte) (4 + lineSeparator.length);\n+        } else {\n+            this.encodeSize = 4;\n         }\n-        for (int i = 'z'; i >= 'a'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'a' + 26);\n+        this.decodeSize = encodeSize - 1;\n+        byte[] separator = discardWhitespace(lineSeparator);\n+        if (separator.length > 0 && isArrayByteBase64(separator)) {\n+            String sep;\n+            try {\n+                sep = new String(lineSeparator, \"UTF-8\");\n+            } catch (UnsupportedEncodingException uee) {\n+                sep = new String(lineSeparator);\n+            }\n+            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n         }\n-        for (int i = '9'; i >= '0'; i--) {\n-            base64Alphabet[i] = (byte) (i - '0' + 52);\n+    }\n+\n+    /**\n+     * This array is a lookup table that translates 6-bit positive integer\n+     * index values into their \"Base64 Alphabet\" equivalents as specified\n+     * in Table 1 of RFC 2045.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code. \n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     */\n+    private static final byte[] intToBase64 = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n+    };\n+\n+    /**\n+     * This array is a lookup table that translates unicode characters\n+     * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n+     * into their 6-bit positive integer equivalents.  Characters that\n+     * are not in the Base64 alphabet but fall within the bounds of the\n+     * array are translated to -1.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n+     */\n+    private static final byte[] base64ToInt = {\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,\n+            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n+            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n+            24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n+    };\n+\n+    /**\n+     * Returns true if this Base64 object has buffered data for reading.\n+     *\n+     * @return true if there is Base64 object still available for reading.\n+     */\n+    boolean hasData() { return buf != null; }\n+\n+    /**\n+     * Returns the amount of buffered data available for reading.\n+     *\n+     * @return The amount of buffered data available for reading.\n+     */\n+    int avail() { return buf != null ? pos - readPos : 0; }\n+\n+    /** Doubles our buffer. */\n+    private void resizeBuf() {\n+        if (buf == null) {\n+            buf = new byte[8192];\n+            pos = 0;\n+            readPos = 0;\n+        } else {\n+            byte[] b = new byte[buf.length * 2];\n+            System.arraycopy(buf, 0, b, 0, buf.length);\n+            buf = b;\n         }\n+    }\n \n-        base64Alphabet['+'] = 62;\n-        base64Alphabet['/'] = 63;\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting\n+     * at position bPos, up to a maximum of bAvail bytes.  Returns how\n+     * many bytes were actually extracted.\n+     *\n+     * @param b      byte[] array to extract the buffered data into.\n+     * @param bPos   position in byte[] array to start extraction at.\n+     * @param bAvail amount of bytes we're allowed to extract.  We may extract\n+     *               fewer (if fewer are available).\n+     * @return The number of bytes successfully extracted into the provided\n+     *         byte[] array.\n+     */\n+    int readResults(byte[] b, int bPos, int bAvail) {\n+        if (buf != null) {\n+            int len = Math.min(avail(), bAvail);\n+            if (buf != b) {\n+                System.arraycopy(buf, readPos, b, bPos, len);\n+                readPos += len;\n+                if (readPos >= pos) {\n+                    buf = null;\n+                }\n+            } else {\n+                // Re-using the original consumer's output array is only\n+                // allowed for one round.\n+                buf = null;\n+            }\n+            return len;\n+        } else {\n+            return eof ? -1 : 0;\n+        }\n+    }\n \n-        for (int i = 0; i <= 25; i++) {\n-            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n+    /**\n+     * Small optimization where we try to buffer directly to the consumer's\n+     * output array for one round (if consumer calls this method first!) instead\n+     * of starting our own buffer.\n+     *\n+     * @param out byte[] array to buffer directly to.\n+     * @param outPos Position to start buffering into.\n+     * @param outAvail Amount of bytes available for direct buffering.\n+     */\n+    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n+        // We can re-use consumer's original output array under\n+        // special circumstances, saving on some System.arraycopy().\n+        if (out != null && out.length == outAvail) {\n+            buf = out;\n+            pos = outPos;\n+            readPos = outPos;\n         }\n+    }\n \n-        for (int i = 26, j = 0; i <= 51; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n+    /**\n+     * <p>\n+     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n+     * Must be called at least twice:  once with the data to encode, and once\n+     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n+     * so flush last remaining bytes (if not multiple of 3).\n+     * </p><p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n+     * and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     * </p>\n+     *\n+     * @param in byte[] array of binary data to base64 encode.\n+     * @param inPos Position to start reading data from.\n+     * @param inAvail Amount of bytes available from input for encoding.\n+     */\n+    void encode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n         }\n \n-        for (int i = 52, j = 0; i <= 61; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n+        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n+        // encoding.\n+        if (inAvail < 0) {\n+            eof = true;\n+            if (buf == null || buf.length - pos < encodeSize) {\n+                resizeBuf();\n+            }\n+            switch (modulus) {\n+                case 1:\n+                    buf[pos++] = intToBase64[(x >> 2) & 0x3f];\n+                    buf[pos++] = intToBase64[(x << 4) & 0x3f];\n+                    buf[pos++] = PAD;\n+                    buf[pos++] = PAD;\n+                    break;\n+\n+                case 2:\n+                    buf[pos++] = intToBase64[(x >> 10) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 4) & 0x3f];\n+                    buf[pos++] = intToBase64[(x << 2) & 0x3f];\n+                    buf[pos++] = PAD;\n+                    break;\n+            }\n+            if (lineLength > 0) {\n+                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                pos += lineSeparator.length;\n+            }\n+        } else {\n+            for (int i = 0; i < inAvail; i++) {\n+                if (buf == null || buf.length - pos < encodeSize) {\n+                    resizeBuf();\n+                }\n+                modulus = (++modulus) % 3;\n+                int b = in[inPos++];\n+                if (b < 0) { b += 256; }\n+                x = (x << 8) + b;\n+                if (0 == modulus) {\n+                    buf[pos++] = intToBase64[(x >> 18) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 12) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 6) & 0x3f];\n+                    buf[pos++] = intToBase64[x & 0x3f];\n+                    currentLinePos += 4;\n+                    if (lineLength > 0 && lineLength <= currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                        pos += lineSeparator.length;\n+                        currentLinePos = 0;\n+                    }\n+                }\n+            }\n         }\n+    }\n \n-        lookUpBase64Alphabet[62] = (byte) '+';\n-        lookUpBase64Alphabet[63] = (byte) '/';\n+    /**\n+     * <p>\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes.\n+     * Should be called at least twice:  once with the data to decode, and once\n+     * with inAvail set to \"-1\" to alert decoder that EOF has been reached.\n+     * The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p><p>\n+     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)\n+     * data is handled, since CR and LF are silently ignored, but has implications\n+     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out\n+     * philosophy:  it will not check the provided data for validity.\n+     * </p><p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n+     * and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     * </p>\n+\n+     * @param in byte[] array of ascii data to base64 decode.\n+     * @param inPos Position to start reading data from.\n+     * @param inAvail Amount of bytes available from input for encoding.\n+     */    \n+    void decode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n+        }\n+        if (inAvail < 0) {\n+            eof = true;\n+        }\n+        for (int i = 0; i < inAvail; i++) {\n+            if (buf == null || buf.length - pos < decodeSize) {\n+                resizeBuf();\n+            }\n+            byte b = in[inPos++];\n+            if (b == PAD) {\n+                modulus = (++modulus) % 4;\n+                x = x << 6;\n+                switch (modulus) {\n+                    case 3:\n+                        x = x << 6;\n+                    case 0:\n+                        buf[pos++] = (byte) ((x >> 16) & 0xff);\n+                        if (modulus == 0) {\n+                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n+                        }\n+                    default:\n+                        // WE'RE DONE!!!!\n+                        eof = true;\n+                        return;\n+                }\n+            } else {\n+                if (b >= 0 && b < base64ToInt.length) {\n+                    int result = base64ToInt[b];\n+                    if (result >= 0) {\n+                        modulus = (byte) ((++modulus) % 4);\n+                        x = (x << 6) + result;\n+                        if (modulus == 0) {\n+                            buf[pos++] = (byte) ((x >> 16) & 0xff);\n+                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n+                            buf[pos++] = (byte) (x & 0xff);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     /**\n@@ -167,13 +455,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n      */\n     private static boolean isBase64(byte octect) {\n-        if (octect == PAD) {\n-            return true;\n-        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n-            return false;\n-        } else {\n-            return true;\n-        }\n+        return octect == PAD || (octect >= 0 && octect < base64ToInt.length && base64ToInt[octect] != -1);\n     }\n \n     /**\n@@ -264,189 +546,59 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      */\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n-        long binaryDataLength = binaryData.length;\n-        long lengthDataBits = binaryDataLength * EIGHTBIT;\n-        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n-        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n-        long encodedDataLengthLong = 0;\n-        int chunckCount = 0;\n-\n-        if (fewerThan24bits != 0) {\n-            // data not divisible by 24 bit\n-            encodedDataLengthLong = (tripletCount + 1) * 4;\n-        } else {\n-            // 16 or 8 bit\n-            encodedDataLengthLong = tripletCount * 4;\n+        if (binaryData == null || binaryData.length == 0) {\n+            return binaryData;\n         }\n+        Base64 b64 = isChunked ? new Base64() : new Base64(0);\n \n-        // If the output is to be \"chunked\" into 76 character sections,\n-        // for compliance with RFC 2045 MIME, then it is important to\n-        // allow for extra length to account for the separator(s)\n+        long len = (binaryData.length * 4) / 3;\n+        long mod = len % 4;\n+        if (mod != 0) {\n+            len += 4 - mod;\n+        }\n         if (isChunked) {\n-\n-            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n-                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n-            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n+            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n         }\n \n-        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n+        if (len > Integer.MAX_VALUE) {\n             throw new IllegalArgumentException(\n                     \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n         }\n-        int encodedDataLength = (int) encodedDataLengthLong;\n-        byte encodedData[] = new byte[encodedDataLength];\n-\n-        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        int i = 0;\n-        int nextSeparatorIndex = CHUNK_SIZE;\n-        int chunksSoFar = 0;\n-\n-        // log.debug(\"number of triplets = \" + numberTriplets);\n-        for (i = 0; i < tripletCount; i++) {\n-            dataIndex = i * 3;\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            b3 = binaryData[dataIndex + 2];\n-\n-            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n-\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n-            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            // log.debug( \"val2 = \" + val2 );\n-            // log.debug( \"k4 = \" + (k<<4) );\n-            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n-            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n-\n-            encodedIndex += 4;\n-\n-            // If we are chunking, let's put a chunk separator down.\n-            if (isChunked) {\n-                // this assumes that CHUNK_SIZE % 4 == 0\n-                if (encodedIndex == nextSeparatorIndex) {\n-                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n-                    chunksSoFar++;\n-                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n-                    encodedIndex += CHUNK_SEPARATOR.length;\n-                }\n-            }\n-        }\n-\n-        // form integral number of 6-bit groups\n-        dataIndex = i * 3;\n-\n-        if (fewerThan24bits == EIGHTBIT) {\n-            b1 = binaryData[dataIndex];\n-            k = (byte) (b1 & 0x03);\n-            // log.debug(\"b1=\" + b1);\n-            // log.debug(\"b1<<2 = \" + (b1>>2) );\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n-            encodedData[encodedIndex + 2] = PAD;\n-            encodedData[encodedIndex + 3] = PAD;\n-        } else if (fewerThan24bits == SIXTEENBIT) {\n-\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n-            encodedData[encodedIndex + 3] = PAD;\n-        }\n-\n-        if (isChunked) {\n-            // we also add a separator to the end of the final chunk.\n-            if (chunksSoFar < chunckCount) {\n-                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n-                        CHUNK_SEPARATOR.length);\n-            }\n+        byte[] buf = new byte[(int) len];\n+        b64.setInitialBuffer(buf, 0, buf.length);\n+        b64.encode(binaryData, 0, binaryData.length);\n+        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n+\n+        // Encoder might have resized, even though it was unnecessary.\n+        if (b64.buf != buf) {\n+            b64.readResults(buf, 0, buf.length);\n         }\n-\n-        return encodedData;\n+        return buf;\n     }\n \n     /**\n      * Decodes Base64 data into octects\n-     * \n-     * @param base64Data\n-     *            Byte array containing Base64 data\n+     *\n+     * @param base64Data Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n-        // RFC 2045 requires that we discard ALL non-Base64 characters\n-        base64Data = discardNonBase64(base64Data);\n-\n-        // handle the edge case, so we don't have to worry about it later\n-        if (base64Data.length == 0) {\n-            return new byte[0];\n-        }\n-\n-        int numberQuadruple = base64Data.length / FOURBYTE;\n-        byte decodedData[] = null;\n-        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n-\n-        // Throw away anything not in base64Data\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        {\n-            // this sizes the output array properly - rlw\n-            int lastData = base64Data.length;\n-            // ignore the '=' padding\n-            while (base64Data[lastData - 1] == PAD) {\n-                if (--lastData == 0) {\n-                    return new byte[0];\n-                }\n-            }\n-            decodedData = new byte[lastData - numberQuadruple];\n-        }\n-\n-        for (int i = 0; i < numberQuadruple; i++) {\n-            dataIndex = i * 4;\n-            marker0 = base64Data[dataIndex + 2];\n-            marker1 = base64Data[dataIndex + 3];\n-\n-            b1 = base64Alphabet[base64Data[dataIndex]];\n-            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n-\n-            if (marker0 != PAD && marker1 != PAD) {\n-                // No PAD e.g 3cQl\n-                b3 = base64Alphabet[marker0];\n-                b4 = base64Alphabet[marker1];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n-            } else if (marker0 == PAD) {\n-                // Two PAD e.g. 3c[Pad][Pad]\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-            } else if (marker1 == PAD) {\n-                // One PAD e.g. 3cQ[Pad]\n-                b3 = base64Alphabet[marker0];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-            }\n-            encodedIndex += 3;\n+        if (base64Data == null || base64Data.length == 0) {\n+            return base64Data;\n         }\n-        return decodedData;\n+        Base64 b64 = new Base64();\n+\n+        long len = (base64Data.length * 3) / 4;\n+        byte[] buf = new byte[(int) len];\n+        b64.setInitialBuffer(buf, 0, buf.length);\n+        b64.decode(base64Data, 0, base64Data.length);\n+        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n+\n+        // We have no idea what the line-length was, so we\n+        // cannot know how much of our array wasn't used.\n+        byte[] result = new byte[b64.pos];\n+        b64.readResults(result, 0, result.length);\n+        return result;\n     }\n \n     /**\n",
      "files_name_in_blame_commit": [
        "Base64OutputStreamTest.java",
        "Base64InputStreamTest.java",
        "Base64.java",
        "Base64TestData.java",
        "Base64InputStream.java",
        "Base64OutputStream.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 46
  }
}
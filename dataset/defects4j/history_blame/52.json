{
  "id": "52",
  "blame_commit": {
    "commit": {
      "commit_id": "bb639974b0928a338b4bf60b17b1f612d619e0db",
      "commit_message": "Start adding basic JSON Pointer support",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2013-08-30 21:45:13",
      "commit_parent": "7dc9de68ef10bb4899a59a86a1242dd54a2953f1"
    },
    "function": {
      "function_name": "",
      "function_code_before": "",
      "function_code_after": "",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": "",
      "function_after_end_line": "",
      "function_before_token_count": 0,
      "function_after_token_count": 0,
      "functions_name_modified_file": [
        "matches",
        "matchElement",
        "getMatchingIndex",
        "_parseInt",
        "toString",
        "mayMatchProperty",
        "_parseTail",
        "equals",
        "getMatchingProperty",
        "parse",
        "hashCode",
        "_parseQuotedTail",
        "_appendEscape",
        "mayMatchElement",
        "matchProperty",
        "JsonPointer"
      ],
      "functions_name_all_files": [
        "createRootContext",
        "toString",
        "getParent",
        "getMatchingProperty",
        "createChildArrayContext",
        "hashCode",
        "writeFieldName",
        "JsonWriteContext",
        "appendDesc",
        "getMatchingIndex",
        "mayMatchProperty",
        "writeValue",
        "parse",
        "_parseQuotedTail",
        "_appendEscape",
        "getCurrentName",
        "JsonPointer",
        "matches",
        "_parseTail",
        "createChildObjectContext",
        "matchElement",
        "_parseInt",
        "equals",
        "mayMatchElement",
        "reset",
        "matchProperty"
      ],
      "functions_name_co_evolved_modified_file": [
        "matches",
        "matchElement",
        "getMatchingIndex",
        "_parseInt",
        "_parseTail",
        "toString",
        "mayMatchProperty",
        "equals",
        "getMatchingProperty",
        "parse",
        "hashCode",
        "_parseQuotedTail",
        "_appendEscape",
        "mayMatchElement",
        "matchProperty",
        "JsonPointer"
      ],
      "functions_name_co_evolved_all_files": [
        "matches",
        "matchElement",
        "getMatchingIndex",
        "_parseInt",
        "_parseTail",
        "toString",
        "mayMatchProperty",
        "equals",
        "getMatchingProperty",
        "parse",
        "hashCode",
        "_parseQuotedTail",
        "_appendEscape",
        "mayMatchElement",
        "matchProperty",
        "JsonPointer"
      ]
    },
    "file": {
      "file_name": "JsonPointer.java",
      "file_nloc": 143,
      "file_complexity": 42,
      "file_token_count": 807,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,281 @@\n+package com.fasterxml.jackson.core;\n+\n+import com.fasterxml.jackson.core.io.NumberInput;\n+\n+/**\n+ * Implementation of\n+ * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n+ * specification.\n+ * Pointer instances can be used to locate logical JSON nodes for things like\n+ * tree traversal (see {@link TreeNode#find}) and filtering of streaming JSON content\n+ * (see {@link JsonParser#filter}).\n+ *<p>\n+ * Instances are fully immutable and can be shared, cached.\n+ * \n+ * @author Tatu Saloranta\n+ * \n+ * @since 2.3\n+ */\n+public class JsonPointer\n+{\n+    /**\n+     * Marker instance used to represent segment that matches current\n+     * node or position.\n+     */\n+    protected final static JsonPointer EMPTY = new JsonPointer();\n+    \n+    /**\n+     * Reference to rest of the pointer beyond currently matching\n+     * segment (if any); null if this pointer refers to a matching\n+     * segment.\n+     */\n+    protected final JsonPointer _nextSegment;\n+    \n+    /**\n+     * We will retain representation of the pointer, as a String,\n+     * so that {@link #toString} should be as efficient as possible.\n+     */\n+    protected final String _asString;\n+    \n+    protected final String _matchingPropertyName;\n+\n+    protected final int _matchingElementIndex;\n+\n+    /*\n+    /**********************************************************\n+    /* Cosntruction\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Constructor used for creating \"empty\" instance, used to represent\n+     * state that matches current node.\n+     */\n+    protected JsonPointer()\n+    {\n+        _nextSegment = null;\n+        _matchingPropertyName = \"\";\n+        _matchingElementIndex = -1;\n+        _asString = \"\";\n+    }\n+\n+    /**\n+     * Constructor used for creating non-empty Segments\n+     */\n+    protected JsonPointer(String fullString, String segment, JsonPointer next)\n+    {\n+        _asString = fullString;\n+        _nextSegment = next;\n+        // Ok; may always be a property\n+        _matchingPropertyName = segment;\n+        _matchingElementIndex = _parseInt(segment);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method that parses given input and construct matching pointer\n+     * instance, if it represents a valid JSON Pointer: if not, a\n+     * {@link IllegalArgumentException} is thrown.\n+     * \n+     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n+     *   expression: currently the only such expression is one that does NOT start with\n+     *   a slash ('/').\n+     */\n+    public static JsonPointer parse(String input)\n+        throws IllegalArgumentException\n+    {\n+        // First quick checks for well-known 'empty' pointer\n+        if ((input == null) || input.length() == 0) {\n+            return EMPTY;\n+        }\n+        // And then quick validity check:\n+        if (input.charAt(0) != '/') {\n+            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"\n+                    +\"\\\"\"+input+\"\\\"\");\n+        }\n+        return _parseTail(input);\n+    }\n+\n+    /*\n+    \n+    /**\n+     * Factory method that composes a pointer instance, given a set\n+     * of 'raw' segments: raw meaning that no processing will be done,\n+     * no escaping may is present.\n+     * \n+     * @param segments\n+     * \n+     * @return Constructed path instance\n+     */\n+    /* TODO!\n+    public static JsonPointer fromSegment(String... segments)\n+    {\n+        if (segments.length == 0) {\n+            return EMPTY;\n+        }\n+        JsonPointer prev = null;\n+                \n+        for (String segment : segments) {\n+            JsonPointer next = new JsonPointer()\n+        }\n+    }\n+    */\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    public boolean matches() {\n+        return _nextSegment == null;\n+    }\n+    \n+    public String getMatchingProperty() {\n+        return _matchingPropertyName;\n+    }\n+\n+    public int getMatchingIndex() {\n+        return _matchingElementIndex;\n+    }\n+\n+    public boolean mayMatchProperty() {\n+        return _matchingPropertyName != null;\n+    }\n+\n+    public boolean mayMatchElement() {\n+        return _matchingElementIndex >= 0;\n+    }\n+\n+    public JsonPointer matchProperty(String name) {\n+        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n+            return null;\n+        }\n+        return _nextSegment;\n+    }\n+\n+    public JsonPointer matchElement (int index) {\n+        if ((index != _matchingElementIndex) || (index < 0)) {\n+            return null;\n+        }\n+        return _nextSegment;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard method overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString() {\n+        return _asString;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return _asString.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (!(o instanceof JsonPointer)) {\n+            return false;\n+        }\n+        return _asString.equals(((JsonPointer) o)._asString);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private final static int _parseInt(String str)\n+    {\n+        final int len = str.length();\n+        if (len == 0) {\n+            return -1;\n+        }\n+        for (int i = 0; i < len; ++i) {\n+            char c = str.charAt(i++);\n+            if (c > '9' || c < '0') {\n+                return -1;\n+            }\n+        }\n+        // for now, we'll assume 32-bit indexes are fine\n+        return NumberInput.parseInt(str);\n+    }\n+    \n+    protected static JsonPointer _parseTail(String input)\n+    {\n+        final int end = input.length();\n+\n+        // first char is the contextual slash, skip\n+        for (int i = 1; i < end; ++i) {\n+            char c = input.charAt(i++);\n+            if (c == '/') { // common case, got a segment\n+                return new JsonPointer(input, input.substring(1, i-1),\n+                        _parseTail(input.substring(i)));\n+            }\n+            // quoting is different; offline this case\n+            if (c == '~' && i < end) { // possibly, quote\n+                return _parseQuotedTail(input, i);\n+            }\n+            // otherwise, loop on\n+        }\n+        // end of the road, no escapes\n+        return new JsonPointer(input, input.substring(1), EMPTY);\n+    }\n+\n+    /**\n+     * Method called to parse tail of pointer path, when a potentially\n+     * escaped character has been seen.\n+     * \n+     * @param input Full input for the tail being parsed\n+     * @param i Offset to character after tilde\n+     */\n+    protected static JsonPointer _parseQuotedTail(String input, int i)\n+    {\n+        final int end = input.length();\n+        StringBuilder sb = new StringBuilder(Math.max(16, end));\n+        if (i > 2) {\n+            sb.append(input, 1, i-1);\n+        }\n+        _appendEscape(sb, input.charAt(i++));\n+        while (i < end) {\n+            char c = input.charAt(i++);\n+            if (c == '/') { // end is nigh!\n+                return new JsonPointer(input, sb.toString(),\n+                        _parseTail(input.substring(i)));\n+            }\n+            if (c == '~' && i < end) {\n+                _appendEscape(sb, c);\n+                continue;\n+            }\n+            sb.append(c);\n+        }\n+        // end of the road, last segment\n+        return new JsonPointer(input, sb.toString(), EMPTY);\n+    }\n+    \n+    private static void _appendEscape(StringBuilder sb, char c)\n+    {\n+        if (c == '0') {\n+            c = '~';\n+        } else if ( c == '1') {\n+            c = '/';\n+        } else {\n+            sb.append('~');\n+        }\n+        sb.append(c);\n+    }\n+}\n",
      "files_name_in_blame_commit": [
        "JsonPointer.java",
        "TreeNode.java",
        "JsonWriteContext.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 9
  }
}
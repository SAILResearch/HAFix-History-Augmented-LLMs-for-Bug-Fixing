{
  "id": "30",
  "blame_commit": {
    "commit": {
      "commit_id": "bd9c7b620384fe5a98772729001ed56304459bc6",
      "commit_message": "Add toMaybeFunctionType/toMaybeEnumElementType.\ntry #2. the bugs in jstestc were fixed. this cl is exactly\nthe same as the original\n\nR=johnlenz\nDELTA=317  (79 added, 47 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=3078\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1367 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "nicksantos@google.com",
      "commit_date": "2011-08-18 22:46:32",
      "commit_parent": "1e1ae5059abd0d42acca1ae0b47ab39c08ca3210"
    },
    "function": {
      "function_name": "visitNew",
      "function_code_before": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  FunctionType type = getFunctionType(constructor);\n  if (type != null && type.isConstructor()) {\n    visitParameterList(t, n, type);\n    ensureTyped(t, n, type.getInstanceType());\n  } else {\n    // TODO(user): add support for namespaced objects.\n    if (constructor.getType() != Token.GETPROP) {\n      // TODO(user): make the constructor node have lineno/charno\n      // and use constructor for a more precise error indication.\n      // It seems that GETPROP nodes are missing this information.\n      Node line;\n      if (constructor.getLineno() < 0 || constructor.getCharno() < 0) {\n        line = n;\n      } else {\n        line = constructor;\n      }\n      report(t, line, NOT_A_CONSTRUCTOR);\n    }\n    ensureTyped(t, n);\n  }\n}",
      "function_code_after": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    // TODO(user): add support for namespaced objects.\n    if (constructor.getType() != Token.GETPROP) {\n      // TODO(user): make the constructor node have lineno/charno\n      // and use constructor for a more precise error indication.\n      // It seems that GETPROP nodes are missing this information.\n      Node line;\n      if (constructor.getLineno() < 0 || constructor.getCharno() < 0) {\n        line = n;\n      } else {\n        line = constructor;\n      }\n      report(t, line, NOT_A_CONSTRUCTOR);\n    }\n    ensureTyped(t, n);\n  }\n}",
      "function_before_start_line": 1409,
      "function_before_end_line": 1431,
      "function_after_start_line": 1406,
      "function_after_end_line": 1433,
      "function_before_token_count": 130,
      "function_after_token_count": 169,
      "functions_name_modified_file": [
        "getTypedPercent",
        "visitGetProp",
        "visitGetElem",
        "doPercentTypedAccounting",
        "visitName",
        "visitObjLitKey",
        "visitCall",
        "visitAssign",
        "shouldTraverse",
        "checkEnumInitializer",
        "visitFunction",
        "process",
        "ensureTyped",
        "checkDeclaredPropertyInheritance",
        "visitInterfaceGetprop",
        "getNativeType",
        "visitVar",
        "checkPropertyAccess",
        "isPropertyTest",
        "visitBinaryOperator",
        "visit",
        "hasUnknownOrEmptySupertype",
        "visitParameterList",
        "check",
        "propertyIsImplicitCast",
        "checkInterfaceConflictProperties",
        "TypeCheck",
        "reportMissingProperties",
        "getJSType",
        "checkNoTypeCheckSection",
        "report",
        "visitReturn",
        "processForTesting",
        "visitAnnotatedAssignGetprop",
        "visitNew"
      ],
      "functions_name_all_files": [
        "maybeAliasNamesOnAssign",
        "getDeclaration",
        "handleTypeCycle",
        "isKnownLocalValue",
        "getExtendedInterfacesCount",
        "checkForStateChangeHelper",
        "recordPrototypePropUse",
        "explicitReturnExpected",
        "canBeCalled",
        "isStaticNameReference",
        "recordInterfaces",
        "caseUnionType",
        "getArgumentsVar",
        "hasMoreTagsToResolve",
        "printErrorLocations",
        "referencesThis",
        "fixFunctionType",
        "getOrCreateConstructor",
        "getSlot",
        "getConcreteInstance",
        "hasImplementedInterfaces",
        "resolveInternal",
        "isPropertyInExterns",
        "inferInheritance",
        "shouldUseFunctionLiteralType",
        "isCheckedUnknownType",
        "isNoResolvedType",
        "checkPropertyAccess",
        "getSource",
        "inferReturnType",
        "isBooleanResultHelper",
        "getSourceName",
        "expectAnyObject",
        "isValidDefineValue",
        "TypeInference",
        "isStatementBlock",
        "inferParameterTypes",
        "caseObjectType",
        "getBooleanOutcomes",
        "setIsCallFunction",
        "getParameterSlot",
        "isFunctionObjectApply",
        "apply",
        "mutatesThis",
        "reportMissingProperties",
        "hasNoSideEffectsAnnotation",
        "exitScope",
        "isLocalNameReference",
        "getCatchBlock",
        "resolveStubDeclarations",
        "isVarOrSimpleAssignLhs",
        "isNullOrUndefined",
        "getArgumentForFunction",
        "processForTesting",
        "getClassOfMethod",
        "isNominalType",
        "maybeCollectMember",
        "setDebugInformation",
        "clearCachedValues",
        "isAssociative",
        "PropertyOrders",
        "TypedCodeGenerator",
        "TypeFilter",
        "getConstructorType",
        "defineAndAlias",
        "getFunctionType",
        "inferTemplateTypeName",
        "hasOwnProperty",
        "isVarArgsFunction",
        "traverseCall",
        "addType",
        "setTaintsUnknown",
        "checkConstructorDeprecation",
        "reportError",
        "caseNameOrGetProp",
        "addConcreteType",
        "createInstanceScope",
        "getImplicitActionsFromProp",
        "caseTypeOf",
        "getCallSlot",
        "isEmptyFunction",
        "isArrayType",
        "getReturnSlot",
        "RestrictByTrueInstanceOfResultVisitor",
        "connectUnknowns",
        "caseIn",
        "handlePropertyExport",
        "dereferenceToObject",
        "getTypedefType",
        "mutatesGlobalState",
        "addParameter",
        "caseAndOrNotShortCircuiting",
        "FunctionInformation",
        "getPropertySlot",
        "callHasLocalResult",
        "getPrototypePropertyName",
        "getSourceFile",
        "NativeCallFunctionCall",
        "traverseArrayLiteral",
        "resolve",
        "defineCatch",
        "isEmptyBlock",
        "JSTypeSystem",
        "getPrototypeTypes",
        "getTopDefiningInterface",
        "pushContainingFunction",
        "isImmutableValue",
        "Var",
        "mismatch",
        "isControlStructure",
        "getInputName",
        "DiscoverEnumsAndTypedefs",
        "MatchNodeType",
        "getCount",
        "checkPropertyDeprecation",
        "getNameReferenceCount",
        "tightenTypesAfterAssertions",
        "createConcreteFunction",
        "doPercentTypedAccounting",
        "getGreatestSubtype",
        "trimJsWhiteSpace",
        "isReferenceName",
        "checkForTypedef",
        "meet",
        "supAndInfHelper",
        "fastAllPathsReturnCheck",
        "isExprCall",
        "getFirstParameter",
        "isResolved",
        "getTypesUnderShallowEquality",
        "isObjectLitKey",
        "traverseEdge",
        "expectCanCast",
        "isBooleanObjectType",
        "autoboxesTo",
        "traverseChildren",
        "Comparator<JSType>",
        "createConcreteInstance",
        "DeferredSetType",
        "Export",
        "getFunctionBody",
        "getBestLValueName",
        "reportWarning",
        "isLabelName",
        "getRootOfQualifiedName",
        "Arguments",
        "finishPropertyContinuations",
        "createForTypes",
        "getOwnPropertyJSDocInfo",
        "createTypeIntersection",
        "setTaintsThis",
        "identifyNameNode",
        "getScope",
        "testForEqualityHelper",
        "getObjectLitKeyName",
        "getOwnSlot",
        "getConcreteFunction",
        "ConcreteFunctionType",
        "handleGetProp",
        "toUnion",
        "EnumElementType",
        "getReferenceName",
        "isConst",
        "addTypeToSkip",
        "getPreciserScopeKnowingConditionOutcome",
        "getMinArguments",
        "ExternExportsPass",
        "getRootNode",
        "declareNativeFunctionType",
        "resolveViaRegistry",
        "hashCode",
        "isInstance",
        "getFunctionCallAssignments",
        "canBeSideEffected",
        "getLeastSupertype",
        "propagateSideEffects",
        "isThis",
        "visitAssign",
        "shouldRename",
        "getDebugReport",
        "restrictByNotNullOrUndefined",
        "applyDelegateRelationship",
        "getReferencedObjTypeInternal",
        "expectAllInterfaceProperties",
        "toMaybeUnionType",
        "isForward",
        "getMismatches",
        "getFunctionJSDocInfo",
        "getVar",
        "getParameters",
        "expectIndexMatch",
        "canAccessDeprecatedTypes",
        "defineSlot",
        "containsForwardDeclaredUnresolvedName",
        "isFunctionTypeDeclaration",
        "isSimpleOperator",
        "expectBitwiseable",
        "setReferencedAndResolvedType",
        "PropertyContinuation",
        "getFunctionParameters",
        "Driver",
        "handleObjectLit",
        "getParametersNode",
        "isTheObjectType",
        "safeResolve",
        "isGetOrSetKey",
        "getExportedPath",
        "createExternFunctionCall",
        "isString",
        "differsFrom",
        "getBoilerplateCode",
        "isStringValueType",
        "intersectWith",
        "addMarker",
        "report",
        "expectCanAssignToPropertyOf",
        "getParameterNodeJSDocType",
        "Scope",
        "getAssignedOuterLocalVars",
        "getAssignedValue",
        "getIndexType",
        "getStringValue",
        "declare",
        "getArgumentForCallOrNew",
        "isDeclared",
        "TightenTypes",
        "getPrimitiveType",
        "isLiteralValue",
        "redeclareVarsInsideBranch",
        "visitCall",
        "getImplicitActionsFromArgument",
        "getObjectSlot",
        "maybeAddFinally",
        "setImplementedInterfaces",
        "getParentScope",
        "getRestrictedTypeGivenToBooleanOutcome",
        "traverseName",
        "isNone",
        "isPrototypeMethodDefinition",
        "renameProperties",
        "isExpressionNode",
        "isName",
        "traverseWithinShortCircuitingBinOp",
        "getTypesToSkipForType",
        "isSymmetricOperation",
        "isBottom",
        "isReturnTypeInferred",
        "isOptionalParameter",
        "getDisplayName",
        "getTypesUnderEquality",
        "resolveViaProperties",
        "NoObjectType",
        "newFunctionNode",
        "hasCachedValues",
        "getArrayElementStringValue",
        "traverseAnd",
        "setType",
        "checkNameDeprecation",
        "setFunctionThrows",
        "toInstance",
        "ensurePropertyDeclared",
        "getReferencedTypeInternal",
        "setTaintsArguments",
        "isBooleanResult",
        "defineVar",
        "isNamedType",
        "getFunctionAnnotation",
        "computePathPrefixes",
        "addAction",
        "getAllSymbols",
        "isNoObjectType",
        "getTypeDeprecationInfo",
        "isNumericResultHelper",
        "isLocalValueType",
        "getScopeDeclaredIn",
        "getNodeTypeReferenceCount",
        "isIncDec",
        "isNumberObjectType",
        "NameUse",
        "getSuperclassType",
        "defineProperty",
        "newQualifiedNameNode",
        "getCtorImplementedInterfaces",
        "isFunctionPrototypeType",
        "isLatin",
        "checkEnumInitializer",
        "filterNoResolvedType",
        "isStringObjectType",
        "getJSDocInfo",
        "isFunctionType",
        "getCallsInFunctionBody",
        "mayHaveSideEffects",
        "applyCommonRestriction",
        "JSType",
        "isFunctionPrototype",
        "getOpFromAssignmentOp",
        "caseTopType",
        "createTypeWithSubTypes",
        "ConcreteUnionType",
        "formatFoundRequired",
        "isDeprecatedFunction",
        "isFunction",
        "caseUnknownType",
        "reportUnknownReturnType",
        "isForIn",
        "isControlStructureCodeBlock",
        "defineFunctionLiteral",
        "removeProperty",
        "TypePair",
        "getTypeRegistry",
        "setJSDocInfo",
        "isNumber",
        "Predicate<Node>",
        "isUndefined",
        "caseAndOrMaybeShortCircuiting",
        "expectNotNullOrUndefined",
        "add",
        "ProxyObjectType",
        "getName",
        "getAllExtendedInterfaces",
        "getSuperclassTypes",
        "isVar",
        "rewriteDefinitionIfEligible",
        "isPrototypeNameReference",
        "initForScopeRoot",
        "processObjectLitProperties",
        "Traversal",
        "getImpureBooleanValue",
        "recordSuperClassPrototypePropUse",
        "AddMarkers",
        "Function<TypePair,TypePair>",
        "getFunctionInstanceTypes",
        "canAssignTo",
        "setTaintsGlobalState",
        "getInstanceTypeWithProperty",
        "expectNumber",
        "forInterface",
        "setInstanceType",
        "inferReturnStatementsAsLastResort",
        "canTestForShallowEqualityWith",
        "handleUnresolvedType",
        "getTypesToSkipForTypeNonUnion",
        "forceResolve",
        "DisambiguateProperties",
        "flowThrough",
        "PropertyAssignAction",
        "build",
        "TypeMismatch",
        "getNamedContainingFunction",
        "isTryCatchNodeContainer",
        "getInputId",
        "enableSpecialization",
        "CreateScope",
        "expectString",
        "createScope",
        "recordPrototypePropDefinition",
        "PropertyOrdersFlowAnalysis",
        "maybeDeclareQualifiedName",
        "hasInstanceType",
        "undeclare",
        "isConstructor",
        "FunctionCall",
        "setShouldReport",
        "isVoidType",
        "expandTypesToSkip",
        "processProperty",
        "expectCanOverride",
        "initExportMethods",
        "AddChecks",
        "getDeclarativelyUnboundVarsWithoutTypes",
        "recordInvalidationError",
        "unionWith",
        "isEmptyType",
        "getSuperClassConstructor",
        "getJSTypeHashCode",
        "hotSwapScript",
        "expectActualObject",
        "isVarDeclaration",
        "markPureFunctionCalls",
        "addBoilerplateCode",
        "ExternFunctionCall",
        "nodeTypeMayHaveSideEffects",
        "ensurePropertyDeclaredHelper",
        "getInternalArrowType",
        "has",
        "canTestForEqualityWith",
        "createAssignmentActions",
        "isUnknownType",
        "isVarArgsParameter",
        "setExtendedInterfaces",
        "expectCanAssignTo",
        "resolveTypes",
        "isRelationalOperation",
        "copyAndAdd",
        "getPrototypeType",
        "isBooleanValueType",
        "getAllImplementedInterfaces",
        "traverseGetElem",
        "getInfoForNameNode",
        "handleSymbolExport",
        "isEligibleDefinition",
        "createCheckerNode",
        "normalizeClassType",
        "getType",
        "getFunctionScope",
        "getNode",
        "toDebugHashCodeString",
        "ConcreteSlot",
        "getParameterSlots",
        "visitAnnotatedAssignGetprop",
        "visitNew",
        "checkForFunctionsWithUnknownTypes",
        "isTryFinallyNode",
        "caseEquality",
        "createExternFunction",
        "isInterface",
        "containsName",
        "popContainingFunction",
        "findOverriddenFunction",
        "hasFinally",
        "toMaybeFunctionType",
        "expectSwitchMatchesCase",
        "ConcreteUniqueType",
        "matchesObjectContext",
        "visitObjLitKey",
        "getExtendedInterfaces",
        "expectArgumentMatchesParameter",
        "constructorCallHasSideEffects",
        "matchesUint32Context",
        "isValidPrivateConstructorAccess",
        "hasReferenceName",
        "isConstantName",
        "getBooleanOutcomePair",
        "checkEnumElementCycle",
        "patchGlobalScope",
        "setIsNewCall",
        "handleFunctionInputs",
        "getNativeType",
        "isRegexpType",
        "getAlternatives",
        "forJSTypeSystem",
        "getInstanceType",
        "isPropertyTest",
        "isInvalidatingType",
        "reportUnknownParameterType",
        "getOutcomeFlowScope",
        "isStrWhiteSpaceChar",
        "TypedScopeCreator",
        "addRelatedExtendedInterfaces",
        "check",
        "propertyIsImplicitCast",
        "hasProperty",
        "traverseShortCircuitingBinOp",
        "isEnumElementType",
        "getReturnType",
        "CheckPropertyOrder",
        "isExprAssign",
        "checkInvariant",
        "branchedFlowThrough",
        "getTopMostDefiningType",
        "isPropertyTypeInferred",
        "createInitialScope",
        "isEnumType",
        "getPropertySlots",
        "getTypedPercent",
        "isFunctionObjectCallOrApply",
        "visitGetElem",
        "getAssignments",
        "getThisSlot",
        "forConcreteTypeSystem",
        "visitName",
        "getVars",
        "getPrototype",
        "traverseHook",
        "AbstractScopeBuilder",
        "inferPropertyTypesToMatchConstraint",
        "setSourceNode",
        "shouldEmitDeprecationWarning",
        "safeAlias",
        "recordStaticNameDefinition",
        "RestrictByFalseInstanceOfResultVisitor",
        "isNumberValueType",
        "getInverseOperator",
        "reverse",
        "initForExternRoot",
        "declareArguments",
        "isSwitchCase",
        "newName",
        "getImplicitPrototype",
        "traverseAssign",
        "newCallNode",
        "getRewrittenMethodName",
        "isExtern",
        "createEnumTypeFromNodes",
        "Property",
        "maybeSetBaseType",
        "appendVarArgsString",
        "visitVar",
        "getNameNode",
        "getJoinedFlowScope",
        "isOrdinaryFunction",
        "checkConstructor",
        "isFunctionExpression",
        "equalsJSType",
        "visit",
        "getObjectLitKeyTypeFromValueType",
        "hasSideEffectsThisAnnotation",
        "getVarsDeclaredInBranch",
        "isValidPropertyName",
        "getTopScope",
        "traverseCatch",
        "inferThisType",
        "recordStaticNameUse",
        "isFunctionObjectCall",
        "getFunctions",
        "getTypesUnderShallowInequality",
        "LocalScopeBuilder",
        "traverseAdd",
        "tryMergeFunctionPiecewise",
        "getBestJSDocInfo",
        "isPrototypePropertyDeclaration",
        "blacklistLocal",
        "FunctionType",
        "isStatementParent",
        "updateScopeForTypeChange",
        "isWithinLoop",
        "isPropertyTypeDeclared",
        "isTemplateType",
        "isLoopStructure",
        "createFunctionScope",
        "arrayToString",
        "checkPropertyVisibility",
        "getInstances",
        "ensureTyped",
        "functionThrows",
        "StubDeclaration",
        "matchesStringContext",
        "getReferences",
        "hasSideEffectsArgumentsAnnotation",
        "visitInterfaceGetprop",
        "getTemplateTypeName",
        "isNoType",
        "getSymbol",
        "isDateType",
        "isArrayLiteral",
        "traverse",
        "expectStringOrNumber",
        "visitThrow",
        "caseInstanceOf",
        "InferJSDocInfo",
        "isAssign",
        "getImplementedInterfaces",
        "isInstanceType",
        "setSource",
        "commit",
        "getTypeAlternatives",
        "getNameReferenceGraph",
        "setResolvedTypeInternal",
        "toMaybeEnumElementType",
        "getInput",
        "getNearestFunctionName",
        "getDeclaredTypeInAnnotation",
        "getRootScope",
        "getGeneratedExterns",
        "isTypeInferred",
        "bothIntrinsics",
        "setDeferredType",
        "defineObjectLiteral",
        "newExpr",
        "isToStringMethodCall",
        "visitReturn",
        "mayBeString",
        "registerMismatch",
        "ensurePropertyDefined",
        "rewriteCallSites",
        "isEquivalentTo",
        "resolveType",
        "getOwnPropertyNames",
        "VariableAssignAction",
        "setReferencedType",
        "scheduleRenaming",
        "recordUnknownUse",
        "traverseGetProp",
        "registerIfMismatch",
        "createInitialEstimateLattice",
        "addTaintedLocalObject",
        "SymbolExport",
        "isNew",
        "getInstanceFromPrototype",
        "getTypeAnnotation",
        "expectObject",
        "visitFunction",
        "process",
        "newBooleanOutcomePair",
        "FunctionAnalyzer",
        "getPropertyNode",
        "isAssignmentOp",
        "redeclareSimpleVar",
        "checkConstantProperty",
        "assertDefinitionNode",
        "getProperty",
        "unboxesTo",
        "getMaxArguments",
        "getParameterType",
        "isNullType",
        "getBestLValue",
        "removeChild",
        "setIsPure",
        "getPropertyDeprecationInfo",
        "narrowScope",
        "getTypeOfThis",
        "getDebugHashCodeStringOf",
        "isFunctionDeclaration",
        "recordClassConstructorOrInterface",
        "getDepth",
        "isUnionType",
        "getConditionExpression",
        "checkNoTypeCheckSection",
        "clearResolved",
        "createFunctionTypeFromNodes",
        "checkNameVisibility",
        "NameReferenceGraphConstruction",
        "buildAndRegister",
        "isGetProp",
        "PropertyExport",
        "isStatement",
        "mayBePure",
        "lookupViaProperties",
        "setPropertyJSDocInfo",
        "toString",
        "addRelatedInterfaces",
        "isCallOrApply",
        "getCallThisObject",
        "getAddingRoot",
        "CheckAccessControls",
        "setPrototype",
        "addActions",
        "FunctionCallBuilder",
        "attachLiteralTypes",
        "testForEquality",
        "getNthSibling",
        "isObjectCallMethod",
        "getSlots",
        "valueCheck",
        "opToStr",
        "copyNameAnnotations",
        "isConstantByConvention",
        "newUndefinedNode",
        "Assignment",
        "ConcreteJSTypePair",
        "getFunctionValue",
        "buildPropNames",
        "containsType",
        "isSimpleFunctionObjectCall",
        "getTypes",
        "visitBinaryOperator",
        "resetLocalVars",
        "findNodeToInsertAfter",
        "hasCatchHandler",
        "getActions",
        "dereference",
        "visitParameterList",
        "hasEqualCallType",
        "containsFunction",
        "isSubtype",
        "isRecordType",
        "RuntimeTypeCheck",
        "TypeCheck",
        "TypeValidator",
        "inferConcreteType",
        "matchesInt32Context",
        "collectPropertyNames",
        "isCallOrNew",
        "appendCall",
        "NamedType",
        "visitGetProp",
        "getReadableJSTypeName",
        "getTypesUnderInequality",
        "createUnionWithSubTypes",
        "inferFromOverriddenFunction",
        "isNullable",
        "isCall",
        "getNumberValue",
        "jsCode",
        "getImplicitActionsFromPropNonUnion",
        "setTaintsReturn",
        "declareNativeValueType",
        "isAllType",
        "appendPathDefinition",
        "GlobalScopeBuilder",
        "getImplicitActionsFromCall",
        "addInvalidatingType",
        "recordSubclassPrototypePropUse",
        "isPropertyDeclaredConstant",
        "isHoistedFunctionDeclaration",
        "isEquivalent",
        "isNull",
        "isEmptyFunctionExpression",
        "traverseNew",
        "visitAssignmentOrUnaryOperator",
        "expectSuperType",
        "isGlobal",
        "evaluatesToLocalValue",
        "getImplicitActions",
        "getLoopCodeBlock",
        "generateExterns",
        "setPrototypeBasedOn",
        "getTypeWithProperty",
        "tryMergeBlock",
        "getCallableDefinitions",
        "updateTypeOfThisOnClosure",
        "SemanticReverseAbstractInterpreter",
        "isVoidOrUnknown",
        "getConstructor",
        "updateTypeOfParameters",
        "getOrders",
        "isClassDefiningCall",
        "traverseOr",
        "equals",
        "checkForClassDefiningCalls",
        "appendExtern",
        "ConcreteInstanceType",
        "getStringNumberValue",
        "getPrototypeClassName",
        "defineName",
        "getParent",
        "getParentNode",
        "getGlobalScope",
        "addSubType",
        "getPureBooleanValue",
        "matchesNumberContext",
        "getRenamedTypesForTesting",
        "opToStrNoFail",
        "rewriteDefinition",
        "FunctionTypeBuilder",
        "isPrototypeProperty",
        "getVarCount",
        "isSingleton",
        "getFunctionName",
        "getPropertiesCount",
        "getSubTypes",
        "isSimpleOperatorType",
        "isLValue",
        "isNumericResult",
        "ConcreteTypeSystem",
        "getReferencedType",
        "getPropertyType",
        "getInitialValue",
        "functionCallHasSideEffects",
        "checkInterfaceConflictProperties",
        "isCommutative",
        "getDeclaredType",
        "NodeUtil",
        "isTypeToSkip",
        "CheckMissingReturn",
        "createEntryLattice",
        "visitPreOrder",
        "declareNativeType",
        "mayEffectMutableState",
        "findPropertyType",
        "dereferencePointer",
        "toFunction",
        "findEnclosingConstructorDeclaration",
        "mayBeStringHelper",
        "visitPostOrder",
        "BooleanOutcomePair",
        "setValidator",
        "maybeRecordExport",
        "CollectProperties",
        "ConcreteScope",
        "isUnion",
        "expectUndeclaredVariable",
        "setPropName",
        "expectInterfaceProperty",
        "isDefine",
        "getParameterName",
        "createType",
        "getMatchingTypes",
        "PureFunctionIdentifier",
        "invalidate",
        "shouldTraverse",
        "isGet",
        "isNoShadow",
        "newVarNode",
        "checkDeclaredPropertyInheritance",
        "caseFunctionType",
        "isObject",
        "traverseObjectLiteral",
        "newHasLocalResult",
        "replaceReferencesToThis",
        "hasUnknownOrEmptySupertype",
        "maybeAddAutoboxes",
        "isBleedingFunction",
        "hasDisplayName",
        "declareSlot",
        "getJSDocInfoForFunction",
        "attachJSDocInfoToNominalTypeOrShape",
        "isAll",
        "getJSType",
        "isQnameRootedInGlobalScope",
        "toObjectType",
        "enterScope",
        "checkForCallingConventionDefiningCalls",
        "createCheckTypeCallNode",
        "precedence",
        "isNameReferenced",
        "containsCall",
        "MatchNameNode",
        "DevirtualizePrototypeMethods",
        "isLocal",
        "Predicate<Var>",
        "isAddedAsNumber"
      ],
      "functions_name_co_evolved_modified_file": [
        "visitCall",
        "visitAssign",
        "shouldTraverse",
        "getFunctionType",
        "visitFunction",
        "ensureTyped",
        "visitReturn",
        "visitNew"
      ],
      "functions_name_co_evolved_all_files": [
        "checkForFunctionsWithUnknownTypes",
        "isEquivalentTo",
        "getReadableJSTypeName",
        "explicitReturnExpected",
        "getFunctionType",
        "recordInterfaces",
        "createConcreteFunction",
        "findOverriddenFunction",
        "caseUnionType",
        "createType",
        "toMaybeFunctionType",
        "getGreatestSubtype",
        "traverseCall",
        "getImplicitActionsFromPropNonUnion",
        "supAndInfHelper",
        "visitCall",
        "getImplicitActionsFromArgument",
        "getImplicitActionsFromCall",
        "addInvalidatingType",
        "recordStaticNameDefinition",
        "fixFunctionType",
        "visitAssign",
        "shouldTraverse",
        "getTypeAnnotation",
        "visitFunction",
        "Scope",
        "declareArguments",
        "ensureTyped",
        "resolveInternal",
        "isFunctionType",
        "getTypesToSkipForType",
        "traverseNew",
        "applyCommonRestriction",
        "resolveViaProperties",
        "defineSlot",
        "visit",
        "maybeAddAutoboxes",
        "getObjectLitKeyTypeFromValueType",
        "caseInstanceOf",
        "createFunctionTypeFromNodes",
        "getTypeWithProperty",
        "updateTypeOfThisOnClosure",
        "caseObjectType",
        "updateTypeOfParameters",
        "getDeclaredType",
        "isSubtype",
        "normalizeClassType",
        "createScope",
        "attachJSDocInfoToNominalTypeOrShape",
        "inferThisType",
        "recordPrototypePropDefinition",
        "caseUnknownType",
        "getJSType",
        "getFunctionAnnotation",
        "maybeDeclareQualifiedName",
        "isEnumElementType",
        "toMaybeEnumElementType",
        "visitReturn",
        "registerMismatch",
        "getClassOfMethod",
        "visitNew"
      ]
    },
    "file": {
      "file_name": "TypeCheck.java",
      "file_nloc": 1309,
      "file_complexity": 371,
      "file_token_count": 8287,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -24,7 +24,6 @@ import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TY\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n@@ -428,9 +427,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     switch (n.getType()) {\n       case Token.FUNCTION:\n         // normal type checking\n-        final TypeCheck outerThis = this;\n         final Scope outerScope = t.getScope();\n-        final FunctionType functionType = (FunctionType) n.getJSType();\n         final String functionPrivateName = n.getFirstChild().getString();\n         if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n             outerScope.isDeclared(functionPrivateName, false) &&\n@@ -879,8 +876,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // object.prototype = ...;\n       if (property.equals(\"prototype\")) {\n-        if (objectJsType instanceof FunctionType) {\n-          FunctionType functionType = (FunctionType) objectJsType;\n+        if (objectJsType != null && objectJsType.isFunctionType()) {\n+          FunctionType functionType = objectJsType.toMaybeFunctionType();\n           if (functionType.isConstructor()) {\n             JSType rvalueType = rvalue.getJSType();\n             validator.expectObject(t, rvalue, rvalueType,\n@@ -898,9 +895,9 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n         String property2 = NodeUtil.getStringValue(object.getLastChild());\n \n         if (\"prototype\".equals(property2)) {\n-          JSType jsType = object2.getJSType();\n-          if (jsType instanceof FunctionType) {\n-            FunctionType functionType = (FunctionType) jsType;\n+          JSType jsType = getJSType(object2);\n+          if (jsType.isFunctionType()) {\n+            FunctionType functionType = jsType.toMaybeFunctionType();\n             if (functionType.isConstructor() || functionType.isInterface()) {\n               checkDeclaredPropertyInheritance(\n                   t, assign, functionType, property, info, getJSType(rvalue));\n@@ -1408,10 +1405,15 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    */\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n-    FunctionType type = getFunctionType(constructor);\n-    if (type != null && type.isConstructor()) {\n-      visitParameterList(t, n, type);\n-      ensureTyped(t, n, type.getInstanceType());\n+    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n+    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n+      FunctionType fnType = type.toMaybeFunctionType();\n+      if (fnType != null) {\n+        visitParameterList(t, n, fnType);\n+        ensureTyped(t, n, fnType.getInstanceType());\n+      } else {\n+        ensureTyped(t, n);\n+      }\n     } else {\n       // TODO(user): add support for namespaced objects.\n       if (constructor.getType() != Token.GETPROP) {\n@@ -1474,7 +1476,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * @param n The node being visited.\n    */\n   private void visitFunction(NodeTraversal t, Node n) {\n-    FunctionType functionType = (FunctionType) n.getJSType();\n+    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n     String functionPrivateName = n.getFirstChild().getString();\n     if (functionType.isConstructor()) {\n       FunctionType baseConstructor = functionType.\n@@ -1556,8 +1558,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n     // A couple of types can be called as if they were functions.\n     // If it is a function type, then validate parameters.\n-    if (childType instanceof FunctionType) {\n-      FunctionType functionType = (FunctionType) childType;\n+    if (childType.isFunctionType()) {\n+      FunctionType functionType = childType.toMaybeFunctionType();\n \n       boolean isExtern = false;\n       JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n@@ -1653,8 +1655,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     }\n     JSType jsType = getJSType(function);\n \n-    if (jsType instanceof FunctionType) {\n-      FunctionType functionType = (FunctionType) jsType;\n+    if (jsType.isFunctionType()) {\n+      FunctionType functionType = jsType.toMaybeFunctionType();\n \n       JSType returnType = functionType.getReturnType();\n \n@@ -1807,21 +1809,6 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     }\n   }\n \n-  /**\n-   * Gets the type of the node or {@code null} if the node's type is not a\n-   * function.\n-   */\n-  private FunctionType getFunctionType(Node n) {\n-    JSType type = getJSType(n).restrictByNotNullOrUndefined();\n-    if (type.isUnknownType()) {\n-      return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE);\n-    } else if (type instanceof FunctionType) {\n-      return (FunctionType) type;\n-    } else {\n-      return null;\n-    }\n-  }\n-\n   // TODO(nicksantos): TypeCheck should never be attaching types to nodes.\n   // All types should be attached by TypeInference. This is not true today\n   // for legacy reasons. There are a number of places where TypeInference\n@@ -1861,7 +1848,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n   private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n     // Make sure FUNCTION nodes always get function type.\n     Preconditions.checkState(n.getType() != Token.FUNCTION ||\n-            type instanceof FunctionType ||\n+            type.isFunctionType() ||\n             type.isUnknownType());\n     JSDocInfo info = n.getJSDocInfo();\n     if (info != null) {\n",
      "files_name_in_blame_commit": [
        "JSType.java",
        "SemanticReverseAbstractInterpreter.java",
        "InferJSDocInfo.java",
        "ExternExportsPass.java",
        "RuntimeTypeCheck.java",
        "CheckAccessControls.java",
        "DevirtualizePrototypeMethods.java",
        "TypeCheck.java",
        "TypedCodeGenerator.java",
        "FunctionType.java",
        "NameReferenceGraphConstruction.java",
        "EnumElementType.java",
        "FunctionTypeBuilder.java",
        "PureFunctionIdentifier.java",
        "DisambiguateProperties.java",
        "CheckMissingReturn.java",
        "Scope.java",
        "TightenTypes.java",
        "ConcreteType.java",
        "NoObjectType.java",
        "TypeValidator.java",
        "NodeUtil.java",
        "TypedScopeCreator.java",
        "TypeInference.java",
        "NamedType.java",
        "CheckPropertyOrder.java",
        "ProxyObjectType.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 116
  }
}
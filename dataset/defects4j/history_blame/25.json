{
  "id": "25",
  "blame_commit": {
    "commit": {
      "commit_id": "6a2378d43d1f06344f6418388d45c66fe3466a07",
      "commit_message": "Take advantage of the finer grain side-effect information when\ndetermining side-effects.\nThe bulk of the changes here are the move of the \"isKnownLocalValue\"\nfunction and its tests from to NodeUtil/NodeUtilTest.\n\nR=nicksantos\nDELTA=664  (419 added, 201 deleted, 44 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=260873\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@466 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "johnlenz@google.com",
      "commit_date": "2010-09-27 23:16:58",
      "commit_parent": "f95797059bdc7b6c4cfc4960081f0773ec85bbf8"
    },
    "function": {
      "function_name": "evaluatesToLocalValue",
      "function_code_before": "",
      "function_code_after": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // A result that is aliased by a non-local name, is the effectively the\n      // same as returning a non-local name, but this doesn't matter if the\n      // value is immutable.\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      // There is no information about the locality of object properties.\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value) || locals.apply(value);\n    case Token.NEW:\n      return true;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 2259,
      "function_after_end_line": 2319,
      "function_before_token_count": 0,
      "function_after_token_count": 330,
      "functions_name_modified_file": [
        "isGetProp",
        "isStatement",
        "isTryFinallyNode",
        "checkForStateChangeHelper",
        "getStringValue",
        "hasFinally",
        "isLiteralValue",
        "getAddingRoot",
        "referencesThis",
        "redeclareVarsInsideBranch",
        "constructorCallHasSideEffects",
        "isObjectCallMethod",
        "isConstantName",
        "opToStr",
        "isExpressionNode",
        "isName",
        "copyNameAnnotations",
        "newUndefinedNode",
        "isConstantByConvention",
        "containsType",
        "isSimpleFunctionObjectCall",
        "newFunctionNode",
        "hasCatchHandler",
        "getSourceName",
        "isValidDefineValue",
        "containsFunction",
        "isStatementBlock",
        "isFunctionObjectApply",
        "apply",
        "getCatchBlock",
        "isExprAssign",
        "getExpressionBooleanValue",
        "setDebugInformation",
        "getNodeTypeReferenceCount",
        "isAssociative",
        "getBooleanValue",
        "newQualifiedNameNode",
        "isVarArgsFunction",
        "isCall",
        "isLatin",
        "isLhs",
        "isHoistedFunctionDeclaration",
        "isSwitchCase",
        "newName",
        "newCallNode",
        "isEmptyFunctionExpression",
        "mayHaveSideEffects",
        "isFunctionExpression",
        "getOpFromAssignmentOp",
        "evaluatesToLocalValue",
        "visit",
        "getLoopCodeBlock",
        "tryMergeBlock",
        "getVarsDeclaredInBranch",
        "isValidPropertyName",
        "isFunction",
        "isForIn",
        "callHasLocalResult",
        "getPrototypePropertyName",
        "isControlStructureCodeBlock",
        "isFunctionObjectCall",
        "isEmptyBlock",
        "isPrototypePropertyDeclaration",
        "isImmutableValue",
        "isControlStructure",
        "MatchNodeType",
        "getPrototypeClassName",
        "getCount",
        "isWithinLoop",
        "getNameReferenceCount",
        "isVar",
        "isLoopStructure",
        "isReferenceName",
        "opToStrNoFail",
        "isExprCall",
        "isPrototypeProperty",
        "isObjectLitKey",
        "getFunctionName",
        "getFunctionInfo",
        "getFnParameters",
        "getFunctionBody",
        "isSimpleOperatorType",
        "isLabelName",
        "getRootOfQualifiedName",
        "isAssign",
        "functionCallHasSideEffects",
        "NodeUtil",
        "getNearestFunctionName",
        "visitPreOrder",
        "mayEffectMutableState",
        "newExpr",
        "visitPostOrder",
        "canBeSideEffected",
        "isNew",
        "isVarDeclaration",
        "isThis",
        "isGet",
        "nodeTypeMayHaveSideEffects",
        "has",
        "newVarNode",
        "isAssignmentOp",
        "isSimpleOperator",
        "getInfoForNameNode",
        "removeChild",
        "isFunctionDeclaration",
        "isString",
        "getConditionExpression",
        "precedence",
        "isNameReferenced",
        "containsCall",
        "MatchNameNode",
        "getAssignedValue"
      ],
      "functions_name_all_files": [
        "isKnownLocalValue",
        "checkForStateChangeHelper",
        "setReturnsTainted",
        "referencesThis",
        "cloneTree",
        "testAnnotationInExterns_new2",
        "addChildToFront",
        "isNoSideEffectsCall",
        "mergeLineCharNo",
        "setQuotedString",
        "testCallFunctionFOrGWithSideEffects",
        "assertBooleanFalse",
        "testNamespaceAnnotationInExterns5",
        "getSourceName",
        "isValidDefineValue",
        "isStatementBlock",
        "isFunctionObjectApply",
        "testSharedFunctionName1",
        "apply",
        "testAnnotationInExternStubs3",
        "mutatesThis",
        "hasNoSideEffectsAnnotation",
        "NumberNode",
        "exitScope",
        "testInference4",
        "getCatchBlock",
        "testRegExpSideEffect",
        "setDebugInformation",
        "isAssociative",
        "setLineno",
        "getBooleanValue",
        "testAnnotationInExterns1",
        "assertBooleanTrue",
        "testHookOperators4",
        "isVarArgsFunction",
        "setTaintsUnknown",
        "assertExpressionBooleanFalse",
        "putBooleanProp",
        "testRemoveTryChild",
        "testLocalizedSideEffects6",
        "getJsDocBuilderForNode",
        "testNewFunctionNode",
        "checkTreeTypeAwareEqualsImpl",
        "hasSideEffects",
        "testLocalizedSideEffects10",
        "testConstructorThatModifiesThis2",
        "testInvalidAnnotation1",
        "mutatesGlobalState",
        "isLocalResultCall",
        "testInvalidAnnotation5",
        "testAnnotationInExterns_new4",
        "FunctionInformation",
        "getPrototypePropertyName",
        "callHasLocalResult",
        "isEmptyBlock",
        "getNext",
        "toStringTree",
        "testConstructorAnnotationInExterns5",
        "isImmutableValue",
        "testCallFunctionForGorH",
        "isControlStructure",
        "MatchNodeType",
        "getCount",
        "tokenToName",
        "assertBooleanUnknown",
        "getNameReferenceCount",
        "testAnnotationInExterns2",
        "isReferenceName",
        "isExprCall",
        "testHookOperator2",
        "isObjectLitKey",
        "traverseEdge",
        "getSortedPropTypes",
        "PropListItem",
        "getFunctionBody",
        "isLabelName",
        "testInference1",
        "getRootOfQualifiedName",
        "hasChildren",
        "testIsLabelName",
        "getFuncChild",
        "removeFlag",
        "setTaintsThis",
        "getCharno",
        "testAnnotationInExternStubs1",
        "checkTreeEquals",
        "toStringTreeImpl",
        "testAndOperator2",
        "hashCode",
        "testGetNodeTypeReferenceCount",
        "testConstructorThatModifiesGlobal2",
        "canBeSideEffected",
        "checkTreeEqualsImpl",
        "setMutatesThis",
        "propagateSideEffects",
        "isThis",
        "getDebugReport",
        "testGetVarsDeclaredInBranch",
        "testCallBeforeDefinition",
        "getDirectives",
        "isSimpleOperator",
        "testInference2",
        "Driver",
        "isUnscopedQualifiedName",
        "isString",
        "testAnonymousFunction1",
        "assertLiteralAndImmutable",
        "testAnonymousFunction4",
        "getAssignedValue",
        "getStringValue",
        "addChildToBack",
        "toStringTreeHelper",
        "testHookOperator3",
        "testConstructorAnnotationInExterns4",
        "areBitFlagsSet",
        "isLiteralValue",
        "testGetFunctionName",
        "redeclareVarsInsideBranch",
        "visitCall",
        "testIsNameReferenceCount",
        "testInvalidAnnotation2",
        "isExpressionNode",
        "isName",
        "hasNext",
        "testConstructorAnnotationInExterns1",
        "testLocalizedSideEffects4",
        "testExternCalls",
        "newFunctionNode",
        "setType",
        "setFunctionThrows",
        "getChildAtIndex",
        "testOrOperators4",
        "setTaintsArguments",
        "isOptionalArg",
        "testGetNameReferenceCount",
        "remove",
        "tearDown",
        "getNodeTypeReferenceCount",
        "isIncDec",
        "newQualifiedNameNode",
        "getSideEffectFlags",
        "testIsFunctionExpression",
        "lookupProperty",
        "testAnnotationInExterns3",
        "isLatin",
        "removeChildren",
        "findParentOfFuncDescendant",
        "testAnnotationInExterns_new7",
        "getJSDocInfo",
        "getCallsInFunctionBody",
        "mayHaveSideEffects",
        "getNodeClass",
        "testRemoveLabelChild2",
        "testGetFunctionName5",
        "getOpFromAssignmentOp",
        "putProp",
        "clearSideEffectFlags",
        "testHookOperator1",
        "isFunction",
        "isForIn",
        "isControlStructureCodeBlock",
        "setIsSyntheticBlock",
        "setThrows",
        "testCallRegExpWithSideEffects",
        "setJSDocInfo",
        "generateNameString",
        "testUnaryOperators3",
        "isVar",
        "addChildBefore",
        "testRemoveVarChild",
        "copyInformationFromForTree",
        "assertSideEffect",
        "testInference6",
        "setTaintsGlobalState",
        "testUnaryOperators1",
        "testInference5",
        "putIntProp",
        "testMayEffectMutableState",
        "testThrow1",
        "newString",
        "testGetStringValue",
        "testUnaryOperators2",
        "testAndOperator3",
        "testAnnotationInExterns_new3",
        "testLocalizedSideEffects5",
        "SiblingNodeIterable",
        "testResultLocalitySimple",
        "addChildrenToBack",
        "isVarDeclaration",
        "markPureFunctionCalls",
        "removeChildAfter",
        "nodeTypeMayHaveSideEffects",
        "has",
        "assertContainsAnonFunc",
        "setCharno",
        "testAnnotationInExterns_new10",
        "newNumber",
        "testInvalidAnnotation3",
        "getInfoForNameNode",
        "testConstructorAnnotationInExterns6",
        "getType",
        "wasEmptyNode",
        "testAnonymousFunction3",
        "getNode",
        "setAllFlags",
        "isTryFinallyNode",
        "valueOf",
        "hasFinally",
        "testNamespaceAnnotationInExterns4",
        "constructorCallHasSideEffects",
        "testLocalValue",
        "isConstantName",
        "setMutatesArguments",
        "testAnnotationInExterns5",
        "testConstructorThatModifiesThis3",
        "testGetFunctionName2",
        "replaceChild",
        "assertExpressionBooleanTrue",
        "testRemoveForChild",
        "setDirectives",
        "setMutatesGlobalState",
        "isSyntheticBlock",
        "testMergeBlock3",
        "setJSType",
        "next",
        "testThrow2",
        "isExprAssign",
        "checkInvariant",
        "getExpressionBooleanValue",
        "testApply",
        "propToString",
        "getLineno",
        "testGetBooleanValue",
        "getChildCount",
        "testAndOperator1",
        "assertNodeNames",
        "hasChild",
        "setSideEffectFlags",
        "isSwitchCase",
        "hasOneChild",
        "newName",
        "newCallNode",
        "isExtern",
        "getExistingIntProp",
        "isQuotedString",
        "isFunctionExpression",
        "visit",
        "setDouble",
        "hasSideEffectsThisAnnotation",
        "getVarsDeclaredInBranch",
        "isValidPropertyName",
        "testNamespaceAnnotationInExterns1",
        "testUnaryOperators4",
        "assertExpressionBooleanUnknown",
        "isFunctionObjectCall",
        "setOptionalArg",
        "isPrototypePropertyDeclaration",
        "blacklistLocal",
        "isWithinLoop",
        "assertNotLiteral",
        "testReferencesThis",
        "addSuppression",
        "clonePropsFrom",
        "isLoopStructure",
        "testAnnotationInExternStubs5",
        "isVarArgs",
        "getChildBefore",
        "getFunctionInfo",
        "getProp",
        "testGetExpressionBooleanValue",
        "functionThrows",
        "testLocalValue1",
        "testLocalizedSideEffects3",
        "setWasEmptyNode",
        "hasSideEffectsArgumentsAnnotation",
        "isOnlyModifiesThisCall",
        "cloneNode",
        "extractLineno",
        "testGetFunctionName1",
        "testAnnotationInExterns4",
        "testGetFunctionName3",
        "testLocalizedSideEffects9",
        "visitThrow",
        "testAnnotationInExternStubs4",
        "getString",
        "isAssign",
        "testAnnotationInExternStubs2b",
        "getNearestFunctionName",
        "testSharedFunctionName2",
        "siblings",
        "newExpr",
        "removeFirstChild",
        "getProcessor",
        "checkMarkedCalls",
        "testLocalizedSideEffects7",
        "isEquivalentTo",
        "addTaintedLocalObject",
        "isNew",
        "testLocalizedSideEffects8",
        "testNamespaceAnnotationInExterns2",
        "visitFunction",
        "process",
        "testAnnotationInExterns_new5",
        "getNumRepetitions",
        "setVarArgs",
        "FunctionAnalyzer",
        "testConstructorThatModifiesGlobal1",
        "isAssignmentOp",
        "testNoSideEffectsSimple",
        "testConstructorAnnotationInExterns8",
        "testUnaryOperators5",
        "extractCharno",
        "removeChild",
        "setIsPure",
        "testIsControlStructureCodeBlock",
        "testIsFunctionExpression1",
        "isFunctionDeclaration",
        "addChildrenToFront",
        "isQualifiedName",
        "getConditionExpression",
        "NoSideEffectCallEnumerator",
        "testCallFunctionThatModifiesThis",
        "isGetProp",
        "isStatement",
        "replaceChildAfter",
        "mayBePure",
        "getQualifiedName",
        "testMayHaveSideEffects",
        "toString",
        "testContainsFunctionDeclaration",
        "isCallOrApply",
        "getCallThisObject",
        "getAddingRoot",
        "testDeleteOperator1",
        "hasMoreThanOneChild",
        "isObjectCallMethod",
        "testOrOperator1",
        "opToStr",
        "copyNameAnnotations",
        "isConstantByConvention",
        "newUndefinedNode",
        "testRemoveLabelChild1",
        "appendStringTree",
        "testCallFunctionFOrGViaHookWithSideEffects",
        "containsType",
        "isSimpleFunctionObjectCall",
        "AncestorIterable",
        "testContainsType",
        "testOrOperator3",
        "resetLocalVars",
        "hasCatchHandler",
        "testAnnotationInExterns_new8",
        "containsFunction",
        "testConstructorThatModifiesThis1",
        "setString",
        "testConstructorThatModifiesThis4",
        "appendCall",
        "checkTreeTypeAwareEqualsSilent",
        "getAncestor",
        "testInference3",
        "getAncestors",
        "isCall",
        "testIsFunctionExpression2",
        "setTaintsReturn",
        "detachFromParent",
        "PureFunctionIdentifierTest",
        "testConstructorAnnotationInExterns3",
        "isLhs",
        "testAnnotationInExternStubs1b",
        "isHoistedFunctionDeclaration",
        "getFirstChild",
        "getBooleanProp",
        "testDeleteOperator2",
        "isEmptyFunctionExpression",
        "testCallFunctionFOrG",
        "visitAssignmentOrUnaryOperator",
        "evaluatesToLocalValue",
        "getLoopCodeBlock",
        "assertMutableState",
        "getCallableDefinitions",
        "tryMergeBlock",
        "testNamespaceAnnotationInExterns3",
        "testLocalizedSideEffects2",
        "equals",
        "getIntProp",
        "testAnonymousFunction2",
        "addChildAfter",
        "testConstructorAnnotationInExterns7",
        "getPrototypeClassName",
        "getParent",
        "testInheritance2",
        "checkTreeEqualsSilent",
        "opToStrNoFail",
        "StringNode",
        "isPrototypeProperty",
        "detachChildren",
        "testAssignmentOverride",
        "append",
        "getFunctionName",
        "copyInformationFrom",
        "NodeMismatch",
        "assertLiteralButNotImmutable",
        "getFnParameters",
        "isSimpleOperatorType",
        "testAnnotationInExterns_new6",
        "getLastChild",
        "testGetSourceName",
        "testIsLiteralOrConstValue",
        "testInheritance1",
        "checkLocalityOfMarkedCalls",
        "iterator",
        "testAnnotationInExterns_new9",
        "functionCallHasSideEffects",
        "getDouble",
        "testConstructorAnnotationInExterns2",
        "NodeUtil",
        "children",
        "visitPreOrder",
        "mayEffectMutableState",
        "testMergeBlock2",
        "testAnnotationInExternStubs2",
        "visitPostOrder",
        "testGetFunctionName4",
        "testAnnotationInExterns_new1",
        "testMergeBlock1",
        "SideEffectFlags",
        "PureFunctionIdentifier",
        "isGet",
        "shouldTraverse",
        "clearAllFlags",
        "testInvalidAnnotation4",
        "areAllFlagsSet",
        "newVarNode",
        "parse",
        "testAndOperators4",
        "testCall",
        "testLocalizedSideEffects1",
        "removeProp",
        "getLastSibling",
        "testOrOperator2",
        "getJSDocInfoForFunction",
        "getJSType",
        "testCallFunctionFOrGViaHook",
        "Node",
        "enterScope",
        "precedence",
        "isNameReferenced",
        "containsCall",
        "MatchNameNode",
        "testNamespaceAnnotationInExterns6"
      ],
      "functions_name_co_evolved_modified_file": [
        "functionCallHasSideEffects",
        "checkForStateChangeHelper",
        "evaluatesToLocalValue"
      ],
      "functions_name_co_evolved_all_files": [
        "isKnownLocalValue",
        "testMayHaveSideEffects",
        "checkForStateChangeHelper",
        "setReturnsTainted",
        "valueOf",
        "markPureFunctionCalls",
        "setMutatesThis",
        "SideEffectFlags",
        "clearAllFlags",
        "traverseEdge",
        "testLocalValue",
        "areAllFlagsSet",
        "setSideEffectFlags",
        "visitFunction",
        "testLocalValue1",
        "testGetExpressionBooleanValue",
        "setMutatesArguments",
        "isOnlyModifiesThisCall",
        "testAnnotationInExterns_new6",
        "visitAssignmentOrUnaryOperator",
        "evaluatesToLocalValue",
        "visit",
        "clearSideEffectFlags",
        "removeFlag",
        "setMutatesGlobalState",
        "functionCallHasSideEffects",
        "testAnnotationInExterns_new4",
        "setThrows",
        "setAllFlags"
      ]
    },
    "file": {
      "file_name": "NodeUtil.java",
      "file_nloc": 1396,
      "file_complexity": 614,
      "file_token_count": 8924,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -530,6 +530,11 @@ public final class NodeUtil {\n         }\n \n         if (isAssignmentOp(n)) {\n+          Node assignTarget = n.getFirstChild();\n+          if (isName(assignTarget)) {\n+            return true;\n+          }\n+\n           // Assignments will have side effects if\n           // a) The RHS has side effects, or\n           // b) The LHS has side effects, or\n@@ -541,13 +546,32 @@ public final class NodeUtil {\n             return true;\n           }\n \n-          Node current = n.getFirstChild();\n-          for (;\n-               current.getType() == Token.GETPROP ||\n-               current.getType() == Token.GETELEM;\n-               current = current.getFirstChild()) { }\n-\n-          return !isLiteralValue(current, true);\n+          if (isGet(assignTarget)) {\n+            // If the object being assigned to is a local object, don't\n+            // consider this a side-effect as it can't be referenced\n+            // elsewhere.  Don't do this recursively as the property might\n+            // be an alias of another object, unlike a literal below.\n+            Node current = assignTarget.getFirstChild();\n+            if (evaluatesToLocalValue(current)) {\n+              return false;\n+            }\n+\n+            // A literal value as defined by \"isLiteralValue\" is guaranteed\n+            // not to be an alias, or any components which are aliases of\n+            // other objects.\n+            // If the root object is a literal don't consider this a\n+            // side-effect.\n+            while (isGet(current)) {\n+              current = current.getFirstChild();\n+            }\n+\n+            return !isLiteralValue(current, true);\n+          } else {\n+            // TODO(johnlenz): remove this code and make this an exception. This\n+            // is here only for legacy reasons, the AST is not valid but\n+            // preserve existing behavior.\n+            return !isLiteralValue(assignTarget, true);\n+          }\n         }\n \n         return true;\n@@ -637,6 +661,11 @@ public final class NodeUtil {\n         return false;\n       }\n     } else if (nameNode.getType() == Token.GETPROP) {\n+      if (callNode.isOnlyModifiesThisCall()\n+          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n+        return false;\n+      }\n+\n       // Functions in the \"Math\" namespace have no side effects.\n       if (nameNode.getFirstChild().getType() == Token.NAME) {\n         String namespaceName = nameNode.getFirstChild().getString();\n@@ -2213,4 +2242,79 @@ public final class NodeUtil {\n     }\n     return call;\n   }\n+\n+  /**\n+   * @return Whether the node is known to be a value that is not referenced\n+   * elsewhere.\n+   */\n+  static boolean evaluatesToLocalValue(Node value) {\n+    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());\n+  }\n+\n+  /**\n+   * @param locals A predicate to apply to unknown local values.\n+   * @return Whether the node is known to be a value that is not a reference\n+   *     outside the expression scope.\n+   */\n+  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch (value.getType()) {\n+      case Token.ASSIGN:\n+        // A result that is aliased by a non-local name, is the effectively the\n+        // same as returning a non-local name, but this doesn't matter if the\n+        // value is immutable.\n+        return NodeUtil.isImmutableValue(value.getLastChild())\n+            || (locals.apply(value)\n+                && evaluatesToLocalValue(value.getLastChild(), locals));\n+      case Token.COMMA:\n+        return evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.AND:\n+      case Token.OR:\n+        return evaluatesToLocalValue(value.getFirstChild(), locals)\n+           && evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.HOOK:\n+        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n+           && evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.INC:\n+      case Token.DEC:\n+        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+          return evaluatesToLocalValue(value.getFirstChild(), locals);\n+        } else {\n+          return true;\n+        }\n+      case Token.THIS:\n+        return locals.apply(value);\n+      case Token.NAME:\n+        return isImmutableValue(value) || locals.apply(value);\n+      case Token.GETELEM:\n+      case Token.GETPROP:\n+        // There is no information about the locality of object properties.\n+        return locals.apply(value);\n+      case Token.CALL:\n+        return callHasLocalResult(value) || locals.apply(value);\n+      case Token.NEW:\n+        return true;\n+      case Token.FUNCTION:\n+      case Token.REGEXP:\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+        // Literals objects with non-literal children are allowed.\n+        return true;\n+      case Token.IN:\n+        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n+        return true;\n+      default:\n+        // Other op force a local value:\n+        //  x = '' + g (x is now an local string)\n+        //  x -= g (x is now an local number)\n+        if (isAssignmentOp(value)\n+            || isSimpleOperator(value)\n+            || isImmutableValue(value)) {\n+          return true;\n+        }\n+\n+        throw new IllegalStateException(\n+            \"Unexpected expression node\" + value +\n+            \"\\n parent:\" + value.getParent());\n+    }\n+  }\n }\n",
      "files_name_in_blame_commit": [
        "PureFunctionIdentifierTest.java",
        "PureFunctionIdentifier.java",
        "NodeUtilTest.java",
        "Node.java",
        "NodeUtil.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 59
  }
}
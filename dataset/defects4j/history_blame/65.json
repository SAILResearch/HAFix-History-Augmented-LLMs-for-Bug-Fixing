{
  "id": "65",
  "blame_commit": {
    "commit": {
      "commit_id": "f7df7b6f2ea22f97081bf8127f1fc39325a4fcde",
      "commit_message": "More creator-handling refactoring...",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2017-09-21 23:22:28",
      "commit_parent": "e1360656535ebd5868a25d57e05e0c500f4cfb0e"
    },
    "function": {
      "function_name": "_addExplicitAnyCreator",
      "function_code_before": "",
      "function_code_after": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n    if (1 != candidate.paramCount()) {\n        // Ok: for delegates, we want one and exactly one parameter without\n        // injection AND  without name\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            // getting close; but most not have name\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n    // If there's injection or explicit name, should be properties-based\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n        // One more thing: if implicit name matches property with a getter\n        // or field, we'll consider it property-based as well\n        paramName = candidate.findImplicitParamName(0);\n        useProps = (paramName != null) && paramDef.couldSerialize();\n    }\n    if (useProps) {\n        SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n        };\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n    // one more thing: sever link to creator property, to avoid possible later\n    // problems with \"unresolved\" constructor property\n    if (paramDef != null) {\n        ((POJOPropertyBuilder) paramDef).removeConstructors();\n    }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 664,
      "function_after_end_line": 711,
      "function_before_token_count": 0,
      "function_after_token_count": 262,
      "functions_name_modified_file": [
        "_mapAbstractCollectionType",
        "_findCustomEnumDeserializer",
        "resolveType",
        "findOptionalStdDeserializer",
        "_handleSingleArgumentCreator",
        "createReferenceDeserializer",
        "createMapLikeDeserializer",
        "BasicDeserializerFactory",
        "_findCustomReferenceDeserializer",
        "getFactoryConfig",
        "withDeserializerModifier",
        "createMapDeserializer",
        "_findRemappedType",
        "_findCustomMapDeserializer",
        "_findCustomArrayDeserializer",
        "findContentDeserializerFromAnnotation",
        "createCollectionLikeDeserializer",
        "_findCustomMapLikeDeserializer",
        "modifyTypeByAnnotation",
        "_findCustomCollectionDeserializer",
        "_mapAbstractType2",
        "_addExplicitAnyCreator",
        "_addDeserializerConstructors",
        "_addDeserializerFactoryMethods",
        "withAdditionalKeyDeserializers",
        "_addExplicitDelegatingCreator",
        "constructCreatorProperty",
        "findPropertyContentTypeDeserializer",
        "_findCustomCollectionLikeDeserializer",
        "withAdditionalDeserializers",
        "_findStdValueInstantiator",
        "_createEnumKeyDeserializer",
        "_constructDefaultValueInstantiator",
        "withAbstractTypeResolver",
        "_findCustomTreeNodeDeserializer",
        "_checkImplicitlyNamedConstructors",
        "_findParamName",
        "_checkIfCreatorPropertyBased",
        "createKeyDeserializer",
        "createArrayDeserializer",
        "createEnumDeserializer",
        "findKeyDeserializerFromAnnotation",
        "constructEnumResolver",
        "_findJsonValueFor",
        "withValueInstantiators",
        "_addExplicitPropertyCreator",
        "_findCreatorsFromProperties",
        "_hasCreatorAnnotation",
        "findTypeDeserializer",
        "_valueInstantiatorInstance",
        "findDeserializerFromAnnotation",
        "createTreeDeserializer",
        "createCollectionDeserializer",
        "_reportUnwrappedCreatorProperty",
        "findDefaultDeserializer",
        "resolveMemberAndTypeAnnotations",
        "mapAbstractType",
        "findPropertyTypeDeserializer",
        "findValueInstantiator",
        "_findCustomBeanDeserializer"
      ],
      "functions_name_all_files": [
        "_findCustomEnumDeserializer",
        "toString",
        "findOptionalStdDeserializer",
        "findBackReferenceProperties",
        "_handleSingleArgumentCreator",
        "_createConverter",
        "valueOf",
        "getFactoryConfig",
        "createMapDeserializer",
        "BrokenBean",
        "BooleanConstructorBean",
        "CreatorBean",
        "findContentDeserializerFromAnnotation",
        "modifyTypeByAnnotation",
        "setC",
        "findProperty",
        "findAnyGetter",
        "_addDeserializerFactoryMethods",
        "testLongFactory",
        "testFactoryCreatorWithMixin",
        "_findCustomCollectionLikeDeserializer",
        "testTwoInjectablesViaCreator",
        "testSimpleFactory",
        "testDeferredFactoryAndProps",
        "_checkImplicitlyNamedConstructors",
        "NoArgFactoryBean",
        "hasProperty",
        "getConstructors",
        "testMapWithConstructor",
        "findKeyDeserializerFromAnnotation",
        "constructEnumResolver",
        "withValueInstantiators",
        "_addExplicitPropertyCreator",
        "_hasCreatorAnnotation",
        "findPOJOBuilder",
        "Param",
        "testStringFactoryAlt",
        "addProperty",
        "findSingleArgConstructor",
        "_mapAbstractCollectionType",
        "setPropA",
        "testFactoryCreatorWithRenamingMixin",
        "getClassInfo",
        "FactoryBean",
        "createReferenceDeserializer",
        "createIt",
        "findFactoryMethod",
        "MapWithFactory",
        "_findRemappedType",
        "_findCustomMapDeserializer",
        "setB",
        "testSimple",
        "testMapWithFactory",
        "testTransientField",
        "CreatorCandidate",
        "findExpectedFormat",
        "_addExplicitAnyCreator",
        "_findPropertyFields",
        "findAnySetterAccessor",
        "testWithCtors",
        "withAdditionalDeserializers",
        "_findStdValueInstantiator",
        "testIssue471",
        "_constructDefaultValueInstantiator",
        "instantiateBean",
        "_findCustomTreeNodeDeserializer",
        "findBackReferences",
        "hasFullName",
        "CtorBean",
        "Bean471",
        "findClassDescription",
        "setMethodInjected",
        "testSimpleBooleanConstructor",
        "_findJsonValueFor",
        "findTypeDeserializer",
        "getFactoryMethods",
        "getClassAnnotations",
        "findPropertyInclusion",
        "removeProperty",
        "createCollectionDeserializer",
        "bindingsForBeanType",
        "resolveMemberAndTypeAnnotations",
        "BooleanConstructorBean2",
        "setMethodValue",
        "paramName",
        "FactoryAndPropsBean",
        "ConstructorAndPropsBean",
        "createMapLikeDeserializer",
        "creator",
        "hasKnownClassAnnotations",
        "_findCustomReferenceDeserializer",
        "testBrokenConstructor",
        "getObjectIdInfo",
        "setPropB",
        "_findCustomArrayDeserializer",
        "testConstructorCreator",
        "createCollectionLikeDeserializer",
        "_findCustomMapLikeDeserializer",
        "testMultipleCreators",
        "_mapAbstractType2",
        "create",
        "forDeserialization",
        "MixIn",
        "MapWithCtor",
        "_createEnumKeyDeserializer",
        "DoubleConstructorBean",
        "setProp",
        "BasicBeanDescription",
        "ConstructorBean",
        "withAbstractTypeResolver",
        "forSerialization",
        "_checkIfCreatorPropertyBased",
        "CtorBean2",
        "createEnumDeserializer",
        "testConstructorAndProps",
        "_valueInstantiatorInstance",
        "findDeserializerFromAnnotation",
        "MultiBean",
        "createKeyDeserializer",
        "mapAbstractType",
        "findPropertyTypeDeserializer",
        "findValueInstantiator",
        "forOtherUse",
        "_findCustomBeanDeserializer",
        "getIgnoredPropertyNames",
        "parameter",
        "resolveType",
        "testFactoryAndProps",
        "_properties",
        "DeferredConstructorAndPropsBean",
        "testSimpleDoubleConstructor",
        "findJsonValueMethod",
        "paramCount",
        "BasicDeserializerFactory",
        "fullName",
        "withDeserializerModifier",
        "testSimpleConstructor",
        "injectThird",
        "findJsonValueAccessor",
        "findDefaultViews",
        "_addDeserializerConstructors",
        "findProperties",
        "findImplicitParamName",
        "construct",
        "findDefaultConstructor",
        "DeferredFactoryAndPropsBean",
        "withAdditionalKeyDeserializers",
        "_addExplicitDelegatingCreator",
        "constructCreatorProperty",
        "findPropertyContentTypeDeserializer",
        "isFactoryMethod",
        "fromString",
        "_findParamName",
        "findSerializationConverter",
        "findDeserializationConverter",
        "createArrayDeserializer",
        "findPOJOBuilderConfig",
        "LongFactoryBean",
        "FromStringBean",
        "_findCreatorsFromProperties",
        "injection",
        "buildMeUpButterCup",
        "propertyDef",
        "_findCreatorPropertyName",
        "StringFactoryBean",
        "testNoArgsFactory",
        "explicitParamName",
        "createTreeDeserializer",
        "findOnlyParamWithoutInjection",
        "_reportUnwrappedCreatorProperty",
        "findDefaultDeserializer",
        "findInjectables",
        "testStringFactory",
        "_findCustomCollectionDeserializer",
        "findMethod",
        "testDeferredConstructorAndProps"
      ],
      "functions_name_co_evolved_modified_file": [
        "_handleSingleArgumentFactory",
        "_addExplicitDelegatingCreator",
        "_addExplicitPropertyCreator",
        "_findCreatorsFromProperties",
        "_addAnyCreator",
        "_addPropertyCreator",
        "_handleSingleArgumentCreator",
        "_handleSingleArgumentConstructor",
        "_findImplicitParamName",
        "_addDelegatingCreator",
        "_addExplicitAnyCreator",
        "_checkImplicitlyNamedConstructors",
        "_addDeserializerFactoryMethods",
        "_findParamName",
        "_addDeserializerConstructors",
        "_checkIfCreatorPropertyBased"
      ],
      "functions_name_co_evolved_all_files": [
        "_handleSingleArgumentFactory",
        "parameter",
        "toString",
        "_handleSingleArgumentCreator",
        "creator",
        "fullName",
        "paramCount",
        "testBrokenConstructor",
        "_addAnyCreator",
        "IssueGH471Bean",
        "_addDelegatingCreator",
        "CreatorCandidate",
        "testIssueGH471",
        "_addExplicitAnyCreator",
        "_addDeserializerConstructors",
        "_addDeserializerFactoryMethods",
        "findImplicitParamName",
        "construct",
        "_addExplicitDelegatingCreator",
        "testIssue471",
        "isFactoryMethod",
        "_findImplicitParamName",
        "Bean471",
        "_checkImplicitlyNamedConstructors",
        "hasFullName",
        "_handleSingleArgumentConstructor",
        "_findParamName",
        "_checkIfCreatorPropertyBased",
        "_addExplicitPropertyCreator",
        "_findCreatorsFromProperties",
        "injection",
        "Param",
        "propertyDef",
        "getFactoryMethods",
        "_addPropertyCreator",
        "explicitParamName",
        "findOnlyParamWithoutInjection",
        "paramName"
      ]
    },
    "file": {
      "file_name": "BasicDeserializerFactory.java",
      "file_nloc": 1464,
      "file_complexity": 355,
      "file_token_count": 9698,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -12,6 +12,7 @@ import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.deser.impl.CreatorCandidate;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n@@ -343,8 +344,9 @@ public abstract class BasicDeserializerFactory\n                     result.put(owner, defs);\n                 } else {\n                     if (defs[index] != null) {\n-                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n-                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n+                        ctxt.reportBadTypeDefinition(beanDesc,\n+\"Conflict: parameter #%d of %s bound to more than one property; %s vs %s\",\n+index, owner, defs[index], propDef);\n                     }\n                 }\n                 defs[index] = propDef;\n@@ -416,29 +418,31 @@ public abstract class BasicDeserializerFactory\n         }\n \n         // 21-Sep-2017, tatu: First let's handle explicitly annotated ones\n-        List<AnnotatedConstructor> nonAnnotated = new LinkedList<>();\n+        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n         for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n             JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);\n+            if (Mode.DISABLED == creatorMode) {\n+                continue;\n+            }\n             if (creatorMode == null) {\n                 // let's check Visibility here, to avoid further processing for non-visible?\n                 if (vchecker.isCreatorVisible(ctor)) {\n-                    nonAnnotated.add(ctor);\n+                    nonAnnotated.add(CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                 }\n                 continue;\n             }\n             switch (creatorMode) {\n-            case DISABLED: // to be ignored completely\n-                break;\n             case DELEGATING:\n-                _addDelegatingCreator(ctxt, beanDesc, vchecker, intr, creators, ctor);\n+                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n+                        CreatorCandidate.construct(intr, ctor, null));\n                 break;\n             case PROPERTIES:\n-                _addPropertyCreator(ctxt, beanDesc, vchecker, intr, creators, ctor, creatorParams);\n+                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n+                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                 break;\n-            case DEFAULT:\n-//                _addAnyCreator(ctxt, beanDesc, vchecker, intr, creators, ctor, creatorParams);\n-                // !!! NOT YET RIGHT\n-                nonAnnotated.add(ctor);\n+            default:\n+                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n+                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));\n                 break;\n             }\n         }\n@@ -446,33 +450,30 @@ public abstract class BasicDeserializerFactory\n         // And only if and when those handled, consider potentially visible ones\n \n         // may need to keep track for [#725]\n-        List<AnnotatedConstructor> implicitCtors = null;\n-        for (AnnotatedConstructor ctor : nonAnnotated) {\n-            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);\n-            final boolean isCreator = (creatorMode != null); // disabled excluded earlier\n-            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n-            final int argCount = ctor.getParameterCount();\n+        List<AnnotatedWithParams> implicitCtors = null;\n+        for (CreatorCandidate candidate : nonAnnotated) {\n+            final int argCount = candidate.paramCount();\n+            final AnnotatedWithParams ctor = candidate.creator();\n \n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n-                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n+                BeanPropertyDefinition propDef = candidate.propertyDef(0);\n+                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, propDef);\n \n                 if (useProps) {\n                     SettableBeanProperty[] properties = new SettableBeanProperty[1];\n-                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n-                    AnnotatedParameter arg = ctor.getParameter(0);\n-                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n-                            intr.findInjectableValue(arg));\n-                    creators.addPropertyCreator(ctor, isCreator, properties);\n+                    PropertyName name = candidate.paramName(0);\n+                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0,\n+                            candidate.parameter(0), candidate.injection(0));\n+                    creators.addPropertyCreator(ctor, false, properties);\n                 } else {\n-                    /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n-                            ctor, isCreator,\n+                    /*boolean added = */ _handleSingleArgumentCreator(creators,\n+                            ctor, false,\n                             vchecker.isCreatorVisible(ctor));\n                     // one more thing: sever link to creator property, to avoid possible later\n                     // problems with \"unresolved\" constructor property\n-                    if (argDef != null) {\n-                        ((POJOPropertyBuilder) argDef).removeConstructors();\n+                    if (propDef != null) {\n+                        ((POJOPropertyBuilder) propDef).removeConstructors();\n                     }\n                 }\n                 // regardless, fully handled\n@@ -483,7 +484,7 @@ public abstract class BasicDeserializerFactory\n             // 14-Mar-2015, tatu (2.6): Or, as per [#725], implicit names will also\n             //   do, with some constraints. But that will require bit post processing...\n \n-            AnnotatedParameter nonAnnotatedParam = null;\n+            int nonAnnotatedParamIndex = -1;\n             SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n             int explicitNameCount = 0;\n             int implicitWithCreatorCount = 0;\n@@ -491,7 +492,7 @@ public abstract class BasicDeserializerFactory\n \n             for (int i = 0; i < argCount; ++i) {\n                 final AnnotatedParameter param = ctor.getParameter(i);\n-                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n+                BeanPropertyDefinition propDef = candidate.propertyDef(i);\n                 JacksonInject.Value injectId = intr.findInjectableValue(param);\n                 final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n \n@@ -515,51 +516,53 @@ public abstract class BasicDeserializerFactory\n                     continue;\n                 }\n                 // One more thing: implicit names are ok iff ctor has creator annotation\n+                /*\n                 if (isCreator && (name != null && !name.isEmpty())) {\n                     ++implicitWithCreatorCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                     continue;\n                 }\n-                if (nonAnnotatedParam == null) {\n-                    nonAnnotatedParam = param;\n+                */\n+                if (nonAnnotatedParamIndex < 0) {\n+                    nonAnnotatedParamIndex = i;\n                 }\n             }\n \n             final int namedCount = explicitNameCount + implicitWithCreatorCount;\n             // Ok: if named or injectable, we have more work to do\n-            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n+            if ((explicitNameCount > 0) || (injectCount > 0)) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(ctor, isCreator, properties);\n+                    creators.addPropertyCreator(ctor, false, properties);\n                     continue;\n                 }\n                 if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // Secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(ctor, isCreator, properties, 0);\n+                    creators.addDelegatingCreator(ctor, false, properties, 0);\n                     continue;\n                 }\n                 // otherwise, epic fail?\n                 // 16-Mar-2015, tatu: due to [#725], need to be more permissive. For now let's\n                 //    only report problem if there's no implicit name\n-                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n+                PropertyName impl = candidate.findImplicitParamName(nonAnnotatedParamIndex);\n                 if (impl == null || impl.isEmpty()) {\n                     // Let's consider non-static inner class as a special case...\n-                    int ix = nonAnnotatedParam.getIndex();\n                     // 25-Jan-2017, tatu: Non-static inner classes skipped altogether, now\n                     /*\n-                    if ((ix == 0) && isNonStaticInnerClass) {\n+                    if ((nonAnnotatedParamIndex == 0) && isNonStaticInnerClass) {\n                         throw new IllegalArgumentException(\"Non-static inner classes like \"\n                                 +ctor.getDeclaringClass().getName()+\" cannot use @JsonCreator for constructors\");\n                     }\n                     */\n-                    throw new IllegalArgumentException(\"Argument #\"+ix\n-                            +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n+                    ctxt.reportBadTypeDefinition(beanDesc,\n+\"Argument #%d of constructor %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\n+nonAnnotatedParamIndex, ctor);\n                 }\n             }\n             // [#725]: as a fallback, all-implicit names may work as well\n             if (!creators.hasDefaultCreator()) {\n                 if (implicitCtors == null) {\n-                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n+                    implicitCtors = new LinkedList<>();\n                 }\n                 implicitCtors.add(ctor);\n             }\n@@ -578,20 +581,20 @@ public abstract class BasicDeserializerFactory\n      *\n      * @since 2.9.2\n      */\n-    protected void _addDelegatingCreator(DeserializationContext ctxt,\n-            BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr,\n-            CreatorCollector creators, AnnotatedWithParams creator)\n+    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n+            BeanDescription beanDesc, CreatorCollector creators,\n+            CreatorCandidate candidate)\n         throws JsonMappingException\n     {\n         // Somewhat simple: find injectable values, if any, ensure there is one\n         // and just one delegated argument; report violations if any\n \n         int ix = -1;\n-        final int argCount = creator.getParameterCount();\n+        final int argCount = candidate.paramCount();\n         SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n         for (int i = 0; i < argCount; ++i) {\n-            AnnotatedParameter param = creator.getParameter(i);\n-            JacksonInject.Value injectId = intr.findInjectableValue(param);\n+            AnnotatedParameter param = candidate.parameter(i);\n+            JacksonInject.Value injectId = candidate.injection(i);\n             if (injectId != null) {\n                 properties[i] = constructCreatorProperty(ctxt, beanDesc, null, i, param, injectId);\n                 continue;\n@@ -601,17 +604,16 @@ public abstract class BasicDeserializerFactory\n                 continue;\n             }\n             // Illegal to have more than one value to delegate to\n-            throw new IllegalArgumentException(String.format(\n-                    \"More than one argument (#%d amd #%d) left as delegating for Creator %s: only one allowed\",\n-                    ix, i, creator));\n+            ctxt.reportBadTypeDefinition(beanDesc,\n+                    \"More than one argument (#%d and #%d) left as delegating for Creator %s: only one allowed\",\n+                    ix, i, candidate);\n         }\n         // Also, let's require that one Delegating argument does eixt\n         if (ix < 0) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"No argument left as delegating for Creator %s: exactly one required\",\n-                    creator));\n+            ctxt.reportBadTypeDefinition(beanDesc,\n+                    \"No argument left as delegating for Creator %s: exactly one required\", candidate);\n         }\n-        creators.addDelegatingCreator(creator, true, properties, ix);\n+        creators.addDelegatingCreator(candidate.creator(), true, properties, ix);\n     }\n \n     /**\n@@ -619,24 +621,22 @@ public abstract class BasicDeserializerFactory\n      *\n      * @since 2.9.2\n      */\n-    protected void _addPropertyCreator(DeserializationContext ctxt,\n-            BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr,\n-            CreatorCollector creators, AnnotatedWithParams creator,\n-            Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n+    protected void _addExplicitPropertyCreator(DeserializationContext ctxt,\n+            BeanDescription beanDesc, CreatorCollector creators,\n+            CreatorCandidate candidate)\n         throws JsonMappingException\n     {\n-        final int argCount = creator.getParameterCount();\n-        SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n-        BeanPropertyDefinition[] propDefs = creatorParams.get(creator);\n-        for (int i = 0; i < argCount; ++i) {\n-            AnnotatedParameter param = creator.getParameter(i);\n-            BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n-            JacksonInject.Value injectId = intr.findInjectableValue(param);\n-            PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+        final int paramCount = candidate.paramCount();\n+        SettableBeanProperty[] properties = new SettableBeanProperty[paramCount];\n+\n+        for (int i = 0; i < paramCount; ++i) {\n+            JacksonInject.Value injectId = candidate.injection(i);\n+            AnnotatedParameter param = candidate.parameter(i);\n+            PropertyName name = candidate.paramName(i);\n             if (name == null) {\n                 // 21-Sep-2017, tatu: Looks like we want to block accidental use of Unwrapped,\n                 //   as that will not work with Creators well at all\n-                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n+                NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(param);\n                 if (unwrapper != null) {\n                     _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                     /*\n@@ -644,16 +644,16 @@ public abstract class BasicDeserializerFactory\n                     ++explicitNameCount;\n                     */\n                 }\n-                name = _findImplicitParamName(param, intr);\n+                name = candidate.findImplicitParamName(i);\n                 // Must be injectable or have name; without either won't work\n                 if ((name == null) && (injectId == null)) {\n-                    throw new IllegalArgumentException(String.format(\n-                            \"Argument #%d has no name, is not Injectable: can not use Creator %s\", i, creator));\n+                    ctxt.reportBadTypeDefinition(beanDesc,\n+\"Argument #%d has no property name, is not Injectable: can not use as Creator %s\", i, candidate);\n                 }\n             }\n             properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n         }\n-        creators.addPropertyCreator(creator, true, properties);\n+        creators.addPropertyCreator(candidate.creator(), true, properties);\n     }\n \n     /**\n@@ -661,23 +661,83 @@ public abstract class BasicDeserializerFactory\n      *\n      * @since 2.9.2\n      */\n-    protected void _addAnyCreator(DeserializationContext ctxt,\n-            BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr,\n-            CreatorCollector creators, AnnotatedWithParams creator,\n-            Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n+    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n+            BeanDescription beanDesc, CreatorCollector creators,\n+            CreatorCandidate candidate)\n         throws JsonMappingException\n     {\n-        final int argCount = creator.getParameterCount();\n-        // First things first: only ambiguity may be wrt 1-argument case\n-        \n+        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n+        if (1 != candidate.paramCount()) {\n+            // Ok: for delegates, we want one and exactly one parameter without\n+            // injection AND  without name\n+            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n+            if (oneNotInjected >= 0) {\n+                // getting close; but most not have name\n+                if (candidate.paramName(oneNotInjected) == null) {\n+                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n+                    return;\n+                }\n+            }\n+            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n+            return;\n+        }\n+        AnnotatedParameter param = candidate.parameter(0);\n+        JacksonInject.Value injectId = candidate.injection(0);\n+        PropertyName paramName = candidate.explicitParamName(0);\n+        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n+\n+        // If there's injection or explicit name, should be properties-based\n+        boolean useProps = (paramName != null) || (injectId != null);\n+        if (!useProps && (paramDef != null)) {\n+            // One more thing: if implicit name matches property with a getter\n+            // or field, we'll consider it property-based as well\n+            paramName = candidate.findImplicitParamName(0);\n+            useProps = (paramName != null) && paramDef.couldSerialize();\n+        }\n+        if (useProps) {\n+            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n+                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n+            };\n+            creators.addPropertyCreator(candidate.creator(), true, properties);\n+            return;\n+        }\n+        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n+\n+        // one more thing: sever link to creator property, to avoid possible later\n+        // problems with \"unresolved\" constructor property\n+        if (paramDef != null) {\n+            ((POJOPropertyBuilder) paramDef).removeConstructors();\n+        }\n     }\n-    \n-    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt,\n+\n+    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n+            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n+    {\n+        // If explicit name, or inject id, property-based\n+        if (((propDef != null) && propDef.isExplicitlyNamed())\n+                || (intr.findInjectableValue(creator.getParameter(0)) != null)) {\n+            return true;\n+        }\n+        if (propDef != null) {\n+            // One more thing: if implicit name matches property with a getter\n+            // or field, we'll consider it property-based as well\n+            String implName = propDef.getName();\n+            if (implName != null && !implName.isEmpty()) {\n+                if (propDef.couldSerialize()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        // in absence of everything else, default to delegating\n+        return false;\n+    }\n+\n+    private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n             AnnotationIntrospector intr, CreatorCollector creators,\n-            List<AnnotatedConstructor> implicitCtors) throws JsonMappingException\n+            List<AnnotatedWithParams> implicitCtors) throws JsonMappingException\n     {\n-        AnnotatedConstructor found = null;\n+        AnnotatedWithParams found = null;\n         SettableBeanProperty[] foundProps = null;\n \n         // Further checks: (a) must have names for all parameters, (b) only one visible\n@@ -685,7 +745,7 @@ public abstract class BasicDeserializerFactory\n         // `@JsonCreator` (or equivalent) annotation, we need to do bit more re-inspection...\n \n         main_loop:\n-        for (AnnotatedConstructor ctor : implicitCtors) {\n+        for (AnnotatedWithParams ctor : implicitCtors) {\n             if (!vchecker.isCreatorVisible(ctor)) {\n                 continue;\n             }\n@@ -703,7 +763,7 @@ public abstract class BasicDeserializerFactory\n                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                         param, /*injectId*/ null);\n             }\n-            if (found != null) { // only one allowed\n+            if (found != null) { // only one allowed; but multiple not an error\n                 found = null;\n                 break;\n             }\n@@ -726,60 +786,13 @@ public abstract class BasicDeserializerFactory\n         }\n     }\n \n-    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n-            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-            AnnotationIntrospector intr, CreatorCollector creators,\n-            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n-        throws JsonMappingException\n-    {\n-        // otherwise either 'simple' number, String, or general delegate:\n-        Class<?> type = ctor.getRawParameterType(0);\n-        if (type == String.class || type == CharSequence.class) {\n-            if (isCreator || isVisible) {\n-                creators.addStringCreator(ctor, isCreator);\n-            }\n-            return true;\n-        }\n-        if (type == int.class || type == Integer.class) {\n-            if (isCreator || isVisible) {\n-                creators.addIntCreator(ctor, isCreator);\n-            }\n-            return true;\n-        }\n-        if (type == long.class || type == Long.class) {\n-            if (isCreator || isVisible) {\n-                creators.addLongCreator(ctor, isCreator);\n-            }\n-            return true;\n-        }\n-        if (type == double.class || type == Double.class) {\n-            if (isCreator || isVisible) {\n-                creators.addDoubleCreator(ctor, isCreator);\n-            }\n-            return true;\n-        }\n-        if (type == boolean.class || type == Boolean.class) {\n-            if (isCreator || isVisible) {\n-                creators.addBooleanCreator(ctor, isCreator);\n-            }\n-            return true;\n-        }\n-        // Delegating Creator ok iff it has @JsonCreator (etc)\n-        if (isCreator) {\n-            creators.addDelegatingCreator(ctor, isCreator, null, 0);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n     protected void _addDeserializerFactoryMethods\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n          AnnotationIntrospector intr, CreatorCollector creators,\n          Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n         throws JsonMappingException\n     {\n-        final DeserializationConfig config = ctxt.getConfig();\n-        List<AnnotatedMethod> nonAnnotated = new LinkedList<>();\n+        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n \n         // 21-Sep-2017, tatu: First let's handle explicitly annotated ones\n         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n@@ -788,7 +801,7 @@ public abstract class BasicDeserializerFactory\n             if (creatorMode == null) {\n                 // Only potentially accept 1-argument factory methods\n                 if ((argCount == 1) && vchecker.isCreatorVisible(factory)) {\n-                    nonAnnotated.add(factory);\n+                    nonAnnotated.add(CreatorCandidate.construct(intr, factory, null));\n                 }\n                 continue;\n             }\n@@ -804,33 +817,33 @@ public abstract class BasicDeserializerFactory\n \n             switch (creatorMode) {\n             case DELEGATING:\n-                _addDelegatingCreator(ctxt, beanDesc, vchecker, intr, creators, factory);\n+                _addExplicitDelegatingCreator(ctxt, beanDesc, creators,\n+                        CreatorCandidate.construct(intr, factory, null));\n                 break;\n             case PROPERTIES:\n-                _addPropertyCreator(ctxt, beanDesc, vchecker, intr, creators, factory, creatorParams);\n+                _addExplicitPropertyCreator(ctxt, beanDesc, creators,\n+                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                 break;\n             case DEFAULT:\n             default:\n-//                    _addAnyCreator(ctxt, beanDesc, vchecker, intr, creators, ctor, creatorParams);\n-                    // !!! NOT YET RIGHT\n-                nonAnnotated.add(factory);\n+                _addExplicitAnyCreator(ctxt, beanDesc, creators,\n+                        CreatorCandidate.construct(intr, factory, creatorParams.get(factory)));\n                 break;\n             }\n         }\n         // And then implicitly found\n-        for (AnnotatedMethod factory : nonAnnotated) {\n-            final int argCount = factory.getParameterCount();\n-            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), factory);\n-            final boolean isCreator = (creatorMode != null); // disabled excluded earlier\n+        for (CreatorCandidate candidate : nonAnnotated) {\n+            final int argCount = candidate.paramCount();\n+            AnnotatedWithParams factory = candidate.creator();\n             final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n                 // more than 2 args, must have @JsonCreator (and 0-args handled earlier\n-                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n+                BeanPropertyDefinition argDef = candidate.propertyDef(0);\n                 boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                 if (!useProps) { // not property based but delegating\n-                    /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n-                            factory, true);\n+                    /*boolean added=*/ _handleSingleArgumentCreator(creators,\n+                            factory, false, vchecker.isCreatorVisible(factory));\n                     // 23-Sep-2016, tatu: [databind#1383]: Need to also sever link to avoid possible\n                     //    later problems with \"unresolved\" constructor property\n                     if (argDef != null) {\n@@ -839,10 +852,8 @@ public abstract class BasicDeserializerFactory\n                     continue;\n                 }\n                 // fall through if there's name\n-            } else { // 2 and more args? Must be explicit\n-                if (!isCreator) {\n-                    continue;\n-                }\n+            } else {\n+                continue; // 2 and more args? Must be explicit, handled earlier\n             }\n             // 1 or more args; all params must have name annotations\n             AnnotatedParameter nonAnnotatedParam = null;            \n@@ -877,6 +888,7 @@ public abstract class BasicDeserializerFactory\n                     continue;\n                 }\n                 // One more thing: implicit names are ok iff ctor has creator annotation\n+                /*\n                 if (isCreator) {\n                     if (name != null && !name.isEmpty()) {\n                         ++implicitNameCount;\n@@ -884,6 +896,7 @@ public abstract class BasicDeserializerFactory\n                         continue;\n                     }\n                 }\n+                */\n                 /* 25-Sep-2014, tatu: Actually, we may end up \"losing\" naming due to higher-priority constructor\n                  *  (see TestCreators#testConstructorCreator() test). And just to avoid running into that problem,\n                  *  let's add one more work around\n@@ -903,61 +916,60 @@ public abstract class BasicDeserializerFactory\n             final int namedCount = explicitNameCount + implicitNameCount;\n             \n             // Ok: if named or injectable, we have more work to do\n-            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n+            if (explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(factory, isCreator, properties);\n+                    creators.addPropertyCreator(factory, false, properties);\n                 } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(factory, isCreator, properties, 0);\n+                    creators.addDelegatingCreator(factory, false, properties, 0);\n                 } else { // otherwise, epic fail\n-                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n-                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n+                    ctxt.reportBadTypeDefinition(beanDesc,\n+\"Argument #%d of factory method %s has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\",\n+                    nonAnnotatedParam.getIndex(), factory);\n                 }\n             }\n         }\n     }\n \n-    protected boolean _handleSingleArgumentFactory(DeserializationConfig config,\n-            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-            AnnotationIntrospector intr, CreatorCollector creators,\n-            AnnotatedMethod factory, boolean isCreator)\n-        throws JsonMappingException\n+    protected boolean _handleSingleArgumentCreator(CreatorCollector creators,\n+            AnnotatedWithParams ctor, boolean isCreator, boolean isVisible)\n     {\n-        Class<?> type = factory.getRawParameterType(0);\n-        \n+        // otherwise either 'simple' number, String, or general delegate:\n+        Class<?> type = ctor.getRawParameterType(0);\n         if (type == String.class || type == CharSequence.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addStringCreator(factory, isCreator);\n+            if (isCreator || isVisible) {\n+                creators.addStringCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == int.class || type == Integer.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addIntCreator(factory, isCreator);\n+            if (isCreator || isVisible) {\n+                creators.addIntCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == long.class || type == Long.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addLongCreator(factory, isCreator);\n+            if (isCreator || isVisible) {\n+                creators.addLongCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == double.class || type == Double.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addDoubleCreator(factory, isCreator);\n+            if (isCreator || isVisible) {\n+                creators.addDoubleCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == boolean.class || type == Boolean.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addBooleanCreator(factory, isCreator);\n+            if (isCreator || isVisible) {\n+                creators.addBooleanCreator(ctor, isCreator);\n             }\n             return true;\n         }\n+        // Delegating Creator ok iff it has @JsonCreator (etc)\n         if (isCreator) {\n-            creators.addDelegatingCreator(factory, isCreator, null, 0);\n+            creators.addDelegatingCreator(ctor, isCreator, null, 0);\n             return true;\n         }\n         return false;\n@@ -1028,7 +1040,7 @@ public abstract class BasicDeserializerFactory\n         return prop;\n     }\n \n-    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n     {\n         if (param != null && intr != null) {\n             PropertyName name = intr.findNameForDeserialization(param);\n@@ -1046,37 +1058,6 @@ public abstract class BasicDeserializerFactory\n         return null;\n     }\n \n-    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n-    {\n-        String str = intr.findImplicitPropertyName(param);\n-        if (str != null && !str.isEmpty()) {\n-            return PropertyName.construct(str);\n-        }\n-        return null;\n-    }\n-\n-    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n-            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n-    {\n-        // If explicit name, or inject id, property-based\n-        if (((propDef != null) && propDef.isExplicitlyNamed())\n-                || (intr.findInjectableValue(creator.getParameter(0)) != null)) {\n-            return true;\n-        }\n-        if (propDef != null) {\n-            // One more thing: if implicit name matches property with a getter\n-            // or field, we'll consider it property-based as well\n-            String implName = propDef.getName();\n-            if (implName != null && !implName.isEmpty()) {\n-                if (propDef.couldSerialize()) {\n-                    return true;\n-                }\n-            }\n-        }\n-        // in absence of everything else, default to delegating\n-        return false;\n-    }\n-\n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: array deserializers\n",
      "files_name_in_blame_commit": [
        "TestInjectables.java",
        "CreatorCandidate.java",
        "TestCreators.java",
        "BasicDeserializerFactory.java",
        "BasicBeanDescription.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 188
  }
}
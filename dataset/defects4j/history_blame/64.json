{
  "id": "64",
  "blame_commit": {
    "commit": {
      "commit_id": "24407a462cd8779fd36ae4229d0c5fe01f57e507",
      "commit_message": "Refactorings to use JsonIgnoreProperties.Value to allow config overrides",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2016-05-01 14:07:51",
      "commit_parent": "8edbf2750fce2c134f6674dbefef3e3f3d215df2"
    },
    "function": {
      "function_name": "addBeanProps",
      "function_code_before": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final SettableBeanProperty[] creatorProps =\n            builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n\n    // Things specified as \"ok to ignore\"? [JACKSON-77]\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    boolean ignoreAny = false;\n    {\n        Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n        if (B != null) {\n            ignoreAny = B.booleanValue();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n        }\n    }\n    // Or explicit/implicit definitions?\n    Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false));        \n    for (String propName : ignored) {\n        builder.addIgnorable(propName);\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetter = beanDesc.findAnySetter();\n    if (anySetter != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetter == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (isConcrete && propDef.hasConstructorParameter()) {\n            /* [JACKSON-700] If property is passed via constructor parameter, we must\n             *   handle things in special way. Not sure what is the most optimal way...\n             *   for now, let's just call a (new) method in builder, which does nothing.\n             */\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                throw ctxt.mappingException(\"Could not find creator property with name '%s' (in class %s)\",\n                        name, beanDesc.getBeanClass().getName());\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}",
      "function_code_after": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final SettableBeanProperty[] creatorProps =\n            builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n\n    // Things specified as \"ok to ignore\"?\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(beanDesc.getClassInfo());\n    Set<String> ignored;\n\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetter = beanDesc.findAnySetter();\n    if (anySetter != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetter == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (isConcrete && propDef.hasConstructorParameter()) {\n            /* [JACKSON-700] If property is passed via constructor parameter, we must\n             *   handle things in special way. Not sure what is the most optimal way...\n             *   for now, let's just call a (new) method in builder, which does nothing.\n             */\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                throw ctxt.mappingException(\"Could not find creator property with name '%s' (in class %s)\",\n                        name, beanDesc.getBeanClass().getName());\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}",
      "function_before_start_line": 444,
      "function_before_end_line": 566,
      "function_after_start_line": 442,
      "function_after_end_line": 566,
      "function_before_token_count": 649,
      "function_after_token_count": 646,
      "functions_name_modified_file": [
        "addBeanProps",
        "materializeAbstractType",
        "filterBeanProps",
        "findStdDeserializer",
        "BeanDeserializerFactory",
        "buildBeanDeserializer",
        "createBeanDeserializer",
        "addReferenceProperties",
        "addObjectIdReader",
        "constructAnySetter",
        "constructBeanDeserializerBuilder",
        "isIgnorableType",
        "buildBuilderBasedDeserializer",
        "withConfig",
        "addInjectables",
        "isPotentialBeanType",
        "constructSetterlessProperty",
        "buildThrowableDeserializer",
        "constructSettableProperty",
        "createBuilderBasedDeserializer"
      ],
      "functions_name_all_files": [
        "refineSerializationType",
        "materializeAbstractType",
        "testClassWithUnknownAndIgnore",
        "removeOverlappingTypeIds",
        "_deserializeUsingPropertyBased",
        "deserializeFromObjectUsingNonDefault",
        "_handleTypedObjectId",
        "BuilderBasedDeserializer",
        "findViews",
        "modifyTypeByAnnotation",
        "createContextual",
        "BeanDeserializer",
        "_addDeserializerFactoryMethods",
        "BeanSerializerFactory",
        "BeanDeserializerBase",
        "processViews",
        "properties",
        "findKeyDeserializerFromAnnotation",
        "constructEnumResolver",
        "_resolveInnerClassValuedProperty",
        "_deserializeWithCreator",
        "managed",
        "removeIgnorableTypes",
        "deserializeUsingPropertyBasedWithUnwrapped",
        "serializeTypedFields",
        "withAdditionalSerializers",
        "finishBuild",
        "findPropertyTypeResolver",
        "_findRemappedType",
        "findConvertingDeserializer",
        "resolveSetterConflict",
        "withSerializerModifier",
        "allIntrospectors",
        "_findStdValueInstantiator",
        "BeanAsArraySerializer",
        "put",
        "usesObjectId",
        "injectValues",
        "findClassDescription",
        "findTypeDeserializer",
        "findDeserializer",
        "handleUnknownProperty",
        "resolve",
        "deserializeFromBoolean",
        "findContentSerializer",
        "createCollectionDeserializer",
        "version",
        "arrayToSet",
        "customSerializers",
        "deserializeWithObjectId",
        "findPropertyContentTypeResolver",
        "createMapLikeDeserializer",
        "_serializeObjectId",
        "_findCustomReferenceDeserializer",
        "getKeySerializer",
        "findPropertyAccess",
        "BeanSerializerBase",
        "findKeySerializer",
        "addReferenceProperties",
        "withAdditionalKeySerializers",
        "DoubleBuilder",
        "getBeanClass",
        "getByteBuilder",
        "testUnknownHandlingIgnoreWithHandlerAndObjectReader",
        "resolveForwardReference",
        "isIgnorableType",
        "handleUnknownProperties",
        "BasicSerializerFactory",
        "asArrayDeserializer",
        "withObjectIdReader",
        "findPropertyContentTypeSerializer",
        "findSerializationKeyType",
        "filterBeanProps",
        "getSchema",
        "isCachable",
        "findPropertyDefaultValue",
        "findDeserializationType",
        "refineDeserializationType",
        "_addDeserializerConstructors",
        "construct",
        "acceptJsonFormatVisitor",
        "getDoubleBuilder",
        "constructCreatorProperty",
        "findPropertyContentTypeDeserializer",
        "_orderEntries",
        "rename",
        "unwrappingDeserializer",
        "buildArraySerializer",
        "wrapInstantiationProblem",
        "MapReferringAccumulator",
        "findDeserializationConverter",
        "findSerializationConverter",
        "_findParamName",
        "findPOJOBuilderConfig",
        "_findCreatorsFromProperties",
        "_resolveUnwrappedProperty",
        "findObjectIdInfo",
        "findDeserializationKeyType",
        "_deserializeNonVanilla",
        "createMapDeserializer",
        "buildCollectionSerializer",
        "buildBeanDeserializer",
        "serializeFilteredFields",
        "serializeFieldsUsing",
        "findSerializationInclusion",
        "withObjectIdWriter",
        "nopInstance",
        "serializeOptionalFields",
        "c",
        "findSerializationTyping",
        "testPropertyIgnoral",
        "hasAsValueAnnotation",
        "buildIteratorSerializer",
        "findSerializer",
        "ShortBuilder",
        "filterBeanProperties",
        "findKeyDeserializer",
        "getValueType",
        "_mapAbstractCollectionType",
        "getKnownPropertyNames",
        "_resolvedObjectIdProperty",
        "creatorProperties",
        "createTypeSerializer",
        "setB",
        "handleUnknownVanilla",
        "testPropertyIgnoralWithClass",
        "getObjectIdReader",
        "findPropertyTypeSerializer",
        "findEnumValues",
        "withAdditionalDeserializers",
        "isBackReference",
        "handleIgnoredProperty",
        "_findJsonValueFor",
        "buildBuilderBasedDeserializer",
        "setIgnorableProperties",
        "handledType",
        "buildThrowableDeserializer",
        "BeanAsArrayDeserializer",
        "_deserializeWithErrorWrapping",
        "findOptionalStdSerializer",
        "_findContentSerializer",
        "findPropertyDescription",
        "constructBeanSerializer",
        "_deserialize",
        "findRootName",
        "_deserializeOther",
        "_findDelegateDeserializer",
        "_deserializeFromNonArray",
        "getBooleanBuilder",
        "getName",
        "findNullSerializer",
        "IgnoreSome",
        "findNameForSerialization",
        "_findCustomArrayDeserializer",
        "findWrapperName",
        "findNamingStrategy",
        "testPropertyIgnoralForMap",
        "findSerializationInclusionForContent",
        "TestBean",
        "create",
        "deserializeUsingPropertyBasedWithExternalTypeId",
        "buildMapEntrySerializer",
        "findSerializationSortAlphabetically",
        "_findImplicitParamName",
        "_convertObjectId",
        "_checkIfCreatorPropertyBased",
        "createEnumDeserializer",
        "findPropertiesToIgnore",
        "testUnknownHandlingIgnoreWithFeature",
        "deserializeWithExternalTypeId",
        "deserializeWithType",
        "_findCustomBeanDeserializer",
        "vanillaDeserialize",
        "withDeserializerModifier",
        "wrapAndThrow",
        "findNameForDeserialization",
        "createBeanDeserializer",
        "_ensureOverride",
        "withAdditionalKeyDeserializers",
        "constructFilteredBeanWriter",
        "withResolved",
        "handlePolymorphic",
        "pair",
        "createArrayDeserializer",
        "_customTypeId",
        "withConfig",
        "findDeserializationContentType",
        "getType",
        "isTypeId",
        "deserializeFromArray",
        "unwrappingSerializer",
        "findSuppressableContentValue",
        "hasViews",
        "_findCustomEnumDeserializer",
        "addBeanProps",
        "isManagedReference",
        "findOptionalStdDeserializer",
        "findUnwrappingNameTransformer",
        "deserializeFromEmbedded",
        "deserializeFromObjectId",
        "findAndAddVirtualProperties",
        "buildContainerSerializer",
        "getFactoryConfig",
        "_readAndBindStringMap",
        "handleUnresolvedReference",
        "isUnwrappingSerializer",
        "findSerializationContentConverter",
        "deserializeWithUnwrapped",
        "serializeFields",
        "_hasExplicitParamName",
        "addObjectIdReader",
        "MapSerializer",
        "_findCustomCollectionLikeDeserializer",
        "serializeFieldsFiltered",
        "findBeanProperties",
        "createKeySerializer",
        "serialize",
        "withIgnorableProperties",
        "d",
        "_checkImplicitlyNamedConstructors",
        "hasProperty",
        "testClassIgnoreWithMap",
        "withValueInstantiators",
        "getContentDeserializer",
        "findFormat",
        "_readAndBind",
        "hasCreatorAnnotation",
        "getValueInstantiator",
        "markUnknown",
        "LongBuilder",
        "findSerializerByPrimaryType",
        "constructObjectIdHandler",
        "findEnumValue",
        "findSerializerByAnnotations",
        "MapReferring",
        "throwOrReturnThrowable",
        "setA",
        "deserializeFromDouble",
        "_constructDefaultValueInstantiator",
        "_findCustomTreeNodeDeserializer",
        "arrayToList",
        "constructSetterlessProperty",
        "buildMapSerializer",
        "findPropertyInclusion",
        "UnwrappingBeanSerializer",
        "createBuilderBasedDeserializer",
        "findSerializationContentType",
        "_findSubclassDeserializer",
        "getContentType",
        "setAndArray",
        "findSubtypes",
        "findStdDeserializer",
        "findBackReference",
        "testWithClassIgnore",
        "BooleanBuilder",
        "createCollectionLikeDeserializer",
        "findReferenceSerializer",
        "buildIterableSerializer",
        "findCreatorBinding",
        "withFilterId",
        "findReferenceType",
        "findSerializationPropertyOrder",
        "findImplicitPropertyName",
        "isIndexedList",
        "constructBeanSerializerBuilder",
        "deserializeFromNull",
        "getPropertyCount",
        "_missingToken",
        "_createSerializer2",
        "createSerializer",
        "findContentDeserializer",
        "hasAnySetterAnnotation",
        "findDeserializerFromAnnotation",
        "buildEnumSerializer",
        "findDeserializationContentConverter",
        "findBeanSerializer",
        "_hasOneOf",
        "_findKeySerializer",
        "findObjectReferenceInfo",
        "mapAbstractType",
        "findValueInstantiator",
        "serializeWithType",
        "_serializeWithObjectId",
        "resolveType",
        "deserializeWithView",
        "for",
        "insertInList",
        "_isStdKeyDeser",
        "AnnotationIntrospectorPair",
        "_findAndAddDynamic",
        "ByteBuilder",
        "findPropertyIgnorals",
        "constructSettableProperty",
        "ArrayBuilders",
        "createTreeDeserializer",
        "findInjectableValueId",
        "findAutoDetectVisibility",
        "findSerializerFromAnnotation",
        "toString",
        "constructPropertyBuilder",
        "serializeAsArray",
        "buildIndexedListSerializer",
        "setC",
        "findProperty",
        "MapDeserializer",
        "testClassWithIgnoreUnknown",
        "getArrayComparator",
        "getContentSerializer",
        "asArraySerializer",
        "createDummy",
        "_verifyAsClass",
        "getLongBuilder",
        "ReferenceProperty",
        "_resolveManagedReferenceProperty",
        "buildEnumSetSerializer",
        "_hasAnnotation",
        "constructBeanDeserializerBuilder",
        "findPOJOBuilder",
        "findSerializationType",
        "findConverter",
        "removeSetterlessGetters",
        "createReferenceDeserializer",
        "_findCustomMapDeserializer",
        "deserialize",
        "_findExplicitParamName",
        "back",
        "getIntBuilder",
        "addToList",
        "setD",
        "testUnknownHandlingDefault",
        "findFilterId",
        "_isExplicitClassOrOb",
        "_handleSingleArgumentConstructor",
        "testUnknownHandlingIgnoreWithHandler",
        "withContentInclusion",
        "addInjectables",
        "isPotentialBeanType",
        "replaceProperty",
        "insertInListNoDup",
        "handleResolvedForwardReference",
        "hasIgnoreMarker",
        "findConvertingSerializer",
        "_handleSingleArgumentFactory",
        "deserializeFromObject",
        "findPropertyIndex",
        "FloatBuilder",
        "_findCustomMapLikeDeserializer",
        "findSerializerByLookup",
        "findTypeName",
        "_mapAbstractType2",
        "hasRequiredMarker",
        "withIgnorals",
        "getFloatBuilder",
        "deserializeFromString",
        "_createEnumKeyDeserializer",
        "hasAnyGetterAnnotation",
        "withAbstractTypeResolver",
        "findSerializerByAddonType",
        "BeanAsArrayBuilderDeserializer",
        "deserializeFromNumber",
        "_findAnnotation",
        "_valueInstantiatorInstance",
        "_constructWriter",
        "hasSingleElement",
        "_constructArray",
        "createKeyDeserializer",
        "findPropertyTypeDeserializer",
        "_deserializeUsingCreator",
        "findIgnoreUnknownProperties",
        "BasicDeserializerFactory",
        "BeanDeserializerFactory",
        "BeanSerializer",
        "getMapClass",
        "findTypeResolver",
        "isEmpty",
        "constructAnySetter",
        "IntBuilder",
        "_withValueTypeSerializer",
        "isAnnotationBundle",
        "getShortBuilder",
        "testIssue987",
        "usesStaticTyping",
        "findDefaultEnumValue",
        "findDefaultDeserializer",
        "_findCustomCollectionDeserializer"
      ],
      "functions_name_co_evolved_modified_file": [
        "addBeanProps"
      ],
      "functions_name_co_evolved_all_files": [
        "addBeanProps",
        "createMapDeserializer",
        "BuilderBasedDeserializer",
        "BeanSerializer",
        "testPropertyIgnoralWithClass",
        "MapDeserializer",
        "createContextual",
        "serializeFilteredFields",
        "serializeFields",
        "serializeFieldsUsing",
        "BeanDeserializer",
        "BeanSerializerBase",
        "withIgnorals",
        "construct",
        "serializeOptionalFields",
        "MapSerializer",
        "BeanAsArraySerializer",
        "withResolved",
        "BeanDeserializerBase",
        "withIgnorableProperties",
        "findPropertyIgnorals",
        "setIgnorableProperties",
        "filterBeanProperties",
        "buildMapSerializer",
        "constructBeanSerializer",
        "UnwrappingBeanSerializer",
        "serializeTypedFields"
      ]
    },
    "file": {
      "file_name": "BeanDeserializerFactory.java",
      "file_nloc": 532,
      "file_complexity": 117,
      "file_token_count": 3782,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -2,9 +2,8 @@ package com.fasterxml.jackson.databind.deser;\n \n import java.util.*;\n \n-import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+import com.fasterxml.jackson.annotation.*;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n@@ -13,7 +12,6 @@ import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n \n@@ -449,21 +447,23 @@ public class BeanDeserializerFactory\n                 builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n         final boolean isConcrete = !beanDesc.getType().isAbstract();\n         \n-        // Things specified as \"ok to ignore\"? [JACKSON-77]\n+        // Things specified as \"ok to ignore\"?\n         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n-        boolean ignoreAny = false;\n-        {\n-            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n-            if (B != null) {\n-                ignoreAny = B.booleanValue();\n-                builder.setIgnoreUnknownProperties(ignoreAny);\n+        JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(beanDesc.getClassInfo());\n+        Set<String> ignored;\n+        \n+        if (ignorals != null) {\n+            boolean ignoreAny = ignorals.getIgnoreUnknown();\n+            builder.setIgnoreUnknownProperties(ignoreAny);\n+            // Or explicit/implicit definitions?\n+            ignored = ignorals.getIgnored();\n+            for (String propName : ignored) {\n+                builder.addIgnorable(propName);\n             }\n+        } else {\n+            ignored = Collections.emptySet();\n         }\n-        // Or explicit/implicit definitions?\n-        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false));        \n-        for (String propName : ignored) {\n-            builder.addIgnorable(propName);\n-        }\n+\n         // Also, do we have a fallback \"any\" setter?\n         AnnotatedMethod anySetter = beanDesc.findAnySetter();\n         if (anySetter != null) {\n",
      "files_name_in_blame_commit": [
        "AnnotationIntrospector.java",
        "BeanSerializer.java",
        "BeanSerializerFactory.java",
        "TestUnknownPropertyDeserialization.java",
        "BeanSerializerBase.java",
        "BeanAsArrayBuilderDeserializer.java",
        "BeanDeserializer.java",
        "BeanDeserializerBase.java",
        "BasicSerializerFactory.java",
        "ArrayBuilders.java",
        "UnwrappingBeanSerializer.java",
        "BasicDeserializerFactory.java",
        "BeanDeserializerFactory.java",
        "BuilderBasedDeserializer.java",
        "MapSerializer.java",
        "AnnotationIntrospectorPair.java",
        "BeanAsArrayDeserializer.java",
        "MapDeserializer.java",
        "BeanAsArraySerializer.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 118
  }
}
{
  "id": "66",
  "blame_commit": {
    "commit": {
      "commit_id": "33ba4ad08ee2220b62028101b026e29ed4167d52",
      "commit_message": "Added DeserializationContext.handleUnknownTypeId()",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2016-05-10 20:03:26",
      "commit_parent": "bd3c3121f1ecdc07f936fff99bbaa9dac42546dd"
    },
    "function": {
      "function_name": "_findDeserializer",
      "function_code_before": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [Databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; can not change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
      "function_code_after": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [Databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) { // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; can not change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
      "function_before_start_line": 140,
      "function_before_end_line": 180,
      "function_after_start_line": 140,
      "function_after_end_line": 187,
      "function_before_token_count": 148,
      "function_after_token_count": 171,
      "functions_name_modified_file": [
        "baseTypeName",
        "_findDefaultImplDeserializer",
        "getDefaultImpl",
        "toString",
        "getPropertyName",
        "_handleUnknownTypeId",
        "_findDeserializer",
        "getTypeIdResolver",
        "_deserializeWithNativeTypeId",
        "TypeDeserializerBase"
      ],
      "functions_name_all_files": [
        "getAnnotationIntrospector",
        "handleSecondaryContextualization",
        "toString",
        "parseDouble",
        "getArrayBuilders",
        "getValueClass",
        "readPropertyValue",
        "unknownTypeException",
        "_isNaN",
        "_parseShort",
        "getConfig",
        "reportMappingException",
        "_valueDesc",
        "_parseInteger",
        "_findDefaultImplDeserializer",
        "handleUnknownTypeId",
        "getDefaultImpl",
        "getDefaultPropertyFormat",
        "_deserializeWithNativeTypeId",
        "handlePrimaryContextualization",
        "isDefaultDeserializer",
        "_calcName",
        "determineClassName",
        "_findDeserializer",
        "findKeyDeserializer",
        "mappingException",
        "isEnabled",
        "getValueType",
        "isDefaultKeyDeserializer",
        "findClass",
        "reportUnknownProperty",
        "_parseString",
        "_hasTextualNull",
        "findConvertingContentDeserializer",
        "getLocale",
        "getParser",
        "hasSomeOfFeatures",
        "_isIntNumber",
        "_parseLong",
        "_parseBooleanPrimitive",
        "getTimeZone",
        "reportWeirdStringException",
        "getFactory",
        "DeserializationContext",
        "hasDeserializationFeatures",
        "canOverrideAccessModifiers",
        "findInjectableValue",
        "getContextualType",
        "_quotedString",
        "_parseByte",
        "_parseFloatPrimitive",
        "handleMissingEndArrayForSingle",
        "findNonContextualValueDeserializer",
        "handledType",
        "findDeserializer",
        "wrongTokenException",
        "handleUnknownProperty",
        "reportWrongTokenException",
        "_parseBoolean",
        "reportInstantiationException",
        "weirdNumberException",
        "setAttribute",
        "_parseShortPrimitive",
        "_parseDoublePrimitive",
        "_desc",
        "_parseBooleanFromOther",
        "_isPosInf",
        "StdDeserializer",
        "baseTypeName",
        "getTypeFactory",
        "_handleUnknownTypeId",
        "findFormatFeature",
        "_isNegInf",
        "weirdStringException",
        "getAttribute",
        "findRootValueDeserializer",
        "constructType",
        "getTypeIdResolver",
        "readValue",
        "deserializeWithType",
        "_failDoubleToIntCoercion",
        "constructCalendar",
        "_parseFloat",
        "getPropertyName",
        "_parseDouble",
        "instantiationException",
        "endOfInputException",
        "getNodeFactory",
        "reportEndOfInputException",
        "findContextualValueDeserializer",
        "TypeDeserializerBase",
        "weirdKeyException",
        "_parseDate",
        "hasValueDeserializerFor",
        "_parseIntPrimitive",
        "_coerceIntegral",
        "leaseObjectBuffer",
        "getDateFormat",
        "getActiveView",
        "_parseLongPrimitive",
        "findFormatOverrides",
        "reportWeirdNumberException",
        "handleWeirdKey",
        "parseDate",
        "_deserializeFromEmpty",
        "getDeserializationFeatures",
        "returnObjectBuffer",
        "getBase64Variant"
      ],
      "functions_name_co_evolved_modified_file": [
        "_handleUnknownTypeId",
        "_findDeserializer"
      ],
      "functions_name_co_evolved_all_files": [
        "handleUnknownTypeId",
        "handleWeirdKey",
        "_handleUnknownTypeId",
        "handleUnknownProperty",
        "_findDeserializer",
        "reportUnknownTypeException"
      ]
    },
    "file": {
      "file_name": "TypeDeserializerBase.java",
      "file_nloc": 157,
      "file_complexity": 29,
      "file_token_count": 1022,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -152,7 +152,14 @@ public abstract class TypeDeserializerBase\n                 // As per [JACKSON-614], use the default impl if no type id available:\n                 deser = _findDefaultImplDeserializer(ctxt);\n                 if (deser == null) {\n-                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n+                    // 10-May-2016, tatu: We may get some help...\n+                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n+                    if (actual == null) { // what should this be taken to mean?\n+                        // TODO: try to figure out something better\n+                        return null;\n+                    }\n+                    // ... would this actually work?\n+                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n                 /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n@@ -254,9 +261,9 @@ public abstract class TypeDeserializerBase\n      *   should return that deserializer; otherwise throw an exception to indicate\n      *   the problem.\n      *\n-     * @since 2.5\n+     * @since 2.8\n      */\n-    protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId,\n+    protected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId,\n             TypeIdResolver idResolver, JavaType baseType)\n         throws IOException\n     {\n@@ -271,7 +278,6 @@ public abstract class TypeDeserializerBase\n         } else {\n             extraDesc = null;\n         }\n-        ctxt.reportUnknownTypeException(_baseType, typeId, extraDesc);\n-        return null;\n+        return ctxt.handleUnknownTypeId(_baseType, typeId, extraDesc);\n     }\n }\n",
      "files_name_in_blame_commit": [
        "DeserializationProblemHandler.java",
        "DeserializationContext.java",
        "TypeDeserializerBase.java",
        "StdDeserializer.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 48
  }
}
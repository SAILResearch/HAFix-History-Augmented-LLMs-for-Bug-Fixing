{
  "id": "109",
  "blame_commit": {
    "commit": {
      "commit_id": "746892442f75845426e16f258d42498ad1de154b",
      "commit_message": "Ported numerics improvements in commons lang Fraction implementation.\nAdded utility methods for overflow-checked integer arithmetic and\nimproved gcd method in MathUtils.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@168072 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Phil Steitz",
      "commit_date": "2005-05-04 05:14:59",
      "commit_parent": "6a82146702f0f420879108d5d4d40a9297a03d4a"
    },
    "function": {
      "function_name": "gcd",
      "function_code_before": "",
      "function_code_after": "public static int gcd(int u, int v) {\n    if (u * v == 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u>0) { u=-u; } // make u negative\n    if (v>0) { v=-v; } // make v negative\n    // B1. [Find power of 2]\n    int k=0;\n    while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n        u/=2; v/=2; k++; // cast out twos.\n    }\n    if (k==31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    //     one is odd.\n    int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t&1)==0) { // while t is even..\n            t/=2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t>0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u)/2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t!=0);\n    return -u*(1<<k); // gcd is u*2^k\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 547,
      "function_after_end_line": 589,
      "function_before_token_count": 0,
      "function_after_token_count": 210,
      "functions_name_modified_file": [
        "indicator",
        "binomialCoefficientLog",
        "factorialLog",
        "mulAndCheck",
        "factorial",
        "round",
        "addAndCheck",
        "cosh",
        "lcm",
        "sign",
        "binomialCoefficient",
        "gcd",
        "sinh",
        "equals",
        "subAndCheck",
        "factorialDouble",
        "binomialCoefficientDouble",
        "MathUtils",
        "hash"
      ],
      "functions_name_all_files": [
        "floatValue",
        "testSignFloat",
        "testSignByte",
        "testIndicatorInt",
        "compareTo",
        "lcm",
        "sign",
        "testIndicatorDouble",
        "setUp",
        "findFactorialLimits",
        "longValue",
        "testDivide",
        "testSubtract",
        "testIndicatorFloat",
        "testMulAndCheck",
        "Fraction",
        "negate",
        "testHash",
        "multiply",
        "testMultiply",
        "testSignInt",
        "binomialCoefficientDouble",
        "indicator",
        "factorialLog",
        "addSub",
        "testIndicatorShort",
        "assertFraction",
        "testLcm",
        "binomialCoefficient",
        "divide",
        "testFactorialFail",
        "abs",
        "testSinh",
        "testSignDouble",
        "sinh",
        "getReducedFraction",
        "equals",
        "reduce",
        "add",
        "binomialCoefficientLog",
        "testRoundFloat",
        "testSubAndCheck",
        "testAbs",
        "doubleValue",
        "testFactorial",
        "testBinomialCoefficientFail",
        "cosh",
        "test0Choose0",
        "getDenominator",
        "testEquals",
        "testConstructor",
        "MathUtilsTest",
        "testBinomialCoefficient",
        "testCoshNaN",
        "testSignShort",
        "subtract",
        "testSinhNaN",
        "subAndCheck",
        "factorialDouble",
        "intValue",
        "reciprocal",
        "testSignLong",
        "mulAndCheck",
        "hashCode",
        "factorial",
        "testNegate",
        "testReciprocal",
        "round",
        "addAndCheck",
        "testIndicatorByte",
        "getNumerator",
        "testAdd",
        "findBinomialLimits",
        "gcd",
        "testConstructorDouble",
        "testAddAndCheck",
        "suite",
        "testIndicatorLong",
        "testCosh",
        "testRoundDouble",
        "testGcd",
        "MathUtils",
        "hash"
      ],
      "functions_name_co_evolved_modified_file": [
        "subAndCheck",
        "addAndCheck",
        "gcd",
        "mulAndCheck"
      ],
      "functions_name_co_evolved_all_files": [
        "add",
        "mulAndCheck",
        "testSubAndCheck",
        "testNegate",
        "addSub",
        "testReciprocal",
        "addAndCheck",
        "testAdd",
        "divide",
        "gcd",
        "testDivide",
        "testSubtract",
        "testAddAndCheck",
        "testMulAndCheck",
        "Fraction",
        "negate",
        "getReducedFraction",
        "subtract",
        "subAndCheck",
        "multiply",
        "testMultiply"
      ]
    },
    "file": {
      "file_name": "MathUtils.java",
      "file_nloc": 215,
      "file_complexity": 92,
      "file_token_count": 1654,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -535,31 +535,110 @@ public final class MathUtils {\n     }\n \n     /**\n-     * Returns the greatest common divisor between two integer values.\n-     * @param a the first integer value.\n-     * @param b the second integer value.\n-     * @return the greatest common divisor between a and b.\n+     * <p>Gets the greatest common divisor of the absolute value of\n+     * two numbers, using the \"binary gcd\" method which avoids\n+     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).</p>\n+     *\n+     * @param u  a non-zero number\n+     * @param v  a non-zero number\n+     * @return the greatest common divisor, never zero\n      */\n-    public static int gcd(int a, int b) {\n-        int ret;\n-        \n-        if (a == 0) {\n-            ret = Math.abs(b);\n-        } else if (b == 0) {\n-            ret = Math.abs(a);\n-        } else if (a < 0) {\n-            ret = gcd(-a, b);\n-        } else if (b < 0) {\n-            ret = gcd(a, -b);\n-        } else {\n-            int r = 0;\n-            while(b > 0){\n-                r = a % b;\n-                a = b;\n-                b = r;\n+    public static int gcd(int u, int v) {\n+        if (u * v == 0) {\n+            return (Math.abs(u) + Math.abs(v));\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u>0) { u=-u; } // make u negative\n+        if (v>0) { v=-v; } // make v negative\n+        // B1. [Find power of 2]\n+        int k=0;\n+        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n+            u/=2; v/=2; k++; // cast out twos.\n+        }\n+        if (k==31) {\n+            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        //     one is odd.\n+        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t&1)==0) { // while t is even..\n+                t/=2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t>0) {\n+                u = -t;\n+            } else {\n+                v = t;\n             }\n-            ret = a;\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u)/2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t!=0);\n+        return -u*(1<<k); // gcd is u*2^k\n+    }\n+\n+    /** \n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     *                             an int\n+     */\n+    public static int mulAndCheck(int x, int y) {\n+        long m = ((long)x)*((long)y);\n+        if (m < Integer.MIN_VALUE ||\n+                m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /** \n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    public static int addAndCheck(int x, int y) {\n+        long s = (long)x+(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+                s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /** \n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    public static int subAndCheck(int x, int y) {\n+        long s = (long)x-(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+                s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n         }\n-        return ret;\n+        return (int)s;\n     }\n }\n",
      "files_name_in_blame_commit": [
        "FractionTest.java",
        "Fraction.java",
        "MathUtils.java",
        "MathUtilsTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 50
  }
}
{
  "id": "49",
  "blame_commit": {
    "commit": {
      "commit_id": "4a6af4590838e8804290464a8d88a837acb2fa08",
      "commit_message": "[CSV-182] Allow some printing operations directly from CSVFormat. Adds APIs to CSVFormat so update version from 1.3.1-SNAPSHOT to 1.4-SNAPHOT a la semver. This commit refactors a small bit of guts code from CSVPrinter to CSVFormat.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1743430 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_date": "2016-05-11 21:09:48",
      "commit_parent": "21cb8b4750ca9356644e2e64655c6463bed47509"
    },
    "function": {
      "function_name": "printAndQuote",
      "function_code_before": "",
      "function_code_after": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // TODO where did this rule come from?\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 954,
      "function_after_end_line": 1059,
      "function_before_token_count": 0,
      "function_after_token_count": 430,
      "functions_name_modified_file": [
        "trim",
        "getEscapeCharacter",
        "printRecord",
        "toString",
        "getTrim",
        "println",
        "getIgnoreEmptyLines",
        "withFirstRecordAsHeader",
        "withIgnoreHeaderCase",
        "withIgnoreEmptyLines",
        "valueOf",
        "hashCode",
        "getFormat",
        "getNullString",
        "withEscape",
        "getQuoteCharacter",
        "withNullString",
        "getHeader",
        "toStringArray",
        "getAllowMissingColumnNames",
        "withTrim",
        "withQuote",
        "getHeaderComments",
        "withTrailingDelimiter",
        "printAndEscape",
        "isLineBreak",
        "getIgnoreHeaderCase",
        "parse",
        "isCommentMarkerSet",
        "withRecordSeparator",
        "withHeader",
        "withHeaderComments",
        "printAndQuote",
        "getDelimiter",
        "format",
        "getSkipHeaderRecord",
        "getQuoteMode",
        "validate",
        "withSkipHeaderRecord",
        "withDelimiter",
        "getTrailingDelimiter",
        "isEscapeCharacterSet",
        "print",
        "getRecordSeparator",
        "getCommentMarker",
        "Predefined",
        "isNullStringSet",
        "withAllowMissingColumnNames",
        "equals",
        "newFormat",
        "isQuoteCharacterSet",
        "withCommentMarker",
        "withQuoteMode",
        "withIgnoreSurroundingSpaces",
        "CSVFormat",
        "getIgnoreSurroundingSpaces"
      ],
      "functions_name_all_files": [
        "CSVPrinter",
        "trim",
        "getEscapeCharacter",
        "printRecord",
        "toString",
        "getTrim",
        "println",
        "getIgnoreEmptyLines",
        "withFirstRecordAsHeader",
        "withIgnoreHeaderCase",
        "withIgnoreEmptyLines",
        "valueOf",
        "hashCode",
        "getFormat",
        "getNullString",
        "withEscape",
        "getQuoteCharacter",
        "withNullString",
        "getHeader",
        "toStringArray",
        "getAllowMissingColumnNames",
        "withTrim",
        "withQuote",
        "printRecords",
        "getHeaderComments",
        "withTrailingDelimiter",
        "printAndEscape",
        "close",
        "isLineBreak",
        "getIgnoreHeaderCase",
        "parse",
        "isCommentMarkerSet",
        "withRecordSeparator",
        "withHeader",
        "withHeaderComments",
        "printAndQuote",
        "getDelimiter",
        "format",
        "getSkipHeaderRecord",
        "getQuoteMode",
        "validate",
        "withSkipHeaderRecord",
        "withDelimiter",
        "getTrailingDelimiter",
        "printComment",
        "flush",
        "isEscapeCharacterSet",
        "print",
        "getRecordSeparator",
        "getCommentMarker",
        "Predefined",
        "isNullStringSet",
        "withAllowMissingColumnNames",
        "getOut",
        "equals",
        "newFormat",
        "isQuoteCharacterSet",
        "withCommentMarker",
        "withQuoteMode",
        "withIgnoreSurroundingSpaces",
        "CSVFormat",
        "getIgnoreSurroundingSpaces"
      ],
      "functions_name_co_evolved_modified_file": [
        "trim",
        "printRecord",
        "println",
        "printAndEscape",
        "print",
        "printAndQuote"
      ],
      "functions_name_co_evolved_all_files": [
        "trim",
        "printRecord",
        "println",
        "printAndEscape",
        "print",
        "printAndQuote"
      ]
    },
    "file": {
      "file_name": "CSVFormat.java",
      "file_nloc": 666,
      "file_complexity": 204,
      "file_token_count": 4724,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -19,11 +19,13 @@ package org.apache.commons.csv;\n \n import static org.apache.commons.csv.Constants.BACKSLASH;\n import static org.apache.commons.csv.Constants.COMMA;\n+import static org.apache.commons.csv.Constants.COMMENT;\n import static org.apache.commons.csv.Constants.CR;\n import static org.apache.commons.csv.Constants.CRLF;\n import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\n import static org.apache.commons.csv.Constants.LF;\n import static org.apache.commons.csv.Constants.PIPE;\n+import static org.apache.commons.csv.Constants.SP;\n import static org.apache.commons.csv.Constants.TAB;\n \n import java.io.IOException;\n@@ -499,7 +501,8 @@ public final class CSVFormat implements Serializable {\n      *            TODO\n      * @param trim\n      *            TODO\n-     * @param trailingDelimiter TODO\n+     * @param trailingDelimiter\n+     *            TODO\n      * @throws IllegalArgumentException\n      *             if the delimiter is a line break character\n      */\n@@ -860,6 +863,242 @@ public final class CSVFormat implements Serializable {\n         return new CSVPrinter(out, this);\n     }\n \n+    /**\n+     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed. Useful when\n+     * one wants to avoid creating CSVPrinters.\n+     *\n+     * @param value\n+     *            value to be output.\n+     * @param out\n+     *            where to print the value\n+     * @param newRecord\n+     *            is this a new record\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.4\n+     */\n+    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n+        // null values are considered empty\n+        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n+        CharSequence charSequence;\n+        if (value == null) {\n+            charSequence = nullString == null ? Constants.EMPTY : nullString;\n+        } else {\n+            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n+        }\n+        charSequence = getTrim() ? trim(charSequence) : charSequence;\n+        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n+    }\n+\n+    private void print(final Object object, final CharSequence value, final int offset, final int len,\n+            final Appendable out, final boolean newRecord) throws IOException {\n+        if (!newRecord) {\n+            out.append(getDelimiter());\n+        }\n+        if (object == null) {\n+            out.append(value);\n+        } else if (isQuoteCharacterSet()) {\n+            // the original object is needed so can check for Number\n+            printAndQuote(object, value, offset, len, out, newRecord);\n+        } else if (isEscapeCharacterSet()) {\n+            printAndEscape(value, offset, len, out);\n+        } else {\n+            out.append(value, offset, offset + len);\n+        }\n+    }\n+\n+    /*\n+     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n+     */\n+    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n+            throws IOException {\n+        int start = offset;\n+        int pos = offset;\n+        final int end = offset + len;\n+\n+        final char delim = getDelimiter();\n+        final char escape = getEscapeCharacter().charValue();\n+\n+        while (pos < end) {\n+            char c = value.charAt(pos);\n+            if (c == CR || c == LF || c == delim || c == escape) {\n+                // write out segment up until this char\n+                if (pos > start) {\n+                    out.append(value, start, pos);\n+                }\n+                if (c == LF) {\n+                    c = 'n';\n+                } else if (c == CR) {\n+                    c = 'r';\n+                }\n+\n+                out.append(escape);\n+                out.append(c);\n+\n+                start = pos + 1; // start on the current char after this one\n+            }\n+\n+            pos++;\n+        }\n+\n+        // write last segment\n+        if (pos > start) {\n+            out.append(value, start, pos);\n+        }\n+    }\n+\n+    /*\n+     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n+     */\n+    // the original object is needed so can check for Number\n+    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n+            final Appendable out, final boolean newRecord) throws IOException {\n+        boolean quote = false;\n+        int start = offset;\n+        int pos = offset;\n+        final int end = offset + len;\n+\n+        final char delimChar = getDelimiter();\n+        final char quoteChar = getQuoteCharacter().charValue();\n+\n+        QuoteMode quoteModePolicy = getQuoteMode();\n+        if (quoteModePolicy == null) {\n+            quoteModePolicy = QuoteMode.MINIMAL;\n+        }\n+        switch (quoteModePolicy) {\n+        case ALL:\n+            quote = true;\n+            break;\n+        case NON_NUMERIC:\n+            quote = !(object instanceof Number);\n+            break;\n+        case NONE:\n+            // Use the existing escaping code\n+            printAndEscape(value, offset, len, out);\n+            return;\n+        case MINIMAL:\n+            if (len <= 0) {\n+                // always quote an empty token that is the first\n+                // on the line, as it may be the only thing on the\n+                // line. If it were not quoted in that case,\n+                // an empty line has no tokens.\n+                if (newRecord) {\n+                    quote = true;\n+                }\n+            } else {\n+                char c = value.charAt(pos);\n+\n+                // TODO where did this rule come from?\n+                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+                    quote = true;\n+                } else if (c <= COMMENT) {\n+                    // Some other chars at the start of a value caused the parser to fail, so for now\n+                    // encapsulate if we start in anything less than '#'. We are being conservative\n+                    // by including the default comment char too.\n+                    quote = true;\n+                } else {\n+                    while (pos < end) {\n+                        c = value.charAt(pos);\n+                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n+                            quote = true;\n+                            break;\n+                        }\n+                        pos++;\n+                    }\n+\n+                    if (!quote) {\n+                        pos = end - 1;\n+                        c = value.charAt(pos);\n+                        // Some other chars at the end caused the parser to fail, so for now\n+                        // encapsulate if we end in anything less than ' '\n+                        if (c <= SP) {\n+                            quote = true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (!quote) {\n+                // no encapsulation needed - write out the original value\n+                out.append(value, start, end);\n+                return;\n+            }\n+            break;\n+        default:\n+            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n+        }\n+\n+        if (!quote) {\n+            // no encapsulation needed - write out the original value\n+            out.append(value, start, end);\n+            return;\n+        }\n+\n+        // we hit something that needed encapsulation\n+        out.append(quoteChar);\n+\n+        // Pick up where we left off: pos should be positioned on the first character that caused\n+        // the need for encapsulation.\n+        while (pos < end) {\n+            final char c = value.charAt(pos);\n+            if (c == quoteChar) {\n+                // write out the chunk up until this point\n+\n+                // add 1 to the length to write out the encapsulator also\n+                out.append(value, start, pos + 1);\n+                // put the next starting position on the encapsulator so we will\n+                // write it out again with the next string (effectively doubling it)\n+                start = pos;\n+            }\n+            pos++;\n+        }\n+\n+        // write the last segment\n+        out.append(value, start, pos);\n+        out.append(quoteChar);\n+    }\n+\n+    /**\n+     * Outputs the record separator.\n+     *\n+     * @param out\n+     *            where to write\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.4\n+     */\n+    public void println(final Appendable out) throws IOException {\n+        if (getTrailingDelimiter()) {\n+            out.append(getDelimiter());\n+        }\n+        if (recordSeparator != null) {\n+            out.append(recordSeparator);\n+        }\n+    }\n+\n+    /**\n+     * Prints the given values a single record of delimiter separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n+     * </p>\n+     *\n+     * @param out where to write\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.4\n+     */\n+    public void printRecord(final Appendable out, final Object... values) throws IOException {\n+        for (int i = 0; i < values.length; i++) {\n+            print(values[i], out, i == 0);\n+        }\n+        println(out);\n+    }\n+\n     @Override\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n@@ -917,6 +1156,23 @@ public final class CSVFormat implements Serializable {\n         return strings;\n     }\n \n+    private CharSequence trim(final CharSequence charSequence) {\n+        if (charSequence instanceof String) {\n+            return ((String) charSequence).trim();\n+        }\n+        final int count = charSequence.length();\n+        int len = count;\n+        int pos = 0;\n+\n+        while ((pos < len) && (charSequence.charAt(pos) <= ' ')) {\n+            pos++;\n+        }\n+        while ((pos < len) && (charSequence.charAt(len - 1) <= ' ')) {\n+            len--;\n+        }\n+        return (pos > 0) || (len < count) ? charSequence.subSequence(pos, len) : charSequence;\n+    }\n+\n     /**\n      * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n      *\n@@ -1083,6 +1339,7 @@ public final class CSVFormat implements Serializable {\n      * <p>\n      * Calling this method is equivalent to calling:\n      * </p>\n+     *\n      * <pre>\n      * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n      * </pre>\n@@ -1114,8 +1371,8 @@ public final class CSVFormat implements Serializable {\n      * </p>\n      *\n      * @param headerEnum\n-     *              the enum defining the header, {@code null} if disabled, empty if parsed automatically, user\n-     *              specified otherwise.\n+     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n+     *            otherwise.\n      *\n      * @return A new CSVFormat that is equal to this but with the specified header\n      * @see #withHeader(String...)\n",
      "files_name_in_blame_commit": [
        "CSVPrinter.java",
        "CSVFormat.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 271
  }
}
{
  "id": "101",
  "blame_commit": {
    "commit": {
      "commit_id": "28257de1805aee7970a564677366a44a80ad9859",
      "commit_message": "added a clustering package with an implementation of k-means++\nJIRA: MATH-266\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@770979 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_date": "2009-05-02 19:34:51",
      "commit_parent": "d94d0a556a02af7a11bb93a73ecd3e614b9fcab0"
    },
    "function": {
      "function_name": "chooseInitialCenters",
      "function_code_before": "",
      "function_code_after": "    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n    // Choose one center uniformly at random from among the data points.\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        // For each data point x, compute D(x), the distance between x and \n        // the nearest center that has already been chosen.\n        int sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n\n        // Add one new data point as a center. Each point x is chosen with\n        // probability proportional to D(x)2\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n\n    return resultSet;\n\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 102,
      "function_after_end_line": 138,
      "function_before_token_count": 0,
      "function_after_token_count": 267,
      "functions_name_modified_file": [
        "chooseInitialCenters",
        "KMeansPlusPlusClusterer",
        "assignPointsToClusters",
        "cluster",
        "getNearestCluster"
      ],
      "functions_name_all_files": [
        "Cluster",
        "KMeansPlusPlusClusterer",
        "chooseInitialCenters",
        "equals",
        "assignPointsToClusters",
        "dimension2",
        "cluster",
        "getPoints",
        "centroidOf",
        "getPoint",
        "hashCode",
        "getNearestCluster",
        "getCenter",
        "distanceFrom",
        "addPoint",
        "EuclideanIntegerPoint"
      ],
      "functions_name_co_evolved_modified_file": [
        "KMeansPlusPlusClusterer",
        "chooseInitialCenters",
        "assignPointsToClusters",
        "cluster",
        "getNearestCluster"
      ],
      "functions_name_co_evolved_all_files": [
        "Cluster",
        "chooseInitialCenters",
        "KMeansPlusPlusClusterer",
        "equals",
        "assignPointsToClusters",
        "dimension2",
        "cluster",
        "getPoints",
        "hashCode",
        "getPoint",
        "centroidOf",
        "getNearestCluster",
        "getCenter",
        "distanceFrom",
        "addPoint",
        "EuclideanIntegerPoint"
      ]
    },
    "file": {
      "file_name": "KMeansPlusPlusClusterer.java",
      "file_nloc": 81,
      "file_complexity": 17,
      "file_token_count": 713,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+\n+/**\n+ * Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.\n+ * @see <a href=\"http://en.wikipedia.org/wiki/K-means%2B%2B\">K-means++ (wikipedia)</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n+\n+    /** Random generator for choosing initial centers. */\n+    private final Random random;\n+\n+    /** Build a clusterer.\n+     * @param random random generator to use for choosing initial centers\n+     */\n+    public KMeansPlusPlusClusterer(final Random random) {\n+        this.random = random;\n+    }\n+\n+    /**\n+     * Runs the K-means++ clustering algorithm.\n+     * \n+     * @param points the points to cluster\n+     * @param k the number of clusters to split the data into\n+     * @param maxIterations the maximum number of iterations to run the algorithm\n+     *     for.  If negative, no maximum will be used\n+     * @return a list of clusters containing the points\n+     */\n+    public List<Cluster<T>> cluster(final Collection<T> points,\n+                                    final int k, final int maxIterations) {\n+        // create the initial clusters\n+        List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\n+        assignPointsToClusters(clusters, points);\n+\n+        // iterate through updating the centers until we're done\n+        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; \n+        for (int count = 0; count < max; count++) {\n+            boolean clusteringChanged = false;\n+            List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n+            for (final Cluster<T> cluster : clusters) {\n+                final T newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\n+                if (!newCenter.equals(cluster.getCenter())) {\n+                    clusteringChanged = true;\n+                }\n+                newClusters.add(new Cluster<T>(newCenter));\n+            }\n+            if (!clusteringChanged) {\n+                return clusters;\n+            }\n+            assignPointsToClusters(newClusters, points);\n+            clusters = newClusters;\n+        }\n+        return clusters;\n+    }\n+\n+    /**\n+     * Adds the given points to the closest {@link Cluster}.\n+     * \n+     * @param clusters the {@link Cluster}s to add the points to\n+     * @param points the points to add to the given {@link Cluster}s\n+     */\n+    private static <T extends Clusterable<T>> void\n+        assignPointsToClusters(final Collection<Cluster<T>> clusters, final Collection<T> points) {\n+        for (final T p : points) {\n+            Cluster<T> cluster = getNearestCluster(clusters, p);\n+            cluster.addPoint(p);\n+        }\n+    }\n+\n+    /**\n+     * Use K-means++ to choose the initial centers.\n+     * \n+     * @param points the points to choose the initial centers from\n+     * @param k the number of centers to choose\n+     * @param random random generator to use\n+     * @return the initial centers\n+     */\n+    private static <T extends Clusterable<T>> List<Cluster<T>>\n+        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n+\n+        final List<T> pointSet = new ArrayList<T>(points);\n+        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n+\n+        // Choose one center uniformly at random from among the data points.\n+        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n+        resultSet.add(new Cluster<T>(firstPoint));\n+\n+        final double[] dx2 = new double[pointSet.size()];\n+        while (resultSet.size() < k) {\n+            // For each data point x, compute D(x), the distance between x and \n+            // the nearest center that has already been chosen.\n+            int sum = 0;\n+            for (int i = 0; i < pointSet.size(); i++) {\n+                final T p = pointSet.get(i);\n+                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n+                final double d = p.distanceFrom(nearest.getCenter());\n+                sum += d * d;\n+                dx2[i] = sum;\n+            }\n+\n+            // Add one new data point as a center. Each point x is chosen with\n+            // probability proportional to D(x)2\n+            final double r = random.nextDouble() * sum;\n+            for (int i = 0 ; i < dx2.length; i++) {\n+                if (dx2[i] >= r) {\n+                    final T p = pointSet.remove(i);\n+                    resultSet.add(new Cluster<T>(p));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return resultSet;\n+\n+    }\n+\n+    /**\n+     * Returns the nearest {@link Cluster} to the given point\n+     * \n+     * @param clusters the {@link Cluster}s to search\n+     * @param point the point to find the nearest {@link Cluster} for\n+     * @return the nearest {@link Cluster} to the given point\n+     */\n+    private static <T extends Clusterable<T>> Cluster<T>\n+        getNearestCluster(final Collection<Cluster<T>> clusters, final T point) {\n+        double minDistance = Double.MAX_VALUE;\n+        Cluster<T> minCluster = null;\n+        for (final Cluster<T> c : clusters) {\n+            final double distance = point.distanceFrom(c.getCenter());\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                minCluster = c;\n+            }\n+        }\n+        return minCluster;\n+    }\n+\n+}\n",
      "files_name_in_blame_commit": [
        "Clusterable.java",
        "KMeansPlusPlusClusterer.java",
        "Cluster.java",
        "EuclideanIntegerPoint.java",
        "KMeansPlusPlusClustererTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 7
  }
}
{
  "id": "97",
  "blame_commit": {
    "commit": {
      "commit_id": "03fa7c14316371f43c62dd486036be9145ab98d0",
      "commit_message": "A complete generic implementation of Binary Space Partitioning Trees (BSP trees)\nhas been added. A few specializations of this implementation are also provided\nfor 1D, 2D and 3D Euclidean geometry. This allows support for arbitrary\nintervals sets (1D), polygons sets (2D) and polyhedrons sets (3D) with all\nsets operations (union, intersection, symmetric difference, difference, complement),\nwith predicates (point inside/outside/on boundary, emptiness, other region contained),\nwith geometrical computation (barycenter, size, boundary size) and with conversions\nfrom and to boundary representation.\n\nJIRA: MATH-576\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1103438 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_date": "2011-05-15 16:02:05",
      "commit_parent": "e401d4ac0696c2dc62aa960044d9fd07bfc01ef9"
    },
    "function": {
      "function_name": "computeGeometricalProperties",
      "function_code_before": "",
      "function_code_after": "protected void computeGeometricalProperties() {\n\n    final Point2D[][] v = getVertices();\n\n    if (v.length == 0) {\n        if ((Boolean) getTree(false).getAttribute()) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Point2D.UNDEFINED);\n        } else {\n            setSize(0);\n            setBarycenter(new Point2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        // there is at least one open-loop: the polygon is infinite\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Point2D.UNDEFINED);\n    } else {\n        // all loops are closed, we compute some integrals around the shape\n\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n\n        for (Point2D[] loop : v) {\n            double x1 = loop[loop.length - 1].x;\n            double y1 = loop[loop.length - 1].y;\n            for (final Point2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.x;\n                y1 = point.y;\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n\n        if (sum < 0) {\n            // the polygon as a finite outside surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Point2D.UNDEFINED);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Point2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n\n    }\n\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 121,
      "function_after_end_line": 170,
      "function_before_token_count": 0,
      "function_after_token_count": 287,
      "functions_name_modified_file": [
        "buildNew",
        "PolygonsSet",
        "followLoop",
        "computeGeometricalProperties",
        "getVertices",
        "boxBoundary"
      ],
      "functions_name_all_files": [
        "BoundaryAttribute",
        "getFormat",
        "testQuaternion",
        "getY",
        "AVLTree",
        "testParsePositiveInfinity",
        "setFrame",
        "getSup",
        "getAvailableLocales",
        "BSPTree",
        "testOriginOffset",
        "testNormInf",
        "apply",
        "testNormalize",
        "firstIntersection",
        "encode",
        "testSimpleWithDecimalsTrunc",
        "testChoppedHexagon",
        "getInstance",
        "distanceInf",
        "getLargest",
        "getLength",
        "LocalizedFormats",
        "NestedLoops",
        "getNorm",
        "getDirection",
        "Point1D",
        "getMatrix",
        "testNegativeZ",
        "testDistance",
        "copySelf",
        "isInside",
        "getHyperplane",
        "hasIn",
        "applyTransform",
        "setOriginOffset",
        "getNotLarger",
        "recurseList",
        "getNext",
        "translateToPoint",
        "testBox",
        "testPointAt",
        "testScalarProduct",
        "value",
        "testEmptyDifference",
        "testOppositeHyperplanes",
        "OrderedTuple",
        "getLocalizedString",
        "BoundarySizeVisitor",
        "getEnd",
        "PolyhedronsSet",
        "Vector3DFormat",
        "getAbscissa",
        "testTetrahedron",
        "testDistanceInf",
        "testNan",
        "angle",
        "getDecimalCharacter",
        "testParseNan",
        "recurseFirstIntersection",
        "testContains",
        "getQ0",
        "getRemainingRegion",
        "recurseComplement",
        "testNegativeX",
        "testSingularities",
        "correctOrientation",
        "boxBoundary",
        "insertCut",
        "testDifference",
        "crossProduct",
        "testParseNegativeZ",
        "testForgottenPrefix",
        "hashCode",
        "toSubSpace",
        "testDistance1",
        "scalarMultiply",
        "testPositiveInfinity",
        "getDelta",
        "Interval",
        "rotate",
        "SubHyperplane",
        "checkAngle",
        "Sides",
        "reset",
        "fitToCell",
        "testDelete1",
        "testVectorOnePair",
        "testLineIntersection",
        "testCrossProductCancellation",
        "testDistanceSq",
        "getQ2",
        "Vector3DFormatAbstractTest",
        "testCompose",
        "getAlpha",
        "getSeparator",
        "testMatrix",
        "rememberMinusFound",
        "testIntersection",
        "computeLSB",
        "getOut",
        "testAxisAngle",
        "getUpper",
        "testNegativeY",
        "testInfinite",
        "RotationTransform",
        "orthogonal",
        "getLower",
        "testThreePoints",
        "intersectionAbscissa",
        "applyTo",
        "getLocation",
        "side",
        "setBarycenter",
        "testInterval",
        "recurseTransform",
        "translate",
        "getQ1",
        "testSimilar",
        "getCell",
        "normalize",
        "rotateCCW",
        "add",
        "buildHalfLine",
        "testRepetition",
        "setNormal",
        "testOrthogonal",
        "testAngle",
        "getBoundarySize",
        "getFieldName",
        "getPrevious",
        "rebalanceLeftGrown",
        "getZ",
        "difference",
        "testSimplyConnected",
        "getOffset",
        "testTransform",
        "Line",
        "checkVector",
        "getMidPoint",
        "buildLine",
        "getAttribute",
        "toSpace",
        "followLoop",
        "isSimilarTo",
        "getPlusOutside",
        "IntervalsSet",
        "revertSelf",
        "tesNegativeInfinity",
        "testUnion",
        "applyInverseTo",
        "getV",
        "condense",
        "getNormal",
        "getTransform",
        "testSimpleWithDecimals",
        "testIntersection3",
        "Point3D",
        "testAdd",
        "rememberPlusFound",
        "characterize",
        "format",
        "getPlusInside",
        "rotateCW",
        "getA2",
        "split",
        "Characterization",
        "checkOrder",
        "testParseSimpleWithDecimals",
        "testDisjointPolygons",
        "getSuffix",
        "isInfinite",
        "getReverse",
        "getPointAt",
        "checkPoints",
        "Point2D",
        "setSize",
        "sign",
        "testForgottenSuffix",
        "revert",
        "chopOffPlus",
        "LineTransform",
        "testBug20040520",
        "testUnlimitedSubHyperplane",
        "negate",
        "getA3",
        "getOriginOffset",
        "testTranslate",
        "SegmentsBuilder",
        "union",
        "Segment",
        "boundaryFacet",
        "distanceSq",
        "chopOffMinus",
        "Region",
        "setClockWise",
        "intersection",
        "testSimpleNoDecimals",
        "testParseIgnoredWhitespace",
        "testName",
        "dotProduct",
        "minusFound",
        "getNormInf",
        "delete",
        "merge",
        "visit",
        "mantissa",
        "testNorm1",
        "visitInternalNode",
        "checkRotation",
        "Vector3D",
        "getSize",
        "distance",
        "getPlus",
        "buildConvex",
        "setAttribute",
        "SplitSubHyperplane",
        "testSearch",
        "testNavigation",
        "BoundaryProjector",
        "testConstructorSingleFormat",
        "getU",
        "testParseNegativeY",
        "getSourceString",
        "rebalanceRightGrown",
        "buildTree",
        "orthogonalizeMatrix",
        "sameOrientationAs",
        "getA1",
        "subtract",
        "getNotSmaller",
        "testBuildBox",
        "OrientedPoint",
        "getPrefix",
        "buildSet",
        "testComposeInverse",
        "visitOrder",
        "wholeHyperplane",
        "testAngular",
        "testParallel",
        "testParseNegativeInfinity",
        "testXor",
        "testAngularSeparation",
        "testVectorTwoPairs",
        "getSorted",
        "recurseSides",
        "getAngles",
        "size",
        "testParseZeroX",
        "PolygonsSet",
        "rebalanceRightShrunk",
        "testApplyInverseTo",
        "testConcentric",
        "getStart",
        "computeGeometricalProperties",
        "pointIsBetween",
        "rebalanceLeftShrunk",
        "getNorm1",
        "getOrigin",
        "testIdentity",
        "getOutline",
        "getNormSq",
        "testPoint",
        "toString",
        "checkInSegment",
        "getMinus",
        "asList",
        "getInf",
        "compareTo",
        "testNonDefaultSetting",
        "addContribution",
        "getVertices",
        "recurseIntersection",
        "getBarycenter",
        "insertInTree",
        "testDefaultFormatVector3D",
        "getCut",
        "testCross",
        "DummyRegion",
        "testIntersection2",
        "distance1",
        "testSubtract",
        "checkVertices",
        "getX",
        "testMultiple",
        "wholeSpace",
        "getLine",
        "getProjected",
        "hasOut",
        "exponent",
        "Plane",
        "computeMSB",
        "getIn",
        "getLocale",
        "testPointDistance",
        "testRotate",
        "testAngles",
        "isParallelTo",
        "getBit",
        "testVectorialProducts",
        "testIsometry",
        "testCoordinates",
        "getComplement",
        "testConstructors",
        "RotationOrder",
        "testParseNonDefaultSetting",
        "getComponents",
        "testOffset",
        "equals",
        "insertCuts",
        "getAxis",
        "testParseSimpleNoDecimals",
        "CardanEulerSingularityException",
        "OutlineExtractor",
        "testStair",
        "testSingularPoint",
        "buildNew",
        "TranslationTransform",
        "getParent",
        "testRevert",
        "recurseBuildBoundary",
        "isNaN",
        "testAbscissa",
        "xor",
        "getAngle",
        "testInsert",
        "isDirect",
        "contains",
        "setAngle",
        "testParseSimpleWithDecimalsTrunc",
        "plusFound",
        "getTree",
        "getElement",
        "visitLeafNode",
        "testNorm",
        "insert",
        "getSmallest",
        "testLineDistance",
        "NotARotationMatrixException",
        "Rotation",
        "parse",
        "checkPoint",
        "FacetsContributionVisitor",
        "isEmpty",
        "testForgottenSeparator",
        "testParseNegativeX",
        "testBug20041003",
        "testParseNegativeAll",
        "Node",
        "testHole",
        "getQ3",
        "buildSegment"
      ],
      "functions_name_co_evolved_modified_file": [
        "buildNew",
        "PolygonsSet",
        "followLoop",
        "computeGeometricalProperties",
        "getVertices",
        "boxBoundary"
      ],
      "functions_name_co_evolved_all_files": [
        "getOutline",
        "fitToCell",
        "testPoint",
        "testDelete1",
        "testDisjointPolygons",
        "BoundaryAttribute",
        "checkInSegment",
        "testLineIntersection",
        "getMinus",
        "asList",
        "getInf",
        "getReverse",
        "compareTo",
        "getPointAt",
        "checkPoints",
        "Point2D",
        "AVLTree",
        "setSize",
        "sign",
        "buildSegment",
        "setFrame",
        "getSup",
        "addContribution",
        "getVertices",
        "recurseIntersection",
        "BSPTree",
        "getBarycenter",
        "insertInTree",
        "getCut",
        "chopOffPlus",
        "testCross",
        "testOriginOffset",
        "DummyRegion",
        "testIntersection2",
        "LineTransform",
        "checkVertices",
        "testBug20040520",
        "testUnlimitedSubHyperplane",
        "testMultiple",
        "wholeSpace",
        "apply",
        "getLine",
        "firstIntersection",
        "rememberMinusFound",
        "getProjected",
        "encode",
        "hasOut",
        "testIntersection",
        "getOriginOffset",
        "exponent",
        "computeLSB",
        "testTranslate",
        "SegmentsBuilder",
        "union",
        "getOut",
        "Plane",
        "Segment",
        "testChoppedHexagon",
        "computeMSB",
        "boundaryFacet",
        "getUpper",
        "getLength",
        "getIn",
        "getLargest",
        "testPointDistance",
        "testRotate",
        "NestedLoops",
        "chopOffMinus",
        "Region",
        "setClockWise",
        "intersection",
        "isParallelTo",
        "getBit",
        "testInfinite",
        "RotationTransform",
        "testIsometry",
        "getDirection",
        "Point1D",
        "getLower",
        "getComplement",
        "copySelf",
        "testThreePoints",
        "intersectionAbscissa",
        "minusFound",
        "delete",
        "merge",
        "isInside",
        "getLocation",
        "visit",
        "getHyperplane",
        "mantissa",
        "side",
        "hasIn",
        "applyTransform",
        "setBarycenter",
        "testInterval",
        "recurseTransform",
        "visitInternalNode",
        "setOriginOffset",
        "getComponents",
        "getNotLarger",
        "recurseList",
        "testOffset",
        "equals",
        "translate",
        "insertCuts",
        "getNext",
        "testSimilar",
        "translateToPoint",
        "getCell",
        "testBox",
        "getSize",
        "OutlineExtractor",
        "testPointAt",
        "testSingularPoint",
        "buildNew",
        "distance",
        "testStair",
        "rotateCCW",
        "add",
        "testEmptyDifference",
        "getPlus",
        "TranslationTransform",
        "getParent",
        "setAttribute",
        "buildConvex",
        "OrderedTuple",
        "testOppositeHyperplanes",
        "buildHalfLine",
        "SplitSubHyperplane",
        "BoundarySizeVisitor",
        "recurseBuildBoundary",
        "testRepetition",
        "setNormal",
        "getEnd",
        "testSearch",
        "testNavigation",
        "PolyhedronsSet",
        "BoundaryProjector",
        "getAbscissa",
        "getBoundarySize",
        "testTetrahedron",
        "testAbscissa",
        "xor",
        "getU",
        "getPrevious",
        "getAngle",
        "rebalanceLeftGrown",
        "difference",
        "testInsert",
        "isDirect",
        "testSimplyConnected",
        "contains",
        "setAngle",
        "rebalanceRightGrown",
        "getOffset",
        "buildTree",
        "recurseFirstIntersection",
        "testContains",
        "sameOrientationAs",
        "Line",
        "recurseComplement",
        "getMidPoint",
        "getRemainingRegion",
        "testTransform",
        "buildLine",
        "getAttribute",
        "toSpace",
        "followLoop",
        "getNotSmaller",
        "correctOrientation",
        "plusFound",
        "boxBoundary",
        "insertCut",
        "testBuildBox",
        "getTree",
        "isSimilarTo",
        "getPlusOutside",
        "OrientedPoint",
        "testDifference",
        "IntervalsSet",
        "revertSelf",
        "testUnion",
        "buildSet",
        "getElement",
        "visitLeafNode",
        "visitOrder",
        "hashCode",
        "wholeHyperplane",
        "toSubSpace",
        "insert",
        "getSmallest",
        "getV",
        "testParallel",
        "value",
        "testLineDistance",
        "condense",
        "getNormal",
        "testXor",
        "getTransform",
        "testIntersection3",
        "Point3D",
        "getSorted",
        "rememberPlusFound",
        "characterize",
        "recurseSides",
        "size",
        "checkPoint",
        "Interval",
        "FacetsContributionVisitor",
        "PolygonsSet",
        "getPlusInside",
        "isEmpty",
        "rotateCW",
        "rebalanceRightShrunk",
        "testConcentric",
        "rotate",
        "SubHyperplane",
        "getStart",
        "computeGeometricalProperties",
        "pointIsBetween",
        "rebalanceLeftShrunk",
        "testBug20041003",
        "split",
        "Node",
        "getOrigin",
        "Characterization",
        "checkOrder",
        "Sides",
        "testHole",
        "reset"
      ]
    },
    "file": {
      "file_name": "PolygonsSet.java",
      "file_nloc": 186,
      "file_complexity": 38,
      "file_token_count": 1629,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n+import org.apache.commons.math.util.FastMath;\n+\n+/** This class represents a 2D region: a set of polygons.\n+ * @version $Revision$ $Date$\n+ */\n+public class PolygonsSet extends Region {\n+\n+    /** Vertices organized as boundary loops. */\n+    private Point2D[][] vertices;\n+\n+    /** Build a polygons set representing the whole real line.\n+     */\n+    public PolygonsSet() {\n+        super();\n+    }\n+\n+    /** Build a polygons set from a BSP tree.\n+     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n+     * {@code Boolean} attribute representing the inside status of\n+     * the corresponding cell (true for inside cells, false for outside\n+     * cells). In order to avoid building too many small objects, it is\n+     * recommended to use the predefined constants\n+     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * @param tree inside/outside BSP tree representing the region\n+     */\n+    public PolygonsSet(final BSPTree tree) {\n+        super(tree);\n+    }\n+\n+    /** Build a polygons set from a Boundary REPresentation (B-rep).\n+     * <p>The boundary is provided as a collection of {@link\n+     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n+     * interior part of the region on its minus side and the exterior on\n+     * its plus side.</p>\n+     * <p>The boundary elements can be in any order, and can form\n+     * several non-connected sets (like for example polygons with holes\n+     * or a set of disjoints polyhedrons considered as a whole). In\n+     * fact, the elements do not even need to be connected together\n+     * (their topological connections are not used here). However, if the\n+     * boundary does not really separate an inside open from an outside\n+     * open (open having here its topological meaning), then subsequent\n+     * calls to the {@link\n+     * Region#checkPoint(org.apache.commons.math.geometry.partitioning.Point)\n+     * checkPoint} method will not be meaningful anymore.</p>\n+     * <p>If the boundary is empty, the region will represent the whole\n+     * space.</p>\n+     * @param boundary collection of boundary elements, as a\n+     * collection of {@link SubHyperplane SubHyperplane} objects\n+     */\n+    public PolygonsSet(final Collection<SubHyperplane> boundary) {\n+        super(boundary);\n+    }\n+\n+    /** Build a parallellepipedic box.\n+     * @param xMin low bound along the x direction\n+     * @param xMax high bound along the x direction\n+     * @param yMin low bound along the y direction\n+     * @param yMax high bound along the y direction\n+     */\n+    public PolygonsSet(final double xMin, final double xMax,\n+                       final double yMin, final double yMax) {\n+        this(buildConvex(boxBoundary(xMin, xMax, yMin, yMax)).getTree(false));\n+    }\n+\n+    /** Create a list of hyperplanes representing the boundary of a box.\n+     * @param xMin low bound along the x direction\n+     * @param xMax high bound along the x direction\n+     * @param yMin low bound along the y direction\n+     * @param yMax high bound along the y direction\n+     * @return boundary of the box\n+     */\n+    private static List<Hyperplane> boxBoundary(final double xMin, final double xMax,\n+                                                final double yMin, final double yMax) {\n+        final Point2D minMin = new Point2D(xMin, yMin);\n+        final Point2D minMax = new Point2D(xMin, yMax);\n+        final Point2D maxMin = new Point2D(xMax, yMin);\n+        final Point2D maxMax = new Point2D(xMax, yMax);\n+        return Arrays.asList(new Hyperplane[] {\n+            new Line(minMin, maxMin),\n+            new Line(maxMin, maxMax),\n+            new Line(maxMax, minMax),\n+            new Line(minMax, minMin)\n+        });\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Region buildNew(final BSPTree tree) {\n+        return new PolygonsSet(tree);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeGeometricalProperties() {\n+\n+        final Point2D[][] v = getVertices();\n+\n+        if (v.length == 0) {\n+            if ((Boolean) getTree(false).getAttribute()) {\n+                setSize(Double.POSITIVE_INFINITY);\n+                setBarycenter(Point2D.UNDEFINED);\n+            } else {\n+                setSize(0);\n+                setBarycenter(new Point2D(0, 0));\n+            }\n+        } else if (v[0][0] == null) {\n+            // there is at least one open-loop: the polygon is infinite\n+            setSize(Double.POSITIVE_INFINITY);\n+            setBarycenter(Point2D.UNDEFINED);\n+        } else {\n+            // all loops are closed, we compute some integrals around the shape\n+\n+            double sum  = 0;\n+            double sumX = 0;\n+            double sumY = 0;\n+\n+            for (Point2D[] loop : v) {\n+                double x1 = loop[loop.length - 1].x;\n+                double y1 = loop[loop.length - 1].y;\n+                for (final Point2D point : loop) {\n+                    final double x0 = x1;\n+                    final double y0 = y1;\n+                    x1 = point.x;\n+                    y1 = point.y;\n+                    final double factor = x0 * y1 - y0 * x1;\n+                    sum  += factor;\n+                    sumX += factor * (x0 + x1);\n+                    sumY += factor * (y0 + y1);\n+                }\n+            }\n+\n+            if (sum < 0) {\n+                // the polygon as a finite outside surrounded by an infinite inside\n+                setSize(Double.POSITIVE_INFINITY);\n+                setBarycenter(Point2D.UNDEFINED);\n+            } else {\n+                setSize(sum / 2);\n+                setBarycenter(new Point2D(sumX / (3 * sum), sumY / (3 * sum)));\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** Get the vertices of the polygon.\n+     * <p>The polygon boundary can be represented as an array of loops,\n+     * each loop being itself an array of vertices.</p>\n+     * <p>In order to identify open loops which start and end by\n+     * infinite edges, the open loops arrays start with a null point. In\n+     * this case, the first non null point and the last point of the\n+     * array do not represent real vertices, they are dummy points\n+     * intended only to get the direction of the first and last edge. An\n+     * open loop consisting of a single infinite line will therefore be\n+     * represented by a three elements array with one null point\n+     * followed by two dummy points. The open loops are always the first\n+     * ones in the loops array.</p>\n+     * <p>If the polygon has no boundary at all, a zero length loop\n+     * array will be returned.</p>\n+     * <p>All line segments in the various loops have the inside of the\n+     * region on their left side and the outside on their right side\n+     * when moving in the underlying line direction. This means that\n+     * closed loops surrounding finite areas obey the direct\n+     * trigonometric orientation.</p>\n+     * @return vertices of the polygon, organized as oriented boundary\n+     * loops with the open loops first (the returned value is guaranteed\n+     * to be non-null)\n+     */\n+    public Point2D[][] getVertices() {\n+        if (vertices == null) {\n+            if (getTree(false).getCut() == null) {\n+                vertices = new Point2D[0][];\n+            } else {\n+\n+                // sort the segmfinal ents according to their start point\n+                final SegmentsBuilder visitor = new SegmentsBuilder();\n+                getTree(true).visit(visitor);\n+                final AVLTree<Segment> sorted = visitor.getSorted();\n+\n+                // identify the loops, starting from the open ones\n+                // (their start segments final are naturally at the sorted set beginning)\n+                final ArrayList<List<Segment>> loops = new ArrayList<List<Segment>>();\n+                while (!sorted.isEmpty()) {\n+                    final AVLTree<Segment>.Node node = sorted.getSmallest();\n+                    final List<Segment> loop = followLoop(node, sorted);\n+                    if (loop != null) {\n+                        loops.add(loop);\n+                    }\n+                }\n+\n+                // tranform the loops in an array of arrays of points\n+                vertices = new Point2D[loops.size()][];\n+                int i = 0;\n+\n+                for (final List<Segment> loop : loops) {\n+                    if (loop.size() < 2) {\n+                        // sifinal ngle infinite line\n+                        final Line line = ((Segment) loop.get(0)).getLine();\n+                        vertices[i++] = new Point2D[] {\n+                            null,\n+                            (Point2D) line.toSpace(new Point1D(-Float.MAX_VALUE)),\n+                            (Point2D) line.toSpace(new Point1D(+Float.MAX_VALUE))\n+                        };\n+                    } else if (((Segment) loop.get(0)).getStart() == null) {\n+                        // open lofinal op with at least one real point\n+                        final Point2D[] array = new Point2D[loop.size() + 2];\n+                        int j = 0;\n+                        for (Segment segment : loop) {\n+\n+                            if (j == 0) {\n+                                // null point and first dummy point\n+                                double x =\n+                                    ((Point1D) segment.getLine().toSubSpace(segment.getEnd())).getAbscissa();\n+                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n+                                array[j++] = null;\n+                                array[j++] = (Point2D) segment.getLine().toSpace(new Point1D(x));\n+                            }\n+\n+                            if (j < (array.length - 1)) {\n+                                // current point\n+                                array[j++] = segment.getEnd();\n+                            }\n+\n+                            if (j == (array.length - 1)) {\n+                                // last dummy point\n+                                double x =\n+                                    ((Point1D) segment.getLine().toSubSpace(segment.getStart())).getAbscissa();\n+                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n+                                array[j++] = (Point2D) segment.getLine().toSpace(new Point1D(x));\n+                            }\n+\n+                        }\n+                        vertices[i++] = array;\n+                    } else {\n+                        final Point2D[] array = new Point2D[loop.size()];\n+                        int j = 0;\n+                        for (Segment segment : loop) {\n+                            array[j++] = segment.getStart();\n+                        }\n+                        vertices[i++] = array;\n+                    }\n+                }\n+\n+            }\n+        }\n+\n+        return vertices.clone();\n+\n+    }\n+\n+    /** Follow a boundary loop.\n+     * @param node node containing the segment starting the loop\n+     * @param sorted set of segments belonging to the boundary, sorted by\n+     * start points (contains {@code node})\n+     * @return a list of connected sub-hyperplanes starting at\n+     * {@code node}\n+     */\n+    private List<Segment> followLoop(final AVLTree<Segment>.Node node,\n+                                     final AVLTree<Segment> sorted) {\n+\n+        final ArrayList<Segment> loop = new ArrayList<Segment>();\n+        Segment segment = (Segment) node.getElement();\n+        loop.add(segment);\n+        final Point2D globalStart = segment.getStart();\n+        Point2D end = segment.getEnd();\n+        node.delete();\n+\n+        // is this an open or a closed loop ?\n+        final boolean open = segment.getStart() == null;\n+\n+        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n+\n+            // search the sub-hyperplane starting where the previous one ended\n+            AVLTree<Segment>.Node selectedNode = null;\n+            Segment       selectedSegment  = null;\n+            double        selectedDistance = Double.POSITIVE_INFINITY;\n+            final Segment lowerLeft        = new Segment(end, -1.0e-10, -1.0e-10);\n+            final Segment upperRight       = new Segment(end, +1.0e-10, +1.0e-10);\n+            for (AVLTree<Segment>.Node n = sorted.getNotSmaller(lowerLeft);\n+                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n+                 n = n.getNext()) {\n+                segment = (Segment) n.getElement();\n+                final double distance = end.distance(segment.getStart());\n+                if (distance < selectedDistance) {\n+                    selectedNode     = n;\n+                    selectedSegment  = segment;\n+                    selectedDistance = distance;\n+                }\n+            }\n+\n+            if (selectedDistance > 1.0e-10) {\n+                // this is a degenerated loop, it probably comes from a very\n+                // tiny region with some segments smaller than the threshold, we\n+                // simply ignore it\n+                return null;\n+            }\n+\n+            end = selectedSegment.getEnd();\n+            loop.add(selectedSegment);\n+            selectedNode.delete();\n+\n+        }\n+\n+        if ((loop.size() == 2) && !open) {\n+            // this is a degenerated infinitely thin loop, we simply ignore it\n+            return null;\n+        }\n+\n+        if ((end == null) && !open) {\n+            throw new RuntimeException(\"internal error\");\n+        }\n+\n+        return loop;\n+\n+    }\n+\n+}\n",
      "files_name_in_blame_commit": [
        "RotationOrderTest.java",
        "Line.java",
        "Point3D.java",
        "PlaneTest.java",
        "PolyhedronsSet.java",
        "LocalizedFormats.java",
        "Transform.java",
        "Vector3DTest.java",
        "PolygonsSet.java",
        "Region.java",
        "Point1D.java",
        "RotationTest.java",
        "Hyperplane.java",
        "OrderedTuple.java",
        "Rotation.java",
        "FrenchVector3DFormatTest.java",
        "SubSpace.java",
        "PolyhedronsSetTest.java",
        "AVLTreeTest.java",
        "LineTest.java",
        "Point2D.java",
        "BSPTree.java",
        "CardanEulerSingularityException.java",
        "Characterization.java",
        "Interval.java",
        "IntervalsSetTest.java",
        "NestedLoops.java",
        "Point.java",
        "Vector3D.java",
        "SegmentBuilder.java",
        "BSPTreeVisitor.java",
        "Vector3DFormatAbstractTest.java",
        "IntervalsSet.java",
        "Segment.java",
        "SubHyperplane.java",
        "NotARotationMatrixException.java",
        "OrientedPoint.java",
        "Vector3DFormat.java",
        "AVLTree.java",
        "OutlineExtractor.java",
        "Plane.java",
        "Vector3DFormatTest.java",
        "PolygonsSetTest.java",
        "RotationOrder.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 9
  }
}
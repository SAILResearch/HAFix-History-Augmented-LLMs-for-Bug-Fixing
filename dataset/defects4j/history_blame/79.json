{
  "id": "79",
  "blame_commit": {
    "commit": {
      "commit_id": "5000be31966a575f54d80ef85ee49ca1f5cb6ea8",
      "commit_message": "First draft of a simple XML treebuilder / parser.\n\nThis provides an alternative to the HTML5 parser which enforces HTML\nsemantics on the parsed input. The simple XML parser has no understanding\nof HTML, and will parse the input as-is into a DOM.",
      "commit_author": "Jonathan Hedley",
      "commit_date": "2012-02-26 17:23:10",
      "commit_parent": "1e84edbe208aab0c9330eadc50f9773d81d70cd6"
    },
    "function": {
      "function_name": "popStackToClose",
      "function_code_before": "",
      "function_code_after": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n\n    Iterator<Element> it = stack.descendingIterator();\n    while (it.hasNext()) {\n        Element next = it.next();\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    it = stack.descendingIterator();\n    while (it.hasNext()) {\n        Element next = it.next();\n        if (next == firstFound) {\n            it.remove();\n            break;\n        } else {\n            it.remove();\n        }\n    }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 85,
      "function_after_end_line": 110,
      "function_before_token_count": 0,
      "function_after_token_count": 135,
      "functions_name_modified_file": [
        "insertNode",
        "process",
        "initialiseParse",
        "popStackToClose",
        "insert"
      ],
      "functions_name_all_files": [
        "getStack",
        "parsesSimpleDocument",
        "toString",
        "aboveOnStack",
        "inTableScope",
        "ignoresDupeEndTrTag",
        "setFosterInserts",
        "handlesBaseWithoutHref",
        "exitTableBody",
        "popStackToBefore",
        "generateImpliedEndTags",
        "resetInsertionMode",
        "state",
        "handlesSolidusAtAttributeEnd",
        "testSimpleXmlParse",
        "getFromStack",
        "initialiseParse",
        "pushActiveFormattingElements",
        "clearStackToTableContext",
        "handlesCdata",
        "createsStructureFromBodySnippet",
        "handlesTbodyTable",
        "discardsNakedTds",
        "handleMissingTr",
        "findsCharsetInMalformedMeta",
        "testRelaxedTags",
        "testSpaceAfterTag",
        "handlesTextAfterData",
        "replaceActiveFormattingElement",
        "handlesEscapedScript",
        "handlesUnknownTags",
        "handlesMisnestedTagsBI",
        "getDocument",
        "getHeadElement",
        "noImplicitFormForTextAreas",
        "normalisesHeadlessBody",
        "handlesEscapedData",
        "HtmlTreeBuilder",
        "markInsertionMode",
        "handlesInvalidStartTags",
        "maybeSetBaseUri",
        "testHeaderContents",
        "testSpanContents",
        "transition",
        "framesetOk",
        "getFormElement",
        "clearStackToTableRowContext",
        "testNoImagesInNoScriptInHead",
        "getBaseUri",
        "insertInFosterParent",
        "testAFlowContents",
        "handlesWhitespaceInoDocType",
        "clearStackToTableBodyContext",
        "testHgroup",
        "insertNode",
        "pop",
        "handlesUnclosedDefinitionLists",
        "handlesNullInData",
        "handlesSolidusInA",
        "handlesTextArea",
        "error",
        "popStackToClose",
        "runParser",
        "normalisesDocument",
        "originalState",
        "currentElement",
        "dropsUnterminatedTag",
        "doesNotCreateImplicitLists",
        "handlesWhatWgExpensesTableExample",
        "parsesRoughAttributes",
        "handlesImplicitCaptionClose",
        "handlesUnclosedRawtextAtEof",
        "anythingElse",
        "setPendingTableCharacters",
        "handlesBaseTags",
        "handlesSpanInTbody",
        "clearFormattingElementsToLastMarker",
        "push",
        "handlesUnknownInlineTags",
        "newPendingTableCharacters",
        "handlesMisnestedTagsBP",
        "parsesComments",
        "noTableDirectInTable",
        "handlesUnknownNamespaceTags",
        "normalisedBodyAfterContent",
        "removeFromStack",
        "handlesJavadocFont",
        "handlesFrames",
        "closeCell",
        "insertMarkerToFormattingElements",
        "inScope",
        "commentBeforeHtml",
        "testFontFlowContents",
        "handlesNestedImplicitTable",
        "clearStackToContext",
        "isFosterInserts",
        "handlesUnclosedTitleAtEof",
        "inButtonScope",
        "handlesKnownEmptyBlocks",
        "parsesUnterminatedComments",
        "onStack",
        "handles0CharacterAsText",
        "normalisesEmptyDocument",
        "handleRawtext",
        "insertOnStackAfter",
        "getActiveFormattingElement",
        "handlesMultiClosingBody",
        "handlesNullInComments",
        "isSameFormattingElement",
        "handlesUnclosedTitle",
        "parsesQuiteRoughAttributes",
        "inSpecificScope",
        "reconstructFormattingElementsInTable",
        "inSelectScope",
        "parsesBodyFragment",
        "emptyTdTag",
        "isWhitespace",
        "insert",
        "parseFragment",
        "removeFromActiveFormattingElements",
        "parseBodyFragmentRelaxed",
        "parsesUnterminatedOption",
        "handlesNewlinesAndWhitespaceInTag",
        "process",
        "parse",
        "handlesUnexpectedMarkupInTables",
        "ParseError",
        "insertEmpty",
        "replaceInQueue",
        "reconstructFormattingElements",
        "handlesUnclosedScriptAtEof",
        "handlesUnclosedFormattingElements",
        "getPos",
        "handlesBlocksInDefinitions",
        "replaceOnStack",
        "handlesDataOnlyTags",
        "setHeadElement",
        "isElementInQueue",
        "getPendingTableCharacters",
        "inListItemScope",
        "setFormElement",
        "isSpecial",
        "handleRcData",
        "anyOtherEndTag",
        "createsDocumentStructure",
        "dropsUnterminatedAttribute",
        "isFragmentParsing",
        "getErrorMsg",
        "parsesUnterminatedTextarea",
        "parseBodyFragment",
        "isInActiveFormattingElements"
      ],
      "functions_name_co_evolved_modified_file": [
        "insertNode",
        "process",
        "initialiseParse",
        "popStackToClose",
        "insert"
      ],
      "functions_name_co_evolved_all_files": [
        "setPendingTableCharacters",
        "getStack",
        "markInsertionMode",
        "clearFormattingElementsToLastMarker",
        "TreeBuilder",
        "inSpecificScope",
        "push",
        "toString",
        "isSameFormattingElement",
        "aboveOnStack",
        "maybeSetBaseUri",
        "inSelectScope",
        "transition",
        "framesetOk",
        "newPendingTableCharacters",
        "isFragmentParsing",
        "inTableScope",
        "setFosterInserts",
        "exitTableBody",
        "popStackToBefore",
        "insert",
        "removeFromActiveFormattingElements",
        "parseFragment",
        "generateImpliedEndTags",
        "getFormElement",
        "clearStackToTableRowContext",
        "removeFromStack",
        "resetInsertionMode",
        "state",
        "getBaseUri",
        "testSimpleXmlParse",
        "insertInFosterParent",
        "getFromStack",
        "process",
        "parse",
        "closeCell",
        "insertMarkerToFormattingElements",
        "inScope",
        "initialiseParse",
        "pushActiveFormattingElements",
        "clearStackToTableContext",
        "ParseError",
        "insertEmpty",
        "clearStackToTableBodyContext",
        "insertNode",
        "HtmlTreeBuilder",
        "replaceInQueue",
        "clearStackToContext",
        "isFosterInserts",
        "reconstructFormattingElements",
        "inButtonScope",
        "replaceOnStack",
        "popStackToClose",
        "error",
        "runParser",
        "onStack",
        "originalState",
        "setHeadElement",
        "isElementInQueue",
        "replaceActiveFormattingElement",
        "getPendingTableCharacters",
        "inListItemScope",
        "handleRawtext",
        "setFormElement",
        "getDocument",
        "getHeadElement",
        "isSpecial",
        "handleRcData",
        "anyOtherEndTag",
        "pop",
        "insertOnStackAfter",
        "anythingElse",
        "getActiveFormattingElement",
        "isInActiveFormattingElements"
      ]
    },
    "file": {
      "file_name": "XmlTreeBuilder.java",
      "file_nloc": 88,
      "file_complexity": 21,
      "file_token_count": 523,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,111 @@\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.*;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * @author Jonathan Hedley\n+ */\n+public class XmlTreeBuilder extends TreeBuilder {\n+    @Override\n+    protected void initialiseParse(String input, String baseUri) {\n+        super.initialiseParse(input, baseUri);\n+        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n+    }\n+\n+    @Override\n+    boolean process(Token token) {\n+        // start tag, end tag, doctype, comment, character, eof\n+        switch (token.type) {\n+            case StartTag:\n+                insert(token.asStartTag());\n+                break;\n+            case EndTag:\n+                popStackToClose(token.asEndTag());\n+                break;\n+            case Comment:\n+                insert(token.asComment());\n+                break;\n+            case Character:\n+                insert(token.asCharacter());\n+                break;\n+            case Doctype:\n+                insert(token.asDoctype());\n+                break;\n+            case EOF: // could put some normalisation here if desired\n+                break;\n+            default:\n+                Validate.fail(\"Unexpected token type: \" + token.type);\n+        }\n+        return true;\n+    }\n+\n+    private void insertNode(Node node) {\n+        currentElement().appendChild(node);\n+    }\n+\n+    Element insert(Token.StartTag startTag) {\n+        Tag tag = Tag.valueOf(startTag.name());\n+        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n+        Element el = new Element(tag, baseUri, startTag.attributes);\n+        insertNode(el);\n+        if (startTag.isSelfClosing()) {\n+            tokeniser.acknowledgeSelfClosingFlag();\n+            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n+                tag.setSelfClosing();\n+        } else {\n+            stack.add(el);\n+        }\n+        return el;\n+    }\n+\n+    void insert(Token.Comment commentToken) {\n+        Comment comment = new Comment(commentToken.getData(), baseUri);\n+        insertNode(comment);\n+    }\n+\n+    void insert(Token.Character characterToken) {\n+        Node node = new TextNode(characterToken.getData(), baseUri);\n+        insertNode(node);\n+    }\n+\n+    void insert(Token.Doctype d) {\n+        DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n+        insertNode(doctypeNode);\n+    }\n+\n+    /**\n+     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n+     * found, skips.\n+     *\n+     * @param endTag\n+     */\n+    private void popStackToClose(Token.EndTag endTag) {\n+        String elName = endTag.name();\n+        Element firstFound = null;\n+\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                firstFound = next;\n+                break;\n+            }\n+        }\n+        if (firstFound == null)\n+            return; // not found, skip\n+\n+        it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == firstFound) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+}\n",
      "files_name_in_blame_commit": [
        "XmlTreeBuilderTest.java",
        "HtmlParserTest.java",
        "HtmlTreeBuilderState.java",
        "HtmlTreeBuilder.java",
        "ParseError.java",
        "XmlTreeBuilder.java",
        "Parser.java",
        "TreeBuilder.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 18
  }
}
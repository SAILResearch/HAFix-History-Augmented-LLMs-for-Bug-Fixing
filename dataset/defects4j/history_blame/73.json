{
  "id": "73",
  "blame_commit": {
    "commit": {
      "commit_id": "6c4f16f233cdfd7aedef33374609e9aa4ede255c",
      "commit_message": "Support for HTML output syntax, enabled by default\n\nIntroduced the ability to chose between HTML and XML output, and made\nHTML the default. This means img tags are\noutput as <img>, not <img />. XML is the default when using the\nXmlTreeBuilder. Control this with the\nDocument.OutputSettings.syntax() method.\n\nTightened the scope of what characters are escaped in attributes and\ntextnodes, to align with the spec. Also, when\nusing the extended escape entities map, only escape a character if the\ncurrent output charset does not support it.\nThis produces smaller, more legible HTML, with greated control over the\noutput (by setting charset and escape mode).\n\nFixes #322\nFixes #373\nFixes #346\nFixes #150",
      "commit_author": "Jonathan Hedley",
      "commit_date": "2013-11-17 19:11:08",
      "commit_parent": "d65185506919c50de85e766771898fdbd054e77b"
    },
    "function": {
      "function_name": "escape",
      "function_code_before": "",
      "function_code_after": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    EscapeMode escapeMode = out.escapeMode();\n    CharsetEncoder encoder = out.encoder();\n    Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (encoder.canEncode(c))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c))\n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 81,
      "function_after_end_line": 155,
      "function_before_token_count": 0,
      "function_after_token_count": 433,
      "functions_name_modified_file": [
        "isBaseNamedEntity",
        "escape",
        "toCharacterKey",
        "EscapeMode",
        "getMap",
        "isNamedEntity",
        "Entities",
        "unescape",
        "loadEntities",
        "for",
        "getCharacterByName"
      ],
      "functions_name_all_files": [
        "normalise",
        "ignoresDupeEndTrTag",
        "testIsValid",
        "isKnownTag",
        "isFormListed",
        "getElementsByTagName",
        "letterDigitEntities",
        "initialiseParse",
        "getNamespacedElementsByTag",
        "handlesCdata",
        "lastElementSibling",
        "location",
        "nextElementSibling",
        "encoder",
        "handlesTextAfterData",
        "isData",
        "noImplicitFormForTextAreas",
        "charset",
        "Element",
        "testAddNewHtml",
        "handlesEscapedData",
        "testGetSiblings",
        "isInline",
        "testClonesDeclarations",
        "testPrependRowToTable",
        "createShell",
        "getElementsByTag",
        "testAFlowContents",
        "testClone",
        "handlesWhitespaceInoDocType",
        "testPrependElement",
        "getElementsMatchingText",
        "testElementSiblingIndex",
        "getElementsByAttributeValueContaining",
        "isBaseNamedEntity",
        "testGetElementsWithClass",
        "testClassDomMethods",
        "testGetTextNodes",
        "parsesRoughAttributes",
        "testGetParents",
        "handlesUnclosedRawtextAtEof",
        "canContainBlock",
        "hasClass",
        "indentAmount",
        "handlesFramesets",
        "handlesMisnestedTagsBP",
        "getElementsByIndexGreaterThan",
        "handlesJavadocFont",
        "handlesXmlDeclarationAsBogusComment",
        "commentBeforeHtml",
        "handlesUnclosedAnchors",
        "text",
        "OutputSettings",
        "testGetElementsWithAttributeValue",
        "normalisesEmptyDocument",
        "appendText",
        "handlesMultiClosingBody",
        "handlesInputInTable",
        "before",
        "id",
        "Entities",
        "hashCode",
        "testFormatHtml",
        "clone",
        "noSpuriousDecodes",
        "parseFragment",
        "getElementsByAttributeStarting",
        "absUrl",
        "prependChild",
        "handlesTagsInTextarea",
        "testDropComments",
        "createElement",
        "testFormatOutline",
        "elementIsNotASiblingOfItself",
        "getWholeText",
        "testSetIndent",
        "prependText",
        "removeAttr",
        "getElementsByClass",
        "supplyOutputSettings",
        "createFromEncoded",
        "indexInList",
        "testTitles",
        "parsesSimpleDocument",
        "htmlParseDefaultsToHtmlOutputSyntax",
        "normaliseStructure",
        "testAddNewText",
        "getElementsByIndexLessThan",
        "tag",
        "testManipulateTextNodes",
        "basicWithImagesTest",
        "testGetText",
        "testNoIndentOnScriptAndStyle",
        "testLocation",
        "testGetElementsWithAttribute",
        "Attribute",
        "register",
        "createsStructureFromBodySnippet",
        "testRelaxedTags",
        "getValue",
        "prettyPrint",
        "testHtmlContainsOuter",
        "setTextPreservesDocumentStructure",
        "ignoresContentAfterFrameset",
        "handlesInvalidStartTags",
        "testSpanContents",
        "xmlFragment",
        "testDropImageScript",
        "testOuterHtml",
        "outputSettings",
        "testContainerOutput",
        "doesNotFindShortestMatchingEntity",
        "isBlock",
        "testPopToClose",
        "ensureAttributes",
        "parentlessToString",
        "prepend",
        "after",
        "testPrependText",
        "testDropXmlProc",
        "testHgroup",
        "parents",
        "handlesCustomProtocols",
        "handlesUnclosedDefinitionLists",
        "attr",
        "tracksErrorsWhenRequested",
        "handlesSolidusInA",
        "testSupplyParserToJsoupClass",
        "popStackToClose",
        "normalisesDocument",
        "head",
        "handlesWhatWgExpensesTableExample",
        "siblingElements",
        "simpleBehaviourTest2",
        "handlesCommentsInTable",
        "isFormSubmittable",
        "prependElement",
        "lastCharIsWhitespace",
        "accumulateParents",
        "handlesUnknownInlineTags",
        "getName",
        "quoteReplacements",
        "parsesComments",
        "getElementsByAttributeValue",
        "appendWhitespaceIfBr",
        "shouldCollapseAttribute",
        "handlesNestedImplicitTable",
        "handlesUnclosedTitleAtEof",
        "tagName",
        "handles0CharacterAsText",
        "testKeepsPreText",
        "testClassUpdates",
        "className",
        "elementSiblingIndex",
        "formatAsBlock",
        "splitText",
        "getAllElements",
        "testHtmlAndXmlSyntax",
        "handlesQuotesInCommentsInScripts",
        "handlesBlocksInDefinitions",
        "testEmptyElementFormatHtml",
        "dropsUnterminatedAttribute",
        "parsesUnterminatedTextarea",
        "TextNode",
        "valueOf",
        "child",
        "loadEntities",
        "textNodes",
        "val",
        "testHasText",
        "Tag",
        "cleansInternationalText",
        "testSupplyParserToConnection",
        "testNotPretty",
        "findsCharsetInMalformedMeta",
        "testBrHasSpace",
        "moveByAppend",
        "testSpaceAfterTag",
        "normalisesHeadlessBody",
        "testSupplyParserToDataStream",
        "syntax",
        "basicBehaviourTest",
        "testAddNewElement",
        "handlesAllPseudoTag",
        "escapeMode",
        "testNoImagesInNoScriptInHead",
        "testDropsUnknownTags",
        "testWrapWithRemainder",
        "getElementsContainingOwnText",
        "getElementsByAttributeValueNot",
        "insertNode",
        "handlesNullInData",
        "preservesRelativeLinksIfConfigured",
        "handlesTextArea",
        "empty",
        "testClonesClassnames",
        "data",
        "dropsUnterminatedTag",
        "handlesImplicitCaptionClose",
        "outline",
        "testSetHtml",
        "title",
        "testWrap",
        "attributes",
        "handlesBaseTags",
        "escape",
        "handlesUnclosedCdataAtEOF",
        "escapeSupplementaryCharacter",
        "testGetElementsWithAttributeDash",
        "handlesUnknownNamespaceTags",
        "normaliseWhitespace",
        "getElementById",
        "addsTagOnAttributesIfNotSet",
        "preservesSpaceInScript",
        "insertChildren",
        "getElementsMatchingOwnText",
        "testFontFlowContents",
        "isNamedEntity",
        "testChildThrowsIndexOutOfBoundsOnMissing",
        "Document",
        "handlesKnownEmptyBlocks",
        "isDataAttribute",
        "isBlank",
        "handlesNullInComments",
        "getCharacterByName",
        "parsesQuiteRoughAttributes",
        "firstElementSibling",
        "parsesBodyFragment",
        "for",
        "testNormalisesText",
        "getElementsByAttributeValueStarting",
        "process",
        "classNames",
        "testSetText",
        "testNormalisesStructure",
        "handlesUnclosedFormattingElements",
        "parent",
        "previousElementSibling",
        "stripLeadingWhitespace",
        "handlesDataOnlyTags",
        "convertsImageToImg",
        "createsDocumentStructure",
        "createsFormElements",
        "body",
        "addClass",
        "toString",
        "handlesBaseWithoutHref",
        "relaxedBaseEntityMatchAndStrictExtendedMatch",
        "hasAttr",
        "handlesSolidusAtAttributeEnd",
        "tracksLimitedErrorsWhenRequested",
        "testSimpleXmlParse",
        "testRelaxed",
        "handleNullContextInParseFragment",
        "testCommentAndDocType",
        "handlesTbodyTable",
        "discardsNakedTds",
        "testCleanJavascriptHref",
        "setSelfClosing",
        "testTagNameSet",
        "handlesEscapedScript",
        "handlesUnknownTags",
        "testDoesNotForceSelfClosingKnownTags",
        "handlesMisnestedTagsBI",
        "insertChildrenAsCopy",
        "appendElement",
        "getElementsContainingText",
        "EscapeMode",
        "testHeaderContents",
        "getMap",
        "getElementsByAttributeValueEnding",
        "getElementsByAttributeValueMatching",
        "appendNormalisedText",
        "html",
        "setKey",
        "testDropScript",
        "testXhtmlReferences",
        "appendChild",
        "quirksMode",
        "dataNodes",
        "outerHtmlTail",
        "handlesXmlDeclarationAsDeclaration",
        "DocumentType",
        "resolvesRelativeLinks",
        "dropsUnresolvableRelativeLinks",
        "preserveWhitespace",
        "testAppendRowToTable",
        "associatedFormControlsWithDisjointForms",
        "doesNotCreateImplicitLists",
        "testGetDataNodes",
        "normaliseTextNodes",
        "outerHtml",
        "equals",
        "outerHtmlHead",
        "handlesSpanInTbody",
        "xmlParseDefaultsToHtmlOutputSyntax",
        "toCharacterKey",
        "testGetChildText",
        "noTableDirectInTable",
        "normalisedBodyAfterContent",
        "getElementsByIndexEquals",
        "getKey",
        "select",
        "testHandlesEmptyAttributes",
        "append",
        "handlesFrames",
        "testKeepsPreTextInCode",
        "testOutputEncoding",
        "wrap",
        "testOverflowClone",
        "parsesUnterminatedComments",
        "nodeName",
        "hasText",
        "ownText",
        "children",
        "caseSensitive",
        "testPrependNewHtml",
        "preservesSpaceInTextArea",
        "handlesUnclosedTitle",
        "simpleBehaviourTest",
        "testGetElementById",
        "reconstructFormattingElementsInTable",
        "removeClass",
        "emptyTdTag",
        "unescape",
        "getElementsByAttribute",
        "insert",
        "isSelfClosing",
        "parsesUnterminatedOption",
        "handlesNewlinesAndWhitespaceInTag",
        "toggleClass",
        "handlesUnexpectedMarkupInTables",
        "isEmpty",
        "reconstructFormattingElements",
        "handlesUnclosedScriptAtEof",
        "dataset",
        "setValue",
        "findFirstElementByTagName",
        "strictUnescape",
        "insertChildrenArgumentValidation",
        "noErrorsByDefault",
        "insertChildrenAtPosition",
        "testInnerHtml"
      ],
      "functions_name_co_evolved_modified_file": [
        "escape"
      ],
      "functions_name_co_evolved_all_files": [
        "xmlParseDefaultsToHtmlOutputSyntax",
        "escape",
        "syntax",
        "ignoresContentAfterFrameset",
        "testDropImageScript",
        "testOuterHtml",
        "escapeSupplementaryCharacter",
        "relaxedBaseEntityMatchAndStrictExtendedMatch",
        "htmlParseDefaultsToHtmlOutputSyntax",
        "html",
        "shouldCollapseAttribute",
        "testHandlesEmptyAttributes",
        "testNoImagesInNoScriptInHead",
        "parentlessToString",
        "testXhtmlReferences",
        "handlesFrames",
        "letterDigitEntities",
        "testHtmlAndXmlSyntax",
        "initialiseParse",
        "resolvesRelativeLinks",
        "handlesCustomProtocols",
        "basicWithImagesTest",
        "testLocation",
        "preservesRelativeLinksIfConfigured",
        "handlesKnownEmptyBlocks",
        "normalisesDocument",
        "associatedFormControlsWithDisjointForms",
        "convertsImageToImg",
        "handlesWhatWgExpensesTableExample",
        "testDoesNotForceSelfClosingKnownTags",
        "supplyOutputSettings",
        "caseSensitive",
        "outerHtmlHead"
      ]
    },
    "file": {
      "file_name": "Entities.java",
      "file_nloc": 167,
      "file_complexity": 37,
      "file_token_count": 1195,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -1,5 +1,6 @@\n package org.jsoup.nodes;\n \n+import org.jsoup.helper.StringUtil;\n import org.jsoup.parser.Parser;\n \n import java.io.IOException;\n@@ -16,7 +17,7 @@ import java.util.regex.Pattern;\n  */\n public class Entities {\n     public enum EscapeMode {\n-        /** Restricted entities suitable for XHTML output: lt, gt, amp, apos, and quot only. */\n+        /** Restricted entities suitable for XHTML output: lt, gt, amp, and quot only. */\n         xhtml(xhtmlByVal),\n         /** Default HTML output entities. */\n         base(baseByVal),\n@@ -71,26 +72,78 @@ public class Entities {\n     }\n     \n     static String escape(String string, Document.OutputSettings out) {\n-        return escape(string, out.encoder(), out.escapeMode());\n+        StringBuilder accum = new StringBuilder(string.length() * 2);\n+        escape(accum, string, out, false, false, false);\n+        return accum.toString();\n     }\n \n-    static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n-        StringBuilder accum = new StringBuilder(string.length() * 2);\n-        Map<Character, String> map = escapeMode.getMap();\n+    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n+    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n+                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n \n+        boolean lastWasWhite = false;\n+        boolean reachedNonWhite = false;\n+        EscapeMode escapeMode = out.escapeMode();\n+        CharsetEncoder encoder = out.encoder();\n+        Map<Character, String> map = escapeMode.getMap();\n         final int length = string.length();\n-        for (int offset = 0; offset < length; ) {\n-            final int codePoint = string.codePointAt(offset);\n \n+        int codePoint;\n+        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n+            codePoint = string.codePointAt(offset);\n+\n+            if (normaliseWhite) {\n+                if (StringUtil.isWhitespace(codePoint)) {\n+                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n+                        continue;\n+                    accum.append(' ');\n+                    lastWasWhite = true;\n+                    continue;\n+                } else {\n+                    lastWasWhite = false;\n+                    reachedNonWhite = true;\n+                }\n+            }\n             // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n             if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                 final char c = (char) codePoint;\n-                if (map.containsKey(c))\n-                    accum.append('&').append(map.get(c)).append(';');\n-                else if (encoder.canEncode(c))\n-                    accum.append(c);\n-                else\n-                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n+                // html specific and required escapes:\n+                switch (c) {\n+                    case '&':\n+                        accum.append(\"&amp;\");\n+                        break;\n+                    case 0xA0:\n+                        if (escapeMode != EscapeMode.xhtml)\n+                            accum.append(\"&nbsp;\");\n+                        else\n+                            accum.append(c);\n+                        break;\n+                    case '<':\n+                        if (!inAttribute)\n+                            accum.append(\"&lt;\");\n+                        else\n+                            accum.append(c);\n+                        break;\n+                    case '>':\n+                        if (!inAttribute)\n+                            accum.append(\"&gt;\");\n+                        else\n+                            accum.append(c);\n+                        break;\n+                    case '\"':\n+                        if (inAttribute)\n+                            accum.append(\"&quot;\");\n+                        else\n+                            accum.append(c);\n+                        break;\n+                    default:\n+                        if (encoder.canEncode(c))\n+                            accum.append(c);\n+                        else if (map.containsKey(c))\n+                            accum.append('&').append(map.get(c)).append(';');\n+                        else\n+                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n+                }\n             } else {\n                 final String c = new String(Character.toChars(codePoint));\n                 if (encoder.canEncode(c))\n@@ -98,11 +151,7 @@ public class Entities {\n                 else\n                     accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n             }\n-\n-            offset += Character.charCount(codePoint);\n         }\n-\n-        return accum.toString();\n     }\n \n     static String unescape(String string) {\n@@ -119,11 +168,11 @@ public class Entities {\n         return Parser.unescapeEntities(string, strict);\n     }\n \n+\n     // xhtml has restricted entities\n     private static final Object[][] xhtmlArray = {\n             {\"quot\", 0x00022},\n             {\"amp\", 0x00026},\n-            {\"apos\", 0x00027},\n             {\"lt\", 0x0003C},\n             {\"gt\", 0x0003E}\n     };\n",
      "files_name_in_blame_commit": [
        "Document.java",
        "HtmlParserTest.java",
        "Attribute.java",
        "XmlTreeBuilderTest.java",
        "DocumentTest.java",
        "CleanerTest.java",
        "Tag.java",
        "Element.java",
        "DocumentType.java",
        "ElementTest.java",
        "Entities.java",
        "TextNode.java",
        "XmlTreeBuilder.java",
        "EntitiesTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 27
  }
}
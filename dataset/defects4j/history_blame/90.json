{
  "id": "90",
  "blame_commit": {
    "commit": {
      "commit_id": "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4",
      "commit_message": "Test LocaleUtils\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@291219 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Stephen Colebourne",
      "commit_date": "2005-09-23 23:17:31",
      "commit_parent": "b2da02296f79e4119b749522a1912f5be5ea4f8c"
    },
    "function": {
      "function_name": "isAvailableLocale",
      "function_code_before": "",
      "function_code_after": "public static boolean isAvailableLocale(Locale locale) {\n    return cAvailableLocaleSet.contains(locale);\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 216,
      "function_after_end_line": 218,
      "function_before_token_count": 0,
      "function_after_token_count": 15,
      "functions_name_modified_file": [
        "availableLocaleList",
        "languagesByCountry",
        "toLocale",
        "LocaleUtils",
        "localeLookupList",
        "countriesByLanguage",
        "availableLocaleSet",
        "isAvailableLocale"
      ],
      "functions_name_all_files": [
        "testAvailableLocaleSet",
        "assertCountriesByLanguage",
        "testLanguagesByCountry",
        "testToLocale_3Part",
        "countriesByLanguage",
        "testLocaleLookupList_Locale",
        "assertValidToLocale",
        "availableLocaleSet",
        "LangTestSuite",
        "testToLocale_1Part",
        "main",
        "assertLanguageByCountry",
        "LocaleUtilsTest",
        "availableLocaleList",
        "languagesByCountry",
        "assertLocaleLookupList",
        "toLocale",
        "localeLookupList",
        "testConstructor",
        "testLocaleLookupList_LocaleLocale",
        "testIsAvailableLocale",
        "suite",
        "testCountriesByLanguage",
        "testAvailableLocaleList",
        "LocaleUtils",
        "testToLocale_2Part",
        "isAvailableLocale"
      ],
      "functions_name_co_evolved_modified_file": [
        "availableLocaleList",
        "languagesByCountry",
        "toLocale",
        "localeLookupList",
        "countriesByLanguage",
        "availableLocaleSet",
        "isAvailableLocale"
      ],
      "functions_name_co_evolved_all_files": [
        "testAvailableLocaleSet",
        "assertCountriesByLanguage",
        "testLanguagesByCountry",
        "testToLocale_3Part",
        "countriesByLanguage",
        "testLocaleLookupList_Locale",
        "assertValidToLocale",
        "availableLocaleSet",
        "testToLocale_1Part",
        "main",
        "assertLanguageByCountry",
        "LocaleUtilsTest",
        "availableLocaleList",
        "languagesByCountry",
        "assertLocaleLookupList",
        "toLocale",
        "localeLookupList",
        "testConstructor",
        "testLocaleLookupList_LocaleLocale",
        "testIsAvailableLocale",
        "suite",
        "testCountriesByLanguage",
        "testAvailableLocaleList",
        "testToLocale_2Part",
        "isAvailableLocale"
      ]
    },
    "file": {
      "file_name": "LocaleUtils.java",
      "file_nloc": 134,
      "file_complexity": 41,
      "file_token_count": 978,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -16,9 +16,13 @@\n package org.apache.commons.lang;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.Set;\n \n /**\n@@ -34,6 +38,19 @@\n  */\n public class LocaleUtils {\n \n+    /** Unmodifiable list of available locales. */\n+    private static final List cAvailableLocaleList;\n+    /** Unmodifiable set of available locales. */\n+    private static Set cAvailableLocaleSet;\n+    /** Unmodifiable map of language locales by country. */\n+    private static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n+    /** Unmodifiable map of country locales by language. */\n+    private static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\n+    static {\n+        List list = Arrays.asList(Locale.getAvailableLocales());\n+        cAvailableLocaleList = Collections.unmodifiableList(list);\n+    }\n+\n     /**\n      * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n      * Instead, the class should be used as <code>LocaleUtils.toLocale(\"en_GB\");</code>.</p>\n@@ -57,34 +74,48 @@ public LocaleUtils() {\n      *   LocaleUtils.toLocale(\"en_GB\")  = new Locale(\"en\", \"GB\")\n      *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")\n      * </pre>\n+     * \n+     * <p>This method validates the input strictly.\n+     * The language code must be lowercase.\n+     * The country code must be uppercase.\n+     * The separator must be an underscore.\n+     * The length must be correct.\n+     * </p>\n      *\n      * @param str  the locale String to convert, null returns null\n-     * @return a Locale\n+     * @return a Locale, null if null input\n      * @throws IllegalArgumentException if the string is an invalid format\n      */\n     public static Locale toLocale(String str) {\n         if (str == null) {\n             return null;\n         }\n-        if (str.length() != 2 &&\n-            str.length() != 5 &&\n-            str.length() < 7) {\n+        int len = str.length();\n+        if (len != 2 && len != 5 && len < 7) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (Character.isLowerCase(str.charAt(0)) == false ||\n-            Character.isLowerCase(str.charAt(1)) == false) {\n+        char ch0 = str.charAt(0);\n+        char ch1 = str.charAt(1);\n+        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (str.length() == 2) {\n+        if (len == 2) {\n             return new Locale(str, \"\");\n         } else {\n-            if (Character.isUpperCase(str.charAt(3)) == false ||\n-                Character.isUpperCase(str.charAt(4)) == false) {\n+            if (str.charAt(2) != '_') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            char ch3 = str.charAt(3);\n+            char ch4 = str.charAt(4);\n+            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n-            if (str.length() == 5) {\n+            if (len == 5) {\n                 return new Locale(str.substring(0, 2), str.substring(3, 5));\n             } else {\n+                if (str.charAt(5) != '_') {\n+                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+                }\n                 return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n             }\n         }\n@@ -101,7 +132,7 @@ public static Locale toLocale(String str) {\n      * </pre>\n      *\n      * @param locale  the locale to start from\n-     * @return the list of Locale objects, 0 being locale\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n      */\n     public static List localeLookupList(Locale locale) {\n         return localeLookupList(locale, locale);\n@@ -117,12 +148,13 @@ public static List localeLookupList(Locale locale) {\n      *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n      * </pre>\n      *\n-     * <p>This method takes a country code and searches to find the\n-     * languages available for that country. Variant locales are removed.</p>\n+     * <p>The result list begins with the most specific locale, then the\n+     * next more general and so on, finishing with the default locale.\n+     * The list will never contain the same locale twice.</p>\n      *\n      * @param locale  the locale to start from, null returns empty list\n      * @param defaultLocale  the default locale to use if no other is found\n-     * @return the list of Locale objects, 0 being locale\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n      */\n     public static List localeLookupList(Locale locale, Locale defaultLocale) {\n         List list = new ArrayList(4);\n@@ -138,55 +170,116 @@ public static List localeLookupList(Locale locale, Locale defaultLocale) {\n                 list.add(defaultLocale);\n             }\n         }\n-        return list;\n+        return Collections.unmodifiableList(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable list of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable list of available locales\n+     */\n+    public static List availableLocaleList() {\n+        return cAvailableLocaleList;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Obtains the set of languages supported for a given country.</p>\n-     \n+     * <p>Obtains an unmodifiable set of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable set of available locales\n+     */\n+    public static Set availableLocaleSet() {\n+        Set set = cAvailableLocaleSet;\n+        if (set == null) {\n+            set = new HashSet(availableLocaleList());\n+            set = Collections.unmodifiableSet(set);\n+            cAvailableLocaleSet = set;\n+        }\n+        return set;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the locale specified is in the list of available locales.</p>\n+     *\n+     * @return true if the locale is a known locale\n+     */\n+    public static boolean isAvailableLocale(Locale locale) {\n+        return cAvailableLocaleSet.contains(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of languages supported for a given country.</p>\n+     *\n      * <p>This method takes a country code and searches to find the\n      * languages available for that country. Variant locales are removed.</p>\n      *\n      * @param countryCode  the 2 letter country code, null returns empty\n-     * @return a Set of Locale objects\n+     * @return an unmodifiable List of Locale objects, never null\n      */\n-    public static Set languagesByCountry(String countryCode) {\n-        Set set = new HashSet();\n-        Locale[] array = Locale.getAvailableLocales();\n-        if (countryCode != null) {\n-            for (int i = 0; i < array.length; i++) {\n-                if (countryCode.equals(array[i].getCountry()) &&\n-                        array[i].getVariant().length() == 0) {\n-                    set.add(array[i]);\n+    public static List languagesByCountry(String countryCode) {\n+        List langs = (List) cLanguagesByCountry.get(countryCode);\n+        if (langs == null) {\n+            if (countryCode != null) {\n+                langs = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (countryCode.equals(locale.getCountry()) &&\n+                            locale.getVariant().length() == 0) {\n+                        langs.add(locale);\n+                    }\n                 }\n+                langs = Collections.unmodifiableList(langs);\n+            } else {\n+                langs = Collections.EMPTY_LIST;\n             }\n+            cLanguagesByCountry.put(countryCode, langs);\n         }\n-        return set;\n+        return langs;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Obtains the set of countries supported for a given language.</p>\n+     * <p>Obtains the list of countries supported for a given language.</p>\n      * \n      * <p>This method takes a language code and searches to find the\n      * countries available for that language. Variant locales are removed.</p>\n      *\n      * @param languageCode  the 2 letter language code, null returns empty\n-     * @return a Set of Locale objects\n+     * @return an unmodifiable List of Locale objects, never null\n      */\n-    public static Set countriesByLanguage(String languageCode) {\n-        Set set = new HashSet();\n-        Locale[] array = Locale.getAvailableLocales();\n-        if (languageCode != null) {\n-            for (int i = 0; i < array.length; i++) {\n-                if (languageCode.equals(array[i].getLanguage()) &&\n-                        array[i].getVariant().length() == 0) {\n-                    set.add(array[i]);\n+    public static List countriesByLanguage(String languageCode) {\n+        List countries = (List) cCountriesByLanguage.get(languageCode);\n+        if (countries == null) {\n+            if (languageCode != null) {\n+                countries = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (languageCode.equals(locale.getLanguage()) &&\n+                            locale.getCountry().length() != 0 &&\n+                            locale.getVariant().length() == 0) {\n+                        countries.add(locale);\n+                    }\n                 }\n+                countries = Collections.unmodifiableList(countries);\n+            } else {\n+                countries = Collections.EMPTY_LIST;\n             }\n+            cCountriesByLanguage.put(languageCode, countries);\n         }\n-        return set;\n+        return countries;\n     }\n \n }\n",
      "files_name_in_blame_commit": [
        "LocaleUtilsTest.java",
        "LangTestSuite.java",
        "LocaleUtils.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 10
  }
}
{
  "id": "108",
  "blame_commit": {
    "commit": {
      "commit_id": "eb6fb6cda45d8bf83aa8347eccd36d2ef68b0694",
      "commit_message": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Phil Steitz",
      "commit_date": "2004-07-17 21:19:39",
      "commit_parent": "b03610041da61b1305b68654f499a65ec28a4b61"
    },
    "function": {
      "function_name": "bracket",
      "function_code_before": "public static double[] bracket(UnivariateRealFunction function,\n                               double initial,\n                               double lowerBound,\n                               double upperBound,\n                               int maximumIterations) throws MathException {\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations += 1 ;\n    } while ( (fa * fb > 0.0) && ( numIterations < maximumIterations ) );\n\n    return new double[]{a, b};\n}",
      "function_code_after": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n\n    if (function == null) {\n        throw new IllegalArgumentException (\"function is null.\");\n    }\n    if (maximumIterations <= 0)  {\n        throw new IllegalArgumentException\n        (\"bad value for maximumIterations: \" + maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw new IllegalArgumentException\n        (\"Invalid endpoint parameters:  lowerBound=\" + lowerBound + \n          \" initial=\" + initial + \" upperBound=\" + upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n\n    if (fa * fb >= 0.0 ) {\n        throw new ConvergenceException\n        (\"Number of iterations= \" + numIterations +\n          \" maximum iterations= \"  + maximumIterations +\n          \" initial= \" + initial + \" lowerBound=\" + lowerBound +\n          \" upperBound=\" + upperBound + \" final a value=\" + a +\n          \" final b value=\" + b + \" f(a)=\" + fa + \" f(b)=\" + fb);\n    }\n\n    return new double[]{a, b};\n}",
      "function_before_start_line": 117,
      "function_before_end_line": 137,
      "function_after_start_line": 165,
      "function_after_end_line": 208,
      "function_before_token_count": 127,
      "function_after_token_count": 260,
      "functions_name_modified_file": [
        "setup",
        "midpoint",
        "bracket",
        "UnivariateRealSolverUtils",
        "solve"
      ],
      "functions_name_all_files": [
        "testSolveAccuracySin",
        "value",
        "getResult",
        "verifyBracketing",
        "isStrictlyIncreasing",
        "testResetAbsoluteAccuracy",
        "setAbsoluteAccuracy",
        "BrentSolver",
        "testSetFunctionValueAccuracy",
        "testSolveBadParameters",
        "SecantSolver",
        "resetFunctionValueAccuracy",
        "resetAbsoluteAccuracy",
        "testSetMaximalIterationCount",
        "testResetMaximalIterationCount",
        "testSolveSin",
        "getMaximalIterationCount",
        "getRelativeAccuracy",
        "bracket",
        "getIterationCount",
        "setFunctionValueAccuracy",
        "AbstractContinuousDistribution",
        "verifySequence",
        "PolynomialSplineFunction",
        "testSinZero",
        "isBracketing",
        "NewtonSolver",
        "setResult",
        "verifyInterval",
        "getKnots",
        "setMaximalIterationCount",
        "resetRelativeAccuracy",
        "UnivariateRealSolverImpl",
        "getFunctionValueAccuracy",
        "testQuinticZero",
        "testSolveAccuracyNull",
        "clearResult",
        "midpoint",
        "getPolynomials",
        "resetMaximalIterationCount",
        "testSolveNoRoot",
        "isSequence",
        "testSetRelativeAccuracy",
        "testResetRelativeAccuracy",
        "testBracketSin",
        "polynomialSplineDerivative",
        "testResetFunctionValueAccuracy",
        "derivative",
        "setup",
        "cumulativeProbability",
        "getN",
        "testSolveNull",
        "setRelativeAccuracy",
        "testSerialization",
        "testSetAbsoluteAccuracy",
        "inverseCumulativeProbability",
        "testBracketCornerSolution",
        "testBadParameters",
        "UnivariateRealSolverUtils",
        "solve",
        "BisectionSolver",
        "getAbsoluteAccuracy"
      ],
      "functions_name_co_evolved_modified_file": [
        "setup",
        "solve",
        "bracket"
      ],
      "functions_name_co_evolved_all_files": [
        "testSolveAccuracySin",
        "value",
        "getResult",
        "verifyBracketing",
        "testResetAbsoluteAccuracy",
        "setAbsoluteAccuracy",
        "testSetFunctionValueAccuracy",
        "testSolveBadParameters",
        "testSolveSin",
        "bracket",
        "setFunctionValueAccuracy",
        "getIterationCount",
        "verifySequence",
        "testSinZero",
        "isBracketing",
        "verifyInterval",
        "testQuinticZero",
        "testSolveNoRoot",
        "testSolveAccuracyNull",
        "testBracketSin",
        "isSequence",
        "testResetRelativeAccuracy",
        "testSetRelativeAccuracy",
        "testResetFunctionValueAccuracy",
        "setup",
        "derivative",
        "testSolveNull",
        "setRelativeAccuracy",
        "testSerialization",
        "testSetAbsoluteAccuracy",
        "inverseCumulativeProbability",
        "testBracketCornerSolution",
        "testBadParameters",
        "solve"
      ]
    },
    "file": {
      "file_name": "UnivariateRealSolverUtils.java",
      "file_nloc": 78,
      "file_complexity": 19,
      "file_token_count": 520,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -15,11 +15,13 @@\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.ConvergenceException;\n \n /**\n  * Utility routines for {@link UnivariateRealSolver} objects.\n- * @version $Revision: 1.9 $ $Date: 2004/06/23 16:26:14 $\n+ * \n+ * @version $Revision: 1.10 $ $Date: 2004/07/17 21:19:39 $\n  */\n public class UnivariateRealSolverUtils {\n     /**\n@@ -28,97 +30,155 @@ public class UnivariateRealSolverUtils {\n     private UnivariateRealSolverUtils() {\n         super();\n     }\n+    \n+    /** Cached solver factory */\n+    private static UnivariateRealSolverFactory factory = null;\n \n     /**\n-     * Method to solve for zeros of real univariate functions.  A\n-     * default solver is created and used for solving. \n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n      * @param f the function.\n      * @param x0 the lower bound for the interval.\n      * @param x1 the upper bound for the interval.\n      * @return a value where the function is zero.\n-     * @throws MathException if the iteration count was exceeded or the\n-     *         solver detects convergence problems otherwise.\n+     * @throws ConvergenceException if the iteration count was exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function\n+     * @throws IllegalArgumentException if f is null or the endpoints do not\n+     * specify a valid interval\n      */\n     public static double solve(UnivariateRealFunction f, double x0, double x1)\n-        throws MathException\n-    {\n-        if(f == null){\n-            throw new IllegalArgumentException(\"f can not be null.\");    \n-        }\n-        \n-        return UnivariateRealSolverFactory.newInstance().newDefaultSolver(f)\n-            .solve(x0, x1);\n+    throws ConvergenceException, FunctionEvaluationException {\n+        setup(f);\n+        return factory.newDefaultSolver(f).solve(x0, x1);\n     }\n \n     /**\n-     * Convience method to solve for zeros of real univariate functions.  A\n-     * default solver is created and used for solving. \n-     * @param f the function.\n-     * @param x0 the lower bound for the interval.\n-     * @param x1 the upper bound for the interval.\n-     * @param absoluteAccuracy the accuracy to be used by the solver.\n-     * @return a value where the function is zero.\n-     * @throws MathException if the iteration count was exceeded or the\n-     *         solver detects convergence problems otherwise.\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n+     * @param f the function\n+     * @param x0 the lower bound for the interval\n+     * @param x1 the upper bound for the interval\n+     * @param absoluteAccuracy the accuracy to be used by the solver\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if f is null, the endpoints do not \n+     * specify a valid interval, or the absoluteAccuracy is not valid for the\n+     * default solver\n      */\n-    public static double solve(\n-        UnivariateRealFunction f,\n-        double x0,\n-        double x1,\n-        double absoluteAccuracy)\n-        throws MathException\n-    {\n-        if(f == null){\n-            throw new IllegalArgumentException(\"f can not be null.\");    \n-        }\n-            \n-        UnivariateRealSolver solver = UnivariateRealSolverFactory.newInstance()\n-            .newDefaultSolver(f);\n+    public static double solve(UnivariateRealFunction f, double x0, double x1,\n+            double absoluteAccuracy) throws ConvergenceException, \n+            FunctionEvaluationException {    \n+       \n+        setup(f);\n+        UnivariateRealSolver solver = factory.newDefaultSolver(f);\n         solver.setAbsoluteAccuracy(absoluteAccuracy);\n         return solver.solve(x0, x1);\n     }\n \n     /**\n-     * For a function, f, this method returns two values, a and b that bracket\n-     * a root of f.  That is to say, there exists a value c between a and b\n-     * such that f(c) = 0.\n+     * This method attempts to find two values a and b satisfying <ul>\n+    * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code></li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n+     * -- ConvergenceException </li>\n+     * </ul>\n+     * <p>\n+     * <strong>Note: </strong> this method can take \n+     * <code>Integer.MAX_VALUE</code> iterations to throw a \n+     * <code>ConvergenceException.</code>  Unless you are confident that there\n+     * is a root between <code>lowerBound</code> and <code>upperBound</code>\n+     * near <code>initial,</code> it is better to use \n+     * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n+     * explicitly specifying the maximum number of iterations.\n      *\n      * @param function the function\n-     * @param initial midpoint of the returned range.\n-     * @param lowerBound for numerical safety, a never is less than this value.\n-     * @param upperBound for numerical safety, b never is greater than this\n-     *                   value.\n-     * @return a two element array holding {a, b}.\n-     * @throws MathException if a root can not be bracketted.\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @return a two element array holding {a, b}\n+     * @throws ConvergenceException if a root can not be bracketted\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n      */\n-    public static double[] bracket(UnivariateRealFunction function,\n-                                   double initial,\n-                                   double lowerBound,\n-                                   double upperBound) throws MathException {\n+    public static double[] bracket(UnivariateRealFunction function, \n+            double initial, double lowerBound, double upperBound) \n+    throws ConvergenceException, FunctionEvaluationException {\n         return bracket( function, initial, lowerBound, upperBound,\n             Integer.MAX_VALUE ) ;\n     }\n \n-    /**\n-     * For a function, f, this method returns two values, a and b that bracket\n-     * a root of f.  That is to say, there exists a value c between a and b\n-     * such that f(c) = 0.\n-     *\n+     /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code> </li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> maximumIterations</code> iterations elapse \n+     * -- ConvergenceException </li></ul>\n+     * \n      * @param function the function\n-     * @param initial midpoint of the returned range.\n-     * @param lowerBound for numerical safety, a never is less than this value.\n-     * @param upperBound for numerical safety, b never is greater than this\n-     *                   value.\n-     * @param maximumIterations to guard against infinite looping, maximum\n-     *                          number of iterations to perform\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @param maximumIterations maximum number of iterations to perform\n      * @return a two element array holding {a, b}.\n-     * @throws MathException if a root can not be bracketted.\n+     * @throws ConvergenceException if the algorithm fails to find a and b\n+     * satisfying the desired conditions\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n      */\n     public static double[] bracket(UnivariateRealFunction function,\n-                                   double initial,\n-                                   double lowerBound,\n-                                   double upperBound,\n-                                   int maximumIterations) throws MathException {\n+            double initial, double lowerBound, double upperBound, \n+            int maximumIterations) throws ConvergenceException, \n+            FunctionEvaluationException {\n+        \n+        if (function == null) {\n+            throw new IllegalArgumentException (\"function is null.\");\n+        }\n+        if (maximumIterations <= 0)  {\n+            throw new IllegalArgumentException\n+            (\"bad value for maximumIterations: \" + maximumIterations);\n+        }\n+        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n+            throw new IllegalArgumentException\n+            (\"Invalid endpoint parameters:  lowerBound=\" + lowerBound + \n+              \" initial=\" + initial + \" upperBound=\" + upperBound);\n+        }\n         double a = initial;\n         double b = initial;\n         double fa;\n@@ -129,15 +189,27 @@ public class UnivariateRealSolverUtils {\n             a = Math.max(a - 1.0, lowerBound);\n             b = Math.min(b + 1.0, upperBound);\n             fa = function.value(a);\n+            \n             fb = function.value(b);\n-            numIterations += 1 ;\n-        } while ( (fa * fb > 0.0) && ( numIterations < maximumIterations ) );\n-    \n+            numIterations++ ;\n+        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n+                ((a > lowerBound) || (b < upperBound)));\n+   \n+        if (fa * fb >= 0.0 ) {\n+            throw new ConvergenceException\n+            (\"Number of iterations= \" + numIterations +\n+              \" maximum iterations= \"  + maximumIterations +\n+              \" initial= \" + initial + \" lowerBound=\" + lowerBound +\n+              \" upperBound=\" + upperBound + \" final a value=\" + a +\n+              \" final b value=\" + b + \" f(a)=\" + fa + \" f(b)=\" + fb);\n+        }\n+        \n         return new double[]{a, b};\n     }\n \n     /**\n      * Compute the midpoint of two values.\n+     * \n      * @param a first value.\n      * @param b second value.\n      * @return the midpoint. \n@@ -145,4 +217,22 @@ public class UnivariateRealSolverUtils {\n     public static double midpoint(double a, double b) {\n         return (a + b) * .5;\n     }\n+    \n+    /**\n+     * Checks to see if f is null, throwing IllegalArgumentException if so.\n+     * Also initializes factory if factory is null.\n+     * \n+     * @param f  input function\n+     * @throws IllegalArgumentException if f is null\n+     */\n+    private static void setup(UnivariateRealFunction f) {\n+       \n+        if (f == null) {\n+            throw new IllegalArgumentException(\"function can not be null.\");    \n+        }\n+        \n+        if (factory == null) {\n+            factory = UnivariateRealSolverFactory.newInstance();\n+        }       \n+    }\n }\n",
      "files_name_in_blame_commit": [
        "AbstractContinuousDistribution.java",
        "UnivariateRealSolver.java",
        "BisectionSolver.java",
        "UnivariateRealSolverUtils.java",
        "UnivariateRealFunction.java",
        "UnivariateRealSolverImpl.java",
        "SinFunction.java",
        "SecantSolver.java",
        "UnivariateRealSolverUtilsTest.java",
        "NewtonSolver.java",
        "NewtonSolverTest.java",
        "QuinticFunction.java",
        "BisectionSolverTest.java",
        "PolynomialSplineFunction.java",
        "BrentSolver.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 33
  }
}
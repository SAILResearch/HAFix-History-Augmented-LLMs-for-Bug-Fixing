{
  "id": "10",
  "blame_commit": {
    "commit": {
      "commit_id": "9b2b8038b52be022e42c8c7fdf26e236888f94c5",
      "commit_message": "checkstyle fixes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/cli/trunk@129857 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "John Keyes",
      "commit_date": "2002-12-09 23:47:26",
      "commit_parent": "6dffb657aa427151ba9bf2b832977c42f8c01f7a"
    },
    "function": {
      "function_name": "appendOption",
      "function_code_before": "private static void appendOption( final StringBuffer buff, final Option option, final boolean required)\n{\n    if( !required ) {\n        buff.append( \"[\" );\n    }\n\n    if( option.getOpt() != null ) {\n        buff.append( \"-\" ).append( option.getOpt() );\n    }\n    else {\n        buff.append( \"--\" ).append( option.getLongOpt() );\n    }\n\n    // if the Option has a value\n    if( option.hasArg() && option.getArgName() != null ) {\n        buff.append( \" <\" ).append( option.getArgName() ).append( \">\" );\n    }\n\n    // if the Option is not a required option\n    if( !required ) {\n        buff.append( \"]\" );\n    }\n}",
      "function_code_after": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n\n    // if the Option has a value\n    if (option.hasArg() && (option.getArgName() != null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n\n    // if the Option is not a required option\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
      "function_before_start_line": 310,
      "function_before_end_line": 332,
      "function_after_start_line": 569,
      "function_after_end_line": 598,
      "function_before_token_count": 130,
      "function_after_token_count": 132,
      "functions_name_modified_file": [
        "compare",
        "setWidth",
        "createPadding",
        "getDescPadding",
        "setNewLine",
        "printUsage",
        "getLeftPadding",
        "getNewLine",
        "setLeftPadding",
        "findWrapPos",
        "appendOptionGroup",
        "renderWrappedText",
        "setDescPadding",
        "rtrim",
        "getArgName",
        "setSyntaxPrefix",
        "printWrapped",
        "renderOptions",
        "setOptPrefix",
        "printOptions",
        "getOptPrefix",
        "setLongOptPrefix",
        "stripPrefix",
        "getLongOptPrefix",
        "getSyntaxPrefix",
        "printHelp",
        "getWidth",
        "setArgName",
        "appendOption"
      ],
      "functions_name_all_files": [
        "ParseException",
        "toString",
        "createPadding",
        "getDescPadding",
        "addOptionGroup",
        "testPrintWrapped",
        "setNewLine",
        "printUsage",
        "getRequiredOptions",
        "getLeftPadding",
        "getValueClass",
        "withValueSeparator",
        "MissingOptionException",
        "withLongOpt",
        "hasArgs",
        "findWrapPos",
        "processSingleHyphen",
        "testPrintOptions",
        "main",
        "getSelected",
        "addArg",
        "createValue",
        "hasNoValues",
        "setType",
        "rtrim",
        "helpOptions",
        "isValidChar",
        "hasOption",
        "hasValueSeparator",
        "addValue",
        "getValue",
        "printOptions",
        "init",
        "getOpt",
        "getOptionValue",
        "hasArgName",
        "getOption",
        "getValuesList",
        "processProperties",
        "isRequired",
        "getNewLine",
        "getValueSeparator",
        "getNames",
        "appendOptionGroup",
        "renderWrappedText",
        "gobble",
        "flatten",
        "setArgs",
        "getArgs",
        "processOptionToken",
        "printWrapped",
        "renderOptions",
        "setRequired",
        "getArgList",
        "stripLeadingHyphens",
        "MissingArgumentException",
        "printHelp",
        "setOptionalArg",
        "getWidth",
        "setSelected",
        "appendOption",
        "setArgName",
        "testFindWrapPos",
        "checkRequiredOptions",
        "add",
        "OptionBuilder",
        "Option",
        "createDate",
        "processOption",
        "processValue",
        "getOptionObject",
        "getKey",
        "createObject",
        "setValueSeparator",
        "withDescription",
        "hasLongOpt",
        "setLeftPadding",
        "setLongOpt",
        "create",
        "getDescription",
        "getOptionValues",
        "createFile",
        "getId",
        "setDescPadding",
        "burstToken",
        "createNumber",
        "validateOption",
        "iterator",
        "addOption",
        "withArgName",
        "processArgs",
        "isValidOpt",
        "getOptPrefix",
        "setLongOptPrefix",
        "stripPrefix",
        "getOptionGroup",
        "UnrecognizedOptionException",
        "getSyntaxPrefix",
        "createClass",
        "compare",
        "createURL",
        "setWidth",
        "isValueCode",
        "getLongOpt",
        "clone",
        "CommandLine",
        "hasOptionalArgs",
        "process",
        "parse",
        "getOptions",
        "hasArg",
        "testAutomaticUsage",
        "getArgName",
        "hasOptionalArg",
        "setSyntaxPrefix",
        "getValues",
        "TestHelpFormatter",
        "suite",
        "setOptPrefix",
        "Options",
        "getType",
        "createFiles",
        "getLongOptPrefix",
        "withType",
        "parsePattern",
        "reset",
        "AlreadySelectedException"
      ],
      "functions_name_co_evolved_modified_file": [
        "compare",
        "setWidth",
        "createPadding",
        "getDescPadding",
        "setNewLine",
        "HelpFormatter",
        "printUsage",
        "getLeftPadding",
        "getNewLine",
        "setLeftPadding",
        "findWrapPos",
        "appendOptionGroup",
        "renderWrappedText",
        "setDescPadding",
        "rtrim",
        "getArgName",
        "setSyntaxPrefix",
        "printWrapped",
        "renderOptions",
        "setOptPrefix",
        "printOptions",
        "setLongOptPrefix",
        "getOptPrefix",
        "stripPrefix",
        "getLongOptPrefix",
        "getSyntaxPrefix",
        "printHelp",
        "getWidth",
        "setArgName",
        "appendOption"
      ],
      "functions_name_co_evolved_all_files": [
        "ParseException",
        "toString",
        "createPadding",
        "getDescPadding",
        "addOptionGroup",
        "testPrintWrapped",
        "setNewLine",
        "printUsage",
        "getRequiredOptions",
        "getLeftPadding",
        "getValueClass",
        "withValueSeparator",
        "MissingOptionException",
        "withLongOpt",
        "hasArgs",
        "findWrapPos",
        "processSingleHyphen",
        "testPrintOptions",
        "getSelected",
        "addArg",
        "createValue",
        "hasNoValues",
        "setType",
        "rtrim",
        "helpOptions",
        "isValidChar",
        "hasOption",
        "hasValueSeparator",
        "addValue",
        "getValue",
        "printOptions",
        "init",
        "getOpt",
        "getOptionValue",
        "hasArgName",
        "reset",
        "getOption",
        "getValuesList",
        "processProperties",
        "isRequired",
        "HelpFormatter",
        "getNewLine",
        "getValueSeparator",
        "getNames",
        "appendOptionGroup",
        "renderWrappedText",
        "gobble",
        "flatten",
        "setArgs",
        "getArgs",
        "processOptionToken",
        "printWrapped",
        "renderOptions",
        "setRequired",
        "getArgList",
        "stripLeadingHyphens",
        "MissingArgumentException",
        "printHelp",
        "setOptionalArg",
        "getWidth",
        "setSelected",
        "appendOption",
        "checkRequiredOptions",
        "add",
        "OptionBuilder",
        "Option",
        "createDate",
        "processOption",
        "processValue",
        "getOptionObject",
        "getKey",
        "createObject",
        "setValueSeparator",
        "withDescription",
        "hasLongOpt",
        "setLeftPadding",
        "setLongOpt",
        "create",
        "getDescription",
        "getOptionValues",
        "createFile",
        "getId",
        "setDescPadding",
        "burstToken",
        "createNumber",
        "validateOption",
        "iterator",
        "addOption",
        "withArgName",
        "processArgs",
        "isValidOpt",
        "setLongOptPrefix",
        "getOptPrefix",
        "stripPrefix",
        "getOptionGroup",
        "UnrecognizedOptionException",
        "getSyntaxPrefix",
        "createClass",
        "compare",
        "createURL",
        "setWidth",
        "isValueCode",
        "getLongOpt",
        "clone",
        "CommandLine",
        "hasOptionalArgs",
        "process",
        "parse",
        "getOptions",
        "hasArg",
        "getArgName",
        "hasOptionalArg",
        "setSyntaxPrefix",
        "getValues",
        "setOptPrefix",
        "Options",
        "getType",
        "createFiles",
        "getLongOptPrefix",
        "withType",
        "parsePattern",
        "setArgName",
        "AlreadySelectedException"
      ]
    },
    "file": {
      "file_name": "HelpFormatter.java",
      "file_nloc": 423,
      "file_complexity": 92,
      "file_token_count": 2480,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -58,10 +58,10 @@\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n import java.io.PrintWriter;\n+\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n@@ -75,503 +75,899 @@ import java.util.List;\n  * @author Slawek Zachcial\n  * @author John Keyes (john at integralsource.com)\n  **/\n-public class HelpFormatter\n-{\n-   // --------------------------------------------------------------- Constants\n-\n-   public static final int DEFAULT_WIDTH              = 74;\n-   public static final int DEFAULT_LEFT_PAD           = 1;\n-   public static final int DEFAULT_DESC_PAD           = 3;\n-   public static final String DEFAULT_SYNTAX_PREFIX   = \"usage: \";\n-   public static final String DEFAULT_OPT_PREFIX      = \"-\";\n-   public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n-   public static final String DEFAULT_ARG_NAME        = \"arg\";\n-\n-   // ------------------------------------------------------------------ Static\n-\n-   // -------------------------------------------------------------- Attributes\n-\n-   public int defaultWidth;\n-   public int defaultLeftPad;\n-   public int defaultDescPad;\n-   public String defaultSyntaxPrefix;\n-   public String defaultNewLine;\n-   public String defaultOptPrefix;\n-   public String defaultLongOptPrefix;\n-   public String defaultArgName;\n-\n-   // ------------------------------------------------------------ Constructors\n-   public HelpFormatter()\n-   {\n-      defaultWidth = DEFAULT_WIDTH;\n-      defaultLeftPad = DEFAULT_LEFT_PAD;\n-      defaultDescPad = DEFAULT_DESC_PAD;\n-      defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n-      defaultNewLine = System.getProperty(\"line.separator\");\n-      defaultOptPrefix = DEFAULT_OPT_PREFIX;\n-      defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n-      defaultArgName = DEFAULT_ARG_NAME;\n-   }\n-\n-   // ------------------------------------------------------------------ Public\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          Options options )\n-   {\n-       printHelp( defaultWidth, cmdLineSyntax, null, options, null, false );\n-   }\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          Options options,\n-                          boolean autoUsage )\n-   {\n-       printHelp( defaultWidth, cmdLineSyntax, null, options, null, autoUsage );\n-   }\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer )\n-   {\n-       printHelp( cmdLineSyntax, header, options, footer, false );\n-   }\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer,\n-                          boolean autoUsage )\n-   {\n-      printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage );\n-   }\n-   \n-   public void printHelp( int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer )\n-   {\n-       printHelp( width, cmdLineSyntax, header, options, footer, false );\n-   }\n-\n-   public void printHelp( int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer,\n-                          boolean autoUsage )\n-   {\n-      PrintWriter pw = new PrintWriter(System.out);\n-      printHelp( pw, width, cmdLineSyntax, header,\n-                 options, defaultLeftPad, defaultDescPad, footer, autoUsage );\n-      pw.flush();\n-   }\n-   public void printHelp( PrintWriter pw,\n-                          int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          int leftPad,\n-                          int descPad,\n-                          String footer )\n-   throws IllegalArgumentException\n-   {\n-       printHelp( pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false );\n-   }\n-\n-   public void printHelp( PrintWriter pw,\n-                          int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          int leftPad,\n-                          int descPad,\n-                          String footer,\n-                          boolean autoUsage )\n-      throws IllegalArgumentException\n-   {\n-      if ( cmdLineSyntax == null || cmdLineSyntax.length() == 0 )\n-      {\n-         throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n-      }\n-\n-      if ( autoUsage ) {\n-          printUsage( pw, width, cmdLineSyntax, options );\n-      }\n-      else {\n-          printUsage( pw, width, cmdLineSyntax );\n-      }\n-\n-      if ( header != null && header.trim().length() > 0 )\n-      {\n-         printWrapped( pw, width, header );\n-      }\n-      printOptions( pw, width, options, leftPad, descPad );\n-      if ( footer != null && footer.trim().length() > 0 )\n-      {\n-         printWrapped( pw, width, footer );\n-      }\n-   }\n-\n-   /**\n-    * <p>Prints the usage statement for the specified application.</p>\n-    *\n-    * @param pw The PrintWriter to print the usage statement \n-    * @param width ??\n-    * @param appName The application name\n-    * @param options The command line Options\n-    * @see #appendOptionGroup(StringBuffer,OptionGroup)\n-    * @see #appendOption(StringBuffer,Option,boolean)\n-    *\n-    */\n-   public void printUsage( PrintWriter pw, int width, String app, Options options ) \n-   {\n-       // initialise the string buffer\n-       StringBuffer buff = new StringBuffer( defaultSyntaxPrefix ).append( app ).append( \" \" );\n-       \n-       // create a list for processed option groups\n-       final Collection processedGroups = new ArrayList();\n-\n-       // temp variable\n-       Option option;\n-       \n-       // iterate over the options\n-       for ( Iterator i = options.getOptions().iterator(); i.hasNext(); )\n-       {\n-           // get the next Option\n-           option = (Option) i.next();\n-\n-           // check if the option is part of an OptionGroup\n-           OptionGroup group = options.getOptionGroup( option );\n-\n-           // if the option is part of a group \n-           if( group != null) {\n-               // and if the group has not already been processed\n-               if( !processedGroups.contains(group) ) {\n-                   // add the group to the processed list\n-                   processedGroups.add( group );\n-                   // add the usage clause\n-                   appendOptionGroup( buff, group );\n-               }\n-               // otherwise the option was displayed in the group\n-               // previously so ignore it.\n-           }\n-           // if the Option is not part of an OptionGroup\n-           else {\n-               appendOption( buff, option, option.isRequired() );\n-           }\n-           \n-           if( i.hasNext() ){\n-               buff.append( \" \" );\n-           }\n-       }\n-\n-       // call printWrapped\n-       printWrapped( pw, width, buff.toString().indexOf(' ')+1,\n-                     buff.toString() );\n-   }\n-   \n-   /**\n-    * Appends the usage clause for an OptionGroup to a StringBuffer.  \n-    * The clause is wrapped in square brackets if the group is required.\n-    * The display of the options is handled by appendOption\n-    * @param buff the StringBuffer to append to\n-    * @param group the group to append\n-    * @see #appendOption(StringBuffer,Option,boolean)\n-    */\n-   private static void appendOptionGroup( final StringBuffer buff, final OptionGroup group )\n-   {\n-       if( !group.isRequired() ) {\n-           buff.append( \"[\" ); \n-       }\n-\n-       // for each option in the OptionGroup\n-       for( Iterator i = group.getOptions().iterator(); i.hasNext(); ) {\n-           // whether the option is required or not is handled at group level\n-           appendOption( buff, (Option)i.next(), true);\n-           if( i.hasNext() ) {\n-               buff.append( \" | \" );\n-           }\n-       }\n-       \n-       if( !group.isRequired() ) {\n-           buff.append( \"]\" ); \n-       }\n-   }\n-   \n-   /**\n-    * Appends the usage clause for an Option to a StringBuffer.  \n-    * The clause is wrapped in square brackets if the group is required.\n-    * The display of the options is handled by appendOption\n-    * @param buff the StringBuffer to append to\n-    * @param group the group to append\n-    * @see #appendOption(StringBuffer,Option,boolean)\n-    */\n-   private static void appendOption( final StringBuffer buff, final Option option, final boolean required)\n-   {\n-       if( !required ) {\n-           buff.append( \"[\" );\n-       }\n-\n-       if( option.getOpt() != null ) {\n-           buff.append( \"-\" ).append( option.getOpt() );\n-       }\n-       else {\n-           buff.append( \"--\" ).append( option.getLongOpt() );\n-       }\n-\n-       // if the Option has a value\n-       if( option.hasArg() && option.getArgName() != null ) {\n-           buff.append( \" <\" ).append( option.getArgName() ).append( \">\" );\n-       }\n-\n-       // if the Option is not a required option\n-       if( !required ) {\n-           buff.append( \"]\" );\n-       }\n-   }\n-       \n-\n-   public void printUsage( PrintWriter pw, int width, String cmdLineSyntax )\n-   {\n-      int argPos = cmdLineSyntax.indexOf(' ') + 1;\n-      printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos,\n-                   defaultSyntaxPrefix + cmdLineSyntax);\n-   }\n-\n-   public void printOptions( PrintWriter pw, int width, Options options, int leftPad, int descPad )\n-   {\n-      StringBuffer sb = new StringBuffer();\n-      renderOptions(sb, width, options, leftPad, descPad);\n-      pw.println(sb.toString());\n-   }\n-\n-   public void printWrapped( PrintWriter pw, int width, String text )\n-   {\n-      printWrapped(pw, width, 0, text);\n-   }\n-\n-   public void printWrapped( PrintWriter pw, int width, int nextLineTabStop, String text )\n-   {\n-      StringBuffer sb = new StringBuffer(text.length());\n-      renderWrappedText(sb, width, nextLineTabStop, text);\n-      pw.println(sb.toString());\n-   }\n-\n-   // --------------------------------------------------------------- Protected\n-\n-   protected StringBuffer renderOptions( StringBuffer sb,\n-                                         int width,\n-                                         Options options,\n-                                         int leftPad,\n-                                         int descPad )\n-   {\n-      final String lpad = createPadding(leftPad);\n-      final String dpad = createPadding(descPad);\n-\n-      //first create list containing only <lpad>-a,--aaa where -a is opt and --aaa is\n-      //long opt; in parallel look for the longest opt string\n-      //this list will be then used to sort options ascending\n-      int max = 0;\n-      StringBuffer optBuf;\n-      List prefixList = new ArrayList();\n-      Option option;\n-      List optList = options.helpOptions();\n-      Collections.sort( optList, new StringBufferComparator() );\n-      for ( Iterator i = optList.iterator(); i.hasNext(); )\n-      {\n-         option = (Option) i.next();\n-         optBuf = new StringBuffer(8);\n-\n-         if ( option.getOpt() == null )\n-         {\n-             optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n-         }\n-         else\n-         {\n-             optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n-             if ( option.hasLongOpt() )\n-             {\n-                optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n-             }\n-\n-         }\n-\n-         if( option.hasArg() ) {\n-             if( option.hasArgName() ) {\n-                 optBuf.append(\" <\").append( option.getArgName() ).append( \">\" );\n-             }\n-             else {\n-                 optBuf.append(' ');\n-             }\n-         }\n-\n-         prefixList.add(optBuf);\n-         max = optBuf.length() > max ? optBuf.length() : max;\n-      }\n-      int x = 0;\n-      for ( Iterator i = optList.iterator(); i.hasNext(); )\n-      {\n-         option = (Option) i.next();\n-         optBuf = new StringBuffer( prefixList.get( x++ ).toString() );\n-\n-         if ( optBuf.length() < max )\n-         {\n-             optBuf.append(createPadding(max - optBuf.length()));\n-         }\n-         optBuf.append( dpad );\n-         \n-         int nextLineTabStop = max + descPad;\n-\n-         if( option.getDescription() != null ) {\n-             optBuf.append( option.getDescription() );\n-         }\n-         renderWrappedText(sb, width, nextLineTabStop,\n-                           optBuf.toString());\n-         if ( i.hasNext() )\n-         {\n-             sb.append(defaultNewLine);\n-         }\n-      }\n-\n-      return sb;\n-   }\n-\n-   protected StringBuffer renderWrappedText( StringBuffer sb,\n-                                             int width,\n-                                             int nextLineTabStop,\n-                                             String text )\n-   {\n-      int pos = findWrapPos( text, width, 0);\n-      if ( pos == -1 )\n-      {\n-         sb.append(rtrim(text));\n-         return sb;\n-      }\n-      else\n-      {\n-         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n-      }\n-\n-      //all following lines must be padded with nextLineTabStop space characters\n-      final String padding = createPadding(nextLineTabStop);\n-\n-      while ( true )\n-      {\n-         text = padding + text.substring(pos).trim();\n-         pos = findWrapPos( text, width, nextLineTabStop );\n-         if ( pos == -1 )\n-         {\n-            sb.append(text);\n+public class HelpFormatter {\n+    // --------------------------------------------------------------- Constants\n+\n+    /** default number of characters per line */\n+    public static final int DEFAULT_WIDTH = 74;\n+\n+    /** default padding to the left of each line */\n+    public static final int DEFAULT_LEFT_PAD = 1;\n+\n+    /** ?? */\n+    public static final int DEFAULT_DESC_PAD = 3;\n+\n+    /** the string to display at the begining of the usage statement */\n+    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n+\n+    /** default prefix for shortOpts */\n+    public static final String DEFAULT_OPT_PREFIX = \"-\";\n+\n+    /** default prefix for long Option */\n+    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n+\n+    /** default name for an argument */\n+    public static final String DEFAULT_ARG_NAME = \"arg\";\n+\n+    // -------------------------------------------------------------- Attributes\n+\n+    /** number of characters per line */\n+    private int defaultWidth = DEFAULT_WIDTH;\n+\n+    /** amount of padding to the left of each line */\n+    private int defaultLeftPad = DEFAULT_LEFT_PAD;\n+\n+    /** ?? */\n+    private int defaultDescPad = DEFAULT_DESC_PAD;\n+\n+    /** the string to display at the begining of the usage statement */\n+    private String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n+\n+    /** the new line character/string ?? */\n+    private String defaultNewLine = System.getProperty(\"line.separator\");\n+\n+    /** the shortOpt prefix */\n+    private String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n+\n+    /** the long Opt prefix */\n+    private String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n+\n+    /** the name of the argument */\n+    private String defaultArgName = DEFAULT_ARG_NAME;\n+\n+    /**\n+     * Sets the 'width'.\n+     *\n+     * @param width the new value of 'width'\n+     */\n+    public void setWidth(int width)\n+    {\n+        this.defaultWidth = width;\n+    }\n+\n+    /**\n+     * Returns the 'width'.\n+     *\n+     * @return the 'width'\n+     */\n+    public int getWidth()\n+    {\n+        return this.defaultWidth;\n+    }\n+\n+    /**\n+     * Sets the 'leftPadding'.\n+     *\n+     * @param padding the new value of 'leftPadding'\n+     */\n+    public void setLeftPadding(int padding)\n+    {\n+        this.defaultLeftPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'leftPadding'.\n+     *\n+     * @return the 'leftPadding'\n+     */\n+    public int getLeftPadding()\n+    {\n+        return this.defaultLeftPad;\n+    }\n+\n+    /**\n+     * Sets the 'descPadding'.\n+     *\n+     * @param padding the new value of 'descPadding'\n+     */\n+    public void setDescPadding(int padding)\n+    {\n+        this.defaultDescPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'descPadding'.\n+     *\n+     * @return the 'descPadding'\n+     */\n+    public int getDescPadding()\n+    {\n+        return this.defaultDescPad;\n+    }\n+\n+    /**\n+     * Sets the 'syntaxPrefix'.\n+     *\n+     * @param prefix the new value of 'syntaxPrefix'\n+     */\n+    public void setSyntaxPrefix(String prefix)\n+    {\n+        this.defaultSyntaxPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'syntaxPrefix'.\n+     *\n+     * @return the 'syntaxPrefix'\n+     */\n+    public String getSyntaxPrefix()\n+    {\n+        return this.defaultSyntaxPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'newLine'.\n+     *\n+     * @param newline the new value of 'newLine'\n+     */\n+    public void setNewLine(String newline)\n+    {\n+        this.defaultNewLine = newline;\n+    }\n+\n+    /**\n+     * Returns the 'newLine'.\n+     *\n+     * @return the 'newLine'\n+     */\n+    public String getNewLine()\n+    {\n+        return this.defaultNewLine;\n+    }\n+\n+    /**\n+     * Sets the 'optPrefix'.\n+     *\n+     * @param prefix the new value of 'optPrefix'\n+     */\n+    public void setOptPrefix(String prefix)\n+    {\n+        this.defaultOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'optPrefix'.\n+     *\n+     * @return the 'optPrefix'\n+     */\n+    public String getOptPrefix()\n+    {\n+        return this.defaultOptPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'longOptPrefix'.\n+     *\n+     * @param prefix the new value of 'longOptPrefix'\n+     */\n+    public void setLongOptPrefix(String prefix)\n+    {\n+        this.defaultLongOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'longOptPrefix'.\n+     *\n+     * @return the 'longOptPrefix'\n+     */\n+    public String getLongOptPrefix()\n+    {\n+        return this.defaultLongOptPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'argName'.\n+     *\n+     * @param name the new value of 'argName'\n+     */\n+    public void setArgName(String name)\n+    {\n+        this.defaultArgName = name;\n+    }\n+\n+    /**\n+     * Returns the 'argName'.\n+     *\n+     * @return the 'argName'\n+     */\n+    public String getArgName()\n+    {\n+        return this.defaultArgName;\n+    }\n+\n+\n+    // ------------------------------------------------------------------ Public\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options, \n+                          boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, \n+                          String footer)\n+    {\n+        printHelp(cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, \n+                          String footer, boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, \n+                  autoUsage);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header, \n+                          Options options, String footer)\n+    {\n+        printHelp(width, cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header, \n+                          Options options, String footer, boolean autoUsage)\n+    {\n+        PrintWriter pw = new PrintWriter(System.out);\n+\n+        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, \n+                  defaultDescPad, footer, autoUsage);\n+        pw.flush();\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n+                          String header, Options options, int leftPad, \n+                          int descPad, String footer)\n+    {\n+        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, \n+                  footer, false);\n+    }\n+\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n+                          String header, Options options, int leftPad, \n+                          int descPad, String footer, boolean autoUsage)\n+    {\n+        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n+        {\n+            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n+        }\n+\n+        if (autoUsage)\n+        {\n+            printUsage(pw, width, cmdLineSyntax, options);\n+        }\n+        else\n+        {\n+            printUsage(pw, width, cmdLineSyntax);\n+        }\n+\n+        if ((header != null) && (header.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, header);\n+        }\n+\n+        printOptions(pw, width, options, leftPad, descPad);\n+\n+        if ((footer != null) && (footer.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, footer);\n+        }\n+    }\n+\n+    /**\n+     * <p>Prints the usage statement for the specified application.</p>\n+     *\n+     * @param pw The PrintWriter to print the usage statement \n+     * @param width The number of characters to display per line\n+     * @param app The application name\n+     * @param options The command line Options\n+     *\n+     */\n+    public void printUsage(PrintWriter pw, int width, String app, \n+                           Options options)\n+    {\n+        // initialise the string buffer\n+        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n+                                                                 .append(\" \");\n+\n+        // create a list for processed option groups\n+        final Collection processedGroups = new ArrayList();\n+\n+        // temp variable\n+        Option option;\n+\n+        // iterate over the options\n+        for (Iterator i = options.getOptions().iterator(); i.hasNext();)\n+        {\n+            // get the next Option\n+            option = (Option) i.next();\n+\n+            // check if the option is part of an OptionGroup\n+            OptionGroup group = options.getOptionGroup(option);\n+\n+            // if the option is part of a group \n+            if (group != null)\n+            {\n+                // and if the group has not already been processed\n+                if (!processedGroups.contains(group))\n+                {\n+                    // add the group to the processed list\n+                    processedGroups.add(group);\n+\n+\n+                    // add the usage clause\n+                    appendOptionGroup(buff, group);\n+                }\n+\n+                // otherwise the option was displayed in the group\n+                // previously so ignore it.\n+            }\n+\n+            // if the Option is not part of an OptionGroup\n+            else\n+            {\n+                appendOption(buff, option, option.isRequired());\n+            }\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" \");\n+            }\n+        }\n+\n+\n+        // call printWrapped\n+        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n+                     buff.toString());\n+    }\n+\n+    /**\n+     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n+     * The clause is wrapped in square brackets if the group is required.\n+     * The display of the options is handled by appendOption\n+     * @param buff the StringBuffer to append to\n+     * @param group the group to append\n+     * @see #appendOption(StringBuffer,Option,boolean)\n+     */\n+    private static void appendOptionGroup(final StringBuffer buff, \n+                                          final OptionGroup group)\n+    {\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        // for each option in the OptionGroup\n+        for (Iterator i = group.getOptions().iterator(); i.hasNext();)\n+        {\n+            // whether the option is required or not is handled at group level\n+            appendOption(buff, (Option) i.next(), true);\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" | \");\n+            }\n+        }\n+\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+\n+    /**\n+     * Appends the usage clause for an Option to a StringBuffer.  \n+     *\n+     * @param buff the StringBuffer to append to\n+     * @param option the Option to append\n+     * @param required whether the Option is required or not\n+     */\n+    private static void appendOption(final StringBuffer buff, \n+                                     final Option option, \n+                                     final boolean required)\n+    {\n+        if (!required)\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        if (option.getOpt() != null)\n+        {\n+            buff.append(\"-\").append(option.getOpt());\n+        }\n+        else\n+        {\n+            buff.append(\"--\").append(option.getLongOpt());\n+        }\n+\n+        // if the Option has a value\n+        if (option.hasArg() && (option.getArgName() != null))\n+        {\n+            buff.append(\" <\").append(option.getArgName()).append(\">\");\n+        }\n+\n+        // if the Option is not a required option\n+        if (!required)\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+\n+    /**\n+     * <p>Print the cmdLineSyntax to the specified writer, using the\n+     * specified width.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters per line for the usage statement.\n+     * @param cmdLineSyntax The usage statement.\n+     */\n+    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n+    {\n+        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n+\n+        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n+                     defaultSyntaxPrefix + cmdLineSyntax);\n+    }\n+\n+    /**\n+     * <p>Print the help for the specified Options to the specified writer, \n+     * using the specified width, left padding and description padding.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     */\n+    public void printOptions(PrintWriter pw, int width, Options options, \n+                             int leftPad, int descPad)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+\n+        renderOptions(sb, width, options, leftPad, descPad);\n+        pw.println(sb.toString());\n+    }\n+\n+    /**\n+     * <p>Print the specified text to the specified PrintWriter.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, String text)\n+    {\n+        printWrapped(pw, width, 0, text);\n+    }\n+\n+    /**\n+     * <p>Print the specified text to the specified PrintWriter.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, \n+                             String text)\n+    {\n+        StringBuffer sb = new StringBuffer(text.length());\n+\n+        renderWrappedText(sb, width, nextLineTabStop, text);\n+        pw.println(sb.toString());\n+    }\n+\n+    // --------------------------------------------------------------- Protected\n+\n+    /**\n+     * <p>Render the specified Options and return the rendered Options\n+     * in a StringBuffer.</p>\n+     *\n+     * @param sb The StringBuffer to place the rendered Options into.\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderOptions(StringBuffer sb, int width, \n+                                         Options options, int leftPad, \n+                                         int descPad)\n+    {\n+        final String lpad = createPadding(leftPad);\n+        final String dpad = createPadding(descPad);\n+\n+        // first create list containing only <lpad>-a,--aaa where \n+        // -a is opt and --aaa is long opt; in parallel look for \n+        // the longest opt string this list will be then used to \n+        // sort options ascending\n+        int max = 0;\n+        StringBuffer optBuf;\n+        List prefixList = new ArrayList();\n+        Option option;\n+        List optList = options.helpOptions();\n+\n+        Collections.sort(optList, new StringBufferComparator());\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            option = (Option) i.next();\n+            optBuf = new StringBuffer(8);\n+\n+            if (option.getOpt() == null)\n+            {\n+                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n+                      .append(option.getLongOpt());\n+            }\n+            else\n+            {\n+                optBuf.append(lpad).append(defaultOptPrefix)\n+                      .append(option.getOpt());\n+\n+                if (option.hasLongOpt())\n+                {\n+                    optBuf.append(',').append(defaultLongOptPrefix)\n+                          .append(option.getLongOpt());\n+                }\n+            }\n+\n+            if (option.hasArg())\n+            {\n+                if (option.hasArgName())\n+                {\n+                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n+                }\n+                else\n+                {\n+                    optBuf.append(' ');\n+                }\n+            }\n+\n+            prefixList.add(optBuf);\n+            max = (optBuf.length() > max)       ? optBuf.length() : max;\n+        }\n+\n+        int x = 0;\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            option = (Option) i.next();\n+            optBuf = new StringBuffer(prefixList.get(x++).toString());\n+\n+            if (optBuf.length() < max)\n+            {\n+                optBuf.append(createPadding(max - optBuf.length()));\n+            }\n+\n+            optBuf.append(dpad);\n+\n+            int nextLineTabStop = max + descPad;\n+\n+            if (option.getDescription() != null)\n+            {\n+                optBuf.append(option.getDescription());\n+            }\n+\n+            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n+\n+            if (i.hasNext())\n+            {\n+                sb.append(defaultNewLine);\n+            }\n+        }\n+\n+        return sb;\n+    }\n+\n+    /**\n+     * <p>Render the specified text and return the rendered Options\n+     * in a StringBuffer.</p>\n+     *\n+     * @param sb The StringBuffer to place the rendered text into.\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be rendered.\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n+                                             int nextLineTabStop, String text)\n+    {\n+        int pos = findWrapPos(text, width, 0);\n+\n+        if (pos == -1)\n+        {\n+            sb.append(rtrim(text));\n+\n             return sb;\n-         }\n-\n-         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n-      }\n-\n-   }\n-\n-   /**\n-    * Finds the next text wrap position after <code>startPos</code> for the text\n-    * in <code>sb</code> with the column width <code>width</code>.\n-    * The wrap point is the last postion before startPos+width having a whitespace\n-    * character (space, \\n, \\r).\n-    *\n-    * @param sb text to be analyzed\n-    * @param width width of the wrapped text\n-    * @param startPos position from which to start the lookup whitespace character\n-    * @return postion on which the text must be wrapped or -1 if the wrap position is at the end\n-    *         of the text\n-    */\n-   protected int findWrapPos( String text, int width, int startPos )\n-   {\n-      int pos = -1;\n-      // the line ends before the max wrap pos or a new line char found\n-      if ( ((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)  ||\n-           ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width) )\n-      {\n-         return pos;\n-      }\n-      else if ( (startPos + width) >= text.length() )\n-      {\n-         return -1;\n-      }\n-\n-      //look for the last whitespace character before startPos+width\n-      pos = startPos + width;\n-      char c;\n-      while ( pos >= startPos && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r' )\n-      {\n-         --pos;\n-      }\n-      //if we found it - just return\n-      if ( pos > startPos )\n-      {\n-         return pos;\n-      }\n-      else\n-      {\n-         //must look for the first whitespace chearacter after startPos + width\n-         pos = startPos + width;\n-         while ( pos <= text.length() && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r' )\n-         {\n-            ++pos;\n-         }\n-         return pos == text.length() ? -1 : pos;\n-      }\n-   }\n-\n-   protected String createPadding(int len)\n-   {\n-      StringBuffer sb = new StringBuffer(len);\n-      for ( int i = 0; i < len; ++i )\n-      {\n-         sb.append(' ');\n-      }\n-      return sb.toString();\n-   }\n-\n-   protected String rtrim( String s )\n-   {\n-      if ( s == null || s.length() == 0 )\n-      {\n-         return s;\n-      }\n-\n-      int pos = s.length();\n-      while ( pos >= 0 && Character.isWhitespace(s.charAt(pos-1)) )\n-      {\n-         --pos;\n-      }\n-      return s.substring(0, pos);\n-   }\n-\n-   // ------------------------------------------------------- Package protected\n-   \n-   // ----------------------------------------------------------------- Private\n-   \n-   // ----------------------------------------------------------- Inner classes\n+        }\n+        else\n+        {\n+            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+        }\n \n-    private static class StringBufferComparator\n-    implements Comparator\n+        // all following lines must be padded with nextLineTabStop space \n+        // characters\n+        final String padding = createPadding(nextLineTabStop);\n+\n+        while (true)\n+        {\n+            text = padding + text.substring(pos).trim();\n+            pos = findWrapPos(text, width, nextLineTabStop);\n+\n+            if (pos == -1)\n+            {\n+                sb.append(text);\n+\n+                return sb;\n+            }\n+\n+            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+        }\n+    }\n+\n+    /**\n+     * Finds the next text wrap position after <code>startPos</code> for the \n+     * text in <code>text</code> with the column width <code>width</code>.\n+     * The wrap point is the last postion before startPos+width having a \n+     * whitespace character (space, \\n, \\r).\n+     *\n+     * @param text The text being searched for the wrap position\n+     * @param width width of the wrapped text\n+     * @param startPos position from which to start the lookup whitespace \n+     * character\n+     * @return postion on which the text must be wrapped or -1 if the wrap \n+     * position is at the end of the text\n+     */\n+    protected int findWrapPos(String text, int width, int startPos)\n     {\n-        public int compare( Object o1, Object o2 )\n+        int pos = -1;\n+\n+        // the line ends before the max wrap pos or a new line char found\n+        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n+            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n+        {\n+            return pos;\n+        }\n+        else if ((startPos + width) >= text.length())\n+        {\n+            return -1;\n+        }\n+\n+\n+        // look for the last whitespace character before startPos+width\n+        pos = startPos + width;\n+\n+        char c;\n+\n+        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n+               && (c != '\\n') && (c != '\\r'))\n+        {\n+            --pos;\n+        }\n+\n+        // if we found it - just return\n+        if (pos > startPos)\n+        {\n+            return pos;\n+        }\n+        else\n+        {\n+            // must look for the first whitespace chearacter after startPos \n+            // + width\n+            pos = startPos + width;\n+\n+            while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n+                   && (c != '\\n') && (c != '\\r'))\n+            {\n+                ++pos;\n+            }\n+\n+            return (pos == text.length())        ? (-1) : pos;\n+        }\n+    }\n+\n+    /**\n+     * <p>Return a String of padding of length <code>len</code>.</p>\n+     *\n+     * @param len The length of the String of padding to create.\n+     *\n+     * @return The String of padding\n+     */\n+    protected String createPadding(int len)\n+    {\n+        StringBuffer sb = new StringBuffer(len);\n+\n+        for (int i = 0; i < len; ++i)\n+        {\n+            sb.append(' ');\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>Remove the trailing whitespace from the specified String.</p>\n+     *\n+     * @param s The String to remove the trailing padding from.\n+     *\n+     * @return The String of without the trailing padding\n+     */\n+    protected String rtrim(String s)\n+    {\n+        if ((s == null) || (s.length() == 0))\n+        {\n+            return s;\n+        }\n+\n+        int pos = s.length();\n+\n+        while ((pos >= 0) && Character.isWhitespace(s.charAt(pos - 1)))\n+        {\n+            --pos;\n+        }\n+\n+        return s.substring(0, pos);\n+    }\n+\n+    // ------------------------------------------------------ Package protected\n+    // ---------------------------------------------------------------- Private\n+    // ---------------------------------------------------------- Inner classes\n+    /**\n+     * <p>This class implements the <code>Comparator</code> interface\n+     * for comparing StringBuffers.</p>\n+     */\n+    private static class StringBufferComparator\n+        implements Comparator {\n+\n+        /**\n+         * <p>Compares its two arguments for order. Returns a negative \n+         * integer, zero, or a positive integer as the first argument \n+         * is less than, equal to, or greater than the second.</p>\n+         *\n+         * @param o1 The first StringBuffer to be compared.\n+         * @param o2 The second StringBuffer to be compared.\n+         *\n+         * @return a negative integer, zero, or a positive integer as \n+         * the first argument is less than, equal to, or greater than the \n+         * second.\n+         */\n+        public int compare(Object o1, Object o2)\n         {\n             String str1 = stripPrefix(o1.toString());\n             String str2 = stripPrefix(o2.toString());\n+\n             return (str1.compareTo(str2));\n         }\n \n+        /**\n+         * <p>Removes any leading hyphens from <code>strOption</code>.</p>\n+         *         \n+         * @param strOption The String from which to strip the leading\n+         * hyphens.\n+         *\n+         * @return The String without any leading hyphens.\n+         */\n         private String stripPrefix(String strOption)\n         {\n             // Strip any leading '-' characters\n             int iStartIndex = strOption.lastIndexOf('-');\n+\n             if (iStartIndex == -1)\n             {\n-              iStartIndex = 0;\n+                iStartIndex = 0;\n             }\n-            return strOption.substring(iStartIndex);\n \n+            return strOption.substring(iStartIndex);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
      "files_name_in_blame_commit": [
        "CommandLineParser.java",
        "AlreadySelectedException.java",
        "ParseException.java",
        "MissingArgumentException.java",
        "BasicParser.java",
        "PosixParser.java",
        "HelpFormatter.java",
        "PatternOptionBuilder.java",
        "UnrecognizedOptionException.java",
        "TestHelpFormatter.java",
        "OptionGroup.java",
        "GnuParser.java",
        "Option.java",
        "OptionBuilder.java",
        "CommandLine.java",
        "Options.java",
        "TypeHandler.java",
        "Util.java",
        "Parser.java",
        "MissingOptionException.java",
        "OptionValidator.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 26
  }
}
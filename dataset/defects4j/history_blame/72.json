{
  "id": "72",
  "blame_commit": {
    "commit": {
      "commit_id": "5000be31966a575f54d80ef85ee49ca1f5cb6ea8",
      "commit_message": "First draft of a simple XML treebuilder / parser.\n\nThis provides an alternative to the HTML5 parser which enforces HTML\nsemantics on the parsed input. The simple XML parser has no understanding\nof HTML, and will parse the input as-is into a DOM.",
      "commit_author": "Jonathan Hedley",
      "commit_date": "2012-02-26 17:23:10",
      "commit_parent": "1e84edbe208aab0c9330eadc50f9773d81d70cd6"
    },
    "function": {
      "function_name": "resetInsertionMode",
      "function_code_before": "",
      "function_code_after": "void resetInsertionMode() {\n    boolean last = false;\n    Iterator<Element> it = stack.descendingIterator();\n    while (it.hasNext()) {\n        Element node = it.next();\n        if (!it.hasNext()) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; // frag\n        } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; // frag\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; // frag\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; // frag\n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; // frag\n        }\n    }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 351,
      "function_after_end_line": 399,
      "function_before_token_count": 0,
      "function_after_token_count": 341,
      "functions_name_modified_file": [
        "setPendingTableCharacters",
        "getStack",
        "markInsertionMode",
        "clearFormattingElementsToLastMarker",
        "inSpecificScope",
        "push",
        "isSameFormattingElement",
        "toString",
        "aboveOnStack",
        "isInActiveFormattingElements",
        "maybeSetBaseUri",
        "inSelectScope",
        "transition",
        "framesetOk",
        "inTableScope",
        "isFragmentParsing",
        "newPendingTableCharacters",
        "setFosterInserts",
        "popStackToBefore",
        "insert",
        "parseFragment",
        "removeFromActiveFormattingElements",
        "generateImpliedEndTags",
        "getFormElement",
        "clearStackToTableRowContext",
        "removeFromStack",
        "resetInsertionMode",
        "state",
        "getBaseUri",
        "insertInFosterParent",
        "getFromStack",
        "process",
        "parse",
        "insertMarkerToFormattingElements",
        "inScope",
        "pushActiveFormattingElements",
        "clearStackToTableContext",
        "insertEmpty",
        "clearStackToTableBodyContext",
        "insertNode",
        "replaceInQueue",
        "clearStackToContext",
        "isFosterInserts",
        "reconstructFormattingElements",
        "inButtonScope",
        "replaceOnStack",
        "error",
        "popStackToClose",
        "onStack",
        "originalState",
        "setHeadElement",
        "isElementInQueue",
        "replaceActiveFormattingElement",
        "getPendingTableCharacters",
        "inListItemScope",
        "setFormElement",
        "getDocument",
        "getHeadElement",
        "isSpecial",
        "pop",
        "insertOnStackAfter",
        "getActiveFormattingElement",
        "HtmlTreeBuilder"
      ],
      "functions_name_all_files": [
        "getStack",
        "parsesSimpleDocument",
        "toString",
        "aboveOnStack",
        "inTableScope",
        "ignoresDupeEndTrTag",
        "setFosterInserts",
        "handlesBaseWithoutHref",
        "exitTableBody",
        "popStackToBefore",
        "generateImpliedEndTags",
        "resetInsertionMode",
        "state",
        "handlesSolidusAtAttributeEnd",
        "testSimpleXmlParse",
        "getFromStack",
        "initialiseParse",
        "pushActiveFormattingElements",
        "clearStackToTableContext",
        "handlesCdata",
        "createsStructureFromBodySnippet",
        "handlesTbodyTable",
        "discardsNakedTds",
        "handleMissingTr",
        "findsCharsetInMalformedMeta",
        "testRelaxedTags",
        "testSpaceAfterTag",
        "handlesTextAfterData",
        "replaceActiveFormattingElement",
        "handlesEscapedScript",
        "handlesUnknownTags",
        "handlesMisnestedTagsBI",
        "getDocument",
        "getHeadElement",
        "noImplicitFormForTextAreas",
        "normalisesHeadlessBody",
        "handlesEscapedData",
        "HtmlTreeBuilder",
        "markInsertionMode",
        "handlesInvalidStartTags",
        "maybeSetBaseUri",
        "testHeaderContents",
        "testSpanContents",
        "transition",
        "framesetOk",
        "getFormElement",
        "clearStackToTableRowContext",
        "testNoImagesInNoScriptInHead",
        "getBaseUri",
        "insertInFosterParent",
        "testAFlowContents",
        "handlesWhitespaceInoDocType",
        "clearStackToTableBodyContext",
        "testHgroup",
        "insertNode",
        "pop",
        "handlesUnclosedDefinitionLists",
        "handlesNullInData",
        "handlesSolidusInA",
        "handlesTextArea",
        "error",
        "popStackToClose",
        "runParser",
        "normalisesDocument",
        "originalState",
        "currentElement",
        "dropsUnterminatedTag",
        "doesNotCreateImplicitLists",
        "handlesWhatWgExpensesTableExample",
        "parsesRoughAttributes",
        "handlesImplicitCaptionClose",
        "handlesUnclosedRawtextAtEof",
        "anythingElse",
        "setPendingTableCharacters",
        "handlesBaseTags",
        "handlesSpanInTbody",
        "clearFormattingElementsToLastMarker",
        "push",
        "handlesUnknownInlineTags",
        "newPendingTableCharacters",
        "handlesMisnestedTagsBP",
        "parsesComments",
        "noTableDirectInTable",
        "handlesUnknownNamespaceTags",
        "normalisedBodyAfterContent",
        "removeFromStack",
        "handlesJavadocFont",
        "handlesFrames",
        "closeCell",
        "insertMarkerToFormattingElements",
        "inScope",
        "commentBeforeHtml",
        "testFontFlowContents",
        "handlesNestedImplicitTable",
        "clearStackToContext",
        "isFosterInserts",
        "handlesUnclosedTitleAtEof",
        "inButtonScope",
        "handlesKnownEmptyBlocks",
        "parsesUnterminatedComments",
        "onStack",
        "handles0CharacterAsText",
        "normalisesEmptyDocument",
        "handleRawtext",
        "insertOnStackAfter",
        "getActiveFormattingElement",
        "handlesMultiClosingBody",
        "handlesNullInComments",
        "isSameFormattingElement",
        "handlesUnclosedTitle",
        "parsesQuiteRoughAttributes",
        "inSpecificScope",
        "reconstructFormattingElementsInTable",
        "inSelectScope",
        "parsesBodyFragment",
        "emptyTdTag",
        "isWhitespace",
        "insert",
        "parseFragment",
        "removeFromActiveFormattingElements",
        "parseBodyFragmentRelaxed",
        "parsesUnterminatedOption",
        "handlesNewlinesAndWhitespaceInTag",
        "process",
        "parse",
        "handlesUnexpectedMarkupInTables",
        "ParseError",
        "insertEmpty",
        "replaceInQueue",
        "reconstructFormattingElements",
        "handlesUnclosedScriptAtEof",
        "handlesUnclosedFormattingElements",
        "getPos",
        "handlesBlocksInDefinitions",
        "replaceOnStack",
        "handlesDataOnlyTags",
        "setHeadElement",
        "isElementInQueue",
        "getPendingTableCharacters",
        "inListItemScope",
        "setFormElement",
        "isSpecial",
        "handleRcData",
        "anyOtherEndTag",
        "createsDocumentStructure",
        "dropsUnterminatedAttribute",
        "isFragmentParsing",
        "getErrorMsg",
        "parsesUnterminatedTextarea",
        "parseBodyFragment",
        "isInActiveFormattingElements"
      ],
      "functions_name_co_evolved_modified_file": [
        "setPendingTableCharacters",
        "getStack",
        "markInsertionMode",
        "clearFormattingElementsToLastMarker",
        "inSpecificScope",
        "push",
        "toString",
        "isSameFormattingElement",
        "aboveOnStack",
        "maybeSetBaseUri",
        "inSelectScope",
        "transition",
        "framesetOk",
        "newPendingTableCharacters",
        "isFragmentParsing",
        "inTableScope",
        "setFosterInserts",
        "popStackToBefore",
        "insert",
        "removeFromActiveFormattingElements",
        "parseFragment",
        "generateImpliedEndTags",
        "getFormElement",
        "clearStackToTableRowContext",
        "removeFromStack",
        "resetInsertionMode",
        "state",
        "getBaseUri",
        "insertInFosterParent",
        "getFromStack",
        "process",
        "parse",
        "insertMarkerToFormattingElements",
        "inScope",
        "pushActiveFormattingElements",
        "clearStackToTableContext",
        "insertEmpty",
        "clearStackToTableBodyContext",
        "insertNode",
        "HtmlTreeBuilder",
        "replaceInQueue",
        "clearStackToContext",
        "isFosterInserts",
        "reconstructFormattingElements",
        "inButtonScope",
        "replaceOnStack",
        "popStackToClose",
        "error",
        "onStack",
        "originalState",
        "setHeadElement",
        "isElementInQueue",
        "replaceActiveFormattingElement",
        "getPendingTableCharacters",
        "inListItemScope",
        "setFormElement",
        "getDocument",
        "getHeadElement",
        "isSpecial",
        "pop",
        "insertOnStackAfter",
        "getActiveFormattingElement",
        "isInActiveFormattingElements"
      ],
      "functions_name_co_evolved_all_files": [
        "setPendingTableCharacters",
        "getStack",
        "markInsertionMode",
        "clearFormattingElementsToLastMarker",
        "TreeBuilder",
        "inSpecificScope",
        "push",
        "toString",
        "isSameFormattingElement",
        "aboveOnStack",
        "maybeSetBaseUri",
        "inSelectScope",
        "transition",
        "framesetOk",
        "newPendingTableCharacters",
        "isFragmentParsing",
        "inTableScope",
        "setFosterInserts",
        "exitTableBody",
        "popStackToBefore",
        "insert",
        "removeFromActiveFormattingElements",
        "parseFragment",
        "generateImpliedEndTags",
        "getFormElement",
        "clearStackToTableRowContext",
        "removeFromStack",
        "resetInsertionMode",
        "state",
        "getBaseUri",
        "testSimpleXmlParse",
        "insertInFosterParent",
        "getFromStack",
        "process",
        "parse",
        "closeCell",
        "insertMarkerToFormattingElements",
        "inScope",
        "initialiseParse",
        "pushActiveFormattingElements",
        "clearStackToTableContext",
        "ParseError",
        "insertEmpty",
        "clearStackToTableBodyContext",
        "insertNode",
        "HtmlTreeBuilder",
        "replaceInQueue",
        "clearStackToContext",
        "isFosterInserts",
        "reconstructFormattingElements",
        "inButtonScope",
        "replaceOnStack",
        "popStackToClose",
        "error",
        "runParser",
        "onStack",
        "originalState",
        "setHeadElement",
        "isElementInQueue",
        "replaceActiveFormattingElement",
        "getPendingTableCharacters",
        "inListItemScope",
        "handleRawtext",
        "setFormElement",
        "getDocument",
        "getHeadElement",
        "isSpecial",
        "handleRcData",
        "anyOtherEndTag",
        "pop",
        "insertOnStackAfter",
        "anythingElse",
        "getActiveFormattingElement",
        "isInActiveFormattingElements"
      ]
    },
    "file": {
      "file_name": "HtmlTreeBuilder.java",
      "file_nloc": 545,
      "file_complexity": 166,
      "file_token_count": 3637,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,671 @@\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.DescendableLinkedList;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.*;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * HTML Tree Builder; creates a DOM from Tokens.\n+ */\n+class HtmlTreeBuilder extends TreeBuilder {\n+\n+    private HtmlTreeBuilderState state; // the current state\n+    private HtmlTreeBuilderState originalState; // original / marked state\n+\n+    private boolean baseUriSetFromDoc = false;\n+    private Element headElement; // the current head element\n+    private Element formElement; // the current form element\n+    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n+    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n+    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n+\n+    private boolean framesetOk = true; // if ok to go into frameset\n+    private boolean fosterInserts = false; // if next inserts should be fostered\n+    private boolean fragmentParsing = false; // if parsing a fragment of html\n+\n+    HtmlTreeBuilder() {}\n+\n+    @Override\n+    Document parse(String input, String baseUri) {\n+        state = HtmlTreeBuilderState.Initial;\n+        return super.parse(input, baseUri);\n+    }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri) {\n+        // context may be null\n+        initialiseParse(inputFragment, baseUri);\n+        contextElement = context;\n+        fragmentParsing = true;\n+        Element root = null;\n+\n+        if (context != null) {\n+            if (context.ownerDocument() != null) // quirks setup:\n+                doc.quirksMode(context.ownerDocument().quirksMode());\n+\n+            // initialise the tokeniser state:\n+            String contextTag = context.tagName();\n+            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n+                tokeniser.transition(TokeniserState.Rcdata);\n+            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n+                tokeniser.transition(TokeniserState.Rawtext);\n+            else if (contextTag.equals(\"script\"))\n+                tokeniser.transition(TokeniserState.ScriptData);\n+            else if (contextTag.equals((\"noscript\")))\n+                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n+            else if (contextTag.equals(\"plaintext\"))\n+                tokeniser.transition(TokeniserState.Data);\n+            else\n+                tokeniser.transition(TokeniserState.Data); // default\n+\n+            root = new Element(Tag.valueOf(\"html\"), baseUri);\n+            doc.appendChild(root);\n+            stack.push(root);\n+            resetInsertionMode();\n+            // todo: setup form element to nearest form on context (up ancestor chain)\n+        }\n+\n+        runParser();\n+        if (context != null)\n+            return root.childNodes();\n+        else\n+            return doc.childNodes();\n+    }\n+\n+    @Override\n+    boolean process(Token token) {\n+        currentToken = token;\n+        return this.state.process(token, this);\n+    }\n+\n+    boolean process(Token token, HtmlTreeBuilderState state) {\n+        currentToken = token;\n+        return state.process(token, this);\n+    }\n+\n+    void transition(HtmlTreeBuilderState state) {\n+        this.state = state;\n+    }\n+\n+    HtmlTreeBuilderState state() {\n+        return state;\n+    }\n+\n+    void markInsertionMode() {\n+        originalState = state;\n+    }\n+\n+    HtmlTreeBuilderState originalState() {\n+        return originalState;\n+    }\n+\n+    void framesetOk(boolean framesetOk) {\n+        this.framesetOk = framesetOk;\n+    }\n+\n+    boolean framesetOk() {\n+        return framesetOk;\n+    }\n+\n+    Document getDocument() {\n+        return doc;\n+    }\n+\n+    String getBaseUri() {\n+        return baseUri;\n+    }\n+\n+    void maybeSetBaseUri(Element base) {\n+        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n+            return;\n+\n+        String href = base.absUrl(\"href\");\n+        if (href.length() != 0) { // ignore <base target> etc\n+            baseUri = href;\n+            baseUriSetFromDoc = true;\n+            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n+        }\n+    }\n+\n+    boolean isFragmentParsing() {\n+        return fragmentParsing;\n+    }\n+\n+    void error(HtmlTreeBuilderState state) {\n+        if (trackErrors)\n+            errors.add(new ParseError(\"Unexpected token\", state, currentToken, reader.pos()));\n+    }\n+\n+    Element insert(Token.StartTag startTag) {\n+        // handle empty unknown tags\n+        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\n+        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\n+            Element el = insertEmpty(startTag);\n+            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\n+            return el;\n+        }\n+        \n+        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n+        insert(el);\n+        return el;\n+    }\n+\n+    Element insert(String startTagName) {\n+        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n+        insert(el);\n+        return el;\n+    }\n+\n+    void insert(Element el) {\n+        insertNode(el);\n+        stack.add(el);\n+    }\n+\n+    Element insertEmpty(Token.StartTag startTag) {\n+        Tag tag = Tag.valueOf(startTag.name());\n+        Element el = new Element(tag, baseUri, startTag.attributes);\n+        insertNode(el);\n+        if (startTag.isSelfClosing()) {\n+            tokeniser.acknowledgeSelfClosingFlag();\n+            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output\n+                tag.setSelfClosing();\n+        }\n+        return el;\n+    }\n+\n+    void insert(Token.Comment commentToken) {\n+        Comment comment = new Comment(commentToken.getData(), baseUri);\n+        insertNode(comment);\n+    }\n+\n+    void insert(Token.Character characterToken) {\n+        Node node;\n+        // characters in script and style go in as datanodes, not text nodes\n+        if (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\n+            node = new DataNode(characterToken.getData(), baseUri);\n+        else\n+            node = new TextNode(characterToken.getData(), baseUri);\n+        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n+    }\n+\n+    private void insertNode(Node node) {\n+        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n+        if (stack.size() == 0)\n+            doc.appendChild(node);\n+        else if (isFosterInserts())\n+            insertInFosterParent(node);\n+        else\n+            currentElement().appendChild(node);\n+    }\n+\n+    Element pop() {\n+        // todo - dev, remove validation check\n+        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n+            Validate.isFalse(true, \"pop td not in cell\");\n+        if (stack.peekLast().nodeName().equals(\"html\"))\n+            Validate.isFalse(true, \"popping html!\");\n+        return stack.pollLast();\n+    }\n+\n+    void push(Element element) {\n+        stack.add(element);\n+    }\n+\n+    DescendableLinkedList<Element> getStack() {\n+        return stack;\n+    }\n+\n+    boolean onStack(Element el) {\n+        return isElementInQueue(stack, el);\n+    }\n+\n+    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n+        Iterator<Element> it = queue.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == element) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    Element getFromStack(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                return next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    boolean removeFromStack(Element el) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                it.remove();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void popStackToClose(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void popStackToClose(String... elNames) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (StringUtil.in(next.nodeName(), elNames)) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void popStackToBefore(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void clearStackToTableContext() {\n+        clearStackToContext(\"table\");\n+    }\n+\n+    void clearStackToTableBodyContext() {\n+        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n+    }\n+\n+    void clearStackToTableRowContext() {\n+        clearStackToContext(\"tr\");\n+    }\n+\n+    private void clearStackToContext(String... nodeNames) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n+                break;\n+            else\n+                it.remove();\n+        }\n+    }\n+\n+    Element aboveOnStack(Element el) {\n+        assert onStack(el);\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                return it.next();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    void insertOnStackAfter(Element after, Element in) {\n+        int i = stack.lastIndexOf(after);\n+        Validate.isTrue(i != -1);\n+        stack.add(i+1, in);\n+    }\n+\n+    void replaceOnStack(Element out, Element in) {\n+        replaceInQueue(stack, out, in);\n+    }\n+\n+    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n+        int i = queue.lastIndexOf(out);\n+        Validate.isTrue(i != -1);\n+        queue.remove(i);\n+        queue.add(i, in);\n+    }\n+\n+    void resetInsertionMode() {\n+        boolean last = false;\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element node = it.next();\n+            if (!it.hasNext()) {\n+                last = true;\n+                node = contextElement;\n+            }\n+            String name = node.nodeName();\n+            if (\"select\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InSelect);\n+                break; // frag\n+            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+                transition(HtmlTreeBuilderState.InCell);\n+                break;\n+            } else if (\"tr\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InRow);\n+                break;\n+            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InTableBody);\n+                break;\n+            } else if (\"caption\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InCaption);\n+                break;\n+            } else if (\"colgroup\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InColumnGroup);\n+                break; // frag\n+            } else if (\"table\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InTable);\n+                break;\n+            } else if (\"head\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InBody);\n+                break; // frag\n+            } else if (\"body\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InBody);\n+                break;\n+            } else if (\"frameset\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InFrameset);\n+                break; // frag\n+            } else if (\"html\".equals(name)) {\n+                transition(HtmlTreeBuilderState.BeforeHead);\n+                break; // frag\n+            } else if (last) {\n+                transition(HtmlTreeBuilderState.InBody);\n+                break; // frag\n+            }\n+        }\n+    }\n+\n+    // todo: tidy up in specific scope methods\n+    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n+        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n+    }\n+\n+    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element el = it.next();\n+            String elName = el.nodeName();\n+            if (StringUtil.in(elName, targetNames))\n+                return true;\n+            if (StringUtil.in(elName, baseTypes))\n+                return false;\n+            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n+                return false;\n+        }\n+        Validate.fail(\"Should not be reachable\");\n+        return false;\n+    }\n+\n+    boolean inScope(String[] targetNames) {\n+        return inSpecificScope(targetNames, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, null);\n+    }\n+\n+    boolean inScope(String targetName) {\n+        return inScope(targetName, null);\n+    }\n+\n+    boolean inScope(String targetName, String[] extras) {\n+        return inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n+        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n+        // todo: in svg namespace: forignOjbect, desc, title\n+    }\n+\n+    boolean inListItemScope(String targetName) {\n+        return inScope(targetName, new String[]{\"ol\", \"ul\"});\n+    }\n+\n+    boolean inButtonScope(String targetName) {\n+        return inScope(targetName, new String[]{\"button\"});\n+    }\n+\n+    boolean inTableScope(String targetName) {\n+        return inSpecificScope(targetName, new String[]{\"html\", \"table\"}, null);\n+    }\n+\n+    boolean inSelectScope(String targetName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element el = it.next();\n+            String elName = el.nodeName();\n+            if (elName.equals(targetName))\n+                return true;\n+            if (!StringUtil.in(elName, \"optgroup\", \"option\")) // all elements except\n+                return false;\n+        }\n+        Validate.fail(\"Should not be reachable\");\n+        return false;\n+    }\n+\n+    void setHeadElement(Element headElement) {\n+        this.headElement = headElement;\n+    }\n+\n+    Element getHeadElement() {\n+        return headElement;\n+    }\n+\n+    boolean isFosterInserts() {\n+        return fosterInserts;\n+    }\n+\n+    void setFosterInserts(boolean fosterInserts) {\n+        this.fosterInserts = fosterInserts;\n+    }\n+\n+    Element getFormElement() {\n+        return formElement;\n+    }\n+\n+    void setFormElement(Element formElement) {\n+        this.formElement = formElement;\n+    }\n+\n+    void newPendingTableCharacters() {\n+        pendingTableCharacters = new ArrayList<Token.Character>();\n+    }\n+\n+    List<Token.Character> getPendingTableCharacters() {\n+        return pendingTableCharacters;\n+    }\n+\n+    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n+        this.pendingTableCharacters = pendingTableCharacters;\n+    }\n+\n+    /**\n+     11.2.5.2 Closing elements that have implied end tags<p/>\n+     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n+     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n+     the UA must pop the current node off the stack of open elements.\n+\n+     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n+     process, then the UA must perform the above steps as if that element was not in the above list.\n+     */\n+    void generateImpliedEndTags(String excludeTag) {\n+        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n+                StringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\n+            pop();\n+    }\n+\n+    void generateImpliedEndTags() {\n+        generateImpliedEndTags(null);\n+    }\n+\n+    boolean isSpecial(Element el) {\n+        // todo: mathml's mi, mo, mn\n+        // todo: svg's foreigObject, desc, title\n+        String name = el.nodeName();\n+        return StringUtil.in(name, \"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n+                \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n+                \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n+                \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n+                \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n+                \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n+                \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n+                \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\");\n+    }\n+\n+    // active formatting elements\n+    void pushActiveFormattingElements(Element in) {\n+        int numSeen = 0;\n+        Iterator<Element> iter = formattingElements.descendingIterator();\n+        while (iter.hasNext()) {\n+            Element el =  iter.next();\n+            if (el == null) // marker\n+                break;\n+\n+            if (isSameFormattingElement(in, el))\n+                numSeen++;\n+\n+            if (numSeen == 3) {\n+                iter.remove();\n+                break;\n+            }\n+        }\n+        formattingElements.add(in);\n+    }\n+\n+    private boolean isSameFormattingElement(Element a, Element b) {\n+        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n+        return a.nodeName().equals(b.nodeName()) &&\n+                // a.namespace().equals(b.namespace()) &&\n+                a.attributes().equals(b.attributes());\n+        // todo: namespaces\n+    }\n+\n+    void reconstructFormattingElements() {\n+        int size = formattingElements.size();\n+        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n+            return;\n+\n+        Element entry = formattingElements.getLast();\n+        int pos = size - 1;\n+        boolean skip = false;\n+        while (true) {\n+            if (pos == 0) { // step 4. if none before, skip to 8\n+                skip = true;\n+                break;\n+            }\n+            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n+            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n+                break; // jump to 8, else continue back to 4\n+        }\n+        while(true) {\n+            if (!skip) // step 7: on later than entry\n+                entry = formattingElements.get(++pos);\n+            Validate.notNull(entry); // should not occur, as we break at last element\n+\n+            // 8. create new element from element, 9 insert into current node, onto stack\n+            skip = false; // can only skip increment from 4.\n+            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n+            // newEl.namespace(entry.namespace()); // todo: namespaces\n+            newEl.attributes().addAll(entry.attributes());\n+\n+            // 10. replace entry with new entry\n+            formattingElements.add(pos, newEl);\n+            formattingElements.remove(pos + 1);\n+\n+            // 11\n+            if (pos == size-1) // if not last entry in list, jump to 7\n+                break;\n+        }\n+    }\n+\n+    void clearFormattingElementsToLastMarker() {\n+        while (!formattingElements.isEmpty()) {\n+            Element el = formattingElements.peekLast();\n+            formattingElements.removeLast();\n+            if (el == null)\n+                break;\n+        }\n+    }\n+\n+    void removeFromActiveFormattingElements(Element el) {\n+        Iterator<Element> it = formattingElements.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                it.remove();\n+                break;\n+            }\n+        }\n+    }\n+\n+    boolean isInActiveFormattingElements(Element el) {\n+        return isElementInQueue(formattingElements, el);\n+    }\n+\n+    Element getActiveFormattingElement(String nodeName) {\n+        Iterator<Element> it = formattingElements.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == null) // scope marker\n+                break;\n+            else if (next.nodeName().equals(nodeName))\n+                return next;\n+        }\n+        return null;\n+    }\n+\n+    void replaceActiveFormattingElement(Element out, Element in) {\n+        replaceInQueue(formattingElements, out, in);\n+    }\n+\n+    void insertMarkerToFormattingElements() {\n+        formattingElements.add(null);\n+    }\n+\n+    void insertInFosterParent(Node in) {\n+        Element fosterParent = null;\n+        Element lastTable = getFromStack(\"table\");\n+        boolean isLastTableParent = false;\n+        if (lastTable != null) {\n+            if (lastTable.parent() != null) {\n+                fosterParent = lastTable.parent();\n+                isLastTableParent = true;\n+            } else\n+                fosterParent = aboveOnStack(lastTable);\n+        } else { // no table == frag\n+            fosterParent = stack.get(0);\n+        }\n+\n+        if (isLastTableParent) {\n+            Validate.notNull(lastTable); // last table cannot be null by this point.\n+            lastTable.before(in);\n+        }\n+        else\n+            fosterParent.appendChild(in);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TreeBuilder{\" +\n+                \"currentToken=\" + currentToken +\n+                \", state=\" + state +\n+                \", currentElement=\" + currentElement() +\n+                '}';\n+    }\n+}\n",
      "files_name_in_blame_commit": [
        "XmlTreeBuilderTest.java",
        "HtmlParserTest.java",
        "HtmlTreeBuilderState.java",
        "HtmlTreeBuilder.java",
        "ParseError.java",
        "XmlTreeBuilder.java",
        "Parser.java",
        "TreeBuilder.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 26
  }
}
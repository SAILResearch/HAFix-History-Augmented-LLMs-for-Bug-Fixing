{
  "id": "117",
  "blame_commit": {
    "commit": {
      "commit_id": "843d7b8f07f4899ad153ffabc25e09a6c0e897c7",
      "commit_message": "Parse month-day in year 2000 instead of 1970 to parse Feb 29\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1591 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1",
      "commit_author": "Stephen Colebourne",
      "commit_date": "2010-11-18 19:26:06",
      "commit_parent": "e12257524e216a6673ba1e337f8d97e955af7800"
    },
    "function": {
      "function_name": "parseInto",
      "function_code_before": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket\n        (instantLocal, chrono, iLocale, iPivotYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getZone() == null) {\n        int parsedOffset = bucket.getOffset();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "function_code_after": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getZone() == null) {\n        int parsedOffset = bucket.getOffset();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "function_before_start_line": 654,
      "function_before_end_line": 676,
      "function_after_start_line": 692,
      "function_after_end_line": 714,
      "function_before_token_count": 171,
      "function_after_token_count": 173,
      "functions_name_modified_file": [
        "getChronology",
        "isOffsetParsed",
        "isParser",
        "getLocale",
        "getParser",
        "getZone",
        "parseMutableDateTime",
        "getChronolgy",
        "withDefaultYear",
        "parseLocalDate",
        "withOffsetParsed",
        "withLocale",
        "withChronology",
        "withZoneUTC",
        "requirePrinter",
        "parseLocalTime",
        "parseLocalDateTime",
        "getPrinter",
        "withZone",
        "getDefaultYear",
        "requireParser",
        "isPrinter",
        "DateTimeFormatter",
        "parseMillis",
        "print",
        "selectChronology",
        "getPivotYear",
        "printTo",
        "withPivotYear",
        "parseInto",
        "parseDateTime"
      ],
      "functions_name_all_files": [
        "getChronology",
        "isOffsetParsed",
        "testParseMutableDateTime_offsetParsed",
        "testFormat_zoneAmountColon",
        "testParseInto_simple",
        "testFormatParse_textMonthAtEnd_France_withSpecifiedDefault",
        "testFormatParse_textMonthJanShort_UK",
        "testPrint_bufferMethods",
        "testFormatParse_zoneId_colon_parseZ",
        "testFormatParse_textEraAD_UK",
        "testPrint_simple",
        "parseMutableDateTime",
        "testFormatParse_textEraBC_France",
        "withDefaultYear",
        "compareTo",
        "computeMillis",
        "parseLocalDate",
        "testParseLocalDateTime_monthDay_feb29",
        "withLocale",
        "testParseDateTime_offsetParsed",
        "testParseMutableDateTime_chrono",
        "testParseDateTime_zone3",
        "parseLocalDateTime",
        "testWithGetChronology",
        "testWithGetOffsetParsedMethods",
        "main",
        "setUp",
        "saveField",
        "testFormatParse_zoneId_colon",
        "withZone",
        "testParseInto_chrono",
        "getDefaultYear",
        "testFormat_dayOfWeekShortText",
        "testFormat_shortBasicParse",
        "requireParser",
        "parseMillis",
        "check",
        "testFormatParse_textYear_UK",
        "testFormat_yearOfEra_twoDigit",
        "print",
        "testParseLocalDate_yearOfEra",
        "testParseDateTime_simple",
        "testFormatParse_textMonthApr_Korean",
        "testParseDateTime_chrono",
        "testParseMutableDateTime_zone3",
        "testParseInto_zone",
        "testFormatParse_textEraAD_France",
        "testFormat_second",
        "testFormat_weekOfWeekyear",
        "printTo",
        "parseInto",
        "testParseLocalDateTime_simple",
        "testWithGetLocale",
        "tearDown",
        "getLocale",
        "getParser",
        "testFormat_monthOfYearText",
        "testPrint_chrono_and_zone",
        "saveState",
        "testFormat_minute",
        "testFormat_zoneAmount",
        "testParseInto_zone2",
        "SavedState",
        "testFormatParse_textMonthJanLongLowerCase_UK",
        "testFormatParse_textHalfdayAM_France",
        "testParseInto_zone3",
        "testWithGetPivotYear",
        "testFormatParse_textAdjoiningHelloWorld_UK",
        "withZoneUTC",
        "testFormatParse_zoneId_noColon",
        "testParseMutableDateTime_simple",
        "setOffset",
        "getPrinter",
        "testPrint_writerMethods",
        "testParseDateTime_zone2",
        "testParseLocalDate_simple",
        "testFormat_monthOfYearShortText",
        "testPrinterParserMethods",
        "testFormat_zoneAmountID",
        "testFormat_zoneLongText",
        "testParseDateTime_simple_precedence",
        "testFormatParse_textHalfdayAM_UK",
        "getPivotYear",
        "compareReverse",
        "DateTimeParserBucket",
        "testParseLocalTime_simple",
        "testFormat_samples",
        "testFormatParse_textMonthJanShortUpperCase_UK",
        "testFormat_dayOfWeekText",
        "testFormat_era",
        "testParseMutableDateTime_zone2",
        "testFormat_yearOfEra",
        "testParseInto_offsetParsed",
        "testPrint_locale",
        "testParseMutableDateTime_zone",
        "testFormatParse_textAdjoiningMonthDOW_UK",
        "sort",
        "testFormat_clockhourOfHalfday",
        "setZone",
        "testFormat_halfdayOfDay",
        "TestDateTimeFormat",
        "withChronology",
        "testFormat_dayOfYearText",
        "testParse_textMonthJanLong_UK",
        "testFormatParse_textMonthJanShort_France",
        "setPivotYear",
        "testFormat_centuryOfEra",
        "restoreState",
        "testFormat_year",
        "testParseLocalDate_monthDay_feb29",
        "testParseLocalDate_yearOfCentury",
        "testParseLocalDateTime_monthDay_withDefaultYear_feb29",
        "DateTimeFormatter",
        "testPrint_appendableMethods",
        "testSubclassableConstructor",
        "testFormat_year_long",
        "testFormatParse_textYear_France",
        "getOffset",
        "testFormat_monthOfYear",
        "testFormat_clockhourOfDay",
        "testFormat_weekyearOfEra_twoDigit",
        "testFormatParse_zoneId_noColon_parseZ",
        "testFormat_hourOfHalfday",
        "testParse_pivotYear",
        "testFormat_dayOfWeek",
        "testParseDateTime_zone",
        "testFormat_dayOfMonth",
        "testFormat_yearOfEraParse",
        "isParser",
        "getZone",
        "testFormatParse_textMonthApr_France",
        "testFormatParse_textMonthAtEnd_France",
        "getChronolgy",
        "testFormat_fractionOfSecondLong",
        "TestDateTimeFormatter",
        "testFormat_year_twoDigit",
        "testFormat_weekyear",
        "withOffsetParsed",
        "testParseInto_simple_precedence",
        "requirePrinter",
        "parseLocalTime",
        "testParse_pivotYear_ignored4DigitYear",
        "testFormatParse_textMonthJanShortLowerCase_UK",
        "testFormat_hourOfDay",
        "isPrinter",
        "testZoneNameNearTransition",
        "set",
        "testFormat_other",
        "suite",
        "testWithGetZone",
        "testFormatParse_textMonthJanLong_France",
        "selectChronology",
        "SavedField",
        "testFormat_invalid",
        "testParseLocalDate_monthDay_withDefaultYear_feb29",
        "testPrint_zone",
        "testFormat_fractionOfSecond",
        "testFormatParse_textMonthJanLongUpperCase_UK",
        "withPivotYear",
        "testParseMillis_fractionOfSecondLong",
        "testZoneShortNameNearTransition",
        "parseDateTime",
        "testPrint_chrono",
        "testParseMutableDateTime_simple_precedence",
        "testFormat_zoneText"
      ],
      "functions_name_co_evolved_modified_file": [
        "withZone",
        "getDefaultYear",
        "withOffsetParsed",
        "withLocale",
        "parseInto",
        "withPivotYear",
        "withChronology",
        "DateTimeFormatter",
        "parseDateTime",
        "parseMillis",
        "parseLocalDateTime",
        "parseMutableDateTime",
        "withDefaultYear"
      ],
      "functions_name_co_evolved_all_files": [
        "testFormatParse_textMonthAtEnd_France_withSpecifiedDefault",
        "testFormatParse_textMonthAtEnd_France",
        "parseMutableDateTime",
        "withDefaultYear",
        "computeMillis",
        "testParseLocalDateTime_monthDay_feb29",
        "withOffsetParsed",
        "withLocale",
        "withChronology",
        "parseLocalDateTime",
        "testParseLocalDate_monthDay_feb29",
        "withZone",
        "getDefaultYear",
        "testParseLocalDate_yearOfCentury",
        "testParseLocalDateTime_monthDay_withDefaultYear_feb29",
        "DateTimeFormatter",
        "parseMillis",
        "testParseLocalDate_yearOfEra",
        "testParseLocalDate_monthDay_withDefaultYear_feb29",
        "compareReverse",
        "DateTimeParserBucket",
        "parseInto",
        "withPivotYear",
        "parseDateTime"
      ]
    },
    "file": {
      "file_name": "DateTimeFormatter.java",
      "file_nloc": 335,
      "file_complexity": 80,
      "file_token_count": 2237,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -90,8 +90,10 @@ public class DateTimeFormatter {\n     private final Chronology iChrono;\n     /** The zone to use as an override. */\n     private final DateTimeZone iZone;\n-    /* The pivot year to use for two-digit year parsing. */\n+    /** The pivot year to use for two-digit year parsing. */\n     private final Integer iPivotYear;\n+    /** The default year for parsing month/day without year. */\n+    private final int iDefaultYear;\n \n     /**\n      * Creates a new formatter, however you will normally use the factory\n@@ -110,6 +112,7 @@ public class DateTimeFormatter {\n         iChrono = null;\n         iZone = null;\n         iPivotYear = null;\n+        iDefaultYear = 2000;\n     }\n \n     /**\n@@ -119,7 +122,7 @@ public class DateTimeFormatter {\n             DateTimePrinter printer, DateTimeParser parser,\n             Locale locale, boolean offsetParsed,\n             Chronology chrono, DateTimeZone zone,\n-            Integer pivotYear) {\n+            Integer pivotYear, int defaultYear) {\n         super();\n         iPrinter = printer;\n         iParser = parser;\n@@ -128,6 +131,7 @@ public class DateTimeFormatter {\n         iChrono = chrono;\n         iZone = zone;\n         iPivotYear = pivotYear;\n+        iDefaultYear = defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n@@ -184,7 +188,7 @@ public class DateTimeFormatter {\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, locale,\n-                iOffsetParsed, iChrono, iZone, iPivotYear);\n+                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -217,7 +221,7 @@ public class DateTimeFormatter {\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                true, iChrono, null, iPivotYear);\n+                true, iChrono, null, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -252,7 +256,7 @@ public class DateTimeFormatter {\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, chrono, iZone, iPivotYear);\n+                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -315,7 +319,7 @@ public class DateTimeFormatter {\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                false, iChrono, zone, iPivotYear);\n+                false, iChrono, zone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -362,7 +366,7 @@ public class DateTimeFormatter {\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, iChrono, iZone, pivotYear);\n+                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n     }\n \n     /**\n@@ -408,6 +412,40 @@ public class DateTimeFormatter {\n       return iPivotYear;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the specified default year.\n+     * <p>\n+     * The default year is used when parsing in the case where there is a\n+     * month or a day but not a year. Specifically, it is used if there is\n+     * a field parsed with a duration between the length of a month and the\n+     * length of a day inclusive.\n+     * <p>\n+     * This value is typically used to move the year from 1970 to a leap year\n+     * to enable February 29th to be parsed.\n+     * Unless customised, the year 2000 is used.\n+     * <p>\n+     * This setting has no effect when printing.\n+     *\n+     * @param defaultYear  the default year to use\n+     * @return the new formatter, not null\n+     * @since 2.0\n+     */\n+    public DateTimeFormatter withDefaultYear(int defaultYear) {\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n+    }\n+\n+    /**\n+     * Gets the default year for parsing months and days.\n+     *\n+     * @return the default year for parsing months and days\n+     * @since 2.0\n+     */\n+    public int getDefaultYear() {\n+      return iDefaultYear;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Prints a ReadableInstant, using the chronology supplied by the instant.\n@@ -662,8 +700,8 @@ public class DateTimeFormatter {\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n-        DateTimeParserBucket bucket = new DateTimeParserBucket\n-            (instantLocal, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(\n+            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getZone() == null) {\n@@ -691,7 +729,7 @@ public class DateTimeFormatter {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(iChrono);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n@@ -757,7 +795,7 @@ public class DateTimeFormatter {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n@@ -796,7 +834,7 @@ public class DateTimeFormatter {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n@@ -835,7 +873,7 @@ public class DateTimeFormatter {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n",
      "files_name_in_blame_commit": [
        "DateTimeParserBucket.java",
        "TestDateTimeFormat.java",
        "DateTimeFormatter.java",
        "TestDateTimeFormatter.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 35
  }
}
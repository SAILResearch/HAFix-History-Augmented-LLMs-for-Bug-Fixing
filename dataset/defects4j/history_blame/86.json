{
  "id": "86",
  "blame_commit": {
    "commit": {
      "commit_id": "2d06a7ce861432fc702168fd4c94bc00ddfc39eb",
      "commit_message": "NumberUtils moved to math subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137379 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Stephen Colebourne",
      "commit_date": "2003-06-24 21:14:51",
      "commit_parent": "9949f090897b042dce8fa86830f40d11ac7701df"
    },
    "function": {
      "function_name": "isNumber",
      "function_code_before": "public static boolean isNumber(String str) {\n    if ((str == null) || (str.length() == 0)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; // str == \"0x\"\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; // don't want to loop to the last char, check it afterwords\n          // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent   \n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; // we need a digit after the E\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            // not allowing L with an exponoent\n            return foundDigit && !hasExp;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}",
      "function_code_after": "public static boolean isNumber(String str) {\n    if ((str == null) || (str.length() == 0)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; // str == \"0x\"\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; // don't want to loop to the last char, check it afterwords\n          // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent   \n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; // we need a digit after the E\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            // not allowing L with an exponoent\n            return foundDigit && !hasExp;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}",
      "function_before_start_line": 680,
      "function_before_end_line": 774,
      "function_after_start_line": 648,
      "function_after_end_line": 742,
      "function_before_token_count": 503,
      "function_after_token_count": 503,
      "functions_name_modified_file": [
        "compare",
        "minimum",
        "isAllZeros",
        "createFloat",
        "createBigDecimal",
        "createNumber",
        "createDouble",
        "isNumber",
        "isDigits",
        "maximum",
        "createBigInteger",
        "createInteger",
        "createLong",
        "NumberUtils",
        "stringToInt"
      ],
      "functions_name_all_files": [
        "trimToEmpty",
        "indexOfAnyBut",
        "toString",
        "reflectionAppend",
        "min",
        "maximum",
        "toBooleanDefaultIfNull",
        "overlapsRange",
        "indexOfAny",
        "testCreateInteger",
        "testMinimumInt",
        "getPrechomp",
        "createFloat",
        "sliceRemainder",
        "isAlphaSpace",
        "reverseDelimitedString",
        "chompLast",
        "capitalise",
        "getLevenshteinDistance",
        "toStringOnOff",
        "main",
        "getChomp",
        "Range",
        "minimum",
        "createBigDecimal",
        "toStringTrueFalse",
        "sliceFirst",
        "includesDouble",
        "chomp",
        "negate",
        "getMaximumDouble",
        "concatenate",
        "differenceAt",
        "testIsDigits",
        "testMaximumLong",
        "getMaximumInteger",
        "capitaliseAllWords",
        "reflectionCompare",
        "uncapitalise",
        "isAlpha",
        "testMinimumByte",
        "padding",
        "testCreateNumber",
        "containsOnly",
        "getMinimumFloat",
        "getMaximumFloat",
        "deleteSpaces",
        "testStringToIntStringI",
        "isNumericSpace",
        "testCreateLong",
        "CompareToBuilder",
        "reverse",
        "toStringYesNo",
        "checkCreateNumber",
        "createInteger",
        "stringToInt",
        "clean",
        "trimToNull",
        "replace",
        "strip",
        "getMinimumInteger",
        "abbreviate",
        "createDouble",
        "upperCase",
        "testStringToIntString",
        "appendSuper",
        "equals",
        "stripAll",
        "includesFloat",
        "lowerCase",
        "isNumber",
        "testMinimumLong",
        "escape",
        "toInteger",
        "defaultString",
        "overlayString",
        "testCreateBigInteger",
        "mid",
        "testIsNumber",
        "replaceOnce",
        "testCreateDouble",
        "isAllZeros",
        "getMaximumLong",
        "containsNone",
        "testMaximumByte",
        "append",
        "right",
        "sliceFirstRemainder",
        "lastIndexOfAny",
        "BooleanUtils",
        "stripStart",
        "getMinimumLong",
        "difference",
        "includesLong",
        "MathTestSuite",
        "toIntegerObject",
        "prechomp",
        "createNumber",
        "center",
        "isDigits",
        "toBooleanObject",
        "testConstants",
        "isAlphanumericSpace",
        "chop",
        "testCreateFloat",
        "substring",
        "repeat",
        "leftPad",
        "toComparison",
        "StringUtils",
        "includesInteger",
        "testMaximumShort",
        "swapCase",
        "compare",
        "equalsIgnoreCase",
        "trim",
        "getMinimumDouble",
        "isAlphanumeric",
        "testCreateBigDecimal",
        "unescape",
        "isWhitespace",
        "hashCode",
        "testMinimumShort",
        "isNumeric",
        "isNotEmpty",
        "testCompareFloat",
        "testMaximumInt",
        "rightPad",
        "deleteWhitespace",
        "testCompareDouble",
        "max",
        "NumberUtilsTest",
        "getNestedString",
        "stripEnd",
        "isEmpty",
        "uncapitaliseAllWords",
        "countMatches",
        "chopNewline",
        "includesRange",
        "left",
        "NumberUtils",
        "suite",
        "split",
        "toBoolean",
        "slice",
        "join",
        "createBigInteger",
        "createLong"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "compare",
        "min",
        "testMinimumByte",
        "testCreateNumber",
        "testCreateBigDecimal",
        "testCreateBigInteger",
        "testMinimumShort",
        "testIsNumber",
        "testCompareFloat",
        "testStringToIntStringI",
        "testMaximumInt",
        "testCreateDouble",
        "testCreateInteger",
        "isAllZeros",
        "testMaximumByte",
        "testCreateLong",
        "testCompareDouble",
        "testMinimumInt",
        "createFloat",
        "checkCreateNumber",
        "max",
        "getLevenshteinDistance",
        "NumberUtilsTest",
        "createInteger",
        "stringToInt",
        "createBigDecimal",
        "createNumber",
        "createDouble",
        "isDigits",
        "testConstants",
        "testMinimumLong",
        "suite",
        "NumberUtils",
        "testCreateFloat",
        "testStringToIntString",
        "testIsDigits",
        "testMaximumLong",
        "testMaximumShort",
        "createBigInteger",
        "isNumber",
        "createLong"
      ]
    },
    "file": {
      "file_name": "NumberUtils.java",
      "file_nloc": 331,
      "file_complexity": 136,
      "file_token_count": 1973,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -55,6 +55,7 @@\n \n import java.math.BigInteger;\n import java.math.BigDecimal;\n+\n /**\n  * <p>Provides extra functionality for Java Number classes.</p>\n  *\n@@ -65,47 +66,14 @@\n  * @author Eric Pugh\n  * @author Phil Steitz\n  * @since 1.0\n- * @version $Id: NumberUtils.java,v 1.10 2003/06/08 14:14:01 scolebourne Exp $\n+ * @version $Id: NumberUtils.java,v 1.11 2003/06/24 21:14:50 scolebourne Exp $\n+ * \n+ * @deprecated Moved to org.apache.commons.lang.math.\n+ *             Class will be removed in Commons Lang 3.0.\n  */\n public final class NumberUtils {\n+    // DEPRECATED CLASS !!!\n     \n-    /** Reusable Long constant for zero. */\n-    public static final Long LONG_ZERO = new Long(0L);\n-    /** Reusable Long constant for one. */\n-    public static final Long LONG_ONE = new Long(1L);\n-    /** Reusable Long constant for minus one. */\n-    public static final Long LONG_MINUS_ONE = new Long(-1L);\n-    /** Reusable Integer constant for zero. */\n-    public static final Integer INTEGER_ZERO = new Integer(0);\n-    /** Reusable Integer constant for one. */\n-    public static final Integer INTEGER_ONE = new Integer(1);\n-    /** Reusable Integer constant for minus one. */\n-    public static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n-    /** Reusable Short constant for zero. */\n-    public static final Short SHORT_ZERO = new Short((short) 0);\n-    /** Reusable Short constant for one. */\n-    public static final Short SHORT_ONE = new Short((short) 1);\n-    /** Reusable Short constant for minus one. */\n-    public static final Short SHORT_MINUS_ONE = new Short((short) -1);\n-    /** Reusable Byte constant for zero. */\n-    public static final Byte BYTE_ZERO = new Byte((byte) 0);\n-    /** Reusable Byte constant for one. */\n-    public static final Byte BYTE_ONE = new Byte((byte) 1);\n-    /** Reusable Byte constant for minus one. */\n-    public static final Byte BYTE_MINUS_ONE = new Byte((byte) -1);\n-    /** Reusable Double constant for zero. */\n-    public static final Double DOUBLE_ZERO = new Double(0.0d);\n-    /** Reusable Double constant for one. */\n-    public static final Double DOUBLE_ONE = new Double(1.0d);\n-    /** Reusable Double constant for minus one. */\n-    public static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n-    /** Reusable Float constant for zero. */\n-    public static final Float FLOAT_ZERO = new Float(0.0f);\n-    /** Reusable Float constant for one. */\n-    public static final Float FLOAT_ONE = new Float(1.0f);\n-    /** Reusable Float constant for minus one. */\n-    public static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n-\n     /**\n      * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n      * Instead, the class should be used as <code>NumberUtils.stringToInt(\"6\");</code>.</p>\n",
      "files_name_in_blame_commit": [
        "NumberUtilsTest.java",
        "Range.java",
        "BooleanUtils.java",
        "NumberUtils.java",
        "CompareToBuilder.java",
        "StringUtils.java",
        "MathTestSuite.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 56
  }
}
{
  "id": "102",
  "blame_commit": {
    "commit": {
      "commit_id": "0ec92a0fc205fb0704d3b9032b88ebb0d4e561a9",
      "commit_message": "added FastMath and used it everywhere in replacement of java.util.Math\nthe unit tests have not been added yet (waiting for dfp library addition)\nJIRA: MATH-375\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990658 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_date": "2010-08-29 22:04:09",
      "commit_parent": "bb38a224ebd20c62d01ca12f2156d1c3c33a8ee2"
    },
    "function": {
      "function_name": "max",
      "function_code_before": "",
      "function_code_after": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 2954,
      "function_after_end_line": 2956,
      "function_before_token_count": 0,
      "function_after_token_count": 38,
      "functions_name_modified_file": [
        "signum",
        "cos",
        "log10",
        "min",
        "atanh",
        "log1p",
        "splitReciprocal",
        "polySine",
        "nextUp",
        "slowCos",
        "splitAdd",
        "slowSin",
        "tanQ",
        "for",
        "slowLog",
        "reducePayneHanek",
        "FastMath",
        "round",
        "tan",
        "cosQ",
        "slowexp",
        "atan2",
        "cosh",
        "random",
        "resplit",
        "polyCosine",
        "ulp",
        "expint",
        "max",
        "nextAfter",
        "sqrt",
        "tanh",
        "cbrt",
        "atan",
        "toRadians",
        "asin",
        "floor",
        "expm1",
        "abs",
        "quadMult",
        "rint",
        "sin",
        "log",
        "sinh",
        "split",
        "pow",
        "asinh",
        "buildSinCosTables",
        "sinQ",
        "toDegrees",
        "acosh",
        "ceil",
        "exp",
        "splitMult",
        "acos"
      ],
      "functions_name_all_files": [
        "exactYDot",
        "setShape",
        "getCenterDistance",
        "testBackward",
        "getDenominatorAsInt",
        "testQOrthogonal",
        "getSubMatrix",
        "testNegativeBoth",
        "DormandPrince853Integrator",
        "AbstractRandomGenerator",
        "getY",
        "getDomain",
        "polyCosine",
        "AbstractContinuousDistribution",
        "mapSignum",
        "sumSquareDev",
        "testDoubleValue",
        "testAbsNaN",
        "testMultiplyNaNInf",
        "getDomainLowerBound",
        "testSetScale",
        "testExactIntegration",
        "buildChebyquadArray",
        "testMulAndCheck",
        "DormandPrince54IntegratorTest",
        "getMaxStep",
        "wasLastSeen",
        "makeInverseCumulativeTestPoints",
        "getLastTime",
        "MultivariateSummaryStatisticsTest",
        "scalb",
        "EigenDecompositionImpl",
        "reinitialize",
        "testSimpleWithDecimalsTrunc",
        "checkVectorDimensions",
        "recomputeZ",
        "AbstractLeastSquaresOptimizer",
        "testMulAndCheckLong",
        "distanceInf",
        "setParRelativeTolerance",
        "sortObservations",
        "getImagEigenvalues",
        "testInterpolateLinear",
        "setMean",
        "LoessInterpolator",
        "nextGamma",
        "getGuessedAmplitude",
        "assertSame",
        "nextSecureLong",
        "testMinpackHelicalValley",
        "getMatrix",
        "testNotAllFiniteReal5",
        "binomialCoefficient",
        "getRow",
        "testLogGammaNegative",
        "setMaximalIterationCount",
        "atan",
        "testExpm1Function",
        "testParseInvalid",
        "EmbeddedRungeKuttaIntegrator",
        "quadMult",
        "testTanhInf",
        "percentageValue",
        "log",
        "testPlane",
        "checkClone",
        "TDistributionImpl",
        "SummaryStatisticsTest",
        "createChebyshevPolynomial",
        "testScalarProduct",
        "EntryImpl",
        "cos",
        "testSetImaginaryFormatNull",
        "testAcos",
        "recodeNaNs",
        "testNextT",
        "getResiduals",
        "getConvergence",
        "getMaxIndex",
        "Skewness",
        "AdaptiveStepsizeIntegrator",
        "testDecreasingSteps",
        "StepNormalizerTest",
        "scaleArray",
        "test0Choose0",
        "testGaussian",
        "testSingularMatrix",
        "testInterpolateSin",
        "testGetArgument",
        "setMaxCostEval",
        "testDimensions",
        "SimpleVectorialPointChecker",
        "testParseNan",
        "mapAcos",
        "shouldContract",
        "createSummaryStatistics",
        "getFrobeniusNorm",
        "walkInOptimizedOrder",
        "testDistinctEigenvalues",
        "testDensity",
        "getInitialTime",
        "removeNaNs",
        "normal",
        "HighamHall54IntegratorTest",
        "testNoAccessBelowDiagonal",
        "testSignum",
        "testArrayIsReference",
        "testMisc",
        "getRan",
        "testDimension1",
        "blockWidth",
        "setMeanInternal",
        "Corrector",
        "getSlopeStdErr",
        "inversetransform",
        "testIntegratorControls",
        "testSetRowVector",
        "load",
        "getPartialRadiusX",
        "checkAngle",
        "testParse",
        "testConfig",
        "testConjugateNaN",
        "testGetSubMatrix",
        "testFirstHermitePolynomials",
        "floatValue",
        "isSymmetric",
        "copy",
        "estimateRegressionParameters",
        "createLowerTriangularRealMatrix",
        "discardExtremeElements",
        "testWholeFormat",
        "testEvaluation",
        "getGenerator",
        "exactY",
        "FirstOrderConverterTest",
        "getMinValue",
        "getSampleSize",
        "preMultiply",
        "isSquare",
        "guessParametersErrors",
        "testCompose",
        "testNextIntExtremeValues",
        "testAEqualQTQt",
        "nextF",
        "setUp",
        "LinearFullRankFunction",
        "addElementRolling",
        "t",
        "testShuffledStatistics",
        "nextHexString",
        "testSinhInf",
        "getConditionNumber",
        "setConvergence",
        "testSerialization",
        "converged",
        "GillIntegratorTest",
        "testAxisAngle",
        "NormalDistributionTest",
        "testDigammaSmallArgs",
        "getGeneratorUpperBounds",
        "Osborne1Function",
        "isPowerOf2",
        "testTanhCritical",
        "testFormatObject",
        "testCovarianceConsistency",
        "PolynomialFunction",
        "NormalDistributionImpl",
        "QuadraticProblem",
        "nextLong",
        "mapDivide",
        "normalizeAngle",
        "testRegularizedGammaNanPositive",
        "estimateRegressionStandardError",
        "fix1stArgument",
        "makeDensityTestValues",
        "testDimension3",
        "testQuinticMin",
        "testNormalizeAngle",
        "expand",
        "checkAEqualQTQt",
        "setExpansionMode",
        "testMath280",
        "pairedT",
        "testTrivial",
        "nextPermutation",
        "testRoundFloat",
        "SecantSolver",
        "getEventHandler",
        "setInitialStepBoundFactor",
        "testPolar2ComplexNaN",
        "MultiStartUnivariateRealOptimizer",
        "testRosenbrock",
        "getSkewness",
        "toRadians",
        "testSolveNoRoot",
        "expm1",
        "testLargeValues",
        "testFirstLegendrePolynomials",
        "getLowerDomain",
        "testConstructor",
        "checkMatricesValues",
        "checkVector",
        "addPoint",
        "testLog",
        "testGetSetColumnMatrixLarge",
        "nextUniform",
        "testFormatNegative",
        "intValue",
        "testNextPermutation",
        "reciprocal",
        "testEmptyData",
        "getArgument",
        "testSetRow",
        "mapCeil",
        "testLogGamma",
        "setQuantile",
        "factorial",
        "getOmegaImaginary",
        "applyInverseTo",
        "getV",
        "testErf1960",
        "heresFoo",
        "testIndicatorByte",
        "KeplerStepHandler",
        "toBlocksLayout",
        "setSampleSizeInternal",
        "testNthRoot_normal_thirdRoot",
        "LegendreGaussIntegratorTest",
        "digamma",
        "setAlpha",
        "testConstructorDouble",
        "checkArrays",
        "testStdErrorConsistency",
        "setSumLogImpl",
        "testBracketSin",
        "testLogInf",
        "addElement",
        "testInverseCumulativeProbabilityExtremes",
        "getStartPoint",
        "testMatricesValues",
        "testResetFunctionValueAccuracy",
        "isIncludedValue",
        "readExternal",
        "getM",
        "checkTheoreticalMinParams",
        "split",
        "checkOrder",
        "getExpansionMode",
        "nextInversionDeviate",
        "testPow",
        "mapTanh",
        "testSetBeta",
        "createLegendrePolynomial",
        "getEventHandlers",
        "getPartialDiY",
        "setMaxEvaluations",
        "testSqrtInf",
        "getArray",
        "newYSampleData",
        "testInternalDifferentiation",
        "revert",
        "getRMS",
        "getInterpolatedState",
        "testUpperOrLower",
        "incrementAll",
        "setWindowSize",
        "FastCosineTransformer",
        "getPartialRadiusY",
        "UnitSphereRandomVectorGenerator",
        "testQuintic",
        "of",
        "testDegenerateInverseCumulativeProbability",
        "testFinalResult",
        "setMinReduction",
        "testErf0",
        "testInitialGuess",
        "testErrorConditions",
        "findEigenVectors",
        "testSimpleCombination",
        "postCompose",
        "getEigenvector",
        "Vector3DTest",
        "sparseIterator",
        "testNegativeReal",
        "checkDensity",
        "testParseProper",
        "log1p",
        "SimpleRegression",
        "splitReciprocal",
        "getR",
        "getRowDimension",
        "OpenMapSparseIterator",
        "setSecureAlgorithm",
        "testFormat",
        "resetAbsoluteAccuracy",
        "getSortedValues",
        "testNaNContracts",
        "testParseDifferentImaginaryChar",
        "testSetStandardDeviation",
        "getTransformer",
        "getL1Norm",
        "polar2Complex",
        "checkTheoreticalMinCost",
        "setPreconditioner",
        "testMath209",
        "JennrichSampsonFunction",
        "testMinpackOsborne1",
        "setStepsizeControl",
        "setKurtosisImpl",
        "testSubAndCheckLongFailure",
        "abs",
        "testNorm1",
        "testMeanAccessors",
        "computeCapacity",
        "BlockRealMatrix",
        "Vector3D",
        "testQTOrthogonal",
        "getMaxGrowth",
        "testDifferenceStats",
        "testExpm1Function2",
        "MinpackFunction",
        "testFormatNumber",
        "testSmallLastStep",
        "testMath372",
        "mapExpToSelf",
        "getSummary",
        "testForgottenImaginaryCharacter",
        "setNumberOfTrialsInternal",
        "WeibullDistributionTest",
        "updateCounts",
        "testAtan2",
        "tan",
        "testN0andN1Conditions",
        "slowexp",
        "partial",
        "testConstructorSingleFormat",
        "testSinNaN",
        "checkNonNegative",
        "testGetColumnMatrix",
        "EstimatedParameterTest",
        "interpolationAtBounds",
        "combine",
        "makeInverseCumulativeTestValues",
        "testMoreEstimatedParametersSimple",
        "decompose",
        "pairedTTest",
        "testL2DistanceDouble",
        "testDivideInfinite",
        "testProductAndGeometricMean",
        "getUpperBounds",
        "testMaxEvaluations",
        "OpenIntToDoubleHashMap",
        "test",
        "verifyIterationCount",
        "testZeroImaginary",
        "testNextAfter",
        "getMaxCheckInterval",
        "testParaboloid2D",
        "findBin",
        "HypergeometricDistributionImpl",
        "filterStep",
        "Powell",
        "LinearMeasurement",
        "GraggBulirschStoerIntegratorTest",
        "getSlopeConfidenceInterval",
        "testSetImaginaryCharacterEmpty",
        "getOptima",
        "getNumerator",
        "getInterpolatingPoints",
        "testLaguerreDifferentials",
        "testNotAllFiniteReal3",
        "testMinpackKowalikOsborne",
        "computeDerivatives",
        "size",
        "testLeastSquares1",
        "mapMultiply",
        "testApplyInverseTo",
        "testNextPascal",
        "getSecondMoment",
        "DormandPrince853IntegratorTest",
        "getOrder",
        "testGetMean",
        "getBeta",
        "RandomDataImpl",
        "testTrigamma",
        "getNormSq",
        "Gamma",
        "testMatricesValues3",
        "getD",
        "getMaximalValueError",
        "getExpansionFactor",
        "testRootEndpoints",
        "testMath296withoutWeights",
        "mapRintToSelf",
        "testNextAfterSpecialCases",
        "testLcmLong",
        "testEqualsNull",
        "testParseInvalidDenominator",
        "testDigammaLargeArgs",
        "mapTanToSelf",
        "UniformRandomGenerator",
        "setInverseCumulativeTestValues",
        "getPivot",
        "backward",
        "testNextSecureHex",
        "replaceMostRecentValue",
        "midpoint",
        "checkTriDiagonal",
        "checkNullPolynomial",
        "fit",
        "createOrthogonalMatrix",
        "getX",
        "createLaguerrePolynomial",
        "mapAsinToSelf",
        "setElement",
        "getLocale",
        "testFixedState",
        "testVectorialProducts",
        "randomPopulation",
        "walkInColumnOrder",
        "getMainDiagonalRef",
        "findPerm",
        "testDenominatorFormat",
        "resplit",
        "testArrayHash",
        "checkProbability",
        "testSqrtRealPositive",
        "testStepHandlerResult",
        "mapInvToSelf",
        "getTrace",
        "testIgnored",
        "testAsinInf",
        "getAxis",
        "testExpNaN",
        "getColumnDimension",
        "setAbsoluteAccuracy",
        "containsNaNs",
        "testRevert",
        "testSubAndCheck",
        "StorelessUnivariateStatisticAbstractTest",
        "testErf3291",
        "checkValue",
        "checkOrthogonal",
        "testDiagonal",
        "mapSqrt",
        "isNaN",
        "createTestMatrix",
        "equalsIncludingNaN",
        "getLastError",
        "testMathpbx03",
        "testMath340",
        "testSetColumnVector",
        "LUDecompositionImpl",
        "testNaN",
        "setBiasCorrected",
        "testExtremeValues",
        "getTheoreticalValue",
        "copySubMatrix",
        "stop",
        "testDeprecated2",
        "ceil",
        "subAndCheck",
        "calculateErrorVariance",
        "unitize",
        "nthRoot",
        "getTolerance",
        "testMax",
        "testScalarMultiplyNaN",
        "getSumSq",
        "getH",
        "nextSecureInt",
        "testNorm",
        "testMultiplication",
        "round",
        "testMeanAndCovariance",
        "setNumeratorDegreesOfFreedom",
        "getMeanSquareError",
        "testWave",
        "testEventsNoConvergence",
        "testCumulativeProbability2",
        "testSumSq",
        "testGetArgumentInf",
        "getGeometricMean",
        "OpenIntToFieldHashMap",
        "testNotAllFiniteReal4",
        "mapSinhToSelf",
        "testModelsMerging",
        "Box3DimensionalFunction",
        "ebeDivide",
        "getQuantile",
        "testNextExponential",
        "getDimension",
        "testDimension4WithSplit",
        "getMinStep",
        "locatePoint",
        "reducePayneHanek",
        "testIndicatorDouble",
        "GammaTest",
        "testNonStrictlyIncreasing2",
        "QRDecompositionImpl",
        "testSqrtImaginaryNegative",
        "MultistepIntegrator",
        "getMeanImpl",
        "mapLog1p",
        "testMomentSmallSamples",
        "testNormInf",
        "testSetSubMatrix",
        "testPowInf",
        "setParameter",
        "testExamples",
        "SparseRealVectorTestImpl",
        "testNextSecureInt",
        "checkArray",
        "copyBlockPart",
        "getShape",
        "testErf2576",
        "testMultiply",
        "getWindowSize",
        "mapUlpToSelf",
        "setCumulativeTestPoints",
        "testEqualsAndHashCode",
        "testLInfDistanceInt",
        "checkIntegerOverflow",
        "setNumberOfElements",
        "addSub",
        "testNoError",
        "nextBytes",
        "calculateYVariance",
        "findInsertionIndex",
        "getColumnMatrix",
        "testMinpackRosenbrok",
        "getScale",
        "testPlusMinus",
        "discardMostRecentElements",
        "TrapezoidIntegrator",
        "unsupported",
        "transform",
        "testBadEndpoints",
        "getPartialDiX",
        "getSolverAbsoluteAccuracy",
        "Kurtosis",
        "Equations",
        "testCosNaN",
        "testNoReset",
        "testGoldenRatio",
        "testSetMaximalIterationCount",
        "getPosition",
        "substituteMostRecentElement",
        "testIncreasingTolerance",
        "setInitialCapacity",
        "normalizeArray",
        "testRedundantSolvable",
        "mapFloor",
        "isBiasCorrected",
        "getQT",
        "testSignShort",
        "mapCbrt",
        "testSingularities",
        "setDenominatorDegreesOfFreedom",
        "roundUnscaled",
        "setInterpolationControl",
        "testCollector",
        "testMinpackBrownDennis",
        "RiddersSolver",
        "validateCovarianceData",
        "testCosInf",
        "computeBinStats",
        "BardFunction",
        "hashCode",
        "scalarMultiply",
        "testConstructorNaN",
        "Complex",
        "testBinomialCoefficientLarge",
        "testSinFunction",
        "testTTriDiagonal",
        "setInitialStepSize",
        "testSolveAccuracyNull",
        "testCircleFitting",
        "testGetSetColumnVectorLarge",
        "getGeoMeanImpl",
        "testAbsInfinite",
        "testCosh",
        "testGetEntry",
        "EmpiricalDistributionImpl",
        "getRank",
        "LineSearchFunction",
        "testMinpackJennrichSampson",
        "clear",
        "testHighAccuracyExternalDifferentiation",
        "ExponentialDistributionTest",
        "getSlope",
        "mapCosToSelf",
        "getStirlingError",
        "addEndTimeChecker",
        "testDistanceSq",
        "getEvaluations",
        "getNatural",
        "checkIndex",
        "writeExternal",
        "PowellSingularFunction",
        "testInconsistentSizes",
        "testParseZeroReal",
        "clearStepHandlers",
        "getInternalValues",
        "getValue",
        "getNumberOfElements",
        "inverseCumulativeProbability",
        "setDensityTestPoints",
        "testSqrtRealNegative",
        "getAbsoluteAccuracy",
        "testfirstDerivativeComparison",
        "tearDown",
        "testEventsErrors",
        "setProbabilityOfSuccess",
        "nextPoisson",
        "getRegressionSumSquares",
        "testMath303",
        "bigDecimalValue",
        "isDefaultValue",
        "testNthRoot_normal_fourthRoot",
        "setDensityTestValues",
        "exactDyDy0Dot",
        "FreudensteinRothFunction",
        "assertFraction",
        "testNextBeta",
        "StatisticalSummaryValues",
        "LinearRank1Function",
        "ArrayRealVector",
        "applyTo",
        "testSumLog",
        "setStabilityCheck",
        "testOneSet",
        "testGetReducedFraction",
        "getMaxValue",
        "getQ1",
        "resetEvaluations",
        "getTarget",
        "checkdimensions",
        "WeightedMeasurementTest",
        "getSecondaryDiagonalRef",
        "getRootMatrix",
        "getName",
        "testLogGammaPositive",
        "nextInt",
        "testFactorial",
        "testNonInversible",
        "StatUtilsTest",
        "testGetSummary",
        "testMin",
        "createRealMatrix",
        "testAngle",
        "setTolerance",
        "getMaximalIterationCount",
        "testNextHypergeometric",
        "testSubAndCheckErrorMessage",
        "getZ",
        "DescriptiveStatistics",
        "getJacobianEvaluations",
        "testSetColumnMatrix",
        "GaussNewtonEstimator",
        "testSetRelativeAccuracy",
        "setEntry",
        "mapSin",
        "getS",
        "setMinImpl",
        "regularizedBeta",
        "testAddInfinite",
        "testMakotoNishimura",
        "factorialDouble",
        "reinitializeBegin",
        "testCumulativeProbabilityExtremes",
        "testPaseNegativeInfinity",
        "LevenbergMarquardtEstimator",
        "testDivideNaN",
        "testMinEndpoints",
        "testChebyshevBounds",
        "testRandomAccess",
        "setExponent",
        "BrentSolverTest",
        "ZipfDistributionImpl",
        "getCumulativeTestPoints",
        "getGuessedPhase",
        "testAdd",
        "makeCumulativeTestValues",
        "mapFloorToSelf",
        "getRowVector",
        "testParaboloid",
        "testPolar2ComplexIllegalModulus",
        "VariableStepHandler",
        "testFirstChebyshevPolynomials",
        "testIndicatorLong",
        "getSecRan",
        "getMaxImpl",
        "testAddition",
        "testGcd",
        "determineLMDirection",
        "createMultivariateSummaryStatistics",
        "ChebyquadFunction",
        "degree",
        "getSparsity",
        "FastFourierTransformer",
        "end",
        "getDenominatorAsLong",
        "testLinearFunction",
        "WatsonFunction",
        "testPopulation",
        "testTanh",
        "setRow",
        "start",
        "HarmonicCoefficientsGuesser",
        "getInterpolatingValues",
        "getSumImpl",
        "ListUnivariateImpl",
        "negate",
        "buildSinCosTables",
        "contract",
        "testNotAllFiniteReal2",
        "ContinuousOutputModelTest",
        "testAddFail",
        "testCopyConsistency",
        "setCostAccuracy",
        "homoscedasticT",
        "testTrace",
        "findUpperBound",
        "HighamHall54Integrator",
        "testEpsilonLimitConstructor",
        "dimensionCheck",
        "initializeStep",
        "BrentOptimizer",
        "verifySummary",
        "testLogNaN",
        "testSimpleNoDecimals",
        "getSignificance",
        "nextGaussian",
        "setGeometricMeanImpl",
        "testLeastSquares2",
        "tryStep",
        "testParseInteger",
        "divide",
        "setExpansionFactor",
        "rescale",
        "verifyDensities",
        "visit",
        "getDeterminant",
        "setShapeInternal",
        "testRegularizedGammaZeroPositive",
        "getTotalSumSquares",
        "getBinCount",
        "Rosenbrock",
        "testNullIntervalCheck",
        "testSubtraction",
        "testSolveAccuracySin",
        "distance",
        "doComputeDerivatives",
        "testTanNaN",
        "getSumOfLogs",
        "testDouble",
        "setInterpolatedTime",
        "StepNormalizer",
        "eventOccurred",
        "testSeveralBlocks",
        "RotationTest",
        "getSafety",
        "setQRRankingThreshold",
        "orthogonalizeMatrix",
        "projection",
        "createRandomMatrix",
        "getSum",
        "transpose",
        "pow",
        "subtract",
        "multiplyEntry",
        "testOperate",
        "getField",
        "GaussNewtonOptimizerTest",
        "getStarterIntegrator",
        "nextPowerOfTwo",
        "testNextGaussian",
        "mulAndCheck",
        "testComposeInverse",
        "readResolve",
        "slowCos",
        "testVOrthogonal",
        "resolveTie",
        "stepAccepted",
        "addAndCheck",
        "EulerIntegratorTest",
        "testAngularSeparation",
        "CorrelatedRandomVectorGenerator",
        "buildInterpolator",
        "floor",
        "ResizableDoubleArray",
        "reSeed",
        "setColumn",
        "doOptimize",
        "testRoundDouble",
        "g",
        "SingularValueDecompositionImpl",
        "hash",
        "MinpackMeasurement",
        "acos",
        "getPhase",
        "testGetSetColumnLarge",
        "testSerial",
        "nextZipf",
        "testChebyshevDifferentials",
        "testNextUniformExclusiveEndpoints",
        "testEqualsRealDifference",
        "fill",
        "mapAtanToSelf",
        "getMinImpl",
        "lcm",
        "testAlpha",
        "checkBinomial",
        "testCentroid",
        "cbrt",
        "testRegularizedGammaPositivePositive",
        "testSetterInjection",
        "testIndicatorFloat",
        "setMedianInternal",
        "isUpperBiDiagonal",
        "testMinpackMeyer",
        "getInterpolatedStateVariation",
        "inverse",
        "nextNormalizedDouble",
        "StandardDeviationTest",
        "updateBandwidthInterval",
        "setPercentileImpl",
        "PearsonsCorrelation",
        "fitness",
        "getElitismRate",
        "testMinpackChebyquad",
        "mapLog10",
        "LevenbergMarquardtOptimizerTest",
        "polySine",
        "testAEqualUSVt",
        "checkEigenValues",
        "testL1DistanceInt",
        "testParameters",
        "getPopulationSize",
        "testMinMax",
        "testStepSize",
        "getMedian",
        "testDimension2",
        "incrementJacobianEvaluationsCounter",
        "testNextGamma",
        "testConstructors",
        "derivativesConsistency",
        "getContractionCriteria",
        "testMath199",
        "getMaxIterationCount",
        "mapAdd",
        "setPopulationSizeInternal",
        "testMean",
        "resetMaximalIterationCount",
        "nextBinomial",
        "MinPermutations",
        "reseedRandomGenerator",
        "NordsieckInitializer",
        "testSinh",
        "columnToArray",
        "serializeAndRecover",
        "testGetRow",
        "testRedundantUnsolvable",
        "stage",
        "testMap",
        "UnivariateRealSolverUtils",
        "BisectionSolver",
        "testParseSimpleNoDecimals",
        "interpolationInside",
        "testDivideZero",
        "getAllParameters",
        "getKurtosis",
        "TriDiagonalTransformer",
        "testMissedEndEvent",
        "testLinearFunction2D",
        "reSeedSecure",
        "testWalk",
        "SimpleVectorialValueChecker",
        "testRegularizedGamma",
        "testOnStraightLine",
        "checkDerivativesConsistency",
        "setDegreesOfFreedomInternal",
        "testPowell",
        "getAngle",
        "testSanityChecks",
        "LevenbergMarquardtEstimatorTest",
        "getSkewnessImpl",
        "getInterpolatedTime",
        "evaluateStep",
        "testBeforeEnd",
        "KeplerHandler",
        "df",
        "testComposition",
        "testMinpackOsborne2",
        "expectedValue",
        "RealVectorTestImpl",
        "testSetFunctionValueAccuracy",
        "setElitismRate",
        "slowLog",
        "TestProblem3",
        "getRealEigenvalue",
        "getExponent",
        "testParseZeroImaginary",
        "getIndex",
        "testCopyFunctions",
        "setCostRelativeTolerance",
        "testOnTwoPoints",
        "testMinpackLinearRank1ZeroColsAndRows",
        "getOmegaReal",
        "testDimension",
        "max",
        "map",
        "getLT",
        "Stop",
        "Solver",
        "OpenMapEntry",
        "getEventsHandlers",
        "testZeroDivide",
        "setValue",
        "testAtanNaN",
        "ThreeEighthesIntegratorTest",
        "assertChiSquareAccept",
        "nextPascal",
        "operate",
        "getMaximumPosition",
        "getQ3",
        "checkAllFiniteReal",
        "exactDyDp",
        "mapCoshToSelf",
        "signum",
        "testFloat",
        "ArrayDataAdapter",
        "estimateResiduals",
        "LinearRank1ZeroColsAndRowsFunction",
        "Gaussian2D",
        "testNextIntN",
        "RootsOfUnity",
        "testQuaternion",
        "testTan",
        "nextChiSquare",
        "random",
        "getVarianceImpl",
        "setMaxImpl",
        "testRootMatrix",
        "PointModel",
        "testMinpackLinearRank1",
        "verifyCumulativeProbabilities",
        "longValue",
        "getReal",
        "checklone",
        "estimateErrorVariance",
        "testArrayEqualsIncludingNaN",
        "apply",
        "testNormalize",
        "splitLU",
        "testConstant",
        "getN",
        "testMoreEstimatedParametersUnsorted",
        "getSumOfCrossProducts",
        "nextBeta",
        "testTridiagonal",
        "addStepHandler",
        "testSignInt",
        "binomialCoefficientDouble",
        "getDensityTestPoints",
        "testRegularizedGammaPositiveNan",
        "testNthRoot_cornercase_thirdRoot_realPartZero",
        "mapAbs",
        "HarmonicFitter",
        "getDensityTestValues",
        "trigamma",
        "getIterations",
        "checkPositive",
        "testFix2nd",
        "shuffle",
        "testOnOnePoint",
        "testInterpolateLinearDegenerateThreeSegment",
        "testQuinticFunction2",
        "testIncrementation",
        "testNexBytes",
        "setOrthoTolerance",
        "getIterationCount",
        "get",
        "testDistance",
        "checkedCumulativeProbability",
        "setAlphaInternal",
        "testRegularizedGammaPositiveZero",
        "put",
        "checkEmpty",
        "fct",
        "testMinpackBard",
        "testSignDouble",
        "BadStepInterpolator",
        "getSumsq",
        "getRadius",
        "getCorrelationMatrix",
        "HelicalValleyFunction",
        "inversetransform2",
        "testMathpbx02",
        "testOnDistortedSine",
        "checkGetSubMatrix",
        "InitializationCompletedMarkerException",
        "value",
        "buildPolynomial",
        "binomialCoefficientLog",
        "getNumberOfTrials",
        "testNthRoot_cornercase_NAN_Inf",
        "getLInfDistance",
        "testTanInf",
        "testAbs",
        "ChiSquareTestImpl",
        "verifyQuantiles",
        "tricube",
        "testSolveSin",
        "computeStepGrowShrinkFactor",
        "getUpperDomain",
        "testDoubleDimension",
        "addData",
        "guess",
        "testNan",
        "testExpInf",
        "setInitialStep",
        "checkStrictlyIncreasing",
        "assertEquals",
        "mapAbsToSelf",
        "checkCopy",
        "getStepHandlers",
        "hashOf",
        "sin",
        "getQ0",
        "setLastSeen",
        "updateResidualsAndCost",
        "testProduct",
        "asinh",
        "getCoefficients",
        "toDegrees",
        "testBadParameters",
        "testPremultiply",
        "testCumulativeProbabilities",
        "testNormalApproximateProbability",
        "testSetColumn",
        "clone",
        "verifyInterpolationArray",
        "MyMeasurement",
        "assertClose",
        "mapAcosToSelf",
        "testNoDependency",
        "CountingDifferentialEquations",
        "ulp",
        "nextAfter",
        "testNormalizeArray",
        "getJacobian",
        "computeUpToDegree",
        "testQuinticZero",
        "testMatricesValues5",
        "getL",
        "verifyInterpolation",
        "testMinpackBox3Dimensional",
        "acosh",
        "setRelativeAccuracy",
        "testVariableSteps",
        "testWrongDerivative",
        "nextGeneration",
        "testNotAllFiniteReal1",
        "reset",
        "getNumeratorAsLong",
        "testVectorOnePair",
        "min",
        "AbstractIntegrator",
        "testSignByte",
        "testEventHandler",
        "exactIntegration",
        "testGetArgumentNaN",
        "testQuinticMinStatistics",
        "hasNext",
        "testCombine",
        "EndTimeChecker",
        "verifyInverseCumulativeProbabilities",
        "mapPowToSelf",
        "dYdP1",
        "testExp",
        "IntegerDistributionAbstractTest",
        "testMatrix",
        "setSteadyStateThreshold",
        "Fraction",
        "getUT",
        "polynomialDerivative",
        "testTheory",
        "testToString",
        "regularizedGammaP",
        "testSolveNull",
        "multiply",
        "indicator",
        "testBound",
        "estimateRegressionParametersVariance",
        "toArray",
        "testAddAndCheckLongFailure",
        "probability",
        "testTwoSets",
        "safeNorm",
        "testSubAndCheckLong",
        "MultivariateSummaryStatistics",
        "testSinZero",
        "getNumberOfSuccesses",
        "testMath221",
        "estimate",
        "checkAEqualUSVt",
        "getMean",
        "getImaginary",
        "testEqualsIncludingNaNWithAllowedDelta",
        "derivative",
        "testEigenvalues",
        "CorrelatedRandomVectorGeneratorTest",
        "nextBoolean",
        "testPercentile",
        "reduce",
        "normalize",
        "getResult",
        "checkAppendError",
        "atanh",
        "testColumnsPermutation",
        "testGetRowMatrix",
        "splitAdd",
        "Percentile",
        "nextSample",
        "setParamsAccuracy",
        "mapAsin",
        "Product",
        "chiSquareTest",
        "testDigitLimitConstructor",
        "atan2",
        "testConsistency",
        "getGeometricMeanImpl",
        "testFormatZero",
        "Brusselator",
        "doCopy",
        "testNegateNaN",
        "updateJacobian",
        "setNumberOfElementsInternal",
        "requiresDenseOutput",
        "nextT",
        "setSumImpl",
        "exactDyDpDot",
        "testOne",
        "MathUtilsTest",
        "tTest",
        "testBigStep",
        "PoissonDistributionTest",
        "CholeskyDecompositionImpl",
        "testLogGammaZero",
        "testSetAbsoluteAccuracy",
        "FDistributionImpl",
        "smooth",
        "ContinuousOutputModel",
        "transformToLowerBiDiagonal",
        "testAddNaN",
        "testBigDecimalValue",
        "checkContractExpand",
        "testNegate",
        "Circle",
        "testLogGammaNan",
        "testPredicates",
        "testDoubleConstructor",
        "getPartial",
        "testMultiplyNaN",
        "getParametersDimension",
        "testDoubleFormat",
        "SaddlePointExpansion",
        "testSimpleWithDecimals",
        "mapTanhToSelf",
        "getCostEvaluations",
        "testScalarMultiply",
        "getSumsqImpl",
        "NonLinearConjugateGradientOptimizer",
        "SimpleScalarValueChecker",
        "nextWeibull",
        "mapSinToSelf",
        "getInverseCumulativeTestValues",
        "setSubMatrix",
        "testGetVectors",
        "testQuinticMax",
        "getConvergenceChecker",
        "theoretical",
        "TestProblemHandler",
        "illumination",
        "testL1DistanceDouble",
        "nextDouble",
        "testAnalyticalDifferentiation",
        "exactDyDy0",
        "getInverseCumulativeTestPoints",
        "setDenominatorDegreesOfFreedomInternal",
        "testBoundParameters",
        "getPolynomialFunction",
        "testEqualsIncludingNaN",
        "StreamDataAdapter",
        "testInsufficientBandwidth",
        "testDivideNaNInf",
        "SparseEntryIterator",
        "AbstractEstimator",
        "testOperatePremultiplyLarge",
        "sample",
        "sign",
        "mapLog1pToSelf",
        "normalApproximateProbability",
        "isRootOK",
        "testString",
        "getEntries",
        "WeibullDistributionImpl",
        "SummaryStatistics",
        "getT",
        "testSetImaginaryCharacterNull",
        "getInitialDomain",
        "testSinFunction2",
        "testHighDegreeLegendre",
        "testMultiply2",
        "testNextInt",
        "testL2DistanceInt",
        "testGetRowVector",
        "mdfft",
        "testPermutedArrayHash",
        "distanceSq",
        "integrateWithSpecifiedStep",
        "BigFraction",
        "testSampling",
        "testTranspose",
        "testSkewAndKurtosis",
        "addObject",
        "MersenneTwister",
        "testPolar2Complex",
        "RombergIntegrator",
        "mapCbrtToSelf",
        "testIterator",
        "setLineSearchSolver",
        "getNormInf",
        "testPolar2ComplexInf",
        "correlation",
        "checkDimension",
        "checkRotation",
        "getKurtosisImpl",
        "testGeometricMean",
        "testDataInOut",
        "testMinimizeMaximize",
        "setVarianceImpl",
        "testGetColumn",
        "setNumeratorDegreesOfFreedomInternal",
        "removeData",
        "getGoalType",
        "setMeanImpl",
        "interpolate",
        "TriDiagonalTransformerTest",
        "getDimensionSizes",
        "LaguerreSolver",
        "tanh",
        "generateSineData",
        "initializeEstimate",
        "expandTo",
        "testMulAndCheckLongFailure",
        "getSumLog",
        "setMedian",
        "testUnequalSizeArguments",
        "testSqrtRealZero",
        "mapLogToSelf",
        "SumOfLogs",
        "transform2",
        "RosenbrockFunction",
        "testNexBoolean",
        "unitVector",
        "DP54SmallLastHandler",
        "getCurrentStepStart",
        "testPValueNearZero",
        "testSinhNaN",
        "getSingularValues",
        "FastSineTransformer",
        "solve",
        "getDegreesOfFreedom",
        "ExponentialDistributionImpl",
        "testRedundantEquations",
        "LocalMeasurement",
        "testLInfDistanceDouble",
        "getNanStrategy",
        "testCos",
        "for",
        "testAngular",
        "LevenbergMarquardtOptimizer",
        "testSetAlpha",
        "getSubVector",
        "BinomialDistributionImpl",
        "testVectorTwoPairs",
        "nextVector",
        "estimateRegressionParametersStandardErrors",
        "testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers",
        "BiDiagonalTransformer",
        "testMath341",
        "createComplex",
        "testGcdLong",
        "mapSubtractToSelf",
        "testMath369",
        "getNorm1",
        "getCovariance",
        "OpenMapRealVector",
        "precondition",
        "testCumulativeProbabilitySpecial",
        "testNextInversionDeviate",
        "testEvents",
        "mapTan",
        "testFormatImproper",
        "Beta",
        "toString",
        "estimateRegressandVariance",
        "getCurrentSignedStepsize",
        "MicrosphereInterpolatingFunction",
        "transformToTridiagonal",
        "rank",
        "TestProblem2",
        "verifyConsistency",
        "setDistribution",
        "setPopulationSize",
        "testCircleFittingBadInit",
        "getRSquare",
        "getFunctionValue",
        "NewtonSolver",
        "setStarterIntegrator",
        "testDimension3MultipleRoot",
        "testControlParameters",
        "testNextWeibull",
        "distance1",
        "testAtanInf",
        "checkSufficientData",
        "growTable",
        "testScale",
        "LinearProblem",
        "perturb",
        "LegendreGaussIntegrator",
        "StandardDeviation",
        "CauchyDistributionTest",
        "readObject",
        "populationStandardDeviation",
        "qrDecomposition",
        "mapExpm1ToSelf",
        "EigenDecompositionImplTest",
        "setMaxIterations",
        "testBoundaries",
        "asCollector",
        "log10",
        "factorialLog",
        "setBeta",
        "polynomial",
        "testSmallStep",
        "NordsieckStepInterpolator",
        "testGetSetRowVectorLarge",
        "testDifferentImaginaryChar",
        "setScale",
        "HarmonicFunction",
        "testCoordinates",
        "isSingular",
        "testQuantiles",
        "checkTheoreticalStartCost",
        "discardFrontElements",
        "determineLMParameter",
        "VariableHandler",
        "testRegularizedGammaPositiveNegative",
        "setStandardDeviation",
        "testNextChiSquare",
        "getXSumSquares",
        "testBBiDiagonal",
        "validateSampleData",
        "equals",
        "getColumn",
        "getPercentileImpl",
        "testSparseIterator",
        "testDivideReal",
        "dYdP0",
        "testSetterIllegalState",
        "testConjugateInfiinite",
        "mapLog10ToSelf",
        "testGetImaginaryFormat",
        "testMinpackWatson",
        "testTanhNaN",
        "ListUnivariateImplTest",
        "getQ",
        "append",
        "testFunctionEvaluationExceptions",
        "testRank",
        "testLowAccuracyExternalDifferentiation",
        "restoreNaNs",
        "testIllConditioned",
        "testQRColumnsPermutation",
        "testZeroReal",
        "rint",
        "iterator",
        "newXSampleData",
        "testParseSimpleWithDecimalsTrunc",
        "testConjugate",
        "testCompletelyIncorrectBandwidth1",
        "test1PercentError",
        "testInsufficientData",
        "setRowVector",
        "createMatrix",
        "setProbabilityOfSuccessInternal",
        "calculateResiduals",
        "exceedMaxEvaluations",
        "guessAOmega",
        "testRint",
        "conjugate",
        "testRegularizedGammaNegativePositive",
        "TestVectorImpl",
        "testReciprocal",
        "mapSignumToSelf",
        "TestProblem4",
        "testResetMaximalIterationCount",
        "testNoDenseOutput",
        "testLeastSquares3",
        "Rotation",
        "testHermiteDifferentials",
        "expint",
        "testNegativeInfinity",
        "getAdapter",
        "setTransformer",
        "EventState",
        "getMinIndex",
        "getMaxEvaluations",
        "testAddAndCheck",
        "evaluate",
        "testSqrtPolar",
        "GillStepInterpolator",
        "testZero",
        "testAdHocData",
        "testGetStandardDeviation",
        "findSample",
        "testSolveBadParameters",
        "testIndicatorInt",
        "testEqualsTrue",
        "Array2DRowRealMatrixTest",
        "noReset",
        "setNormalAndMeanInternal",
        "permuteRows",
        "ebeMultiply",
        "store",
        "testParsePositiveInfinity",
        "testFloatValue",
        "getNumeratorDegreesOfFreedom",
        "testConstruction",
        "testDivide",
        "testResetRelativeAccuracy",
        "sqrt1z",
        "testUnstableDerivative",
        "getSampleStats",
        "estimateError",
        "AbstractRealMatrix",
        "testMinpackLinearFullRank",
        "computeTheoreticalState",
        "AdamsMoultonIntegrator",
        "doRemove",
        "fillBinStats",
        "testNotAllFiniteReal6",
        "mapLog",
        "getCumulativeTestValues",
        "getSparcity",
        "testMaxIterations",
        "testNextCauchy",
        "getNorm",
        "testAtan",
        "testPreconditions",
        "mapAddToSelf",
        "TTestImpl",
        "testLogZero",
        "getDistributionQuartiles",
        "mapExp",
        "testClone",
        "serialization",
        "newFixedLengthChromosome",
        "testUOrthogonal",
        "isIncludedColumn",
        "BetaDistributionImpl",
        "MicrosphereSurfaceElement",
        "containsKey",
        "AbstractIntegerDistribution",
        "testErf2807",
        "Bounce",
        "mapCos",
        "getMin",
        "testSin",
        "sinh",
        "testSqrtImaginaryZero",
        "testNextIntNeg",
        "setNumberOfTrials",
        "getCount",
        "setGeoMeanImpl",
        "mapDivideToSelf",
        "getHouseholderVectorsRef",
        "logBinomialProbability",
        "testParseNegativeImaginary",
        "testEstimate",
        "SimpsonIntegrator",
        "getMeasurements",
        "getDenominatorDegreesOfFreedom",
        "testGetSetRowMatrixLarge",
        "testNextLongExtremeValues",
        "testNextBinomial",
        "testDistanceInf",
        "testMath226",
        "angle",
        "testNextHex",
        "setRowMatrix",
        "setDegreesOfFreedom",
        "chiSquareDataSetsComparison",
        "testGetRealFormat",
        "createHermitePolynomial",
        "addToEntry",
        "sanityChecks",
        "setup",
        "testBinomialCoefficient",
        "altPolar",
        "guessPhi",
        "checkSampleData",
        "GammaDistributionImpl",
        "testMedian",
        "getWeight",
        "getNanPositions",
        "resetTables",
        "createDiagonalMatrix",
        "getMaximalTimeError",
        "testMapFunctions",
        "setInverseCumulativeTestPoints",
        "setSkewnessImpl",
        "fillUpper",
        "GillIntegrator",
        "crossProduct",
        "generalizedHarmonic",
        "ComplexUtils",
        "getDataRef",
        "testDivideImaginary",
        "testDistance1",
        "setSeed",
        "computeJacobians",
        "GraggBulirschStoerIntegrator",
        "homoscedasticTTest",
        "computeObjectiveValue",
        "testPositiveInfinity",
        "logBeta",
        "getInternalLength",
        "isForward",
        "getDelta",
        "testDeprecated",
        "getParameters",
        "handleStep",
        "setContractionCriteria",
        "makeCumulativeTestPoints",
        "gcd",
        "resetRelativeAccuracy",
        "assertRelativelyEquals",
        "luDecompose",
        "makeDistribution",
        "testParseBig",
        "mapMultiplyToSelf",
        "nextHypergeometric",
        "testFormatImproperNegative",
        "testParseProperNegative",
        "testMath283",
        "ComposableFunction",
        "MathUtils",
        "BitsStreamGenerator",
        "getOptimaValues",
        "testAEqualVDVt",
        "testNextSample",
        "testDensities",
        "BrownDennisFunction",
        "testEqualsSame",
        "differentiate",
        "tanQ",
        "RandomDataTest",
        "getQ2",
        "testFirstLaguerrePolynomials",
        "testSqrt1z",
        "setNumberOfSuccesses",
        "testPowNaNExponent",
        "mapPow",
        "testDimension4WithoutSplit",
        "computeSecondDerivatives",
        "setNumberOfSuccessesInternal",
        "testpowNull",
        "RealMatrixImplTest",
        "getAlpha",
        "testArrayIndexConditions",
        "testQuadratic",
        "testSmallError",
        "testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty",
        "isNonSingular",
        "KowalikOsborneFunction",
        "getRealEigenvalues",
        "partialerror",
        "testGetColumnVector",
        "DummyIntegrator",
        "testHash",
        "advance",
        "remove",
        "MidpointIntegratorTest",
        "testSetMean",
        "chiSquareTestDataSetsComparison",
        "addObservedPoint",
        "testCompareTo",
        "incrementIterationsCounter",
        "clearEventHandlers",
        "regularizedGammaQ",
        "getCorrelationStandardErrors",
        "testLegendreDifferentials",
        "testFloatingPointArguments",
        "shouldGrowTable",
        "ContinuousDistributionAbstractTest",
        "testEqualsIncludingNaNWithAllowedUlps",
        "orthogonal",
        "TestUtils",
        "testNonSquare",
        "testIllegalArguments",
        "testLinear",
        "testLcm",
        "logGamma",
        "NaturalRanking",
        "testCopy",
        "setStandardDeviationInternal",
        "BlockFieldMatrix",
        "ContinuedFraction",
        "testHashCode",
        "getInverse",
        "testNextPoissonConsistency",
        "testUnsorted",
        "test2DData",
        "testLongly",
        "getCovariances",
        "computeOmega",
        "testIncreasingBandwidthIncreasesSmoothness",
        "add",
        "mapRint",
        "getBinStats",
        "columnToVector",
        "getDistribution",
        "MeyerFunction",
        "doubleValue",
        "setNormal",
        "getRowMatrix",
        "mapToSelf",
        "extrapolate",
        "IntDoublePair",
        "scalarAdd",
        "testOrthogonal",
        "testMinStep",
        "testMinpackPowellSingular",
        "testMinpackBrownAlmostLinear",
        "cosAngle",
        "getDenominator",
        "testEqualsWithAllowedDelta",
        "testCompletelyIncorrectBandwidth2",
        "testEqualsWithAllowedUlps",
        "verifyDataSet",
        "testScalb",
        "testCoshNaN",
        "UnivariateStatisticAbstractTest",
        "nextCauchy",
        "setNumElements",
        "testSqrtNaN",
        "testSwissFertility",
        "BaseAbstractScalarOptimizer",
        "testParseProperInvalidMinus",
        "setSampleSize",
        "probe",
        "testCopySubMatrix",
        "ElitisticListPopulation",
        "testSetRealFormatNull",
        "testSinInf",
        "PolynomialsUtils",
        "MinpackTest",
        "testGetSetRowLarge",
        "getColumnVector",
        "getStandardDeviation",
        "testBasicFunctions",
        "testImpossibleSerialization",
        "MultiDimensionalComplexMatrix",
        "testEqualsImaginaryDifference",
        "set",
        "testParseSimpleWithDecimals",
        "testMath304",
        "splitMult",
        "getData",
        "testSignFloat",
        "isInfinite",
        "density",
        "getPercentile",
        "testFrobeniusNorm",
        "computeCoefficients",
        "getDomainUpperBound",
        "testAddAndCheckLong",
        "getUnivariateStatistic",
        "setImpl",
        "chiSquare",
        "testParseNegativeReal",
        "testLargeMeanInverseCumulativeProbability",
        "setConvergenceChecker",
        "getGuessedPulsation",
        "buildRandomPolynomial",
        "testCheckOrder",
        "RungeKuttaIntegrator",
        "MixedListUnivariateImplTest",
        "next",
        "getDistance",
        "predict",
        "integrate",
        "setSumsqImpl",
        "testDimensionCheck",
        "solveAll",
        "testPowZero",
        "checkSerializedEquality",
        "nextFloat",
        "qTy",
        "mapCosh",
        "walkInRowOrder",
        "testInconsistentEquations",
        "getPulsation",
        "slowSin",
        "testIndicatorShort",
        "GeometricMean",
        "dotProduct",
        "testGcdConsistency",
        "setSubVector",
        "testBeta",
        "testFactorialFail",
        "theoreticalValue",
        "getMinReduction",
        "fst",
        "getAmplitude",
        "BinaryFunction",
        "checkSignificanceLevel",
        "getNumElements",
        "mapSubtract",
        "minpackTest",
        "getChiSquare",
        "testNextPoisson",
        "makeDensityTestPoints",
        "getNumeratorAsInt",
        "nextSecureHexString",
        "getSumLogImpl",
        "testSinMin",
        "testResetAbsoluteAccuracy",
        "increment",
        "mapUlp",
        "getMaxError",
        "gradient",
        "setCumulativeTestValues",
        "testNextZipf",
        "outerProduct",
        "removeMostRecentValue",
        "testInterpolateLinearDegenerateTwoSegment",
        "testStats",
        "setScaleInternal",
        "getU",
        "SimpleRealPointChecker",
        "CauchyDistributionImpl",
        "testScalarAdd",
        "testNextLong",
        "verifyInterval",
        "mapInv",
        "testTanCritical",
        "testNextF",
        "isLoaded",
        "nextNonzero",
        "TestComplex",
        "testConstants",
        "setColumnVector",
        "testNegativeImaginary",
        "checkNoAccessBelowDiagonal",
        "cumulativeProbability",
        "getVT",
        "ClassicalRungeKuttaIntegratorTest",
        "buildArray",
        "mapCeilToSelf",
        "PoissonDistributionImpl",
        "testGetSetMatrixLarge",
        "setMaxGrowth",
        "testSignLong",
        "testAsin",
        "getImagEigenvalue",
        "getDeviancePart",
        "testSqrt1zNaN",
        "fft",
        "getTiesStrategy",
        "getMaxIterations",
        "testIntegerOverflow",
        "bracket",
        "checkNextPoissonConsistency",
        "getEventTime",
        "checkBiDiagonal",
        "testArrayEquals",
        "getAngles",
        "asin",
        "key",
        "blockHeight",
        "testAcosInf",
        "mapSqrtToSelf",
        "testKepler",
        "sinQ",
        "getMax",
        "testQuinticFunction",
        "upperCumulativeProbability",
        "exp",
        "TestProblem1",
        "PascalDistributionImpl",
        "testIdentity",
        "testOperateLarge",
        "getProbabilityOfSuccess",
        "setColumnMatrix",
        "testInverseCumulativeProbabilities",
        "heresBar",
        "getP",
        "compareTo",
        "getNextValue",
        "checkRelativeError",
        "cosQ",
        "getCorrelationPValues",
        "testLongValue",
        "testAsinNaN",
        "transformToUpperBiDiagonal",
        "getRelativeAccuracy",
        "testStaticFormatComplex",
        "setOrderControl",
        "getMaximum",
        "fix2ndArgument",
        "GraggBulirschStoerStepInterpolator",
        "GaussNewtonEstimatorTest",
        "getInterceptStdErr",
        "testSubtract",
        "getL1Distance",
        "resetInternalState",
        "addValue",
        "testIntValue",
        "getFinalTime",
        "AdamsBashforthIntegrator",
        "testNonStrictlyIncreasing1",
        "initializeArrays",
        "innerCumulativeProbability",
        "computeInterpolatedStateAndDerivatives",
        "testAngles",
        "testMath308",
        "solve2",
        "getUnboundParameters",
        "testEqualsClass",
        "testCoshInf",
        "getLInfNorm",
        "covarianceToCorrelation",
        "checkEstimate",
        "testPowNaNBase",
        "BlockRealMatrixTest",
        "testQuadraticFunction",
        "testNextUniform",
        "getReducedFraction",
        "testSubtractNaN",
        "newSampleData",
        "getIntercept",
        "mapAtan",
        "optimize",
        "testAcosNaN",
        "testLongFormat",
        "mapSinh",
        "localMin",
        "testWeightedConsistency",
        "setExponentInternal",
        "setSafety",
        "FastMath",
        "testEqualsNaN",
        "Iterator",
        "getElements",
        "testRepeatedEigenvalue",
        "checkEigenVector",
        "jacobian",
        "testBinomialCoefficientFail",
        "cosh",
        "testBracketEndpointRoot",
        "sqrt",
        "resetState",
        "testBigMatrix",
        "nextExponential",
        "getVariance",
        "createBlocksLayout",
        "getB",
        "testEigenvectors",
        "testSetRowMatrix",
        "testFix1st",
        "changeIndexSign",
        "testParseNegativeBoth",
        "testNumeratorFormat",
        "testParseNegative",
        "checkUnsolvableProblem",
        "DormandPrince54Integrator",
        "setBetaInternal",
        "getResults",
        "Osborne2Function",
        "BrentSolver",
        "getElement",
        "testLargeMeanCumulativeProbability",
        "nextUp",
        "testMinpackFreudensteinRoth",
        "testScalarMultiplyInf",
        "assertContains",
        "addEventHandler",
        "PolynomialFunctionLagrangeForm",
        "setEquations",
        "MullerSolver",
        "testVariance",
        "computeStats",
        "BrownAlmostLinearFunction",
        "getSolver",
        "getMainSetDimension",
        "mapExpm1",
        "testNextSecureLong",
        "checkPolynomial",
        "doFinalize",
        "getValues",
        "computeCorrelationMatrix",
        "eliminateZeroMassPoints",
        "getEntry",
        "getSumSquaredErrors",
        "checkRectangular",
        "testPremultiplyVector"
      ],
      "functions_name_co_evolved_modified_file": [
        "signum",
        "cos",
        "log10",
        "min",
        "log1p",
        "atanh",
        "splitReciprocal",
        "polySine",
        "nextUp",
        "slowCos",
        "slowSin",
        "splitAdd",
        "tanQ",
        "for",
        "slowLog",
        "reducePayneHanek",
        "FastMath",
        "round",
        "tan",
        "cosQ",
        "atan2",
        "slowexp",
        "resplit",
        "random",
        "cosh",
        "polyCosine",
        "ulp",
        "max",
        "expint",
        "nextAfter",
        "sqrt",
        "tanh",
        "cbrt",
        "atan",
        "toRadians",
        "asin",
        "floor",
        "expm1",
        "abs",
        "rint",
        "quadMult",
        "sin",
        "log",
        "pow",
        "split",
        "sinh",
        "buildSinCosTables",
        "sinQ",
        "asinh",
        "toDegrees",
        "acosh",
        "ceil",
        "exp",
        "splitMult",
        "acos"
      ],
      "functions_name_co_evolved_all_files": [
        "mapCoshToSelf",
        "signum",
        "exactYDot",
        "testAdHocData",
        "testFloat",
        "LinearRank1ZeroColsAndRowsFunction",
        "getCenterDistance",
        "testBackward",
        "reducePayneHanek",
        "noReset",
        "setNormalAndMeanInternal",
        "polyCosine",
        "random",
        "QRDecompositionImpl",
        "MultistepIntegrator",
        "checklone",
        "testExactIntegration",
        "testArrayEqualsIncludingNaN",
        "estimateError",
        "computeTheoreticalState",
        "testErf2576",
        "binomialCoefficientDouble",
        "mapUlpToSelf",
        "distanceInf",
        "getNorm",
        "testNoError",
        "testQuinticFunction2",
        "testNexBytes",
        "testDistance",
        "isIncludedColumn",
        "atan",
        "testExpm1Function",
        "testErf2807",
        "fct",
        "testMinpackRosenbrok",
        "quadMult",
        "log",
        "testPlane",
        "sinh",
        "checkClone",
        "transform",
        "inversetransform2",
        "testOnDistortedSine",
        "testNoReset",
        "value",
        "buildPolynomial",
        "cos",
        "binomialCoefficientLog",
        "getLInfDistance",
        "testAcos",
        "logBinomialProbability",
        "getResiduals",
        "testGoldenRatio",
        "testDecreasingSteps",
        "AdaptiveStepsizeIntegrator",
        "testSolveSin",
        "computeStepGrowShrinkFactor",
        "getUpperDomain",
        "testMath226",
        "testIncreasingTolerance",
        "angle",
        "testSingularMatrix",
        "testInterpolateSin",
        "testGetArgument",
        "mapAbsToSelf",
        "chiSquareDataSetsComparison",
        "getQT",
        "sin",
        "updateResidualsAndCost",
        "sanityChecks",
        "testBinomialCoefficient",
        "guessPhi",
        "asinh",
        "toDegrees",
        "testMedian",
        "testSingularities",
        "getFrobeniusNorm",
        "roundUnscaled",
        "walkInOptimizedOrder",
        "resetTables",
        "createDiagonalMatrix",
        "testDensity",
        "generalizedHarmonic",
        "mapAcosToSelf",
        "setSeed",
        "homoscedasticTTest",
        "ulp",
        "getDelta",
        "testDeprecated",
        "nextAfter",
        "handleStep",
        "getJacobian",
        "testBinomialCoefficientLarge",
        "testSinFunction",
        "gcd",
        "assertRelativelyEquals",
        "testParseBig",
        "testCircleFitting",
        "testMatricesValues5",
        "getSlopeStdErr",
        "ComposableFunction",
        "acosh",
        "nextGeneration",
        "isSymmetric",
        "getRank",
        "testHighAccuracyExternalDifferentiation",
        "testVectorOnePair",
        "min",
        "getSlope",
        "mapCosToSelf",
        "exactY",
        "getStirlingError",
        "tanQ",
        "addEndTimeChecker",
        "testEventHandler",
        "preMultiply",
        "guessParametersErrors",
        "testQuinticMinStatistics",
        "getAlpha",
        "testCombine",
        "testSmallError",
        "mapPowToSelf",
        "t",
        "testMatrix",
        "Fraction",
        "regularizedGammaP",
        "testSerialization",
        "multiply",
        "inverseCumulativeProbability",
        "converged",
        "testfirstDerivativeComparison",
        "nextPoisson",
        "testSetMean",
        "testAxisAngle",
        "testDigammaSmallArgs",
        "probability",
        "isDefaultValue",
        "regularizedGammaQ",
        "getCorrelationStandardErrors",
        "exactDyDy0Dot",
        "testFloatingPointArguments",
        "testEqualsIncludingNaNWithAllowedUlps",
        "orthogonal",
        "normalizeAngle",
        "testSinZero",
        "estimate",
        "logGamma",
        "testSumLog",
        "derivative",
        "testNormalizeAngle",
        "expand",
        "computeOmega",
        "getResult",
        "testIncreasingBandwidthIncreasesSmoothness",
        "add",
        "atanh",
        "splitAdd",
        "testFactorial",
        "testNonInversible",
        "atan2",
        "testConsistency",
        "testMinStep",
        "updateJacobian",
        "toRadians",
        "expm1",
        "getLowerDomain",
        "testConstructor",
        "exactDyDpDot",
        "testEqualsWithAllowedUlps",
        "tTest",
        "testScalb",
        "testBigStep",
        "regularizedBeta",
        "CholeskyDecompositionImpl",
        "factorialDouble",
        "smooth",
        "getArgument",
        "transformToLowerBiDiagonal",
        "testPredicates",
        "testMinEndpoints",
        "testDoubleFormat",
        "testErf1960",
        "testChebyshevBounds",
        "toBlocksLayout",
        "mapTanhToSelf",
        "mapFloorToSelf",
        "getStandardDeviation",
        "digamma",
        "testStdErrorConsistency",
        "testParaboloid",
        "testMatricesValues",
        "isIncludedValue",
        "mapSinToSelf",
        "setSubMatrix",
        "checkTheoreticalMinParams",
        "split",
        "determineLMDirection",
        "splitMult",
        "exactDyDy0",
        "getData",
        "density",
        "end",
        "testFrobeniusNorm",
        "sample",
        "testLinearFunction",
        "mapLog1pToSelf",
        "getRMS",
        "isRootOK",
        "chiSquare",
        "testFinalResult",
        "RungeKuttaIntegrator",
        "getInitialDomain",
        "buildSinCosTables",
        "findEigenVectors",
        "getDistance",
        "testSinFunction2",
        "integrate",
        "testSimpleCombination",
        "testHighDegreeLegendre",
        "testNextInt",
        "testCopyConsistency",
        "homoscedasticT",
        "integrateWithSpecifiedStep",
        "walkInRowOrder",
        "log1p",
        "splitReciprocal",
        "BigFraction",
        "getR",
        "findUpperBound",
        "slowSin",
        "initializeStep",
        "testSetStandardDeviation",
        "getL1Norm",
        "getSignificance",
        "nextGaussian",
        "polar2Complex",
        "checkTheoreticalMinCost",
        "tryStep",
        "mapCbrtToSelf",
        "divide",
        "getNormInf",
        "testBeta",
        "rescale",
        "abs",
        "computeCapacity",
        "fst",
        "BinaryFunction",
        "Vector3D",
        "minpackTest",
        "testGeometricMean",
        "testExpm1Function2",
        "testFormatNumber",
        "testSmallLastStep",
        "testMinimizeMaximize",
        "testMath372",
        "mapExpToSelf",
        "testSolveAccuracySin",
        "distance",
        "doComputeDerivatives",
        "testSinMin",
        "increment",
        "testAtan2",
        "tan",
        "gradient",
        "slowexp",
        "testDouble",
        "setInterpolatedTime",
        "testStats",
        "interpolationAtBounds",
        "tanh",
        "generateSineData",
        "testNextLong",
        "StepNormalizer",
        "decompose",
        "mapLogToSelf",
        "orthogonalizeMatrix",
        "transform2",
        "testNexBoolean",
        "transpose",
        "pow",
        "subtract",
        "cumulativeProbability",
        "solve",
        "mapCeilToSelf",
        "testNextAfter",
        "testParaboloid2D",
        "findBin",
        "testNextGaussian",
        "slowCos",
        "filterStep",
        "for",
        "getDeviancePart",
        "testAngular",
        "resolveTie",
        "bracket",
        "testAngularSeparation",
        "testVectorTwoPairs",
        "nextVector",
        "estimateRegressionParametersStandardErrors",
        "checkNextPoissonConsistency",
        "testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers",
        "BiDiagonalTransformer",
        "testArrayEquals",
        "getAngles",
        "testMath341",
        "testApplyInverseTo",
        "asin",
        "floor",
        "testMath369",
        "doOptimize",
        "getNorm1",
        "mapSqrtToSelf",
        "sinQ",
        "testQuinticFunction",
        "SingularValueDecompositionImpl",
        "exp",
        "acos",
        "toString",
        "testRootEndpoints",
        "testSerial",
        "mapRintToSelf",
        "testNextAfterSpecialCases",
        "checkRelativeError",
        "getNextValue",
        "cosQ",
        "mapAtanToSelf",
        "getCorrelationPValues",
        "lcm",
        "mapTanToSelf",
        "transformToUpperBiDiagonal",
        "testAlpha",
        "cbrt",
        "backward",
        "getInterceptStdErr",
        "testSetterInjection",
        "distance1",
        "createOrthogonalMatrix",
        "getL1Distance",
        "testScale",
        "resetInternalState",
        "populationStandardDeviation",
        "qrDecomposition",
        "mapExpm1ToSelf",
        "fitness",
        "mapAsinToSelf",
        "computeInterpolatedStateAndDerivatives",
        "polynomial",
        "log10",
        "factorialLog",
        "testSmallStep",
        "polySine",
        "testFixedState",
        "testVectorialProducts",
        "solve2",
        "resplit",
        "testCoordinates",
        "testArrayHash",
        "getLInfNorm",
        "checkTheoreticalStartCost",
        "determineLMParameter",
        "testConstructors",
        "covarianceToCorrelation",
        "testStepHandlerResult",
        "testQuadraticFunction",
        "equals",
        "optimize",
        "getAxis",
        "interpolationInside",
        "mapLog10ToSelf",
        "testMissedEndEvent",
        "testLinearFunction2D",
        "localMin",
        "testErf3291",
        "checkDerivativesConsistency",
        "FastMath",
        "checkValue",
        "jacobian",
        "append",
        "cosh",
        "equalsIncludingNaN",
        "sqrt",
        "getAngle",
        "nextExponential",
        "LUDecompositionImpl",
        "rint",
        "createBlocksLayout",
        "evaluateStep",
        "testDeprecated2",
        "testFix1st",
        "ceil",
        "testComposition",
        "nthRoot",
        "guessAOmega",
        "getH",
        "testLargeMeanCumulativeProbability",
        "nextUp",
        "testNorm",
        "slowLog",
        "TestProblem3",
        "round",
        "mapSignumToSelf",
        "TestProblem4",
        "Rotation",
        "max",
        "expint",
        "testMeanAndCovariance",
        "EventState",
        "testZeroDivide",
        "testWave",
        "getValues",
        "evaluate",
        "getSumSquaredErrors",
        "operate",
        "testGetArgumentInf",
        "mapSinhToSelf",
        "testSqrtPolar",
        "testModelsMerging",
        "exactDyDp"
      ]
    },
    "file": {
      "file_name": "FastMath.java",
      "file_nloc": 1683,
      "file_complexity": 323,
      "file_token_count": 14546,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,2967 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+/**\n+ * Faster, more accurate, portable alternative to StrictMath.\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class FastMath {\n+\n+    /** Archimede's constant PI, ratio of circle circumference to diameter. */\n+    public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n+\n+    /** Napier's constant e, base of the natural logarithm. */\n+    public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;\n+\n+    /** Exponential evaluated at integer values,\n+     * exp(x) =  expIntTableA[x + 750] + expIntTableB[x+750].\n+     */\n+    private static final double EXP_INT_TABLE_A[] = new double[1500];\n+\n+    /** Exponential evaluated at integer values,\n+     * exp(x) =  expIntTableA[x + 750] + expIntTableB[x+750]\n+     */\n+    private static final double EXP_INT_TABLE_B[] = new double[1500];\n+\n+    /** Exponential over the range of 0 - 1 in increments of 2^-10\n+     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n+     */\n+    private static final double EXP_FRAC_TABLE_A[] = new double[1025];\n+\n+    /** Exponential over the range of 0 - 1 in increments of 2^-10\n+     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n+     */\n+    private static final double EXP_FRAC_TABLE_B[] = new double[1025];\n+\n+    /** Factorial table, for Taylor series expansions. */\n+    private static final double FACT[] = new double[20];\n+\n+    /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n+    private static final double LN_MANT[][] = new double[1024][];\n+\n+    /** log(2) (high bits). */\n+    private static final double LN_2_A = 0.693147063255310059;\n+\n+    /** log(2) (low bits). */\n+    private static final double LN_2_B = 1.17304635250823482e-7;\n+\n+    /** Coefficients for slowLog. */\n+    private static final double LN_SPLIT_COEF[][] = {\n+        {2.0, 0.0},\n+        {0.6666666269302368, 3.9736429850260626E-8},\n+        {0.3999999761581421, 2.3841857910019882E-8},\n+        {0.2857142686843872, 1.7029898543501842E-8},\n+        {0.2222222089767456, 1.3245471311735498E-8},\n+        {0.1818181574344635, 2.4384203044354907E-8},\n+        {0.1538461446762085, 9.140260083262505E-9},\n+        {0.13333332538604736, 9.220590270857665E-9},\n+        {0.11764700710773468, 1.2393345855018391E-8},\n+        {0.10526403784751892, 8.251545029714408E-9},\n+        {0.0952233225107193, 1.2675934823758863E-8},\n+        {0.08713622391223907, 1.1430250008909141E-8},\n+        {0.07842259109020233, 2.404307984052299E-9},\n+        {0.08371849358081818, 1.176342548272881E-8},\n+        {0.030589580535888672, 1.2958646899018938E-9},\n+        {0.14982303977012634, 1.225743062930824E-8},\n+    };\n+\n+    /** Coefficients for log, when input 0.99 < x < 1.01. */\n+    private static final double LN_QUICK_COEF[][] = {\n+        {1.0, 5.669184079525E-24},\n+        {-0.25, -0.25},\n+        {0.3333333134651184, 1.986821492305628E-8},\n+        {-0.25, -6.663542893624021E-14},\n+        {0.19999998807907104, 1.1921056801463227E-8},\n+        {-0.1666666567325592, -7.800414592973399E-9},\n+        {0.1428571343421936, 5.650007086920087E-9},\n+        {-0.12502530217170715, -7.44321345601866E-11},\n+        {0.11113807559013367, 9.219544613762692E-9},\n+    };\n+\n+    /** Coefficients for log in the range of 1.0 < x < 1.0 + 2^-10. */\n+    private static final double LN_HI_PREC_COEF[][] = {\n+        {1.0, -6.032174644509064E-23},\n+        {-0.25, -0.25},\n+        {0.3333333134651184, 1.9868161777724352E-8},\n+        {-0.2499999701976776, -2.957007209750105E-8},\n+        {0.19999954104423523, 1.5830993332061267E-10},\n+        {-0.16624879837036133, -2.6033824355191673E-8}\n+    };\n+\n+    /** Sine table (high bits). */\n+    private static final double SINE_TABLE_A[] = new double[14];\n+\n+    /** Sine table (low bits). */\n+    private static final double SINE_TABLE_B[] = new double[14];\n+\n+    /** Cosine table (high bits). */\n+    private static final double COSINE_TABLE_A[] = new double[14];\n+\n+    /** Cosine table (low bits). */\n+    private static final double COSINE_TABLE_B[] = new double[14];\n+\n+    /** Tangent table, used by atan() (high bits). */\n+    private static final double TANGENT_TABLE_A[] = new double[14];\n+\n+    /** Tangent table, used by atan() (low bits). */\n+    private static final double TANGENT_TABLE_B[] = new double[14];\n+\n+    /** Bits of 1/(2*pi), need for reducePayneHanek(). */\n+    private static long RECIP_2PI[] = new long[] {\n+        (0x28be60dbL << 32) | 0x9391054aL,\n+        (0x7f09d5f4L << 32) | 0x7d4d3770L,\n+        (0x36d8a566L << 32) | 0x4f10e410L,\n+        (0x7f9458eaL << 32) | 0xf7aef158L,\n+        (0x6dc91b8eL << 32) | 0x909374b8L,\n+        (0x01924bbaL << 32) | 0x82746487L,\n+        (0x3f877ac7L << 32) | 0x2c4a69cfL,\n+        (0xba208d7dL << 32) | 0x4baed121L,\n+        (0x3a671c09L << 32) | 0xad17df90L,\n+        (0x4e64758eL << 32) | 0x60d4ce7dL,\n+        (0x272117e2L << 32) | 0xef7e4a0eL,\n+        (0xc7fe25ffL << 32) | 0xf7816603L,\n+        (0xfbcbc462L << 32) | 0xd6829b47L,\n+        (0xdb4d9fb3L << 32) | 0xc9f2c26dL,\n+        (0xd3d18fd9L << 32) | 0xa797fa8bL,\n+        (0x5d49eeb1L << 32) | 0xfaf97c5eL,\n+        (0xcf41ce7dL << 32) | 0xe294a4baL,\n+         0x9afed7ecL << 32  };\n+\n+    /** Bits of pi/4, need for reducePayneHanek(). */\n+    private static long PI_O_4_BITS[] = new long[] {\n+        (0xc90fdaa2L << 32) | 0x2168c234L,\n+        (0xc4c6628bL << 32) | 0x80dc1cd1L };\n+\n+    /** Eighthes.\n+     * This is used by sinQ, because its faster to do a table lookup than\n+     * a multiply in this time-critical routine\n+     */\n+    private static final double EIGHTHES[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};\n+\n+    // Initialize tables\n+    static {\n+        int i;\n+\n+        // Generate an array of factorials\n+        FACT[0] = 1.0;\n+        for (i = 1; i < 20; i++) {\n+            FACT[i] = FACT[i-1] * i;\n+        }\n+\n+        double tmp[] = new double[2];\n+        double recip[] = new double[2];\n+\n+        // Populate expIntTable\n+        for (i = 0; i < 750; i++) {\n+            expint(i, tmp);\n+            EXP_INT_TABLE_A[i+750] = tmp[0];\n+            EXP_INT_TABLE_B[i+750] = tmp[1];\n+\n+            if (i != 0) {\n+                // Negative integer powers\n+                splitReciprocal(tmp, recip);\n+                EXP_INT_TABLE_A[750-i] = recip[0];\n+                EXP_INT_TABLE_B[750-i] = recip[1];\n+            }\n+        }\n+\n+        // Populate expFracTable\n+        for (i = 0; i < 1025; i++) {\n+            slowexp(i/1024.0, tmp);\n+            EXP_FRAC_TABLE_A[i] = tmp[0];\n+            EXP_FRAC_TABLE_B[i] = tmp[1];\n+        }\n+\n+        // Populate lnMant table\n+        for (i = 0; i < 1024; i++) {\n+            double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n+            LN_MANT[i] = slowLog(d);\n+        }\n+\n+        // Build the sine and cosine tables\n+        buildSinCosTables();\n+    }\n+\n+    /**\n+     * Private Constructor\n+     */\n+    private FastMath() {\n+    }\n+\n+    /** Compute the arc cosine of a number.\n+     * @param a number on which evaluation is done\n+     * @return arc cosine of a\n+     */\n+    public static double acos(final double a) {\n+        return Math.acos(a);\n+    }\n+\n+    /** Compute the arc sine of a number.\n+     * @param a number on which evaluation is done\n+     * @return arc sine of a\n+     */\n+    public static double asin(final double a) {\n+        return Math.asin(a);\n+    }\n+\n+    /** Compute the square root of a number.\n+     * @param a number on which evaluation is done\n+     * @return square root of a\n+     */\n+    public static double sqrt(final double a) {\n+        return Math.sqrt(a);\n+    }\n+\n+    /** Compute the cubic root of a number.\n+     * @param a number on which evaluation is done\n+     * @return cubic root of a\n+     */\n+    public static double cbrt(final double a) {\n+        return Math.cbrt(a);\n+    }\n+\n+    /** Compute the hyperbolic cosine of a number.\n+     * @param a number on which evaluation is done\n+     * @return hyperbolic cosine of a\n+     */\n+    public static double cosh(final double a) {\n+        return 0.5 * (FastMath.exp(a) + FastMath.exp(-a));\n+    }\n+\n+    /** Compute the hyperbolic sine of a number.\n+     * @param a number on which evaluation is done\n+     * @return hyperbolic sine of a\n+     */\n+    public static double sinh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absSinh;\n+        if (a > 0.3) {\n+            absSinh = 0.5 * (FastMath.exp(a) - FastMath.exp(-a));\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.05) {\n+                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 * (1 + a2 * (1 + a2 / 110) / 72) / 42) / 20) / 6);\n+            } else {\n+                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 / 42) / 20) / 6);\n+            }\n+        }\n+\n+        return negative ? -absSinh : absSinh;\n+\n+    }\n+\n+    /** Compute the hyperbolic tangent of a number.\n+     * @param a number on which evaluation is done\n+     * @return hyperbolic tangent of a\n+     */\n+    public static double tanh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absTanh;\n+        if (a > 0.074) {\n+            final double twoA = 2 * a;\n+            absTanh = FastMath.expm1(twoA) / (FastMath.exp(twoA) + 1);\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.016) {\n+                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * (17 - a2 * (62 - a2 * 1382 / 55 ) / 9) / 21) / 5) / 3);\n+            } else {\n+                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * 17 / 21) / 5) / 3);\n+            }\n+        }\n+\n+        return negative ? -absTanh : absTanh;\n+\n+    }\n+\n+    /** Compute the inverse hyperbolic cosine of a number.\n+     * @param a number on which evaluation is done\n+     * @return inverse hyperbolic cosine of a\n+     */\n+    public static double acosh(final double a) {\n+        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n+    }\n+\n+    /** Compute the inverse hyperbolic sine of a number.\n+     * @param a number on which evaluation is done\n+     * @return inverse hyperbolic sine of a\n+     */\n+    public static double asinh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absAsinh;\n+        if (a > 0.167) {\n+            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.097) {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n+            } else if (a > 0.036) {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n+            } else if (a > 0.0036) {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n+            } else {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);\n+            }\n+        }\n+\n+        return negative ? -absAsinh : absAsinh;\n+\n+    }\n+\n+    /** Compute the inverse hyperbolic tangent of a number.\n+     * @param a number on which evaluation is done\n+     * @return inverse hyperbolic tangent of a\n+     */\n+    public static double atanh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absAtanh;\n+        if (a > 0.15) {\n+            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.087) {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));\n+            } else if (a > 0.031) {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));\n+            } else if (a > 0.003) {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));\n+            } else {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));\n+            }\n+        }\n+\n+        return negative ? -absAtanh : absAtanh;\n+\n+    }\n+\n+    /** Compute the signum of a number.\n+     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n+     * @param a number on which evaluation is done\n+     * @return -1, 0, +1 or NaN depending on sign of a\n+     */\n+    public static double signum(final double a) {\n+        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));\n+    }\n+\n+    /** Compute next number towards positive infinity.\n+     * @param a number to which neighbor should be computed\n+     * @return neighbor of a towards positive infinity\n+     */\n+    public static double nextUp(final double a) {\n+        return nextAfter(a, Double.POSITIVE_INFINITY);\n+    }\n+\n+    /** Returns a pseudo-random number between 0.0 and 1.0.\n+     * @return a random number between 0.0 and 1.0\n+     */\n+    public static double random() {\n+        return Math.random();\n+    }\n+\n+    /**\n+     * Exponential function.\n+     *\n+     * Computes exp(x), function result is nearly rounded.   It will be correctly\n+     * rounded to the theoretical value for 99.9% of input values, otherwise it will\n+     * have a 1 UPL error.\n+     *\n+     * Method:\n+     *    Lookup intVal = exp(int(x))\n+     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n+     *    Compute z as the exponential of the remaining bits by a polynomial minus one\n+     *    exp(x) = intVal * fracVal * (1 + z)\n+     *\n+     * Accuracy:\n+     *    Calculation is done with 63 bits of precision, so result should be correctly\n+     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n+     *\n+     * @param x   a double\n+     * @return double e<sup>x</sup>\n+     */\n+    public static double exp(double x) {\n+        return exp(x, 0.0, null);\n+    }\n+\n+    /**\n+     * Internal helper method for exponential function.\n+     * @param x original argument of the exponential function\n+     * @param extra extra bits of precision on input (To Be Confirmed)\n+     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n+     * @return exp(x)\n+     */\n+    private static double exp(double x, double extra, double[] hiPrec) {\n+        double intPartA;\n+        double intPartB;\n+        int intVal;\n+\n+        /* Lookup exp(floor(x)).\n+         * intPartA will have the upper 22 bits, intPartB will have the lower\n+         * 52 bits.\n+         */\n+        if (x < 0.0) {\n+            intVal = (int) -x;\n+\n+            if (intVal > 746) {\n+                return 0.0;\n+            }\n+\n+            if (intVal > 709) {\n+                /* This will produce a subnormal output */\n+                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n+                if (hiPrec != null) {\n+                    hiPrec[0] /= 285040095144011776.0;\n+                    hiPrec[1] /= 285040095144011776.0;\n+                }\n+                return result;\n+            }\n+\n+            if (intVal == 709) {\n+                /* exp(1.494140625) is nearly a machine number... */\n+                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n+                if (hiPrec != null) {\n+                    hiPrec[0] /= 4.455505956692756620;\n+                    hiPrec[1] /= 4.455505956692756620;\n+                }\n+                return result;\n+            }\n+\n+            intVal++;\n+\n+            intPartA = EXP_INT_TABLE_A[750-intVal];\n+            intPartB = EXP_INT_TABLE_B[750-intVal];\n+\n+            intVal = -intVal;\n+        } else {\n+            intVal = (int) x;\n+\n+            if (intVal > 709) {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+\n+            intPartA = EXP_INT_TABLE_A[750+intVal];\n+            intPartB = EXP_INT_TABLE_B[750+intVal];\n+        }\n+\n+        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n+         * x and look up the exp function of it.\n+         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n+         */\n+        final int intFrac = (int) ((x - intVal) * 1024.0);\n+        final double fracPartA = EXP_FRAC_TABLE_A[intFrac];\n+        final double fracPartB = EXP_FRAC_TABLE_B[intFrac];\n+\n+        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n+         * has a value in the range 0 <= epsilon < 2^-10.\n+         * Do the subtraction from x as the last step to avoid possible loss of percison.\n+         */\n+        final double epsilon = x - (intVal + intFrac / 1024.0);\n+\n+        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n+       full double precision (52 bits).  Since z < 2^-10, we will have\n+       62 bits of precision when combined with the contant 1.  This will be\n+       used in the last addition below to get proper rounding. */\n+\n+        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n+       is less than 0.5 ULP */\n+        double z = 0.04168701738764507;\n+        z = z * epsilon + 0.1666666505023083;\n+        z = z * epsilon + 0.5000000000042687;\n+        z = z * epsilon + 1.0;\n+        z = z * epsilon + -3.940510424527919E-20;\n+\n+        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n+       expansion.\n+       tempA is exact since intPartA and intPartB only have 22 bits each.\n+       tempB will have 52 bits of precision.\n+         */\n+        double tempA = intPartA * fracPartA;\n+        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n+\n+        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n+       important.  For accuracy add by increasing size.  tempA is exact and\n+       much larger than the others.  If there are extra bits specified from the\n+       pow() function, use them. */\n+        final double tempC = tempB + tempA;\n+        final double result;\n+        if (extra != 0.0) {\n+            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n+        } else {\n+            result = tempC*z + tempB + tempA;\n+        }\n+\n+        if (hiPrec != null) {\n+            // If requesting high precision\n+            hiPrec[0] = tempA;\n+            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n+        }\n+\n+        return result;\n+    }\n+\n+    /** Compute exp(x) - 1\n+     * @param x number to compute shifted exponential\n+     * @return exp(x) - 1\n+     */\n+    public static double expm1(double x) {\n+        if (x != x || x == 0.0) { // NaN or zero\n+            return x;\n+        }\n+\n+        if (x <= -1.0 || x >= 1.0) {\n+            // If not between +/- 1.0\n+            //return exp(x) - 1.0;\n+            double hiPrec[] = new double[2];\n+            exp(x, 0.0, hiPrec);\n+            if (x > 0.0) {\n+                return -1.0 + hiPrec[0] + hiPrec[1];\n+            } else {\n+                final double ra = -1.0 + hiPrec[0];\n+                double rb = -(ra + 1.0 - hiPrec[0]);\n+                rb += hiPrec[1];\n+                return ra + rb;\n+            }\n+        }\n+\n+        double baseA;\n+        double baseB;\n+        double epsilon;\n+        boolean negative = false;\n+\n+        if (x < 0.0) {\n+            x = -x;\n+            negative = true;\n+        }\n+\n+        {\n+            int intFrac = (int) (x * 1024.0);\n+            double tempA = EXP_FRAC_TABLE_A[intFrac] - 1.0;\n+            double tempB = EXP_FRAC_TABLE_B[intFrac];\n+\n+            double temp = tempA + tempB;\n+            tempB = -(temp - tempA - tempB);\n+            tempA = temp;\n+\n+            temp = tempA * 1073741824.0;\n+            baseA = tempA + temp - temp;\n+            baseB = tempB + (tempA - baseA);\n+\n+            epsilon = x - intFrac/1024.0;\n+        }\n+\n+\n+        /* Compute expm1(epsilon) */\n+        double zb = 0.008336750013465571;\n+        zb = zb * epsilon + 0.041666663879186654;\n+        zb = zb * epsilon + 0.16666666666745392;\n+        zb = zb * epsilon + 0.49999999999999994;\n+        zb = zb * epsilon;\n+        zb = zb * epsilon;\n+\n+        double za = epsilon;\n+        double temp = za + zb;\n+        zb = -(temp - za - zb);\n+        za = temp;\n+\n+        temp = za * 1073741824.0;\n+        temp = za + temp - temp;\n+        zb += za - temp;\n+        za = temp;\n+\n+        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */\n+        double ya = za * baseA;\n+        //double yb = za*baseB + zb*baseA + zb*baseB;\n+        temp = ya + za * baseB;\n+        double yb = -(temp - ya - za * baseB);\n+        ya = temp;\n+\n+        temp = ya + zb * baseA;\n+        yb += -(temp - ya - zb * baseA);\n+        ya = temp;\n+\n+        temp = ya + zb * baseB;\n+        yb += -(temp - ya - zb*baseB);\n+        ya = temp;\n+\n+        //ya = ya + za + baseA;\n+        //yb = yb + zb + baseB;\n+        temp = ya + baseA;\n+        yb += -(temp - baseA - ya);\n+        ya = temp;\n+\n+        temp = ya + za;\n+        //yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);\n+        yb += -(temp - ya - za);\n+        ya = temp;\n+\n+        temp = ya + baseB;\n+        //yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);\n+        yb += -(temp - ya - baseB);\n+        ya = temp;\n+\n+        temp = ya + zb;\n+        //yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);\n+        yb += -(temp - ya - zb);\n+        ya = temp;\n+\n+        if (negative) {\n+            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n+            double denom = 1.0 + ya;\n+            double denomr = 1.0 / denom;\n+            double denomb = -(denom - 1.0 - ya) + yb;\n+            double ratio = ya * denomr;\n+            temp = ratio * 1073741824.0;\n+            final double ra = ratio + temp - temp;\n+            double rb = ratio - ra;\n+\n+            temp = denom * 1073741824.0;\n+            za = denom + temp - temp;\n+            zb = denom - za;\n+\n+            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n+\n+            // f(x) = x/1+x\n+            // Compute f'(x)\n+            // Product rule:  d(uv) = du*v + u*dv\n+            // Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))\n+            // d(1/x) = -1/(x*x)\n+            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))\n+            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))\n+\n+            // Adjust for yb\n+            rb += yb * denomr;                      // numerator\n+            rb += -ya * denomb * denomr * denomr;   // denominator\n+\n+            // negate\n+            ya = -ra;\n+            yb = -rb;\n+        }\n+\n+        return ya + yb;\n+    }\n+\n+    /**\n+     *  For x between 0 and 1, returns exp(x), uses extended precision\n+     *  @param x argument of exponential\n+     *  @param result placeholder where to place exp(x) split in two terms\n+     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n+     *  @return exp(x)\n+     */\n+    private static double slowexp(final double x, final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = 19; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0];\n+            ys[1] = as[1];\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0];\n+            ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /** Compute split[0], split[1] such that their sum is equal to d,\n+     * and split[0] has its 30 least significant bits as zero.\n+     * @param d number to split\n+     * @param split placeholder where to place the result\n+     */\n+    private static void split(final double d, final double split[]) {\n+        if (d < 8e298 && d > -8e298) {\n+            final double a = d * 1073741824.0;\n+            split[0] = (d + a) - a;\n+            split[1] = d - split[0];\n+        } else {\n+            final double a = d * 9.31322574615478515625E-10;\n+            split[0] = (d + a - d) * 1073741824.0;\n+            split[1] = d - split[0];\n+        }\n+    }\n+\n+    /** Recompute a split.\n+     * @param a input/out array containing the split, changed\n+     * on output\n+     */\n+    private static void resplit(final double a[]) {\n+        final double c = a[0] + a[1];\n+        final double d = -(c - a[0] - a[1]);\n+\n+        if (c < 8e298 && c > -8e298) {\n+            double z = c * 1073741824.0;\n+            a[0] = (c + z) - z;\n+            a[1] = c - a[0] + d;\n+        } else {\n+            double z = c * 9.31322574615478515625E-10;\n+            a[0] = (c + z - c) * 1073741824.0;\n+            a[1] = c - a[0] + d;\n+        }\n+    }\n+\n+    /** Multiply two numbers in split form.\n+     * @param a first term of multiplication\n+     * @param b second term of multiplication\n+     * @param ans placeholder where to put the result\n+     */\n+    private static void splitMult(double a[], double b[], double ans[]) {\n+        ans[0] = a[0] * b[0];\n+        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n+\n+        /* Resplit */\n+        resplit(ans);\n+    }\n+\n+    /** Add two numbers in split form.\n+     * @param a first term of addition\n+     * @param b second term of addition\n+     * @param ans placeholder where to put the result\n+     */\n+    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n+        ans[0] = a[0] + b[0];\n+        ans[1] = a[1] + b[1];\n+\n+        resplit(ans);\n+    }\n+\n+    /** Compute the reciprocal of in.  Use the following algorithm.\n+     *  in = c + d.\n+     *  want to find x + y such that x+y = 1/(c+d) and x is much\n+     *  larger than y and x has several zero bits on the right.\n+     *\n+     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n+     *  Use following identity to compute (a+b)/(c+d)\n+     *\n+     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n+     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n+     *  This will be close to the right answer, but there will be\n+     *  some rounding in the calculation of X.  So by carefully\n+     *  computing 1 - (c+d)(x+y) we can compute an error and\n+     *  add that back in.   This is done carefully so that terms\n+     *  of similar size are subtracted first.\n+     *  @param in initial number, in split form\n+     *  @param result placeholder where to put the result\n+     */\n+    private static void splitReciprocal(final double in[], final double result[]) {\n+        final double b = 1.0/4194304.0;\n+        final double a = 1.0 - b;\n+\n+        if (in[0] == 0.0) {\n+            in[0] = in[1];\n+            in[1] = 0.0;\n+        }\n+\n+        result[0] = a / in[0];\n+        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n+\n+        if (result[1] != result[1]) { // can happen if result[1] is NAN\n+            result[1] = 0.0;\n+        }\n+\n+        /* Resplit */\n+        resplit(result);\n+\n+        for (int i = 0; i < 2; i++) {\n+            /* this may be overkill, probably once is enough */\n+            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n+            result[1] * in[0] - result[1] * in[1];\n+            /*err = 1.0 - err; */\n+            err = err * (result[0] + result[1]);\n+            /*printf(\"err = %16e\\n\", err); */\n+            result[1] += err;\n+        }\n+    }\n+\n+    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n+     * @param a first term of the multiplication\n+     * @param b second term of the multiplication\n+     * @param result placeholder where to put the result\n+     */\n+    private static void quadMult(final double a[], final double b[], final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double zs[] = new double[2];\n+\n+        /* a[0] * b[0] */\n+        split(a[0], xs);\n+        split(b[0], ys);\n+        splitMult(xs, ys, zs);\n+\n+        result[0] = zs[0];\n+        result[1] = zs[1];\n+\n+        /* a[0] * b[1] */\n+        split(b[1], ys);\n+        splitMult(xs, ys, zs);\n+\n+        double tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+\n+        /* a[1] * b[0] */\n+        split(a[1], xs);\n+        split(b[0], ys);\n+        splitMult(xs, ys, zs);\n+\n+        tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+\n+        /* a[1] * b[0] */\n+        split(a[1], xs);\n+        split(b[1], ys);\n+        splitMult(xs, ys, zs);\n+\n+        tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+    }\n+\n+    /** Compute exp(p) for a integer p in extended precision.\n+     * @param p integer whose exponential is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * @return exp(p) in standard precision (equal to result[0] + result[1])\n+     */\n+    private static double expint(int p, final double result[]) {\n+        //double x = M_E;\n+        final double xs[] = new double[2];\n+        final double as[] = new double[2];\n+        final double ys[] = new double[2];\n+        //split(x, xs);\n+        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n+        //xs[0] = 2.71827697753906250000;\n+        //xs[1] = 4.85091998273542816811e-06;\n+        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n+        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n+\n+        /* E */\n+        xs[0] = 2.718281828459045;\n+        xs[1] = 1.4456468917292502E-16;\n+\n+        split(1.0, ys);\n+\n+        while (p > 0) {\n+            if ((p & 1) != 0) {\n+                quadMult(ys, xs, as);\n+                ys[0] = as[0]; ys[1] = as[1];\n+            }\n+\n+            quadMult(xs, xs, as);\n+            xs[0] = as[0]; xs[1] = as[1];\n+\n+            p >>= 1;\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+\n+            resplit(result);\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+\n+    /**\n+     * Natural logarithm.\n+     *\n+     * @param x   a double\n+     * @return log(x)\n+     */\n+    public static double log(final double x) {\n+        return log(x, null);\n+    }\n+\n+    /**\n+     * Internal helper method for natural logarithm function.\n+     * @param x original argument of the natural logarithm function\n+     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n+     * @return log(x)\n+     */\n+    private static double log(final double x, final double[] hiPrec) {\n+        long bits = Double.doubleToLongBits(x);\n+\n+        /* Handle special cases of negative input, and NaN */\n+        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n+            if (x != 0.0) {\n+                if (hiPrec != null) {\n+                    hiPrec[0] = Double.NaN;\n+                }\n+\n+                return Double.NaN;\n+            }\n+        }\n+\n+        /* Handle special cases of Positive infinity. */\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (hiPrec != null) {\n+                hiPrec[0] = Double.POSITIVE_INFINITY;\n+            }\n+\n+            return Double.POSITIVE_INFINITY;\n+        }\n+\n+        /* Extract the exponent */\n+        int exp = (int)(bits >> 52)-1023;\n+\n+        if ((bits & 0x7ff0000000000000L) == 0) {\n+            // Subnormal!\n+            if (x == 0) {\n+                // Zero\n+                if (hiPrec != null) {\n+                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n+                }\n+\n+                return Double.NEGATIVE_INFINITY;\n+            }\n+\n+            /* Normalize the subnormal number. */\n+            bits <<= 1;\n+            while ( (bits & 0x0010000000000000L) == 0) {\n+                exp--;\n+                bits <<= 1;\n+            }\n+        }\n+\n+\n+        if (exp == -1 || exp == 0) {\n+            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n+                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n+           polynomial expansion in higer precision. */\n+\n+               /* Compute x - 1.0 and split it */\n+                double xa = x - 1.0;\n+                double xb = xa - x + 1.0;\n+                double tmp = xa * 1073741824.0;\n+                double aa = xa + tmp - tmp;\n+                double ab = xa - aa;\n+                xa = aa;\n+                xb = ab;\n+\n+                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n+                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n+\n+                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n+                    /* Multiply a = y * x */\n+                    aa = ya * xa;\n+                    ab = ya * xb + yb * xa + yb * xb;\n+                    /* split, so now y = a */\n+                    tmp = aa * 1073741824.0;\n+                    ya = aa + tmp - tmp;\n+                    yb = aa - ya + ab;\n+\n+                    /* Add  a = y + lnQuickCoef */\n+                    aa = ya + LN_QUICK_COEF[i][0];\n+                    ab = yb + LN_QUICK_COEF[i][1];\n+                    /* Split y = a */\n+                    tmp = aa * 1073741824.0;\n+                    ya = aa + tmp - tmp;\n+                    yb = aa - ya + ab;\n+                }\n+\n+                /* Multiply a = y * x */\n+                aa = ya * xa;\n+                ab = ya * xb + yb * xa + yb * xb;\n+                /* split, so now y = a */\n+                tmp = aa * 1073741824.0;\n+                ya = aa + tmp - tmp;\n+                yb = aa - ya + ab;\n+\n+                if (hiPrec != null) {\n+                    hiPrec[0] = ya;\n+                    hiPrec[1] = yb;\n+                }\n+\n+                return ya + yb;\n+            }\n+        }\n+\n+        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n+        double lnm[] = LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n+\n+        /*\n+    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n+\n+    epsilon -= 1.0;\n+         */\n+\n+        // y is the most significant 10 bits of the mantissa\n+        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n+        //double epsilon = (x - y) / y;\n+        double epsilon = (double)(bits & 0x3ffffffffffL) / (4503599627370496.0 + (bits & 0x000ffc0000000000L));\n+\n+        double lnza = 0.0;\n+        double lnzb = 0.0;\n+\n+        if (hiPrec != null) {\n+            /* split epsilon -> x */\n+            double tmp = epsilon * 1073741824.0;\n+            double aa = epsilon + tmp - tmp;\n+            double ab = epsilon - aa;\n+            double xa = aa;\n+            double xb = ab;\n+\n+            /* Need a more accurate epsilon, so adjust the division. */\n+            double numer = (double)(bits & 0x3ffffffffffL);\n+            double denom = 4503599627370496.0 + (bits & 0x000ffc0000000000L);\n+            aa = numer - xa*denom - xb * denom;\n+            xb += aa / denom;\n+\n+            /* Remez polynomial evaluation */\n+            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n+            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n+\n+            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n+                /* Multiply a = y * x */\n+                aa = ya * xa;\n+                ab = ya * xb + yb * xa + yb * xb;\n+                /* split, so now y = a */\n+                tmp = aa * 1073741824.0;\n+                ya = aa + tmp - tmp;\n+                yb = aa - ya + ab;\n+\n+                /* Add  a = y + lnHiPrecCoef */\n+                aa = ya + LN_HI_PREC_COEF[i][0];\n+                ab = yb + LN_HI_PREC_COEF[i][1];\n+                /* Split y = a */\n+                tmp = aa * 1073741824.0;\n+                ya = aa + tmp - tmp;\n+                yb = aa - ya + ab;\n+            }\n+\n+            /* Multiply a = y * x */\n+            aa = ya * xa;\n+            ab = ya * xb + yb * xa + yb * xb;\n+\n+            /* split, so now lnz = a */\n+            /*\n+      tmp = aa * 1073741824.0;\n+      lnza = aa + tmp - tmp;\n+      lnzb = aa - lnza + ab;\n+             */\n+            lnza = aa + ab;\n+            lnzb = -(lnza - aa - ab);\n+        } else {\n+            /* High precision not required.  Eval Remez polynomial\n+         using standard double precision */\n+            lnza = -0.16624882440418567;\n+            lnza = lnza * epsilon + 0.19999954120254515;\n+            lnza = lnza * epsilon + -0.2499999997677497;\n+            lnza = lnza * epsilon + 0.3333333333332802;\n+            lnza = lnza * epsilon + -0.5;\n+            lnza = lnza * epsilon + 1.0;\n+            lnza = lnza * epsilon;\n+        }\n+\n+        /* Relative sizes:\n+         * lnzb     [0, 2.33E-10]\n+         * lnm[1]   [0, 1.17E-7]\n+         * ln2B*exp [0, 1.12E-4]\n+         * lnza      [0, 9.7E-4]\n+         * lnm[0]   [0, 0.692]\n+         * ln2A*exp [0, 709]\n+         */\n+\n+        /* Compute the following sum:\n+         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n+         */\n+\n+        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n+        double a = LN_2_A*exp;\n+        double b = 0.0;\n+        double c = a+lnm[0];\n+        double d = -(c-a-lnm[0]);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + lnza;\n+        d = -(c - a - lnza);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + LN_2_B*exp;\n+        d = -(c - a - LN_2_B*exp);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + lnm[1];\n+        d = -(c - a - lnm[1]);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + lnzb;\n+        d = -(c - a - lnzb);\n+        a = c;\n+        b = b + d;\n+\n+        if (hiPrec != null) {\n+            hiPrec[0] = a;\n+            hiPrec[1] = b;\n+        }\n+\n+        return a + b;\n+    }\n+\n+    /** Compute log(1 + x).\n+     * @param x a number\n+     * @return log(1 + x)\n+     */\n+    public static double log1p(final double x) {\n+        double xpa = 1.0 + x;\n+        double xpb = -(xpa - 1.0 - x);\n+\n+        if (x>1e-6 || x<-1e-6) {\n+            double hiPrec[] = new double[2];\n+\n+            log(xpa, hiPrec);\n+\n+            /* Do a taylor series expansion around xpa */\n+            /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */\n+            double fx1 = xpb/xpa;\n+\n+            double epsilon = 0.5 * fx1 + 1.0;\n+            epsilon = epsilon * fx1;\n+\n+            return epsilon + hiPrec[1] + hiPrec[0];\n+        }\n+\n+        /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */\n+        double y = x * 0.333333333333333 - 0.5;\n+        y = y * x + 1.0;\n+        y = y * x;\n+\n+        return y;\n+    }\n+\n+    /** Compute the base 10 logarithm.\n+     * @param x a number\n+     * @return log10(x)\n+     */\n+    public static double log10(final double x) {\n+        final double hiPrec[] = new double[2];\n+\n+        log(x, hiPrec);\n+\n+        final double tmp = hiPrec[0] * 1073741824.0;\n+        final double lna = hiPrec[0] + tmp - tmp;\n+        final double lnb = hiPrec[0] - lna + hiPrec[1];\n+\n+        final double rln10a = 0.4342944622039795;\n+        final double rln10b = 1.9699272335463627E-8;\n+\n+        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n+    }\n+\n+    /**\n+     * Power function.  Compute x^y.\n+     *\n+     * @param x   a double\n+     * @param y   a double\n+     * @return double\n+     */\n+    public static double pow(double x, double y) {\n+        final double lns[] = new double[2];\n+\n+        if (y == 0.0) {\n+            return 1.0;\n+        }\n+\n+        /* Handle special case x<0 */\n+        if (x < 0) {\n+            if (y == (long) y) {\n+                // If y is an integer\n+                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n+            } else {\n+                return Double.NaN;\n+            }\n+        }\n+\n+        if (x == 0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if ((bits & 0x8000000000000000L) != 0) {\n+                // -zero\n+                if (y < 0 && y == (long)y)\n+                    return Double.NEGATIVE_INFINITY;\n+            }\n+\n+            if (y < 0) {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+            if (y > 0) {\n+                return 0.0;\n+            }\n+\n+            return Double.NaN;\n+        }\n+\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (y < 0.0) {\n+                return 0.0;\n+            } else {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n+\n+        if (y == Double.POSITIVE_INFINITY) {\n+            if (x * x > 1.0) {\n+                return Double.POSITIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n+\n+        if (y == Double.NEGATIVE_INFINITY) {\n+            if (x*x < 1.0) {\n+                return Double.NEGATIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n+\n+        /* Split y into ya and yb such that y = ya+yb */\n+        double tmp1 = y * 1073741824.0;\n+        final double ya = y + tmp1 - tmp1;\n+        final double yb = y - ya;\n+\n+        /* Compute ln(x) */\n+        log(x, lns);\n+        double lna = lns[0];\n+        double lnb = lns[1];\n+\n+        /* resplit lns */\n+        tmp1 = lna * 1073741824.0;\n+        final double tmp2 = lna + tmp1 - tmp1;\n+        lnb += lna - tmp2;\n+        lna = tmp2;\n+\n+        // y*ln(x) = (aa+ab)\n+        final double aa = lna * ya;\n+        final double ab = lna * yb + lnb * ya + lnb * yb;\n+\n+        lna = aa+ab;\n+        lnb = -(lna - aa - ab);\n+\n+        double z = 1.0 / 120.0;\n+        z = z * lnb + (1.0 / 24.0);\n+        z = z * lnb + (1.0 / 6.0);\n+        z = z * lnb + 0.5;\n+        z = z * lnb + 1.0;\n+        z = z * lnb;\n+\n+        final double result = exp(lna, z, null);\n+        //result = result + result * z;\n+        return result;\n+    }\n+\n+    /** xi in the range of [1, 2].\n+     *                                3        5        7\n+     *      x+1           /          x        x        x          \\\n+     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n+     *      1-x           \\          3        5        7          /\n+     *\n+     * So, compute a Remez approximation of the following function\n+     *\n+     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n+     *\n+     * This will be an even function with only positive coefficents.\n+     * x is in the range [0 - 1/3].\n+     *\n+     * Transform xi for input to the above function by setting\n+     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n+     * the result is multiplied by x.\n+     * @param xi number from which log is requested\n+     * @return log(xi)\n+     */\n+    private static double[] slowLog(double xi) {\n+        double x[] = new double[2];\n+        double x2[] = new double[2];\n+        double y[] = new double[2];\n+        double a[] = new double[2];\n+\n+        split(xi, x);\n+\n+        /* Set X = (x-1)/(x+1) */\n+        x[0] += 1.0;\n+        resplit(x);\n+        splitReciprocal(x, a);\n+        x[0] -= 2.0;\n+        resplit(x);\n+        splitMult(x, a, y);\n+        x[0] = y[0];\n+        x[1] = y[1];\n+\n+        /* Square X -> X2*/\n+        splitMult(x, x, x2);\n+\n+\n+        //x[0] -= 1.0;\n+        //resplit(x);\n+\n+        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n+        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n+\n+        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n+            splitMult(y, x2, a);\n+            y[0] = a[0];\n+            y[1] = a[1];\n+            splitAdd(y, LN_SPLIT_COEF[i], a);\n+            y[0] = a[0];\n+            y[1] = a[1];\n+        }\n+\n+        splitMult(y, x, a);\n+        y[0] = a[0];\n+        y[1] = a[1];\n+\n+        return y;\n+    }\n+\n+    /**\n+     * For x between 0 and pi/4 compute sine.\n+     * @param x number from which sine is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * @return sin(x)\n+     */\n+    private static double slowSin(final double x, final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = 19; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+\n+            if ( (i & 1) == 0) {\n+                continue;\n+            }\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            if ( (i & 2) != 0 ) {\n+                facts[0] = -facts[0];\n+                facts[1] = -facts[1];\n+            }\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /**\n+     *  For x between 0 and pi/4 compute cosine\n+     * @param x number from which cosine is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * @return cos(x)\n+     */\n+    private static double slowCos(final double x, final double result[]) {\n+\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = 19; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+\n+            if ( (i & 1) != 0) {\n+                continue;\n+            }\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            if ( (i & 2) != 0 ) {\n+                facts[0] = -facts[0];\n+                facts[1] = -facts[1];\n+            }\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /** Build the sine and cosine tables.\n+     */\n+    private static void buildSinCosTables() {\n+        final double result[] = new double[2];\n+\n+        /* Use taylor series for 0 <= x <= 6/8 */\n+        for (int i = 0; i < 7; i++) {\n+            double x = i / 8.0;\n+\n+            slowSin(x, result);\n+            SINE_TABLE_A[i] = result[0];\n+            SINE_TABLE_B[i] = result[1];\n+\n+            slowCos(x, result);\n+            COSINE_TABLE_A[i] = result[0];\n+            COSINE_TABLE_B[i] = result[1];\n+        }\n+\n+        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n+        for (int i = 7; i < 14; i++) {\n+            double xs[] = new double[2];\n+            double ys[] = new double[2];\n+            double as[] = new double[2];\n+            double bs[] = new double[2];\n+            double temps[] = new double[2];\n+\n+            if ( (i & 1) == 0) {\n+                // Even, use double angle\n+                xs[0] = SINE_TABLE_A[i/2];\n+                xs[1] = SINE_TABLE_B[i/2];\n+                ys[0] = COSINE_TABLE_A[i/2];\n+                ys[1] = COSINE_TABLE_B[i/2];\n+\n+                /* compute sine */\n+                splitMult(xs, ys, result);\n+                SINE_TABLE_A[i] = result[0] * 2.0;\n+                SINE_TABLE_B[i] = result[1] * 2.0;\n+\n+                /* Compute cosine */\n+                splitMult(ys, ys, as);\n+                splitMult(xs, xs, temps);\n+                temps[0] = -temps[0];\n+                temps[1] = -temps[1];\n+                splitAdd(as, temps, result);\n+                COSINE_TABLE_A[i] = result[0];\n+                COSINE_TABLE_B[i] = result[1];\n+            } else {\n+                xs[0] = SINE_TABLE_A[i/2];\n+                xs[1] = SINE_TABLE_B[i/2];\n+                ys[0] = COSINE_TABLE_A[i/2];\n+                ys[1] = COSINE_TABLE_B[i/2];\n+                as[0] = SINE_TABLE_A[i/2+1];\n+                as[1] = SINE_TABLE_B[i/2+1];\n+                bs[0] = COSINE_TABLE_A[i/2+1];\n+                bs[1] = COSINE_TABLE_B[i/2+1];\n+\n+                /* compute sine */\n+                splitMult(xs, bs, temps);\n+                splitMult(ys, as, result);\n+                splitAdd(result, temps, result);\n+                SINE_TABLE_A[i] = result[0];\n+                SINE_TABLE_B[i] = result[1];\n+\n+                /* Compute cosine */\n+                splitMult(ys, bs, result);\n+                splitMult(xs, as, temps);\n+                temps[0] = -temps[0];\n+                temps[1] = -temps[1];\n+                splitAdd(result, temps, result);\n+                COSINE_TABLE_A[i] = result[0];\n+                COSINE_TABLE_B[i] = result[1];\n+            }\n+        }\n+\n+        /* Compute tangent = sine/cosine */\n+        for (int i = 0; i < 14; i++) {\n+            double xs[] = new double[2];\n+            double ys[] = new double[2];\n+            double as[] = new double[2];\n+\n+            as[0] = COSINE_TABLE_A[i];\n+            as[1] = COSINE_TABLE_B[i];\n+\n+            splitReciprocal(as, ys);\n+\n+            xs[0] = SINE_TABLE_A[i];\n+            xs[1] = SINE_TABLE_B[i];\n+\n+            splitMult(xs, ys, as);\n+\n+            TANGENT_TABLE_A[i] = as[0];\n+            TANGENT_TABLE_B[i] = as[1];\n+        }\n+\n+    }\n+\n+    /**\n+     *  Computes sin(x) - x, where |x| < 1/16.\n+     *  Use a Remez polynomial approximation.\n+     *  @param x a number smaller than 1/16\n+     *  @return sin(x) - x\n+     */\n+    private static double polySine(final double x)\n+    {\n+        double x2 = x*x;\n+\n+        double p = 2.7553817452272217E-6;\n+        p = p * x2 + -1.9841269659586505E-4;\n+        p = p * x2 + 0.008333333333329196;\n+        p = p * x2 + -0.16666666666666666;\n+        //p *= x2;\n+        //p *= x;\n+        p = p * x2 * x;\n+\n+        return p;\n+    }\n+\n+    /**\n+     *  Computes cos(x) - 1, where |x| < 1/16.\n+     *  Use a Remez polynomial approximation.\n+     *  @param x a number smaller than 1/16\n+     *  @return cos(x) - 1\n+     */\n+    private static double polyCosine(double x) {\n+        double x2 = x*x;\n+\n+        double p = 2.479773539153719E-5;\n+        p = p * x2 + -0.0013888888689039883;\n+        p = p * x2 + 0.041666666666621166;\n+        p = p * x2 + -0.49999999999999994;\n+        p *= x2;\n+\n+        return p;\n+    }\n+\n+    /**\n+     *  Compute sine over the first quadrant (0 < x < pi/2).\n+     *  Use combination of table lookup and rational polynomial expansion.\n+     *  @param xa number from which sine is requested\n+     *  @param xb extra bits for x (may be 0.0)\n+     *  @return sin(xa + xb)\n+     */\n+    private static double sinQ(double xa, double xb) {\n+        int idx = (int) ((xa * 8.0) + 0.5);\n+        final double epsilon = xa - EIGHTHES[idx]; //idx*0.125;\n+\n+        // Table lookups\n+        final double sintA = SINE_TABLE_A[idx];\n+        final double sintB = SINE_TABLE_B[idx];\n+        final double costA = COSINE_TABLE_A[idx];\n+        final double costB = COSINE_TABLE_B[idx];\n+\n+        // Polynomial eval of sin(epsilon), cos(epsilon)\n+        double sinEpsA = epsilon;\n+        double sinEpsB = polySine(epsilon);\n+        final double cosEpsA = 1.0;\n+        final double cosEpsB = polyCosine(epsilon);\n+\n+        // Split epsilon   xa + xb = x\n+        final double temp = sinEpsA * 1073741824.0;\n+        double temp2 = (sinEpsA + temp) - temp;\n+        sinEpsB +=  sinEpsA - temp2;\n+        sinEpsA = temp2;\n+\n+        /* Compute sin(x) by angle addition formula */\n+        double result;\n+\n+        /* Compute the following sum:\n+         *\n+         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+         *\n+         * Ranges of elements\n+         *\n+         * xxxtA   0            PI/2\n+         * xxxtB   -1.5e-9      1.5e-9\n+         * sinEpsA -0.0625      0.0625\n+         * sinEpsB -6e-11       6e-11\n+         * cosEpsA  1.0\n+         * cosEpsB  0           -0.0625\n+         *\n+         */\n+\n+        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+\n+        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n+        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n+        double a = 0;\n+        double b = 0;\n+\n+        double t = sintA;\n+        double c = a + t;\n+        double d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        t = costA * sinEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        b = b + sintA * cosEpsB + costA * sinEpsB;\n+        /*\n+    t = sintA*cosEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = costA*sinEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+         */\n+\n+        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n+        /*\n+    t = sintB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = costB*sinEpsA;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = sintB*cosEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = costB*sinEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+         */\n+\n+        if (xb != 0.0) {\n+            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n+                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n+            c = a + t;\n+            d = -(c - a - t);\n+            a = c;\n+            b = b + d;\n+        }\n+\n+        result = a + b;\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Compute cosine in the first quadrant by subtracting input from PI/2 and\n+     * then calling sinQ.  This is more accurate as the input approaches PI/2.\n+     *  @param xa number from which cosine is requested\n+     *  @param xb extra bits for x (may be 0.0)\n+     *  @return cos(xa + xb)\n+     */\n+    private static double cosQ(double xa, double xb) {\n+        final double pi2a = 1.5707963267948966;\n+        final double pi2b = 6.123233995736766E-17;\n+\n+        final double a = pi2a - xa;\n+        double b = -(a - pi2a + xa);\n+        b += pi2b - xb;\n+\n+        return sinQ(a, b);\n+    }\n+\n+    /**\n+     *  Compute tangent (or cotangent) over the first quadrant.   0 < x < pi/2\n+     *  Use combination of table lookup and rational polynomial expansion.\n+     *  @param xa number from which sine is requested\n+     *  @param xb extra bits for x (may be 0.0)\n+     *  @param cotanFlag if true, compute the cotangent instead of the tangent\n+     *  @return tan(xa+xb) (or cotangent, depending on cotanFlag)\n+     */\n+    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n+\n+        int idx = (int) ((xa * 8.0) + 0.5);\n+        final double epsilon = xa - EIGHTHES[idx]; //idx*0.125;\n+\n+        // Table lookups\n+        final double sintA = SINE_TABLE_A[idx];\n+        final double sintB = SINE_TABLE_B[idx];\n+        final double costA = COSINE_TABLE_A[idx];\n+        final double costB = COSINE_TABLE_B[idx];\n+\n+        // Polynomial eval of sin(epsilon), cos(epsilon)\n+        double sinEpsA = epsilon;\n+        double sinEpsB = polySine(epsilon);\n+        final double cosEpsA = 1.0;\n+        final double cosEpsB = polyCosine(epsilon);\n+\n+        // Split epsilon   xa + xb = x\n+        double temp = sinEpsA * 1073741824.0;\n+        double temp2 = (sinEpsA + temp) - temp;\n+        sinEpsB +=  sinEpsA - temp2;\n+        sinEpsA = temp2;\n+\n+        /* Compute sin(x) by angle addition formula */\n+\n+        /* Compute the following sum:\n+         *\n+         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+         *\n+         * Ranges of elements\n+         *\n+         * xxxtA   0            PI/2\n+         * xxxtB   -1.5e-9      1.5e-9\n+         * sinEpsA -0.0625      0.0625\n+         * sinEpsB -6e-11       6e-11\n+         * cosEpsA  1.0\n+         * cosEpsB  0           -0.0625\n+         *\n+         */\n+\n+        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+\n+        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n+        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n+        double a = 0;\n+        double b = 0;\n+\n+        // Compute sine\n+        double t = sintA;\n+        double c = a + t;\n+        double d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        t = costA*sinEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        b = b + sintA*cosEpsB + costA*sinEpsB;\n+        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+\n+        double sina = a + b;\n+        double sinb = -(sina - a - b);\n+\n+        // Compute cosine\n+\n+        a = b = c = d = 0.0;\n+\n+        t = costA*cosEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        t = -sintA*sinEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n+        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n+\n+        double cosa = a + b;\n+        double cosb = -(cosa - a - b);\n+\n+        if (cotanFlag) {\n+            double tmp;\n+            tmp = cosa; cosa = sina; sina = tmp;\n+            tmp = cosb; cosb = sinb; sinb = tmp;\n+        }\n+\n+\n+        /* estimate and correct, compute 1.0/(cosa+cosb) */\n+        /*\n+    double est = (sina+sinb)/(cosa+cosb);\n+    double err = (sina - cosa*est) + (sinb - cosb*est);\n+    est += err/(cosa+cosb);\n+    err = (sina - cosa*est) + (sinb - cosb*est);\n+         */\n+\n+        // f(x) = 1/x,   f'(x) = -1/x^2\n+\n+        double est = sina/cosa;\n+\n+        /* Split the estimate to get more accurate read on division rounding */\n+        temp = est * 1073741824.0;\n+        double esta = (est + temp) - temp;\n+        double estb =  est - esta;\n+\n+        temp = cosa * 1073741824.0;\n+        double cosaa = (cosa + temp) - temp;\n+        double cosab =  cosa - cosaa;\n+\n+        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n+        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n+        err += sinb/cosa;                     // Change in est due to sinb\n+        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n+\n+        if (xb != 0.0) {\n+            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n+            // Approximate impact of xb\n+            double xbadj = xb + est*est*xb;\n+            if (cotanFlag) {\n+                xbadj = -xbadj;\n+            }\n+\n+            err += xbadj;\n+        }\n+\n+        return est+err;\n+    }\n+\n+    /** Reduce the input argument using the Payne and Hanek method.\n+     *  This is good for all inputs 0.0 < x < inf\n+     *  Output is remainder after dividing by PI/2\n+     *  The result array should contain 3 numbers.\n+     *  result[0] is the integer portion, so mod 4 this gives the quadrant.\n+     *  result[1] is the upper bits of the remainder\n+     *  result[2] is the lower bits of the remainder\n+     *\n+     * @param x number to reduce\n+     * @param result placeholder where to put the result\n+     */\n+    private static void reducePayneHanek(double x, double result[])\n+    {\n+        /* Convert input double to bits */\n+        long inbits = Double.doubleToLongBits(x);\n+        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n+\n+        /* Convert to fixed point representation */\n+        inbits &= 0x000fffffffffffffL;\n+        inbits |= 0x0010000000000000L;\n+\n+        /* Normalize input to be between 0.5 and 1.0 */\n+        exponent++;\n+        inbits <<= 11;\n+\n+        /* Based on the exponent, get a shifted copy of recip2pi */\n+        long shpi0;\n+        long shpiA;\n+        long shpiB;\n+        int idx = exponent >> 6;\n+        int shift = exponent - (idx << 6);\n+\n+        if (shift != 0) {\n+            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n+            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n+            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n+            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n+        } else {\n+            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n+            shpiA = RECIP_2PI[idx];\n+            shpiB = RECIP_2PI[idx+1];\n+        }\n+\n+        /* Multiply input by shpiA */\n+        long a = inbits >>> 32;\n+        long b = inbits & 0xffffffffL;\n+\n+        long c = shpiA >>> 32;\n+        long d = shpiA & 0xffffffffL;\n+\n+        long ac = a * c;\n+        long bd = b * d;\n+        long bc = b * c;\n+        long ad = a * d;\n+\n+        long prodB = bd + (ad << 32);\n+        long prodA = ac + (ad >>> 32);\n+\n+        boolean bita = (bd & 0x8000000000000000L) != 0;\n+        boolean bitb = (ad & 0x80000000L ) != 0;\n+        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prodA++;\n+        }\n+\n+        bita = (prodB & 0x8000000000000000L) != 0;\n+        bitb = (bc & 0x80000000L ) != 0;\n+\n+        prodB = prodB + (bc << 32);\n+        prodA = prodA + (bc >>> 32);\n+\n+        bitsum = (prodB & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prodA++;\n+        }\n+\n+        /* Multiply input by shpiB */\n+        c = shpiB >>> 32;\n+        d = shpiB & 0xffffffffL;\n+        ac = a * c;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        /* Collect terms */\n+        ac = ac + ((bc + ad) >>> 32);\n+\n+        bita = (prodB & 0x8000000000000000L) != 0;\n+        bitb = (ac & 0x8000000000000000L ) != 0;\n+        prodB += ac;\n+        bitsum = (prodB & 0x8000000000000000L) != 0;\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prodA++;\n+        }\n+\n+        /* Multiply by shpi0 */\n+        c = shpi0 >>> 32;\n+        d = shpi0 & 0xffffffffL;\n+\n+        bd = b * d;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        prodA += bd + ((bc + ad) << 32);\n+\n+        /*\n+         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n+         * PI/2, so use the following steps:\n+         * 1.) multiply by 4.\n+         * 2.) do a fixed point muliply by PI/4.\n+         * 3.) Convert to floating point.\n+         * 4.) Multiply by 2\n+         */\n+\n+        /* This identifies the quadrant */\n+        int intPart = (int)(prodA >>> 62);\n+\n+        /* Multiply by 4 */\n+        prodA <<= 2;\n+        prodA |= prodB >>> 62;\n+        prodB <<= 2;\n+\n+        /* Multiply by PI/4 */\n+        a = prodA >>> 32;\n+        b = prodA & 0xffffffffL;\n+\n+        c = PI_O_4_BITS[0] >>> 32;\n+        d = PI_O_4_BITS[0] & 0xffffffffL;\n+\n+        ac = a * c;\n+        bd = b * d;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        long prod2B = bd + (ad << 32);\n+        long prod2A = ac + (ad >>> 32);\n+\n+        bita = (bd & 0x8000000000000000L) != 0;\n+        bitb = (ad & 0x80000000L ) != 0;\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        bita = (prod2B & 0x8000000000000000L) != 0;\n+        bitb = (bc & 0x80000000L ) != 0;\n+\n+        prod2B = prod2B + (bc << 32);\n+        prod2A = prod2A + (bc >>> 32);\n+\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        /* Multiply input by pio4bits[1] */\n+        c = PI_O_4_BITS[1] >>> 32;\n+        d = PI_O_4_BITS[1] & 0xffffffffL;\n+        ac = a * c;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        /* Collect terms */\n+        ac = ac + ((bc + ad) >>> 32);\n+\n+        bita = (prod2B & 0x8000000000000000L) != 0;\n+        bitb = (ac & 0x8000000000000000L ) != 0;\n+        prod2B += ac;\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        /* Multiply inputB by pio4bits[0] */\n+        a = prodB >>> 32;\n+        b = prodB & 0xffffffffL;\n+        c = PI_O_4_BITS[0] >>> 32;\n+        d = PI_O_4_BITS[0] & 0xffffffffL;\n+        ac = a * c;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        /* Collect terms */\n+        ac = ac + ((bc + ad) >>> 32);\n+\n+        bita = (prod2B & 0x8000000000000000L) != 0;\n+        bitb = (ac & 0x8000000000000000L ) != 0;\n+        prod2B += ac;\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        /* Convert to double */\n+        double tmpA = (prod2A >>> 12) / 4503599627370496.0;  // High order 52 bits\n+        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / 4503599627370496.0 / 4503599627370496.0; // Low bits\n+\n+        double sumA = tmpA + tmpB;\n+        double sumB = -(sumA - tmpA - tmpB);\n+\n+        /* Multiply by PI/2 and return */\n+        result[0] = intPart;\n+        result[1] = sumA * 2.0;\n+        result[2] = sumB * 2.0;\n+    }\n+\n+    /**\n+     *  Sine function.\n+     *  @param x a number\n+     *  @return sin(x)\n+     */\n+    public static double sin(double x) {\n+        boolean negative = false;\n+        int quadrant = 0;\n+        double xa;\n+        double xb = 0.0;\n+\n+        /* Take absolute value of the input */\n+        xa = x;\n+        if (x < 0) {\n+            negative = true;\n+            xa = -xa;\n+        }\n+\n+        /* Check for zero and negative zero */\n+        if (xa == 0.0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if (bits < 0) {\n+                return -0.0;\n+            }\n+            return 0.0;\n+        }\n+\n+        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n+            return Double.NaN;\n+        }\n+\n+        /* Perform any argument reduction */\n+        if (xa > 3294198.0) {\n+            // PI * (2**20)\n+            // Argument too big for CodyWaite reduction.  Must use\n+            // PayneHanek.\n+            double reduceResults[] = new double[3];\n+            reducePayneHanek(xa, reduceResults);\n+            quadrant = ((int) reduceResults[0]) & 3;\n+            xa = reduceResults[1];\n+            xb = reduceResults[2];\n+        } else if (xa > 1.5707963267948966) {\n+            /* Inline the Cody/Waite reduction for performance */\n+\n+            // Estimate k\n+            //k = (int)(xa / 1.5707963267948966);\n+            int k = (int)(xa * 0.6366197723675814);\n+\n+            // Compute remainder\n+            double remA;\n+            double remB;\n+            while (true) {\n+                double a = -k * 1.570796251296997;\n+                remA = xa + a;\n+                remB = -(remA - xa - a);\n+\n+                a = -k * 7.549789948768648E-8;\n+                double b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                a = -k * 6.123233995736766E-17;\n+                b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                if (remA > 0.0)\n+                    break;\n+\n+                // Remainder is negative, so decrement k and try again.\n+                // This should only happen if the input is very close\n+                // to an even multiple of pi/2\n+                k--;\n+            }\n+            quadrant = k & 3;\n+            xa = remA;\n+            xb = remB;\n+        }\n+\n+        if (negative) {\n+            quadrant ^= 2;  // Flip bit 1\n+        }\n+\n+        switch (quadrant) {\n+            case 0:\n+                return sinQ(xa, xb);\n+            case 1:\n+                return cosQ(xa, xb);\n+            case 2:\n+                return -sinQ(xa, xb);\n+            case 3:\n+                return -cosQ(xa, xb);\n+            default:\n+                return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     *  Cosine function\n+     *  @param x a number\n+     *  @return cos(x)\n+     */\n+    public static double cos(double x) {\n+        int quadrant = 0;\n+\n+        /* Take absolute value of the input */\n+        double xa = x;\n+        if (x < 0) {\n+            xa = -xa;\n+        }\n+\n+        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n+            return Double.NaN;\n+        }\n+\n+        /* Perform any argument reduction */\n+        double xb = 0;\n+        if (xa > 3294198.0) {\n+            // PI * (2**20)\n+            // Argument too big for CodyWaite reduction.  Must use\n+            // PayneHanek.\n+            double reduceResults[] = new double[3];\n+            reducePayneHanek(xa, reduceResults);\n+            quadrant = ((int) reduceResults[0]) & 3;\n+            xa = reduceResults[1];\n+            xb = reduceResults[2];\n+        } else if (xa > 1.5707963267948966) {\n+            /* Inline the Cody/Waite reduction for performance */\n+\n+            // Estimate k\n+            //k = (int)(xa / 1.5707963267948966);\n+            int k = (int)(xa * 0.6366197723675814);\n+\n+            // Compute remainder\n+            double remA;\n+            double remB;\n+            while (true) {\n+                double a = -k * 1.570796251296997;\n+                remA = xa + a;\n+                remB = -(remA - xa - a);\n+\n+                a = -k * 7.549789948768648E-8;\n+                double b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                a = -k * 6.123233995736766E-17;\n+                b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                if (remA > 0.0)\n+                    break;\n+\n+                // Remainder is negative, so decrement k and try again.\n+                // This should only happen if the input is very close\n+                // to an even multiple of pi/2\n+                k--;\n+            }\n+            quadrant = k & 3;\n+            xa = remA;\n+            xb = remB;\n+        }\n+\n+        //if (negative)\n+        //  quadrant = (quadrant + 2) % 4;\n+\n+        switch (quadrant) {\n+            case 0:\n+                return cosQ(xa, xb);\n+            case 1:\n+                return -sinQ(xa, xb);\n+            case 2:\n+                return -cosQ(xa, xb);\n+            case 3:\n+                return sinQ(xa, xb);\n+            default:\n+                return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     *   Tangent function\n+     *  @param x a number\n+     *  @return tan(x)\n+     */\n+    public static double tan(double x) {\n+        boolean negative = false;\n+        int quadrant = 0;\n+\n+        /* Take absolute value of the input */\n+        double xa = x;\n+        if (x < 0) {\n+            negative = true;\n+            xa = -xa;\n+        }\n+\n+        /* Check for zero and negative zero */\n+        if (xa == 0.0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if (bits < 0) {\n+                return -0.0;\n+            }\n+            return 0.0;\n+        }\n+\n+        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n+            return Double.NaN;\n+        }\n+\n+        /* Perform any argument reduction */\n+        double xb = 0;\n+        if (xa > 3294198.0) {\n+            // PI * (2**20)\n+            // Argument too big for CodyWaite reduction.  Must use\n+            // PayneHanek.\n+            double reduceResults[] = new double[3];\n+            reducePayneHanek(xa, reduceResults);\n+            quadrant = ((int) reduceResults[0]) & 3;\n+            xa = reduceResults[1];\n+            xb = reduceResults[2];\n+        } else if (xa > 1.5707963267948966) {\n+            /* Inline the Cody/Waite reduction for performance */\n+\n+            // Estimate k\n+            //k = (int)(xa / 1.5707963267948966);\n+            int k = (int)(xa * 0.6366197723675814);\n+\n+            // Compute remainder\n+            double remA;\n+            double remB;\n+            while (true) {\n+                double a = -k * 1.570796251296997;\n+                remA = xa + a;\n+                remB = -(remA - xa - a);\n+\n+                a = -k * 7.549789948768648E-8;\n+                double b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                a = -k * 6.123233995736766E-17;\n+                b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                if (remA > 0.0)\n+                    break;\n+\n+                // Remainder is negative, so decrement k and try again.\n+                // This should only happen if the input is very close\n+                // to an even multiple of pi/2\n+                k--;\n+            }\n+            quadrant = k & 3;\n+            xa = remA;\n+            xb = remB;\n+        }\n+\n+        if (xa > 1.5) {\n+            // Accurracy suffers between 1.5 and PI/2\n+            final double pi2a = 1.5707963267948966;\n+            final double pi2b = 6.123233995736766E-17;\n+\n+            final double a = pi2a - xa;\n+            double b = -(a - pi2a + xa);\n+            b += pi2b - xb;\n+\n+            xa = a;\n+            xb = b;\n+            quadrant ^= 1;\n+            negative ^= true;\n+        }\n+\n+        double result;\n+        if ((quadrant & 1) == 0) {\n+            result = tanQ(xa, xb, false);\n+        } else {\n+            result = -tanQ(xa, xb, true);\n+        }\n+\n+        if (negative) {\n+            result = -result;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Arctangent function\n+     *  @param x a number\n+     *  @return atan(x)\n+     */\n+    public static double atan(double x) {\n+        return atan(x, 0.0, false);\n+    }\n+\n+    /** Internal helper function to compute arctangent.\n+     * @param xa number from which arctangent is requested\n+     * @param xb extra bits for x (may be 0.0)\n+     * @param leftPlane if true, result angle must be put in the left half plane\n+     * @return atan(xa + xb) (or angle shifted by &pi; if leftPlane is true)\n+     */\n+    private static double atan(double xa, double xb, boolean leftPlane) {\n+        boolean negate = false;\n+        boolean recip = false;\n+        int idx;\n+\n+        if (xa < 0) {\n+            // negative\n+            xa = -xa;\n+            xb = -xb;\n+            negate = true;\n+        }\n+\n+        if (xa > 1.633123935319537E16) { // Very large input\n+            return (negate ^ leftPlane) ? (-Math.PI/2.0) : (Math.PI/2.0);\n+        }\n+\n+        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\n+        if (xa < 1.0) {\n+            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n+        } else {\n+            double temp = 1.0/xa;\n+            idx = (int) (-((-1.7168146928204136 * temp * temp + 8.0) * temp) + 13.07);\n+        }\n+        double epsA = xa - TANGENT_TABLE_A[idx];\n+        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n+        epsB += xb - TANGENT_TABLE_B[idx];\n+\n+        double temp = epsA + epsB;\n+        epsB = -(temp - epsA - epsB);\n+        epsA = temp;\n+\n+        /* Compute eps = eps / (1.0 + xa*tangent) */\n+        temp = xa * 1073741824.0;\n+        double ya = xa + temp - temp;\n+        double yb = xb + xa - ya;\n+        xa = ya;\n+        xb += yb;\n+\n+        //if (idx > 8 || idx == 0)\n+        if (idx == 0) {\n+            /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n+            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n+            double denom = 1.0 / (1.0 + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n+            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\n+            ya = epsA * denom;\n+            yb = epsB * denom;\n+        } else {\n+            double temp2 = xa * TANGENT_TABLE_A[idx];\n+            double za = 1.0 + temp2;\n+            double zb = -(za - 1.0 - temp2);\n+            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n+            temp = za + temp2;\n+            zb += -(temp - za - temp2);\n+            za = temp;\n+\n+            zb += xb * TANGENT_TABLE_B[idx];\n+            ya = epsA / za;\n+\n+            temp = ya * 1073741824.0;\n+            final double yaa = (ya + temp) - temp;\n+            final double yab = ya - yaa;\n+\n+            temp = za * 1073741824.0;\n+            final double zaa = (za + temp) - temp;\n+            final double zab = za - zaa;\n+\n+            /* Correct for rounding in division */\n+            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n+\n+            yb += -epsA * zb / za / za;\n+            yb += epsB / za;\n+        }\n+\n+\n+        epsA = ya;\n+        epsB = yb;\n+\n+        /* Evaluate polynomial */\n+        double epsA2 = epsA*epsA;\n+\n+        /*\n+    yb = -0.09001346640161823;\n+    yb = yb * epsA2 + 0.11110718400605211;\n+    yb = yb * epsA2 + -0.1428571349122913;\n+    yb = yb * epsA2 + 0.19999999999273194;\n+    yb = yb * epsA2 + -0.33333333333333093;\n+    yb = yb * epsA2 * epsA;\n+         */\n+\n+        yb = 0.07490822288864472;\n+        yb = yb * epsA2 + -0.09088450866185192;\n+        yb = yb * epsA2 + 0.11111095942313305;\n+        yb = yb * epsA2 + -0.1428571423679182;\n+        yb = yb * epsA2 + 0.19999999999923582;\n+        yb = yb * epsA2 + -0.33333333333333287;\n+        yb = yb * epsA2 * epsA;\n+\n+\n+        ya = epsA;\n+\n+        temp = ya + yb;\n+        yb = -(temp - ya - yb);\n+        ya = temp;\n+\n+        /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\n+        yb += epsB / (1.0 + epsA * epsA);\n+\n+        double result;\n+        double resultb;\n+        if (recip) {\n+            final double pi2a = 1.5707963267948966;\n+            final double pi2b = 6.123233995736766E-17;\n+\n+            double za = pi2a - ya;\n+            double zb = -(za - pi2a + ya);\n+            temp = za - EIGHTHES[idx];\n+            zb += -(temp - za + EIGHTHES[idx]);\n+            za = temp;\n+\n+            zb += pi2b - yb;\n+            ya = za;\n+            yb = zb;\n+\n+            result = yb + ya;\n+            resultb = -(result - yb - ya);\n+        } else {\n+            //result = yb + eighths[idx] + ya;\n+            double za = EIGHTHES[idx] + ya;\n+            double zb = -(za - EIGHTHES[idx] - ya);\n+            temp = za + yb;\n+            zb += -(temp - za - yb);\n+            za = temp;\n+\n+            result = za + zb;\n+            resultb = -(result - za - zb);\n+        }\n+\n+        if (leftPlane) {\n+            // Result is in the left plane\n+            final double pia = 1.5707963267948966*2.0;\n+            final double pib = 6.123233995736766E-17*2.0;\n+\n+            final double za = pia - result;\n+            double zb = -(za - pia + result);\n+            zb += pib - resultb;\n+\n+            result = za + zb;\n+            resultb = -(result - za - zb);\n+        }\n+\n+\n+        if (negate ^ leftPlane) {\n+            result = -result;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Two arguments arctangent function\n+     * @param y ordinate\n+     * @param x abscissa\n+     * @return phase angle of point (x,y) between -&pi; and &pi;\n+     */\n+    public static double atan2(double y, double x) {\n+        if (x !=x || y != y) {\n+            return Double.NaN;\n+        }\n+\n+        if (y == 0.0) {\n+            double result = x*y;\n+            double invx = 1.0/x;\n+            double invy = 1.0/y;\n+\n+            if (invx == 0.0) { // X is infinite\n+                return 0.0;\n+            }\n+\n+            if (result != result) { // y must be infinite\n+                return x/y;\n+            }\n+\n+            if (x < 0.0 || invx < 0.0) {\n+                if (y < 0.0 || invy < 0.0) {\n+                    return -Math.PI;\n+                } else {\n+                    return Math.PI;\n+                }\n+            } else {\n+                return result;\n+            }\n+        }\n+\n+        if (y == Double.POSITIVE_INFINITY) {\n+            if (x == Double.POSITIVE_INFINITY) {\n+                return Math.PI/4.0;\n+            }\n+\n+            if (x == Double.NEGATIVE_INFINITY) {\n+                return Math.PI*3.0/4.0;\n+            }\n+\n+            return Math.PI/2.0;\n+        }\n+\n+        if (y == Double.NEGATIVE_INFINITY) {\n+            if (x == Double.POSITIVE_INFINITY) {\n+                return -Math.PI/4.0;\n+            }\n+\n+            if (x == Double.NEGATIVE_INFINITY) {\n+                return -Math.PI*3.0/4.0;\n+            }\n+\n+            return -Math.PI/2.0;\n+        }\n+\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (y > 0.0 || 1/y > 0.0) {\n+                return 0.0;\n+            }\n+\n+            if (y < 0.0 || 1/y < 0.0) {\n+                return -0.0;\n+            }\n+        }\n+\n+        if (x == Double.NEGATIVE_INFINITY)\n+        {\n+            if (y > 0.0 || 1/y > 0.0) {\n+                return Math.PI;\n+            }\n+\n+            if (y < 0.0 || 1/y < 0.0) {\n+                return -Math.PI;\n+            }\n+        }\n+\n+        if (x == 0) {\n+            if (y > 0.0 || 1/y > 0.0) {\n+                return Math.PI/2.0;\n+            }\n+\n+            if (y < 0.0 || 1/y < 0.0) {\n+                return -Math.PI/2.0;\n+            }\n+        }\n+\n+        if (x > 8e298 || x < -8e298) { // This would cause split of x to fail\n+            x *= 9.31322574615478515625E-10;\n+            y *= 9.31322574615478515625E-10;\n+        }\n+\n+        // Split y\n+        double temp = x * 1073741824.0;\n+        final double xa = x + temp - temp;\n+        final double xb = x - xa;\n+\n+        // Compute ratio r = x/y\n+        final double r = y/x;\n+        temp = r * 1073741824.0;\n+        double ra = r + temp - temp;\n+        double rb = r - ra;\n+\n+        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n+\n+        temp = ra + rb;\n+        rb = -(temp - ra - rb);\n+        ra = temp;\n+\n+        // Call atan\n+        double result = atan(ra, rb, x < 0);\n+\n+        return result;\n+    }\n+\n+    /**\n+     *  Convert degrees to radians, with error of less than 0.5 ULP\n+     *  @param x angle in degrees\n+     *  @return x converted into radians\n+     */\n+    public static double toRadians(double x)\n+    {\n+        final double facta = 0.01745329052209854;\n+        final double factb = 1.997844754509471E-9;\n+\n+        double temp = x * 1073741824.0;\n+        double xa = x + temp - temp;\n+        double xb = x - xa;\n+\n+        return xb * factb + xb * facta + xa * factb + xa * facta;\n+    }\n+\n+    /**\n+     *  Convert radians to degrees, with error of less than 0.5 ULP\n+     *  @param x angle in radians\n+     *  @return x converted into degrees\n+     */\n+    public static double toDegrees(double x)\n+    {\n+        final double facta = 57.2957763671875;\n+        final double factb = 3.145894820876798E-6;\n+\n+        double temp = x * 1073741824.0;\n+        double xa = x + temp - temp;\n+        double xb = x - xa;\n+\n+        return xb * factb + xb * facta + xa * factb + xa * facta;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static int abs(final int x) {\n+        return (x < 0) ? -x : x;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static long abs(final long x) {\n+        return (x < 0l) ? -x : x;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static float abs(final float x) {\n+        return (x < 0.0f) ? -x : x;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static double abs(double x) {\n+        return (x < 0.0) ? -x : x;\n+    }\n+\n+    /**\n+     * Compute least significant bit (Unit in Last Position) for a number.\n+     * @param x number from which ulp is requested\n+     * @return ulp(x)\n+     */\n+\n+    public static double ulp(double x) {\n+        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n+    }\n+\n+    /**\n+     * Get the next machine representable number after a number, moving\n+     * in the direction of another number.\n+     * <p>\n+     * If <code>direction</code> is greater than or equal to<code>d</code>,\n+     * the smallest machine representable number strictly greater than\n+     * <code>d</code> is returned; otherwise the largest representable number\n+     * strictly less than <code>d</code> is returned.</p>\n+     * <p>\n+     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n+     *\n+     * @param d base number\n+     * @param direction (the only important thing is whether\n+     * direction is greater or smaller than d)\n+     * @return the next machine representable number in the specified direction\n+     */\n+    public static double nextAfter(double d, double direction) {\n+\n+        // handling of some important special cases\n+        if (Double.isNaN(d) || Double.isInfinite(d)) {\n+            return d;\n+        } else if (d == 0) {\n+            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n+        }\n+        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n+        // are handled just as normal numbers\n+\n+        // split the double in raw components\n+        long bits     = Double.doubleToLongBits(d);\n+        long sign     = bits & 0x8000000000000000L;\n+        long exponent = bits & 0x7ff0000000000000L;\n+        long mantissa = bits & 0x000fffffffffffffL;\n+\n+        if (d * (direction - d) >= 0) {\n+            // we should increase the mantissa\n+            if (mantissa == 0x000fffffffffffffL) {\n+                return Double.longBitsToDouble(sign |\n+                                               (exponent + 0x0010000000000000L));\n+            } else {\n+                return Double.longBitsToDouble(sign |\n+                                               exponent | (mantissa + 1));\n+            }\n+        } else {\n+            // we should decrease the mantissa\n+            if (mantissa == 0L) {\n+                return Double.longBitsToDouble(sign |\n+                                               (exponent - 0x0010000000000000L) |\n+                                               0x000fffffffffffffL);\n+            } else {\n+                return Double.longBitsToDouble(sign |\n+                                               exponent | (mantissa - 1));\n+            }\n+        }\n+\n+    }\n+\n+    /** Get the largest whole number smaller than x.\n+     * @param x number from which floor is requested\n+     * @return a double number f such that f is an integer f <= x < f + 1.0\n+     */\n+    public static double floor(double x) {\n+        long y;\n+\n+        if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {\n+            return x;\n+        }\n+\n+        y = (long) x;\n+        if (x < 0) {\n+            y--;\n+        }\n+\n+        return (double) y;\n+    }\n+\n+    /** Get the smallest whole number larger than x.\n+     * @param x number from which ceil is requested\n+     * @return a double number c such that c is an integer c - 1.0 < x <= c\n+     */\n+    public static double ceil(double x) {\n+        double y;\n+\n+        y = floor(x);\n+        if (y == x) {\n+            return y;\n+        }\n+\n+        return y + 1.0;\n+    }\n+\n+    /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n+     * @param x number from which nearest whole number is requested\n+     * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5\n+     */\n+    public static double rint(double x) {\n+        double y = floor(x);\n+        double d = x - y;\n+\n+        if (d > 0.5) {\n+            return y+1.0;\n+        }\n+        if (d < 0.5) {\n+            return y;\n+        }\n+\n+        /* half way, round to even */\n+        long z = (long) y;\n+        return (z & 1) == 0 ? y : y + 1.0;\n+    }\n+\n+    /** Get the closest long to x.\n+     * @param x number from which closest long is requested\n+     * @return closest long to x\n+     */\n+    public static long round(double x) {\n+        return (long) floor(x + 0.5);\n+    }\n+\n+    /** Get the closest int to x.\n+     * @param x number from which closest int is requested\n+     * @return closest int to x\n+     */\n+    public static int round(final float x) {\n+        return Math.round(x);\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static int min(final int a, final int b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static long min(final long a, final long b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static float min(final float a, final float b) {\n+        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static double min(final double a, final double b) {\n+        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static int max(final int a, final int b) {\n+        return (a <= b) ? b : a;\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static long max(final long a, final long b) {\n+        return (a <= b) ? b : a;\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static float max(final float a, final float b) {\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static double max(final double a, final double b) {\n+        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n+    }\n+\n+}\n",
      "files_name_in_blame_commit": [
        "CurveFitterTest.java",
        "SimpleRegression.java",
        "EulerIntegratorTest.java",
        "SinFunction.java",
        "EstimatedParameterTest.java",
        "TestProblem2.java",
        "EventState.java",
        "Skewness.java",
        "PoissonDistributionImpl.java",
        "PolynomialFunction.java",
        "ResizableDoubleArray.java",
        "AbstractIntegerDistribution.java",
        "SimpsonIntegrator.java",
        "GeneticAlgorithmTestPermutations.java",
        "SimpleRealPointChecker.java",
        "HarmonicFitter.java",
        "UnitSphereRandomVectorGenerator.java",
        "ComposableFunctionTest.java",
        "Array2DRowRealMatrixTest.java",
        "DormandPrince54IntegratorTest.java",
        "HighamHall54IntegratorTest.java",
        "UnivariateRealSolverUtilsTest.java",
        "MicrosphereInterpolatingFunction.java",
        "AbstractRealMatrix.java",
        "GammaDistributionImpl.java",
        "QRDecompositionImpl.java",
        "BiDiagonalTransformer.java",
        "TestUtils.java",
        "BrentSolver.java",
        "ContinuousDistributionAbstractTest.java",
        "StorelessUnivariateStatisticAbstractTest.java",
        "CorrelatedRandomVectorGeneratorTest.java",
        "AbstractRealVector.java",
        "RungeKuttaIntegrator.java",
        "RealMatrixImplTest.java",
        "FastFourierTransformer.java",
        "HarmonicFunction.java",
        "BrentOptimizerTest.java",
        "GaussNewtonOptimizerTest.java",
        "AdaptiveStepsizeIntegrator.java",
        "ArrayRealVector.java",
        "SimpleVectorialPointChecker.java",
        "BigRealTest.java",
        "FastSineTransformerTest.java",
        "MultiStartUnivariateRealOptimizer.java",
        "RiddersSolverTest.java",
        "DividedDifferenceInterpolatorTest.java",
        "DormandPrince853Integrator.java",
        "NormalDistributionTest.java",
        "MultivariateSummaryStatisticsTest.java",
        "BigFraction.java",
        "FastCosineTransformer.java",
        "EulerStepInterpolatorTest.java",
        "FastMath.java",
        "NonLinearConjugateGradientOptimizer.java",
        "LevenbergMarquardtEstimator.java",
        "AbstractIntegrator.java",
        "MinpackTest.java",
        "Beta.java",
        "Gamma.java",
        "LoessInterpolatorTest.java",
        "MicrosphereInterpolatorTest.java",
        "BlockRealMatrix.java",
        "MultistepIntegrator.java",
        "BaseMultivariateRealOptimizer.java",
        "TTestImpl.java",
        "Vector3DTest.java",
        "SumOfLogs.java",
        "GeometricMean.java",
        "StandardDeviationTest.java",
        "UnivariateRealSolverUtils.java",
        "HarmonicCoefficientsGuesser.java",
        "SummaryStatistics.java",
        "BiDiagonalTransformerTest.java",
        "ListUnivariateImpl.java",
        "DescriptiveStatistics.java",
        "ZipfDistributionImpl.java",
        "ClassicalRungeKuttaIntegratorTest.java",
        "FDistributionImpl.java",
        "RandomDataTest.java",
        "TriDiagonalTransformer.java",
        "StandardDeviation.java",
        "NevilleInterpolatorTest.java",
        "NordsieckStepInterpolator.java",
        "EigenDecompositionImplTest.java",
        "RandomDataImpl.java",
        "RombergIntegratorTest.java",
        "DormandPrince853StepInterpolatorTest.java",
        "PascalDistributionImpl.java",
        "Product.java",
        "TricubicSplineInterpolatorTest.java",
        "NewtonSolverTest.java",
        "NormalDistributionImpl.java",
        "RombergIntegrator.java",
        "GaussNewtonEstimatorTest.java",
        "MultivariateSummaryStatistics.java",
        "PolynomialsUtilsTest.java",
        "PearsonsCorrelationTest.java",
        "BlockRealMatrixTest.java",
        "StepNormalizerTest.java",
        "PoissonDistributionTest.java",
        "MullerSolverTest.java",
        "TrapezoidIntegratorTest.java",
        "BaseAbstractScalarOptimizer.java",
        "GammaTest.java",
        "GillIntegratorTest.java",
        "GillStepInterpolator.java",
        "OpenIntToDoubleHashMap.java",
        "SimpsonIntegratorTest.java",
        "MersenneTwister.java",
        "TestProblem3.java",
        "LegendreGaussIntegrator.java",
        "MixedListUnivariateImplTest.java",
        "MultiDirectionalTest.java",
        "BinaryFunctionTest.java",
        "TricubicSplineInterpolatingFunctionTest.java",
        "FastCosineTransformerTest.java",
        "BinaryFunction.java",
        "DormandPrince54Integrator.java",
        "EmpiricalDistributionImpl.java",
        "ArrayRealVectorTest.java",
        "LaguerreSolverTest.java",
        "PolynomialFitterTest.java",
        "AbstractContinuousDistribution.java",
        "StepInterpolatorTestUtils.java",
        "RiddersSolver.java",
        "SimpleScalarValueChecker.java",
        "FastFourierTransformerTest.java",
        "FractionFormatTest.java",
        "BinomialDistributionImpl.java",
        "RotationTest.java",
        "FastSineTransformer.java",
        "NewtonSolver.java",
        "AdamsMoultonIntegratorTest.java",
        "ThreeEighthesIntegratorTest.java",
        "BigFractionTest.java",
        "SplineInterpolatorTest.java",
        "StepNormalizer.java",
        "MathUtilsTest.java",
        "TriDiagonalTransformerTest.java",
        "LevenbergMarquardtEstimatorTest.java",
        "FirstOrderConverterTest.java",
        "SecantSolver.java",
        "WeightedMeasurementTest.java",
        "TDistributionImpl.java",
        "IntegerDistributionAbstractTest.java",
        "BisectionSolverTest.java",
        "Vector3D.java",
        "OpenMapRealVector.java",
        "LUDecompositionImpl.java",
        "BigFractionFormatTest.java",
        "DormandPrince54StepInterpolatorTest.java",
        "SparseRealVectorTest.java",
        "ExponentialDistributionTest.java",
        "ElitisticListPopulation.java",
        "FirstOrderIntegratorWithJacobiansTest.java",
        "ListUnivariateImplTest.java",
        "BisectionSolver.java",
        "AbstractEstimator.java",
        "GraggBulirschStoerIntegrator.java",
        "LevenbergMarquardtOptimizer.java",
        "Expm1Function.java",
        "SummaryStatisticsTest.java",
        "Percentile.java",
        "MullerSolver.java",
        "CholeskyDecompositionImpl.java",
        "SimpleVectorialValueChecker.java",
        "BrentOptimizer.java",
        "WeibullDistributionTest.java",
        "LegendreGaussIntegratorTest.java",
        "NelderMeadTest.java",
        "LaguerreSolver.java",
        "MultiStartUnivariateRealOptimizerTest.java",
        "PolynomialFunctionLagrangeForm.java",
        "ComplexUtilsTest.java",
        "BitsStreamGenerator.java",
        "HighamHall54Integrator.java",
        "BetaDistributionImpl.java",
        "GillIntegrator.java",
        "AbstractLeastSquaresOptimizer.java",
        "WeibullDistributionImpl.java",
        "OpenIntToFieldHashMap.java",
        "GraggBulirschStoerStepInterpolator.java",
        "MidpointIntegratorTest.java",
        "NaturalRanking.java",
        "Fraction.java",
        "AbstractRandomGenerator.java",
        "ComplexFormatAbstractTest.java",
        "StatUtilsTest.java",
        "TrapezoidIntegrator.java",
        "GaussNewtonEstimator.java",
        "SingularValueDecompositionImpl.java",
        "TestProblemHandler.java",
        "CorrelatedRandomVectorGenerator.java",
        "DormandPrince853IntegratorTest.java",
        "LevenbergMarquardtOptimizerTest.java",
        "EmbeddedRungeKuttaIntegrator.java",
        "TestProblem1.java",
        "GraggBulirschStoerIntegratorTest.java",
        "ContinuousOutputModel.java",
        "Rotation.java",
        "GraggBulirschStoerStepInterpolatorTest.java",
        "HighamHall54StepInterpolatorTest.java",
        "Kurtosis.java",
        "HarmonicFitterTest.java",
        "ContinuousOutputModelTest.java",
        "BrentSolverTest.java",
        "EuclideanIntegerPointTest.java",
        "CauchyDistributionImpl.java",
        "StatisticalSummaryValues.java",
        "ChiSquareTestImpl.java",
        "MersenneTwisterTest.java",
        "AbstractRealVectorTest.java",
        "BlockFieldMatrix.java",
        "MathUtils.java",
        "TestProblem4.java",
        "UniformRandomGenerator.java",
        "AbstractMultipleLinearRegression.java",
        "UnivariateStatisticAbstractTest.java",
        "Complex.java",
        "AdamsBashforthIntegratorTest.java",
        "ComplexTest.java",
        "ComposableFunction.java",
        "LoessInterpolator.java",
        "AdamsBashforthIntegrator.java",
        "AdamsMoultonIntegrator.java",
        "ContinuedFraction.java",
        "FractionTest.java",
        "ErfTest.java",
        "HypergeometricDistributionImpl.java",
        "ArgumentOutsideDomainExceptionTest.java",
        "PolynomialFunctionTest.java",
        "SmoothingPolynomialBicubicSplineInterpolatorTest.java",
        "SaddlePointExpansion.java",
        "PearsonsCorrelation.java",
        "CauchyDistributionTest.java",
        "ComplexUtils.java",
        "DummyStepInterpolatorTest.java",
        "EigenDecompositionImpl.java",
        "ExponentialDistributionImpl.java",
        "PolynomialsUtils.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 7
  }
}
{
  "id": "60",
  "blame_commit": {
    "commit": {
      "commit_id": "c85438ba38b9be69d9368c68aeecb27e3e680fa5",
      "commit_message": "Start work on supporting referential type as 1st class concept (and maybe general handling, in future)",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2015-04-28 22:11:13",
      "commit_parent": "a782d3695986b840dcadf571fd9b4cc6af4ee596"
    },
    "function": {
      "function_name": "getGenericSignature",
      "function_code_before": "",
      "function_code_after": "public StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(';');\n    return sb;\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 151,
      "function_after_end_line": 158,
      "function_before_token_count": 0,
      "function_after_token_count": 42,
      "functions_name_modified_file": [
        "buildCanonicalName",
        "withStaticTyping",
        "getParameterSource",
        "toString",
        "containedType",
        "_narrow",
        "containedTypeName",
        "construct",
        "withContentValueHandler",
        "ReferenceType",
        "getReferencedType",
        "withValueHandler",
        "withTypeHandler",
        "containedTypeCount",
        "equals",
        "getGenericSignature",
        "getErasedSignature",
        "isReferenceType",
        "withContentTypeHandler"
      ],
      "functions_name_all_files": [
        "isFinal",
        "constructUnsafe",
        "withStaticTyping",
        "getRawClass",
        "toString",
        "isInterface",
        "_findSuperClassChain",
        "hasValueHandler",
        "_fromParameterizedClass",
        "_arrayListSuperInterfaceChain",
        "widenBy",
        "getValueHandler",
        "_doFindSuperInterfaceChain",
        "_unknownType",
        "_resolveVariableViaSubTypes",
        "widenKey",
        "_findSuperInterfaceChain",
        "_fromArrayType",
        "CollectionType",
        "withKeyValueHandler",
        "constructSpecializedType",
        "containedTypeCount",
        "hasGenericTypes",
        "constructSimpleType",
        "isConcrete",
        "testUpdatingWithViews",
        "moreSpecificType",
        "rawClass",
        "isTrueMapType",
        "isReferenceType",
        "isEnumType",
        "buildCanonicalName",
        "getParameterSource",
        "testBeanUpdate",
        "containedTypeOrUnknown",
        "testIssue744",
        "constructRawMapType",
        "MapLikeType",
        "TypeFactory",
        "ArrayType",
        "_hashMapSuperInterfaceChain",
        "deserialize",
        "testUpdateSequence",
        "constructParametricType",
        "forcedNarrowBy",
        "containedTypeName",
        "isArrayType",
        "withValueHandler",
        "MapType",
        "narrowContentsBy",
        "isJavaLangObject",
        "_widen",
        "equals",
        "getGenericSignature",
        "constructMapType",
        "_mapType",
        "getContentType",
        "narrowBy",
        "getKeyType",
        "withKeyTypeHandler",
        "isTrueCollectionType",
        "_collectionType",
        "uncheckedSimpleType",
        "DataADeserializer",
        "_assertSubclass",
        "testMapUpdate",
        "findTypeParameters",
        "useStaticType",
        "constructReferenceType",
        "constructRawCollectionLikeType",
        "getReferencedType",
        "withContentValueHandler",
        "ReferenceType",
        "isMapLikeType",
        "hasRawClass",
        "defaultInstance",
        "constructRawCollectionType",
        "_fromWildcard",
        "withTypeHandler",
        "isCollectionLikeType",
        "constructMapLikeType",
        "isThrowable",
        "_constructType",
        "getTypeHandler",
        "CollectionLikeType",
        "constructType",
        "constructCollectionLikeType",
        "constructFromCanonical",
        "_fromVariable",
        "_findSuperTypeChain",
        "isPrimitive",
        "JavaType",
        "testListUpdate",
        "withModifier",
        "hashCode",
        "constructArrayType",
        "containedType",
        "SimpleType",
        "isAbstract",
        "_fromClass",
        "_narrow",
        "construct",
        "_fromParamType",
        "unknownType",
        "isContainerType",
        "constructParametrizedType",
        "constructCollectionType",
        "clearCache",
        "constructRawMapLikeType",
        "narrowKey",
        "widenContentsBy",
        "getErasedSignature",
        "withContentTypeHandler"
      ],
      "functions_name_co_evolved_modified_file": [
        "buildCanonicalName",
        "withStaticTyping",
        "getParameterSource",
        "toString",
        "containedType",
        "_narrow",
        "containedTypeName",
        "construct",
        "getReferencedType",
        "ReferenceType",
        "withContentValueHandler",
        "withValueHandler",
        "withTypeHandler",
        "containedTypeCount",
        "equals",
        "getGenericSignature",
        "getErasedSignature",
        "isReferenceType",
        "withContentTypeHandler"
      ],
      "functions_name_co_evolved_all_files": [
        "buildCanonicalName",
        "withStaticTyping",
        "getParameterSource",
        "toString",
        "containedType",
        "SimpleType",
        "ArrayType",
        "_fromClass",
        "_narrow",
        "containedTypeName",
        "construct",
        "constructReferenceType",
        "getReferencedType",
        "ReferenceType",
        "withContentValueHandler",
        "withValueHandler",
        "withTypeHandler",
        "containedTypeCount",
        "equals",
        "getGenericSignature",
        "getErasedSignature",
        "isReferenceType",
        "withContentTypeHandler"
      ]
    },
    "file": {
      "file_name": "ReferenceType.java",
      "file_nloc": 132,
      "file_complexity": 29,
      "file_token_count": 682,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,191 @@\n+package com.fasterxml.jackson.databind.type;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+/**\n+ * Specialized {@link SimpleType} for types that are referential types,\n+ * that is, values that can be dereferenced to another value (or null),\n+ * of different type.\n+ * Referenced type is accessible using {@link #getContentType()}.\n+ * \n+ * @since 2.6\n+ */\n+public class ReferenceType extends SimpleType\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected final JavaType _referencedType;\n+\n+    protected ReferenceType(Class<?> cls, JavaType refType,\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n+    {\n+        super(cls, refType.hashCode(),\n+                valueHandler, typeHandler, asStatic);\n+        _referencedType = refType;\n+    }\n+\n+    public static ReferenceType construct(Class<?> cls, JavaType refType,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        return new ReferenceType(cls, refType, null, null, false);\n+    }                                   \n+    \n+    @Override\n+    public ReferenceType withTypeHandler(Object h)\n+    {\n+        if (h == _typeHandler) {\n+            return this;\n+        }\n+        return new ReferenceType(_class, _referencedType, _valueHandler, h, _asStatic);\n+    }\n+\n+    @Override\n+    public ReferenceType withContentTypeHandler(Object h)\n+    {\n+        if (h == _referencedType.<Object>getTypeHandler()) {\n+            return this;\n+        }\n+        return new ReferenceType(_class, _referencedType.withTypeHandler(h),\n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    @Override\n+    public ReferenceType withValueHandler(Object h) {\n+        if (h == _valueHandler) {\n+            return this;\n+        }\n+        return new ReferenceType(_class, _referencedType, h, _typeHandler,_asStatic);\n+    }\n+\n+    @Override\n+    public ReferenceType withContentValueHandler(Object h) {\n+        if (h == _referencedType.<Object>getValueHandler()) {\n+            return this;\n+        }\n+        return new ReferenceType(_class, _referencedType.withValueHandler(h),\n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    @Override\n+    public ReferenceType withStaticTyping() {\n+        if (_asStatic) {\n+            return this;\n+        }\n+        return new ReferenceType(_class, _referencedType.withStaticTyping(),\n+                 _valueHandler, _typeHandler, true);\n+    }\n+\n+    @Override\n+    protected String buildCanonicalName()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(_class.getName());\n+        sb.append('<');\n+        sb.append(_referencedType.toCanonical());\n+        return sb.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Narrow/widen\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    protected JavaType _narrow(Class<?> subclass)\n+    {\n+        // Should we check that there is a sub-class relationship?\n+        return new ReferenceType(subclass, _referencedType,\n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JavaType getReferencedType() {\n+        return _referencedType;\n+    }\n+\n+    @Override\n+    public boolean isReferenceType() {\n+        return true;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public int containedTypeCount() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public JavaType containedType(int index) {\n+        return (index == 0) ? _referencedType : null;\n+    }\n+\n+    @Override\n+    public String containedTypeName(int index) {\n+        return (index == 0) ? \"T\" : null;\n+    }\n+\n+    @Override\n+    public Class<?> getParameterSource() {\n+        // Hmmh. For now, assume it's the raw type\n+        return _class;\n+    }\n+    \n+    @Override\n+    public StringBuilder getErasedSignature(StringBuilder sb) {\n+        return _classSignature(_class, sb, true);\n+    }\n+    \n+    @Override\n+    public StringBuilder getGenericSignature(StringBuilder sb)\n+    {\n+        _classSignature(_class, sb, false);\n+        sb.append('<');\n+        sb = _referencedType.getGenericSignature(sb);\n+        sb.append(';');\n+        return sb;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return new StringBuilder(40)\n+            .append(\"[reference type, class \")\n+            .append(buildCanonicalName())\n+            .append('<')\n+            .append(_referencedType)\n+            .append('>')\n+            .append(']')\n+            .toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+\n+        ReferenceType other = (ReferenceType) o;\n+\n+        // Otherwise actually mostly worry about referenced type\n+        return _referencedType.equals(other._referencedType);\n+    }\n+}\n",
      "files_name_in_blame_commit": [
        "ArrayType.java",
        "MapType.java",
        "JavaType.java",
        "SimpleType.java",
        "ReferenceType.java",
        "TestUpdateValue.java",
        "TypeFactory.java",
        "CollectionType.java",
        "CollectionLikeType.java",
        "MapLikeType.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 3
  }
}
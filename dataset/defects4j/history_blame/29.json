{
  "id": "29",
  "blame_commit": {
    "commit": {
      "commit_id": "5a0efdcf1e7b3ba0b999c5575bd54baf4b7ae37e",
      "commit_message": "Handle chained assignment and the resulting aliases more gracefully.\nFixes issue 874\nFixes issue 838\n\nR=nicksantos\nDELTA=442 (358 added, 33 deleted, 51 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=6053\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2429 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "johnlenz@google.com",
      "commit_date": "2013-01-02 21:51:31",
      "commit_parent": "d635254c9acd4cfd3f4f205d01ed554c061a5ae1"
    },
    "function": {
      "function_name": "recordAssignment",
      "function_code_before": "",
      "function_code_after": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.  Without\n      // this change, all 3 of those parts try to claim the for\n      // loop as their dependency scope.  The last assignment in\n      // those three fields wins, which can result in incorrect\n      // reference edges between referenced and assigned variables.\n      //\n      // TODO(user) revisit the dependency scope calculation\n      // logic.\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 558,
      "function_after_end_line": 582,
      "function_before_token_count": 0,
      "function_after_token_count": 110,
      "functions_name_modified_file": [
        "keepSubTree",
        "getDependencyScope",
        "removeUnreferenced",
        "appendListItem",
        "ClassDefiningFunctionNode",
        "toString",
        "keepSimplifiedHookExpression",
        "calculateReferences",
        "getParent",
        "classDefiningCallsHaveSideEffects",
        "name",
        "referenceParentNames",
        "nameLink",
        "recordConsumers",
        "recordDepScope",
        "getName",
        "getRhsSubexpressions",
        "recordPrototypeSet",
        "maybeRecordAlias",
        "recordAlias",
        "recordSet",
        "referenceAliases",
        "getHtmlReport",
        "compareTo",
        "NameAnalyzer",
        "maybeHiddenAlias",
        "maybeRecordReferenceOrAlias",
        "shouldTraverse",
        "traverseEdge",
        "JsNameRefNode",
        "countOf",
        "getGramps",
        "isExternallyReferenceable",
        "recordWriteOnProperties",
        "replaceTopLevelExpressionWithRhs",
        "process",
        "FindReferences",
        "addSimplifiedExpression",
        "recordAliases",
        "keepSimplifiedShortCircuitExpression",
        "nameAnchor",
        "getSideEffectNodes",
        "recordAssignment",
        "visit",
        "remove",
        "AliasSet",
        "PrototypeSetNode",
        "collapseReplacements",
        "recordReference",
        "valueConsumedByParent",
        "SpecialReferenceNode",
        "addSimplifiedChildren",
        "createNameInformation",
        "getEnclosingFunctionDependencyScope",
        "replaceWithRhs",
        "createName",
        "nodeRemoved",
        "addAllChildren",
        "Predicate<Node>",
        "InstanceOfCheckNode"
      ],
      "functions_name_all_files": [
        "testTopLevelClass1",
        "checkForStateChangeHelper",
        "testTopLevelClass5",
        "testClassDefinedInObjectLit1",
        "recordPrototypeSet",
        "referencesThis",
        "testRemoveFunction2",
        "testConditionallyDefinedFunction1",
        "getSideEffectNodes",
        "testOtherGlobal",
        "recordAssignment",
        "testRefChain17",
        "testInherits2",
        "isBooleanResultHelper",
        "testSetterInForStruct4",
        "getSourceName",
        "isValidDefineValue",
        "testPreservePropertyMutationsToAlias8",
        "testAssignWithHook2a",
        "isStatementBlock",
        "isFunctionObjectApply",
        "apply",
        "testIf5",
        "isValidSimpleName",
        "getCatchBlock",
        "testNestedAssigns2",
        "testRhsAssign6",
        "testNestedAssign3",
        "isVarOrSimpleAssignLhs",
        "testNoSideEffectAnnotation9",
        "testGetElem1",
        "isNullOrUndefined",
        "getArgumentForFunction",
        "testSingletonGetter2",
        "testNoRemoveThrowReference1",
        "setDebugInformation",
        "isAssociative",
        "ClassDefiningFunctionNode",
        "testDoNotChangeReferencedInstanceOf",
        "testMixin6",
        "classDefiningCallsHaveSideEffects",
        "recordDepScope",
        "testInherits1",
        "isVarArgsFunction",
        "booleanNode",
        "testNoSideEffectAnnotation4",
        "testSetterInForIn2",
        "maybeRecordReferenceOrAlias",
        "testSetterInForStruct1",
        "testSideEffectClassification3",
        "testNestedAssign4",
        "testComplexAssigns",
        "testSetterInForIn6",
        "testRefChain3",
        "recordAliases",
        "keepSimplifiedShortCircuitExpression",
        "testAnonymous7",
        "testNoRemoveThrowReference2",
        "testIssue874d",
        "testSideEffectClassification5",
        "testRemoveVarDeclaration6",
        "testUnhandledTopNode",
        "testRemoveInstanceOfOnly",
        "getPrototypePropertyName",
        "callHasLocalResult",
        "getSourceFile",
        "isEmptyBlock",
        "testShortCircuit7",
        "isImmutableValue",
        "isControlStructure",
        "testSideEffectClassification6",
        "testDoNotChangeInstanceOfGetElem",
        "MatchNodeType",
        "getCount",
        "testSideEffectClassification4",
        "testAssignmentWithComplexLhs4",
        "testRemoveRecursiveFunction2",
        "getNameReferenceCount",
        "testInherits5",
        "trimJsWhiteSpace",
        "isReferenceName",
        "testMixin1",
        "testRefChain12",
        "testRefChain19",
        "isExprCall",
        "isObjectLitKey",
        "traverseEdge",
        "testInherits7",
        "isExecutedExactlyOnce",
        "getFunctionBody",
        "getBestLValueName",
        "testRefChain9",
        "testRefChain21",
        "testRemoveLabeledStatment4",
        "testRemoveVarDeclaration7",
        "testFor",
        "getRootOfQualifiedName",
        "testRhsAssign4",
        "testSetterInSwitchInput",
        "testAliasInstanceof4",
        "testIf4",
        "collapseReplacements",
        "getObjectLitKeyName",
        "createName",
        "InstanceOfCheckNode",
        "removeUnreferenced",
        "testDoNotChangeLocalScopeReferencedInstanceOf",
        "testConstants2",
        "testNamespacedClass1",
        "testAssignWithAnd2",
        "testSetterInForStruct16",
        "testSetterInForStruct7",
        "canBeSideEffected",
        "testRefChain18",
        "testAssignmentToCallResultPrototype",
        "testAssignmentToUnknownPrototype",
        "testReferredToByWindow",
        "testPropertyDefinedInGlobalScope",
        "getFunctionJSDocInfo",
        "testRValueReference6",
        "testRefChain11",
        "isSimpleOperator",
        "getFunctionParameters",
        "testSingletonGetter3",
        "testAssignWithAnd1",
        "testRhsAssign7",
        "isGetOrSetKey",
        "testNoRemoveWindowPropertyAlias3",
        "testNamespacedClass2",
        "testSetterInWhilePredicate",
        "testSetterInIfPredicate",
        "testRemoveLocalScopedInstanceOfOnly",
        "testNestedAssign6",
        "testDo",
        "testNoRemovePrototypeDefinitionsOutsideGlobalScope2",
        "getAssignedValue",
        "testNoSideEffectAnnotation6",
        "testPreservePropertyMutationsToAlias9",
        "calculateReferences",
        "testRefChain16",
        "getStringValue",
        "name",
        "testWeirdnessOnLeftSideOfPrototype",
        "getArgumentForCallOrNew",
        "testRemoveRecursiveFunction4",
        "isLiteralValue",
        "testNamespacedClass3",
        "recordSet",
        "redeclareVarsInsideBranch",
        "maybeAddFinally",
        "testExternalAliasInstanceof1",
        "testVarReferencedInClassDefinedInObjectLit2",
        "testArrayExt",
        "testMixin4",
        "isValidQualifiedName",
        "setUp",
        "isSymmetricOperation",
        "testInherits8",
        "testInherits6",
        "testIssue284",
        "testFunctions2",
        "testRhsReference5",
        "getArrayElementStringValue",
        "testRValueReference2",
        "AliasSet",
        "testSetterInForStruct5",
        "testRhsReference3",
        "isBooleanResult",
        "testNoSideEffectAnnotation12",
        "testNestedAssigns1",
        "getEnclosingFunctionDependencyScope",
        "testTopLevelClass6",
        "testRhsAssign8",
        "testRefChain13",
        "testInherits3",
        "nameAnchor",
        "testRemoveRecursiveFunction7",
        "isNumericResultHelper",
        "testSetterInForIn4",
        "remove",
        "getNodeTypeReferenceCount",
        "keepSimplifiedHookExpression",
        "testSetterInDoWhilePredicate",
        "testNoSideEffectAnnotation15",
        "referenceParentNames",
        "newQualifiedNameNode",
        "testNoRemoveAlias0",
        "testMixin7",
        "testIssue838b",
        "getHtmlReport",
        "isLatin",
        "testSetterInForStruct9",
        "testSetterInForStruct12",
        "testIfElse",
        "mayHaveSideEffects",
        "testPrototypePropertySetInLocalScope6",
        "testAssign5",
        "getOpFromAssignmentOp",
        "testNoSideEffectAnnotation1",
        "testSideEffectClassification1",
        "testRemoveVarDeclaration4",
        "testPrototypePropertySetInLocalScope5",
        "testNestedAssign7",
        "testSetterInForIn3",
        "testConditionallyDefinedFunction2",
        "SpecialReferenceNode",
        "testConditionallyDefinedFunction3",
        "isForIn",
        "testRemoveLabeledStatment3",
        "testAssignWithHook8",
        "isControlStructureCodeBlock",
        "testAssignWithOr1",
        "testAnonymous6",
        "testSetterInForStruct13",
        "testSetterInForStruct11",
        "Predicate<Node>",
        "testPreservePropertyMutationsToAlias2",
        "testRemoveVarDeclaration5",
        "testFunctionPrototype",
        "testAssignWithHook9",
        "isUndefined",
        "testNoSideEffectAnnotation16",
        "testUnintendedUseOfInheritsInLocalScope4",
        "getName",
        "testRemoveDeclaration6",
        "testPreservePropertyMutationsToAlias7",
        "testRValueReference1",
        "testWhile",
        "testRemoveAlias",
        "testAssignWithOr2",
        "getImpureBooleanValue",
        "recordWriteOnProperties",
        "testNoSideEffectAnnotation8",
        "testAnonymous8",
        "testNoRemoveAliasOfExternal1",
        "testNoRemoveWindowPropertyAlias7a",
        "isTryCatchNodeContainer",
        "getInputId",
        "testNoSideEffectAnnotation10",
        "testDoNotChangeLocalScopeReferencedLocalScopedInstanceOf2",
        "testAssignmentWithComplexLhs",
        "appendListItem",
        "testGetElem2",
        "testExternalAliasInstanceof2",
        "isVarDeclaration",
        "testRValueReference4",
        "testExternalAliasInstanceof3",
        "nodeTypeMayHaveSideEffects",
        "testIf4c",
        "has",
        "replaceTopLevelExpressionWithRhs",
        "isRelationalOperation",
        "testNoRemoveWindowPropertyAlias1",
        "testRemoveRecursiveFunction6",
        "testShortCircuit4",
        "testAnonymous4",
        "testRhsAssign3",
        "testSetterInForStruct14",
        "testMixin2",
        "testShortCircuit2",
        "getDependencyScope",
        "maybeRecordAlias",
        "testSetterInForStruct10",
        "testAssignWithHook2",
        "isTryFinallyNode",
        "isCallOrNewTarget",
        "testNoRemoveWindowPropertyAlias5",
        "hasFinally",
        "NameAnalyzer",
        "constructorCallHasSideEffects",
        "isConstantName",
        "testDoNotChangeLocalScopeReferencedLocalScopedInstanceOf",
        "testNamespacedClass5",
        "testDoNotChangeReferencedLocalScopedInstanceOf",
        "testNoRemoveAlias3",
        "testIf4a",
        "isStrWhiteSpaceChar",
        "testTopLevelClass3",
        "testNoRemoveWindowPropertyAlias2",
        "testIf2",
        "recordReference",
        "testClassDefinedInObjectLit3",
        "testRemoveFunction4",
        "testNoSideEffectAnnotation3",
        "isExprAssign",
        "testRefChain5",
        "testIf3",
        "testUnintendedUseOfInheritsInLocalScope1",
        "getRValueOfLValue",
        "testAnonymous5",
        "testRemoveVarDeclaration1",
        "recordAlias",
        "MarkNoSideEffectCallsAndNameAnalyzerRunner",
        "testArrayAliasExt",
        "testRhsReference1",
        "testComplexNestedAssigns1",
        "testRefChain2",
        "testPreservePropertyMutationsToAlias4",
        "isExpressionResultUsed",
        "isExternallyReferenceable",
        "getInverseOperator",
        "testRemoveRecursiveFunction9",
        "isSwitchCase",
        "newName",
        "testRemoveFunction1",
        "testPrototypePropertySetInLocalScope7",
        "newCallNode",
        "testNoRemoveWindowPropertyAlias6a",
        "testNoRemoveAliasOfExternal2",
        "isFunctionExpression",
        "testRemoveRecursiveFunction3",
        "visit",
        "testRemoveDeclaration2",
        "testConstants1",
        "getObjectLitKeyTypeFromValueType",
        "testIssue874e",
        "testNoRemoveWindowPropertyAlias4a",
        "testAssign1",
        "getVarsDeclaredInBranch",
        "isValidPropertyName",
        "testNoRemoveAlias2",
        "testExternName1",
        "testPrototypePropertySetInLocalScope3",
        "isFunctionObjectCall",
        "testAnonymous1",
        "getBestJSDocInfo",
        "isPrototypePropertyDeclaration",
        "maybeHiddenAlias",
        "testSingletonGetter1",
        "testRemoveLabeledStatment",
        "testPreservePropertyMutationsToAlias5",
        "isStatementParent",
        "testNoRemoveAliasOfExternal0",
        "isWithinLoop",
        "recordConsumers",
        "isLoopStructure",
        "testRemoveVarDeclaration2",
        "arrayToString",
        "numberNode",
        "testClassDefinedInObjectLit2",
        "FindReferences",
        "testBug6575051",
        "testBrokenNamespaceWithPrototypeAssignment",
        "testRemoveVarDeclaration8",
        "testRemovePrototypeDefinitionsInGlobalScope1",
        "testSetterInForStruct8",
        "testIssue874a",
        "addSimplifiedChildren",
        "testRemoveRecursiveFunction8",
        "createNameInformation",
        "getNearestFunctionName",
        "replaceWithRhs",
        "testIf1",
        "testRhsAssign5",
        "newExpr",
        "getProcessor",
        "isToStringMethodCall",
        "testNestedAssign5",
        "mayBeString",
        "testRefChain7",
        "testPreservePropertyMutationsToAlias1",
        "keepSubTree",
        "testSetCreatingReference",
        "testNestedAssign1",
        "testNoRemovePrototypeDefinitionsOutsideGlobalScope1",
        "testSetterInForStruct3",
        "testUnintendedUseOfInheritsInLocalScope2",
        "testAssign2",
        "testAnonymous9",
        "testShortCircuit1",
        "testComplexNestedAssigns4",
        "process",
        "testPreservePropertyMutationsToAlias3",
        "getNumRepetitions",
        "testInherits4",
        "testExtern",
        "testFunctions1",
        "isAssignmentOp",
        "getBestLValue",
        "PrototypeSetNode",
        "removeChild",
        "testShortCircuit3",
        "valueConsumedByParent",
        "isFunctionDeclaration",
        "testRhsAssign9",
        "testRemoveInstanceOfWithReferencedMethod",
        "testRefChain6",
        "nodeRemoved",
        "getConditionExpression",
        "testTopLevelClass4",
        "testRhsAssign1",
        "isStatement",
        "testRemoveRecursiveFunction2a",
        "testAssignWithHook1",
        "toString",
        "testExpressions2",
        "testNoRemoveWindowPropertyAlias5a",
        "referenceAliases",
        "getAddingRoot",
        "testAssignmentToExternPrototype",
        "testRemovePrototypeAliases",
        "testNoSideEffectAnnotation13",
        "compareTo",
        "getNthSibling",
        "JsNameRefNode",
        "testAssignWithHook4",
        "isObjectCallMethod",
        "testExpressions3",
        "testAssignWithHook6",
        "opToStr",
        "copyNameAnnotations",
        "isConstantByConvention",
        "testPrototypePropertySetInLocalScope4",
        "newUndefinedNode",
        "testAnonymous2",
        "containsType",
        "testNoSideEffectAnnotation11",
        "testRefChain8",
        "hasCatchHandler",
        "containsFunction",
        "testSetterInForIn1",
        "testRemoveDeclaration1",
        "anyResultsMatch",
        "testNoSideEffectAnnotation14",
        "isBleedingFunctionName",
        "testSetterInForIn5",
        "testRemoveDeclaration5",
        "testRValueReference5",
        "isCallOrNew",
        "testTopLevelClass7",
        "testAssignmentToThisPrototype",
        "testNoRemoveWindowPropertyAlias6",
        "NameAnalyzerTest",
        "testRefChain23",
        "nameLink",
        "getRhsSubexpressions",
        "testRefChain15",
        "getNumberValue",
        "testAssignmentWithComplexLhs2",
        "testAssignWithHook5",
        "testNoSideEffectAnnotation2",
        "testExternName2",
        "countOf",
        "getGramps",
        "isHoistedFunctionDeclaration",
        "testPrototypePropertySetInLocalScope1",
        "testAliasInstanceof5",
        "isEmptyFunctionExpression",
        "getBestLValueOwner",
        "testRemoveDeclaration3",
        "evaluatesToLocalValue",
        "testShortCircuit6",
        "getLoopCodeBlock",
        "testNoRemoveAlias1",
        "testIssue874c",
        "tryMergeBlock",
        "testRValueReference3",
        "testRemoveLabeledStatment2",
        "testNoSideEffectAnnotation5",
        "testIf4b",
        "testClassDefinedInObjectLit4",
        "testNoRemoveWindowPropertyAlias4",
        "testAssign4",
        "testAssignWithHook3",
        "testAssignmentWithComplexLhs3",
        "addAllChildren",
        "getStringNumberValue",
        "getPrototypeClassName",
        "testRemoveVarDeclaration3",
        "testNoRemovePrototypeDefinitionsOutsideGlobalScope5",
        "getParent",
        "testNoSideEffectAnnotation7",
        "getPureBooleanValue",
        "testTopLevelClass2",
        "testAssign3",
        "allResultsMatch",
        "opToStrNoFail",
        "testRhsAssign2",
        "isPrototypeProperty",
        "testShortCircuit5",
        "getFunctionName",
        "isNaN",
        "testComplexNestedAssigns3",
        "testRhsReference2",
        "testRefChain4",
        "isSimpleOperatorType",
        "testNoRemovePrototypeDefinitionsOutsideGlobalScope4",
        "isLValue",
        "testSetterInForStruct2",
        "testAnonymous3",
        "isNumericResult",
        "testBug2099540",
        "testSideEffectClassification2",
        "functionCallHasSideEffects",
        "testMixin3",
        "isCommutative",
        "testRefChain10",
        "testGetElem3",
        "testPreservePropertyMutationsToAlias6",
        "NodeUtil",
        "testPrototypePropertySetInLocalScope2",
        "testRemoveNamedFunction",
        "testSideEffectClassification7",
        "visitPreOrder",
        "testRefChain14",
        "testMixin5",
        "testRemovePrototypeDefinitionsInGlobalScope2",
        "mayEffectMutableState",
        "isImmutableResult",
        "testVarReferencedInClassDefinedInObjectLit1",
        "mayBeStringHelper",
        "visitPostOrder",
        "testNoRemoveWindowPropertyAlias7",
        "testExpressions1",
        "testNamespacedClass4",
        "testRhsReference4",
        "testSetterInForStruct15",
        "testNestedAssign15",
        "testIssue838a",
        "shouldTraverse",
        "isGet",
        "testRemoveRecursiveFunction5",
        "testRemoveDeclaration4",
        "testUnintendedUseOfInheritsInLocalScope3",
        "newVarNode",
        "addSimplifiedExpression",
        "testSetterInForStruct6",
        "testComplexNestedAssigns2",
        "testAssignWithHook7",
        "newHasLocalResult",
        "testRefChain1",
        "testRefChain20",
        "testGetElemOnThis",
        "testIssue874b",
        "testRemoveFunction3",
        "testNestedAssign8",
        "testShortCircuit8",
        "testRemoveRecursiveFunction1",
        "testNestedAssign2",
        "precedence",
        "isNameReferenced",
        "MatchNameNode",
        "testRemoveDeclaration7",
        "testRefChain22"
      ],
      "functions_name_co_evolved_modified_file": [
        "recordAssignment",
        "maybeRecordReferenceOrAlias",
        "createNameInformation",
        "getEnclosingFunctionDependencyScope",
        "visit",
        "replaceTopLevelExpressionWithRhs",
        "recordDepScope",
        "recordConsumers",
        "recordAliases",
        "getDependencyScope",
        "maybeRecordAlias"
      ],
      "functions_name_co_evolved_all_files": [
        "testRemoveRecursiveFunction2a",
        "testRemoveVarDeclartion4",
        "testNoRemoveWindowPropertyAlias5",
        "testRemoveRecursiveFunction4",
        "testNestedAssigns",
        "testNoRemoveWindowPropertyAlias5a",
        "testRemoveFunction2",
        "recordAssignment",
        "testIf4a",
        "testRemoveVarDeclartion2",
        "testAssignWithHook2a",
        "testRemoveFunction4",
        "testNestedAssigns1",
        "testRemoveDeclaration1",
        "getEnclosingFunctionDependencyScope",
        "testRemoveVarDeclartion7",
        "testNestedAssigns2",
        "testRemoveDeclaration5",
        "testSetterInForIn4",
        "testNoRemoveWindowPropertyAlias6",
        "recordDepScope",
        "testRemoveVarDeclaration1",
        "testIssue838b",
        "maybeRecordReferenceOrAlias",
        "testRemoveVarDeclartion8",
        "recordAliases",
        "testRemoveFunction1",
        "testRemoveDeclaration3",
        "testNoRemoveWindowPropertyAlias6a",
        "testAssign5",
        "visit",
        "testRemoveDeclaration2",
        "testIssue874d",
        "testIssue874e",
        "testIssue874c",
        "testNoRemoveWindowPropertyAlias4a",
        "testAssign1",
        "testRemoveVarDeclaration6",
        "testRemoveVarDeclaration4",
        "testSetterInForIn3",
        "testIf4b",
        "testConditionallyDefinedFunction3",
        "testAssignWithHook8",
        "testNoRemoveWindowPropertyAlias4",
        "testAssign4",
        "Predicate<Node>",
        "testRemoveVarDeclaration5",
        "testAssignWithHook9",
        "testRemoveVarDeclaration3",
        "testRemoveDeclaration6",
        "recordConsumers",
        "testAssign3",
        "testRemoveVarDeclaration2",
        "testBug6575051",
        "testRemoveVarDeclaration8",
        "testRemoveVarDeclaration7",
        "testRemoveVarDeclartion5",
        "testRemoveVarDeclartion1",
        "testNoRemoveWindowPropertyAlias7a",
        "testIssue874a",
        "testRemoveVarDeclartion3",
        "createNameInformation",
        "isImmutableResult",
        "testNoRemoveWindowPropertyAlias7",
        "testIssue838a",
        "testAssign2",
        "testIf4c",
        "testRemoveDeclaration4",
        "testRemoveVarDeclartion6",
        "replaceTopLevelExpressionWithRhs",
        "testAssignWithHook7",
        "testRemoveFunction",
        "testIssue874b",
        "testRemoveFunction3",
        "getDependencyScope",
        "testRemoveDeclaration7",
        "maybeRecordAlias"
      ]
    },
    "file": {
      "file_name": "NameAnalyzer.java",
      "file_nloc": 1165,
      "file_complexity": 310,
      "file_token_count": 7559,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -19,6 +19,8 @@ package com.google.javascript.jscomp;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.ListMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n@@ -29,10 +31,10 @@ import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph;\n-import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n-import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n@@ -92,7 +94,8 @@ final class NameAnalyzer implements CompilerPass {\n    * If scopes.get(node).equals(name) && node2 is a child of node, then node2\n    * will not get executed unless name is referenced via a get operation\n    */\n-  private final Map<Node, NameInformation> scopes = Maps.newHashMap();\n+  private final ListMultimap<Node, NameInformation> scopes =\n+      LinkedListMultimap.create();\n \n   /** Used to parse prototype names */\n   private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n@@ -463,9 +466,9 @@ final class NameAnalyzer implements CompilerPass {\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       NameInformation ns = null;\n       if (NodeUtil.isVarDeclaration(n)) {\n-        ns = createNameInformation(t, n, parent);\n+        ns = createNameInformation(t, n);\n       } else if (NodeUtil.isFunctionDeclaration(n)) {\n-        ns = createNameInformation(t, n.getFirstChild(), n);\n+        ns = createNameInformation(t, n.getFirstChild());\n       }\n       if (ns != null) {\n         JsName jsName = getName(ns.name, true);\n@@ -504,48 +507,85 @@ final class NameAnalyzer implements CompilerPass {\n       }\n \n       if (n.isAssign()) {\n-        Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n-        if (ns != null) {\n-          if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n-            // Patch for assignments that appear in the init,\n-            // condition or iteration part of a FOR loop.  Without\n-            // this change, all 3 of those parts try to claim the for\n-            // loop as their dependency scope.  The last assignment in\n-            // those three fields wins, which can result in incorrect\n-            // reference edges between referenced and assigned variables.\n-            //\n-            // TODO(user) revisit the dependency scope calculation\n-            // logic.\n-            if (parent.getFirstChild().getNext() != n) {\n-              recordDepScope(n, ns);\n-            } else {\n-              recordDepScope(nameNode, ns);\n-            }\n-          } else {\n-            recordDepScope(n, ns);\n-          }\n+        recordAssignment(t, n, n);\n+        if (!NodeUtil.isImmutableResult(n.getLastChild())) {\n+          recordConsumers(t, n, n);\n         }\n       } else if (NodeUtil.isVarDeclaration(n)) {\n-        NameInformation ns = createNameInformation(t, n, parent);\n+        NameInformation ns = createNameInformation(t, n);\n         recordDepScope(n, ns);\n       } else if (NodeUtil.isFunctionDeclaration(n)) {\n-        NameInformation ns = createNameInformation(t, n.getFirstChild(), n);\n+        NameInformation ns = createNameInformation(t, n.getFirstChild());\n         recordDepScope(n, ns);\n       } else if (NodeUtil.isExprCall(n)) {\n         Node callNode = n.getFirstChild();\n         Node nameNode = callNode.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, callNode);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         if (ns != null && ns.onlyAffectsClassDef) {\n           recordDepScope(n, ns);\n         }\n       }\n     }\n \n+    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {\n+      Node parent = n.getParent();\n+      switch (parent.getType()) {\n+        case Token.ASSIGN:\n+          if (n == parent.getLastChild()) {\n+            recordAssignment(t, parent, recordNode);\n+          }\n+          recordConsumers(t, parent, recordNode);\n+          break;\n+        case Token.NAME:\n+          NameInformation ns = createNameInformation(t, parent);\n+          recordDepScope(recordNode, ns);\n+          break;\n+        case Token.OR:\n+          recordConsumers(t, parent, recordNode);\n+          break;\n+        case Token.AND:\n+          // In \"a && b\" only \"b\" can be meaningfully aliased.\n+          // \"a\" must be falsy, which it must be an immutable, non-Object\n+        case Token.COMMA:\n+        case Token.HOOK:\n+          if (n != parent.getFirstChild()) {\n+            recordConsumers(t, parent, recordNode);\n+          }\n+          break;\n+      }\n+    }\n+\n+    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n+      Node nameNode = n.getFirstChild();\n+      Node parent = n.getParent();\n+      NameInformation ns = createNameInformation(t, nameNode);\n+      if (ns != null) {\n+        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n+          // Patch for assignments that appear in the init,\n+          // condition or iteration part of a FOR loop.  Without\n+          // this change, all 3 of those parts try to claim the for\n+          // loop as their dependency scope.  The last assignment in\n+          // those three fields wins, which can result in incorrect\n+          // reference edges between referenced and assigned variables.\n+          //\n+          // TODO(user) revisit the dependency scope calculation\n+          // logic.\n+          if (parent.getFirstChild().getNext() != n) {\n+            recordDepScope(recordNode, ns);\n+          } else {\n+            recordDepScope(nameNode, ns);\n+          }\n+        } else {\n+          recordDepScope(recordNode, ns);\n+        }\n+      }\n+    }\n+\n     /**\n      * Defines a dependency scope.\n      */\n     private void recordDepScope(Node node, NameInformation name) {\n+      Preconditions.checkNotNull(name);\n       scopes.put(node, name);\n     }\n   }\n@@ -562,12 +602,12 @@ final class NameAnalyzer implements CompilerPass {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (NodeUtil.isVarDeclaration(n)) {\n-        NameInformation ns = createNameInformation(t, n, parent);\n+        NameInformation ns = createNameInformation(t, n);\n         Preconditions.checkNotNull(ns, \"NameInformation is null\");\n         createName(ns.name);\n       } else if (NodeUtil.isFunctionDeclaration(n)) {\n         Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         Preconditions.checkNotNull(ns, \"NameInformation is null\");\n         createName(nameNode.getString());\n       }\n@@ -590,18 +630,18 @@ final class NameAnalyzer implements CompilerPass {\n       // Record global variable and function declarations\n       if (t.inGlobalScope()) {\n         if (NodeUtil.isVarDeclaration(n)) {\n-          NameInformation ns = createNameInformation(t, n, parent);\n+          NameInformation ns = createNameInformation(t, n);\n           Preconditions.checkNotNull(ns);\n           recordSet(ns.name, n);\n         } else if (NodeUtil.isFunctionDeclaration(n)) {\n           Node nameNode = n.getFirstChild();\n-          NameInformation ns = createNameInformation(t, nameNode, n);\n+          NameInformation ns = createNameInformation(t, nameNode);\n           if (ns != null) {\n             JsName nameInfo = getName(nameNode.getString(), true);\n             recordSet(nameInfo.name, nameNode);\n           }\n         } else if (NodeUtil.isObjectLitKey(n, parent)) {\n-          NameInformation ns = createNameInformation(t, n, parent);\n+          NameInformation ns = createNameInformation(t, n);\n           if (ns != null) {\n             recordSet(ns.name, n);\n           }\n@@ -612,7 +652,7 @@ final class NameAnalyzer implements CompilerPass {\n       if (n.isAssign()) {\n         Node nameNode = n.getFirstChild();\n \n-        NameInformation ns = createNameInformation(t, nameNode, n);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         if (ns != null) {\n           if (ns.isPrototype) {\n             recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n@@ -622,7 +662,7 @@ final class NameAnalyzer implements CompilerPass {\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         if (ns != null && ns.onlyAffectsClassDef) {\n           JsName name = getName(ns.name, true);\n           refNodes.add(new ClassDefiningFunctionNode(name, n));\n@@ -811,7 +851,7 @@ final class NameAnalyzer implements CompilerPass {\n         return;\n       }\n \n-      NameInformation nameInfo = createNameInformation(t, n, parent);\n+      NameInformation nameInfo = createNameInformation(t, n);\n       if (nameInfo == null) {\n         // The name is not a global name\n         return;\n@@ -849,7 +889,20 @@ final class NameAnalyzer implements CompilerPass {\n       // looking up the nearest enclosing dependency scope. It's unnecessary to\n       // determine all enclosing dependency scopes because this callback should\n       // create a chain of references between them.\n-      NameInformation referring = getDependencyScope(n);\n+      List<NameInformation> referers = getDependencyScope(n);\n+      if (referers.isEmpty()) {\n+        maybeRecordReferenceOrAlias(t, n, parent, nameInfo, null);\n+      } else {\n+        for (NameInformation referring : referers) {\n+          maybeRecordReferenceOrAlias(t, n, parent, nameInfo, referring);\n+        }\n+        recordAliases(referers);\n+      }\n+    }\n+\n+    private void maybeRecordReferenceOrAlias(\n+        NodeTraversal t, Node n, Node parent,\n+        NameInformation nameInfo, NameInformation referring) {\n       String referringName = \"\";\n       if (referring != null) {\n         referringName = referring.isPrototype\n@@ -885,11 +938,17 @@ final class NameAnalyzer implements CompilerPass {\n       }\n \n       if (nodesToKeep.contains(n)) {\n-        NameInformation functionScope = getEnclosingFunctionDependencyScope(t);\n-        if (functionScope != null) {\n-          recordReference(functionScope.name, name, RefType.REGULAR);\n+        List<NameInformation> functionScopes =\n+            getEnclosingFunctionDependencyScope(t);\n+        if (!functionScopes.isEmpty()) {\n+          for (NameInformation functionScope : functionScopes) {\n+            recordReference(functionScope.name, name, RefType.REGULAR);\n+          }\n         } else {\n           recordReference(WINDOW, name, RefType.REGULAR);\n+          if (referring != null) {\n+            maybeRecordAlias(name, parent, referring, referringName);\n+          }\n         }\n       } else if (referring != null) {\n         if (!maybeRecordAlias(name, parent, referring, referringName)) {\n@@ -912,6 +971,16 @@ final class NameAnalyzer implements CompilerPass {\n       }\n     }\n \n+    private void recordAliases(List<NameInformation> referers) {\n+      int size = referers.size();\n+      for (int i = 0; i < size; i++) {\n+        for (int j = i + 1; j < size; j++) {\n+          recordAlias(referers.get(i).name, referers.get(j).name);\n+          recordAlias(referers.get(j).name, referers.get(i).name);\n+        }\n+      }\n+    }\n+\n     /**\n      * A value whose result is the return value of a function call\n      * can be an alias to global object. The dependency on the call target will\n@@ -959,7 +1028,7 @@ final class NameAnalyzer implements CompilerPass {\n           parent.isAssign()) &&\n           !isPrototypePropAssignment &&\n           referring != null &&\n-          scopes.get(parent) == referring) {\n+          scopes.get(parent).contains(referring)) {\n         recordAlias(referringName, name);\n         return true;\n       }\n@@ -1321,12 +1390,11 @@ final class NameAnalyzer implements CompilerPass {\n    *\n    * @param t The node traversal\n    * @param n The current node\n-   * @param parent The parent of n\n    * @return The name information, or null if the name is irrelevant to this\n    *     pass\n    */\n-  private NameInformation createNameInformation(NodeTraversal t, Node n,\n-      Node parent) {\n+  private NameInformation createNameInformation(NodeTraversal t, Node n) {\n+    Node parent = n.getParent();\n     // Build the full name and find its root node by iterating down through all\n     // GETPROP/GETELEM nodes.\n     String name = \"\";\n@@ -1398,7 +1466,7 @@ final class NameAnalyzer implements CompilerPass {\n             n.isGetProp() &&\n             parent.isAssign() &&\n             \"prototype\".equals(n.getLastChild().getString())) {\n-          if (createNameInformation(t, n.getFirstChild(), n) != null) {\n+          if (createNameInformation(t, n.getFirstChild()) != null) {\n             name = rootNameNode.getString() + name;\n             name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n             NameInformation nameInfo = new NameInformation();\n@@ -1492,15 +1560,15 @@ final class NameAnalyzer implements CompilerPass {\n   /**\n    * Gets the nearest enclosing dependency scope, or null if there isn't one.\n    */\n-  private NameInformation getDependencyScope(Node n) {\n+  private List<NameInformation> getDependencyScope(Node n) {\n     for (Node node : n.getAncestors()) {\n-      NameInformation ref = scopes.get(node);\n-      if (ref != null) {\n-        return ref;\n+      List<NameInformation> refs = scopes.get(node);\n+      if (!refs.isEmpty()) {\n+        return refs;\n       }\n     }\n \n-    return null;\n+    return Collections.emptyList();\n   }\n \n   /**\n@@ -1509,15 +1577,16 @@ final class NameAnalyzer implements CompilerPass {\n    * its parent if the parent node is a variable declaration or\n    * assignment.\n    */\n-  private NameInformation getEnclosingFunctionDependencyScope(NodeTraversal t) {\n+  private List<NameInformation> getEnclosingFunctionDependencyScope(\n+      NodeTraversal t) {\n     Node function = t.getEnclosingFunction();\n     if (function == null) {\n-      return null;\n+      return Collections.emptyList();\n     }\n \n-    NameInformation ref = scopes.get(function);\n-    if (ref != null) {\n-      return ref;\n+    List<NameInformation> refs = scopes.get(function);\n+    if (!refs.isEmpty()) {\n+      return refs;\n     }\n \n     // Function expression.  try to get a name from the parent var\n@@ -1539,7 +1608,7 @@ final class NameAnalyzer implements CompilerPass {\n       }\n     }\n \n-    return null;\n+    return Collections.emptyList();\n   }\n \n   /**\n@@ -1679,7 +1748,8 @@ final class NameAnalyzer implements CompilerPass {\n         break;\n       case Token.ASSIGN:\n         Preconditions.checkArgument(parent.isFor(),\n-            \"Unsupported assignment in replaceWithRhs. parent: %s\", Token.name(parent.getType()));\n+            \"Unsupported assignment in replaceWithRhs. parent: %s\",\n+            Token.name(parent.getType()));\n         break;\n       default:\n         throw new IllegalArgumentException(\n",
      "files_name_in_blame_commit": [
        "NameAnalyzer.java",
        "NameAnalyzerTest.java",
        "NodeUtil.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 47
  }
}
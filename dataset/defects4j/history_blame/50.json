{
  "id": "50",
  "blame_commit": {
    "commit": {
      "commit_id": "b3b919770bd6e1aa14abc9ee1a1406af251e1d1c",
      "commit_message": "Change number parsing to use one big loop. This changes it to return JsonToken.STRING for very long (>8k digits) numbers.",
      "commit_author": "Jesse Wilson",
      "commit_date": "2012-09-02 20:12:19",
      "commit_parent": "3920d95fac0520c288e6b5f626ae0724a32f49ca"
    },
    "function": {
      "function_name": "peekNumber",
      "function_code_before": "private int peekNumber() throws IOException {\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int i = 0;\n  int c = get(i);\n\n  // TODO: figure out a way to speed up repopulating 'c'\n\n  if (c == '-') {\n    negative = true;\n    c = get(++i);\n  }\n\n  if (c == '0') {\n    c = get(++i);\n  } else if (c >= '1' && c <= '9') {\n    value -= (c - '0');\n    c = get(++i);\n    while (c >= '0' && c <= '9') {\n      long newValue = value * 10 - (c - '0');\n      fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n          || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n      value = newValue;\n      c = get(++i);\n    }\n  } else {\n    return PEEKED_NONE;\n  }\n\n  if (c == -1 || !isLiteral((char) c)) {\n    if (fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    }\n  }\n\n  if (c == '.') {\n    c = get(++i);\n    while (c >= '0' && c <= '9') {\n      c = get(++i);\n    }\n  }\n\n  if (c == 'e' || c == 'E') {\n    c = get(++i);\n    if (c == '+' || c == '-') {\n      c = get(++i);\n    }\n    if (c >= '0' && c <= '9') {\n      c = get(++i);\n      while (c >= '0' && c <= '9') {\n        c = get(++i);\n      }\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  if (c == -1 || !isLiteral((char) c)) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  }\n\n  return PEEKED_NONE;\n}",
      "function_code_after": "private int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}",
      "function_before_start_line": 627,
      "function_before_end_line": 696,
      "function_after_start_line": 636,
      "function_after_end_line": 737,
      "function_before_token_count": 375,
      "function_after_token_count": 438,
      "functions_name_modified_file": [
        "peekKeyword",
        "peekNumber",
        "isLenient",
        "getColumnNumber",
        "push",
        "toString",
        "isLiteral",
        "endArray",
        "nextInt",
        "syntaxError",
        "peek",
        "nextQuotedValue",
        "nextNull",
        "nextLong",
        "nextName",
        "setLenient",
        "skipUnquotedValue",
        "close",
        "JsonReader",
        "hasNext",
        "nextNonWhitespace",
        "skipValue",
        "JsonReaderInternalAccess",
        "nextUnquotedValue",
        "skipToEndOfLine",
        "endObject",
        "nextString",
        "readEscapeCharacter",
        "skipQuotedValue",
        "beginArray",
        "checkLenient",
        "getLineNumber",
        "doPeek",
        "consumeNonExecutePrefix",
        "nextBoolean",
        "fillBuffer",
        "beginObject",
        "skipTo",
        "nextDouble"
      ],
      "functions_name_all_files": [
        "testNulls",
        "disabled_testHighPrecisionLong",
        "testStrictCommentsWithSkipValue",
        "toString",
        "testStrictSemicolonDelimitedArrayWithSkipValue",
        "testMissingValue",
        "testStrictUnquotedNames",
        "testLenientSemicolonDelimitedArray",
        "testLenientTopLevelValueType",
        "testFailWithPositionOverQuotedString",
        "assertDocument",
        "testBomIgnoredAsFirstCharacterOfDocument",
        "testVeryLongUnquotedLiteral",
        "syntaxError",
        "testReadEmptyObject",
        "testStrictSemicolonDelimitedNameValuePair",
        "testLenientUnquotedNames",
        "testLenientMultipleTopLevelValues",
        "testFailWithPositionGreaterThanBufferSize",
        "testStringWithLeadingSlash",
        "reader",
        "testStrictQuotedNonFiniteDoubles",
        "testSkipVeryLongUnquotedString",
        "testLongLargerThanMinLongThatWrapsAround",
        "testStrictUnnecessaryArraySeparatorsWithSkipValue",
        "testStrictSingleQuotedNames",
        "testStringAsNumberWithDigitAndNonDigitExponent",
        "testLenientSingleQuotedStrings",
        "nextName",
        "skipUnquotedValue",
        "JsonReader",
        "hasNext",
        "testStrictSingleQuotedNamesWithSkipValue",
        "testStrictExtraCommasInMaps",
        "testStrictTopLevelValueType",
        "testStrictUnquotedStringsWithSkipValue",
        "testCharacterUnescaping",
        "testLenientNonFiniteDoubles",
        "testStrictTopLevelString",
        "JsonReaderInternalAccess",
        "testUnterminatedStringFailure",
        "testSkipInteger",
        "nextString",
        "readEscapeCharacter",
        "testReadObject",
        "testMalformedNumbers",
        "testPeekingUnquotedStringsPrefixedWithBooleans",
        "skipQuotedValue",
        "beginArray",
        "disabled_testPeekLargerThanLongMinValue",
        "testLenientTopLevelString",
        "testIntegerMismatchFailuresDoNotAdvance",
        "checkLenient",
        "testUnescapingInvalidCharacters",
        "testStrictNonExecutePrefix",
        "fillBuffer",
        "testIntegersWithFractionalPartSpecified",
        "testLenientUnnecessaryArraySeparators",
        "testVeryLongUnterminatedString",
        "testDocumentWithCommentEndingInSlash",
        "isLiteral",
        "testLenientVeryLongNumber",
        "testStringNullIsNotNull",
        "peek",
        "nextNull",
        "testSkipObject",
        "testUnescapingTruncatedSequence",
        "nextLong",
        "testDeeplyNestedArrays",
        "close",
        "testStrictSingleQuotedStrings",
        "testStrictNonFiniteDoubles",
        "testStrictSemicolonDelimitedArray",
        "testLenientExtraCommasInMaps",
        "testLenientNonExecutePrefix",
        "testStrictVeryLongNumber",
        "testStrictNameValueSeparator",
        "nextNonWhitespace",
        "testStringAsNumberWithNonDigitExponent",
        "nextUnquotedValue",
        "testLongs",
        "testLenientNameValueSeparator",
        "testFailWithPositionOverCStyleComment",
        "endObject",
        "testHelloWorld",
        "testFailWithPosition",
        "testFailWithPositionOverSlashSlashEndOfLineComment",
        "testUnterminatedObject",
        "testPrematureEndOfInput",
        "disabled_testNumberWithOctalPrefix",
        "testPrematurelyClosed",
        "testFailWithEscapedNewlineCharacter",
        "testBomForbiddenAsOtherCharacterInDocument",
        "testStrictSingleQuotedStringsWithSkipValue",
        "nextBoolean",
        "beginObject",
        "testPeekLongMinValue",
        "testMixedCaseLiterals",
        "testFailWithPositionIsOffsetByBom",
        "testNullLiteralIsNotAString",
        "peekKeyword",
        "isLenient",
        "testFailWithPositionOverUnquotedString",
        "testLenientPartialNonExecutePrefix",
        "push",
        "testSkipDouble",
        "endArray",
        "nextInt",
        "testSkipTopLevelQuotedString",
        "nextQuotedValue",
        "testStrictNameValueSeparatorWithSkipValue",
        "testSkipVeryLongQuotedString",
        "testStrictTopLevelValueTypeWithSkipValue",
        "testNextFailuresDoNotAdvance",
        "testLenientSingleQuotedNames",
        "testPeekMuchLargerThanLongMinValue",
        "testFailWithPositionOverHashEndOfLineComment",
        "testStrictMultipleTopLevelValuesWithSkipValue",
        "testBooleans",
        "skipValue",
        "testStrictNonExecutePrefixWithSkipValue",
        "testStrictUnnecessaryArraySeparators",
        "testVeryLongQuotedString",
        "testStrictNonFiniteDoublesWithSkipValue",
        "testMalformedDocuments",
        "assertNotANumber",
        "repeat",
        "testQuotedNumberWithEscape",
        "testReadArray",
        "doPeek",
        "testPeekingUnquotedStringsPrefixedWithIntegers",
        "testNoTopLevelObject",
        "testVeryLongUnquotedString",
        "testEmptyString",
        "testLenientSemicolonDelimitedNameValuePair",
        "getColumnNumber",
        "peekNumber",
        "testDoubles",
        "testStringEndingInSlash",
        "testDeeplyNestedObjects",
        "testEmptyStringName",
        "testLongLargerThanMaxLongThatWrapsAround",
        "testPeekLongMaxValue",
        "disabled_testPeekLargerThanLongMaxValue",
        "setLenient",
        "testStrictUnquotedNamesWithSkipValue",
        "testStrictUnquotedStrings",
        "testStringAsNumberWithTruncatedExponent",
        "testStrictSemicolonDelimitedNameValuePairWithSkipValue",
        "testStrictComments",
        "testStrictMultipleTopLevelValues",
        "testLenientUnquotedStrings",
        "skipToEndOfLine",
        "testLenientComments",
        "testLenientQuotedNonFiniteDoubles",
        "testReadEmptyArray",
        "testUnescapingTruncatedCharacters",
        "testLenientNonExecutePrefixWithLeadingWhitespace",
        "testSkipTopLevelUnquotedString",
        "getLineNumber",
        "consumeNonExecutePrefix",
        "skipTo",
        "nextDouble"
      ],
      "functions_name_co_evolved_modified_file": [
        "peekNumber",
        "get"
      ],
      "functions_name_co_evolved_all_files": [
        "peekNumber",
        "disabled_testVeryLongNumber",
        "disabled_testNumberWithOctalPrefix",
        "testStrictVeryLongNumber",
        "testLenientVeryLongNumber",
        "disabled_testPeekLargerThanLongMaxValue",
        "testNumberWithOctalPrefix",
        "testPeekLargerThanLongMinValue",
        "get",
        "testMalformedNumbers",
        "disabled_testPeekLargerThanLongMinValue",
        "assertNotANumber",
        "testPeekLargerThanLongMaxValue"
      ]
    },
    "file": {
      "file_name": "JsonReader.java",
      "file_nloc": 1037,
      "file_complexity": 349,
      "file_token_count": 5593,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -624,83 +624,116 @@ public class JsonReader implements Closeable {\n     return peeked = peeking;\n   }\n \n+  private static final int NUMBER_CHAR_NONE = 0;\n+  private static final int NUMBER_CHAR_SIGN = 1;\n+  private static final int NUMBER_CHAR_DIGIT = 2;\n+  private static final int NUMBER_CHAR_DECIMAL = 3;\n+  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n+  private static final int NUMBER_CHAR_EXP_E = 5;\n+  private static final int NUMBER_CHAR_EXP_SIGN = 6;\n+  private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n+\n   private int peekNumber() throws IOException {\n+    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n+    char[] buffer = this.buffer;\n+    int p = pos;\n+    int l = limit;\n+\n     long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n     boolean negative = false;\n     boolean fitsInLong = true;\n-    int i = 0;\n-    int c = get(i);\n+    int last = NUMBER_CHAR_NONE;\n \n-    // TODO: figure out a way to speed up repopulating 'c'\n-\n-    if (c == '-') {\n-      negative = true;\n-      c = get(++i);\n-    }\n+    int i = 0;\n \n-    if (c == '0') {\n-      c = get(++i);\n-    } else if (c >= '1' && c <= '9') {\n-      value -= (c - '0');\n-      c = get(++i);\n-      while (c >= '0' && c <= '9') {\n-        long newValue = value * 10 - (c - '0');\n-        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n-            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n-        value = newValue;\n-        c = get(++i);\n+    charactersOfNumber:\n+    for (; true; i++) {\n+      if (p + i == l) {\n+        if (i == buffer.length) {\n+          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n+          // and let the application handle this as an unquoted literal.\n+          return PEEKED_NONE;\n+        }\n+        if (!fillBuffer(i + 1)) {\n+          break;\n+        }\n+        p = pos;\n+        l = limit;\n       }\n-    } else {\n-      return PEEKED_NONE;\n-    }\n \n-    if (c == -1 || !isLiteral((char) c)) {\n-      if (fitsInLong && (value != Long.MIN_VALUE || negative)) {\n-        peekedLong = negative ? value : -value;\n-        pos += i;\n-        return peeked = PEEKED_LONG;\n-      } else {\n-        peekedNumberLength = i;\n-        return peeked = PEEKED_NUMBER;\n-      }\n-    }\n+      char c = buffer[p + i];\n+      switch (c) {\n+      case '-':\n+        if (last == NUMBER_CHAR_NONE) {\n+          negative = true;\n+          last = NUMBER_CHAR_SIGN;\n+          continue;\n+        } else if (last == NUMBER_CHAR_EXP_E) {\n+          last = NUMBER_CHAR_EXP_SIGN;\n+          continue;\n+        }\n+        return PEEKED_NONE;\n \n-    if (c == '.') {\n-      c = get(++i);\n-      while (c >= '0' && c <= '9') {\n-        c = get(++i);\n-      }\n-    }\n+      case '+':\n+        if (last == NUMBER_CHAR_EXP_E) {\n+          last = NUMBER_CHAR_EXP_SIGN;\n+          continue;\n+        }\n+        return PEEKED_NONE;\n \n-    if (c == 'e' || c == 'E') {\n-      c = get(++i);\n-      if (c == '+' || c == '-') {\n-        c = get(++i);\n-      }\n-      if (c >= '0' && c <= '9') {\n-        c = get(++i);\n-        while (c >= '0' && c <= '9') {\n-          c = get(++i);\n+      case 'e':\n+      case 'E':\n+        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n+          last = NUMBER_CHAR_EXP_E;\n+          continue;\n+        }\n+        return PEEKED_NONE;\n+\n+      case '.':\n+        if (last == NUMBER_CHAR_DIGIT) {\n+          last = NUMBER_CHAR_DECIMAL;\n+          continue;\n         }\n-      } else {\n         return PEEKED_NONE;\n+\n+      default:\n+        if (c < '0' || c > '9') {\n+          if (!isLiteral(c)) {\n+            break charactersOfNumber;\n+          }\n+          return PEEKED_NONE;\n+        }\n+        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n+          value = -(c - '0');\n+          last = NUMBER_CHAR_DIGIT;\n+        } else if (last == NUMBER_CHAR_DIGIT) {\n+          if (value == 0) {\n+            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n+          }\n+          long newValue = value * 10 - (c - '0');\n+          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n+              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n+          value = newValue;\n+        } else if (last == NUMBER_CHAR_DECIMAL) {\n+          last = NUMBER_CHAR_FRACTION_DIGIT;\n+        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n+          last = NUMBER_CHAR_EXP_DIGIT;\n+        }\n       }\n     }\n \n-    if (c == -1 || !isLiteral((char) c)) {\n+    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+      peekedLong = negative ? value : -value;\n+      pos += i;\n+      return peeked = PEEKED_LONG;\n+    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n+        || last == NUMBER_CHAR_EXP_DIGIT) {\n       peekedNumberLength = i;\n       return peeked = PEEKED_NUMBER;\n+    } else {\n+      return PEEKED_NONE;\n     }\n-\n-    return PEEKED_NONE;\n-  }\n-\n-  /**\n-   * Returns a character at position {@code pos + offset}, reading additional\n-   * bytes into the buffer if necessary.\n-   */\n-  private int get(int offset) throws IOException {\n-    return (pos + offset < limit || fillBuffer(offset + 1)) ? buffer[pos + offset] : -1;\n   }\n \n   private boolean isLiteral(char c) throws IOException {\n",
      "files_name_in_blame_commit": [
        "JsonReader.java",
        "JsonReaderTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 61
  }
}
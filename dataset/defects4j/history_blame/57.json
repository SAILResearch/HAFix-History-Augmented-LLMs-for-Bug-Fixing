{
  "id": "57",
  "blame_commit": {
    "commit": {
      "commit_id": "a43e20295b3e40b5033a31c55a2e08d36a61b6e4",
      "commit_message": "Start work on #631 implementation",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2014-11-26 21:03:03",
      "commit_parent": "bf2855e444f44e12c4ed38e622721cd9d3172d5b"
    },
    "function": {
      "function_name": "deserializeUsingPropertyBasedWithExternalTypeId",
      "function_code_before": "",
      "function_code_after": "protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // first: let's check to see if this might be part of value with external type id:\n            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                ;\n            } else {\n                // Last creator property to set?\n                Object value = creatorProp.deserialize(p, ctxt);\n                if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; // never gets here\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); // to skip name\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return ext.complete(p, ctxt, bean);\n                }\n            }\n            continue;\n        }\n        // Object Id property?\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        // regular property? needs buffering\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        // external type id (or property that depends on it)?\n        if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n            continue;\n        }\n        /* As per [JACKSON-313], things marked as ignorable should not be\n         * passed to any setter\n         */\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        // \"any property\"?\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n\n    // We hit END_OBJECT; resolve the pieces:\n    try {\n        return ext.complete(p, ctxt, buffer, creator);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; // never gets here\n    }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 724,
      "function_after_end_line": 806,
      "function_before_token_count": 0,
      "function_after_token_count": 444,
      "functions_name_modified_file": [
        "deserializeWithExternalTypeId",
        "asArrayDeserializer",
        "_deserializeOther",
        "deserializeFromObject",
        "deserialize",
        "withObjectIdReader",
        "unwrappingDeserializer",
        "deserializeWithUnwrapped",
        "withIgnorableProperties",
        "vanillaDeserialize",
        "_deserializeUsingPropertyBased",
        "deserializeWithView",
        "BeanDeserializer",
        "_missingToken",
        "deserializeUsingPropertyBasedWithExternalTypeId",
        "deserializeUsingPropertyBasedWithUnwrapped"
      ],
      "functions_name_all_files": [
        "hasViews",
        "serializeDynamic",
        "getEmbeddedObject",
        "toString",
        "setCurrentValue",
        "deserializeFromEmbedded",
        "_deserializeUsingPropertyBased",
        "deserializeFromObjectId",
        "deserializeFromObjectUsingNonDefault",
        "_readAndBindStringMap",
        "serializeAsArray",
        "_deserializeNonVanilla",
        "_handleTypedObjectId",
        "getTextCharacters",
        "getCurrentLocation",
        "handleUnresolvedReference",
        "isUnwrappingSerializer",
        "findProperty",
        "createContextual",
        "MapDeserializer",
        "serializeFilteredFields",
        "deserializeWithUnwrapped",
        "serializeFields",
        "serializeFieldsUsing",
        "currentNode",
        "BeanDeserializer",
        "nextToken",
        "withObjectIdWriter",
        "getContentSerializer",
        "serializeOptionalFields",
        "asArraySerializer",
        "createDummy",
        "MapSerializer",
        "NodeCursor",
        "BeanDeserializerBase",
        "_resolveManagedReferenceProperty",
        "withIgnorableProperties",
        "serialize",
        "properties",
        "hasProperty",
        "_resolveInnerClassValuedProperty",
        "getContentDeserializer",
        "_deserializeWithCreator",
        "_readAndBind",
        "getValueType",
        "getText",
        "getCurrentName",
        "_handleEOF",
        "deserializeUsingPropertyBasedWithUnwrapped",
        "serializeTypedFields",
        "getDecimalValue",
        "getValueInstantiator",
        "skipChildren",
        "getKnownPropertyNames",
        "getCodec",
        "getBinaryValue",
        "finishBuild",
        "currentHasChildren",
        "_resolvedObjectIdProperty",
        "creatorProperties",
        "getNumberValue",
        "findConvertingDeserializer",
        "handleUnknownVanilla",
        "deserialize",
        "getObjectIdReader",
        "handleNonArray",
        "close",
        "MapReferring",
        "hasTextCharacters",
        "setCodec",
        "throwOrReturnThrowable",
        "MapEntrySerializer",
        "endToken",
        "BeanAsArraySerializer",
        "deserializeFromDouble",
        "TreeTraversingParser",
        "handleIgnoredProperty",
        "getLongValue",
        "put",
        "injectValues",
        "AsArraySerializerBase",
        "withContentInclusion",
        "setIgnorableProperties",
        "replaceProperty",
        "handledType",
        "handleResolvedForwardReference",
        "BeanAsArrayDeserializer",
        "handleUnknownProperty",
        "iterateChildren",
        "resolve",
        "deserializeFromBoolean",
        "version",
        "_deserializeOther",
        "deserializeFromObject",
        "_findSubclassDeserializer",
        "getContentType",
        "CollectionDeserializer",
        "_deserializeFromNonArray",
        "add",
        "deserializeWithObjectId",
        "getParent",
        "getDoubleValue",
        "findBackReference",
        "readBinaryValue",
        "isClosed",
        "getKeySerializer",
        "getCurrentValue",
        "withFilterId",
        "withIgnorals",
        "deserializeUsingPropertyBasedWithExternalTypeId",
        "deserializeFromString",
        "getIntValue",
        "getBeanClass",
        "ArraySerializerBase",
        "serializeUsing",
        "_convertObjectId",
        "getPropertyCount",
        "resolveForwardReference",
        "_missingToken",
        "getTextLength",
        "getParsingContext",
        "BeanAsArrayBuilderDeserializer",
        "deserializeFromNumber",
        "handleUnknownProperties",
        "CollectionReferringAccumulator",
        "deserializeWithExternalTypeId",
        "asArrayDeserializer",
        "RootCursor",
        "nextValue",
        "getFloatValue",
        "hasSingleElement",
        "withObjectIdReader",
        "getNumberType",
        "deserializeWithType",
        "_deserializeUsingCreator",
        "ObjectCursor",
        "serializeWithType",
        "getTokenLocation",
        "vanillaDeserialize",
        "deserializeWithView",
        "ArrayCursor",
        "isCachable",
        "getSchema",
        "getBigIntegerValue",
        "BeanSerializer",
        "getMapClass",
        "wrapAndThrow",
        "currentNumericNode",
        "_isStdKeyDeser",
        "_ensureOverride",
        "construct",
        "acceptJsonFormatVisitor",
        "_findAndAddDynamic",
        "_orderEntries",
        "withResolved",
        "overrideCurrentName",
        "isEmpty",
        "unwrappingDeserializer",
        "handlePolymorphic",
        "wrapInstantiationProblem",
        "MapReferringAccumulator",
        "_withValueTypeSerializer",
        "getTextOffset",
        "deserializeFromArray",
        "_resolveUnwrappedProperty",
        "unwrappingSerializer",
        "CollectionReferring"
      ],
      "functions_name_co_evolved_modified_file": [
        "deserializeWithExternalTypeId",
        "_deserializeOther",
        "deserializeFromObject",
        "deserialize",
        "deserializeWithUnwrapped",
        "_deserializeUsingPropertyBased",
        "vanillaDeserialize",
        "deserializeWithView",
        "_missingToken",
        "deserializeUsingPropertyBasedWithExternalTypeId",
        "deserializeUsingPropertyBasedWithUnwrapped"
      ],
      "functions_name_co_evolved_all_files": [
        "_deserializeOther",
        "deserializeFromObject",
        "_deserializeFromNonArray",
        "setCurrentValue",
        "finishBuild",
        "_deserializeUsingPropertyBased",
        "vanillaDeserialize",
        "deserializeWithView",
        "ArrayCursor",
        "serializeAsArray",
        "_deserializeNonVanilla",
        "serializeWithType",
        "deserialize",
        "getCurrentValue",
        "serializeFilteredFields",
        "handleNonArray",
        "deserializeWithUnwrapped",
        "serializeFields",
        "serializeFieldsUsing",
        "deserializeUsingPropertyBasedWithExternalTypeId",
        "serializeOptionalFields",
        "RootValue",
        "TreeTraversingParser",
        "serialize",
        "Array",
        "_missingToken",
        "deserializeWithExternalTypeId",
        "RootCursor",
        "iterateChildren",
        "_deserializeWithCreator",
        "deserializeWithType",
        "ObjectCursor",
        "deserializeUsingPropertyBasedWithUnwrapped",
        "Object"
      ]
    },
    "file": {
      "file_name": "BeanDeserializer.java",
      "file_nloc": 603,
      "file_complexity": 145,
      "file_token_count": 3819,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -108,58 +108,58 @@ public class BeanDeserializer\n      * like Afterburner change definition.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         // common case first:\n         if (t == JsonToken.START_OBJECT) {\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, jp.nextToken());\n+                return vanillaDeserialize(p, ctxt, p.nextToken());\n             }\n-            jp.nextToken();\n+            p.nextToken();\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n+                return deserializeWithObjectId(p, ctxt);\n             }\n-            return deserializeFromObject(jp, ctxt);\n+            return deserializeFromObject(p, ctxt);\n         }\n-        return _deserializeOther(jp, ctxt, t);\n+        return _deserializeOther(p, ctxt, t);\n     }\n \n-    protected final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt,\n+    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n             JsonToken t) throws IOException\n     {\n         // and then others, generally requiring use of @JsonCreator\n         switch (t) {\n         case VALUE_STRING:\n-            return deserializeFromString(jp, ctxt);\n+            return deserializeFromString(p, ctxt);\n         case VALUE_NUMBER_INT:\n-            return deserializeFromNumber(jp, ctxt);\n+            return deserializeFromNumber(p, ctxt);\n         case VALUE_NUMBER_FLOAT:\n-\t    return deserializeFromDouble(jp, ctxt);\n+\t    return deserializeFromDouble(p, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n-            return deserializeFromEmbedded(jp, ctxt);\n+            return deserializeFromEmbedded(p, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n-            return deserializeFromBoolean(jp, ctxt);\n+            return deserializeFromBoolean(p, ctxt);\n         case START_ARRAY:\n             // these only work if there's a (delegating) creator...\n-            return deserializeFromArray(jp, ctxt);\n+            return deserializeFromArray(p, ctxt);\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, t);\n+                return vanillaDeserialize(p, ctxt, t);\n             }\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n+                return deserializeWithObjectId(p, ctxt);\n             }\n-            return deserializeFromObject(jp, ctxt);\n+            return deserializeFromObject(p, ctxt);\n         default:\n             throw ctxt.mappingException(handledType());\n         }\n     }\n \n-    protected Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n+    protected Object _missingToken(JsonParser p, DeserializationContext ctxt)\n         throws JsonProcessingException\n     {\n         throw ctxt.endOfInputException(handledType());\n@@ -171,44 +171,46 @@ public class BeanDeserializer\n      * after collecting some or all of the properties to set.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n     {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         if (_unwrappedPropertyHandler != null) {\n-            return deserializeWithUnwrapped(jp, ctxt, bean);\n+            return deserializeWithUnwrapped(p, ctxt, bean);\n         }\n         if (_externalTypeIdHandler != null) {\n-            return deserializeWithExternalTypeId(jp, ctxt, bean);\n+            return deserializeWithExternalTypeId(p, ctxt, bean);\n         }\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n+            t = p.nextToken();\n         }\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n+                return deserializeWithView(p, ctxt, bean, view);\n             }\n         }\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             \n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n@@ -223,24 +225,26 @@ public class BeanDeserializer\n      * Streamlined version that is only used when no \"special\"\n      * features are enabled.\n      */\n-    private final Object vanillaDeserialize(JsonParser jp,\n+    private final Object vanillaDeserialize(JsonParser p,\n     \t\tDeserializationContext ctxt, JsonToken t)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             } else {\n-                handleUnknownVanilla(jp, ctxt, bean, propName);\n+                handleUnknownVanilla(p, ctxt, bean, propName);\n             }\n         }\n         return bean;\n@@ -251,17 +255,16 @@ public class BeanDeserializer\n      * features.\n      */\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_nonStandardCreation) {\n             if (_unwrappedPropertyHandler != null) {\n-                return deserializeWithUnwrapped(jp, ctxt);\n+                return deserializeWithUnwrapped(p, ctxt);\n             }\n             if (_externalTypeIdHandler != null) {\n-                return deserializeWithExternalTypeId(jp, ctxt);\n+                return deserializeWithExternalTypeId(p, ctxt);\n             }\n-            Object bean = deserializeFromObjectUsingNonDefault(jp, ctxt);\n+            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n             if (_injectables != null) {\n                 injectValues(ctxt, bean);\n             }\n@@ -280,10 +283,12 @@ public class BeanDeserializer\n             return bean;\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        if (jp.canReadObjectId()) {\n-            Object id = jp.getObjectId();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+        if (p.canReadObjectId()) {\n+            Object id = p.getObjectId();\n             if (id != null) {\n-                _handleTypedObjectId(jp, ctxt, bean, id);\n+                _handleTypedObjectId(p, ctxt, bean, id);\n             }\n         }\n         if (_injectables != null) {\n@@ -292,24 +297,24 @@ public class BeanDeserializer\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n+                return deserializeWithView(p, ctxt, bean, view);\n             }\n         }\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n@@ -324,26 +329,26 @@ public class BeanDeserializer\n      */\n     @Override\n     @SuppressWarnings(\"resource\")\n-    protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n+    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n         throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n         \n         // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n         TokenBuffer unknown = null;\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n@@ -354,15 +359,18 @@ public class BeanDeserializer\n                     if (bean == null) {\n                         throw ctxt.instantiationException(_beanType.getRawClass(), \"JSON Creator returned null\");\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+\n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n-                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                        return handlePolymorphic(p, ctxt, bean, unknown);\n                     }\n                     if (unknown != null) { // nope, just extra unknown stuff...\n                         bean = handleUnknownProperties(ctxt, bean, unknown);\n                     }\n                     // or just clean?\n-                    return deserialize(jp, ctxt, bean);\n+                    return deserialize(p, ctxt, bean);\n                 }\n                 continue;\n             }\n@@ -373,26 +381,26 @@ public class BeanDeserializer\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // As per [JACKSON-313], things marked as ignorable should not be\n             // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                 continue;\n             }\n             // Ok then, let's collect the whole field; name and value\n             if (unknown == null) {\n-                unknown = new TokenBuffer(jp);\n+                unknown = new TokenBuffer(p);\n             }\n             unknown.writeFieldName(propName);\n-            unknown.copyCurrentStructure(jp);\n+            unknown.copyCurrentStructure(p);\n         }\n         \n         // We hit END_OBJECT, so:\n@@ -420,29 +428,29 @@ public class BeanDeserializer\n     /**********************************************************\n      */\n     \n-    protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt,\n+    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n             Object bean, Class<?> activeView)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n                 if (!prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n@@ -458,34 +466,37 @@ public class BeanDeserializer\n      * which need special handling\n      */\n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n+            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n         }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n \n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n@@ -493,16 +504,16 @@ public class BeanDeserializer\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n@@ -510,75 +521,75 @@ public class BeanDeserializer\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n     {\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n+            t = p.nextToken();\n         }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n-            jp.nextToken();\n+            p.nextToken();\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n@@ -586,11 +597,13 @@ public class BeanDeserializer\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n-                        jp.nextToken(); // to skip name\n-                        tokens.copyCurrentStructure(jp);\n-                        t = jp.nextToken();\n+                        p.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(p);\n+                        t = p.nextToken();\n                     }\n                     tokens.writeEndObject();\n                     if (bean.getClass() != _beanType.getRawClass()) {\n@@ -599,7 +612,7 @@ public class BeanDeserializer\n                         tokens.close();\n                         throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                     }\n-                    return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                 }\n                 continue;\n             }\n@@ -610,21 +623,21 @@ public class BeanDeserializer\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n@@ -636,7 +649,7 @@ public class BeanDeserializer\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n         }\n-        return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n     }\n \n     /*\n@@ -646,37 +659,37 @@ public class BeanDeserializer\n     /**********************************************************\n      */\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt);\n+            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n         }\n-        return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n+        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n     }\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt,\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n             Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 // [JACKSON-831]: may have property AND be used as external type id:\n-                if (jp.getCurrentToken().isScalarValue()) {\n-                    ext.handleTypePropertyValue(jp, ctxt, propName, bean);\n+                if (p.getCurrentToken().isScalarValue()) {\n+                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                 }\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n@@ -684,55 +697,55 @@ public class BeanDeserializer\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n-            if (ext.handlePropertyValue(jp, ctxt, propName, bean)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                 continue;\n             }\n             // if not, the usual fallback handling:\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             // Unknown: let's call handler method\n-            handleUnknownProperty(jp, ctxt, bean, propName);         \n+            handleUnknownProperty(p, ctxt, bean, propName);         \n         }\n         // and when we get this far, let's try finalizing the deal:\n-        return ext.complete(jp, ctxt, bean);\n+        return ext.complete(p, ctxt, bean);\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n-                if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n-                    Object value = creatorProp.deserialize(jp, ctxt);\n+                    Object value = creatorProp.deserialize(p, ctxt);\n                     if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                        t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                         Object bean;\n                         try {\n                             bean = creator.build(ctxt, buffer);\n@@ -742,16 +755,16 @@ public class BeanDeserializer\n                         }\n                         // if so, need to copy all remaining tokens into buffer\n                         while (t == JsonToken.FIELD_NAME) {\n-                            jp.nextToken(); // to skip name\n-                            tokens.copyCurrentStructure(jp);\n-                            t = jp.nextToken();\n+                            p.nextToken(); // to skip name\n+                            tokens.copyCurrentStructure(p);\n+                            t = p.nextToken();\n                         }\n                         if (bean.getClass() != _beanType.getRawClass()) {\n                             // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                             //   it's too complicated, so bail out\n                             throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                         }\n-                        return ext.complete(jp, ctxt, bean);\n+                        return ext.complete(p, ctxt, bean);\n                     }\n                 }\n                 continue;\n@@ -763,29 +776,29 @@ public class BeanDeserializer\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // external type id (or property that depends on it)?\n-            if (ext.handlePropertyValue(jp, ctxt, propName, null)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n         // We hit END_OBJECT; resolve the pieces:\n         try {\n-            return ext.complete(jp, ctxt, buffer, creator);\n+            return ext.complete(p, ctxt, buffer, creator);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n",
      "files_name_in_blame_commit": [
        "BeanDeserializer.java",
        "BeanSerializer.java",
        "BeanAsArrayDeserializer.java",
        "NodeCursor.java",
        "MapDeserializer.java",
        "CollectionDeserializer.java",
        "MapEntrySerializer.java",
        "BeanDeserializerBase.java",
        "TreeTraversingParser.java",
        "BeanAsArraySerializer.java",
        "BeanAsArrayBuilderDeserializer.java",
        "AsArraySerializerBase.java",
        "ArraySerializerBase.java",
        "MapSerializer.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 92
  }
}
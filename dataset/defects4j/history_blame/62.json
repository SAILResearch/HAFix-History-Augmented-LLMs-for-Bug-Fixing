{
  "id": "62",
  "blame_commit": {
    "commit": {
      "commit_id": "88059ceade45ce60f30c094ac01b70b71b5f09ae",
      "commit_message": "... round and round. Remove specialized 1/2/3 property variants, mildy faster",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2015-03-22 22:43:39",
      "commit_parent": "478b744a037318e3b14dc1f5b7355c5061c05e53"
    },
    "function": {
      "function_name": "remove",
      "function_code_before": "",
      "function_code_after": "public void remove(SettableBeanProperty propToRm) {\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            found = key.equals(prop.getName());\n            if (found) {\n                // need to leave a hole here\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 334,
      "function_after_end_line": 358,
      "function_before_token_count": 0,
      "function_after_token_count": 151,
      "functions_name_modified_file": [
        "_hashCode",
        "toString",
        "getPropertyName",
        "_find2",
        "getPropertiesInInsertionOrder",
        "_rename",
        "wrapAndThrow",
        "BeanPropertyMap",
        "renameAll",
        "find",
        "construct",
        "replace",
        "findDeserializeAndSet",
        "size",
        "_findFromOrdered",
        "assignIndexes",
        "iterator",
        "properties",
        "init",
        "findSize",
        "withProperty",
        "remove"
      ],
      "functions_name_all_files": [
        "_hashCode",
        "toString",
        "getPropertyName",
        "_find2",
        "getPropertiesInInsertionOrder",
        "_rename",
        "wrapAndThrow",
        "BeanPropertyMap",
        "renameAll",
        "find",
        "construct",
        "replace",
        "findDeserializeAndSet",
        "size",
        "_findFromOrdered",
        "assignIndexes",
        "iterator",
        "properties",
        "init",
        "findSize",
        "withProperty",
        "remove"
      ],
      "functions_name_co_evolved_modified_file": [
        "_hashCode",
        "toString",
        "getPropertyName",
        "Small",
        "_find2",
        "getPropertiesInInsertionOrder",
        "_renameAll",
        "BeanPropertyMap",
        "renameAll",
        "find",
        "construct",
        "replace",
        "findDeserializeAndSet",
        "_findFromSpill",
        "size",
        "_findFromOrdered",
        "assignIndexes",
        "Default",
        "iterator",
        "properties",
        "init",
        "findSize",
        "_findWithEquals",
        "withProperty",
        "remove"
      ],
      "functions_name_co_evolved_all_files": [
        "_hashCode",
        "toString",
        "getPropertyName",
        "Small",
        "_find2",
        "getPropertiesInInsertionOrder",
        "_renameAll",
        "BeanPropertyMap",
        "renameAll",
        "find",
        "construct",
        "replace",
        "findDeserializeAndSet",
        "_findFromSpill",
        "size",
        "_findFromOrdered",
        "assignIndexes",
        "Default",
        "iterator",
        "properties",
        "init",
        "findSize",
        "_findWithEquals",
        "withProperty",
        "remove"
      ]
    },
    "file": {
      "file_name": "BeanPropertyMap.java",
      "file_nloc": 327,
      "file_complexity": 85,
      "file_token_count": 2225,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -24,7 +24,7 @@ import com.fasterxml.jackson.databind.util.NameTransformer;\n  * matter since this is directly on the critical path during deserialization,\n  * as it is done for each and every POJO property deserialized.\n  */\n-public abstract class BeanPropertyMap\n+public class BeanPropertyMap\n     implements Iterable<SettableBeanProperty>,\n         java.io.Serializable\n {\n@@ -35,28 +35,103 @@ public abstract class BeanPropertyMap\n      */\n     protected final boolean _caseInsensitive;\n \n-    protected BeanPropertyMap(boolean caseInsensitive)\n+    private int _hashMask;\n+\n+    /**\n+     * Number of entries stored in the hash area.\n+     */\n+    private int _size;\n+    \n+    private int _spillCount;\n+\n+    /**\n+     * Hash area that contains key/property pairs in adjacent elements.\n+     */\n+    private Object[] _hashArea;\n+\n+    /**\n+     * Array of properties in the exact order they were handed in. This is\n+     * used by as-array serialization, deserialization.\n+     */\n+    private SettableBeanProperty[] _propsInOrder;\n+\n+    public BeanPropertyMap(boolean caseInsensitive, Collection<SettableBeanProperty> props)\n     {\n         _caseInsensitive = caseInsensitive;\n+        _propsInOrder = props.toArray(new SettableBeanProperty[props.size()]);\n+        init(props);\n     }\n+    \n+    protected void init(Collection<SettableBeanProperty> props)\n+    {\n+        _size = props.size();\n+        \n+        // First: calculate size of primary hash area\n+        final int size = findSize(_size);\n+        _hashMask = size-1;\n+\n+        // and allocate enough to contain primary/secondary, expand for spillovers as need be\n+        int alloc = (size + (size>>1)) * 2;\n+        Object[] hashed = new Object[alloc];\n+        int spillCount = 0;\n \n+        for (SettableBeanProperty prop : props) {\n+            // Due to removal, renaming, theoretically possible we'll have \"holes\" so:\n+            if (prop == null) {\n+                continue;\n+            }\n+            \n+            String key = getPropertyName(prop);\n+            int slot = _hashCode(key);\n+            int ix = (slot<<1);\n+\n+            // primary slot not free?\n+            if (hashed[ix] != null) {\n+                // secondary?\n+                ix = (size + (slot >> 1)) << 1;\n+                if (hashed[ix] != null) {\n+                    // ok, spill over.\n+                    ix = ((size + (size >> 1) ) << 1) + spillCount;\n+                    spillCount += 2;\n+                    if (ix >= hashed.length) {\n+                        hashed = Arrays.copyOf(hashed, hashed.length + 4);\n+                    }\n+                }\n+            }\n+//System.err.println(\" add '\"+key+\" at #\"+(ix>>1)+\"/\"+size+\" (hashed at \"+slot+\")\");             \n+            hashed[ix] = key;\n+            hashed[ix+1] = prop;\n+        }\n+/*\n+for (int i = 0; i < hashed.length; i += 2) {\n+System.err.printf(\"#%02d: %s\\n\", i>>1, (hashed[i] == null) ? \"-\" : hashed[i]);\n+}\n+*/\n+        _hashArea = hashed;\n+        _spillCount = spillCount;\n+    }\n+    \n+    private final static int findSize(int size)\n+    {\n+        if (size <= 5) {\n+            return 8;\n+        }\n+        if (size <= 12) {\n+            return 16;\n+        }\n+        int needed = size + (size >> 2); // at most 80% full\n+        int result = 32;\n+        while (result < needed) {\n+            result += result;\n+        }\n+        return result;\n+    }\n+    \n     /**\n      * @since 2.6\n      */\n     public static BeanPropertyMap construct(Collection<SettableBeanProperty> props, boolean caseInsensitive) {\n-        if (props.isEmpty()) {\n-            return new Small(caseInsensitive);\n-        }\n-        Iterator<SettableBeanProperty> it = props.iterator();\n-        switch (props.size()) {\n-        case 1:\n-            return new Small(caseInsensitive, it.next());\n-        case 2:\n-            return new Small(caseInsensitive, it.next(), it.next());\n-        case 3:\n-            return new Small(caseInsensitive, it.next(), it.next(), it.next());\n-        }\n-        return new Default(caseInsensitive, props);\n+        return new BeanPropertyMap(caseInsensitive, props);\n     }\n     \n     /**\n@@ -68,9 +143,61 @@ public abstract class BeanPropertyMap\n      * \n      * @since 2.0\n      */\n-    public abstract BeanPropertyMap withProperty(SettableBeanProperty newProperty);\n+    public BeanPropertyMap withProperty(SettableBeanProperty newProp)\n+    {\n+        // First: may be able to just replace?\n+        String key = getPropertyName(newProp);\n+\n+        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n+            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n+            if ((prop != null) && prop.getName().equals(key)) {\n+                _hashArea[i] = newProp;\n+                _propsInOrder[_findFromOrdered(prop)] = newProp;\n+                return this;\n+            }\n+        }\n+        // If not, append\n+        int slot = _hashCode(key);\n+        int hashSize = _hashMask+1;\n+\n+        // primary slot not free?\n+        if (_hashArea[slot << 1] != null) {\n+            // secondary?\n+            slot = hashSize + (slot >> 1);\n+            if (_hashArea[slot << 1] != null) {\n+                // ok, spill over.\n+                slot = hashSize + (hashSize >> 1) + _spillCount;\n+                _spillCount += 2;\n+                if ((slot << 1) >= _hashArea.length) {\n+                    _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);\n+                }\n+            }\n+        }\n+        int ix = slot << 1;\n+        _hashArea[ix] = key;\n+        _hashArea[ix+1] = newProp;\n+\n+        int last = _propsInOrder.length;\n+        _propsInOrder = Arrays.copyOf(_propsInOrder, last+1);\n+        _propsInOrder[last] = newProp;\n \n-    public abstract BeanPropertyMap assignIndexes();\n+        // should we just create a new one? Or is resetting ok?\n+        \n+        return this;\n+    }\n+\n+    public BeanPropertyMap assignIndexes()\n+    {\n+        // order is arbitrary, but stable:\n+        int index = 0;\n+        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n+            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n+            if (prop != null) {\n+                prop.assignIndex(index++);\n+            }\n+        }\n+        return this;\n+    }\n \n     /**\n      * Factory method for constructing a map where all entries use given\n@@ -81,50 +208,62 @@ public abstract class BeanPropertyMap\n         if (transformer == null || (transformer == NameTransformer.NOP)) {\n             return this;\n         }\n-        return _renameAll(transformer);\n-    }\n+        // Try to retain insertion ordering as well\n+        final int len = _propsInOrder.length;\n+        ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(len);\n \n-    protected abstract BeanPropertyMap _renameAll(NameTransformer transformer);\n-\n-    // Confining this case insensitivity to this function (and the find method) in case we want to\n-    // apply a particular locale to the lower case function.  For now, using the default.\n-    protected final String getPropertyName(SettableBeanProperty prop) {\n-        return _caseInsensitive ? prop.getName().toLowerCase() : prop.getName();\n+        for (int i = 0; i < len; ++i) {\n+            SettableBeanProperty prop = _propsInOrder[i];\n+            \n+            // What to do with holes? For now, retain\n+            if (prop == null) {\n+                newProps.add(prop);\n+                continue;\n+            }\n+            newProps.add(_rename(prop, transformer));\n+        }\n+        // should we try to re-index? Ordering probably changed but caller probably doesn't want changes...\n+        return new BeanPropertyMap(_caseInsensitive, newProps);\n     }\n \n-    /*\n-    /**********************************************************\n-    /* Iterable, for convenient iterating over all properties\n-    /**********************************************************\n+    /**\n+     * Specialized method that can be used to replace an existing entry\n+     * (note: entry MUST exist; otherwise exception is thrown) with\n+     * specified replacement.\n      */\n-\n-    @Override\n-    public String toString()\n+    public void replace(SettableBeanProperty newProp)\n     {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"Properties=[\");\n-        int count = 0;\n+        String key = getPropertyName(newProp);\n+        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n+            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n+            if ((prop != null) && prop.getName().equals(key)) {\n+                _hashArea[i] = newProp;\n+                // also, replace in in-order\n+                _propsInOrder[_findFromOrdered(prop)] = newProp;\n+                return;\n+            }\n+        }\n+        throw new NoSuchElementException(\"No entry '\"+newProp.getName()+\"' found, can't replace\");\n+    }\n \n-        Iterator<SettableBeanProperty> it = iterator();\n-        while (it.hasNext()) {\n-            SettableBeanProperty prop = it.next();\n-            if (count++ > 0) {\n-                sb.append(\", \");\n+    private List<SettableBeanProperty> properties() {\n+        ArrayList<SettableBeanProperty> p = new ArrayList<SettableBeanProperty>(_size);\n+        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n+            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n+            if (prop != null) {\n+                p.add(prop);\n             }\n-            sb.append(prop.getName());\n-            sb.append('(');\n-            sb.append(prop.getType());\n-            sb.append(')');\n         }\n-        sb.append(']');\n-        return sb.toString();\n+        return p;\n     }\n \n     /**\n      * Accessor for traversing over all contained properties.\n      */\n     @Override\n-    public abstract Iterator<SettableBeanProperty> iterator();\n+    public Iterator<SettableBeanProperty> iterator() {\n+        return properties().iterator();\n+    }\n \n     /**\n      * Method that will re-create initial insertion-ordering of\n@@ -134,7 +273,51 @@ public abstract class BeanPropertyMap\n      * \n      * @since 2.1\n      */\n-    public abstract SettableBeanProperty[] getPropertiesInInsertionOrder();\n+    public SettableBeanProperty[] getPropertiesInInsertionOrder() {\n+        return _propsInOrder;\n+    }\n+\n+    // Confining this case insensitivity to this function (and the find method) in case we want to\n+    // apply a particular locale to the lower case function.  For now, using the default.\n+    protected final String getPropertyName(SettableBeanProperty prop) {\n+        return _caseInsensitive ? prop.getName().toLowerCase() : prop.getName();\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public SettableBeanProperty find(int index)\n+    {\n+        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n+            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n+            if ((prop != null) && (index == prop.getPropertyIndex())) {\n+                return prop;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public SettableBeanProperty find(String key)\n+    {\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"Can not pass null property name\");\n+        }\n+        if (_caseInsensitive) {\n+            key = key.toLowerCase();\n+        }\n+\n+        // inlined `_hashCode(key)`\n+        int slot = key.hashCode() & _hashMask;\n+//        int h = key.hashCode();\n+//        int slot = (h + (h >> 13)) & _hashMask;\n+\n+        int ix = (slot<<1);\n+        Object match = _hashArea[ix];\n+        if ((match == key) || key.equals(match)) {\n+            return (SettableBeanProperty) _hashArea[ix+1];\n+        }\n+        return _find2(key, slot, match);\n+    }\n \n     /*\n     /**********************************************************\n@@ -142,9 +325,37 @@ public abstract class BeanPropertyMap\n     /**********************************************************\n      */\n \n-    public abstract int size();\n+    public int size() { return _size; }\n+\n+    /**\n+     * Specialized method for removing specified existing entry.\n+     * NOTE: entry MUST exist, otherwise an exception is thrown.\n+     */\n+    public void remove(SettableBeanProperty propToRm) {\n+        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n+        String key = getPropertyName(propToRm);\n+        boolean found = false;\n \n-    public abstract SettableBeanProperty find(String key);\n+        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n+            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n+            if (prop == null) {\n+                continue;\n+            }\n+            if (!found) {\n+                found = key.equals(prop.getName());\n+                if (found) {\n+                    // need to leave a hole here\n+                    _propsInOrder[_findFromOrdered(prop)] = null;\n+                    continue;\n+                }\n+            }\n+            props.add(prop);\n+        }\n+        if (!found) {\n+            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n+        }\n+        init(props);\n+    }\n \n     /**\n      * Convenience method that tries to find property with given name, and\n@@ -155,31 +366,43 @@ public abstract class BeanPropertyMap\n      * \n      * @since 2.5\n      */\n-    public abstract boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n-            Object bean, String key) throws IOException;\n-\n-    /**\n-     * @since 2.3\n-     */\n-    public abstract SettableBeanProperty find(int propertyIndex);\n-\n-    /**\n-     * Specialized method that can be used to replace an existing entry\n-     * (note: entry MUST exist; otherwise exception is thrown) with\n-     * specified replacement.\n-     */\n-    public void replace(SettableBeanProperty property) {\n-        throw new NoSuchElementException(\"No entry '\"+property.getName()+\"' found, can't replace\");\n+    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n+            Object bean, String key) throws IOException\n+    {\n+        final SettableBeanProperty prop = find(key);\n+        if (prop == null) {\n+            return false;\n+        }\n+        try {\n+            prop.deserializeAndSet(p, ctxt, bean);\n+        } catch (Exception e) {\n+            wrapAndThrow(e, bean, key, ctxt);\n+        }\n+        return true;\n     }\n \n-    /**\n-     * Specialized method for removing specified existing entry.\n-     * NOTE: entry MUST exist, otherwise an exception is thrown.\n-     */\n-    public void remove(SettableBeanProperty property) {\n-        throw new NoSuchElementException(\"No entry '\"+property.getName()+\"' found, can't remove\");\n-    }\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Properties=[\");\n+        int count = 0;\n \n+        Iterator<SettableBeanProperty> it = iterator();\n+        while (it.hasNext()) {\n+            SettableBeanProperty prop = it.next();\n+            if (count++ > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(prop.getName());\n+            sb.append('(');\n+            sb.append(prop.getType());\n+            sb.append(')');\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n@@ -230,610 +453,49 @@ public abstract class BeanPropertyMap\n         }\n         throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Implementations\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Note on implementation: can not make most fields final because of 'remove'\n-     * operation.\n-     */\n-    protected static class Small\n-        extends BeanPropertyMap\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        protected String key1, key2, key3;\n-\n-        protected SettableBeanProperty prop1, prop2, prop3;\n-\n-        protected int size;\n-\n-        public Small(boolean caseInsensitive) {\n-            super(caseInsensitive);\n-            size = 0;\n-            key1 = key2 = key3 = null;\n-            prop1 = prop2 = prop3 = null;\n-        }\n-\n-        public Small(boolean caseInsensitive, SettableBeanProperty p1) {\n-            this(caseInsensitive, 1, p1, null, null);\n-        }\n-\n-        public Small(boolean caseInsensitive, SettableBeanProperty p1, SettableBeanProperty p2) {\n-            this(caseInsensitive, 2, p1, p2, null);\n-        }\n-\n-        public Small(boolean caseInsensitive, SettableBeanProperty p1, SettableBeanProperty p2, SettableBeanProperty p3) {\n-            this(caseInsensitive, 3, p1, p2, p3);\n-        }\n-\n-        protected Small(boolean caseInsensitive, int sz,\n-                SettableBeanProperty p1, SettableBeanProperty p2, SettableBeanProperty p3) {\n-            super(caseInsensitive);\n-            size = sz;\n-            prop1 = p1;\n-            key1 = (p1 == null) ? null : getPropertyName(p1);\n-            prop2 = p2;\n-            key2 = (p2 == null) ? null : getPropertyName(p2);\n-            prop3 = p3;\n-            key3 = (p3 == null) ? null : getPropertyName(p3);\n-        }\n-        \n-        @Override\n-        protected BeanPropertyMap _renameAll(NameTransformer transformer)\n-        {\n-            if (size == 0) {\n-                return this;\n-            }\n-            return new Small(_caseInsensitive, size,\n-                    _rename(prop1, transformer),\n-                    _rename(prop2, transformer),\n-                    _rename(prop3, transformer));\n-        }\n-        \n-        @Override\n-        public BeanPropertyMap withProperty(SettableBeanProperty prop)\n-        {\n-            final String key = getPropertyName(prop);\n-            // First: replace existing one?\n-            switch (size) {\n-            case 3:\n-                if (key.equals(key3)) {\n-                    prop3 = prop;\n-                    return this;\n-                }\n-            case 2:\n-                if (key.equals(key2)) {\n-                    prop2 = prop;\n-                    return this;\n-                }\n-            case 1:\n-                if (key.equals(key1)) {\n-                    prop1 = prop;\n-                    return this;\n-                }\n-            }\n-\n-            // If not, append. Easy if we aren't yet full\n-            switch (size) {\n-            case 2:\n-                return new Small(_caseInsensitive, prop1, prop2, prop);\n-            case 1:\n-                return new Small(_caseInsensitive, prop1, prop);\n-            case 0:\n-                return new Small(_caseInsensitive, prop);\n-            }\n-            // But if we have all 3, \"upgrade\"\n-            prop.assignIndex(3);\n-            List<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(4);\n-            props.add(prop1);\n-            props.add(prop2);\n-            props.add(prop3);\n-            props.add(prop);\n-            return new Default(_caseInsensitive, props);\n-        }\n-\n-        @Override\n-        public BeanPropertyMap assignIndexes() {\n-            int ix = 0;\n-            if (prop1 != null) {\n-                prop1.assignIndex(ix++);\n-            }\n-            if (prop2 != null) {\n-                prop2.assignIndex(ix++);\n-            }\n-            if (prop3 != null) {\n-                prop3.assignIndex(ix++);\n-            }\n-            return this;\n-        }\n-\n-        @Override\n-        public Iterator<SettableBeanProperty> iterator() {\n-            if (size == 0) {\n-                return Collections.<SettableBeanProperty>emptyList().iterator();\n-            }\n-            if (size == 1) {\n-                return Collections.singleton(prop1).iterator();\n-            }\n-            ArrayList<SettableBeanProperty> list = new ArrayList<SettableBeanProperty>();\n-            list.add(prop1);\n-            list.add(prop2);\n-            if (size > 2) {\n-                list.add(prop3);\n-            }\n-            return list.iterator();\n-        }\n-\n-        @Override\n-        public SettableBeanProperty[] getPropertiesInInsertionOrder() {\n-            SettableBeanProperty[] props = new SettableBeanProperty[size];\n-            switch (size) {\n-            case 3:\n-                props[2] = prop3;\n-            case 2:\n-                props[1] = prop2;\n-            case 1:\n-                props[0] = prop1;\n-            }\n-            return props;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return size;\n-        }\n-\n-        @Override\n-        public SettableBeanProperty find(String key) {\n-            if (_caseInsensitive) {\n-                key = key.toLowerCase();\n-            }\n-            if (key == key1) return prop1;\n-            if (key == key2) return prop2;\n-            if (key == key3) return prop3;\n-            return _findWithEquals(key);\n-        }\n-\n-        private SettableBeanProperty _findWithEquals(String key) {\n-            if (key.equals(key1)) return prop1;\n-            if (key.equals(key2)) return prop2;\n-            if (key.equals(key3)) return prop3;\n-            return null;\n-        }\n         \n-        @Override\n-        public boolean findDeserializeAndSet(JsonParser p,\n-                DeserializationContext ctxt, Object bean, String key) throws IOException {\n-            if (_caseInsensitive) {\n-                key = key.toLowerCase();\n-            }\n-            SettableBeanProperty prop = find(key);\n-            if (prop != null) {\n-                try {\n-                    prop.deserializeAndSet(p, ctxt, bean);\n-                } catch (Exception e) {\n-                    wrapAndThrow(e, bean, key, ctxt);\n-                }\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public SettableBeanProperty find(int index) {\n-            switch (size) {\n-            case 3:\n-                if (prop3.getPropertyIndex() == index) return prop3;\n-            case 2:\n-                if (prop2.getPropertyIndex() == index) return prop2;\n-            case 1:\n-                if (prop1.getPropertyIndex() == index) return prop1;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void replace(SettableBeanProperty prop) {\n-            final String key = prop.getName();\n-            switch (size) {\n-            case 3:\n-                if (key.equals(key3)) {\n-                    prop3 = prop;\n-                    return;\n-                }\n-            case 2:\n-                if (key.equals(key2)) {\n-                    prop2 = prop;\n-                    return;\n-                }\n-            case 1:\n-                if (key.equals(key1)) {\n-                    prop1 = prop;\n-                    return;\n-                }\n-            }\n-            super.replace(prop);\n-        }\n-\n-        @Override\n-        public void remove(SettableBeanProperty prop) {\n-            final String key = prop.getName();\n-            switch (size) {\n-            case 3:\n-                if (key.equals(key3)) {\n-                    prop3 = null;\n-                    key3 = null;\n-                    size = 2;\n-                    return;\n-                }\n-            case 2:\n-                if (key.equals(key2)) {\n-                    prop2 = prop3;\n-                    key2 = key3;\n-                    --size;\n-                    return;\n-                }\n-            case 1:\n-                if (key.equals(key1)) {\n-                    prop1 = prop2;\n-                    key1 = key2;\n-                    prop2 = prop3;\n-                    key2 = key3;\n-                    --size;\n-                    return;\n-                }\n-            }\n-            super.remove(prop);\n-        }\n-    }\n-\n-    /**\n-     * For non-trivial number of properties let's use a hash map.\n-     * Alas, can not use {@link com.fasterxml.jackson.databind.util.CompactStringObjectMap}\n-     * as is (need to add index), but structure is similar.\n-     */\n-    protected final static class Default extends BeanPropertyMap\n+    private final SettableBeanProperty _find2(String key, int slot, Object match)\n     {\n-        private static final long serialVersionUID = 1L;\n-\n-        private int _hashMask;\n-\n-        /**\n-         * Number of entries stored in the hash area.\n-         */\n-        private int _size;\n-        \n-        private int _spillCount;\n-\n-        /**\n-         * Hash area that contains key/property pairs in adjacent elements.\n-         */\n-        private Object[] _hashArea;\n-\n-        /**\n-         * Array of properties in the exact order they were handed in. This is\n-         * used by as-array serialization, deserialization.\n-         */\n-        private SettableBeanProperty[] _propsInOrder;\n-\n-        public Default(boolean caseInsensitive, Collection<SettableBeanProperty> props)\n-        {\n-            super(caseInsensitive);\n-            _propsInOrder = props.toArray(new SettableBeanProperty[props.size()]);\n-            init(props);\n-        }\n-        \n-        protected void init(Collection<SettableBeanProperty> props)\n-        {\n-            _size = props.size();\n-            \n-            // First: calculate size of primary hash area\n-            final int size = findSize(_size);\n-            _hashMask = size-1;\n-\n-            // and allocate enough to contain primary/secondary, expand for spillovers as need be\n-            int alloc = (size + (size>>1)) * 2;\n-            Object[] hashed = new Object[alloc];\n-            int spillCount = 0;\n-\n-            for (SettableBeanProperty prop : props) {\n-                // Due to removal, renaming, theoretically possible we'll have \"holes\" so:\n-                if (prop == null) {\n-                    continue;\n-                }\n-                \n-                String key = getPropertyName(prop);\n-                int slot = _hashCode(key);\n-                int ix = (slot<<1);\n-\n-                // primary slot not free?\n-                if (hashed[ix] != null) {\n-                    // secondary?\n-                    ix = (size + (slot >> 1)) << 1;\n-                    if (hashed[ix] != null) {\n-                        // ok, spill over.\n-                        ix = ((size + (size >> 1) ) << 1) + spillCount;\n-                        spillCount += 2;\n-                        if (ix >= hashed.length) {\n-                            hashed = Arrays.copyOf(hashed, hashed.length + 4);\n-                        }\n-                    }\n-                }\n-//System.err.println(\" add '\"+key+\" at #\"+(ix>>1)+\"/\"+size+\" (hashed at \"+slot+\")\");             \n-                hashed[ix] = key;\n-                hashed[ix+1] = prop;\n-            }\n-/*\n-for (int i = 0; i < hashed.length; i += 2) {\n-    System.err.printf(\"#%02d: %s\\n\", i>>1, (hashed[i] == null) ? \"-\" : hashed[i]);\n-}\n-*/\n-            _hashArea = hashed;\n-            _spillCount = spillCount;\n-        }\n-\n-        private final static int findSize(int size)\n-        {\n-            if (size <= 5) {\n-                return 8;\n-            }\n-            if (size <= 12) {\n-                return 16;\n-            }\n-            int needed = size + (size >> 2); // at most 80% full\n-            int result = 32;\n-            while (result < needed) {\n-                result += result;\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        protected BeanPropertyMap _renameAll(NameTransformer transformer)\n-        {\n-            // Try to retain insertion ordering as well\n-            final int len = _propsInOrder.length;\n-            ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(len);\n-\n-            for (int i = 0; i < len; ++i) {\n-                SettableBeanProperty prop = _propsInOrder[i];\n-                \n-                // What to do with holes? For now, retain\n-                if (prop == null) {\n-                    newProps.add(prop);\n-                    continue;\n-                }\n-                newProps.add(_rename(prop, transformer));\n-            }\n-            // should we try to re-index? Ordering probably changed but called probably doesn't want changes...\n-            return new Default(_caseInsensitive, newProps);\n-        }\n-\n-        @Override\n-        public BeanPropertyMap withProperty(SettableBeanProperty newProp)\n-        {\n-            // First: may be able to just replace?\n-            String key = getPropertyName(newProp);\n-\n-            for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n-                SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n-                if ((prop != null) && prop.getName().equals(key)) {\n-                    _hashArea[i] = newProp;\n-                    _propsInOrder[_findFromOrdered(prop)] = newProp;\n-                    return this;\n-                }\n-            }\n-            // If not, append\n-            int slot = _hashCode(key);\n-            int hashSize = _hashMask+1;\n-\n-            // primary slot not free?\n-            if (_hashArea[slot << 1] != null) {\n-                // secondary?\n-                slot = hashSize + (slot >> 1);\n-                if (_hashArea[slot << 1] != null) {\n-                    // ok, spill over.\n-                    slot = hashSize + (hashSize >> 1) + _spillCount;\n-                    _spillCount += 2;\n-                    if ((slot << 1) >= _hashArea.length) {\n-                        _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);\n-                    }\n-                }\n-            }\n-            int ix = slot << 1;\n-            _hashArea[ix] = key;\n-            _hashArea[ix+1] = newProp;\n-\n-            int last = _propsInOrder.length;\n-            _propsInOrder = Arrays.copyOf(_propsInOrder, last+1);\n-            _propsInOrder[last] = newProp;\n-\n-            // should we just create a new one? Or is resetting ok?\n-            \n-            return this;\n-        }\n-\n-        @Override\n-        public BeanPropertyMap assignIndexes()\n-        {\n-            // order is arbitrary, but stable:\n-            int index = 0;\n-            for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n-                SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n-                if (prop != null) {\n-                    prop.assignIndex(index++);\n-                }\n-            }\n-            return this;\n-        }\n-        \n-        @Override\n-        public int size() { return _size; }\n-\n-        @Override\n-        public void remove(SettableBeanProperty propToRm)\n-        {\n-            ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n-            String key = getPropertyName(propToRm);\n-            boolean found = false;\n-\n-            for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n-                SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n-                if (prop == null) {\n-                    continue;\n-                }\n-                if (!found) {\n-                    found = key.equals(prop.getName());\n-                    if (found) {\n-                        // need to leave a hole here\n-                        _propsInOrder[_findFromOrdered(prop)] = null;\n-                        continue;\n-                    }\n-                }\n-                props.add(prop);\n-            }\n-            if (found) {\n-                init(props);\n-                return;\n-            }\n-            super.remove(propToRm);\n-        }\n-\n-        @Override\n-        public void replace(SettableBeanProperty newProp)\n-        {\n-            String key = getPropertyName(newProp);\n-            for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n-                SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n-                if ((prop != null) && prop.getName().equals(key)) {\n-                    _hashArea[i] = newProp;\n-                    // also, replace in in-order\n-                    _propsInOrder[_findFromOrdered(prop)] = newProp;\n-                    return;\n-                }\n-            }\n-            super.replace(newProp);\n-        }\n-\n-        private List<SettableBeanProperty> properties() {\n-            ArrayList<SettableBeanProperty> p = new ArrayList<SettableBeanProperty>(_size);\n-            for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n-                SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n-                if (prop != null) {\n-                    p.add(prop);\n-                }\n-            }\n-            return p;\n-        }\n-        \n-        @Override\n-        public Iterator<SettableBeanProperty> iterator() {\n-            return properties().iterator();\n-        }\n-        \n-        @Override\n-        public SettableBeanProperty[] getPropertiesInInsertionOrder() {\n-            return _propsInOrder;\n-        }\n-\n-        @Override\n-        public SettableBeanProperty find(int index)\n-        {\n-            for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n-                SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n-                if ((prop != null) && (index == prop.getPropertyIndex())) {\n-                    return prop;\n-                }\n-            }\n+        if (match == null) {\n             return null;\n         }\n-\n-        @Override\n-        public SettableBeanProperty find(String key)\n-        {\n-            if (key == null) {\n-                throw new IllegalArgumentException(\"Can not pass null property name\");\n-            }\n-            if (_caseInsensitive) {\n-                key = key.toLowerCase();\n-            }\n-\n-            // inlined `_hashCode(key)`\n-            int slot = key.hashCode() & _hashMask;\n-            \n-//            int slot = key.hashCode() & _hashMask;\n-\n-            int ix = (slot<<1);\n-            Object match = _hashArea[ix];\n-            if ((match == key) || key.equals(match)) {\n-                return (SettableBeanProperty) _hashArea[ix+1];\n-            }\n-            if (match == null) {\n-                return null;\n-            }\n-            // no? secondary?\n-            ix = ((_hashMask+1) + (slot>>1)) << 1;\n-            match = _hashArea[ix];\n-            if (key.equals(match)) {\n-                return (SettableBeanProperty) _hashArea[ix+1];\n-            }\n-            // or spill?\n-            return _findFromSpill(key);\n-        }\n-\n-        @Override\n-        public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n-                Object bean, String key) throws IOException\n-        {\n-            final SettableBeanProperty prop = find(key);\n-            if (prop == null) {\n-                return false;\n-            }\n-            try {\n-                prop.deserializeAndSet(p, ctxt, bean);\n-            } catch (Exception e) {\n-                wrapAndThrow(e, bean, key, ctxt);\n-            }\n-            return true;\n+        // no? secondary?\n+        int hashSize = _hashMask+1;\n+        int ix = hashSize + (slot>>1) << 1;\n+        match = _hashArea[ix];\n+        if (key.equals(match)) {\n+            return (SettableBeanProperty) _hashArea[ix+1];\n         }\n-\n-        private SettableBeanProperty _findFromSpill(String key)\n-        {\n-            int hashSize = _hashMask+1;\n+        if (match != null) { // _findFromSpill(...)\n             int i = (hashSize + (hashSize>>1)) << 1;\n             for (int end = i + _spillCount; i < end; i += 2) {\n-                Object match = _hashArea[i];\n+                match = _hashArea[i];\n                 if ((match == key) || key.equals(match)) {\n                     return (SettableBeanProperty) _hashArea[i+1];\n                 }\n             }\n-            return null;\n         }\n+        return null;\n+    }\n \n-        private int _findFromOrdered(SettableBeanProperty prop) {\n-            for (int i = 0, end = _propsInOrder.length; i < end; ++i) {\n-                if (_propsInOrder[i] == prop) {\n-                    return i;\n-                }\n+    private int _findFromOrdered(SettableBeanProperty prop) {\n+        for (int i = 0, end = _propsInOrder.length; i < end; ++i) {\n+            if (_propsInOrder[i] == prop) {\n+                return i;\n             }\n-            throw new IllegalStateException(\"Illegal state: property '\"+prop.getName()+\"' missing from _propsInOrder\");\n         }\n+        throw new IllegalStateException(\"Illegal state: property '\"+prop.getName()+\"' missing from _propsInOrder\");\n+    }\n \n-        // Offlined version for convenience if we want to change hashing scheme\n-        private final int _hashCode(String key) {\n-            // This method produces better hash, fewer collisions... yet for some\n-            // reason produces slightly worse performance. Very strange.\n-            /*\n-            int h = key.hashCode();\n-            h = h + (h >> 13);\n-            return h & _hashMask;\n-            */\n-            return key.hashCode() & _hashMask;\n-        }\n+    // Offlined version for convenience if we want to change hashing scheme\n+    private final int _hashCode(String key) {\n+        // This method produces better hash, fewer collisions... yet for some\n+        // reason produces slightly worse performance. Very strange.\n+        /*\n+        int h = key.hashCode();\n+        h = h + (h >> 13);\n+        return h & _hashMask;\n+        */\n+        return key.hashCode() & _hashMask;\n     }\n }\n",
      "files_name_in_blame_commit": [
        "BeanPropertyMap.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 37
  }
}
{
  "id": "47",
  "blame_commit": {
    "commit": {
      "commit_id": "69997467d419487cb4098ff116188091907b5ff1",
      "commit_message": "Refactor to only have minimal CSVParser constructors in favor of CSVParser factory methods for String, resource path, URL, and File. Update some tests to use the APIs.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/csv/trunk@1508544 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Gary D. Gregory",
      "commit_date": "2013-07-30 17:36:34",
      "commit_parent": "61fdb7a03a22065de4c63525a4b836ba616aa1f1"
    },
    "function": {
      "function_name": "getHeaderMap",
      "function_code_before": "public Map<String, Integer> getHeaderMap() {\n    return new LinkedHashMap<String, Integer>(headerMap);\n}",
      "function_code_after": "public Map<String, Integer> getHeaderMap() {\n    return new LinkedHashMap<String, Integer>(this.headerMap);\n}",
      "function_before_start_line": 186,
      "function_before_end_line": 188,
      "function_after_start_line": 285,
      "function_after_end_line": 287,
      "function_before_token_count": 17,
      "function_after_token_count": 19,
      "functions_name_modified_file": [
        "getRecords",
        "initializeHeader",
        "isClosed",
        "parseFile",
        "parseString",
        "nextRecord",
        "parseURL",
        "getHeaderMap",
        "parseResource",
        "close",
        "addRecordValue",
        "getRecordNumber",
        "iterator",
        "getCurrentLineNumber",
        "CSVParser"
      ],
      "functions_name_all_files": [
        "getRecords",
        "copy",
        "testInvalidFormat",
        "toString",
        "nextRecord",
        "testGetLine",
        "getNullString",
        "getHeader",
        "testPrinter2",
        "testEndOfFileBehaviourExcel",
        "testJdbcPrinter",
        "testMappedButNotSetAsOutlook2007ContactExport",
        "testForEach",
        "testClose",
        "validateLineNumbers",
        "testCarriageReturnEndings",
        "validate",
        "testRandom",
        "withDelimiter",
        "testCarriageReturnLineFeedEndings",
        "testGetHeaderMap",
        "testSingleQuoteQuoted",
        "testEmptyLineBehaviourCSV",
        "testDefaultFormat",
        "parseResource",
        "withQuotePolicy",
        "generateData",
        "randStr",
        "testGetRecordNumberWithLF",
        "testGetRecords",
        "testEOLEscaped",
        "testEOLQuoted",
        "testExcelPrintAllArrayOfArrays",
        "isQuoting",
        "testPrintNullValues",
        "testPrinter4",
        "testDelimiterEscaped",
        "testGetLineNumberWithCR",
        "close",
        "testExcelPrinter2",
        "testPrintCustomNullValues",
        "CSVParser",
        "testPrinter3",
        "testIterator",
        "getDelimiter",
        "testPlainQuoted",
        "testGetRecordNumberWithCR",
        "testIgnoreEmptyLines",
        "testParseCustomNullValues",
        "testDelimeterQuoted",
        "testExcelFormat1",
        "testHeaderComment",
        "withQuoteChar",
        "getRecordSeparator",
        "testExcelPrintAllArrayOfLists",
        "testGetLineNumberWithCRLF",
        "getCommentStart",
        "testRoundtrip",
        "equals",
        "testPrinter6",
        "addRecordValue",
        "testExcelPrinter1",
        "testDelimeterQuoteNONE",
        "isCommentingEnabled",
        "testBackslashEscapingOld",
        "getIgnoreSurroundingSpaces",
        "testExcelPrintAllIterableOfLists",
        "testPlainPlain",
        "withIgnoreEmptyLines",
        "getRecordNumber",
        "testPrinter5",
        "testEOLPlain",
        "withEscape",
        "testEmptyFile",
        "getQuoteChar",
        "isClosed",
        "CSVFileParserTest",
        "getQuotePolicy",
        "testGetLineNumberWithLF",
        "testQuoteAll",
        "isLineBreak",
        "isEscaping",
        "testEmptyLineBehaviourExcel",
        "testGetRecordNumberWithCRLF",
        "testGetRecordWithMultiiLineValues",
        "parseString",
        "readTestData",
        "testCSVFile",
        "testLineFeedEndings",
        "testCSV57",
        "testEndOfFileBehaviorCSV",
        "testBackslashEscaping",
        "iterator",
        "testSingleLineComment",
        "parseURL",
        "printable",
        "getHeaderMap",
        "doRandom",
        "testPrinter1",
        "parseFile",
        "testExcelPrintAllIterableOfArrays",
        "getIgnoreEmptyLines",
        "validateRecordNumbers",
        "testCSVResource",
        "testDelimiterPlain",
        "getEscape",
        "hashCode",
        "testProvidedHeader",
        "withNullString",
        "testQuoteNonNumeric",
        "testMultiLineComment",
        "testExcelFormat2",
        "parse",
        "withRecordSeparator",
        "testHeader",
        "withHeader",
        "withCommentStart",
        "format",
        "initializeHeader",
        "doOneRandom",
        "testPrinter7",
        "getCurrentLineNumber",
        "testBackslashEscaping2",
        "testPlainEscaped",
        "testDisabledComment",
        "newFormat",
        "withIgnoreSurroundingSpaces",
        "CSVFormat"
      ],
      "functions_name_co_evolved_modified_file": [
        "getRecords",
        "isClosed",
        "initializeHeader",
        "parseFile",
        "parseString",
        "nextRecord",
        "parseURL",
        "getHeaderMap",
        "parseResource",
        "close",
        "addRecordValue",
        "getRecordNumber",
        "iterator",
        "getCurrentLineNumber",
        "CSVParser"
      ],
      "functions_name_co_evolved_all_files": [
        "getRecords",
        "parseFile",
        "testGetRecords",
        "nextRecord",
        "testGetLine",
        "validateRecordNumbers",
        "testCSVResource",
        "getRecordNumber",
        "testEmptyFile",
        "isClosed",
        "testEndOfFileBehaviourExcel",
        "testExcelFormat2",
        "close",
        "validateLineNumbers",
        "testCarriageReturnEndings",
        "CSVParser",
        "testEmptyLineBehaviourExcel",
        "initializeHeader",
        "testGetRecordWithMultiiLineValues",
        "parseString",
        "testCSVFile",
        "testLineFeedEndings",
        "testCSV57",
        "testIgnoreEmptyLines",
        "testCarriageReturnLineFeedEndings",
        "testEndOfFileBehaviorCSV",
        "testBackslashEscaping",
        "doOneRandom",
        "iterator",
        "testExcelFormat1",
        "getCurrentLineNumber",
        "testBackslashEscaping2",
        "testGetHeaderMap",
        "testEmptyLineBehaviourCSV",
        "testDefaultFormat",
        "parseURL",
        "testRoundtrip",
        "getHeaderMap",
        "parseResource",
        "addRecordValue",
        "testBackslashEscapingOld"
      ]
    },
    "file": {
      "file_name": "CSVParser.java",
      "file_nloc": 182,
      "file_complexity": 43,
      "file_token_count": 1258,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -20,9 +20,14 @@ package org.apache.commons.csv;\n import static org.apache.commons.csv.Token.Type.TOKEN;\n \n import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n+import java.io.InputStreamReader;\n import java.io.Reader;\n import java.io.StringReader;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n@@ -32,15 +37,15 @@ import java.util.NoSuchElementException;\n \n /**\n  * Parses CSV files according to the specified configuration.\n- *\n+ * \n  * Because CSV appears in many different dialects, the parser supports many configuration settings by allowing the\n  * specification of a {@link CSVFormat}.\n- *\n+ * \n  * <p>\n- * To parse a CSV input with tabs as separators, '\"' (double-quote) as an optional value encapsulator,\n- * and comments starting with '#', you write:\n+ * To parse a CSV input with tabs as separators, '\"' (double-quote) as an optional value encapsulator, and comments\n+ * starting with '#', you write:\n  * </p>\n- *\n+ * \n  * <pre>\n  * Reader in = new StringReader(&quot;a\\tb\\nc\\td&quot;);\n  * Iterable&lt;CSVRecord&gt; parser = CSVFormat.DEFAULT\n@@ -51,11 +56,11 @@ import java.util.NoSuchElementException;\n  *     ...\n  *  }\n  * </pre>\n- *\n+ * \n  * <p>\n  * To parse CSV input in a given format like Excel, you write:\n  * </p>\n- *\n+ * \n  * <pre>\n  * Reader in = new StringReader(\"a;b\\nc;d\");\n  * Iterable&lt;CSVRecord&gt; parser = CSVFormat.EXCEL.parse(in);\n@@ -66,37 +71,142 @@ import java.util.NoSuchElementException;\n  * <p>\n  * You may also get a List of records:\n  * </p>\n+ * \n  * <pre>\n- * Reader in = new StringReader(\"a;b\\nc;d\");\n+ * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n  * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n  * List&lt;CSVRecord&gt; list = parser.getRecords();\n  * </pre>\n  * <p>\n+ * See also the various static parse methods on this class.\n+ * </p>\n+ * <p>\n  * Internal parser state is completely covered by the format and the reader-state.\n  * </p>\n- *\n+ * \n  * <p>\n  * see <a href=\"package-summary.html\">package documentation</a> for more details\n  * </p>\n- *\n+ * \n  * @version $Id$\n  */\n public class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n+    /**\n+     * Creates a parser for the given resource.\n+     * \n+     * <p>\n+     * If you do not read all records from the given source, you should call {@link #close()} on the parser.\n+     * </p>\n+     * \n+     * @param resource\n+     *            a resource path\n+     * @param charset\n+     *            the charset for the resource\n+     * @param classLoader\n+     *            the class loader to load the resource.\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseResource(String resource, Charset charset, ClassLoader classLoader,\n+            final CSVFormat format) throws IOException {\n+        return parseURL(classLoader.getResource(resource), charset, format);\n+    }\n+    \n+    /**\n+     * Creates a parser for the given {@link String} using the default format {@link CSVFormat#DEFAULT}.\n+     * \n+     * @param string\n+     *            a CSV string\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseString(String string) throws IOException {\n+        return parseString(string, CSVFormat.DEFAULT);\n+    }\n+    \n+    /**\n+     * Creates a parser for the given {@link String}.\n+     * \n+     * @param string\n+     *            a CSV string\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseString(String string, final CSVFormat format) throws IOException {\n+        return new CSVParser(new StringReader(string), format);\n+    }\n+\n+    /**\n+     * Creates a parser for the given {@link File}.\n+     * \n+     * @param file\n+     *            a CSV file\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseFile(File file, final CSVFormat format) throws IOException {\n+        return new CSVParser(new FileReader(file), format);\n+    }\n+\n+    /**\n+     * Creates a parser for the given URL.\n+     * \n+     * <p>\n+     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n+     * you close the {@code url}.\n+     * </p>\n+     * \n+     * @param url\n+     *            a URL\n+     * @param charset\n+     *            the charset for the resource, if {@code null}, uses {@code UTF-8}. UTF-8 is one of the encodings\n+     *            required by the Java specification.\n+     * @param classLoader\n+     *            the class loader to load the resource.\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseURL(URL url, Charset charset, final CSVFormat format) throws IOException {\n+        return new CSVParser(new InputStreamReader(url.openStream(), charset == null ? Charset.forName(\"UTF-8\")\n+                : charset), format);\n+    }\n+\n+    // the following objects are shared to reduce garbage\n+\n     private final CSVFormat format;\n     private final Map<String, Integer> headerMap;\n+\n     private final Lexer lexer;\n+\n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n \n-    // the following objects are shared to reduce garbage\n-\n     private long recordNumber;\n+\n     private final Token reusableToken = new Token();\n \n     /**\n-     * CSV parser using the default {@link CSVFormat}.\n+     * CSV parser using the default format {@link CSVFormat#DEFAULT}.\n      *\n+     * <p>\n+     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n+     * unless you close the {@code reader}.\n+     * </p>\n+     * \n      * @param input\n      *            a Reader containing \"csv-formatted\" input\n      * @throws IllegalArgumentException\n@@ -110,8 +220,13 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n     /**\n      * Customized CSV parser using the given {@link CSVFormat}\n-     *\n-     * @param input\n+     * \n+     * <p>\n+     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n+     * unless you close the {@code reader}.\n+     * </p>\n+     * \n+     * @param reader\n      *            a Reader containing CSV-formatted input\n      * @param format\n      *            the CSVFormat used for CSV parsing\n@@ -120,36 +235,20 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public CSVParser(final Reader input, final CSVFormat format) throws IOException {\n+    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n         format.validate();\n         this.format = format;\n-        this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n-        this.headerMap = initializeHeader();\n-    }\n-\n-    /**\n-     * Customized CSV parser using the given {@link CSVFormat}\n-     *\n-     * @param input\n-     *            a String containing \"csv-formatted\" input\n-     * @param format\n-     *            the CSVFormat used for CSV parsing\n-     * @throws IllegalArgumentException\n-     *             thrown if the parameters of the format are inconsistent\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public CSVParser(final String input, final CSVFormat format) throws IOException {\n-        this(new StringReader(input), format);\n+        this.lexer = new CSVLexer(format, new ExtendedBufferedReader(reader));\n+        this.headerMap = this.initializeHeader();\n     }\n \n     private void addRecordValue() {\n-        final String input = reusableToken.content.toString();\n+        final String input = this.reusableToken.content.toString();\n         final String nullString = this.format.getNullString();\n         if (nullString == null) {\n-            record.add(input);\n+            this.record.add(input);\n         } else {\n-            record.add(input.equalsIgnoreCase(nullString) ? null : input);\n+            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n         }}\n \n     /**\n@@ -159,8 +258,8 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n \t *             If an I/O error occurs\n      */\n \tpublic void close() throws IOException {\n-\t\tif (lexer != null) {\n-\t\t\tlexer.close();\n+\t\tif (this.lexer != null) {\n+\t\t\tthis.lexer.close();\n \t\t}\t\t\n \t}\n \n@@ -172,7 +271,7 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @return current line number\n      */\n     public long getCurrentLineNumber() {\n-        return lexer.getCurrentLineNumber();\n+        return this.lexer.getCurrentLineNumber();\n     }\n \n     /**\n@@ -184,7 +283,7 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(headerMap);\n+        return new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n@@ -195,7 +294,7 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @return current line number\n      */\n     public long getRecordNumber() {\n-        return recordNumber;\n+        return this.recordNumber;\n     }\n \n     /**\n@@ -211,7 +310,7 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n     public List<CSVRecord> getRecords() throws IOException {\n         final List<CSVRecord> records = new ArrayList<CSVRecord>();\n         CSVRecord rec;\n-        while ((rec = nextRecord()) != null) {\n+        while ((rec = this.nextRecord()) != null) {\n             records.add(rec);\n         }\n         return records;\n@@ -222,18 +321,18 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n      */\n     private Map<String, Integer> initializeHeader() throws IOException {\n         Map<String, Integer> hdrMap = null;\n-        if (format.getHeader() != null) {\n+        if (this.format.getHeader() != null) {\n             hdrMap = new LinkedHashMap<String, Integer>();\n \n             String[] header = null;\n-            if (format.getHeader().length == 0) {\n+            if (this.format.getHeader().length == 0) {\n                 // read the header from the first line of the file\n-                final CSVRecord record = nextRecord();\n+                final CSVRecord record = this.nextRecord();\n                 if (record != null) {\n                     header = record.values();\n                 }\n             } else {\n-                header = format.getHeader();\n+                header = this.format.getHeader();\n             }\n \n             // build the name to index mappings\n@@ -247,10 +346,10 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n     }\n \n     public boolean isClosed() {\n-\t\treturn lexer.isClosed();\n+\t\treturn this.lexer.isClosed();\n \t}\n \n-    /**\n+\t/**\n      * Returns an iterator on the records. IOExceptions occurring during the iteration are wrapped in a\n      * RuntimeException.\n      */\n@@ -260,7 +359,7 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n             private CSVRecord getNextRecord() {\n                 try {\n-                    return nextRecord();\n+                    return CSVParser.this.nextRecord();\n                 } catch (final IOException e) {\n                     // TODO: This is not great, throw an ISE instead?\n                     throw new RuntimeException(e);\n@@ -268,26 +367,26 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n             }\n \n             public boolean hasNext() {\n-            \tif (isClosed()) {\n+            \tif (CSVParser.this.isClosed()) {\n             \t\treturn false;\n             \t}\n-                if (current == null) {\n-                    current = getNextRecord();\n+                if (this.current == null) {\n+                    this.current = this.getNextRecord();\n                 }\n \n-                return current != null;\n+                return this.current != null;\n             }\n \n             public CSVRecord next() {\n-            \tif (isClosed()) {\n+            \tif (CSVParser.this.isClosed()) {\n             \t\treturn null;\n             \t}\n-                CSVRecord next = current;\n-                current = null;\n+                CSVRecord next = this.current;\n+                this.current = null;\n \n                 if (next == null) {\n                     // hasNext() wasn't called before\n-                    next = getNextRecord();\n+                    next = this.getNextRecord();\n                     if (next == null) {\n                         throw new NoSuchElementException(\"No more CSV records available\");\n                     }\n@@ -302,7 +401,7 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n         };\n     }\n \n-\t/**\n+    /**\n      * Parses the next record from the current point in the stream.\n      *\n      * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n@@ -311,12 +410,12 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n      */\n     CSVRecord nextRecord() throws IOException {\n         CSVRecord result = null;\n-        record.clear();\n+        this.record.clear();\n         StringBuilder sb = null;\n         do {\n-            reusableToken.reset();\n-            lexer.nextToken(reusableToken);\n-            switch (reusableToken.type) {\n+            this.reusableToken.reset();\n+            this.lexer.nextToken(this.reusableToken);\n+            switch (this.reusableToken.type) {\n             case TOKEN:\n                 this.addRecordValue();\n                 break;\n@@ -324,28 +423,28 @@ public class CSVParser implements Iterable<CSVRecord>, Closeable {\n                 this.addRecordValue();\n                 break;\n             case EOF:\n-                if (reusableToken.isReady) {\n+                if (this.reusableToken.isReady) {\n                     this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n-                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n+                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT: // Ignored currently\n                 if (sb == null) { // first comment for this record\n                     sb = new StringBuilder();\n                 } else {\n                     sb.append(Constants.LF);\n                 }\n-                sb.append(reusableToken.content);\n-                reusableToken.type = TOKEN; // Read another token\n+                sb.append(this.reusableToken.content);\n+                this.reusableToken.type = TOKEN; // Read another token\n                 break;\n             }\n-        } while (reusableToken.type == TOKEN);\n+        } while (this.reusableToken.type == TOKEN);\n \n-        if (!record.isEmpty()) {\n-            recordNumber++;\n+        if (!this.record.isEmpty()) {\n+            this.recordNumber++;\n             final String comment = sb == null ? null : sb.toString();\n-            result = new CSVRecord(record.toArray(new String[record.size()]), headerMap, comment, this.recordNumber);\n+            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n         }\n         return result;\n     }\n",
      "files_name_in_blame_commit": [
        "CSVParser.java",
        "CSVFormat.java",
        "CSVPrinterTest.java",
        "CSVParserTest.java",
        "CSVFileParserTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 137
  }
}
{
  "id": "15",
  "blame_commit": {
    "commit": {
      "commit_id": "0a39688562637465944df3c29ae0c1259cc0a4dc",
      "commit_message": "Removes useless unconditional jumps\n\nR=johnlenz\nDELTA=179  (96 added, 33 deleted, 50 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=88010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@337 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "acleung@google.com",
      "commit_date": "2010-08-05 00:53:31",
      "commit_parent": "c41e5b19af044fd2d5f9e835addece71c3548edb"
    },
    "function": {
      "function_name": "computeFollowNode",
      "function_code_before": "",
      "function_code_after": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  /*\n   * This is the case where:\n   *\n   * 1. Parent is null implies that we are transferring control to the end of\n   * the script.\n   *\n   * 2. Parent is a function implies that we are transferring control back to\n   * the caller of the function.\n   *\n   * 3. If the node is a return statement, we should also transfer control\n   * back to the caller of the function.\n   *\n   * 4. If the node is root then we have reached the end of what we have been\n   * asked to traverse.\n   *\n   * In all cases we should transfer control to a \"symbolic return\" node.\n   * This will make life easier for DFAs.\n   */\n  Node parent = node.getParent();\n  if (parent == null || parent.getType() == Token.FUNCTION ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n\n  // If we are just before a IF/WHILE/DO/FOR:\n  switch (parent.getType()) {\n    // The follow() of any of the path from IF would be what follows IF.\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT:\n      // After the body of a CASE, the control goes to the body of the next\n      // case, without having to go to the case condition.\n      if (parent.getNext() != null) {\n        if (parent.getNext().getType() == Token.CASE) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().getType() == Token.DEFAULT) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      // If we are coming out of the TRY block...\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(parent.getLastChild());\n        } else { // and have no FINALLY.\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // CATCH block.\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      // If we are coming out of the FINALLY block...\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n\n  // Now that we are done with the special cases follow should be its\n  // immediate sibling, unless its sibling is a function\n  Node nextSibling = node.getNext();\n\n  // Skip function declarations because control doesn't get pass into it.\n  while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n    nextSibling = nextSibling.getNext();\n  }\n\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    // If there are no more siblings, control is transfered up the AST.\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 674,
      "function_after_end_line": 771,
      "function_before_token_count": 0,
      "function_after_token_count": 463,
      "functions_name_modified_file": [
        "handleStmt",
        "handleWith",
        "handleBreak",
        "getNextSiblingOfType",
        "handleCase",
        "isContinueStructure",
        "handleWhile",
        "handleFunction",
        "Comparator<DiGraphNode<Node,Branch>>",
        "createEdge",
        "AstControlFlowGraph",
        "isBreakStructure",
        "shouldTraverse",
        "getPosition",
        "handleReturn",
        "process",
        "prioritizeFromEntryNode",
        "isContinueTarget",
        "handleIf",
        "visit",
        "handleSwitch",
        "isBreakTarget",
        "handleExpr",
        "handleCatch",
        "matchLabel",
        "mayThrowException",
        "computeFollowNode",
        "handleFor",
        "getCfg",
        "handleThrow",
        "handleContinue",
        "handleStmtList",
        "handleDefault",
        "computeFallThrough",
        "handleTry",
        "ControlFlowAnalysis",
        "connectToPossibleExceptionHandler",
        "handleDo",
        "getOptionalNodeComparator"
      ],
      "functions_name_all_files": [
        "testRemoveUselessStrings",
        "testConditionalDeadCode",
        "handleStmt",
        "handleWith",
        "handleBreak",
        "getNextSiblingOfType",
        "handleCase",
        "testRemoveUnreachableCode",
        "isContinueStructure",
        "handleWhile",
        "handleFunction",
        "Comparator<DiGraphNode<Node,Branch>>",
        "createEdge",
        "testNoRemoveUseStrict",
        "AstControlFlowGraph",
        "isBreakStructure",
        "shouldTraverse",
        "getPosition",
        "handleReturn",
        "removeDeadExprStatementSafely",
        "process",
        "prioritizeFromEntryNode",
        "testSwitchCase",
        "testRemoveUselessNameStatements",
        "setUp",
        "testAssignPropertyOnCreatedObject",
        "isContinueTarget",
        "testUnlessUnconditonalBreak",
        "testUnlessUnconditionalContinue",
        "handleIf",
        "visit",
        "handleSwitch",
        "isBreakTarget",
        "handleExpr",
        "handleCatch",
        "matchLabel",
        "mayThrowException",
        "testTryCatchFinally",
        "computeFollowNode",
        "testRemoveDo",
        "handleFor",
        "getCfg",
        "handleThrow",
        "handleContinue",
        "testNoRemoveUselessNameStatements",
        "handleStmtList",
        "handleDefault",
        "computeFallThrough",
        "exitScope",
        "handleTry",
        "enterScope",
        "ControlFlowAnalysis",
        "connectToPossibleExceptionHandler",
        "UnreachableCodeElimination",
        "testUnlessUnconditionalReturn",
        "testRemoveUselessLiteralValueStatements",
        "testRemovalRequiresRedeclaration",
        "getProcessor",
        "handleDo",
        "getOptionalNodeComparator"
      ],
      "functions_name_co_evolved_modified_file": [
        "handleStmtList",
        "handleStmt",
        "computeFallThrough",
        "handleIf",
        "handleBreak",
        "handleSwitch",
        "handleCase",
        "handleExpr",
        "handleWhile",
        "handleDo",
        "computeFollowNode",
        "handleFor"
      ],
      "functions_name_co_evolved_all_files": [
        "testKnownIf",
        "testConditionalDeadCode",
        "handleStmt",
        "handleBreak",
        "handleCase",
        "testRemoveUnreachableCode",
        "handleWhile",
        "testSwitchCase",
        "testUnlessUnconditonalBreak",
        "testUnlessUnconditionalContinue",
        "handleIf",
        "visit",
        "handleSwitch",
        "testKnownWhile",
        "handleExpr",
        "computeFollowNode",
        "handleFor",
        "apply",
        "handleStmtList",
        "computeFallThrough",
        "enterScope",
        "testUnlessUnconditionalReturn",
        "handleDo"
      ]
    },
    "file": {
      "file_name": "ControlFlowAnalysis.java",
      "file_nloc": 666,
      "file_complexity": 201,
      "file_token_count": 4496,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -357,7 +357,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n \n     if (elseBlock == null) {\n       createEdge(node, Branch.ON_FALSE,\n-          computeFollowNode(node)); // not taken branch\n+          computeFollowNode(node, this)); // not taken branch\n     } else {\n       createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n     }\n@@ -372,7 +372,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n \n     // Control goes to the follow() if the condition evaluates to false.\n     createEdge(node, Branch.ON_FALSE,\n-        computeFollowNode(node));\n+        computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(\n         node, NodeUtil.getConditionExpression(node));\n   }\n@@ -383,7 +383,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n     createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n     // The edge that leaves the do loop if the condition fails.\n     createEdge(node, Branch.ON_FALSE,\n-        computeFollowNode(node));\n+        computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(\n         node, NodeUtil.getConditionExpression(node));\n   }\n@@ -402,7 +402,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n       // The edge to end of the loop.\n       createEdge(forNode, Branch.ON_FALSE,\n-          computeFollowNode(forNode));\n+          computeFollowNode(forNode, this));\n       // The end of the body will have a unconditional branch to our iter\n       // (handled by calling computeFollowNode of the last instruction of the\n       // body. Our iter will jump to the forNode again to another condition\n@@ -420,7 +420,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n       // The edge to end of the loop.\n       createEdge(forNode, Branch.ON_FALSE,\n-          computeFollowNode(forNode));\n+          computeFollowNode(forNode, this));\n       connectToPossibleExceptionHandler(forNode, collection);\n     }\n   }\n@@ -436,7 +436,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       if (node.getFirstChild().getNext() != null) {\n         createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n       } else { // No CASE, no DEFAULT\n-        createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n       }\n     }\n     connectToPossibleExceptionHandler(node, node.getFirstChild());\n@@ -458,7 +458,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       if (deflt != null) { // Has a DEFAULT\n         createEdge(node, Branch.ON_FALSE, deflt);\n       } else { // No DEFAULT found, go to the follow of the SWITCH.\n-        createEdge(node, Branch.ON_FALSE, computeFollowNode(node));\n+        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n       }\n     }\n     connectToPossibleExceptionHandler(node, node.getFirstChild());\n@@ -497,7 +497,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n     if (child != null) {\n       createEdge(node, Branch.UNCOND, computeFallThrough(child));\n     } else {\n-      createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n     }\n \n     // Synthetic blocks\n@@ -529,7 +529,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n   }\n \n   private void handleExpr(Node node) {\n-    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(node, node);\n   }\n \n@@ -578,9 +578,9 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       Preconditions.checkState(parent != null, \"Cannot find break target.\");\n     }\n     if (lastJump == node) {\n-      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur));\n+      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n     } else {\n-      finallyMap.put(lastJump, computeFollowNode(cur));\n+      finallyMap.put(lastJump, computeFollowNode(cur, this));\n     }\n   }\n \n@@ -649,12 +649,16 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n \n   private void handleStmt(Node node) {\n     // Simply transfer to the next line.\n-    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(node, node);\n   }\n \n-  private Node computeFollowNode(Node node) {\n-    return computeFollowNode(node, node);\n+  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n+    return computeFollowNode(node, node, cfa);\n+  }\n+\n+  static Node computeFollowNode(Node node) {\n+    return computeFollowNode(node, node, null);\n   }\n \n   /**\n@@ -667,7 +671,8 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n    *        during recursion.\n    * @param node The node that follow() should compute.\n    */\n-  private Node computeFollowNode(Node fromNode, Node node) {\n+  private static Node computeFollowNode(\n+      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n     /*\n      * This is the case where:\n      *\n@@ -687,7 +692,8 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n      * This will make life easier for DFAs.\n      */\n     Node parent = node.getParent();\n-    if (parent == null || parent.getType() == Token.FUNCTION || node == root) {\n+    if (parent == null || parent.getType() == Token.FUNCTION ||\n+        (cfa != null && node == cfa.root)) {\n       return null;\n     }\n \n@@ -695,7 +701,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n     switch (parent.getType()) {\n       // The follow() of any of the path from IF would be what follows IF.\n       case Token.IF:\n-        return computeFollowNode(fromNode, parent);\n+        return computeFollowNode(fromNode, parent, cfa);\n       case Token.CASE:\n       case Token.DEFAULT:\n         // After the body of a CASE, the control goes to the body of the next\n@@ -709,7 +715,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n             Preconditions.checkState(false, \"Not reachable\");\n           }\n         } else {\n-          return computeFollowNode(fromNode, parent);\n+          return computeFollowNode(fromNode, parent, cfa);\n         }\n         break;\n       case Token.FOR:\n@@ -727,21 +733,23 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n           if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n             return computeFallThrough(parent.getLastChild());\n           } else { // and have no FINALLY.\n-            return computeFollowNode(fromNode, parent);\n+            return computeFollowNode(fromNode, parent, cfa);\n           }\n         // CATCH block.\n         } else if (NodeUtil.getCatchBlock(parent) == node){\n           if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n             return computeFallThrough(node.getNext());\n           } else {\n-            return computeFollowNode(fromNode, parent);\n+            return computeFollowNode(fromNode, parent, cfa);\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n-          for (Node finallyNode : finallyMap.get(parent)) {\n-            createEdge(fromNode, Branch.UNCOND, finallyNode);\n+          if (cfa != null) {\n+            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+            }\n           }\n-          return computeFollowNode(fromNode, parent);\n+          return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n \n@@ -758,7 +766,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       return computeFallThrough(nextSibling);\n     } else {\n       // If there are no more siblings, control is transfered up the AST.\n-      return computeFollowNode(fromNode, parent);\n+      return computeFollowNode(fromNode, parent, cfa);\n     }\n   }\n \n@@ -767,7 +775,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n    * subtree of n. We don't always create a CFG edge into n itself because of\n    * DOs and FORs.\n    */\n-  private static Node computeFallThrough(Node n) {\n+  static Node computeFallThrough(Node n) {\n     switch (n.getType()) {\n       case Token.DO:\n         return computeFallThrough(n.getFirstChild());\n",
      "files_name_in_blame_commit": [
        "UnreachableCodeElimination.java",
        "ControlFlowAnalysis.java",
        "UnreachableCodeEliminationTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 24
  }
}
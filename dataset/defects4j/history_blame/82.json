{
  "id": "82",
  "blame_commit": {
    "commit": {
      "commit_id": "58fac658aba985ba77f8bd0156c6d01bec8d991b",
      "commit_message": "[JXPATH-93] relational operators did not conform to XPath spec\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/jxpath/trunk@555094 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Matthew Jason Benson",
      "commit_date": "2007-07-10 21:59:45",
      "commit_parent": "9b6406bf37af48e843b02fa8fd53dc673f3cbd1e"
    },
    "function": {
      "function_name": "computeValue",
      "function_code_before": "",
      "function_code_after": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].computeValue(context), args[1]\n            .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 40,
      "function_after_end_line": 43,
      "function_before_token_count": 0,
      "function_after_token_count": 39,
      "functions_name_modified_file": [
        "compare",
        "isSymmetric",
        "reduce",
        "compute",
        "CoreOperationRelationalExpression",
        "computeValue",
        "findMatch",
        "containsMatch",
        "getPrecedence"
      ],
      "functions_name_all_files": [
        "compare",
        "isSymmetric",
        "reduce",
        "compute",
        "CoreOperationLessThan",
        "CoreOperationTest",
        "CoreOperationGreaterThanOrEqual",
        "evaluateCompare",
        "CoreOperationGreaterThan",
        "computeValue",
        "testNodeSetOperations",
        "CoreOperationLessThanOrEqual",
        "setUp",
        "getPrecedence",
        "CoreOperationRelationalExpression",
        "getSymbol",
        "findMatch",
        "testInfoSetTypes",
        "containsMatch"
      ],
      "functions_name_co_evolved_modified_file": [
        "compare",
        "isSymmetric",
        "reduce",
        "compute",
        "CoreOperationRelationalExpression",
        "computeValue",
        "findMatch",
        "containsMatch",
        "getPrecedence"
      ],
      "functions_name_co_evolved_all_files": [
        "compare",
        "isSymmetric",
        "evaluateCompare",
        "reduce",
        "compute",
        "CoreOperationRelationalExpression",
        "computeValue",
        "findMatch",
        "testNodeSetOperations",
        "containsMatch",
        "setUp",
        "getPrecedence"
      ]
    },
    "file": {
      "file_name": "CoreOperationRelationalExpression.java",
      "file_nloc": 79,
      "file_complexity": 25,
      "file_token_count": 554,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n+import org.apache.commons.jxpath.ri.axes.InitialContext;\n+import org.apache.commons.jxpath.ri.axes.SelfContext;\n+\n+/**\n+ * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n+ *\n+ * @author Matt Benson\n+ * @version $Revision:$ $Date:$\n+ */\n+public abstract class CoreOperationRelationalExpression extends CoreOperation {\n+\n+    protected CoreOperationRelationalExpression(Expression[] args) {\n+        super(args);\n+    }\n+\n+    public final Object computeValue(EvalContext context) {\n+        return compute(args[0].computeValue(context), args[1]\n+                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected final int getPrecedence() {\n+        return 3;\n+    }\n+\n+    protected final boolean isSymmetric() {\n+        return false;\n+    }\n+\n+    protected abstract boolean evaluateCompare(int compare);\n+\n+    private boolean compute(Object left, Object right) {\n+        left = reduce(left);\n+        right = reduce(right);\n+\n+        if (left instanceof InitialContext) {\n+            ((InitialContext) left).reset();\n+        }\n+        if (right instanceof InitialContext) {\n+            ((InitialContext) right).reset();\n+        }\n+        if (left instanceof Iterator && right instanceof Iterator) {\n+            return findMatch((Iterator) left, (Iterator) right);\n+        }\n+        if (left instanceof Iterator) {\n+            return containsMatch((Iterator) left, right);\n+        }\n+        if (right instanceof Iterator) {\n+            return containsMatch((Iterator) right, left);\n+        }\n+        return evaluateCompare(compare(left, right));\n+    }\n+\n+    private Object reduce(Object o) {\n+        if (o instanceof SelfContext) {\n+            o = ((EvalContext) o).getSingleNodePointer();\n+        }\n+        if (o instanceof Collection) {\n+            o = ((Collection) o).iterator();\n+        }\n+        return o;\n+    }\n+\n+    private boolean containsMatch(Iterator it, Object value) {\n+        while (it.hasNext()) {\n+            Object element = it.next();\n+            if (evaluateCompare(compare(element, value))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean findMatch(Iterator lit, Iterator rit) {\n+        HashSet left = new HashSet();\n+        while (lit.hasNext()) {\n+            left.add(lit.next());\n+        }\n+        while (rit.hasNext()) {\n+            if (containsMatch(left.iterator(), rit.next())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private int compare(Object l, Object r) {\n+        double ld = InfoSetUtil.doubleValue(l);\n+        double rd = InfoSetUtil.doubleValue(r);\n+        return ld == rd ? 0 : ld < rd ? -1 : 1;\n+    }\n+\n+}\n",
      "files_name_in_blame_commit": [
        "CoreOperationTest.java",
        "CoreOperationLessThan.java",
        "CoreOperationGreaterThan.java",
        "CoreOperationGreaterThanOrEqual.java",
        "CoreOperationLessThanOrEqual.java",
        "CoreOperationRelationalExpression.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 4
  }
}
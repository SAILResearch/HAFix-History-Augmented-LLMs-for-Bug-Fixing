{
  "id": "107",
  "blame_commit": {
    "commit": {
      "commit_id": "0cb01403a1b3eebe97adb97b71e2e5115422e5be",
      "commit_message": "tighten checkstyle rules: declaring multiple variables in one statement is now forbidden\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@825919 13f79535-47bb-0310-9956-ffa450edef68",
      "commit_author": "Luc Maisonobe",
      "commit_date": "2009-10-16 14:51:55",
      "commit_parent": "88885e7a1c9409e22f4fd4c19378eb5bebcd228f"
    },
    "function": {
      "function_name": "flipIfWarranted",
      "function_code_before": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        // flip array\n        for (int i = 0, j = 4 * n - 1; i < j; i += 4, j -= 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n        }\n        return true;\n    }\n    return false;\n}",
      "function_code_after": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        // flip array\n        int j = 4 * n - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
      "function_before_start_line": 1126,
      "function_before_end_line": 1139,
      "function_after_start_line": 1128,
      "function_after_end_line": 1143,
      "function_before_token_count": 124,
      "function_after_token_count": 125,
      "functions_name_modified_file": [
        "process1RowBlock",
        "countEigenValues",
        "isSymmetric",
        "getD",
        "computeSplits",
        "getImagEigenvalues",
        "findEigenvector",
        "ldlTDecomposition",
        "transformToTridiagonal",
        "getImagEigenvalue",
        "computeGershgorinCircles",
        "progressiveQuotientDifferenceWithShift",
        "eigenvaluesRange",
        "computeShiftIncrement",
        "processGeneralBlock",
        "getRealEigenvalue",
        "getV",
        "goodStep",
        "process2RowsBlock",
        "getSolver",
        "Solver",
        "decompose",
        "process3RowsBlock",
        "isNonSingular",
        "dqds",
        "getDeterminant",
        "initialSplits",
        "stationaryQuotientDifferenceWithShift",
        "getInverse",
        "getRealEigenvalues",
        "dqd",
        "getVT",
        "findEigenVectors",
        "EigenDecompositionImpl",
        "findEigenvalues",
        "flipIfWarranted",
        "solve",
        "updateSigma",
        "getEigenvector"
      ],
      "functions_name_all_files": [
        "process1RowBlock",
        "isSymmetric",
        "copy",
        "getD",
        "getData",
        "computeSplits",
        "setColumnMatrix",
        "MicrosphereInterpolatingFunction",
        "transformToTridiagonal",
        "computeGershgorinCircles",
        "degree",
        "FastFourierTransformer",
        "getSubMatrix",
        "RootsOfUnity",
        "getEvaluations",
        "compareTo",
        "AbstractEstimator",
        "setMaxEvaluations",
        "preMultiply",
        "guessParametersErrors",
        "sample",
        "getArray",
        "computeCoefficients",
        "lcm",
        "sign",
        "process2RowsBlock",
        "store",
        "checkBinomial",
        "hasNext",
        "getRMS",
        "QRDecompositionImpl",
        "setRow",
        "FastCosineTransformer",
        "setConvergenceChecker",
        "isNonSingular",
        "dqds",
        "distance1",
        "growTable",
        "hash",
        "getInterpolatingValues",
        "perturb",
        "getRealEigenvalues",
        "scalb",
        "copyBlockPart",
        "EigenDecompositionImpl",
        "findEigenVectors",
        "integrate",
        "doRemove",
        "multiply",
        "flipIfWarranted",
        "updateBandwidthInterval",
        "readObject",
        "qrDecomposition",
        "AbstractLeastSquaresOptimizer",
        "PolynomialFunctionNewtonForm",
        "advance",
        "binomialCoefficientDouble",
        "getEigenvector",
        "remove",
        "indicator",
        "qTy",
        "distanceInf",
        "setParRelativeTolerance",
        "setMaxIterations",
        "mdfft",
        "getImagEigenvalues",
        "findEigenvector",
        "factorialLog",
        "walkInRowOrder",
        "ldlTDecomposition",
        "getR",
        "isPowerOf2",
        "computeDividedDifference",
        "LoessInterpolator",
        "getNorm",
        "getRowDimension",
        "progressiveQuotientDifferenceWithShift",
        "incrementIterationsCounter",
        "getIterations",
        "solve2",
        "findInsertionIndex",
        "shouldGrowTable",
        "goodStep",
        "incrementJacobianEvaluationsCounter",
        "setOrthoTolerance",
        "normalizeAngle",
        "getColumnMatrix",
        "get",
        "determineLMParameter",
        "binomialCoefficient",
        "estimate",
        "getRow",
        "MicrosphereSurfaceElement",
        "containsKey",
        "put",
        "fct",
        "getDeterminant",
        "BlockFieldMatrix",
        "computeCapacity",
        "stationaryQuotientDifferenceWithShift",
        "getInverse",
        "fst",
        "log",
        "dqd",
        "TrapezoidIntegrator",
        "sinh",
        "BlockRealMatrix",
        "stage",
        "transform",
        "equals",
        "getColumn",
        "inversetransform2",
        "getChiSquare",
        "optimize",
        "getCovariances",
        "computeOmega",
        "value",
        "distance",
        "add",
        "getColumnDimension",
        "binomialCoefficientLog",
        "getRowMatrix",
        "computeShiftIncrement",
        "setInitialStepBoundFactor",
        "scalarAdd",
        "getQ",
        "Iterator",
        "SimpsonIntegrator",
        "tricube",
        "verifyInputArray",
        "scaleArray",
        "cosh",
        "interpolate",
        "getDimensionSizes",
        "cosAngle",
        "updateJacobian",
        "getJacobianEvaluations",
        "initializeEstimate",
        "setRowMatrix",
        "checkStrictlyIncreasing",
        "verifyInterval",
        "normalizeArray",
        "decompose",
        "setMaxCostEval",
        "process3RowsBlock",
        "createBlocksLayout",
        "setEntry",
        "initialSplits",
        "getQT",
        "iterator",
        "verifyDataSet",
        "hashOf",
        "setColumnVector",
        "transform2",
        "updateResidualsAndCost",
        "getCenters",
        "addToEntry",
        "transpose",
        "pow",
        "subtract",
        "getVT",
        "OpenIntToDoubleHashMap",
        "getCoefficients",
        "multiplyEntry",
        "setRowVector",
        "FastSineTransformer",
        "verifyIterationCount",
        "createMatrix",
        "getFrobeniusNorm",
        "findEigenvalues",
        "factorialDouble",
        "roundUnscaled",
        "walkInOptimizedOrder",
        "subAndCheck",
        "solve",
        "updateSigma",
        "changeIndexSign",
        "smooth",
        "buildArray",
        "RiddersSolver",
        "countEigenValues",
        "nextPowerOfTwo",
        "normal",
        "mulAndCheck",
        "getNewtonCoefficients",
        "getH",
        "LevenbergMarquardtEstimator",
        "getImagEigenvalue",
        "factorial",
        "probe",
        "clone",
        "verifyInterpolationArray",
        "eigenvaluesRange",
        "getOmegaImaginary",
        "processGeneralBlock",
        "getRealEigenvalue",
        "PolynomialFunctionLagrangeForm",
        "fft",
        "getV",
        "round",
        "MullerSolver",
        "getMaxIterations",
        "LevenbergMarquardtOptimizer",
        "setCostRelativeTolerance",
        "addAndCheck",
        "getOmegaReal",
        "scalarMultiply",
        "toBlocksLayout",
        "getColumnVector",
        "getSolver",
        "isForward",
        "getInterpolatingPoints",
        "nextAfter",
        "Solver",
        "getCostEvaluations",
        "getRowVector",
        "blockWidth",
        "gcd",
        "size",
        "MultiDimensionalComplexMatrix",
        "getMaxEvaluations",
        "key",
        "blockHeight",
        "set",
        "setColumn",
        "inversetransform",
        "doOptimize",
        "evaluate",
        "setSubMatrix",
        "getEntry",
        "operate",
        "OpenIntToFieldHashMap",
        "getConvergenceChecker",
        "illumination",
        "determineLMDirection",
        "MathUtils",
        "checkAllFiniteReal",
        "reset"
      ],
      "functions_name_co_evolved_modified_file": [
        "findEigenvector",
        "findEigenvalues",
        "flipIfWarranted",
        "progressiveQuotientDifferenceWithShift",
        "stationaryQuotientDifferenceWithShift"
      ],
      "functions_name_co_evolved_all_files": [
        "qTy",
        "add",
        "findEigenvector",
        "MicrosphereInterpolatingFunction",
        "walkInRowOrder",
        "computeDividedDifference",
        "progressiveQuotientDifferenceWithShift",
        "getSubMatrix",
        "fft",
        "solve2",
        "computeCoefficients",
        "toBlocksLayout",
        "get",
        "interpolate",
        "determineLMParameter",
        "binomialCoefficient",
        "estimate",
        "updateJacobian",
        "containsKey",
        "fct",
        "createBlocksLayout",
        "stationaryQuotientDifferenceWithShift",
        "updateResidualsAndCost",
        "doOptimize",
        "fst",
        "evaluate",
        "operate",
        "transpose",
        "subtract",
        "stage",
        "integrate",
        "findEigenvalues",
        "multiply",
        "flipIfWarranted",
        "determineLMDirection",
        "walkInOptimizedOrder",
        "solve",
        "smooth",
        "remove"
      ]
    },
    "file": {
      "file_name": "EigenDecompositionImpl.java",
      "file_nloc": 1173,
      "file_complexity": 248,
      "file_token_count": 10112,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -670,10 +670,12 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n \n         // sort the realEigenvalues in decreasing order\n         Arrays.sort(realEigenvalues);\n-        for (int i = 0, j = realEigenvalues.length - 1; i < j; ++i, --j) {\n+        int j = realEigenvalues.length - 1;\n+        for (int i = 0; i < j; ++i) {\n             final double tmp = realEigenvalues[i];\n             realEigenvalues[i] = realEigenvalues[j];\n             realEigenvalues[j] = tmp;\n+            --j;\n         }\n \n     }\n@@ -1126,12 +1128,14 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            for (int i = 0, j = 4 * n - 1; i < j; i += 4, j -= 4) {\n+            int j = 4 * n - 1;\n+            for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n+                j -= 4;\n             }\n             return true;\n         }\n@@ -1734,12 +1738,14 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n         // the least diagonal element in the twisted factorization\n         int r = m - 1;\n         double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n-        for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {\n+        int sixI = 0;\n+        for (int i = 0; i < m - 1; ++i) {\n             final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\n             if (absG < minG) {\n                 r = i;\n                 minG = absG;\n             }\n+            sixI += 6;\n         }\n \n         // solve the singular system by ignoring the equation\n@@ -1784,7 +1790,8 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                                                        final double lambda) {\n         final int nM1 = d.length - 1;\n         double si = -lambda;\n-        for (int i = 0, sixI = 0; i < nM1; ++i, sixI += 6) {\n+        int sixI = 0;\n+        for (int i = 0; i < nM1; ++i) {\n             final double di   = d[i];\n             final double li   = l[i];\n             final double diP1 = di + si;\n@@ -1793,6 +1800,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             work[sixI + 1]    = diP1;\n             work[sixI + 2]    = liP1;\n             si = li * liP1 * si - lambda;\n+            sixI += 6;\n         }\n         work[6 * nM1 + 1] = d[nM1] + si;\n         work[6 * nM1]     = si;\n@@ -1810,7 +1818,8 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                                                         final double lambda) {\n         final int nM1 = d.length - 1;\n         double pi = d[nM1] - lambda;\n-        for (int i = nM1 - 1, sixI = 6 * i; i >= 0; --i, sixI -= 6) {\n+        int sixI = 6 * (nM1 - 1);\n+        for (int i = nM1 - 1; i >= 0; --i) {\n             final double di   = d[i];\n             final double li   = l[i];\n             final double diP1 = di * li * li + pi;\n@@ -1819,6 +1828,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             work[sixI + 10]   = diP1;\n             work[sixI +  5]   = li * t;\n             pi = pi * t - lambda;\n+            sixI -= 6;\n         }\n         work[3] = pi;\n         work[4] = pi;\n",
      "files_name_in_blame_commit": [
        "FastCosineTransformer.java",
        "PolynomialFunctionLagrangeForm.java",
        "PolynomialFunctionNewtonForm.java",
        "AbstractLeastSquaresOptimizer.java",
        "LevenbergMarquardtEstimator.java",
        "OpenIntToFieldHashMap.java",
        "BlockRealMatrix.java",
        "TrapezoidIntegrator.java",
        "SimpsonIntegrator.java",
        "RiddersSolver.java",
        "OpenIntToDoubleHashMap.java",
        "FastSineTransformer.java",
        "MicrosphereInterpolatingFunction.java",
        "QRDecompositionImpl.java",
        "BlockFieldMatrix.java",
        "MathUtils.java",
        "FastFourierTransformer.java",
        "LoessInterpolator.java",
        "AbstractEstimator.java",
        "LevenbergMarquardtOptimizer.java",
        "DividedDifferenceInterpolator.java",
        "EigenDecompositionImpl.java",
        "MullerSolver.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 29
  }
}
{
  "id": "20",
  "blame_commit": {
    "commit": {
      "commit_id": "b88400ce0e9c1a0dadfd3417c256b02a82f38fe1",
      "commit_message": "Special case the NUL character.\nFixes issue 383\n\nR=nicksantos\nDELTA=7  (7 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=928\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@904 b0f006be-c8cd-11de-a2e8-8d36a3108c74",
      "commit_author": "johnlenz@google.com",
      "commit_date": "2011-03-18 00:03:17",
      "commit_parent": "25827942ba9d45825dfd92faa37a78dbc9034ad0"
    },
    "function": {
      "function_name": "strEscape",
      "function_code_before": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "function_code_after": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "function_before_start_line": 956,
      "function_before_end_line": 1025,
      "function_after_start_line": 956,
      "function_after_end_line": 1026,
      "function_before_token_count": 408,
      "function_after_token_count": 420,
      "functions_name_modified_file": [
        "CodeGenerator",
        "getFirstNonEmptyChild",
        "add",
        "getContextForNoInOperator",
        "getNonEmptyChildCount",
        "jsString",
        "identifierEscape",
        "isIndirectEval",
        "addNonEmptyStatement",
        "regexpEscape",
        "addList",
        "appendHexJavaScriptRepresentation",
        "addCaseBody",
        "addLeftExpr",
        "addIdentifier",
        "escapeToDoubleQuotedJsString",
        "strEscape",
        "addAllSiblings",
        "clearContextForNoInOperator",
        "isOneExactlyFunctionOrDo",
        "addExpr",
        "addArrayList",
        "tagAsStrict",
        "getContextForNonEmptyExpression"
      ],
      "functions_name_all_files": [
        "CodeGenerator",
        "testTypeAnnotationsInterface",
        "testIndirectEval",
        "parsePrint",
        "getNonEmptyChildCount",
        "testPrettyPrinter",
        "assertPrintNode",
        "addNonEmptyStatement",
        "assertPrint",
        "testReparse",
        "addCaseBody",
        "escapeToDoubleQuotedJsString",
        "testLineLength",
        "testPrintInOperatorInForLoop",
        "strEscape",
        "testSetter",
        "testPrettyPrinter3",
        "testAmbiguousElseClauses",
        "testFunctionWithCall",
        "testPrettyPrinter2",
        "addExpr",
        "testFunctionSafariCompatiblity",
        "testParsePrintParse",
        "tagAsStrict",
        "testOptionalTypesAnnotation",
        "jsString",
        "identifierEscape",
        "testLineBreak",
        "testVariableArgumentsTypesAnnotation",
        "assertLineLength",
        "testDoLoopIECompatiblity",
        "testTypeAnnotationsDispatcher1",
        "appendHexJavaScriptRepresentation",
        "testZero",
        "checkUnexpectedErrorsOrWarnings",
        "addLeftExpr",
        "testPrettyPrinter4",
        "testDirectEval",
        "addIdentifier",
        "assertPrintNumber",
        "testPrintArray",
        "testTypeAnnotationsAssign",
        "assertTypeAnnotations",
        "addAllSiblings",
        "isOneExactlyFunctionOrDo",
        "testTempConstructor",
        "testSubtraction",
        "testNegCollapse",
        "assertPrettyPrint",
        "testFreeCall2",
        "add",
        "testTypeAnnotationsMember",
        "testObjectLit",
        "testFreeCall1",
        "assertLineBreak",
        "testArrayLiteral",
        "regexpEscape",
        "addList",
        "testPrintScript",
        "testTypeAnnotationsImplements",
        "testHook",
        "testLiteralProperty",
        "testPrint",
        "printNode",
        "testGetter",
        "testTypeAnnotationsNamespace",
        "testU2UFunctionTypeAnnotation",
        "getContextForNonEmptyExpression",
        "getFirstNonEmptyChild",
        "testTypeAnnotationsDispatcher2",
        "getContextForNoInOperator",
        "isIndirectEval",
        "parse",
        "testTypeAnnotations",
        "testStrict",
        "testFreeCall3",
        "testEmitUnknownParamTypesAsAllType",
        "testTypeAnnotationsMemberSubclass",
        "clearContextForNoInOperator",
        "testTypeAnnotationsTypeDef",
        "addArrayList",
        "testExponents"
      ],
      "functions_name_co_evolved_modified_file": [
        "strEscape"
      ],
      "functions_name_co_evolved_all_files": [
        "testZero",
        "strEscape"
      ]
    },
    "file": {
      "file_name": "CodeGenerator.java",
      "file_nloc": 847,
      "file_complexity": 232,
      "file_token_count": 5512,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -963,6 +963,7 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n+        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n",
      "files_name_in_blame_commit": [
        "CodeGenerator.java",
        "CodePrinterTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 53
  }
}
{
  "id": "51",
  "blame_commit": {
    "commit": {
      "commit_id": "765a9f1ecdfaf96f3587f488385111c9d6a4927e",
      "commit_message": "Brand new classes for streaming JSON efficiently.\n\nNotable features:\n - Efficiency. The parser is faster than the current javacc parser. It's also faster than popular libraries for JSON streaming.\n - Toggle lenient/strict\n - Toggle pretty/compact\n - Friendly error messages on bad JSON\n - GSON-quality Javadoc\n - Non-execute prefix handling\n\nThis doesn't wire JsonReader up into Gson just yet. That's coming soon...",
      "commit_author": "Jesse Wilson",
      "commit_date": "2010-08-26 08:44:02",
      "commit_parent": "5bffa1f6790b2a5e8bc0996240c1b12317793324"
    },
    "function": {
      "function_name": "value",
      "function_code_before": "",
      "function_code_after": "public JsonWriter value(double value) throws IOException {\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue(false);\n  out.append(Double.toString(value));\n  return this;\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 314,
      "function_after_end_line": 321,
      "function_before_token_count": 0,
      "function_after_token_count": 56,
      "functions_name_modified_file": [
        "string",
        "value",
        "newline",
        "beforeValue",
        "replaceTop",
        "open",
        "name",
        "close",
        "endObject",
        "nullValue",
        "endArray",
        "beforeName",
        "flush",
        "beginObject",
        "setIndent",
        "JsonWriter",
        "beginArray",
        "peek"
      ],
      "functions_name_all_files": [
        "testNulls",
        "testMultipleTopLevelValues",
        "toString",
        "newline",
        "testMissingValue",
        "testStrictUnquotedNames",
        "name",
        "testLenientSemicolonDelimitedArray",
        "testLenientTopLevelValueType",
        "testNameWithoutValue",
        "syntaxError",
        "testReadEmptyObject",
        "testStrictSemicolonDelimitedNameValuePair",
        "testLenientUnquotedNames",
        "testLenientMultipleTopLevelValues",
        "testNullName",
        "testDeepNestingObjects",
        "nextLiteral",
        "testStrictSingleQuotedNames",
        "testLenientSingleQuotedStrings",
        "nextName",
        "JsonReader",
        "testDeepNestingArrays",
        "hasNext",
        "beforeName",
        "testStrictTopLevelValueType",
        "testCharacterUnescaping",
        "testTwoNames",
        "testLenientNonFiniteDoubles",
        "decodeLiteral",
        "JsonSyntaxException",
        "testRepeatedName",
        "nextString",
        "readEscapeCharacter",
        "flush",
        "testReadObject",
        "objectValue",
        "beginArray",
        "testNullStringValue",
        "checkLenient",
        "open",
        "testStrictNonExecutePrefix",
        "fillBuffer",
        "advance",
        "testIntegersWithFractionalPartSpecified",
        "testLenientUnnecessaryArraySeparators",
        "nextInObject",
        "testObjectsInArrays",
        "testStringNullIsNotNull",
        "peek",
        "nextNull",
        "testEmptyObject",
        "testSkipObject",
        "nextLong",
        "close",
        "testStrictSingleQuotedStrings",
        "testStrictNonFiniteDoubles",
        "testStrictSemicolonDelimitedArray",
        "testLenientNonExecutePrefix",
        "testStrictNameValueSeparator",
        "nextNonWhitespace",
        "testNonFiniteDoubles",
        "testLongs",
        "testLenientNameValueSeparator",
        "endObject",
        "testHelloWorld",
        "testStrings",
        "testPrematureEndOfInput",
        "testPrematurelyClosed",
        "nextBoolean",
        "beginObject",
        "testMixedCaseLiterals",
        "testPrettyPrintObject",
        "testNullLiteralIsNotAString",
        "isLenient",
        "value",
        "testLenientPartialNonExecutePrefix",
        "push",
        "testPrettyPrintArray",
        "peekStack",
        "endArray",
        "nextInt",
        "JsonWriter",
        "testBadNestingArray",
        "getSnippet",
        "testNextFailuresDoNotAdvance",
        "testNumberWithOctalPrefix",
        "testValueWithoutName",
        "testLenientSingleQuotedNames",
        "testEmptyArray",
        "testBooleans",
        "skipValue",
        "testStrictUnnecessaryArraySeparators",
        "testBadNestingObject",
        "expect",
        "testArraysInObjects",
        "nextValue",
        "readLiteral",
        "testReadArray",
        "testNumbers",
        "testNoTopLevelObject",
        "setIndent",
        "nextInArray",
        "testEmptyString",
        "testLenientSemicolonDelimitedNameValuePair",
        "beforeValue",
        "replaceTop",
        "testDoubles",
        "testNonFiniteBoxedDoubles",
        "testWrongTopLevelType",
        "setLenient",
        "testStrictUnquotedStrings",
        "quickPeek",
        "testStrictComments",
        "testStrictMultipleTopLevelValues",
        "testLenientUnquotedStrings",
        "skipToEndOfLine",
        "testLenientComments",
        "nullValue",
        "testReadEmptyArray",
        "testHighPrecisionLong",
        "string",
        "testLenientNonExecutePrefixWithLeadingWhitespace",
        "consumeNonExecutePrefix",
        "pop",
        "skipTo",
        "nextDouble"
      ],
      "functions_name_co_evolved_modified_file": [
        "string",
        "value",
        "newline",
        "beforeValue",
        "replaceTop",
        "name",
        "open",
        "close",
        "endObject",
        "nullValue",
        "endArray",
        "beforeName",
        "flush",
        "beginObject",
        "setIndent",
        "JsonWriter",
        "beginArray",
        "peek"
      ],
      "functions_name_co_evolved_all_files": [
        "testNulls",
        "testMultipleTopLevelValues",
        "toString",
        "newline",
        "testMissingValue",
        "testStrictUnquotedNames",
        "name",
        "testLenientSemicolonDelimitedArray",
        "testLenientTopLevelValueType",
        "testNameWithoutValue",
        "syntaxError",
        "testStrictSemicolonDelimitedNameValuePair",
        "testReadEmptyObject",
        "testLenientUnquotedNames",
        "testLenientMultipleTopLevelValues",
        "testNullName",
        "testDeepNestingObjects",
        "nextLiteral",
        "testStrictSingleQuotedNames",
        "testLenientSingleQuotedStrings",
        "nextName",
        "JsonReader",
        "testDeepNestingArrays",
        "hasNext",
        "beforeName",
        "testStrictTopLevelValueType",
        "testCharacterUnescaping",
        "testTwoNames",
        "testLenientNonFiniteDoubles",
        "decodeLiteral",
        "JsonSyntaxException",
        "testRepeatedName",
        "nextString",
        "readEscapeCharacter",
        "flush",
        "testReadObject",
        "objectValue",
        "beginArray",
        "testNullStringValue",
        "checkLenient",
        "open",
        "testStrictNonExecutePrefix",
        "fillBuffer",
        "advance",
        "testIntegersWithFractionalPartSpecified",
        "testLenientUnnecessaryArraySeparators",
        "nextInObject",
        "testObjectsInArrays",
        "testStringNullIsNotNull",
        "peek",
        "nextNull",
        "testEmptyObject",
        "testSkipObject",
        "nextLong",
        "close",
        "testStrictSingleQuotedStrings",
        "testStrictNonFiniteDoubles",
        "testStrictSemicolonDelimitedArray",
        "testLenientNonExecutePrefix",
        "testStrictNameValueSeparator",
        "nextNonWhitespace",
        "testNonFiniteDoubles",
        "testLongs",
        "testLenientNameValueSeparator",
        "endObject",
        "testHelloWorld",
        "testStrings",
        "testPrematureEndOfInput",
        "testPrematurelyClosed",
        "nextBoolean",
        "testMixedCaseLiterals",
        "beginObject",
        "testPrettyPrintObject",
        "testNullLiteralIsNotAString",
        "isLenient",
        "value",
        "testLenientPartialNonExecutePrefix",
        "push",
        "testPrettyPrintArray",
        "peekStack",
        "endArray",
        "nextInt",
        "JsonWriter",
        "testBadNestingArray",
        "getSnippet",
        "testNextFailuresDoNotAdvance",
        "testNumberWithOctalPrefix",
        "testValueWithoutName",
        "testLenientSingleQuotedNames",
        "testEmptyArray",
        "testBooleans",
        "skipValue",
        "testStrictUnnecessaryArraySeparators",
        "testBadNestingObject",
        "expect",
        "testArraysInObjects",
        "nextValue",
        "readLiteral",
        "testReadArray",
        "testNumbers",
        "testNoTopLevelObject",
        "setIndent",
        "nextInArray",
        "testLenientSemicolonDelimitedNameValuePair",
        "testEmptyString",
        "beforeValue",
        "replaceTop",
        "testDoubles",
        "testNonFiniteBoxedDoubles",
        "testWrongTopLevelType",
        "setLenient",
        "testStrictUnquotedStrings",
        "quickPeek",
        "testStrictComments",
        "testStrictMultipleTopLevelValues",
        "testLenientUnquotedStrings",
        "skipToEndOfLine",
        "testLenientComments",
        "nullValue",
        "testReadEmptyArray",
        "testHighPrecisionLong",
        "string",
        "testLenientNonExecutePrefixWithLeadingWhitespace",
        "consumeNonExecutePrefix",
        "pop",
        "skipTo",
        "nextDouble"
      ]
    },
    "file": {
      "file_name": "JsonWriter.java",
      "file_nloc": 211,
      "file_complexity": 58,
      "file_token_count": 1186,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,495 @@\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * encoded value to a stream, one token at a time. The stream includes both\n+ * literal values (strings, numbers, booleans and nulls) as well as the begin\n+ * and end delimiters of objects and arrays.\n+ *\n+ * <h3>Encoding JSON</h3>\n+ * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n+ * document must contain one top-level array or object. Call methods on the\n+ * writer as you walk the structure's contents, nesting arrays and objects as\n+ * necessary:\n+ * <ul>\n+ *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n+ *       Write each of the array's elements with the appropriate {@link #value}\n+ *       methods or by nesting other arrays and objects. Finally close the array\n+ *       using {@link #endArray()}.\n+ *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n+ *       Write each of the object's properties by alternating calls to\n+ *       {@link #name} with the property's value. Write property values with the\n+ *       appropriate {@link #value} method or by nesting other objects or arrays.\n+ *       Finally close the object using {@link #endObject()}.\n+ * </ul>\n+ *\n+ * <h3>Example</h3>\n+ * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n+ * [\n+ *   {\n+ *     \"id\": 912345678901,\n+ *     \"text\": \"How do I stream JSON in Java?\",\n+ *     \"geo\": null,\n+ *     \"user\": {\n+ *       \"name\": \"json_newb\",\n+ *       \"followers_count\": 41\n+ *      }\n+ *   },\n+ *   {\n+ *     \"id\": 912345678902,\n+ *     \"text\": \"@json_newb just use JsonWriter!\",\n+ *     \"geo\": [50.454722, -104.606667],\n+ *     \"user\": {\n+ *       \"name\": \"jesse\",\n+ *       \"followers_count\": 2\n+ *     }\n+ *   }\n+ * ]}</pre>\n+ * This code encodes the above structure: <pre>   {@code\n+ *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n+ *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n+ *     writer.setIndentSpaces(4);\n+ *     writeMessagesArray(writer, messages);\n+ *     writer.close();\n+ *   }\n+ *\n+ *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n+ *     writer.beginArray();\n+ *     for (Message message : messages) {\n+ *       writeMessage(writer, message);\n+ *     }\n+ *     writer.endArray();\n+ *   }\n+ *\n+ *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n+ *     writer.beginObject();\n+ *     writer.name(\"id\").value(message.getId());\n+ *     writer.name(\"text\").value(message.getText());\n+ *     if (message.getGeo() != null) {\n+ *       writer.name(\"geo\");\n+ *       writeDoublesArray(writer, message.getGeo());\n+ *     } else {\n+ *       writer.name(\"geo\").nullValue();\n+ *     }\n+ *     writer.name(\"user\");\n+ *     writeUser(writer, message.getUser());\n+ *     writer.endObject();\n+ *   }\n+ *\n+ *   public void writeUser(JsonWriter writer, User user) throws IOException {\n+ *     writer.beginObject();\n+ *     writer.name(\"name\").value(user.getName());\n+ *     writer.name(\"followers_count\").value(user.getFollowersCount());\n+ *     writer.endObject();\n+ *   }\n+ *\n+ *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n+ *     writer.beginArray();\n+ *     for (Double value : doubles) {\n+ *       writer.value(value);\n+ *     }\n+ *     writer.endArray();\n+ *   }}</pre>\n+ *\n+ * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n+ * Instances of this class are not thread safe. Calls that would result in a\n+ * malformed JSON string will fail with an {@link IllegalStateException}.\n+ * \n+ * @author Jesse Wilson\n+ */\n+public final class JsonWriter implements Closeable {\n+\n+  /** The output data, containing at most one top-level array or object. */\n+  private final Writer out;\n+\n+  private final List<JsonScope> stack = new ArrayList<JsonScope>();\n+  {\n+    stack.add(JsonScope.EMPTY_DOCUMENT);\n+  }\n+\n+  /**\n+   * A string containing a full set of spaces for a single level of\n+   * indentation, or null for no pretty printing.\n+   */\n+  private String indent;\n+\n+  /**\n+   * The name/value separator; either \":\" or \": \".\n+   */\n+  private String separator = \":\";\n+\n+  /**\n+   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n+   * For best performance, ensure {@link Writer} is buffered; wrapping in\n+   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n+   */\n+  public JsonWriter(Writer out) {\n+    if (out == null) {\n+      throw new NullPointerException(\"out == null\");\n+    }\n+    this.out = out;\n+  }\n+\n+  /**\n+   * Sets the indentation string to be repeated for each level of indentation\n+   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n+   * will be compact. Otherwise the encoded document will be more\n+   * human-readable.\n+   *\n+   * @param indent a string containing only whitespace.\n+   */\n+  public void setIndent(String indent) {\n+    if (indent.isEmpty()) {\n+      this.indent = null;\n+      this.separator = \":\";\n+    } else {\n+      this.indent = indent;\n+      this.separator = \": \";\n+    }\n+  }\n+\n+  /**\n+   * Begins encoding a new array. Each call to this method must be paired with\n+   * a call to {@link #endArray}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter beginArray() throws IOException {\n+    return open(JsonScope.EMPTY_ARRAY, \"[\");\n+  }\n+\n+  /**\n+   * Ends encoding the current array.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter endArray() throws IOException {\n+    return close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, \"]\");\n+  }\n+\n+  /**\n+   * Begins encoding a new object. Each call to this method must be paired\n+   * with a call to {@link #endObject}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter beginObject() throws IOException {\n+    return open(JsonScope.EMPTY_OBJECT, \"{\");\n+  }\n+\n+  /**\n+   * Ends encoding the current object.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter endObject() throws IOException {\n+    return close(JsonScope.EMPTY_OBJECT, JsonScope.NONEMPTY_OBJECT, \"}\");\n+  }\n+\n+  /**\n+   * Enters a new scope by appending any necessary whitespace and the given\n+   * bracket.\n+   */\n+  private JsonWriter open(JsonScope empty, String openBracket) throws IOException {\n+    beforeValue(true);\n+    stack.add(empty);\n+    out.write(openBracket);\n+    return this;\n+  }\n+\n+  /**\n+   * Closes the current scope by appending any necessary whitespace and the\n+   * given bracket.\n+   */\n+  private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket)\n+      throws IOException {\n+    JsonScope context = peek();\n+    if (context != nonempty && context != empty) {\n+      throw new IllegalStateException(\"Nesting problem: \" + stack);\n+    }\n+\n+    stack.remove(stack.size() - 1);\n+    if (context == nonempty) {\n+      newline();\n+    }\n+    out.write(closeBracket);\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the value on the top of the stack.\n+   */\n+  private JsonScope peek() {\n+    return stack.get(stack.size() - 1);\n+  }\n+\n+  /**\n+   * Replace the value on the top of the stack with the given value.\n+   */\n+  private void replaceTop(JsonScope topOfStack) {\n+    stack.set(stack.size() - 1, topOfStack);\n+  }\n+\n+  /**\n+   * Encodes the property name.\n+   *\n+   * @param name the name of the forthcoming value. May not be null.\n+   * @return this writer.\n+   */\n+  public JsonWriter name(String name) throws IOException {\n+    if (name == null) {\n+      throw new NullPointerException(\"name == null\");\n+    }\n+    beforeName();\n+    string(name);\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @param value the literal string value, or null to encode a null literal.\n+   * @return this writer.\n+   */\n+  public JsonWriter value(String value) throws IOException {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+    beforeValue(false);\n+    string(value);\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code null}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter nullValue() throws IOException {\n+    beforeValue(false);\n+    out.write(\"null\");\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter value(boolean value) throws IOException {\n+    beforeValue(false);\n+    out.write(value ? \"true\" : \"false\");\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n+   *     {@link Double#isInfinite() infinities}.\n+   * @return this writer.\n+   */\n+  public JsonWriter value(double value) throws IOException {\n+    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n+    }\n+    beforeValue(false);\n+    out.append(Double.toString(value));\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter value(long value) throws IOException {\n+    beforeValue(false);\n+    out.write(Long.toString(value));\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n+   *     {@link Double#isInfinite() infinities}.\n+   * @return this writer.\n+   */\n+  public JsonWriter value(Number value) throws IOException {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+\n+    String string = value.toString();\n+    if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\n+      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n+    }\n+    beforeValue(false);\n+    out.append(string);\n+    return this;\n+  }\n+\n+  /**\n+   * Ensures all buffered data is written to the underlying {@link Writer}\n+   * and flushes that writer.\n+   */\n+  public void flush() throws IOException {\n+    out.flush();\n+  }\n+\n+  /**\n+   * Flushes and closes this writer and the underlying {@link Writer}.\n+   *\n+   * @throws IOException if the JSON document is incomplete.\n+   */\n+  public void close() throws IOException {\n+    out.close();\n+\n+    if (peek() != JsonScope.NONEMPTY_DOCUMENT) {\n+      throw new IOException(\"Incomplete document\");\n+    }\n+  }\n+\n+  private void string(String value) throws IOException {\n+    out.write(\"\\\"\");\n+    for (int i = 0, length = value.length(); i < length; i++) {\n+      char c = value.charAt(i);\n+\n+      /*\n+       * From RFC 4627, \"All Unicode characters may be placed within the\n+       * quotation marks except for the characters that must be escaped:\n+       * quotation mark, reverse solidus, and the control characters\n+       * (U+0000 through U+001F).\"\n+       */\n+      switch (c) {\n+      case '\"':\n+      case '\\\\':\n+      case '/':\n+        out.write('\\\\');\n+        out.write(c);\n+        break;\n+\n+      case '\\t':\n+        out.write(\"\\\\t\");\n+        break;\n+\n+      case '\\b':\n+        out.write(\"\\\\b\");\n+        break;\n+\n+      case '\\n':\n+        out.write(\"\\\\n\");\n+        break;\n+\n+      case '\\r':\n+        out.write(\"\\\\r\");\n+        break;\n+\n+      case '\\f':\n+        out.write(\"\\\\f\");\n+        break;\n+\n+      default:\n+        if (c <= 0x1F) {\n+          out.write(String.format(\"\\\\u%04x\", (int) c));\n+        } else {\n+          out.write(c);\n+        }\n+        break;\n+      }\n+\n+    }\n+    out.write(\"\\\"\");\n+  }\n+\n+  private void newline() throws IOException {\n+    if (indent == null) {\n+      return;\n+    }\n+\n+    out.write(\"\\n\");\n+    for (int i = 1; i < stack.size(); i++) {\n+      out.write(indent);\n+    }\n+  }\n+\n+  /**\n+   * Inserts any necessary separators and whitespace before a name. Also\n+   * adjusts the stack to expect the name's value.\n+   */\n+  private void beforeName() throws IOException {\n+    JsonScope context = peek();\n+    if (context == JsonScope.NONEMPTY_OBJECT) { // first in object\n+      out.write(',');\n+    } else if (context != JsonScope.EMPTY_OBJECT) { // not in an object!\n+      throw new IllegalStateException(\"Nesting problem: \" + stack);\n+    }\n+    newline();\n+    replaceTop(JsonScope.DANGLING_NAME);\n+  }\n+\n+  /**\n+   * Inserts any necessary separators and whitespace before a literal value,\n+   * inline array, or inline object. Also adjusts the stack to expect either a\n+   * closing bracket or another element.\n+   *\n+   * @param root true if the value is a new array or object, the two values\n+   *     permitted as top-level elements.\n+   */\n+  private void beforeValue(boolean root) throws IOException {\n+    switch (peek()) {\n+    case EMPTY_DOCUMENT: // first in document\n+      if (!root) {\n+        throw new IllegalStateException(\n+            \"JSON must start with an array or an object.\");\n+      }\n+      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n+      break;\n+\n+    case EMPTY_ARRAY: // first in array\n+      replaceTop(JsonScope.NONEMPTY_ARRAY);\n+      newline();\n+      break;\n+\n+    case NONEMPTY_ARRAY: // another in array\n+      out.append(',');\n+      newline();\n+      break;\n+\n+    case DANGLING_NAME: // value for name\n+      out.append(separator);\n+      replaceTop(JsonScope.NONEMPTY_OBJECT);\n+      break;\n+\n+    case NONEMPTY_DOCUMENT:\n+        throw new IllegalStateException(\n+            \"JSON must have only one top-level value.\");\n+\n+    default:\n+      throw new IllegalStateException(\"Nesting problem: \" + stack);\n+    }\n+  }\n+}\n",
      "files_name_in_blame_commit": [
        "JsonReaderTest.java",
        "JsonScope.java",
        "JsonWriter.java",
        "JsonToken.java",
        "JsonReader.java",
        "JsonWriterTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 18
  }
}
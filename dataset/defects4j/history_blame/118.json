{
  "id": "118",
  "blame_commit": {
    "commit": {
      "commit_id": "552be4b677ec30a34d04d234395ba1a8c7beaacf",
      "commit_message": "DateTimeZone.getOffsetFromLocal [2952991]\nThe behaviour during DST overlaps is now defined to always return the earlier instant which is normally known as daylight or summer time. Previously, the result varied by hemisphere. This affects the constructor of DateTime and other methods\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1596 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1",
      "commit_author": "Stephen Colebourne",
      "commit_date": "2010-12-05 23:43:18",
      "commit_parent": "c7a581e55fc988bd90fa4bb1b0acece5181b7c5f"
    },
    "function": {
      "function_name": "getOffsetFromLocal",
      "function_code_before": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantLocal - offsetLocal);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
      "function_code_after": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal > 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
      "function_before_start_line": 876,
      "function_before_end_line": 897,
      "function_after_start_line": 879,
      "function_after_end_line": 910,
      "function_before_token_count": 79,
      "function_after_token_count": 138,
      "functions_name_modified_file": [
        "getProvider",
        "writeReplace",
        "toString",
        "forOffsetMillis",
        "getNameProvider",
        "getName",
        "readResolve",
        "getShortName",
        "convertUTCToLocal",
        "hashCode",
        "Stub",
        "setNameProvider0",
        "setDefault",
        "parseOffset",
        "isStandardOffset",
        "setNameProvider",
        "setProvider0",
        "getDefault",
        "forOffsetHoursMinutes",
        "forTimeZone",
        "DateTimeZone",
        "printOffset",
        "getID",
        "getDefaultNameProvider",
        "forID",
        "getMillisKeepLocal",
        "offsetFormatter",
        "getOffset",
        "getOffsetFromLocal",
        "toTimeZone",
        "getAvailableIDs",
        "forOffsetHours",
        "convertLocalToUTC",
        "writeObject",
        "fixedOffsetZone",
        "isLocalDateTimeGap",
        "readObject",
        "getConvertedId",
        "setProvider",
        "getDefaultProvider"
      ],
      "functions_name_all_files": [
        "writeReplace",
        "toString",
        "testWithMillisOfSecondInDstChange_Paris_winter",
        "test_DateTime_parse_Turk",
        "getShortName",
        "test_DateTime_roundCeiling_hour_NewYork_Spring_postCutover",
        "test_DateTime_plusHour_Guatemata_Autumn",
        "setNameProvider0",
        "test_MutableDateTime_withZoneRetainFields_Gaza",
        "test_DateTime_withZoneRetainFields_Turk",
        "test_DateTime_minusHour_Turk",
        "setDefault",
        "parseOffset",
        "test_DateTime_roundCeiling_secondOfMinute_NewYork_Autumn_postCutover",
        "isStandardOffset",
        "test_DateTime_minusDay_Gaza",
        "testPlusMillisInDstChange",
        "DateTimeZone",
        "getDefault",
        "test_DateTime_roundFloor_hour_NewYork_Spring_postCutover",
        "test_DateTime_roundFloor_minuteOfHour_NewYork_Autumn_preCutover",
        "test_getOffsetFromLocal_NewYork_Autumn",
        "main",
        "setUp",
        "test_DateTime_plusHour_NewYork_Autumn",
        "test_DateTime_roundCeiling_hourOfDay_NewYork_Autumn_postCutover",
        "test_DateTime_roundFloor_Turk",
        "test_DateTime_roundCeiling_hour_NewYork_Spring_preCutover",
        "test_DateTime_minusHour_Moscow_Autumn",
        "test_DateTime_roundFloor_hourOfDay_NewYork_Autumn_preCutover",
        "testPlusSecondsInDstChange",
        "test_DateTime_setHourForward_NewYork_Spring",
        "test_DateTime_withDay_Turk",
        "test_DateTime_roundFloor_day_NewYork_Spring_postCutover",
        "test_GuatemataIsCorrect_Autumn",
        "test_LocalDate_new_Turk",
        "test_DateTime_minusDay_Turk",
        "doTest_getOffsetFromLocal_Gaza",
        "test_DateTime_addWrapFieldDay_Turk",
        "fixedOffsetZone",
        "test_getOffsetFromLocal_NewYork_Spring",
        "readObject",
        "test_DateTime_roundFloor_day_NewYork_Autumn_preCutover",
        "test_DateTime_roundCeiling_day_NewYork_Autumn_preCutover",
        "test_MutableDateTime_setZoneRetainFields_Turk",
        "test_DateTime_roundFloor_minute_NewYork_Spring_preCutover",
        "tearDown",
        "test_DateTime_plusDayMidGap_Gaza",
        "test_getOffsetFromLocal_Guatemata_Autumn",
        "convertUTCToLocal",
        "test_DateTime_roundCeiling_secondOfMinute_NewYork_Autumn_preCutover",
        "Stub",
        "test_DateTime_newValid_Gaza",
        "test_DateTime_plusDay_Turk",
        "test_DateTime_plusDayMidGap_Turk",
        "test_DateTime_roundFloor_day_NewYork_Spring_preCutover",
        "test_DateTime_roundFloor_hour_NewYork_Spring_preCutover",
        "test_DateTime_minusHour_Guatemata_Autumn",
        "testWithMillisOfSecondInDstChange_Paris_summer",
        "setProvider0",
        "test_getOffsetFromLocal_Moscow_Autumn_overlap_mins",
        "forOffsetHoursMinutes",
        "forTimeZone",
        "test_MoscowIsCorrect_Spring",
        "test_DateTime_roundFloorNotDST_Turk",
        "test_DateTime_constructor_Moscow_Autumn",
        "testWithMinuteOfHourInDstChange_mockZone",
        "testWithMinuteOfHourInDstChange",
        "getMillisKeepLocal",
        "test_DateTime_roundCeiling_day_NewYork_Autumn_postCutover",
        "test_DateTime_addWrapFieldDay_Gaza",
        "test_DateTime_setHourAcross_Moscow_Spring",
        "test_DateTime_withDay_Gaza",
        "test_DateTime_roundCeiling_minuteOfHour_NewYork_Autumn_postCutover",
        "test_DateTime_setHourZero_Gaza",
        "test_DateTime_newValid_Turk",
        "isLocalDateTimeGap",
        "test_DateTime_roundCeiling_Turk",
        "setProvider",
        "test_DateTime_new_Turk",
        "test_DateTime_roundCeiling_minute_NewYork_Spring_preCutover",
        "test_DateTime_roundFloor_hourOfDay_NewYork_Autumn_postCutover",
        "test_DateTime_setHourZero_Turk",
        "forOffsetMillis",
        "getName",
        "test_DateTime_plusHour_Moscow_Autumn",
        "test_DateTime_parse_Gaza",
        "test_DateTime_roundCeiling_day_NewYork_Spring_preCutover",
        "test_DateTime_roundFloor_Gaza",
        "testWithMillisOfSecondInDstChange_NewYork_winter",
        "test_DateTime_setHourAcross_NewYork_Spring",
        "printOffset",
        "test_NewYorkIsCorrect_Autumn",
        "test_DateTime_plusDay_Gaza",
        "getID",
        "getDefaultNameProvider",
        "test_MockTurkIsCorrect",
        "test_DateTime_plusHour_Turk",
        "test_DateTime_roundFloor_minute_NewYork_Spring_postCutover",
        "test_DateTime_roundFloor_minuteOfHour_NewYork_Autumn_postCutover",
        "offsetFormatter",
        "test_DateTime_minusHour_NewYork_Autumn",
        "test_DateTime_roundFloor_secondOfMinute_NewYork_Autumn_preCutover",
        "getOffset",
        "TestDateTimeZoneCutover",
        "test_getOffsetFromLocal_Turk",
        "testWithSecondOfMinuteInDstChange",
        "getAvailableIDs",
        "test_LocalDate_toDateMidnight_Gaza",
        "test_DateTime_roundCeiling_minute_NewYork_Spring_postCutover",
        "doTest_getOffsetFromLocal_Turk",
        "testBug2182444_ausNSW",
        "test_getOffsetFromLocal_Moscow_Spring",
        "test_DateTime_roundCeiling_minuteOfHour_NewYork_Autumn_preCutover",
        "getDefaultProvider",
        "test_DateTime_roundFloor_secondOfMinute_NewYork_Autumn_postCutover",
        "getProvider",
        "test_DateTime_setHourBack_NewYork_Spring",
        "testWithMillisOfSecondInDstChange_NewYork_summer",
        "getNameProvider",
        "readResolve",
        "test_getOffsetFromLocal_Gaza",
        "test_DateTime_roundFloor_day_NewYork_Autumn_postCutover",
        "hashCode",
        "test_DateTime_roundCeiling_Gaza",
        "test_DateTime_constructor_NewYork_Autumn",
        "test_DateTime_withHourZero_Gaza",
        "test_DateTime_withZoneRetainFields_Gaza",
        "setNameProvider",
        "test_DateTime_new_Gaza",
        "doTest_getOffsetFromLocal",
        "test_MockGazaIsCorrect",
        "test_DateTime_minusHour_Gaza",
        "testWithHourOfDayInDstChange",
        "forID",
        "test_DateTime_setHourForward_Moscow_Spring",
        "testPlusMinutesInDstChange",
        "test_MoscowIsCorrect_Autumn",
        "getOffsetFromLocal",
        "test_LocalDate_toDateMidnight_Turk",
        "test_DateTime_setHourBack_Moscow_Spring",
        "suite",
        "test_DateTime_plusHour_Gaza",
        "toTimeZone",
        "test_DateTime_withHourZero_Turk",
        "test_DateTime_roundCeiling_hourOfDay_NewYork_Autumn_preCutover",
        "testBug2182444_usCentral",
        "test_DateTime_roundCeiling_day_NewYork_Spring_postCutover",
        "test_NewYorkIsCorrect_Spring",
        "forOffsetHours",
        "convertLocalToUTC",
        "test_LocalDate_new_Gaza",
        "writeObject",
        "test_getOffsetFromLocal_Moscow_Autumn",
        "test_DateTime_JustAfterLastEverOverlap",
        "getConvertedId"
      ],
      "functions_name_co_evolved_modified_file": [
        "getOffsetFromLocal"
      ],
      "functions_name_co_evolved_all_files": [
        "test_getOffsetFromLocal_Moscow_Autumn_overlap_mins",
        "test_getOffsetFromLocal_Moscow_Autumn",
        "test_DateTime_constructor_Moscow_Autumn",
        "getOffsetFromLocal",
        "doTest_getOffsetFromLocal",
        "test_DateTime_constructor_NewYork_Autumn"
      ]
    },
    "file": {
      "file_name": "DateTimeZone.java",
      "file_nloc": 556,
      "file_complexity": 130,
      "file_token_count": 3447,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -866,18 +866,22 @@ public abstract class DateTimeZone implements Serializable {\n      * Input: 02:00  Output: 02:00<br />\n      * Input: 02:30  Output: 02:30<br />\n      * <p>\n-     * NOTE: The behaviour of this method changed in v1.5, with the emphasis\n-     * on returning a consistent result later along the time-line (shown above).\n+     * During a DST overlap (where the local time is ambiguous) this method will return\n+     * the earlier instant. The combination of these two rules is to always favour\n+     * daylight (summer) time over standard (winter) time.\n+     * <p>\n+     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n+     * Prior to v1.5, the DST gap behaviour was also not defined.\n      *\n-     * @param instantLocal  the millisecond instant, relative to this time zone, to\n-     * get the offset for\n+     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n      * @return the millisecond offset to subtract from local time to get UTC time\n      */\n     public int getOffsetFromLocal(long instantLocal) {\n         // get the offset at instantLocal (first estimate)\n-        int offsetLocal = getOffset(instantLocal);\n+        final int offsetLocal = getOffset(instantLocal);\n         // adjust instantLocal using the estimate and recalc the offset\n-        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n+        final long instantAdjusted = instantLocal - offsetLocal;\n+        final int offsetAdjusted = getOffset(instantAdjusted);\n         // if the offsets differ, we must be near a DST boundary\n         if (offsetLocal != offsetAdjusted) {\n             // we need to ensure that time is always after the DST gap\n@@ -886,12 +890,21 @@ public abstract class DateTimeZone implements Serializable {\n                 // if we just return offsetAdjusted then the time is pushed\n                 // back before the transition, whereas it should be\n                 // on or after the transition\n-                long nextLocal = nextTransition(instantLocal - offsetLocal);\n+                long nextLocal = nextTransition(instantAdjusted);\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n+        } else if (offsetLocal > 0) {\n+            long prev = previousTransition(instantAdjusted);\n+            if (prev < instantAdjusted) {\n+                int offsetPrev = getOffset(prev);\n+                int diff = offsetPrev - offsetLocal;\n+                if (instantAdjusted - prev <= diff) {\n+                    return offsetPrev;\n+                }\n+            }\n         }\n         return offsetAdjusted;\n     }\n",
      "files_name_in_blame_commit": [
        "DateTimeZone.java",
        "TestDateTimeZoneCutover.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 52
  }
}
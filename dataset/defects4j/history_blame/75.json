{
  "id": "75",
  "blame_commit": {
    "commit": {
      "commit_id": "8749726a79c22451b1f01b14fb2137f734e926b4",
      "commit_message": "Reimplementation of parser and tokeniser, to make jsoup a HTML5 conformat parser, against the\nhttp://whatwg.org/html spec.",
      "commit_author": "Jonathan Hedley",
      "commit_date": "2011-07-02 21:12:08",
      "commit_parent": "481542f5c74c013b06f6b80e8e9bb30ddad382dd"
    },
    "function": {
      "function_name": "matchesLetter",
      "function_code_before": "",
      "function_code_after": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input.charAt(pos);\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 160,
      "function_after_end_line": 165,
      "function_before_token_count": 0,
      "function_after_token_count": 45,
      "functions_name_modified_file": [
        "toString",
        "consumeAsString",
        "matchConsume",
        "CharacterReader",
        "matchesAny",
        "consumeTo",
        "unconsume",
        "matchesLetter",
        "consumeDigitSequence",
        "pos",
        "consume",
        "consumeToEnd",
        "matches",
        "consumeHexSequence",
        "consumeToAny",
        "matchConsumeIgnoreCase",
        "isEmpty",
        "matchesDigit",
        "consumeLetterSequence",
        "rewindToMark",
        "matchesIgnoreCase",
        "advance",
        "current",
        "mark"
      ],
      "functions_name_all_files": [
        "Character",
        "aboveOnStack",
        "fail",
        "normalise",
        "ignoresDupeEndTrTag",
        "getDeepChild",
        "testIsValid",
        "consumeDigitSequence",
        "getAttributes",
        "isKnownTag",
        "getElementsByTagName",
        "getFromStack",
        "initialiseParse",
        "getNamespacedElementsByTag",
        "clearStackToTableContext",
        "Tokeniser",
        "handlesCdata",
        "lastElementSibling",
        "nextElementSibling",
        "handleMissingTr",
        "encoder",
        "handlesTextAfterData",
        "rewindToMark",
        "isDoctype",
        "getDocument",
        "getHeadElement",
        "isData",
        "charset",
        "Element",
        "testAddNewHtml",
        "handlesEscapedData",
        "testGetSiblings",
        "eq",
        "replaceWith",
        "padding",
        "matchConsume",
        "matchesAny",
        "OuterHtmlVisitor",
        "isForceQuirks",
        "isInline",
        "testClonesDeclarations",
        "setParentNode",
        "testPrependRowToTable",
        "parsesRoughAttributeString",
        "createShell",
        "getElementsByTag",
        "insertInFosterParent",
        "testAFlowContents",
        "testClone",
        "get",
        "testPrependElement",
        "is",
        "hasKey",
        "getElementsMatchingText",
        "testElementSiblingIndex",
        "getElementsByAttributeValueContaining",
        "Doctype",
        "testGetElementsWithClass",
        "put",
        "testClassDomMethods",
        "asDoctype",
        "isEndTag",
        "currentElement",
        "parsesRoughAttributes",
        "nextSibling",
        "testGetParents",
        "reparentChild",
        "canContainBlock",
        "mark",
        "hasClass",
        "indentAmount",
        "StartTag",
        "handlesMisnestedTagsBP",
        "isFalse",
        "newAttribute",
        "getElementsByIndexGreaterThan",
        "asCharacter",
        "handlesJavadocFont",
        "siblingIndex",
        "parseByteData",
        "commentBeforeHtml",
        "consumeCharacterReference",
        "matchConsumeIgnoreCase",
        "isFosterInserts",
        "Token",
        "inButtonScope",
        "text",
        "OutputSettings",
        "testGetElementsWithAttributeValue",
        "characterReferenceError",
        "normalisesEmptyDocument",
        "not",
        "appendText",
        "insertOnStackAfter",
        "handleRawtext",
        "handlesAbsPrefix",
        "handlesMultiClosingBody",
        "isSameFormattingElement",
        "before",
        "id",
        "isTrackErrors",
        "Entities",
        "hashCode",
        "DataUtil",
        "addAll",
        "clone",
        "testFormatHtml",
        "previousSibling",
        "parseFragment",
        "getElementsByAttributeStarting",
        "asEndTag",
        "absUrl",
        "childNodes",
        "consume",
        "prependChild",
        "testDropComments",
        "createElement",
        "createDoctypePending",
        "getPos",
        "createTempBuffer",
        "pSemantics",
        "load",
        "in",
        "prependText",
        "isElementInQueue",
        "getPendingTableCharacters",
        "removeAttr",
        "inListItemScope",
        "testSetIndent",
        "getElementsByClass",
        "indexInList",
        "isInActiveFormattingElements",
        "testTitles",
        "parsesSimpleDocument",
        "parsesEmptyString",
        "name",
        "exitTableBody",
        "popStackToBefore",
        "pos",
        "testAddNewText",
        "normaliseStructure",
        "getElementsByIndexLessThan",
        "setTrackErrors",
        "tag",
        "hasNext",
        "getState",
        "Dataset",
        "basicWithImagesTest",
        "testGetText",
        "testGetElementsWithAttribute",
        "getPublicIdentifier",
        "register",
        "createsStructureFromBodySnippet",
        "testRelaxedTags",
        "advance",
        "addSiblingHtml",
        "prettyPrint",
        "remove",
        "testHtmlContainsOuter",
        "markInsertionMode",
        "setTextPreservesDocumentStructure",
        "handlesInvalidStartTags",
        "testSpanContents",
        "testDropImageScript",
        "framesetOk",
        "testOuterHtml",
        "outputSettings",
        "testContainerOutput",
        "isBlock",
        "createCommentPending",
        "divSemantics",
        "parentlessToString",
        "prepend",
        "getBaseUri",
        "after",
        "appendTagName",
        "testPrependText",
        "readToByteBuffer",
        "isAppropriateEndTagToken",
        "testDropXmlProc",
        "clearStackToTableBodyContext",
        "parents",
        "testHgroup",
        "handlesUnclosedDefinitionLists",
        "testRemove",
        "attr",
        "popStackToClose",
        "normalisesDocument",
        "head",
        "handlesWhatWgExpensesTableExample",
        "siblingElements",
        "simpleBehaviourTest2",
        "prependElement",
        "setPendingTableCharacters",
        "TreeBuilder",
        "accumulateParents",
        "push",
        "emitCommentPending",
        "handlesUnknownInlineTags",
        "getName",
        "asComment",
        "parsesComments",
        "getElementsByAttributeValue",
        "appendWhitespaceIfBr",
        "insertMarkerToFormattingElements",
        "inScope",
        "handlesNestedImplicitTable",
        "appendAttributeName",
        "read",
        "tagName",
        "emit",
        "testKeepsPreText",
        "testClassUpdates",
        "className",
        "elementSiblingIndex",
        "formatAsBlock",
        "consumeAsString",
        "removeFromActiveFormattingElements",
        "getAllElements",
        "matches",
        "insertEmpty",
        "handlesBlocksInDefinitions",
        "testEmptyElementFormatHtml",
        "isTrue",
        "appendAttributeValue",
        "strictAttributeUnescapes",
        "setHeadElement",
        "consumeLetterSequence",
        "dropsUnterminatedAttribute",
        "parsesUnterminatedTextarea",
        "childNodesAsArray",
        "imgSemantics",
        "getData",
        "inTableScope",
        "valueOf",
        "child",
        "setFosterInserts",
        "asStartTag",
        "siblingNodes",
        "val",
        "resetInsertionMode",
        "state",
        "testHasText",
        "Tag",
        "replaceChild",
        "testNotPretty",
        "findsCharsetInMalformedMeta",
        "testBrHasSpace",
        "testSpaceAfterTag",
        "isCaseInsensitive",
        "next",
        "normalisesHeadlessBody",
        "getCharsetFromContentType",
        "basicBehaviourTest",
        "testAddNewElement",
        "escapeMode",
        "testNoImagesInNoScriptInHead",
        "testDropsUnknownTags",
        "classes",
        "testWrapWithRemainder",
        "isCharacter",
        "getElementsContainingOwnText",
        "consumeToEnd",
        "getElementsByAttributeValueNot",
        "insertNode",
        "dataKey",
        "handlesTextArea",
        "runParser",
        "empty",
        "getSystemIdentifier",
        "originalState",
        "data",
        "dropsUnterminatedTag",
        "Comment",
        "handlesImplicitCaptionClose",
        "handlesBaseUri",
        "testSetHtml",
        "isEOF",
        "anythingElse",
        "title",
        "testWrap",
        "attributes",
        "handlesBaseTags",
        "escape",
        "testGetElementsWithAttributeDash",
        "noNullElements",
        "handlesUnknownNamespaceTags",
        "setHtml",
        "isComment",
        "entrySet",
        "normaliseWhitespace",
        "closeCell",
        "getElementById",
        "consumeHexSequence",
        "getElementsMatchingOwnText",
        "testFontFlowContents",
        "baseUri",
        "isNamedEntity",
        "handlesKnownEmptyBlocks",
        "Document",
        "getOutputSettings",
        "onStack",
        "indent",
        "childNode",
        "tagNameSet",
        "isBlank",
        "getCharacterByName",
        "handlesAbsOnImage",
        "parsesQuiteRoughAttributes",
        "inSpecificScope",
        "firstElementSibling",
        "inSelectScope",
        "parsesBodyFragment",
        "isWhitespace",
        "testReplace",
        "isNumeric",
        "for",
        "parseBodyFragmentRelaxed",
        "testNormalisesText",
        "getElementsByAttributeValueStarting",
        "advanceTransition",
        "process",
        "classNames",
        "currentNodeInHtmlNS",
        "testSetText",
        "size",
        "testNormalisesStructure",
        "handlesUnclosedFormattingElements",
        "parent",
        "previousElementSibling",
        "setSiblingIndex",
        "replaceOnStack",
        "emitDoctypePending",
        "removeChild",
        "handlesDataOnlyTags",
        "reindexChildren",
        "addChildren",
        "matchesIgnoreCase",
        "isSpecial",
        "handleRcData",
        "anyOtherEndTag",
        "createsDocumentStructure",
        "acknowledgeSelfClosingFlag",
        "body",
        "pop",
        "getErrorMsg",
        "isStartTag",
        "parseBodyFragment",
        "addClass",
        "getStack",
        "toString",
        "emitTagPending",
        "CharacterReader",
        "consumeTo",
        "asList",
        "unconsume",
        "handlesBaseWithoutHref",
        "valueOfChecksNotEmpty",
        "matchesLetter",
        "generateImpliedEndTags",
        "equality",
        "hasAttr",
        "handlesSolidusAtAttributeEnd",
        "pushActiveFormattingElements",
        "testRelaxed",
        "consumeToAny",
        "handlesTbodyTable",
        "discardsNakedTds",
        "testCleanJavascriptHref",
        "replaceActiveFormattingElement",
        "setSelfClosing",
        "testTagNameSet",
        "handlesUnknownTags",
        "handlesMisnestedTagsBI",
        "appendElement",
        "getElementsContainingText",
        "doClone",
        "current",
        "EscapeMode",
        "createTagPending",
        "getMap",
        "testHeaderContents",
        "transition",
        "getElementsByAttributeValueEnding",
        "getElementsByAttributeValueMatching",
        "appendNormalisedText",
        "getFormElement",
        "html",
        "clearStackToTableRowContext",
        "testDropScript",
        "testXhtmlReferences",
        "appendChild",
        "quirksMode",
        "outerHtmlTail",
        "ownerDocument",
        "DocumentType",
        "resolvesRelativeLinks",
        "filter",
        "dropsUnresolvableRelativeLinks",
        "valueOfChecksNotNull",
        "error",
        "preserveWhitespace",
        "testAppendRowToTable",
        "doesNotCreateImplicitLists",
        "normaliseTextNodes",
        "outerHtml",
        "equals",
        "outerHtmlHead",
        "clearFormattingElementsToLastMarker",
        "notNull",
        "newPendingTableCharacters",
        "testGetChildText",
        "noTableDirectInTable",
        "getElementsByIndexEquals",
        "select",
        "removeFromStack",
        "testHandlesEmptyAttributes",
        "append",
        "finaliseTag",
        "handlesFrames",
        "tail",
        "testKeepsPreTextInCode",
        "eofError",
        "testOutputEncoding",
        "setBaseUri",
        "wrap",
        "clearStackToContext",
        "iterator",
        "parsesUnterminatedComments",
        "Validate",
        "nodeName",
        "hasText",
        "ownText",
        "children",
        "testPrependNewHtml",
        "getActiveFormattingElement",
        "defaultSemantics",
        "simpleBehaviourTest",
        "testGetElementById",
        "canStartWithEq",
        "reconstructFormattingElementsInTable",
        "removeClass",
        "trims",
        "emptyTdTag",
        "unescape",
        "absHandlesRelativeQuery",
        "getElementsByAttribute",
        "insert",
        "isSelfClosing",
        "EndTag",
        "parsesUnterminatedOption",
        "toggleClass",
        "parse",
        "handlesUnexpectedMarkupInTables",
        "ParseError",
        "replaceInQueue",
        "isEmpty",
        "reconstructFormattingElements",
        "notEmpty",
        "dataset",
        "findFirstElementByTagName",
        "matchesDigit",
        "EOF",
        "setFormElement",
        "Node",
        "join",
        "isFragmentParsing",
        "testInnerHtml"
      ],
      "functions_name_co_evolved_modified_file": [
        "toString",
        "consumeAsString",
        "matchConsume",
        "CharacterReader",
        "matchesAny",
        "consumeTo",
        "unconsume",
        "matchesLetter",
        "consumeDigitSequence",
        "pos",
        "consume",
        "consumeHexSequence",
        "matches",
        "consumeToEnd",
        "consumeToAny",
        "matchConsumeIgnoreCase",
        "isEmpty",
        "matchesDigit",
        "consumeLetterSequence",
        "rewindToMark",
        "matchesIgnoreCase",
        "advance",
        "current",
        "mark"
      ],
      "functions_name_co_evolved_all_files": [
        "Character",
        "getStack",
        "getData",
        "toString",
        "aboveOnStack",
        "name",
        "fail",
        "CharacterReader",
        "emitTagPending",
        "valueOf",
        "inTableScope",
        "ignoresDupeEndTrTag",
        "consumeTo",
        "asList",
        "unconsume",
        "stackHasValidParent",
        "asStartTag",
        "setFosterInserts",
        "popStackToBefore",
        "matchesLetter",
        "exitTableBody",
        "generateImpliedEndTags",
        "consumeDigitSequence",
        "pos",
        "getAttributes",
        "isKnownTag",
        "val",
        "setTrackErrors",
        "resetInsertionMode",
        "state",
        "handlesSolidusAtAttributeEnd",
        "setParent",
        "getFromStack",
        "emptyOnNoKey",
        "initialiseParse",
        "getState",
        "pushActiveFormattingElements",
        "clearStackToTableContext",
        "Tokeniser",
        "testRelaxed",
        "handlesCdata",
        "createsImplicitLists",
        "consumeToAny",
        "Dataset",
        "setExcludes",
        "getPublicIdentifier",
        "setIgnoreEnd",
        "register",
        "createsStructureFromBodySnippet",
        "canContain",
        "discardsNakedTds",
        "handleMissingTr",
        "imgSemantics",
        "replaceActiveFormattingElement",
        "rewindToMark",
        "setSelfClosing",
        "isDoctype",
        "getDocument",
        "getHeadElement",
        "createsImplicitTable",
        "handlesMisnestedTagsBI",
        "setCanContainBlock",
        "advance",
        "addSiblingHtml",
        "current",
        "remove",
        "markInsertionMode",
        "createTagPending",
        "basicBehaviourTest",
        "matchConsume",
        "transition",
        "framesetOk",
        "matchesAny",
        "isForceQuirks",
        "setContainDataOnly",
        "last",
        "createCommentPending",
        "setKnownTag",
        "getFormElement",
        "html",
        "clearStackToTableRowContext",
        "divSemantics",
        "testPrependRowToTable",
        "isValidAncestor",
        "testNoImagesInNoScriptInHead",
        "prepend",
        "getBaseUri",
        "quirksMode",
        "insertInFosterParent",
        "after",
        "outerHtmlTail",
        "setOptionalClosing",
        "appendTagName",
        "get",
        "DocumentType",
        "isCharacter",
        "hasKey",
        "isAppropriateEndTagToken",
        "consumeToEnd",
        "clearStackToTableBodyContext",
        "testHgroup",
        "Doctype",
        "insertNode",
        "createBlock",
        "pop",
        "handlesEmptyBlocks",
        "handlesUnclosedDefinitionLists",
        "setFormatAsInline",
        "put",
        "popStackToClose",
        "asDoctype",
        "isEndTag",
        "error",
        "isValidParent",
        "getSystemIdentifier",
        "preserveWhitespace",
        "parseTextNode",
        "runParser",
        "originalState",
        "testAppendRowToTable",
        "currentElement",
        "dropsUnterminatedTag",
        "doesNotCreateImplicitLists",
        "equals",
        "Comment",
        "handlesImplicitCaptionClose",
        "isEOF",
        "outerHtmlHead",
        "Parser",
        "anythingElse",
        "setPreserveWhitespace",
        "mark",
        "setPendingTableCharacters",
        "handlesBaseTags",
        "clearFormattingElementsToLastMarker",
        "TreeBuilder",
        "push",
        "emitCommentPending",
        "getName",
        "asComment",
        "newPendingTableCharacters",
        "isFragmentParsing",
        "StartTag",
        "isIgnorableEndTag",
        "handlesMisnestedTagsBP",
        "parsesComments",
        "noTableDirectInTable",
        "isFalse",
        "newAttribute",
        "handlesUnknownNamespaceTags",
        "isComment",
        "asCharacter",
        "removeFromStack",
        "append",
        "finaliseTag",
        "handlesFrames",
        "closeCell",
        "insertMarkerToFormattingElements",
        "inScope",
        "spanSemantics",
        "eofError",
        "setLimitChildren",
        "consumeHexSequence",
        "setBaseUri",
        "commentBeforeHtml",
        "wrap",
        "handlesNestedImplicitTable",
        "consumeCharacterReference",
        "matchConsumeIgnoreCase",
        "appendAttributeName",
        "read",
        "clearStackToContext",
        "isFosterInserts",
        "testFontFlowContents",
        "Token",
        "inButtonScope",
        "isNamedEntity",
        "handlesKnownEmptyBlocks",
        "popStackToSuitableContainer",
        "onStack",
        "createInline",
        "parseStartTag",
        "characterReferenceError",
        "normalisesEmptyDocument",
        "nodeName",
        "emit",
        "parseCdata",
        "addChildToParent",
        "className",
        "insertOnStackAfter",
        "handleRawtext",
        "getActiveFormattingElement",
        "defaultSemantics",
        "getCharacterByName",
        "isSameFormattingElement",
        "parsesQuiteRoughAttributes",
        "before",
        "inSpecificScope",
        "isTrackErrors",
        "canStartWithEq",
        "reconstructFormattingElementsInTable",
        "consumeAsString",
        "inSelectScope",
        "normalisesDocument",
        "parsesBodyFragment",
        "emptyTdTag",
        "unescape",
        "Entities",
        "hashCode",
        "isWhitespace",
        "addAll",
        "clone",
        "for",
        "parseComment",
        "parseFragment",
        "insert",
        "removeFromActiveFormattingElements",
        "EndTag",
        "parseBodyFragmentRelaxed",
        "isSelfClosing",
        "parsesUnterminatedOption",
        "asEndTag",
        "advanceTransition",
        "parseEndTag",
        "consume",
        "parse",
        "process",
        "handlesUnexpectedMarkupInTables",
        "ParseError",
        "matches",
        "currentNodeInHtmlNS",
        "insertEmpty",
        "size",
        "replaceInQueue",
        "setContainInlineOnly",
        "isEmpty",
        "reconstructFormattingElements",
        "testNormalisesStructure",
        "createDoctypePending",
        "handlesUnclosedFormattingElements",
        "getPos",
        "createTempBuffer",
        "setAncestor",
        "replaceOnStack",
        "emitDoctypePending",
        "testAllowsImageInNoScriptInHead",
        "matchesDigit",
        "appendAttributeValue",
        "EOF",
        "requiresSpecificParent",
        "strictAttributeUnescapes",
        "parsesUnterminatedAttribute",
        "setHeadElement",
        "load",
        "in",
        "consumeLetterSequence",
        "isElementInQueue",
        "getPendingTableCharacters",
        "pSemantics",
        "getImplicitParent",
        "inListItemScope",
        "matchesIgnoreCase",
        "isSpecial",
        "setFormElement",
        "handleRcData",
        "anyOtherEndTag",
        "setEmpty",
        "parsesUnterminatedTag",
        "parseAttribute",
        "dropsUnterminatedAttribute",
        "acknowledgeSelfClosingFlag",
        "parseXmlDecl",
        "getErrorMsg",
        "isStartTag",
        "parseBodyFragment",
        "isInActiveFormattingElements"
      ]
    },
    "file": {
      "file_name": "CharacterReader.java",
      "file_nloc": 160,
      "file_complexity": 61,
      "file_token_count": 897,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,196 @@\n+package org.jsoup.parser;\n+\n+/**\n+ CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n+ */\n+class CharacterReader {\n+    static final char EOF = (char) -1;\n+\n+    private final String input;\n+    private final int length;\n+    private int pos = 0;\n+    private int mark = 0;\n+\n+    CharacterReader(String input) {\n+        this.input = input;\n+        this.length = input.length();\n+    }\n+\n+    int pos() {\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return pos >= length;\n+    }\n+\n+    char current() {\n+        return isEmpty() ? EOF : input.charAt(pos);\n+    }\n+\n+    char consume() {\n+        return isEmpty() ? EOF : input.charAt(pos++);\n+    }\n+\n+    void unconsume() {\n+        pos--;\n+    }\n+\n+    void advance() {\n+        pos++;\n+    }\n+\n+    void mark() {\n+        mark = pos;\n+    }\n+\n+    void rewindToMark() {\n+        pos = mark;\n+    }\n+\n+    String consumeAsString() {\n+        return input.substring(pos, pos++);\n+    }\n+\n+    String consumeTo(char c) {\n+        int offset = input.indexOf(c, pos);\n+        if (offset != -1) {\n+            String consumed = input.substring(pos, offset);\n+            pos += consumed.length();\n+            return consumed;\n+        } else {\n+            return consumeToEnd();\n+        }\n+    }\n+\n+    String consumeTo(String seq) {\n+        int offset = input.indexOf(seq, pos);\n+        if (offset != -1) {\n+            String consumed = input.substring(pos, offset);\n+            pos += consumed.length();\n+            return consumed;\n+        } else {\n+            return consumeToEnd();\n+        }\n+    }\n+\n+    String consumeToAny(char... seq) {\n+        int start = pos;\n+\n+        OUTER: while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            for (char seek : seq) {\n+                if (seek == c)\n+                    break OUTER;\n+            }\n+            pos++;\n+        }\n+\n+        return pos > start ? input.substring(start, pos) : \"\";\n+    }\n+\n+    String consumeToEnd() {\n+        String data = input.substring(pos, input.length() - 1);\n+        pos = input.length();\n+        return data;\n+    }\n+\n+    String consumeLetterSequence() {\n+        int start = pos;\n+        while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n+                pos++;\n+            else\n+                break;\n+        }\n+\n+        return input.substring(start, pos);\n+    }\n+\n+    String consumeHexSequence() {\n+        int start = pos;\n+        while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n+                pos++;\n+            else\n+                break;\n+        }\n+        return input.substring(start, pos);\n+    }\n+\n+    String consumeDigitSequence() {\n+        int start = pos;\n+        while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            if (c >= '0' && c <= '9')\n+                pos++;\n+            else\n+                break;\n+        }\n+        return input.substring(start, pos);\n+    }\n+\n+    boolean matches(char c) {\n+        return !isEmpty() && input.charAt(pos) == c;\n+\n+    }\n+\n+    boolean matches(String seq) {\n+        return input.startsWith(seq, pos);\n+    }\n+\n+    boolean matchesIgnoreCase(String seq) {\n+        return input.regionMatches(true, pos, seq, 0, seq.length());\n+    }\n+\n+    boolean matchesAny(char... seq) {\n+        if (isEmpty())\n+            return false;\n+\n+        char c = input.charAt(pos);\n+        for (char seek : seq) {\n+            if (seek == c)\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean matchesLetter() {\n+        if (isEmpty())\n+            return false;\n+        char c = input.charAt(pos);\n+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n+    }\n+\n+    boolean matchesDigit() {\n+        if (isEmpty())\n+            return false;\n+        char c = input.charAt(pos);\n+        return (c >= '0' && c <= '9');\n+    }\n+\n+    boolean matchConsume(String seq) {\n+        if (matches(seq)) {\n+            pos += seq.length();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    boolean matchConsumeIgnoreCase(String seq) {\n+        if (matchesIgnoreCase(seq)) {\n+            pos += seq.length();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return input.substring(pos);\n+    }\n+}\n",
      "files_name_in_blame_commit": [
        "DataUtil.java",
        "CleanerTest.java",
        "NodeTest.java",
        "Element.java",
        "ElementTest.java",
        "TagTest.java",
        "ElementsTest.java",
        "Validate.java",
        "ParseError.java",
        "TokeniserState.java",
        "Node.java",
        "Token.java",
        "DocumentTest.java",
        "Tokeniser.java",
        "Tag.java",
        "Entities.java",
        "StringUtil.java",
        "AttributeParseTest.java",
        "Parser.java",
        "TreeBuilderState.java",
        "TreeBuilder.java",
        "Document.java",
        "Attributes.java",
        "DocumentType.java",
        "CharacterReader.java",
        "ParserTest.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 20
  }
}
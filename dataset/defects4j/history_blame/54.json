{
  "id": "54",
  "blame_commit": {
    "commit": {
      "commit_id": "f15531c04f87f9e4e4724772426603a909eabe2c",
      "commit_message": "Check in actual sources, moved to the new package, cleaned up a bit",
      "commit_author": "Tatu Saloranta",
      "commit_date": "2011-12-22 23:00:40",
      "commit_parent": "7e2b22a7883adfd8948deae5b3e7ec0dfd3d316c"
    },
    "function": {
      "function_name": "",
      "function_code_before": "",
      "function_code_after": "",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": "",
      "function_after_end_line": "",
      "function_before_token_count": 0,
      "function_after_token_count": 0,
      "functions_name_modified_file": [
        "_handleApostropheValue",
        "_skipWS",
        "getCodec",
        "_parseApostropheFieldName",
        "getBinaryValue",
        "_nextAfterName",
        "_closeInput",
        "_getText2",
        "nextBooleanValue",
        "_skipString",
        "getTextCharacters",
        "getNextChar",
        "nextIntValue",
        "_releaseBuffers",
        "close",
        "loadMore",
        "nextToken",
        "_reportInvalidToken",
        "_parseFieldName",
        "nextTextValue",
        "setCodec",
        "_handleUnexpectedValue",
        "ReaderBasedJsonParser",
        "_skipLF",
        "_decodeBase64",
        "_parseFieldName2",
        "parseNumberText2",
        "_handleUnusualFieldName",
        "parseNumberText",
        "_skipCR",
        "_finishString",
        "_skipComment",
        "_decodeEscaped",
        "getTextLength",
        "_verifyNoLeadingZeroes",
        "_parseUnusualFieldName2",
        "nextLongValue",
        "_skipWSOrEnd",
        "_matchToken",
        "releaseBuffered",
        "getInputSource",
        "getTextOffset",
        "_skipCComment",
        "_finishString2",
        "getText",
        "_skipCppComment",
        "_handleInvalidNumberStart"
      ],
      "functions_name_all_files": [
        "growArrayBy",
        "isFinal",
        "_handleApostropheValue",
        "contentsAsDecimal",
        "getEmbeddedObject",
        "releaseCharBuffer",
        "_outputRawMultiByteChar",
        "reportUnexpectedNumberChar",
        "JsonParserSequence",
        "NameN",
        "quoteAsString",
        "widenBy",
        "getCurrentLocation",
        "writeUTF8String",
        "_appendCharacterEscape",
        "calcLongStrLength",
        "_writeQuotedLong",
        "calloc",
        "find",
        "reportInvalid",
        "_writeQuotedInt",
        "writeRootValueSeparator",
        "getTokenCharacterOffset",
        "readValueAsTree",
        "isDouble",
        "JsonGenerator",
        "WriterBasedJsonGenerator",
        "_cantHappen",
        "_writeGenericEscape",
        "collectDefaults",
        "allocWriteEncodingBuffer",
        "nextFieldName",
        "hasJSONFormat",
        "_decodeUtf8_4",
        "_skipUtf8_3",
        "getInputSource",
        "encode",
        "_optimizedStreamFromURL",
        "TextBuffer",
        "hasMoreBytes",
        "getMask",
        "getInstance",
        "skipChildren",
        "getBooleanValue",
        "createMatcher",
        "getBinaryValue",
        "_getBufferRecycler",
        "getTokenLineNr",
        "resetAsNaN",
        "findName",
        "isInline",
        "markAsShared",
        "getTextValue",
        "releaseReadIOBuffer",
        "decodeBase64Char",
        "writeNull",
        "withMinimalMatch",
        "catch",
        "createFlattened",
        "BufferRecycler",
        "get",
        "isArrayType",
        "_handleUnexpectedValue",
        "setCodec",
        "intern",
        "resetWithCopy",
        "beforeArrayValues",
        "_skipCR",
        "isFloatingPointNumber",
        "unshare",
        "maybeDirty",
        "_constructError",
        "writeBinary",
        "SerializedString",
        "ObjectCodec",
        "_skipColon",
        "getCharOffset",
        "_reportInvalidInitial",
        "getNext",
        "version",
        "_writeStringSegment2",
        "expandCollision",
        "getGenericSignature",
        "parseAsInt",
        "mark",
        "getInputCodeLatin1JsNames",
        "getDoubleValue",
        "getValueAsLong",
        "Name",
        "getEmptyName",
        "tryMatch",
        "releaseByteBuffer",
        "resetWithString",
        "outputFullTriplet",
        "isResourceManaged",
        "findBuffer",
        "decodeBase64Byte",
        "_writeSegmentedRaw",
        "contentsAsString",
        "contentsAsDouble",
        "appendDesc",
        "JsonParserDelegate",
        "unshareNames",
        "writeTree",
        "_reportUnexpectedChar",
        "JsonNode",
        "writeObjectFieldStart",
        "_decodeBase64",
        "_verifyPrettyValueWrite",
        "spacesInObjectEntries",
        "setCurrentSegmentLength",
        "clearSegments",
        "hasRawClass",
        "SegmentedStringWriter",
        "JsonStringEncoder",
        "reportOverflowInt",
        "asDouble",
        "_writeSegment",
        "writeRawUTF8String",
        "getPaddingChar",
        "addName",
        "parseVersionPart",
        "setCharacterEscapes",
        "JsonLocation",
        "getSourceReference",
        "releaseTokenBuffer",
        "ensureLoaded",
        "BytesToNameCanonicalizer",
        "addFlattenedActiveParsers",
        "_reportBase64EOF",
        "hashCode",
        "writeNumber",
        "writeStartArray",
        "_reportInvalidOther",
        "peekNextToken",
        "getLineNr",
        "_allocMore",
        "loadMore",
        "isInt",
        "_outputMultiByteChar",
        "_handleLongCustomEscape",
        "JsonParseException",
        "resetFloat",
        "isLong",
        "_finishString",
        "copyCurrentEvent",
        "getPaddingByte",
        "outputLeadingTriplet",
        "getMatchedFormatName",
        "_parseUnusualFieldName2",
        "encodeBase64BitsAsByte",
        "_skipUtf8_4",
        "_parseSlowFloatValue",
        "reset",
        "freeBuffers",
        "buildResultArray",
        "resetWithEmpty",
        "getEntryCount",
        "getValueHandler",
        "copyHexChars",
        "getTextCharacters",
        "freeMergedBuffer",
        "_checkIsNumber",
        "setCurrentName",
        "getCurrentIndex",
        "ParserBase",
        "findParents",
        "_createJsonParser",
        "expandCurrentSegment",
        "MergedStream",
        "enable",
        "constructReader",
        "allocReadIOBuffer",
        "getValueAsInt",
        "writeNumberField",
        "convertNumberToLong",
        "setSchema",
        "loadMoreGuaranteed",
        "with",
        "getValue",
        "containedTypeCount",
        "appendThreeBytes",
        "usesPaddingChar",
        "isConcrete",
        "_writeStringSegment",
        "allocCharBuffer",
        "_skipCppComment",
        "_handleEOF",
        "writeNullField",
        "setPrettyPrinter",
        "reportInvalidBase64Char",
        "constructParser",
        "getCodec",
        "_writeSimpleObject",
        "reportWeirdUCS4",
        "_decodeBase64Escape",
        "isBigEndian",
        "_decodeUtf8_2",
        "reportUnexpectedEOF",
        "standardAsciiEscapesForJSON",
        "_getByteArrayBuilder",
        "_isNextTokenNameNo",
        "close",
        "parseEscapedFieldName",
        "_throwUnquotedSpace",
        "getTokenColumnNr",
        "findValuesAsText",
        "detectEncoding",
        "_decodeUtf8_3",
        "_outputSurrogates",
        "getLongValue",
        "DataFormatDetector",
        "get7BitOutputEscapes",
        "_writeStringSegmentASCII2",
        "getLocation",
        "_parseFieldName2",
        "getValueAsBoolean",
        "GeneratorBase",
        "_writeSegmentCustom",
        "toByteArray",
        "_widen",
        "expand",
        "asLong",
        "getOutputContext",
        "isNumber",
        "_getCharDesc",
        "inObject",
        "nukeSymbols",
        "_skipWS",
        "_decodeSurrogate",
        "switchToNext",
        "getKeyType",
        "getName",
        "_getText2",
        "unshareCollision",
        "_throwInternal",
        "findValues",
        "_skipUtf8_2",
        "disable",
        "releaseWriteEncodingBuffer",
        "isTextual",
        "isClosed",
        "throwIllegal",
        "nextIntValue",
        "getFormatName",
        "_assertSubclass",
        "appendTwoBytes",
        "releaseConcatBuffer",
        "JsonParser",
        "outputInt",
        "copyArrays",
        "getEncoding",
        "setOutputDecorator",
        "getByteOffset",
        "read",
        "convertNumberToDouble",
        "_skipComment",
        "_append",
        "releaseNameCopyBuffer",
        "encodeBase64BitsAsChar",
        "getTextLength",
        "_verifyNoLeadingZeroes",
        "_charArray",
        "hasCurrentToken",
        "isCollectionLikeType",
        "getAndClear",
        "getCurrentSegmentLength",
        "hasFormat",
        "clearCurrentToken",
        "getFloatValue",
        "isThrowable",
        "_writeCustomStringSegment2",
        "setInputDecorator",
        "createJsonParser",
        "setCurrentLength",
        "isPrimitive",
        "writeRawValue",
        "copyHexBytes",
        "_nextAfterName",
        "isMissingNode",
        "_writeLongString",
        "getShortValue",
        "_writeStringCustom",
        "JsonProcessingException",
        "_parserNumber2",
        "isIntegralNumber",
        "_createUTF8JsonGenerator",
        "Std",
        "isScalarValue",
        "checkUTF16",
        "handleBOM",
        "_writeBinary",
        "getTextBuffer",
        "has",
        "constructName",
        "Name3",
        "asString",
        "asUnquotedUTF8",
        "createParserWithMatch",
        "CharBufferType",
        "UTF32Reader",
        "getStartLocation",
        "unknownVersion",
        "removeEldestEntry",
        "set",
        "hasTextAsCharacters",
        "writeBoolean",
        "_writeUTF8Segment2",
        "getType",
        "_handleUnrecognizedCharacterEscape",
        "getTextOffset",
        "write",
        "MinimalPrettyPrinter",
        "configure",
        "_reportUnsupportedOperation",
        "writeObject",
        "getErasedSignature",
        "isBigDecimal",
        "_prependOrWriteCharacterEscape",
        "BaseReader",
        "getByteValue",
        "isInterface",
        "isExpectedStartArrayToken",
        "readValuesAs",
        "inArray",
        "_skipString",
        "resetWithShared",
        "isContainerNode",
        "charLength",
        "_reportInvalidToken",
        "_writeUTF8Segments",
        "nextTextValue",
        "_findFormat",
        "parseAsLong",
        "outputLong",
        "asInt",
        "convertNumberToInt",
        "_skipLF",
        "JsonFactory",
        "parseVersion",
        "serialize",
        "copyCurrentStructure",
        "contentsAsArray",
        "_appendSingleEscape",
        "reportInvalidNumber",
        "flush",
        "ByteBufferType",
        "skipSpace",
        "asQuotedChars",
        "_matchToken",
        "isBigInteger",
        "writeBinaryField",
        "releaseBuffered",
        "_reportMismatchedEndMarker",
        "indentArraysWith",
        "ensureNotShared",
        "next",
        "findFormat",
        "_writePPFieldName",
        "getText",
        "getCurrentName",
        "reportOverflowLong",
        "findBestBucket",
        "_currentObject",
        "isEnumType",
        "_handleInvalidNumberStart",
        "Segment",
        "convertSurrogate",
        "getMessage",
        "usesPadding",
        "_decodeUtf8_3fast",
        "JsonGenerationException",
        "_writeSegmentASCII",
        "getInputCodeUtf8",
        "setRootValueSeparator",
        "getNextChar",
        "_writeStringSegments",
        "asBoolean",
        "_createWriter",
        "forcedNarrowBy",
        "writeIndentation",
        "containedTypeName",
        "hasTextCharacters",
        "Name2",
        "_nextTokenNotInObject",
        "getLastClearedToken",
        "withOptimalMatch",
        "writeRawLong",
        "getMaxLineLength",
        "createChildObjectContext",
        "findSymbol",
        "_writeCustomEscape",
        "nextLongValue",
        "JsonStreamContext",
        "_appendByteEscape",
        "enabledIn",
        "parseLong",
        "getOutputTarget",
        "Parser",
        "canUseSchema",
        "readValueAs",
        "getContentType",
        "narrowBy",
        "getCurrentToken",
        "_parseApostropheFieldName",
        "Lf2SpacesIndenter",
        "getSourceRef",
        "rehash",
        "_writeQuotedRaw",
        "InternCache",
        "createJsonGenerator",
        "balloc",
        "releaseBuffers",
        "writeValue",
        "UTF8JsonGenerator",
        "writeObjectFieldValueSeparator",
        "versionFor",
        "getMatch",
        "getDataStream",
        "getValueAsDouble",
        "ReaderBasedJsonParser",
        "getIntValue",
        "getFieldNames",
        "getSymbol",
        "FixedSpaceIndenter",
        "isMapLikeType",
        "asParser",
        "_handleUnusualFieldName",
        "_decodeEscaped",
        "Bucket",
        "JsonGeneratorDelegate",
        "getJavaName",
        "ByteSourceJsonBootstrapper",
        "nextValue",
        "_reportInvalidEOF",
        "getOutputDecorator",
        "JsonEncoding",
        "getTypeHandler",
        "writeArrayValueSeparator",
        "Feature",
        "getTokenLocation",
        "release",
        "isNumeric",
        "for",
        "containedType",
        "_allocateEntityBuffer",
        "TypeReference",
        "isAbstract",
        "_addSymbol",
        "writeString",
        "_throwInvalidSpace",
        "writeObjectEntrySeparator",
        "_loadToHaveAtLeast",
        "skip",
        "createRoot",
        "expectComma",
        "setLocation",
        "_writeString",
        "size",
        "_parseSlowIntValue",
        "_decodeCharForError",
        "getInputDecorator",
        "isUknownVersion",
        "_flushBuffer",
        "Base64Variant",
        "mergeChild",
        "_writeNull",
        "_reportInvalidEOFInValue",
        "useDefaultPrettyPrinter",
        "Version",
        "resetInt",
        "writeStringField",
        "encodeBase64Partial",
        "asByteArray",
        "createRootContext",
        "_reportError",
        "_convertSurrogate",
        "toString",
        "getRawClass",
        "parseDouble",
        "slowParseFieldName",
        "quoteAsUTF8",
        "writeFieldName",
        "setEncoding",
        "makeChild",
        "compareTo",
        "isSnapshot",
        "completeAndCoalesce",
        "indentObjectsWith",
        "_createJsonGenerator",
        "getInputCodeComment",
        "nextToken",
        "parseAsDouble",
        "getDefaultVariant",
        "_writeUTF8Segment",
        "writeRaw",
        "Name1",
        "UTF8Writer",
        "reportStrangeStream",
        "parseMediumFieldName",
        "getFields",
        "_throwIllegalSurrogate",
        "convertNumberToBigDecimal",
        "ParserMinimalBase",
        "JsonToken",
        "length",
        "allocTokenBuffer",
        "hasGenericTypes",
        "_skipCComment",
        "NopIndenter",
        "containedParsersCount",
        "isEnabled",
        "calcHash",
        "available",
        "getDecimalValue",
        "UTF8StreamJsonParser",
        "writeEndObject",
        "_wrapError",
        "parseFieldName",
        "inLongRange",
        "isArray",
        "finishCurrentSegment",
        "setHighestNonEscapedChar",
        "getNumberValue",
        "_reportInvalidChar",
        "asCharArray",
        "encodeAsUTF8",
        "_releaseBuffers",
        "parseLongFieldName",
        "_reportInvalidBase64",
        "getCharacterEscapes",
        "isNull",
        "getMinorVersion",
        "isPojo",
        "inRoot",
        "withMaxInputLookahead",
        "encodeBase64Chunk",
        "_isNextTokenNameYes",
        "equals",
        "allocNameCopyBuffer",
        "allocConcatBuffer",
        "getColumnNr",
        "DefaultPrettyPrinter",
        "parseInt",
        "_finishString2",
        "getInputCodeUtf8JsNames",
        "getInputCodeLatin1",
        "markSupported",
        "_writeFieldName",
        "JsonReadContext",
        "getParent",
        "createChildArrayContext",
        "nextBooleanValue",
        "JsonWriteContext",
        "enabledByDefault",
        "beforeObjectEntries",
        "getElements",
        "writeBooleanField",
        "append",
        "allocByteBuffer",
        "emptyAndGetCurrentSegment",
        "getHighestEscapedChar",
        "getCurrentSegmentSize",
        "ByteArrayBuilder",
        "writeEndArray",
        "parseNumberText",
        "writeArrayFieldStart",
        "iterator",
        "appendQuoted",
        "_writeBytes",
        "_writeStringASCII",
        "unshareMain",
        "type",
        "getParsingContext",
        "isBoolean",
        "hasMatch",
        "_skipWSOrEnd",
        "convertNumberToBigInteger",
        "getNumberType",
        "getMatchStrength",
        "DataFormatMatcher",
        "isValueNode",
        "makeOrphan",
        "JavaType",
        "_writeString2",
        "_closeInput",
        "isBinary",
        "getBigIntegerValue",
        "getMajorVersion",
        "reportBounds",
        "TokenBuffer",
        "getPatchLevel",
        "_createContext",
        "CharsToNameCanonicalizer",
        "getCurrentSegment",
        "initTables",
        "isObject",
        "_parseFieldName",
        "asQuotedUTF8",
        "resetAndGetFirstSegment",
        "checkUTF32",
        "constructTextBuffer",
        "getTypeDesc",
        "parseNumberText2",
        "writeObjectField",
        "_verifyValueWrite",
        "nextByte",
        "_parseNumericValue",
        "_parseFloatText",
        "IOContext",
        "writeStartObject",
        "charToHex"
      ],
      "functions_name_co_evolved_modified_file": [
        "_handleApostropheValue",
        "_skipWS",
        "getCodec",
        "_parseApostropheFieldName",
        "getBinaryValue",
        "_nextAfterName",
        "_getText2",
        "_closeInput",
        "nextBooleanValue",
        "_handleInvalidNumberStart",
        "_skipString",
        "getTextCharacters",
        "getNextChar",
        "nextIntValue",
        "_releaseBuffers",
        "close",
        "loadMore",
        "nextToken",
        "_reportInvalidToken",
        "_parseFieldName",
        "nextTextValue",
        "setCodec",
        "_handleUnexpectedValue",
        "ReaderBasedJsonParser",
        "_skipLF",
        "_decodeBase64",
        "_parseFieldName2",
        "parseNumberText2",
        "_handleUnusualFieldName",
        "parseNumberText",
        "_skipCR",
        "_decodeEscaped",
        "_skipComment",
        "_finishString",
        "getTextLength",
        "_verifyNoLeadingZeroes",
        "_parseUnusualFieldName2",
        "_matchToken",
        "_skipWSOrEnd",
        "nextLongValue",
        "getTextOffset",
        "getInputSource",
        "releaseBuffered",
        "_skipCComment",
        "getText",
        "_skipCppComment",
        "_finishString2"
      ],
      "functions_name_co_evolved_all_files": [
        "growArrayBy",
        "isFinal",
        "_handleApostropheValue",
        "contentsAsDecimal",
        "getEmbeddedObject",
        "releaseCharBuffer",
        "_outputRawMultiByteChar",
        "reportUnexpectedNumberChar",
        "JsonParserSequence",
        "NameN",
        "quoteAsString",
        "widenBy",
        "getCurrentLocation",
        "writeUTF8String",
        "_appendCharacterEscape",
        "calcLongStrLength",
        "_writeQuotedLong",
        "calloc",
        "find",
        "reportInvalid",
        "_writeQuotedInt",
        "writeRootValueSeparator",
        "getTokenCharacterOffset",
        "readValueAsTree",
        "isDouble",
        "JsonGenerator",
        "WriterBasedJsonGenerator",
        "_cantHappen",
        "_writeGenericEscape",
        "collectDefaults",
        "allocWriteEncodingBuffer",
        "nextFieldName",
        "hasJSONFormat",
        "_decodeUtf8_4",
        "_skipUtf8_3",
        "getInputSource",
        "encode",
        "_optimizedStreamFromURL",
        "TextBuffer",
        "hasMoreBytes",
        "getMask",
        "getInstance",
        "skipChildren",
        "getBooleanValue",
        "createMatcher",
        "getBinaryValue",
        "_getBufferRecycler",
        "getTokenLineNr",
        "resetAsNaN",
        "findName",
        "isInline",
        "markAsShared",
        "getTextValue",
        "releaseReadIOBuffer",
        "decodeBase64Char",
        "writeNull",
        "withMinimalMatch",
        "catch",
        "createFlattened",
        "BufferRecycler",
        "get",
        "isArrayType",
        "_handleUnexpectedValue",
        "setCodec",
        "intern",
        "resetWithCopy",
        "beforeArrayValues",
        "_skipCR",
        "isFloatingPointNumber",
        "unshare",
        "maybeDirty",
        "_constructError",
        "writeBinary",
        "SerializedString",
        "ObjectCodec",
        "_skipColon",
        "getCharOffset",
        "_reportInvalidInitial",
        "getNext",
        "version",
        "_writeStringSegment2",
        "expandCollision",
        "getGenericSignature",
        "parseAsInt",
        "mark",
        "getInputCodeLatin1JsNames",
        "getDoubleValue",
        "getValueAsLong",
        "Name",
        "getEmptyName",
        "tryMatch",
        "releaseByteBuffer",
        "resetWithString",
        "outputFullTriplet",
        "isResourceManaged",
        "findBuffer",
        "decodeBase64Byte",
        "_writeSegmentedRaw",
        "contentsAsString",
        "contentsAsDouble",
        "appendDesc",
        "JsonParserDelegate",
        "unshareNames",
        "writeTree",
        "_reportUnexpectedChar",
        "JsonNode",
        "writeObjectFieldStart",
        "_decodeBase64",
        "_verifyPrettyValueWrite",
        "spacesInObjectEntries",
        "setCurrentSegmentLength",
        "clearSegments",
        "hasRawClass",
        "SegmentedStringWriter",
        "JsonStringEncoder",
        "reportOverflowInt",
        "asDouble",
        "_writeSegment",
        "writeRawUTF8String",
        "getPaddingChar",
        "addName",
        "parseVersionPart",
        "setCharacterEscapes",
        "JsonLocation",
        "getSourceReference",
        "releaseTokenBuffer",
        "ensureLoaded",
        "BytesToNameCanonicalizer",
        "addFlattenedActiveParsers",
        "_reportBase64EOF",
        "hashCode",
        "writeNumber",
        "writeStartArray",
        "_reportInvalidOther",
        "peekNextToken",
        "getLineNr",
        "_allocMore",
        "loadMore",
        "isInt",
        "_outputMultiByteChar",
        "_handleLongCustomEscape",
        "JsonParseException",
        "resetFloat",
        "isLong",
        "_finishString",
        "copyCurrentEvent",
        "getPaddingByte",
        "outputLeadingTriplet",
        "getMatchedFormatName",
        "_parseUnusualFieldName2",
        "encodeBase64BitsAsByte",
        "_skipUtf8_4",
        "_parseSlowFloatValue",
        "reset",
        "freeBuffers",
        "buildResultArray",
        "resetWithEmpty",
        "getEntryCount",
        "getValueHandler",
        "copyHexChars",
        "getTextCharacters",
        "freeMergedBuffer",
        "_checkIsNumber",
        "setCurrentName",
        "getCurrentIndex",
        "ParserBase",
        "findParents",
        "_createJsonParser",
        "expandCurrentSegment",
        "MergedStream",
        "enable",
        "constructReader",
        "allocReadIOBuffer",
        "getValueAsInt",
        "writeNumberField",
        "convertNumberToLong",
        "setSchema",
        "loadMoreGuaranteed",
        "with",
        "getValue",
        "containedTypeCount",
        "appendThreeBytes",
        "usesPaddingChar",
        "isConcrete",
        "_writeStringSegment",
        "allocCharBuffer",
        "_skipCppComment",
        "_handleEOF",
        "writeNullField",
        "setPrettyPrinter",
        "reportInvalidBase64Char",
        "constructParser",
        "getCodec",
        "_writeSimpleObject",
        "reportWeirdUCS4",
        "_decodeBase64Escape",
        "isBigEndian",
        "_decodeUtf8_2",
        "reportUnexpectedEOF",
        "standardAsciiEscapesForJSON",
        "_getByteArrayBuilder",
        "_isNextTokenNameNo",
        "close",
        "parseEscapedFieldName",
        "_throwUnquotedSpace",
        "getTokenColumnNr",
        "findValuesAsText",
        "detectEncoding",
        "_decodeUtf8_3",
        "_outputSurrogates",
        "getLongValue",
        "DataFormatDetector",
        "get7BitOutputEscapes",
        "_writeStringSegmentASCII2",
        "getLocation",
        "_parseFieldName2",
        "getValueAsBoolean",
        "GeneratorBase",
        "_writeSegmentCustom",
        "toByteArray",
        "_widen",
        "expand",
        "asLong",
        "getOutputContext",
        "isNumber",
        "_getCharDesc",
        "inObject",
        "nukeSymbols",
        "_skipWS",
        "_decodeSurrogate",
        "switchToNext",
        "getKeyType",
        "getName",
        "_getText2",
        "unshareCollision",
        "_throwInternal",
        "findValues",
        "_skipUtf8_2",
        "disable",
        "releaseWriteEncodingBuffer",
        "isTextual",
        "isClosed",
        "throwIllegal",
        "nextIntValue",
        "getFormatName",
        "_assertSubclass",
        "appendTwoBytes",
        "releaseConcatBuffer",
        "JsonParser",
        "outputInt",
        "copyArrays",
        "getEncoding",
        "setOutputDecorator",
        "getByteOffset",
        "read",
        "convertNumberToDouble",
        "_skipComment",
        "_append",
        "releaseNameCopyBuffer",
        "encodeBase64BitsAsChar",
        "getTextLength",
        "_verifyNoLeadingZeroes",
        "_charArray",
        "hasCurrentToken",
        "isCollectionLikeType",
        "getAndClear",
        "getCurrentSegmentLength",
        "hasFormat",
        "clearCurrentToken",
        "getFloatValue",
        "isThrowable",
        "_writeCustomStringSegment2",
        "setInputDecorator",
        "createJsonParser",
        "setCurrentLength",
        "isPrimitive",
        "writeRawValue",
        "copyHexBytes",
        "_nextAfterName",
        "isMissingNode",
        "_writeLongString",
        "getShortValue",
        "_writeStringCustom",
        "JsonProcessingException",
        "_parserNumber2",
        "isIntegralNumber",
        "_createUTF8JsonGenerator",
        "Std",
        "isScalarValue",
        "checkUTF16",
        "handleBOM",
        "_writeBinary",
        "getTextBuffer",
        "has",
        "constructName",
        "Name3",
        "asString",
        "asUnquotedUTF8",
        "createParserWithMatch",
        "CharBufferType",
        "UTF32Reader",
        "getStartLocation",
        "unknownVersion",
        "removeEldestEntry",
        "set",
        "hasTextAsCharacters",
        "writeBoolean",
        "_writeUTF8Segment2",
        "getType",
        "_handleUnrecognizedCharacterEscape",
        "getTextOffset",
        "write",
        "MinimalPrettyPrinter",
        "configure",
        "_reportUnsupportedOperation",
        "writeObject",
        "getErasedSignature",
        "isBigDecimal",
        "_prependOrWriteCharacterEscape",
        "BaseReader",
        "getByteValue",
        "isInterface",
        "isExpectedStartArrayToken",
        "readValuesAs",
        "inArray",
        "_skipString",
        "resetWithShared",
        "isContainerNode",
        "charLength",
        "_reportInvalidToken",
        "_writeUTF8Segments",
        "nextTextValue",
        "_findFormat",
        "parseAsLong",
        "outputLong",
        "asInt",
        "convertNumberToInt",
        "_skipLF",
        "JsonFactory",
        "parseVersion",
        "serialize",
        "copyCurrentStructure",
        "contentsAsArray",
        "_appendSingleEscape",
        "reportInvalidNumber",
        "flush",
        "ByteBufferType",
        "skipSpace",
        "asQuotedChars",
        "_matchToken",
        "isBigInteger",
        "writeBinaryField",
        "releaseBuffered",
        "_reportMismatchedEndMarker",
        "indentArraysWith",
        "ensureNotShared",
        "next",
        "findFormat",
        "_writePPFieldName",
        "getText",
        "getCurrentName",
        "reportOverflowLong",
        "findBestBucket",
        "_currentObject",
        "isEnumType",
        "_handleInvalidNumberStart",
        "Segment",
        "convertSurrogate",
        "getMessage",
        "usesPadding",
        "_decodeUtf8_3fast",
        "JsonGenerationException",
        "_writeSegmentASCII",
        "getInputCodeUtf8",
        "setRootValueSeparator",
        "getNextChar",
        "_writeStringSegments",
        "asBoolean",
        "_createWriter",
        "forcedNarrowBy",
        "writeIndentation",
        "containedTypeName",
        "hasTextCharacters",
        "Name2",
        "_nextTokenNotInObject",
        "getLastClearedToken",
        "withOptimalMatch",
        "writeRawLong",
        "getMaxLineLength",
        "createChildObjectContext",
        "findSymbol",
        "_writeCustomEscape",
        "nextLongValue",
        "JsonStreamContext",
        "_appendByteEscape",
        "enabledIn",
        "parseLong",
        "getOutputTarget",
        "Parser",
        "canUseSchema",
        "readValueAs",
        "getContentType",
        "narrowBy",
        "getCurrentToken",
        "_parseApostropheFieldName",
        "Lf2SpacesIndenter",
        "getSourceRef",
        "rehash",
        "_writeQuotedRaw",
        "InternCache",
        "createJsonGenerator",
        "balloc",
        "releaseBuffers",
        "writeValue",
        "UTF8JsonGenerator",
        "writeObjectFieldValueSeparator",
        "versionFor",
        "getMatch",
        "getDataStream",
        "getValueAsDouble",
        "ReaderBasedJsonParser",
        "getIntValue",
        "getFieldNames",
        "getSymbol",
        "FixedSpaceIndenter",
        "isMapLikeType",
        "asParser",
        "_handleUnusualFieldName",
        "_decodeEscaped",
        "Bucket",
        "JsonGeneratorDelegate",
        "getJavaName",
        "ByteSourceJsonBootstrapper",
        "nextValue",
        "_reportInvalidEOF",
        "getOutputDecorator",
        "JsonEncoding",
        "getTypeHandler",
        "writeArrayValueSeparator",
        "Feature",
        "getTokenLocation",
        "release",
        "isNumeric",
        "for",
        "containedType",
        "_allocateEntityBuffer",
        "TypeReference",
        "isAbstract",
        "_addSymbol",
        "writeString",
        "_throwInvalidSpace",
        "writeObjectEntrySeparator",
        "_loadToHaveAtLeast",
        "skip",
        "createRoot",
        "expectComma",
        "setLocation",
        "_writeString",
        "size",
        "_parseSlowIntValue",
        "_decodeCharForError",
        "getInputDecorator",
        "isUknownVersion",
        "_flushBuffer",
        "Base64Variant",
        "mergeChild",
        "_writeNull",
        "_reportInvalidEOFInValue",
        "useDefaultPrettyPrinter",
        "Version",
        "resetInt",
        "writeStringField",
        "encodeBase64Partial",
        "asByteArray",
        "createRootContext",
        "_reportError",
        "_convertSurrogate",
        "toString",
        "getRawClass",
        "parseDouble",
        "slowParseFieldName",
        "quoteAsUTF8",
        "writeFieldName",
        "setEncoding",
        "makeChild",
        "compareTo",
        "isSnapshot",
        "completeAndCoalesce",
        "indentObjectsWith",
        "_createJsonGenerator",
        "getInputCodeComment",
        "nextToken",
        "parseAsDouble",
        "getDefaultVariant",
        "_writeUTF8Segment",
        "writeRaw",
        "Name1",
        "UTF8Writer",
        "reportStrangeStream",
        "parseMediumFieldName",
        "getFields",
        "_throwIllegalSurrogate",
        "convertNumberToBigDecimal",
        "ParserMinimalBase",
        "JsonToken",
        "length",
        "allocTokenBuffer",
        "hasGenericTypes",
        "_skipCComment",
        "NopIndenter",
        "containedParsersCount",
        "isEnabled",
        "calcHash",
        "available",
        "getDecimalValue",
        "UTF8StreamJsonParser",
        "writeEndObject",
        "_wrapError",
        "parseFieldName",
        "inLongRange",
        "isArray",
        "finishCurrentSegment",
        "setHighestNonEscapedChar",
        "getNumberValue",
        "_reportInvalidChar",
        "asCharArray",
        "encodeAsUTF8",
        "_releaseBuffers",
        "parseLongFieldName",
        "_reportInvalidBase64",
        "getCharacterEscapes",
        "isNull",
        "getMinorVersion",
        "isPojo",
        "inRoot",
        "withMaxInputLookahead",
        "encodeBase64Chunk",
        "_isNextTokenNameYes",
        "equals",
        "allocNameCopyBuffer",
        "allocConcatBuffer",
        "getColumnNr",
        "DefaultPrettyPrinter",
        "parseInt",
        "_finishString2",
        "getInputCodeUtf8JsNames",
        "getInputCodeLatin1",
        "markSupported",
        "_writeFieldName",
        "JsonReadContext",
        "getParent",
        "createChildArrayContext",
        "nextBooleanValue",
        "JsonWriteContext",
        "enabledByDefault",
        "beforeObjectEntries",
        "getElements",
        "writeBooleanField",
        "append",
        "allocByteBuffer",
        "emptyAndGetCurrentSegment",
        "getHighestEscapedChar",
        "getCurrentSegmentSize",
        "ByteArrayBuilder",
        "writeEndArray",
        "parseNumberText",
        "writeArrayFieldStart",
        "iterator",
        "appendQuoted",
        "_writeBytes",
        "_writeStringASCII",
        "unshareMain",
        "type",
        "getParsingContext",
        "isBoolean",
        "hasMatch",
        "_skipWSOrEnd",
        "convertNumberToBigInteger",
        "getNumberType",
        "getMatchStrength",
        "DataFormatMatcher",
        "isValueNode",
        "makeOrphan",
        "JavaType",
        "_writeString2",
        "_closeInput",
        "isBinary",
        "getBigIntegerValue",
        "getMajorVersion",
        "reportBounds",
        "TokenBuffer",
        "getPatchLevel",
        "_createContext",
        "CharsToNameCanonicalizer",
        "getCurrentSegment",
        "initTables",
        "isObject",
        "_parseFieldName",
        "asQuotedUTF8",
        "resetAndGetFirstSegment",
        "checkUTF32",
        "constructTextBuffer",
        "getTypeDesc",
        "parseNumberText2",
        "writeObjectField",
        "_verifyValueWrite",
        "nextByte",
        "_parseNumericValue",
        "_parseFloatText",
        "IOContext",
        "writeStartObject",
        "charToHex"
      ]
    },
    "file": {
      "file_name": "ReaderBasedJsonParser.java",
      "file_nloc": 1334,
      "file_complexity": 399,
      "file_token_count": 6925,
      "file_before": "",
      "file_after": "",
      "file_patch": "@@ -0,0 +1,1817 @@\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserBase;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n+import com.fasterxml.jackson.core.util.*;\n+\n+/**\n+ * This is a concrete implementation of {@link JsonParser}, which is\n+ * based on a {@link java.io.Reader} to handle low-level character\n+ * conversion tasks.\n+ */\n+public final class ReaderBasedJsonParser\n+    extends ParserBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Input configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Reader that can be used for reading more content, if one\n+     * buffer from input source, but in some cases pre-loaded buffer\n+     * is handed to the parser.\n+     */\n+    protected Reader _reader;\n+\n+    /**\n+     * Current buffer from which data is read; generally data is read into\n+     * buffer from input source.\n+     */\n+    protected char[] _inputBuffer;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected ObjectCodec _objectCodec;\n+\n+    final protected CharsToNameCanonicalizer _symbols;\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing state\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Flag that indicates that the current token has not yet\n+     * been fully processed, and needs to be finished for\n+     * some access (or skipped to obtain the next token)\n+     */\n+    protected boolean _tokenIncomplete = false;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n+                             ObjectCodec codec, CharsToNameCanonicalizer st)\n+    {\n+        super(ctxt, features);\n+        _reader = r;\n+        _inputBuffer = ctxt.allocTokenBuffer();\n+        _objectCodec = codec;\n+        _symbols = st;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Base method defs, overrides\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    @Override\n+    public int releaseBuffered(Writer w) throws IOException\n+    {\n+        int count = _inputEnd - _inputPtr;\n+        if (count < 1) {\n+            return 0;\n+        }\n+        // let's just advance ptr to end\n+        int origPtr = _inputPtr;\n+        w.write(_inputBuffer, origPtr, count);\n+        return count;\n+    }\n+\n+    @Override\n+    public Object getInputSource() {\n+        return _reader;\n+    }\n+\n+    @Override\n+    protected final boolean loadMore() throws IOException\n+    {\n+        _currInputProcessed += _inputEnd;\n+        _currInputRowStart -= _inputEnd;\n+\n+        if (_reader != null) {\n+            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n+            if (count > 0) {\n+                _inputPtr = 0;\n+                _inputEnd = count;\n+                return true;\n+            }\n+            // End of input\n+            _closeInput();\n+            // Should never return 0, so let's fail\n+            if (count == 0) {\n+                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected char getNextChar(String eofMsg)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                _reportInvalidEOF(eofMsg);\n+            }\n+        }\n+        return _inputBuffer[_inputPtr++];\n+    }\n+\n+    @Override\n+    protected void _closeInput() throws IOException\n+    {\n+        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n+         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n+         *   feature is enabled.\n+         *   One downside is that when using our optimized\n+         *   Reader (granted, we only do that for UTF-32...) this\n+         *   means that buffer recycling won't work correctly.\n+         */\n+        if (_reader != null) {\n+            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n+                _reader.close();\n+            }\n+            _reader = null;\n+        }\n+    }\n+\n+    /**\n+     * Method called to release internal buffers owned by the base\n+     * reader. This may be called along with {@link #_closeInput} (for\n+     * example, when explicitly closing this reader instance), or\n+     * separately (if need be).\n+     */\n+    @Override\n+    protected void _releaseBuffers()\n+        throws IOException\n+    {\n+        super._releaseBuffers();\n+        char[] buf = _inputBuffer;\n+        if (buf != null) {\n+            _inputBuffer = null;\n+            _ioContext.releaseTokenBuffer(buf);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, data access\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing textual representation of the current event;\n+     * if no current event (before first call to {@link #nextToken}, or\n+     * after encountering end-of-input), returns null.\n+     * Method can be called for any event.\n+     */\n+    @Override\n+    public final String getText()\n+        throws IOException, JsonParseException\n+    {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_STRING) {\n+            if (_tokenIncomplete) {\n+                _tokenIncomplete = false;\n+                _finishString(); // only strings can be incomplete\n+            }\n+            return _textBuffer.contentsAsString();\n+        }\n+        return _getText2(t);\n+    }\n+    \n+    protected final String _getText2(JsonToken t)\n+    {\n+        if (t == null) {\n+            return null;\n+        }\n+        switch (t) {\n+        case FIELD_NAME:\n+            return _parsingContext.getCurrentName();\n+\n+        case VALUE_STRING:\n+            // fall through\n+        case VALUE_NUMBER_INT:\n+        case VALUE_NUMBER_FLOAT:\n+            return _textBuffer.contentsAsString();\n+        }\n+        return t.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) { // null only before/after document\n+            switch (_currToken) {\n+                \n+            case FIELD_NAME:\n+                if (!_nameCopied) {\n+                    String name = _parsingContext.getCurrentName();\n+                    int nameLen = name.length();\n+                    if (_nameCopyBuffer == null) {\n+                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n+                    } else if (_nameCopyBuffer.length < nameLen) {\n+                        _nameCopyBuffer = new char[nameLen];\n+                    }\n+                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n+                    _nameCopied = true;\n+                }\n+                return _nameCopyBuffer;\n+    \n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.getTextBuffer();\n+                \n+            default:\n+                return _currToken.asCharArray();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getTextLength()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) { // null only before/after document\n+            switch (_currToken) {\n+                \n+            case FIELD_NAME:\n+                return _parsingContext.getCurrentName().length();\n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.size();\n+                \n+            default:\n+                return _currToken.asCharArray().length;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException\n+    {\n+        // Most have offset of 0, only some may have other values:\n+        if (_currToken != null) {\n+            switch (_currToken) {\n+            case FIELD_NAME:\n+                return 0;\n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.getTextOffset();\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != JsonToken.VALUE_STRING &&\n+                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n+            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n+        }\n+        /* To ensure that we won't see inconsistent data, better clear up\n+         * state...\n+         */\n+        if (_tokenIncomplete) {\n+            try {\n+                _binaryValue = _decodeBase64(b64variant);\n+            } catch (IllegalArgumentException iae) {\n+                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n+            }\n+            /* let's clear incomplete only now; allows for accessing other\n+             * textual content in error cases\n+             */\n+            _tokenIncomplete = false;\n+        } else { // may actually require conversion...\n+            if (_binaryValue == null) {\n+                ByteArrayBuilder builder = _getByteArrayBuilder();\n+                _decodeBase64(getText(), builder, b64variant);\n+                _binaryValue = builder.toByteArray();\n+            }\n+        }\n+        return _binaryValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, traversal\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Next token from the stream, if any found, or null\n+     *   to indicate end-of-input\n+     */\n+    @Override\n+    public JsonToken nextToken()\n+        throws IOException, JsonParseException\n+    {\n+        _numTypesValid = NR_UNKNOWN;\n+\n+        /* First: field names are special -- we will always tokenize\n+         * (part of) value along with field name to simplify\n+         * state handling. If so, can and need to use secondary token:\n+         */\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return _nextAfterName();\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString(); // only strings can be partial\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) { // end-of-input\n+            /* 19-Feb-2009, tatu: Should actually close/release things\n+             *    like input source, symbol table and recyclable buffers now.\n+             */\n+            close();\n+            return (_currToken = null);\n+        }\n+\n+        /* First, need to ensure we know the starting location of token\n+         * after skipping leading white space\n+         */\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+\n+        // finally: clear any data retained so far\n+        _binaryValue = null;\n+\n+        // Closing scope?\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            return (_currToken = JsonToken.END_ARRAY);\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            return (_currToken = JsonToken.END_OBJECT);\n+        }\n+\n+        // Nope: do we then expect a comma?\n+        if (_parsingContext.expectComma()) {\n+            if (i != INT_COMMA) {\n+                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        /* And should we now have a name? Always true for\n+         * Object contexts, since the intermediate 'expect-value'\n+         * state is never retained.\n+         */\n+        boolean inObject = _parsingContext.inObject();\n+        if (inObject) {\n+           // First, field name itself:\n+            String name = _parseFieldName(i);\n+            _parsingContext.setCurrentName(name);\n+            _currToken = JsonToken.FIELD_NAME;\n+            i = _skipWS();\n+            if (i != INT_COLON) {\n+                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        // Ok: we must have a value... what is it?\n+\n+        JsonToken t;\n+\n+        switch (i) {\n+        case INT_QUOTE:\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case INT_LBRACKET:\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case INT_LCURLY:\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case INT_RBRACKET:\n+        case INT_RCURLY:\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case INT_t:\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case INT_f:\n+            _matchToken(\"false\", 1);\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case INT_n:\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+\n+        case INT_MINUS:\n+            /* Should we have separate handling for plus? Although\n+             * it is not allowed per se, it may be erroneously used,\n+             * and could be indicate by a more specific error message.\n+             */\n+        case INT_0:\n+        case INT_1:\n+        case INT_2:\n+        case INT_3:\n+        case INT_4:\n+        case INT_5:\n+        case INT_6:\n+        case INT_7:\n+        case INT_8:\n+        case INT_9:\n+            t = parseNumberText(i);\n+            break;\n+        default:\n+            t = _handleUnexpectedValue(i);\n+            break;\n+        }\n+\n+        if (inObject) {\n+            _nextToken = t;\n+            return _currToken;\n+        }\n+        _currToken = t;\n+        return t;\n+    }\n+\n+    private final JsonToken _nextAfterName()\n+    {\n+        _nameCopied = false; // need to invalidate if it was copied\n+        JsonToken t = _nextToken;\n+        _nextToken = null;\n+        // Also: may need to start new context?\n+        if (t == JsonToken.START_ARRAY) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+        } else if (t == JsonToken.START_OBJECT) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        return (_currToken = t);\n+    }\n+\n+    /*\n+    @Override\n+    public boolean nextFieldName(SerializableString str)\n+         throws IOException, JsonParseException\n+     */\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public String nextTextValue()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_STRING) {\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString();\n+                }\n+                return _textBuffer.contentsAsString();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return null;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n+    }\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public int nextIntValue(int defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                return getIntValue();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return defaultValue;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n+    }\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public long nextLongValue(long defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                return getLongValue();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return defaultValue;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n+    }\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public Boolean nextBooleanValue()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_TRUE) {\n+                return Boolean.TRUE;\n+            }\n+            if (t == JsonToken.VALUE_FALSE) {\n+                return Boolean.FALSE;\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return null;\n+        }\n+        switch (nextToken()) {\n+        case VALUE_TRUE:\n+            return Boolean.TRUE;\n+        case VALUE_FALSE:\n+            return Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public void close() throws IOException\n+    {\n+        super.close();\n+        _symbols.release();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, number parsing\n+    /* (note: in 1.8 and prior, part of \"ReaderBasedNumericParser\"\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Initial parsing method for number values. It needs to be able\n+     * to parse enough input to be able to determine whether the\n+     * value is to be considered a simple integer value, or a more\n+     * generic decimal value: latter of which needs to be expressed\n+     * as a floating point number. The basic rule is that if the number\n+     * has no fractional or exponential part, it is an integer; otherwise\n+     * a floating point number.\n+     *<p>\n+     * Because much of input has to be processed in any case, no partial\n+     * parsing is done: all input text will be stored for further\n+     * processing. However, actual numeric value conversion will be\n+     * deferred, since it is usually the most complicated and costliest\n+     * part of processing.\n+     */\n+    protected final JsonToken parseNumberText(int ch)\n+        throws IOException, JsonParseException\n+    {\n+        /* Although we will always be complete with respect to textual\n+         * representation (that is, all characters will be parsed),\n+         * actual conversion to a number is deferred. Thus, need to\n+         * note that no representations are valid yet\n+         */\n+        boolean negative = (ch == INT_MINUS);\n+        int ptr = _inputPtr;\n+        int startPtr = ptr-1; // to include sign/digit already read\n+        final int inputLen = _inputEnd;\n+\n+        dummy_loop:\n+        do { // dummy loop, to be able to break out\n+            if (negative) { // need to read the next digit\n+                if (ptr >= _inputEnd) {\n+                    break dummy_loop;\n+                }\n+                ch = _inputBuffer[ptr++];\n+                // First check: must have a digit to follow minus sign\n+                if (ch > INT_9 || ch < INT_0) {\n+                    _inputPtr = ptr;\n+                    return _handleInvalidNumberStart(ch, true);\n+                }\n+                /* (note: has been checked for non-negative already, in\n+                 * the dispatching code that determined it should be\n+                 * a numeric value)\n+                 */\n+            }\n+            // One special case, leading zero(es):\n+            if (ch == INT_0) {\n+                break dummy_loop;\n+            }\n+            \n+            /* First, let's see if the whole number is contained within\n+             * the input buffer unsplit. This should be the common case;\n+             * and to simplify processing, we will just reparse contents\n+             * in the alternative case (number split on buffer boundary)\n+             */\n+            \n+            int intLen = 1; // already got one\n+            \n+            // First let's get the obligatory integer part:\n+            \n+            int_loop:\n+            while (true) {\n+                if (ptr >= _inputEnd) {\n+                    break dummy_loop;\n+                }\n+                ch = (int) _inputBuffer[ptr++];\n+                if (ch < INT_0 || ch > INT_9) {\n+                    break int_loop;\n+                }\n+                ++intLen;\n+            }\n+\n+            int fractLen = 0;\n+            \n+            // And then see if we get other parts\n+            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n+                fract_loop:\n+                while (true) {\n+                    if (ptr >= inputLen) {\n+                        break dummy_loop;\n+                    }\n+                    ch = (int) _inputBuffer[ptr++];\n+                    if (ch < INT_0 || ch > INT_9) {\n+                        break fract_loop;\n+                    }\n+                    ++fractLen;\n+                }\n+                // must be followed by sequence of ints, one minimum\n+                if (fractLen == 0) {\n+                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+                }\n+            }\n+\n+            int expLen = 0;\n+            if (ch == INT_e || ch == INT_E) { // and/or exponent\n+                if (ptr >= inputLen) {\n+                    break dummy_loop;\n+                }\n+                // Sign indicator?\n+                ch = (int) _inputBuffer[ptr++];\n+                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n+                    if (ptr >= inputLen) {\n+                        break dummy_loop;\n+                    }\n+                    ch = (int) _inputBuffer[ptr++];\n+                }\n+                while (ch <= INT_9 && ch >= INT_0) {\n+                    ++expLen;\n+                    if (ptr >= inputLen) {\n+                        break dummy_loop;\n+                    }\n+                    ch = (int) _inputBuffer[ptr++];\n+                }\n+                // must be followed by sequence of ints, one minimum\n+                if (expLen == 0) {\n+                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+                }\n+            }\n+\n+            // Got it all: let's add to text buffer for parsing, access\n+            --ptr; // need to push back following separator\n+            _inputPtr = ptr;\n+            int len = ptr-startPtr;\n+            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n+            return reset(negative, intLen, fractLen, expLen);\n+        } while (false);\n+\n+        _inputPtr = negative ? (startPtr+1) : startPtr;\n+        return parseNumberText2(negative);\n+    }\n+\n+    /**\n+     * Method called to parse a number, when the primary parse\n+     * method has failed to parse it, due to it being split on\n+     * buffer boundary. As a result code is very similar, except\n+     * that it has to explicitly copy contents to the text buffer\n+     * instead of just sharing the main input buffer.\n+     */\n+    private final JsonToken parseNumberText2(boolean negative)\n+        throws IOException, JsonParseException\n+    {\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        int outPtr = 0;\n+\n+        // Need to prepend sign?\n+        if (negative) {\n+            outBuf[outPtr++] = '-';\n+        }\n+\n+        // This is the place to do leading-zero check(s) too:\n+        int intLen = 0;\n+        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n+        if (c == '0') {\n+            c = _verifyNoLeadingZeroes();\n+        }\n+        boolean eof = false;\n+\n+        // Ok, first the obligatory integer part:\n+        int_loop:\n+        while (c >= '0' && c <= '9') {\n+            ++intLen;\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = c;\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                // EOF is legal for main level int values\n+                c = CHAR_NULL;\n+                eof = true;\n+                break int_loop;\n+            }\n+            c = _inputBuffer[_inputPtr++];\n+        }\n+        // Also, integer part is not optional\n+        if (intLen == 0) {\n+            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n+        }\n+\n+        int fractLen = 0;\n+        // And then see if we get other parts\n+        if (c == '.') { // yes, fraction\n+            outBuf[outPtr++] = c;\n+\n+            fract_loop:\n+            while (true) {\n+                if (_inputPtr >= _inputEnd && !loadMore()) {\n+                    eof = true;\n+                    break fract_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+                if (c < INT_0 || c > INT_9) {\n+                    break fract_loop;\n+                }\n+                ++fractLen;\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = c;\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (fractLen == 0) {\n+                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n+            }\n+        }\n+\n+        int expLen = 0;\n+        if (c == 'e' || c == 'E') { // exponent?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = c;\n+            // Not optional, can require that we get one more char\n+            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n+                : getNextChar(\"expected a digit for number exponent\");\n+            // Sign indicator?\n+            if (c == '-' || c == '+') {\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = c;\n+                // Likewise, non optional:\n+                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n+                    : getNextChar(\"expected a digit for number exponent\");\n+            }\n+\n+            exp_loop:\n+            while (c <= INT_9 && c >= INT_0) {\n+                ++expLen;\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = c;\n+                if (_inputPtr >= _inputEnd && !loadMore()) {\n+                    eof = true;\n+                    break exp_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (expLen == 0) {\n+                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n+            }\n+        }\n+\n+        // Ok; unless we hit end-of-input, need to push last char read back\n+        if (!eof) {\n+            --_inputPtr;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        // And there we have it!\n+        return reset(negative, intLen, fractLen, expLen);\n+    }\n+\n+    /**\n+     * Method called when we have seen one zero, and want to ensure\n+     * it is not followed by another\n+     */\n+    private final char _verifyNoLeadingZeroes()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok to have plain \"0\"\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            return '0';\n+        }\n+        char ch = _inputBuffer[_inputPtr];\n+        // if not followed by a number (probably '.'); return zero as is, to be included\n+        if (ch < '0' || ch > '9') {\n+            return '0';\n+        }\n+        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n+            reportInvalidNumber(\"Leading zeroes not allowed\");\n+        }\n+        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n+        ++_inputPtr; // Leading zero to be skipped\n+        if (ch == INT_0) {\n+            while (_inputPtr < _inputEnd || loadMore()) {\n+                ch = _inputBuffer[_inputPtr];\n+                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n+                    return '0';\n+                }\n+                ++_inputPtr; // skip previous zero\n+                if (ch != '0') { // followed by other number; return \n+                    break;\n+                }\n+            }\n+        }\n+        return ch;\n+    }\n+\n+    /**\n+     * Method called if expected numeric value (due to leading sign) does not\n+     * look like a number\n+     */\n+    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative)\n+        throws IOException, JsonParseException\n+    {\n+        if (ch == 'I') {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            if (ch == 'N') {\n+                String match = negative ? \"-INF\" :\"+INF\";\n+                _matchToken(match, 3);\n+                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n+                }\n+                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            } else if (ch == 'n') {\n+                String match = negative ? \"-Infinity\" :\"+Infinity\";\n+                _matchToken(match, 3);\n+                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n+                }\n+                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            }\n+        }\n+        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, secondary parsing\n+    /**********************************************************\n+     */\n+\n+    protected final String _parseFieldName(int i)\n+        throws IOException, JsonParseException\n+    {\n+        if (i != INT_QUOTE) {\n+            return _handleUnusualFieldName(i);\n+        }\n+        /* First: let's try to see if we have a simple name: one that does\n+         * not cross input buffer boundary, and does not contain escape\n+         * sequences.\n+         */\n+        int ptr = _inputPtr;\n+        int hash = 0;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int maxCode = codes.length;\n+\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch < maxCode && codes[ch] != 0) {\n+                    if (ch == '\"') {\n+                        int start = _inputPtr;\n+                        _inputPtr = ptr+1; // to skip the quote\n+                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                    }\n+                    break;\n+                }\n+                hash = (hash * 31) + ch;\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+\n+        int start = _inputPtr;\n+        _inputPtr = ptr;\n+        return _parseFieldName2(start, hash, INT_QUOTE);\n+    }\n+\n+    private String _parseFieldName2(int startPtr, int hash, int endChar)\n+        throws IOException, JsonParseException\n+    {\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n+\n+        /* Output pointers; calls will also ensure that the buffer is\n+         * not shared and has room for at least one more char.\n+         */\n+        char[] outBuf = _textBuffer.getCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    c = _decodeEscaped();\n+                } else if (i <= endChar) {\n+                    if (i == endChar) {\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _throwUnquotedSpace(i, \"name\");\n+                    }\n+                }\n+            }\n+            hash = (hash * 31) + i;\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        {\n+            TextBuffer tb = _textBuffer;\n+            char[] buf = tb.getTextBuffer();\n+            int start = tb.getTextOffset();\n+            int len = tb.size();\n+\n+            return _symbols.findSymbol(buf, start, len, hash);\n+        }\n+    }\n+\n+    /**\n+     * Method called when we see non-white space character other\n+     * than double quote, when expecting a field name.\n+     * In standard mode will just throw an expection; but\n+     * in non-standard modes may be able to parse name.\n+     *\n+     * @since 1.2\n+     */\n+    protected final String _handleUnusualFieldName(int i)\n+        throws IOException, JsonParseException\n+    {\n+        // [JACKSON-173]: allow single quotes\n+        if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+            return _parseApostropheFieldName();\n+        }\n+        // [JACKSON-69]: allow unquoted names if feature enabled:\n+        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        }\n+        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n+        final int maxCode = codes.length;\n+\n+        // Also: first char must be a valid name char, but NOT be number\n+        boolean firstOk;\n+\n+        if (i < maxCode) { // identifier, and not a number\n+            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n+        } else {\n+            firstOk = Character.isJavaIdentifierPart((char) i);\n+        }\n+        if (!firstOk) {\n+            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n+        }\n+        int ptr = _inputPtr;\n+        int hash = 0;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch < maxCode) {\n+                    if (codes[ch] != 0) {\n+                        int start = _inputPtr-1; // -1 to bring back first char\n+                        _inputPtr = ptr;\n+                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                    }\n+                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n+                    int start = _inputPtr-1; // -1 to bring back first char\n+                    _inputPtr = ptr;\n+                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                }\n+                hash = (hash * 31) + ch;\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+        int start = _inputPtr-1;\n+        _inputPtr = ptr;\n+        return _parseUnusualFieldName2(start, hash, codes);\n+    }\n+\n+    protected final String _parseApostropheFieldName()\n+        throws IOException, JsonParseException\n+    {\n+        // Note: mostly copy of_parseFieldName\n+        int ptr = _inputPtr;\n+        int hash = 0;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int maxCode = codes.length;\n+\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch == '\\'') {\n+                    int start = _inputPtr;\n+                    _inputPtr = ptr+1; // to skip the quote\n+                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                }\n+                if (ch < maxCode && codes[ch] != 0) {\n+                    break;\n+                }\n+                hash = (hash * 31) + ch;\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+\n+        int start = _inputPtr;\n+        _inputPtr = ptr;\n+\n+        return _parseFieldName2(start, hash, INT_APOSTROPHE);\n+    }\n+\n+    /**\n+     * Method for handling cases where first non-space character\n+     * of an expected value token is not legal for standard JSON content.\n+     *\n+     * @since 1.3\n+     */\n+    protected final JsonToken _handleUnexpectedValue(int i)\n+        throws IOException, JsonParseException\n+    {\n+        // Most likely an error, unless we are to allow single-quote-strings\n+        switch (i) {\n+        case '\\'':\n+            /* [JACKSON-173]: allow single quotes. Unlike with regular\n+             * Strings, we'll eagerly parse contents; this so that there's\n+             * no need to store information on quote char used.\n+             *\n+             * Also, no separation to fast/slow parsing; we'll just do\n+             * one regular (~= slowish) parsing, to keep code simple\n+             */\n+            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+                return _handleApostropheValue();\n+            }\n+            break;\n+        case 'N':\n+            _matchToken(\"NaN\", 1);\n+            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                return resetAsNaN(\"NaN\", Double.NaN);\n+            }\n+            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            break;\n+        case '+': // note: '-' is taken as number\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n+        }\n+        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n+        return null;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected final JsonToken _handleApostropheValue()\n+        throws IOException, JsonParseException\n+    {\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    c = _decodeEscaped();\n+                } else if (i <= INT_APOSTROPHE) {\n+                    if (i == INT_APOSTROPHE) {\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _throwUnquotedSpace(i, \"string value\");\n+                    }\n+                }\n+            }\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        return JsonToken.VALUE_STRING;\n+    }\n+    \n+    /**\n+     * @since 1.2\n+     */\n+    private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes)\n+        throws IOException, JsonParseException\n+    {\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n+        char[] outBuf = _textBuffer.getCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+        final int maxCode = codes.length;\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) { // acceptable for now (will error out later)\n+                    break;\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr];\n+            int i = (int) c;\n+            if (i <= maxCode) {\n+                if (codes[i] != 0) {\n+                    break;\n+                }\n+            } else if (!Character.isJavaIdentifierPart(c)) {\n+                break;\n+            }\n+            ++_inputPtr;\n+            hash = (hash * 31) + i;\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        {\n+            TextBuffer tb = _textBuffer;\n+            char[] buf = tb.getTextBuffer();\n+            int start = tb.getTextOffset();\n+            int len = tb.size();\n+\n+            return _symbols.findSymbol(buf, start, len, hash);\n+        }\n+    }\n+  \n+    @Override\n+    protected void _finishString()\n+        throws IOException, JsonParseException\n+    {\n+        /* First: let's try to see if we have simple String value: one\n+         * that does not cross input buffer boundary, and does not\n+         * contain escape sequences.\n+         */\n+        int ptr = _inputPtr;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int maxCode = codes.length;\n+\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch < maxCode && codes[ch] != 0) {\n+                    if (ch == '\"') {\n+                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n+                        _inputPtr = ptr+1;\n+                        // Yes, we got it all\n+                        return;\n+                    }\n+                    break;\n+                }\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+\n+        /* Either ran out of input, or bumped into an escape\n+         * sequence...\n+         */\n+        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n+        _inputPtr = ptr;\n+        _finishString2();\n+    }\n+\n+    protected void _finishString2()\n+        throws IOException, JsonParseException\n+    {\n+        char[] outBuf = _textBuffer.getCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    c = _decodeEscaped();\n+                } else if (i <= INT_QUOTE) {\n+                    if (i == INT_QUOTE) {\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _throwUnquotedSpace(i, \"string value\");\n+                    }\n+                }\n+            }\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+    }\n+\n+    /**\n+     * Method called to skim through rest of unparsed String value,\n+     * if it is not needed. This can be done bit faster if contents\n+     * need not be stored for future access.\n+     */\n+    protected void _skipString()\n+        throws IOException, JsonParseException\n+    {\n+        _tokenIncomplete = false;\n+\n+        int inputPtr = _inputPtr;\n+        int inputLen = _inputEnd;\n+        char[] inputBuffer = _inputBuffer;\n+\n+        while (true) {\n+            if (inputPtr >= inputLen) {\n+                _inputPtr = inputPtr;\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n+                }\n+                inputPtr = _inputPtr;\n+                inputLen = _inputEnd;\n+            }\n+            char c = inputBuffer[inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    _inputPtr = inputPtr;\n+                    c = _decodeEscaped();\n+                    inputPtr = _inputPtr;\n+                    inputLen = _inputEnd;\n+                } else if (i <= INT_QUOTE) {\n+                    if (i == INT_QUOTE) {\n+                        _inputPtr = inputPtr;\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _inputPtr = inputPtr;\n+                        _throwUnquotedSpace(i, \"string value\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, other parsing\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * We actually need to check the character value here\n+     * (to see if we have \\n following \\r).\n+     */\n+    protected final void _skipCR() throws IOException\n+    {\n+        if (_inputPtr < _inputEnd || loadMore()) {\n+            if (_inputBuffer[_inputPtr] == '\\n') {\n+                ++_inputPtr;\n+            }\n+        }\n+        ++_currInputRow;\n+        _currInputRowStart = _inputPtr;\n+    }\n+\n+    protected final void _skipLF() throws IOException\n+    {\n+        ++_currInputRow;\n+        _currInputRowStart = _inputPtr;\n+    }\n+\n+    private final int _skipWS()\n+        throws IOException, JsonParseException\n+    {\n+        while (_inputPtr < _inputEnd || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH) {\n+                    return i;\n+                }\n+                _skipComment();\n+            } else if (i != INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+    }\n+\n+    private final int _skipWSOrEnd()\n+        throws IOException, JsonParseException\n+    {\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i > INT_SPACE) {\n+                 if (i == INT_SLASH) {\n+                     _skipComment();\n+                     continue;\n+                }\n+                 return i;\n+            }\n+            if (i != INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+        // We ran out of input...\n+        _handleEOF();\n+        return -1;\n+    }\n+\n+    private final void _skipComment()\n+        throws IOException, JsonParseException\n+    {\n+        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n+            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n+        }\n+        // First: check which comment (if either) it is:\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            _reportInvalidEOF(\" in a comment\");\n+        }\n+        char c = _inputBuffer[_inputPtr++];\n+        if (c == '/') {\n+            _skipCppComment();\n+        } else if (c == '*') {\n+            _skipCComment();\n+        } else {\n+            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n+        }\n+    }\n+\n+    private final void _skipCComment()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok: need the matching '*/'\n+        main_loop:\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i <= INT_ASTERISK) {\n+                if (i == INT_ASTERISK) { // end?\n+                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n+                        break main_loop;\n+                    }\n+                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n+                        ++_inputPtr;\n+                        return;\n+                    }\n+                    continue;\n+                }\n+                if (i < INT_SPACE) {\n+                    if (i == INT_LF) {\n+                        _skipLF();\n+                    } else if (i == INT_CR) {\n+                        _skipCR();\n+                    } else if (i != INT_TAB) {\n+                        _throwInvalidSpace(i);\n+                    }\n+                }\n+            }\n+        }\n+        _reportInvalidEOF(\" in a comment\");\n+    }\n+\n+    private final void _skipCppComment()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok: need to find EOF or linefeed\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i < INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                    break;\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                    break;\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected final char _decodeEscaped()\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                _reportInvalidEOF(\" in character escape sequence\");\n+            }\n+        }\n+        char c = _inputBuffer[_inputPtr++];\n+\n+        switch ((int) c) {\n+            // First, ones that are mapped\n+        case INT_b:\n+            return '\\b';\n+        case INT_t:\n+            return '\\t';\n+        case INT_n:\n+            return '\\n';\n+        case INT_f:\n+            return '\\f';\n+        case INT_r:\n+            return '\\r';\n+\n+            // And these are to be returned as they are\n+        case INT_QUOTE:\n+        case INT_SLASH:\n+        case INT_BACKSLASH:\n+            return c;\n+\n+        case INT_u: // and finally hex-escaped\n+            break;\n+\n+        default:\n+            return _handleUnrecognizedCharacterEscape(c);\n+        }\n+\n+        // Ok, a hex escape. Need 4 characters\n+        int value = 0;\n+        for (int i = 0; i < 4; ++i) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\" in character escape sequence\");\n+                }\n+            }\n+            int ch = (int) _inputBuffer[_inputPtr++];\n+            int digit = CharTypes.charToHex(ch);\n+            if (digit < 0) {\n+                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n+            }\n+            value = (value << 4) | digit;\n+        }\n+        return (char) value;\n+    }\n+    \n+    /**\n+     * Helper method for checking whether input matches expected token\n+     * \n+     * @since 1.8\n+     */\n+    protected final void _matchToken(String matchStr, int i)\n+        throws IOException, JsonParseException\n+    {\n+        final int len = matchStr.length();\n+\n+        do {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n+                _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+            }\n+            ++_inputPtr;\n+        } while (++i < len);\n+\n+        // but let's also ensure we either get EOF, or non-alphanum char...\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                return;\n+            }\n+        }\n+        char c = _inputBuffer[_inputPtr];\n+        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n+            return;\n+        }\n+        // if Java letter, it's a problem tho\n+        if (Character.isJavaIdentifierPart(c)) {\n+            ++_inputPtr;\n+            _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+        }\n+        return;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Binary access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Efficient handling for incremental parsing of base64-encoded\n+     * textual content.\n+     */\n+    protected byte[] _decodeBase64(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        ByteArrayBuilder builder = _getByteArrayBuilder();\n+\n+        //main_loop:\n+        while (true) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                if (_inputPtr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                }\n+                ch = _inputBuffer[_inputPtr++];\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (ch == '\"') { // reached the end, fair and square?\n+                    return builder.toByteArray();\n+                }\n+                bits = _decodeBase64Escape(b64variant, ch, 0);\n+                if (bits < 0) { // white space to skip\n+                    continue;\n+                }\n+            }\n+            int decodedData = bits;\n+            \n+            // then second base64 char; can't get padding yet, nor ws\n+            \n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                bits = _decodeBase64Escape(b64variant, ch, 1);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            \n+            // third base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 4;\n+                        builder.append(decodedData);\n+                        return builder.toByteArray();\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 2);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    // Ok, must get more padding chars, then\n+                    if (_inputPtr >= _inputEnd) {\n+                        loadMoreGuaranteed();\n+                    }\n+                    ch = _inputBuffer[_inputPtr++];\n+                    if (!b64variant.usesPaddingChar(ch)) {\n+                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                    }\n+                    // Got 12 bits, only need 8, need to shift\n+                    decodedData >>= 4;\n+                    builder.append(decodedData);\n+                    continue;\n+                }\n+                // otherwise we got escaped other char, to be processed below\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 2;\n+                        builder.appendTwoBytes(decodedData);\n+                        return builder.toByteArray();\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 3);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    // With padding we only get 2 bytes; but we have\n+                    // to shift it a bit so it is identical to triplet\n+                    // case with partial output.\n+                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n+                    // dummies, need to discard:\n+                    decodedData >>= 2;\n+                    builder.appendTwoBytes(decodedData);\n+                    continue;\n+                }\n+                // otherwise we got escaped other char, to be processed below\n+            }\n+            // otherwise, our triplet is now complete\n+            decodedData = (decodedData << 6) | bits;\n+            builder.appendThreeBytes(decodedData);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Error reporting\n+    /**********************************************************\n+     */\n+\n+    protected void _reportInvalidToken(String matchedPart, String msg)\n+        throws IOException, JsonParseException\n+    {\n+        StringBuilder sb = new StringBuilder(matchedPart);\n+        /* Let's just try to find what appears to be the token, using\n+         * regular Java identifier character rules. It's just a heuristic,\n+         * nothing fancy here.\n+         */\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    break;\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr];\n+            if (!Character.isJavaIdentifierPart(c)) {\n+                break;\n+            }\n+            ++_inputPtr;\n+            sb.append(c);\n+        }\n+        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n+    }\n+}\n",
      "files_name_in_blame_commit": [
        "TextBuffer.java",
        "InternCache.java",
        "BufferRecycler.java",
        "SerializableString.java",
        "UTF8Writer.java",
        "JavaType.java",
        "UTF8StreamJsonParser.java",
        "JsonLocation.java",
        "JsonGeneratorDelegate.java",
        "DefaultPrettyPrinter.java",
        "Versioned.java",
        "JsonNode.java",
        "ParserBase.java",
        "VersionUtil.java",
        "CharacterEscapes.java",
        "SegmentedStringWriter.java",
        "JsonStreamContext.java",
        "ObjectCodec.java",
        "ReaderBasedJsonParser.java",
        "SerializedString.java",
        "CharsToNameCanonicalizer.java",
        "MergedStream.java",
        "MatchStrength.java",
        "Name3.java",
        "JsonParserSequence.java",
        "ParserMinimalBase.java",
        "JsonToken.java",
        "DataFormatMatcher.java",
        "ByteSourceJsonBootstrapper.java",
        "JsonReadContext.java",
        "ByteArrayBuilder.java",
        "TokenBuffer.java",
        "JsonParseException.java",
        "NumberInput.java",
        "Name1.java",
        "InputAccessor.java",
        "Base64Variant.java",
        "JsonProcessingException.java",
        "UTF32Reader.java",
        "TypeReference.java",
        "DataFormatDetector.java",
        "JsonParser.java",
        "JsonGenerator.java",
        "BaseReader.java",
        "CharTypes.java",
        "package-info.java",
        "JsonParserDelegate.java",
        "MinimalPrettyPrinter.java",
        "Base64Variants.java",
        "InputDecorator.java",
        "JsonStringEncoder.java",
        "Name.java",
        "JsonGenerationException.java",
        "JsonWriteContext.java",
        "FormatSchema.java",
        "JsonEncoding.java",
        "Version.java",
        "NumberOutput.java",
        "PrettyPrinter.java",
        "Name2.java",
        "WriterBasedJsonGenerator.java",
        "OutputDecorator.java",
        "BytesToNameCanonicalizer.java",
        "NameN.java",
        "GeneratorBase.java",
        "UTF8JsonGenerator.java",
        "IOContext.java",
        "JsonFactory.java"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 97
  }
}
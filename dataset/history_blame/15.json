{
  "id": "15",
  "blame_commit": {
    "commit": {
      "commit_id": "87ddbdc33e362336b060e0cb95f8adb008d5f29f",
      "commit_message": "Fix handling of kwargs in Language.evaluate\n\nMakes it consistent with other methods",
      "commit_author": "Ines Montani",
      "commit_date": "2019-08-04 13:44:21",
      "commit_parent": "d1d30b044294c7f3a7399ae59bd6efcd0ae3384c"
    },
    "function": {
      "function_name": "evaluate",
      "function_code_before": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if not isinstance(gold, GoldParse):\n            gold = GoldParse(doc, **gold)\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
      "function_code_after": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = _pipe(pipe, docs, kwargs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if not isinstance(gold, GoldParse):\n            gold = GoldParse(doc, **gold)\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
      "function_before_start_line": 607,
      "function_before_end_line": 647,
      "function_after_start_line": 607,
      "function_after_end_line": 647,
      "function_before_token_count": 215,
      "function_after_token_count": 210,
      "functions_name_modified_file": [
        "create_vocab",
        "matcher",
        "pipe_names",
        "preprocess_gold",
        "replace_pipe",
        "_pipe",
        "parser",
        "entity",
        "from_disk",
        "evaluate",
        "tagger",
        "use_params",
        "from_bytes",
        "has_pipe",
        "linker",
        "_fix_pretrained_vectors_name",
        "__enter__",
        "get_pipe",
        "tensorizer",
        "path",
        "disable_pipes",
        "resume_training",
        "rehearse",
        "remove_pipe",
        "make_doc",
        "create_pipe",
        "create_tokenizer",
        "pipe",
        "meta",
        "to_disk",
        "__init__",
        "update",
        "__call__",
        "add_pipe",
        "begin_training",
        "to_bytes",
        "restore",
        "create_lemmatizer",
        "__exit__",
        "rename_pipe"
      ],
      "functions_name_all_files": [
        "create_vocab",
        "matcher",
        "pipe_names",
        "preprocess_gold",
        "replace_pipe",
        "_pipe",
        "parser",
        "entity",
        "from_disk",
        "evaluate",
        "tagger",
        "use_params",
        "from_bytes",
        "has_pipe",
        "linker",
        "_fix_pretrained_vectors_name",
        "__enter__",
        "get_pipe",
        "tensorizer",
        "path",
        "disable_pipes",
        "resume_training",
        "rehearse",
        "remove_pipe",
        "make_doc",
        "create_pipe",
        "create_tokenizer",
        "pipe",
        "meta",
        "to_disk",
        "__init__",
        "update",
        "__call__",
        "add_pipe",
        "begin_training",
        "to_bytes",
        "restore",
        "create_lemmatizer",
        "__exit__",
        "rename_pipe"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": []
    },
    "file": {
      "file_name": "language.py",
      "file_nloc": 678,
      "file_complexity": 199,
      "file_token_count": 4927,
      "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tagger\nfrom .pipeline import Tensorizer, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        else:\n            if (self.lang and vocab.lang) and (self.lang != vocab.lang):\n                raise ValueError(Errors.E150.format(nlp=self.lang, vocab=vocab.lang))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        if self.vocab.lang:\n            self._meta.setdefault(\"lang\", self.vocab.lang)\n        else:\n            self._meta.setdefault(\"lang\", self.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = [\n            self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs\n        ]\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(\n            p, exclude=[\"vocab\"]\n        )\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(\n            srsly.json_dumps(self.meta)\n        )\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(\n            p\n        ) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(\n            p, exclude=[\"vocab\"]\n        )\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(\n                p, exclude=[\"vocab\"]\n            )\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(\n            b\n        ) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(\n            b, exclude=[\"vocab\"]\n        )\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(\n                b, exclude=[\"vocab\"]\n            )\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
      "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tagger\nfrom .pipeline import Tensorizer, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        else:\n            if (self.lang and vocab.lang) and (self.lang != vocab.lang):\n                raise ValueError(Errors.E150.format(nlp=self.lang, vocab=vocab.lang))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        if self.vocab.lang:\n            self._meta.setdefault(\"lang\", self.vocab.lang)\n        else:\n            self._meta.setdefault(\"lang\", self.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = [\n            self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs\n        ]\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = _pipe(pipe, docs, kwargs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(\n            p, exclude=[\"vocab\"]\n        )\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(\n            srsly.json_dumps(self.meta)\n        )\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(\n            p\n        ) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(\n            p, exclude=[\"vocab\"]\n        )\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(\n                p, exclude=[\"vocab\"]\n            )\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(\n            b\n        ) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(\n            b, exclude=[\"vocab\"]\n        )\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(\n                b, exclude=[\"vocab\"]\n            )\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
      "file_patch": "@@ -633,7 +633,7 @@ class Language(object):\n             kwargs = component_cfg.get(name, {})\n             kwargs.setdefault(\"batch_size\", batch_size)\n             if not hasattr(pipe, \"pipe\"):\n-                docs = (pipe(doc, **kwargs) for doc in docs)\n+                docs = _pipe(pipe, docs, kwargs)\n             else:\n                 docs = pipe.pipe(docs, **kwargs)\n         for doc, gold in zip(docs, golds):\n",
      "files_name_in_blame_commit": [
        "language.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 340
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "607": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "    def evaluate(",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "608": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "609": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "    ):",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "610": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        \"\"\"Evaluate a model's pipeline components.",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "611": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 0
      },
      "612": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "613": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        verbose (bool): Print debugging information.",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "614": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        batch_size (int): Batch size to use.",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "615": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "616": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "            will be created.",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "617": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        component_cfg (dict): An optional dictionary with extra keyword",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "618": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "            arguments for specific components.",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "619": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        RETURNS (Scorer): The scorer containing the evaluation results.",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "620": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 0
      },
      "621": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        DOCS: https://spacy.io/api/language#evaluate",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "622": {
        "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
        "line_code": "        \"\"\"",
        "commit_date": "2019-05-24 14:06:36",
        "valid": 1
      },
      "623": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "        if scorer is None:",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "624": {
        "commit_id": "52c180ecf5474e62f305424065d645d14fc43b7b",
        "line_code": "            scorer = Scorer()",
        "commit_date": "2017-08-14 13:00:23",
        "valid": 1
      },
      "625": {
        "commit_id": "ad56641324651b26978d00c833e4ef0c634a1df1",
        "line_code": "        if component_cfg is None:",
        "commit_date": "2019-03-15 15:20:09",
        "valid": 1
      },
      "626": {
        "commit_id": "ad56641324651b26978d00c833e4ef0c634a1df1",
        "line_code": "            component_cfg = {}",
        "commit_date": "2019-03-15 15:20:09",
        "valid": 1
      },
      "627": {
        "commit_id": "11c31d285ce0bc7d64099f29e0d5c4cd26ce7e99",
        "line_code": "        docs, golds = zip(*docs_golds)",
        "commit_date": "2017-08-18 22:26:12",
        "valid": 1
      },
      "628": {
        "commit_id": "f7d950de6df12e729c9beb25ee25ea3dac01afaf",
        "line_code": "        docs = [",
        "commit_date": "2019-08-01 17:13:01",
        "valid": 1
      },
      "629": {
        "commit_id": "f7d950de6df12e729c9beb25ee25ea3dac01afaf",
        "line_code": "            self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs",
        "commit_date": "2019-08-01 17:13:01",
        "valid": 1
      },
      "630": {
        "commit_id": "f7d950de6df12e729c9beb25ee25ea3dac01afaf",
        "line_code": "        ]",
        "commit_date": "2019-08-01 17:13:01",
        "valid": 1
      },
      "631": {
        "commit_id": "11c31d285ce0bc7d64099f29e0d5c4cd26ce7e99",
        "line_code": "        golds = list(golds)",
        "commit_date": "2017-08-18 22:26:12",
        "valid": 1
      },
      "632": {
        "commit_id": "212c8f071180c9ce134a74b85603e48c14199595",
        "line_code": "        for name, pipe in self.pipeline:",
        "commit_date": "2017-10-07 00:25:54",
        "valid": 1
      },
      "633": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "            kwargs = component_cfg.get(name, {})",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "634": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "            kwargs.setdefault(\"batch_size\", batch_size)",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "635": {
        "commit_id": "eddeb36c96b794601971a79c2e20bb24124fbf9a",
        "line_code": "            if not hasattr(pipe, \"pipe\"):",
        "commit_date": "2018-11-30 17:03:03",
        "valid": 1
      },
      "636": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "                docs = (pipe(doc, **kwargs) for doc in docs)",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "637": {
        "commit_id": "11c31d285ce0bc7d64099f29e0d5c4cd26ce7e99",
        "line_code": "            else:",
        "commit_date": "2017-08-18 22:26:12",
        "valid": 1
      },
      "638": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "                docs = pipe.pipe(docs, **kwargs)",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "639": {
        "commit_id": "11c31d285ce0bc7d64099f29e0d5c4cd26ce7e99",
        "line_code": "        for doc, gold in zip(docs, golds):",
        "commit_date": "2017-08-18 22:26:12",
        "valid": 1
      },
      "640": {
        "commit_id": "fc69da0acb655784bdc0d0515e4aeef2a0ca031f",
        "line_code": "            if not isinstance(gold, GoldParse):",
        "commit_date": "2019-07-27 17:30:18",
        "valid": 1
      },
      "641": {
        "commit_id": "fc69da0acb655784bdc0d0515e4aeef2a0ca031f",
        "line_code": "                gold = GoldParse(doc, **gold)",
        "commit_date": "2019-07-27 17:30:18",
        "valid": 1
      },
      "642": {
        "commit_id": "96da86b3e5d3a515f0f8db57ef1704750233ff38",
        "line_code": "            if verbose:",
        "commit_date": "2017-10-03 09:14:57",
        "valid": 1
      },
      "643": {
        "commit_id": "96da86b3e5d3a515f0f8db57ef1704750233ff38",
        "line_code": "                print(doc)",
        "commit_date": "2017-10-03 09:14:57",
        "valid": 1
      },
      "644": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "            kwargs = component_cfg.get(\"scorer\", {})",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "645": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "            kwargs.setdefault(\"verbose\", verbose)",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "646": {
        "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
        "line_code": "            scorer.score(doc, gold, **kwargs)",
        "commit_date": "2019-03-10 23:36:47",
        "valid": 1
      },
      "647": {
        "commit_id": "4c9202249d820d45dde13abae5e3f6b448785225",
        "line_code": "        return scorer",
        "commit_date": "2017-05-21 09:07:06",
        "valid": 1
      }
    },
    "commits": {
      "f7d950de6df12e729c9beb25ee25ea3dac01afaf": {
        "commit": {
          "commit_id": "f7d950de6df12e729c9beb25ee25ea3dac01afaf",
          "commit_message": "ensure the lang of vocab and nlp stay consistent (#4057)\n\n* ensure the language of vocab and nlp stay consistent across serialization\r\n\r\n* equality with =",
          "commit_author": "Sofie Van Landeghem",
          "commit_date": "2019-08-01 17:13:01",
          "commit_parent": "a83c0add2ef3c69476b4a1087536345f18dc86a3"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if not isinstance(gold, GoldParse):\n            gold = GoldParse(doc, **gold)\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if not isinstance(gold, GoldParse):\n            gold = GoldParse(doc, **gold)\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_before_start_line": 600,
          "function_before_end_line": 638,
          "function_after_start_line": 607,
          "function_after_end_line": 647,
          "function_before_token_count": 215,
          "function_after_token_count": 215,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "linker",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_all_files": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "_get_warn_types",
            "_get_warn_excl",
            "replace_pipe",
            "parser",
            "_pipe",
            "entity",
            "test_issue4054",
            "add_codes",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "linker",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "models_warning",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "user_warning",
            "to_bytes",
            "_warn",
            "restore",
            "create_lemmatizer",
            "deprecation_warning",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "meta",
            "from_bytes",
            "from_disk",
            "to_disk"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "meta",
            "from_bytes",
            "test_issue4054",
            "from_disk",
            "to_disk"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 678,
          "file_complexity": 200,
          "file_token_count": 4932,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tagger\nfrom .pipeline import Tensorizer, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        else:\n            if (self.lang and vocab.lang) and (self.lang != vocab.lang):\n                raise ValueError(Errors.E150.format(nlp=self.lang, vocab=vocab.lang))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        if self.vocab.lang:\n            self._meta.setdefault(\"lang\", self.vocab.lang)\n        else:\n            self._meta.setdefault(\"lang\", self.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = [\n            self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs\n        ]\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(\n            p, exclude=[\"vocab\"]\n        )\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(\n            srsly.json_dumps(self.meta)\n        )\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(\n            p\n        ) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(\n            p, exclude=[\"vocab\"]\n        )\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(\n                p, exclude=[\"vocab\"]\n            )\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(\n            b\n        ) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(\n            b, exclude=[\"vocab\"]\n        )\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(\n                b, exclude=[\"vocab\"]\n            )\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_patch": "@@ -14,7 +14,8 @@ import srsly\n from .tokenizer import Tokenizer\n from .vocab import Vocab\n from .lemmatizer import Lemmatizer\n-from .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer, EntityLinker\n+from .pipeline import DependencyParser, Tagger\n+from .pipeline import Tensorizer, EntityRecognizer, EntityLinker\n from .pipeline import SimilarityHook, TextCategorizer, Sentencizer\n from .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\n from .pipeline import EntityRuler\n@@ -158,6 +159,9 @@ class Language(object):\n             vocab = factory(self, **meta.get(\"vocab\", {}))\n             if vocab.vectors.name is None:\n                 vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n+        else:\n+            if (self.lang and vocab.lang) and (self.lang != vocab.lang):\n+                raise ValueError(Errors.E150.format(nlp=self.lang, vocab=vocab.lang))\n         self.vocab = vocab\n         if make_doc is True:\n             factory = self.Defaults.create_tokenizer\n@@ -173,7 +177,10 @@ class Language(object):\n \n     @property\n     def meta(self):\n-        self._meta.setdefault(\"lang\", self.vocab.lang)\n+        if self.vocab.lang:\n+            self._meta.setdefault(\"lang\", self.vocab.lang)\n+        else:\n+            self._meta.setdefault(\"lang\", self.lang)\n         self._meta.setdefault(\"name\", \"model\")\n         self._meta.setdefault(\"version\", \"0.0.0\")\n         self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n@@ -618,7 +625,9 @@ class Language(object):\n         if component_cfg is None:\n             component_cfg = {}\n         docs, golds = zip(*docs_golds)\n-        docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n+        docs = [\n+            self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs\n+        ]\n         golds = list(golds)\n         for name, pipe in self.pipeline:\n             kwargs = component_cfg.get(name, {})\n@@ -769,8 +778,12 @@ class Language(object):\n             exclude = disable\n         path = util.ensure_path(path)\n         serializers = OrderedDict()\n-        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n-        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n+        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(\n+            p, exclude=[\"vocab\"]\n+        )\n+        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(\n+            srsly.json_dumps(self.meta)\n+        )\n         for name, proc in self.pipeline:\n             if not hasattr(proc, \"name\"):\n                 continue\n@@ -799,14 +812,20 @@ class Language(object):\n         path = util.ensure_path(path)\n         deserializers = OrderedDict()\n         deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n-        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n-        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n+        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(\n+            p\n+        ) and _fix_pretrained_vectors_name(self)\n+        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(\n+            p, exclude=[\"vocab\"]\n+        )\n         for name, proc in self.pipeline:\n             if name in exclude:\n                 continue\n             if not hasattr(proc, \"from_disk\"):\n                 continue\n-            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n+            deserializers[name] = lambda p, proc=proc: proc.from_disk(\n+                p, exclude=[\"vocab\"]\n+            )\n         if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n             # Convert to list here in case exclude is (default) tuple\n             exclude = list(exclude) + [\"vocab\"]\n@@ -852,14 +871,20 @@ class Language(object):\n             exclude = disable\n         deserializers = OrderedDict()\n         deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n-        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n-        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n+        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(\n+            b\n+        ) and _fix_pretrained_vectors_name(self)\n+        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(\n+            b, exclude=[\"vocab\"]\n+        )\n         for name, proc in self.pipeline:\n             if name in exclude:\n                 continue\n             if not hasattr(proc, \"from_bytes\"):\n                 continue\n-            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n+            deserializers[name] = lambda b, proc=proc: proc.from_bytes(\n+                b, exclude=[\"vocab\"]\n+            )\n         exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n         util.from_bytes(bytes_data, deserializers, exclude)\n         return self\n",
          "files_name_in_blame_commit": [
            "language.py",
            "test_issue4054.py",
            "errors.py"
          ]
        }
      },
      "fc69da0acb655784bdc0d0515e4aeef2a0ca031f": {
        "commit": {
          "commit_id": "fc69da0acb655784bdc0d0515e4aeef2a0ca031f",
          "commit_message": "\ud83d\udcab Support simple training format in nlp.evaluate and add tests (#4033)\n\n* Support simple training format in nlp.evaluate and add tests\r\n\r\n* Update docs [ci skip]",
          "commit_author": "Ines Montani",
          "commit_date": "2019-07-27 17:30:18",
          "commit_parent": "a3723f439ce739fde97cefed9ea41b402bb55b7a"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if not isinstance(gold, GoldParse):\n            gold = GoldParse(doc, **gold)\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_before_start_line": 600,
          "function_before_end_line": 636,
          "function_after_start_line": 600,
          "function_after_end_line": 638,
          "function_before_token_count": 180,
          "function_after_token_count": 215,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "linker",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_all_files": [
            "create_vocab",
            "nlp",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "test_language_update",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "linker",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "test_language_evaluate",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_language_update",
            "test_language_evaluate",
            "nlp"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 653,
          "file_complexity": 196,
          "file_token_count": 4863,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_patch": "@@ -618,7 +618,7 @@ class Language(object):\n         if component_cfg is None:\n             component_cfg = {}\n         docs, golds = zip(*docs_golds)\n-        docs = list(docs)\n+        docs = [self.make_doc(doc) if isinstance(doc, basestring_) else doc for doc in docs]\n         golds = list(golds)\n         for name, pipe in self.pipeline:\n             kwargs = component_cfg.get(name, {})\n@@ -628,6 +628,8 @@ class Language(object):\n             else:\n                 docs = pipe.pipe(docs, **kwargs)\n         for doc, gold in zip(docs, golds):\n+            if not isinstance(gold, GoldParse):\n+                gold = GoldParse(doc, **gold)\n             if verbose:\n                 print(doc)\n             kwargs = component_cfg.get(\"scorer\", {})\n",
          "files_name_in_blame_commit": [
            "language.py",
            "test_language.py"
          ]
        }
      },
      "7634812172872090fbf23d2b9adb9478fbd97770": {
        "commit": {
          "commit_id": "7634812172872090fbf23d2b9adb9478fbd97770",
          "commit_message": "Document Language.evaluate",
          "commit_author": "Ines Montani",
          "commit_date": "2019-05-24 14:06:36",
          "commit_parent": "45e68555505b6171c09de1a4cdfbb4d0e9b84e42"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_before_start_line": 600,
          "function_before_end_line": 623,
          "function_after_start_line": 600,
          "function_after_end_line": 636,
          "function_before_token_count": 179,
          "function_after_token_count": 180,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "linker",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_all_files": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "linker",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 651,
          "file_complexity": 193,
          "file_token_count": 4828,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer, EntityLinker\nfrom .pipeline import SimilarityHook, TextCategorizer, Sentencizer\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"entity_linker\": lambda nlp, **cfg: EntityLinker(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: Sentencizer(**cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    # Shouldn't be used anymore!\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def linker(self):\n        return self.get_pipe(\"entity_linker\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n\n        DOCS: https://spacy.io/api/language#get_pipe\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#create_pipe\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        DOCS: https://spacy.io/api/language#add_pipe\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n\n        DOCS: https://spacy.io/api/language#has_pipe\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n\n        DOCS: https://spacy.io/api/language#replace_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E135.format(name=name)\n            raise ValueError(msg)\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n\n        DOCS: https://spacy.io/api/language#rename_pipe\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n\n        DOCS: https://spacy.io/api/language#remove_pipe\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        DOCS: https://spacy.io/api/language#call\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        DOCS: https://spacy.io/api/language#disable_pipes\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        losses (dict): Dictionary to update with the loss, keyed by component.\n        component_cfg (dict): Config parameters for specific pipeline\n            components, keyed by component name.\n\n        DOCS: https://spacy.io/api/language#update\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        # TODO: document\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer.\n\n        DOCS: https://spacy.io/api/language#begin_training\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        \"\"\"Evaluate a model's pipeline components.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        verbose (bool): Print debugging information.\n        batch_size (int): Batch size to use.\n        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n            will be created.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        RETURNS (Scorer): The scorer containing the evaluation results.\n\n        DOCS: https://spacy.io/api/language#evaluate\n        \"\"\"\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=-1,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool): If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed to control memory\n            use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword\n            arguments for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        DOCS: https://spacy.io/api/language#pipe\n        \"\"\"\n        if n_threads != -1:\n            deprecation_warning(Warnings.W016)\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_patch": "@@ -600,6 +600,19 @@ class Language(object):\n     def evaluate(\n         self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n     ):\n+        \"\"\"Evaluate a model's pipeline components.\n+\n+        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n+        verbose (bool): Print debugging information.\n+        batch_size (int): Batch size to use.\n+        scorer (Scorer): Optional `Scorer` to use. If not passed in, a new one\n+            will be created.\n+        component_cfg (dict): An optional dictionary with extra keyword\n+            arguments for specific components.\n+        RETURNS (Scorer): The scorer containing the evaluation results.\n+\n+        DOCS: https://spacy.io/api/language#evaluate\n+        \"\"\"\n         if scorer is None:\n             scorer = Scorer()\n         if component_cfg is None:\n",
          "files_name_in_blame_commit": [
            "language.py"
          ]
        }
      },
      "ad56641324651b26978d00c833e4ef0c634a1df1": {
        "commit": {
          "commit_id": "ad56641324651b26978d00c833e4ef0c634a1df1",
          "commit_message": "Fix Language.evaluate",
          "commit_author": "Matthew Honnibal",
          "commit_date": "2019-03-15 15:20:09",
          "commit_parent": "f762c36e618ea8c97fbe4fea0838f04b6beaf7da"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    if scorer is None:\n        scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    if scorer is None:\n        scorer = Scorer()\n    if component_cfg is None:\n        component_cfg = {}\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_before_start_line": 595,
          "function_before_end_line": 616,
          "function_after_start_line": 595,
          "function_after_end_line": 618,
          "function_before_token_count": 170,
          "function_after_token_count": 179,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_all_files": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 640,
          "file_complexity": 188,
          "file_token_count": 4736,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer\nfrom .pipeline import SimilarityHook, TextCategorizer, SentenceSegmenter\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        EXAMPLE:\n            >>> nlp.add_pipe(component, before='ner')\n            >>> nlp.add_pipe(component, name='custom_name', last=True)\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        EXAMPLE:\n            >>> nlp.add_pipe('parser')\n            >>> nlp.add_pipe('tagger')\n            >>> with nlp.disable_pipes('parser', 'tagger'):\n            >>>     assert not nlp.has_pipe('parser')\n            >>> assert nlp.has_pipe('parser')\n            >>> disabled = nlp.disable_pipes('parser')\n            >>> assert len(disabled) == 1\n            >>> assert not nlp.has_pipe('parser')\n            >>> disabled.restore()\n            >>> assert nlp.has_pipe('parser')\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        if scorer is None:\n            scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=2,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): Currently inactive.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed,\n            to control memory use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                n_threads=n_threads,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            kwargs.setdefault(\"n_threads\", n_threads)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer\nfrom .pipeline import SimilarityHook, TextCategorizer, SentenceSegmenter\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n    writing_system = {\"direction\": \"ltr\", \"has_case\": True, \"has_letters\": True}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        EXAMPLE:\n            >>> nlp.add_pipe(component, before='ner')\n            >>> nlp.add_pipe(component, name='custom_name', last=True)\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        EXAMPLE:\n            >>> nlp.add_pipe('parser')\n            >>> nlp.add_pipe('tagger')\n            >>> with nlp.disable_pipes('parser', 'tagger'):\n            >>>     assert not nlp.has_pipe('parser')\n            >>> assert nlp.has_pipe('parser')\n            >>> disabled = nlp.disable_pipes('parser')\n            >>> assert len(disabled) == 1\n            >>> assert not nlp.has_pipe('parser')\n            >>> disabled.restore()\n            >>> assert nlp.has_pipe('parser')\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        if scorer is None:\n            scorer = Scorer()\n        if component_cfg is None:\n            component_cfg = {}\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=2,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): Currently inactive.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed,\n            to control memory use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                n_threads=n_threads,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            kwargs.setdefault(\"n_threads\", n_threads)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    # We added some args for pipe that __call__ doesn't expect.\n    kwargs = dict(kwargs)\n    for arg in [\"n_threads\", \"batch_size\"]:\n        if arg in kwargs:\n            kwargs.pop(arg)\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_patch": "@@ -597,6 +597,8 @@ class Language(object):\n     ):\n         if scorer is None:\n             scorer = Scorer()\n+        if component_cfg is None:\n+            component_cfg = {}\n         docs, golds = zip(*docs_golds)\n         docs = list(docs)\n         golds = list(golds)\n",
          "files_name_in_blame_commit": [
            "language.py"
          ]
        }
      },
      "98acf5ffe408d3ec58fcfba0e0deb742891815d5": {
        "commit": {
          "commit_id": "98acf5ffe408d3ec58fcfba0e0deb742891815d5",
          "commit_message": "\ud83d\udcab Allow passing of config parameters to specific pipeline components (#3386)\n\n* Add component_cfg kwarg to begin_training\r\n\r\n* Document component_cfg arg to begin_training\r\n\r\n* Update docs and auto-format\r\n\r\n* Support component_cfg across Language\r\n\r\n* Format\r\n\r\n* Update docs and docstrings [ci skip]\r\n\r\n* Fix begin_training",
          "commit_author": "Matthew Honnibal",
          "commit_date": "2019-03-10 23:36:47",
          "commit_parent": "8dbf1e9037aecbe31e8d5d3f95798a5bc2c0841c"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds, verbose=False, batch_size=256):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, batch_size=batch_size)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        scorer.score(doc, gold, verbose=verbose)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None):\n    if scorer is None:\n        scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        kwargs = component_cfg.get(name, {})\n        kwargs.setdefault('batch_size', batch_size)\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc, **kwargs) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, **kwargs)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        kwargs = component_cfg.get('scorer', {})\n        kwargs.setdefault('verbose', verbose)\n        scorer.score(doc, gold, **kwargs)\n    return scorer",
          "function_before_start_line": 577,
          "function_before_end_line": 591,
          "function_after_start_line": 594,
          "function_after_end_line": 615,
          "function_before_token_count": 118,
          "function_after_token_count": 170,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_all_files": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "resume_training",
            "rehearse",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_co_evolved_modified_file": [
            "update",
            "__call__",
            "begin_training",
            "_pipe",
            "pipe"
          ],
          "functions_name_co_evolved_all_files": [
            "update",
            "__call__",
            "begin_training",
            "_pipe",
            "pipe"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 633,
          "file_complexity": 185,
          "file_token_count": 4686,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer\nfrom .pipeline import SimilarityHook, TextCategorizer, SentenceSegmenter\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        EXAMPLE:\n            >>> nlp.add_pipe(component, before='ner')\n            >>> nlp.add_pipe(component, name='custom_name', last=True)\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[]):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc)\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        EXAMPLE:\n            >>> nlp.add_pipe('parser')\n            >>> nlp.add_pipe('tagger')\n            >>> with nlp.disable_pipes('parser', 'tagger'):\n            >>>     assert not nlp.has_pipe('parser')\n            >>> assert nlp.has_pipe('parser')\n            >>> disabled = nlp.disable_pipes('parser')\n            >>> assert len(disabled) == 1\n            >>> assert not nlp.has_pipe('parser')\n            >>> disabled.restore()\n            >>> assert nlp.has_pipe('parser')\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        **cfg: Config parameters.\n        RETURNS: An optimizer\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                proc.begin_training(\n                    get_gold_tuples, pipeline=self.pipeline, sgd=self._optimizer, **cfg\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(self, docs_golds, verbose=False, batch_size=256):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, batch_size=batch_size)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            scorer.score(doc, gold, verbose=verbose)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=2,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): Currently inactive.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed,\n            to control memory use. Experimental.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts, n_threads=n_threads, batch_size=batch_size, disable=disable\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        doc = func(doc)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy, deepcopy\nfrom thinc.neural import Model\nimport srsly\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer\nfrom .pipeline import SimilarityHook, TextCategorizer, SentenceSegmenter\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, deprecation_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n\n    DOCS: https://spacy.io/api/language\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n        \"\"\"\n        if name not in self.factories:\n            if name == \"sbd\":\n                raise KeyError(Errors.E108.format(name=name))\n            else:\n                raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        EXAMPLE:\n            >>> nlp.add_pipe(component, before='ner')\n            >>> nlp.add_pipe(component, name='custom_name', last=True)\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[], component_cfg=None):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc, **component_cfg.get(name, {}))\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        EXAMPLE:\n            >>> nlp.add_pipe('parser')\n            >>> nlp.add_pipe('tagger')\n            >>> with nlp.disable_pipes('parser', 'tagger'):\n            >>>     assert not nlp.has_pipe('parser')\n            >>> assert nlp.has_pipe('parser')\n            >>> disabled = nlp.disable_pipes('parser')\n            >>> assert len(disabled) == 1\n            >>> assert not nlp.has_pipe('parser')\n            >>> disabled.restore()\n            >>> assert nlp.has_pipe('parser')\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"drop\", drop)\n            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def rehearse(self, docs, sgd=None, losses=None, config=None):\n        \"\"\"Make a \"rehearsal\" update to the models in the pipeline, to prevent\n        forgetting. Rehearsal updates run an initial copy of the model over some\n        data, and update the model so its current predictions are more like the\n        initial ones. This is useful for keeping a pre-trained model on-track,\n        even if you're updating it with a smaller set of examples.\n\n        docs (iterable): A batch of `Doc` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> raw_text_batches = minibatch(raw_texts)\n            >>> for labelled_batch in minibatch(zip(train_docs, train_golds)):\n            >>>     docs, golds = zip(*train_docs)\n            >>>     nlp.update(docs, golds)\n            >>>     raw_batch = [nlp.make_doc(text) for text in next(raw_text_batches)]\n            >>>     nlp.rehearse(raw_batch)\n        \"\"\"\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n        docs = list(docs)\n        for i, doc in enumerate(docs):\n            if isinstance(doc, basestring_):\n                docs[i] = self.make_doc(doc)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        if config is None:\n            config = {}\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        for name, proc in pipes:\n            if not hasattr(proc, \"rehearse\"):\n                continue\n            grads = {}\n            proc.rehearse(docs, sgd=get_grads, losses=losses, **config.get(name, {}))\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n        return losses\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        component_cfg (dict): Config parameters for specific components.\n        **cfg: Config parameters.\n        RETURNS: An optimizer\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]  # noqa: F841\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                kwargs = component_cfg.get(name, {})\n                kwargs.update(cfg)\n                proc.begin_training(\n                    get_gold_tuples,\n                    pipeline=self.pipeline,\n                    sgd=self._optimizer,\n                    **kwargs\n                )\n        return self._optimizer\n\n    def resume_training(self, sgd=None, **cfg):\n        \"\"\"Continue training a pre-trained model.\n\n        Create and return an optimizer, and initialize \"rehearsal\" for any pipeline\n        component that has a .rehearse() method. Rehearsal is used to prevent\n        models from \"forgetting\" their initialised \"knowledge\". To perform\n        rehearsal, collect samples of text you want the models to retain performance\n        on, and call nlp.rehearse() with a batch of Doc objects.\n        \"\"\"\n        if cfg.get(\"device\", -1) >= 0:\n            util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"_rehearsal_model\"):\n                proc._rehearsal_model = deepcopy(proc.model)\n        return self._optimizer\n\n    def evaluate(\n        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n    ):\n        if scorer is None:\n            scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            kwargs = component_cfg.get(name, {})\n            kwargs.setdefault(\"batch_size\", batch_size)\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc, **kwargs) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, **kwargs)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            kwargs = component_cfg.get(\"scorer\", {})\n            kwargs.setdefault(\"verbose\", verbose)\n            scorer.score(doc, gold, **kwargs)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=2,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n        component_cfg=None,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): Currently inactive.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed,\n            to control memory use. Experimental.\n        component_cfg (dict): An optional dictionary with extra keyword arguments\n            for specific components.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts,\n                n_threads=n_threads,\n                batch_size=batch_size,\n                disable=disable,\n                component_cfg=component_cfg,\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        if component_cfg is None:\n            component_cfg = {}\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            kwargs = component_cfg.get(name, {})\n            # Allow component_cfg to overwrite the top-level kwargs.\n            kwargs.setdefault(\"batch_size\", batch_size)\n            kwargs.setdefault(\"n_threads\", n_threads)\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, **kwargs)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs, kwargs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): Path to a directory, which will be created if\n            it doesn't exist.\n        exclude (list): Names of components or serialization fields to exclude.\n\n        DOCS: https://spacy.io/api/language#to_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        serializers = OrderedDict()\n        serializers[\"tokenizer\"] = lambda p: self.tokenizer.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda p: p.open(\"w\").write(srsly.json_dumps(self.meta))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, exclude=[\"vocab\"])\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, exclude)\n\n    def from_disk(self, path, exclude=tuple(), disable=None):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The modified `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_disk\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        path = util.ensure_path(path)\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda p: self.meta.update(srsly.read_json(p))\n        deserializers[\"vocab\"] = lambda p: self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda p: self.tokenizer.from_disk(p, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, exclude=[\"vocab\"])\n        if not (path / \"vocab\").exists() and \"vocab\" not in exclude:\n            # Convert to list here in case exclude is (default) tuple\n            exclude = list(exclude) + [\"vocab\"]\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Serialize the current state to a binary string.\n\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (bytes): The serialized form of the `Language` object.\n\n        DOCS: https://spacy.io/api/language#to_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        serializers = OrderedDict()\n        serializers[\"vocab\"] = lambda: self.vocab.to_bytes()\n        serializers[\"tokenizer\"] = lambda: self.tokenizer.to_bytes(exclude=[\"vocab\"])\n        serializers[\"meta.json\"] = lambda: srsly.json_dumps(self.meta)\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[name] = lambda proc=proc: proc.to_bytes(exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(serializers, exclude, kwargs)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, exclude=tuple(), disable=None, **kwargs):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        exclude (list): Names of components or serialization fields to exclude.\n        RETURNS (Language): The `Language` object.\n\n        DOCS: https://spacy.io/api/language#from_bytes\n        \"\"\"\n        if disable is not None:\n            deprecation_warning(Warnings.W014)\n            exclude = disable\n        deserializers = OrderedDict()\n        deserializers[\"meta.json\"] = lambda b: self.meta.update(srsly.json_loads(b))\n        deserializers[\"vocab\"] = lambda b: self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n        deserializers[\"tokenizer\"] = lambda b: self.tokenizer.from_bytes(b, exclude=[\"vocab\"])\n        for name, proc in self.pipeline:\n            if name in exclude:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[name] = lambda b, proc=proc: proc.from_bytes(b, exclude=[\"vocab\"])\n        exclude = util.get_serialization_exclude(deserializers, exclude, kwargs)\n        util.from_bytes(bytes_data, deserializers, exclude)\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs, kwargs):\n    for doc in docs:\n        doc = func(doc, **kwargs)\n        yield doc\n",
          "file_patch": "@@ -106,6 +106,7 @@ class Language(object):\n \n     DOCS: https://spacy.io/api/language\n     \"\"\"\n+\n     Defaults = BaseDefaults\n     lang = None\n \n@@ -344,13 +345,15 @@ class Language(object):\n             raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n         return self.pipeline.pop(self.pipe_names.index(name))\n \n-    def __call__(self, text, disable=[]):\n+    def __call__(self, text, disable=[], component_cfg=None):\n         \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n         and can contain arbtrary whitespace. Alignment into the original string\n         is preserved.\n \n         text (unicode): The text to be processed.\n         disable (list): Names of the pipeline components to disable.\n+        component_cfg (dict): An optional dictionary with extra keyword arguments\n+            for specific components.\n         RETURNS (Doc): A container for accessing the annotations.\n \n         EXAMPLE:\n@@ -363,12 +366,14 @@ class Language(object):\n                 Errors.E088.format(length=len(text), max_length=self.max_length)\n             )\n         doc = self.make_doc(text)\n+        if component_cfg is None:\n+            component_cfg = {}\n         for name, proc in self.pipeline:\n             if name in disable:\n                 continue\n             if not hasattr(proc, \"__call__\"):\n                 raise ValueError(Errors.E003.format(component=type(proc), name=name))\n-            doc = proc(doc)\n+            doc = proc(doc, **component_cfg.get(name, {}))\n             if doc is None:\n                 raise ValueError(Errors.E005.format(name=name))\n         return doc\n@@ -396,7 +401,7 @@ class Language(object):\n     def make_doc(self, text):\n         return self.tokenizer(text)\n \n-    def update(self, docs, golds, drop=0.0, sgd=None, losses=None):\n+    def update(self, docs, golds, drop=0.0, sgd=None, losses=None, component_cfg=None):\n         \"\"\"Update the models in the pipeline.\n \n         docs (iterable): A batch of `Doc` objects.\n@@ -443,11 +448,15 @@ class Language(object):\n \n         pipes = list(self.pipeline)\n         random.shuffle(pipes)\n+        if component_cfg is None:\n+            component_cfg = {}\n         for name, proc in pipes:\n             if not hasattr(proc, \"update\"):\n                 continue\n             grads = {}\n-            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n+            kwargs = component_cfg.get(name, {})\n+            kwargs.setdefault(\"drop\", drop)\n+            proc.update(docs, golds, sgd=get_grads, losses=losses, **kwargs)\n             for key, (W, dW) in grads.items():\n                 sgd(W, dW, key=key)\n \n@@ -517,11 +526,12 @@ class Language(object):\n         for doc, gold in docs_golds:\n             yield doc, gold\n \n-    def begin_training(self, get_gold_tuples=None, sgd=None, **cfg):\n+    def begin_training(self, get_gold_tuples=None, sgd=None, component_cfg=None, **cfg):\n         \"\"\"Allocate models, pre-process training data and acquire a trainer and\n         optimizer. Used as a contextmanager.\n \n         get_gold_tuples (function): Function returning gold data\n+        component_cfg (dict): Config parameters for specific components.\n         **cfg: Config parameters.\n         RETURNS: An optimizer\n         \"\"\"\n@@ -543,10 +553,17 @@ class Language(object):\n         if sgd is None:\n             sgd = create_default_optimizer(Model.ops)\n         self._optimizer = sgd\n+        if component_cfg is None:\n+            component_cfg = {}\n         for name, proc in self.pipeline:\n             if hasattr(proc, \"begin_training\"):\n+                kwargs = component_cfg.get(name, {})\n+                kwargs.update(cfg)\n                 proc.begin_training(\n-                    get_gold_tuples, pipeline=self.pipeline, sgd=self._optimizer, **cfg\n+                    get_gold_tuples,\n+                    pipeline=self.pipeline,\n+                    sgd=self._optimizer,\n+                    **kwargs\n                 )\n         return self._optimizer\n \n@@ -574,20 +591,27 @@ class Language(object):\n                 proc._rehearsal_model = deepcopy(proc.model)\n         return self._optimizer\n \n-    def evaluate(self, docs_golds, verbose=False, batch_size=256):\n-        scorer = Scorer()\n+    def evaluate(\n+        self, docs_golds, verbose=False, batch_size=256, scorer=None, component_cfg=None\n+    ):\n+        if scorer is None:\n+            scorer = Scorer()\n         docs, golds = zip(*docs_golds)\n         docs = list(docs)\n         golds = list(golds)\n         for name, pipe in self.pipeline:\n+            kwargs = component_cfg.get(name, {})\n+            kwargs.setdefault(\"batch_size\", batch_size)\n             if not hasattr(pipe, \"pipe\"):\n-                docs = (pipe(doc) for doc in docs)\n+                docs = (pipe(doc, **kwargs) for doc in docs)\n             else:\n-                docs = pipe.pipe(docs, batch_size=batch_size)\n+                docs = pipe.pipe(docs, **kwargs)\n         for doc, gold in zip(docs, golds):\n             if verbose:\n                 print(doc)\n-            scorer.score(doc, gold, verbose=verbose)\n+            kwargs = component_cfg.get(\"scorer\", {})\n+            kwargs.setdefault(\"verbose\", verbose)\n+            scorer.score(doc, gold, **kwargs)\n         return scorer\n \n     @contextmanager\n@@ -630,6 +654,7 @@ class Language(object):\n         batch_size=1000,\n         disable=[],\n         cleanup=False,\n+        component_cfg=None,\n     ):\n         \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n \n@@ -643,6 +668,8 @@ class Language(object):\n         disable (list): Names of the pipeline components to disable.\n         cleanup (bool): If True, unneeded strings are freed,\n             to control memory use. Experimental.\n+        component_cfg (dict): An optional dictionary with extra keyword arguments\n+            for specific components.\n         YIELDS (Doc): Documents in the order of the original text.\n \n         EXAMPLE:\n@@ -655,20 +682,30 @@ class Language(object):\n             texts = (tc[0] for tc in text_context1)\n             contexts = (tc[1] for tc in text_context2)\n             docs = self.pipe(\n-                texts, n_threads=n_threads, batch_size=batch_size, disable=disable\n+                texts,\n+                n_threads=n_threads,\n+                batch_size=batch_size,\n+                disable=disable,\n+                component_cfg=component_cfg,\n             )\n             for doc, context in izip(docs, contexts):\n                 yield (doc, context)\n             return\n         docs = (self.make_doc(text) for text in texts)\n+        if component_cfg is None:\n+            component_cfg = {}\n         for name, proc in self.pipeline:\n             if name in disable:\n                 continue\n+            kwargs = component_cfg.get(name, {})\n+            # Allow component_cfg to overwrite the top-level kwargs.\n+            kwargs.setdefault(\"batch_size\", batch_size)\n+            kwargs.setdefault(\"n_threads\", n_threads)\n             if hasattr(proc, \"pipe\"):\n-                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n+                docs = proc.pipe(docs, **kwargs)\n             else:\n                 # Apply the function, but yield the doc\n-                docs = _pipe(proc, docs)\n+                docs = _pipe(proc, docs, kwargs)\n         # Track weakrefs of \"recent\" documents, so that we can see when they\n         # expire from memory. When they do, we know we don't need old strings.\n         # This way, we avoid maintaining an unbounded growth in string entries\n@@ -861,7 +898,7 @@ class DisabledPipes(list):\n         self[:] = []\n \n \n-def _pipe(func, docs):\n+def _pipe(func, docs, kwargs):\n     for doc in docs:\n-        doc = func(doc)\n+        doc = func(doc, **kwargs)\n         yield doc\n",
          "files_name_in_blame_commit": [
            "language.py"
          ]
        }
      },
      "eddeb36c96b794601971a79c2e20bb24124fbf9a": {
        "commit": {
          "commit_id": "eddeb36c96b794601971a79c2e20bb24124fbf9a",
          "commit_message": "\ud83d\udcab Tidy up and auto-format .py files (#2983)\n\n<!--- Provide a general summary of your changes in the title. -->\r\n\r\n## Description\r\n- [x] Use [`black`](https://github.com/ambv/black) to auto-format all `.py` files.\r\n- [x] Update flake8 config to exclude very large files (lemmatization tables etc.)\r\n- [x] Update code to be compatible with flake8 rules\r\n- [x] Fix various small bugs, inconsistencies and messy stuff in the language data\r\n- [x] Update docs to explain new code style (`black`, `flake8`, when to use `# fmt: off` and `# fmt: on` and what `# noqa` means)\r\n\r\nOnce #2932 is merged, which auto-formats and tidies up the CLI, we'll be able to run `flake8 spacy` actually get meaningful results.\r\n\r\nAt the moment, the code style and linting isn't applied automatically, but I'm hoping that the new [GitHub Actions](https://github.com/features/actions) will let us auto-format pull requests and post comments with relevant linting information.\r\n\r\n### Types of change\r\nenhancement, code style\r\n\r\n## Checklist\r\n<!--- Before you submit the PR, go over this checklist and make sure you can\r\ntick off all the boxes. [] -> [x] -->\r\n- [x] I have submitted the spaCy Contributor Agreement.\r\n- [x] I ran the tests, and all new and existing tests passed.\r\n- [x] My changes don't require a change to the documentation, or if they do, I've added all required information.",
          "commit_author": "Ines Montani",
          "commit_date": "2018-11-30 17:03:03",
          "commit_parent": "852bc2ac16c87fa6c95c7e4fdd494bd3bf7be8a2"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds, verbose=False):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, batch_size=256)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        scorer.score(doc, gold, verbose=verbose)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            docs = (pipe(doc) for doc in docs)\n        else:\n            docs = pipe.pipe(docs, batch_size=256)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        scorer.score(doc, gold, verbose=verbose)\n    return scorer",
          "function_before_start_line": 488,
          "function_before_end_line": 502,
          "function_after_start_line": 503,
          "function_after_end_line": 517,
          "function_before_token_count": 114,
          "function_after_token_count": 114,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "has_pipe",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_pipe",
            "tensorizer",
            "path",
            "disable_pipes",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer",
            "__exit__",
            "rename_pipe"
          ],
          "functions_name_all_files": [
            "merge_bytes",
            "preprocess_gold",
            "las",
            "get_levels",
            "logistic",
            "replace_pipe",
            "parser",
            "load",
            "from_disk",
            "link_vectors_to_models",
            "upper_first_letter",
            "is_base_form",
            "_preprocess_doc_bigrams",
            "evaluate",
            "token_acc",
            "get_hash",
            "from_bytes",
            "is_punct",
            "has_pipe",
            "iter_files",
            "_divide_array",
            "print_shape",
            "merge_chars",
            "next_token",
            "b_to_str",
            "devoice",
            "ents_p",
            "get_package_path",
            "path",
            "__getattr__",
            "resolve_pos",
            "escape_html",
            "fscore",
            "create_default_optimizer",
            "get_col",
            "models_warning",
            "is_alpha",
            "remove_pipe",
            "load_model_from_path",
            "_add_padding",
            "normalize_slice",
            "pop",
            "cosine",
            "pipe",
            "meta",
            "verb",
            "has",
            "noun",
            "__init__",
            "is_valid",
            "is_package",
            "compile_prefix_regex",
            "doc2feats",
            "strip_tags",
            "_warn",
            "is_oov",
            "normalize_univ_pos",
            "build_text_classifier",
            "set_env_log",
            "is_in_jupyter",
            "create_lemmatizer",
            "recall",
            "deprecation_warning",
            "render_svg",
            "tags_acc",
            "create_vocab",
            "punct",
            "_backprop_padding",
            "print_markdown",
            "lemmatize",
            "minibatch",
            "_get_warn_types",
            "_get_warn_excl",
            "_pipe",
            "precision",
            "read_jsonl",
            "entity",
            "begin_update",
            "add_codes",
            "is_quote",
            "detailed_tokens",
            "tagger",
            "get_arrowhead",
            "Tok2Vec",
            "decaying",
            "main",
            "pickle_binder",
            "get_data_path",
            "run",
            "ends_with_vowel",
            "is_lower",
            "is_right_punct",
            "deduplicate",
            "hash_add",
            "merge",
            "uas",
            "load_model_from_link",
            "starts_with_vowel",
            "make_doc",
            "itershuffle",
            "is_stop",
            "locale_escape",
            "load_model",
            "is_digit",
            "begin_training",
            "oc2ud",
            "ents_r",
            "to_bytes",
            "restore",
            "ensure_path",
            "word_shape",
            "build_tagger_model",
            "pipe_names",
            "preserve_cwd",
            "like_url",
            "get_lang_class",
            "lower_first_letter",
            "get_async",
            "test_train_with_many_entity_types",
            "like_num",
            "score_set",
            "get_entry_points",
            "normalize_string_keys",
            "use_gpu",
            "process_pyx",
            "prints",
            "score",
            "minibatch_by_words",
            "_get_attr_unless_lookup",
            "compounding",
            "num",
            "asarray",
            "PyTorchBiLSTM",
            "use_params",
            "is_ascii",
            "is_upper",
            "compile_infix_regex",
            "__setattr__",
            "ends_dentals",
            "render_word",
            "lower",
            "suffix",
            "cluster",
            "_fix_pretrained_vectors_name",
            "__enter__",
            "get_model_meta",
            "noun_bounds",
            "serve",
            "process",
            "_zero_init",
            "render_arrow",
            "ents_f",
            "set_data_path",
            "read_json",
            "create_tokenizer",
            "hash_changed",
            "pron",
            "to_disk",
            "_make_presegmenter",
            "is_space",
            "rename_pipe",
            "__call__",
            "add_pipe",
            "is_bracket",
            "fix_random_seed",
            "user_warning",
            "stepping",
            "_wrap",
            "render_ents",
            "is_verb_token",
            "adj",
            "is_currency",
            "_flatten_add_lengths",
            "__setitem__",
            "get_cuda_stream",
            "noun_chunks",
            "parse_ents",
            "scores",
            "parse_deps",
            "read_regex",
            "matcher",
            "symlink_remove",
            "load_model_from_package",
            "check_changes",
            "save_hashes",
            "try_mecab_import",
            "like_email",
            "set",
            "_get_key",
            "add_lookups",
            "is_left_punct",
            "init_weights",
            "getitem",
            "render",
            "explain",
            "_return_en",
            "lookup",
            "getattr_",
            "minify_html",
            "expand_exc",
            "_preprocess_doc",
            "SpacyVectors",
            "flatten",
            "__exit__",
            "norm",
            "get_arc",
            "get_prob",
            "preprocess_doc",
            "__iter__",
            "get_raw_input",
            "get_meta",
            "tensorizer",
            "get_pipe",
            "add",
            "is_config",
            "load_model_from_init_py",
            "env_opt",
            "disable_pipes",
            "symlink_to",
            "set_lang_class",
            "get",
            "create_pipe",
            "get_docs",
            "det",
            "compile_suffix_regex",
            "print_table",
            "unpickle_binder",
            "prefix",
            "update",
            "zero_init",
            "get_token_vectors",
            "concatenate_lists",
            "update_exc",
            "import_file",
            "load_hashes",
            "get_ext_args",
            "app",
            "is_title",
            "reapply"
          ],
          "functions_name_co_evolved_modified_file": [
            "create_vocab",
            "preprocess_gold",
            "matcher",
            "parser",
            "entity",
            "from_disk",
            "tagger",
            "use_params",
            "from_bytes",
            "_fix_pretrained_vectors_name",
            "tensorizer",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "restore",
            "create_lemmatizer"
          ],
          "functions_name_co_evolved_all_files": [
            "merge_bytes",
            "preprocess_gold",
            "train_model",
            "get_levels",
            "logistic",
            "parser",
            "from_disk",
            "link_vectors_to_models",
            "is_base_form",
            "_preprocess_doc_bigrams",
            "get_hash",
            "is_punct",
            "from_bytes",
            "_divide_array",
            "print_shape",
            "merge_chars",
            "next_token",
            "devoice",
            "escape_html",
            "resolve_pos",
            "create_default_optimizer",
            "get_col",
            "models_warning",
            "is_alpha",
            "load_model_from_path",
            "cosine",
            "pipe",
            "meta",
            "verb",
            "noun",
            "__init__",
            "is_valid",
            "is_package",
            "compile_prefix_regex",
            "doc2feats",
            "strip_tags",
            "_warn",
            "is_oov",
            "normalize_univ_pos",
            "build_text_classifier",
            "is_in_jupyter",
            "create_lemmatizer",
            "deprecation_warning",
            "render_svg",
            "create_vocab",
            "punct",
            "_backprop_padding",
            "print_markdown",
            "lemmatize",
            "_get_warn_types",
            "_get_warn_excl",
            "read_jsonl",
            "entity",
            "begin_update",
            "add_codes",
            "is_quote",
            "detailed_tokens",
            "tagger",
            "get_arrowhead",
            "Tok2Vec",
            "decaying",
            "ends_with_vowel",
            "is_lower",
            "is_right_punct",
            "deduplicate",
            "merge",
            "load_model_from_link",
            "starts_with_vowel",
            "make_doc",
            "itershuffle",
            "is_stop",
            "load_model",
            "is_digit",
            "begin_training",
            "oc2ud",
            "to_bytes",
            "restore",
            "word_shape",
            "build_tagger_model",
            "like_url",
            "get_lang_class",
            "get_async",
            "test_train_with_many_entity_types",
            "like_num",
            "use_gpu",
            "process_pyx",
            "prints",
            "score",
            "minibatch_by_words",
            "compounding",
            "num",
            "asarray",
            "PyTorchBiLSTM",
            "use_params",
            "is_upper",
            "compile_infix_regex",
            "ends_dentals",
            "render_word",
            "suffix",
            "cluster",
            "lower",
            "_fix_pretrained_vectors_name",
            "get_model_meta",
            "noun_bounds",
            "serve",
            "process",
            "_zero_init",
            "render_arrow",
            "read_json",
            "create_tokenizer",
            "pron",
            "to_disk",
            "_make_presegmenter",
            "is_space",
            "__call__",
            "add_pipe",
            "is_bracket",
            "user_warning",
            "_wrap",
            "stepping",
            "render_ents",
            "adj",
            "is_currency",
            "_flatten_add_lengths",
            "noun_chunks",
            "parse_ents",
            "scores",
            "parse_deps",
            "read_regex",
            "matcher",
            "check_changes",
            "save_hashes",
            "try_mecab_import",
            "_get_key",
            "is_left_punct",
            "init_weights",
            "getitem",
            "render",
            "_return_en",
            "minify_html",
            "expand_exc",
            "_preprocess_doc",
            "SpacyVectors",
            "flatten",
            "norm",
            "get_prob",
            "preprocess_doc",
            "__iter__",
            "get_raw_input",
            "get_meta",
            "tensorizer",
            "add",
            "env_opt",
            "load_model_from_init_py",
            "get_docs",
            "det",
            "print_table",
            "prefix",
            "update",
            "zero_init",
            "get_token_vectors",
            "concatenate_lists",
            "update_exc",
            "compile_suffix_regex",
            "get_ext_args",
            "app",
            "is_title",
            "reapply"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 560,
          "file_complexity": 160,
          "file_token_count": 4061,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport ujson\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy\nfrom thinc.neural import Model\nfrom thinc.neural.optimizers import Adam\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer\nfrom .pipeline import SimilarityHook, TextCategorizer, SentenceSegmenter\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import json_dumps, izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, user_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules,\n                          cls.lemma_lookup)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop,\n                                                      stops=cls.stop_words)\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (util.compile_prefix_regex(cls.prefixes).search\n                         if cls.prefixes else None)\n        suffix_search = (util.compile_suffix_regex(cls.suffixes).search\n                         if cls.suffixes else None)\n        infix_finditer = (util.compile_infix_regex(cls.infixes).finditer\n                          if cls.infixes else None)\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search,\n                         suffix_search=suffix_search,\n                         infix_finditer=infix_finditer,\n                         token_match=token_match)\n\n    pipe_names = ['tagger', 'parser', 'ner']\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        'tokenizer': lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        'tensorizer': lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        'tagger': lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        'parser': lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        'ner': lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        'similarity': lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        'textcat': lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        'sbd': lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        'sentencizer': lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        'merge_noun_chunks': lambda nlp, **cfg: merge_noun_chunks,\n        'merge_entities': lambda nlp, **cfg: merge_entities,\n        'merge_subtokens': lambda nlp, **cfg: merge_subtokens,\n        'entity_ruler': lambda nlp, **cfg: EntityRuler(nlp, **cfg)\n    }\n\n    def __init__(self, vocab=True, make_doc=True, max_length=10**6, meta={}, **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points('spacy_factories')\n        for factory in user_factories.keys():\n            if factory in self.factories:\n                user_warning(Warnings.W009.format(name=factory))\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get('vectors', {}).get('name')\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', 'model')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', '>={}'.format(about.__version__))\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        self._meta['vectors'] = {'width': self.vocab.vectors_length,\n                                 'vectors': len(self.vocab.vectors),\n                                 'keys': self.vocab.vectors.n_keys,\n                                 'name': self.vocab.vectors.name}\n        self._meta['pipeline'] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_pipe('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_pipe('tagger')\n\n    @property\n    def parser(self):\n        return self.get_pipe('parser')\n\n    @property\n    def entity(self):\n        return self.get_pipe('ner')\n\n    @property\n    def matcher(self):\n        return self.get_pipe('matcher')\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n        \"\"\"\n        if name not in self.factories:\n            raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(self, component, name=None, before=None, after=None,\n                 first=None, last=None):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        EXAMPLE:\n            >>> nlp.add_pipe(component, before='ner')\n            >>> nlp.add_pipe(component, name='custom_name', last=True)\n        \"\"\"\n        if not hasattr(component, '__call__'):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, 'name'):\n                name = component.name\n            elif hasattr(component, '__name__'):\n                name = component.__name__\n            elif (hasattr(component, '__class__') and\n                  hasattr(component.__class__, '__name__')):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(Errors.E001.format(name=before or after,\n                                                opts=self.pipe_names))\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[]):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(Errors.E088.format(length=len(text),\n                                                max_length=self.max_length))\n        doc = self.make_doc(text)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, '__call__'):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc)\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        EXAMPLE:\n            >>> nlp.add_pipe('parser')\n            >>> nlp.add_pipe('tagger')\n            >>> with nlp.disable_pipes('parser', 'tagger'):\n            >>>     assert not nlp.has_pipe('parser')\n            >>> assert nlp.has_pipe('parser')\n            >>> disabled = nlp.disable_pipes('parser')\n            >>> assert len(disabled) == 1\n            >>> assert not nlp.has_pipe('parser')\n            >>> disabled.restore()\n            >>> assert nlp.has_pipe('parser')\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        for name, proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            grads = {}\n            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        **cfg: Config parameters.\n        RETURNS: An optimizer\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg['pretrained_vectors'] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                proc.begin_training(get_gold_tuples,\n                                    pipeline=self.pipeline,\n                                    sgd=self._optimizer,\n                                    **cfg)\n        return self._optimizer\n\n    def evaluate(self, docs_golds, verbose=False):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            if not hasattr(pipe, 'pipe'):\n                docs = (pipe(doc) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, batch_size=256)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            scorer.score(doc, gold, verbose=verbose)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for name, pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, as_tuples=False, n_threads=2, batch_size=1000,\n             disable=[], cleanup=False):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): Currently inactive.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed,\n            to control memory use. Experimental.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads,\n                                 batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(original_strings_data)\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        serializers['vocab'] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('meta.json', lambda p: self.meta.update(util.read_json(p))),\n            ('vocab', lambda p: (\n                self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self))),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n        ))\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, 'from_disk'):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, disable=[], **exclude):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: json_dumps(self.meta))\n        ))\n        for i, (name, proc) in enumerate(self.pipeline):\n            if name in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('meta', lambda b: self.meta.update(ujson.loads(b))),\n            ('vocab', lambda b: (\n                self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self))),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n        ))\n        for i, (name, proc) in enumerate(self.pipeline):\n            if name in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if 'vectors' in nlp.meta and nlp.meta['vectors'].get('name'):\n        nlp.vocab.vectors.name = nlp.meta['vectors']['name']\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif 'name' in nlp.meta and 'lang' in nlp.meta:\n        vectors_name = '%s_%s.vectors' % (nlp.meta['lang'], nlp.meta['name'])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, 'cfg'):\n            continue\n        proc.cfg.setdefault('deprecation_fixes', {})\n        proc.cfg['deprecation_fixes']['vectors_name'] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        '''Restore the pipeline to its state when DisabledPipes was created.'''\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current\n                      if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        doc = func(doc)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\n\nimport random\nimport ujson\nimport itertools\nimport weakref\nimport functools\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nfrom copy import copy\nfrom thinc.neural import Model\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .lemmatizer import Lemmatizer\nfrom .pipeline import DependencyParser, Tensorizer, Tagger, EntityRecognizer\nfrom .pipeline import SimilarityHook, TextCategorizer, SentenceSegmenter\nfrom .pipeline import merge_noun_chunks, merge_entities, merge_subtokens\nfrom .pipeline import EntityRuler\nfrom .compat import json_dumps, izip, basestring_\nfrom .gold import GoldParse\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models, create_default_optimizer\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES\nfrom .lang.punctuation import TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS, is_stop\nfrom .errors import Errors, Warnings, user_warning\nfrom . import util\nfrom . import about\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(\n            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n        )\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n        vocab = Vocab(\n            lex_attr_getters=lex_attr_getters,\n            tag_map=cls.tag_map,\n            lemmatizer=lemmatizer,\n        )\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = (\n            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n        )\n        suffix_search = (\n            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n        )\n        infix_finditer = (\n            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n        )\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(\n            vocab,\n            rules=rules,\n            prefix_search=prefix_search,\n            suffix_search=suffix_search,\n            infix_finditer=infix_finditer,\n            token_match=token_match,\n        )\n\n    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    lemma_lookup = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n        \"sbd\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        \"sentencizer\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n    }\n\n    def __init__(\n        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n    ):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        max_length (int) :\n            Maximum number of characters in a single text. The current v2 models\n            may run out memory on extremely long texts, due to large internal\n            allocations. You should segment these texts into meaningful units,\n            e.g. paragraphs, subsections etc, before passing them to spaCy.\n            Default maximum length is 1,000,000 characters (1mb). As a rule of\n            thumb, if all pipeline components are enabled, spaCy's default\n            models currently requires roughly 1GB of temporary memory per\n            100,000 characters in one text.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        user_factories = util.get_entry_points(\"spacy_factories\")\n        for factory in user_factories.keys():\n            if factory in self.factories:\n                user_warning(Warnings.W009.format(name=factory))\n        self.factories.update(user_factories)\n        self._meta = dict(meta)\n        self._path = None\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get(\"vocab\", {}))\n            if vocab.vectors.name is None:\n                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self.max_length = max_length\n        self._optimizer = None\n\n    @property\n    def path(self):\n        return self._path\n\n    @property\n    def meta(self):\n        self._meta.setdefault(\"lang\", self.vocab.lang)\n        self._meta.setdefault(\"name\", \"model\")\n        self._meta.setdefault(\"version\", \"0.0.0\")\n        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n        self._meta.setdefault(\"description\", \"\")\n        self._meta.setdefault(\"author\", \"\")\n        self._meta.setdefault(\"email\", \"\")\n        self._meta.setdefault(\"url\", \"\")\n        self._meta.setdefault(\"license\", \"\")\n        self._meta[\"vectors\"] = {\n            \"width\": self.vocab.vectors_length,\n            \"vectors\": len(self.vocab.vectors),\n            \"keys\": self.vocab.vectors.n_keys,\n            \"name\": self.vocab.vectors.name,\n        }\n        self._meta[\"pipeline\"] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_pipe(\"tensorizer\")\n\n    @property\n    def tagger(self):\n        return self.get_pipe(\"tagger\")\n\n    @property\n    def parser(self):\n        return self.get_pipe(\"parser\")\n\n    @property\n    def entity(self):\n        return self.get_pipe(\"ner\")\n\n    @property\n    def matcher(self):\n        return self.get_pipe(\"matcher\")\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        raise KeyError(Errors.E001.format(name=name, opts=self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        config (dict): Configuration parameters to initialise component.\n        RETURNS (callable): Pipeline component.\n        \"\"\"\n        if name not in self.factories:\n            raise KeyError(Errors.E002.format(name=name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(\n        self, component, name=None, before=None, after=None, first=None, last=None\n    ):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one\n        of before/after/first/last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if a name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        EXAMPLE:\n            >>> nlp.add_pipe(component, before='ner')\n            >>> nlp.add_pipe(component, name='custom_name', last=True)\n        \"\"\"\n        if not hasattr(component, \"__call__\"):\n            msg = Errors.E003.format(component=repr(component), name=name)\n            if isinstance(component, basestring_) and component in self.factories:\n                msg += Errors.E004.format(component=component)\n            raise ValueError(msg)\n        if name is None:\n            if hasattr(component, \"name\"):\n                name = component.name\n            elif hasattr(component, \"__name__\"):\n                name = component.__name__\n            elif hasattr(component, \"__class__\") and hasattr(\n                component.__class__, \"__name__\"\n            ):\n                name = component.__class__.__name__\n            else:\n                name = repr(component)\n        if name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=name, opts=self.pipe_names))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            raise ValueError(Errors.E006)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n        else:\n            raise ValueError(\n                Errors.E001.format(name=before or after, opts=self.pipe_names)\n            )\n\n    def has_pipe(self, name):\n        \"\"\"Check if a component name is present in the pipeline. Equivalent to\n        `name in nlp.pipe_names`.\n\n        name (unicode): Name of the component.\n        RETURNS (bool): Whether a component of the name exists in the pipeline.\n        \"\"\"\n        return name in self.pipe_names\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n        \"\"\"\n        if old_name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=old_name, opts=self.pipe_names))\n        if new_name in self.pipe_names:\n            raise ValueError(Errors.E007.format(name=new_name, opts=self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A `(name, component)` tuple of the removed component.\n        \"\"\"\n        if name not in self.pipe_names:\n            raise ValueError(Errors.E001.format(name=name, opts=self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[]):\n        \"\"\"Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        if len(text) > self.max_length:\n            raise ValueError(\n                Errors.E088.format(length=len(text), max_length=self.max_length)\n            )\n        doc = self.make_doc(text)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"__call__\"):\n                raise ValueError(Errors.E003.format(component=type(proc), name=name))\n            doc = proc(doc)\n            if doc is None:\n                raise ValueError(Errors.E005.format(name=name))\n        return doc\n\n    def disable_pipes(self, *names):\n        \"\"\"Disable one or more pipeline components. If used as a context\n        manager, the pipeline will be restored to the initial state at the end\n        of the block. Otherwise, a DisabledPipes object is returned, that has\n        a `.restore()` method you can use to undo your changes.\n\n        EXAMPLE:\n            >>> nlp.add_pipe('parser')\n            >>> nlp.add_pipe('tagger')\n            >>> with nlp.disable_pipes('parser', 'tagger'):\n            >>>     assert not nlp.has_pipe('parser')\n            >>> assert nlp.has_pipe('parser')\n            >>> disabled = nlp.disable_pipes('parser')\n            >>> assert len(disabled) == 1\n            >>> assert not nlp.has_pipe('parser')\n            >>> disabled.restore()\n            >>> assert nlp.has_pipe('parser')\n        \"\"\"\n        return DisabledPipes(self, *names)\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0.0, sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(Errors.E009.format(n_docs=len(docs), n_golds=len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = create_default_optimizer(Model.ops)\n            sgd = self._optimizer\n\n        # Allow dict of args to GoldParse, instead of GoldParse objects.\n        gold_objs = []\n        doc_objs = []\n        for doc, gold in zip(docs, golds):\n            if isinstance(doc, basestring_):\n                doc = self.make_doc(doc)\n            if not isinstance(gold, GoldParse):\n                gold = GoldParse(doc, **gold)\n            doc_objs.append(doc)\n            gold_objs.append(gold)\n        golds = gold_objs\n        docs = doc_objs\n        grads = {}\n\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n\n        get_grads.alpha = sgd.alpha\n        get_grads.b1 = sgd.b1\n        get_grads.b2 = sgd.b2\n\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        for name, proc in pipes:\n            if not hasattr(proc, \"update\"):\n                continue\n            grads = {}\n            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n            for key, (W, dW) in grads.items():\n                sgd(W, dW, key=key)\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"preprocess_gold\"):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples=None, sgd=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        **cfg: Config parameters.\n        RETURNS: An optimizer\n        \"\"\"\n        if get_gold_tuples is None:\n            get_gold_tuples = lambda: []\n        # Populate vocab\n        else:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]\n        contexts = []\n        if cfg.get(\"device\", -1) >= 0:\n            device = util.use_gpu(cfg[\"device\"])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n        else:\n            device = None\n        link_vectors_to_models(self.vocab)\n        if self.vocab.vectors.data.shape[1]:\n            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n        if sgd is None:\n            sgd = create_default_optimizer(Model.ops)\n        self._optimizer = sgd\n        for name, proc in self.pipeline:\n            if hasattr(proc, \"begin_training\"):\n                proc.begin_training(\n                    get_gold_tuples, pipeline=self.pipeline, sgd=self._optimizer, **cfg\n                )\n        return self._optimizer\n\n    def evaluate(self, docs_golds, verbose=False):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            if not hasattr(pipe, \"pipe\"):\n                docs = (pipe(doc) for doc in docs)\n            else:\n                docs = pipe.pipe(docs, batch_size=256)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            scorer.score(doc, gold, verbose=verbose)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [\n            pipe.use_params(params)\n            for name, pipe in self.pipeline\n            if hasattr(pipe, \"use_params\")\n        ]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(\n        self,\n        texts,\n        as_tuples=False,\n        n_threads=2,\n        batch_size=1000,\n        disable=[],\n        cleanup=False,\n    ):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): Currently inactive.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        cleanup (bool): If True, unneeded strings are freed,\n            to control memory use. Experimental.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(\n                texts, n_threads=n_threads, batch_size=batch_size, disable=disable\n            )\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if hasattr(proc, \"pipe\"):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        # Track weakrefs of \"recent\" documents, so that we can see when they\n        # expire from memory. When they do, we know we don't need old strings.\n        # This way, we avoid maintaining an unbounded growth in string entries\n        # in the string store.\n        recent_refs = weakref.WeakSet()\n        old_refs = weakref.WeakSet()\n        # Keep track of the original string data, so that if we flush old strings,\n        # we can recover the original ones. However, we only want to do this if we're\n        # really adding strings, to save up-front costs.\n        original_strings_data = None\n        nr_seen = 0\n        for doc in docs:\n            yield doc\n            if cleanup:\n                recent_refs.add(doc)\n                if nr_seen < 10000:\n                    old_refs.add(doc)\n                    nr_seen += 1\n                elif len(old_refs) == 0:\n                    old_refs, recent_refs = recent_refs, old_refs\n                    if original_strings_data is None:\n                        original_strings_data = list(self.vocab.strings)\n                    else:\n                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n                            original_strings_data\n                        )\n                        self.vocab._reset_cache(keys, strings)\n                        self.tokenizer._reset_cache(keys)\n                    nr_seen = 0\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict(\n            (\n                (\"tokenizer\", lambda p: self.tokenizer.to_disk(p, vocab=False)),\n                (\"meta.json\", lambda p: p.open(\"w\").write(json_dumps(self.meta))),\n            )\n        )\n        for name, proc in self.pipeline:\n            if not hasattr(proc, \"name\"):\n                continue\n            if name in disable:\n                continue\n            if not hasattr(proc, \"to_disk\"):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict(\n            (\n                (\"meta.json\", lambda p: self.meta.update(util.read_json(p))),\n                (\n                    \"vocab\",\n                    lambda p: (\n                        self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n                    ),\n                ),\n                (\"tokenizer\", lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            )\n        )\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, \"from_disk\"):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / \"vocab\").exists():\n            exclude[\"vocab\"] = True\n        util.from_disk(path, deserializers, exclude)\n        self._path = path\n        return self\n\n    def to_bytes(self, disable=[], **exclude):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict(\n            (\n                (\"vocab\", lambda: self.vocab.to_bytes()),\n                (\"tokenizer\", lambda: self.tokenizer.to_bytes(vocab=False)),\n                (\"meta\", lambda: json_dumps(self.meta)),\n            )\n        )\n        for i, (name, proc) in enumerate(self.pipeline):\n            if name in disable:\n                continue\n            if not hasattr(proc, \"to_bytes\"):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, exclude)\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict(\n            (\n                (\"meta\", lambda b: self.meta.update(ujson.loads(b))),\n                (\n                    \"vocab\",\n                    lambda b: (\n                        self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n                    ),\n                ),\n                (\"tokenizer\", lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            )\n        )\n        for i, (name, proc) in enumerate(self.pipeline):\n            if name in disable:\n                continue\n            if not hasattr(proc, \"from_bytes\"):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _fix_pretrained_vectors_name(nlp):\n    # TODO: Replace this once we handle vectors consistently as static\n    # data\n    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n    elif not nlp.vocab.vectors.size:\n        nlp.vocab.vectors.name = None\n    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n        nlp.vocab.vectors.name = vectors_name\n    else:\n        raise ValueError(Errors.E092)\n    if nlp.vocab.vectors.size != 0:\n        link_vectors_to_models(nlp.vocab)\n    for name, proc in nlp.pipeline:\n        if not hasattr(proc, \"cfg\"):\n            continue\n        proc.cfg.setdefault(\"deprecation_fixes\", {})\n        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n\n\nclass DisabledPipes(list):\n    \"\"\"Manager for temporary pipeline disabling.\"\"\"\n\n    def __init__(self, nlp, *names):\n        self.nlp = nlp\n        self.names = names\n        # Important! Not deep copy -- we just want the container (but we also\n        # want to support people providing arbitrarily typed nlp.pipeline\n        # objects.)\n        self.original_pipeline = copy(nlp.pipeline)\n        list.__init__(self)\n        self.extend(nlp.remove_pipe(name) for name in names)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.restore()\n\n    def restore(self):\n        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n        current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n        if unexpected:\n            # Don't change the pipeline if we're raising an error.\n            self.nlp.pipeline = current\n            raise ValueError(Errors.E008.format(names=unexpected))\n        self[:] = []\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        doc = func(doc)\n        yield doc\n",
          "file_patch": "@@ -10,7 +10,6 @@ from collections import OrderedDict\n from contextlib import contextmanager\n from copy import copy\n from thinc.neural import Model\n-from thinc.neural.optimizers import Adam\n \n from .tokenizer import Tokenizer\n from .vocab import Vocab\n@@ -37,18 +36,21 @@ from . import about\n class BaseDefaults(object):\n     @classmethod\n     def create_lemmatizer(cls, nlp=None):\n-        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules,\n-                          cls.lemma_lookup)\n+        return Lemmatizer(\n+            cls.lemma_index, cls.lemma_exc, cls.lemma_rules, cls.lemma_lookup\n+        )\n \n     @classmethod\n     def create_vocab(cls, nlp=None):\n         lemmatizer = cls.create_lemmatizer(nlp)\n         lex_attr_getters = dict(cls.lex_attr_getters)\n         # This is messy, but it's the minimal working fix to Issue #639.\n-        lex_attr_getters[IS_STOP] = functools.partial(is_stop,\n-                                                      stops=cls.stop_words)\n-        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n-                      lemmatizer=lemmatizer)\n+        lex_attr_getters[IS_STOP] = functools.partial(is_stop, stops=cls.stop_words)\n+        vocab = Vocab(\n+            lex_attr_getters=lex_attr_getters,\n+            tag_map=cls.tag_map,\n+            lemmatizer=lemmatizer,\n+        )\n         for tag_str, exc in cls.morph_rules.items():\n             for orth_str, attrs in exc.items():\n                 vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n@@ -58,20 +60,26 @@ class BaseDefaults(object):\n     def create_tokenizer(cls, nlp=None):\n         rules = cls.tokenizer_exceptions\n         token_match = cls.token_match\n-        prefix_search = (util.compile_prefix_regex(cls.prefixes).search\n-                         if cls.prefixes else None)\n-        suffix_search = (util.compile_suffix_regex(cls.suffixes).search\n-                         if cls.suffixes else None)\n-        infix_finditer = (util.compile_infix_regex(cls.infixes).finditer\n-                          if cls.infixes else None)\n+        prefix_search = (\n+            util.compile_prefix_regex(cls.prefixes).search if cls.prefixes else None\n+        )\n+        suffix_search = (\n+            util.compile_suffix_regex(cls.suffixes).search if cls.suffixes else None\n+        )\n+        infix_finditer = (\n+            util.compile_infix_regex(cls.infixes).finditer if cls.infixes else None\n+        )\n         vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n-        return Tokenizer(vocab, rules=rules,\n-                         prefix_search=prefix_search,\n-                         suffix_search=suffix_search,\n-                         infix_finditer=infix_finditer,\n-                         token_match=token_match)\n-\n-    pipe_names = ['tagger', 'parser', 'ner']\n+        return Tokenizer(\n+            vocab,\n+            rules=rules,\n+            prefix_search=prefix_search,\n+            suffix_search=suffix_search,\n+            infix_finditer=infix_finditer,\n+            token_match=token_match,\n+        )\n+\n+    pipe_names = [\"tagger\", \"parser\", \"ner\"]\n     token_match = TOKEN_MATCH\n     prefixes = tuple(TOKENIZER_PREFIXES)\n     suffixes = tuple(TOKENIZER_SUFFIXES)\n@@ -96,26 +104,29 @@ class Language(object):\n         object and processing pipeline.\n     lang (unicode): Two-letter language ID, i.e. ISO code.\n     \"\"\"\n+\n     Defaults = BaseDefaults\n     lang = None\n \n     factories = {\n-        'tokenizer': lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n-        'tensorizer': lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n-        'tagger': lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n-        'parser': lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n-        'ner': lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n-        'similarity': lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n-        'textcat': lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n-        'sbd': lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n-        'sentencizer': lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n-        'merge_noun_chunks': lambda nlp, **cfg: merge_noun_chunks,\n-        'merge_entities': lambda nlp, **cfg: merge_entities,\n-        'merge_subtokens': lambda nlp, **cfg: merge_subtokens,\n-        'entity_ruler': lambda nlp, **cfg: EntityRuler(nlp, **cfg)\n+        \"tokenizer\": lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n+        \"tensorizer\": lambda nlp, **cfg: Tensorizer(nlp.vocab, **cfg),\n+        \"tagger\": lambda nlp, **cfg: Tagger(nlp.vocab, **cfg),\n+        \"parser\": lambda nlp, **cfg: DependencyParser(nlp.vocab, **cfg),\n+        \"ner\": lambda nlp, **cfg: EntityRecognizer(nlp.vocab, **cfg),\n+        \"similarity\": lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n+        \"textcat\": lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg),\n+        \"sbd\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n+        \"sentencizer\": lambda nlp, **cfg: SentenceSegmenter(nlp.vocab, **cfg),\n+        \"merge_noun_chunks\": lambda nlp, **cfg: merge_noun_chunks,\n+        \"merge_entities\": lambda nlp, **cfg: merge_entities,\n+        \"merge_subtokens\": lambda nlp, **cfg: merge_subtokens,\n+        \"entity_ruler\": lambda nlp, **cfg: EntityRuler(nlp, **cfg),\n     }\n \n-    def __init__(self, vocab=True, make_doc=True, max_length=10**6, meta={}, **kwargs):\n+    def __init__(\n+        self, vocab=True, make_doc=True, max_length=10 ** 6, meta={}, **kwargs\n+    ):\n         \"\"\"Initialise a Language object.\n \n         vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n@@ -135,7 +146,7 @@ class Language(object):\n             100,000 characters in one text.\n         RETURNS (Language): The newly constructed object.\n         \"\"\"\n-        user_factories = util.get_entry_points('spacy_factories')\n+        user_factories = util.get_entry_points(\"spacy_factories\")\n         for factory in user_factories.keys():\n             if factory in self.factories:\n                 user_warning(Warnings.W009.format(name=factory))\n@@ -144,13 +155,13 @@ class Language(object):\n         self._path = None\n         if vocab is True:\n             factory = self.Defaults.create_vocab\n-            vocab = factory(self, **meta.get('vocab', {}))\n+            vocab = factory(self, **meta.get(\"vocab\", {}))\n             if vocab.vectors.name is None:\n-                vocab.vectors.name = meta.get('vectors', {}).get('name')\n+                vocab.vectors.name = meta.get(\"vectors\", {}).get(\"name\")\n         self.vocab = vocab\n         if make_doc is True:\n             factory = self.Defaults.create_tokenizer\n-            make_doc = factory(self, **meta.get('tokenizer', {}))\n+            make_doc = factory(self, **meta.get(\"tokenizer\", {}))\n         self.tokenizer = make_doc\n         self.pipeline = []\n         self.max_length = max_length\n@@ -162,20 +173,22 @@ class Language(object):\n \n     @property\n     def meta(self):\n-        self._meta.setdefault('lang', self.vocab.lang)\n-        self._meta.setdefault('name', 'model')\n-        self._meta.setdefault('version', '0.0.0')\n-        self._meta.setdefault('spacy_version', '>={}'.format(about.__version__))\n-        self._meta.setdefault('description', '')\n-        self._meta.setdefault('author', '')\n-        self._meta.setdefault('email', '')\n-        self._meta.setdefault('url', '')\n-        self._meta.setdefault('license', '')\n-        self._meta['vectors'] = {'width': self.vocab.vectors_length,\n-                                 'vectors': len(self.vocab.vectors),\n-                                 'keys': self.vocab.vectors.n_keys,\n-                                 'name': self.vocab.vectors.name}\n-        self._meta['pipeline'] = self.pipe_names\n+        self._meta.setdefault(\"lang\", self.vocab.lang)\n+        self._meta.setdefault(\"name\", \"model\")\n+        self._meta.setdefault(\"version\", \"0.0.0\")\n+        self._meta.setdefault(\"spacy_version\", \">={}\".format(about.__version__))\n+        self._meta.setdefault(\"description\", \"\")\n+        self._meta.setdefault(\"author\", \"\")\n+        self._meta.setdefault(\"email\", \"\")\n+        self._meta.setdefault(\"url\", \"\")\n+        self._meta.setdefault(\"license\", \"\")\n+        self._meta[\"vectors\"] = {\n+            \"width\": self.vocab.vectors_length,\n+            \"vectors\": len(self.vocab.vectors),\n+            \"keys\": self.vocab.vectors.n_keys,\n+            \"name\": self.vocab.vectors.name,\n+        }\n+        self._meta[\"pipeline\"] = self.pipe_names\n         return self._meta\n \n     @meta.setter\n@@ -185,23 +198,23 @@ class Language(object):\n     # Conveniences to access pipeline components\n     @property\n     def tensorizer(self):\n-        return self.get_pipe('tensorizer')\n+        return self.get_pipe(\"tensorizer\")\n \n     @property\n     def tagger(self):\n-        return self.get_pipe('tagger')\n+        return self.get_pipe(\"tagger\")\n \n     @property\n     def parser(self):\n-        return self.get_pipe('parser')\n+        return self.get_pipe(\"parser\")\n \n     @property\n     def entity(self):\n-        return self.get_pipe('ner')\n+        return self.get_pipe(\"ner\")\n \n     @property\n     def matcher(self):\n-        return self.get_pipe('matcher')\n+        return self.get_pipe(\"matcher\")\n \n     @property\n     def pipe_names(self):\n@@ -234,8 +247,9 @@ class Language(object):\n         factory = self.factories[name]\n         return factory(self, **config)\n \n-    def add_pipe(self, component, name=None, before=None, after=None,\n-                 first=None, last=None):\n+    def add_pipe(\n+        self, component, name=None, before=None, after=None, first=None, last=None\n+    ):\n         \"\"\"Add a component to the processing pipeline. Valid components are\n         callables that take a `Doc` object, modify it and return it. Only one\n         of before/after/first/last can be set. Default behaviour is \"last\".\n@@ -254,18 +268,19 @@ class Language(object):\n             >>> nlp.add_pipe(component, before='ner')\n             >>> nlp.add_pipe(component, name='custom_name', last=True)\n         \"\"\"\n-        if not hasattr(component, '__call__'):\n+        if not hasattr(component, \"__call__\"):\n             msg = Errors.E003.format(component=repr(component), name=name)\n             if isinstance(component, basestring_) and component in self.factories:\n                 msg += Errors.E004.format(component=component)\n             raise ValueError(msg)\n         if name is None:\n-            if hasattr(component, 'name'):\n+            if hasattr(component, \"name\"):\n                 name = component.name\n-            elif hasattr(component, '__name__'):\n+            elif hasattr(component, \"__name__\"):\n                 name = component.__name__\n-            elif (hasattr(component, '__class__') and\n-                  hasattr(component.__class__, '__name__')):\n+            elif hasattr(component, \"__class__\") and hasattr(\n+                component.__class__, \"__name__\"\n+            ):\n                 name = component.__class__.__name__\n             else:\n                 name = repr(component)\n@@ -283,8 +298,9 @@ class Language(object):\n         elif after and after in self.pipe_names:\n             self.pipeline.insert(self.pipe_names.index(after) + 1, pipe)\n         else:\n-            raise ValueError(Errors.E001.format(name=before or after,\n-                                                opts=self.pipe_names))\n+            raise ValueError(\n+                Errors.E001.format(name=before or after, opts=self.pipe_names)\n+            )\n \n     def has_pipe(self, name):\n         \"\"\"Check if a component name is present in the pipeline. Equivalent to\n@@ -343,13 +359,14 @@ class Language(object):\n             ('An', 'NN')\n         \"\"\"\n         if len(text) > self.max_length:\n-            raise ValueError(Errors.E088.format(length=len(text),\n-                                                max_length=self.max_length))\n+            raise ValueError(\n+                Errors.E088.format(length=len(text), max_length=self.max_length)\n+            )\n         doc = self.make_doc(text)\n         for name, proc in self.pipeline:\n             if name in disable:\n                 continue\n-            if not hasattr(proc, '__call__'):\n+            if not hasattr(proc, \"__call__\"):\n                 raise ValueError(Errors.E003.format(component=type(proc), name=name))\n             doc = proc(doc)\n             if doc is None:\n@@ -379,7 +396,7 @@ class Language(object):\n     def make_doc(self, text):\n         return self.tokenizer(text)\n \n-    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n+    def update(self, docs, golds, drop=0.0, sgd=None, losses=None):\n         \"\"\"Update the models in the pipeline.\n \n         docs (iterable): A batch of `Doc` objects.\n@@ -427,7 +444,7 @@ class Language(object):\n         pipes = list(self.pipeline)\n         random.shuffle(pipes)\n         for name, proc in pipes:\n-            if not hasattr(proc, 'update'):\n+            if not hasattr(proc, \"update\"):\n                 continue\n             grads = {}\n             proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n@@ -442,7 +459,7 @@ class Language(object):\n         YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n         \"\"\"\n         for name, proc in self.pipeline:\n-            if hasattr(proc, 'preprocess_gold'):\n+            if hasattr(proc, \"preprocess_gold\"):\n                 docs_golds = proc.preprocess_gold(docs_golds)\n         for doc, gold in docs_golds:\n             yield doc, gold\n@@ -464,25 +481,23 @@ class Language(object):\n                     for word in annots[1]:\n                         _ = self.vocab[word]\n         contexts = []\n-        if cfg.get('device', -1) >= 0:\n-            device = util.use_gpu(cfg['device'])\n+        if cfg.get(\"device\", -1) >= 0:\n+            device = util.use_gpu(cfg[\"device\"])\n             if self.vocab.vectors.data.shape[1] >= 1:\n-                self.vocab.vectors.data = Model.ops.asarray(\n-                    self.vocab.vectors.data)\n+                self.vocab.vectors.data = Model.ops.asarray(self.vocab.vectors.data)\n         else:\n             device = None\n         link_vectors_to_models(self.vocab)\n         if self.vocab.vectors.data.shape[1]:\n-            cfg['pretrained_vectors'] = self.vocab.vectors.name\n+            cfg[\"pretrained_vectors\"] = self.vocab.vectors.name\n         if sgd is None:\n             sgd = create_default_optimizer(Model.ops)\n         self._optimizer = sgd\n         for name, proc in self.pipeline:\n-            if hasattr(proc, 'begin_training'):\n-                proc.begin_training(get_gold_tuples,\n-                                    pipeline=self.pipeline,\n-                                    sgd=self._optimizer,\n-                                    **cfg)\n+            if hasattr(proc, \"begin_training\"):\n+                proc.begin_training(\n+                    get_gold_tuples, pipeline=self.pipeline, sgd=self._optimizer, **cfg\n+                )\n         return self._optimizer\n \n     def evaluate(self, docs_golds, verbose=False):\n@@ -491,7 +506,7 @@ class Language(object):\n         docs = list(docs)\n         golds = list(golds)\n         for name, pipe in self.pipeline:\n-            if not hasattr(pipe, 'pipe'):\n+            if not hasattr(pipe, \"pipe\"):\n                 docs = (pipe(doc) for doc in docs)\n             else:\n                 docs = pipe.pipe(docs, batch_size=256)\n@@ -514,8 +529,11 @@ class Language(object):\n             >>> with nlp.use_params(optimizer.averages):\n             >>>     nlp.to_disk('/tmp/checkpoint')\n         \"\"\"\n-        contexts = [pipe.use_params(params) for name, pipe\n-                    in self.pipeline if hasattr(pipe, 'use_params')]\n+        contexts = [\n+            pipe.use_params(params)\n+            for name, pipe in self.pipeline\n+            if hasattr(pipe, \"use_params\")\n+        ]\n         # TODO: Having trouble with contextlib\n         # Workaround: these aren't actually context managers atm.\n         for context in contexts:\n@@ -530,8 +548,15 @@ class Language(object):\n             except StopIteration:\n                 pass\n \n-    def pipe(self, texts, as_tuples=False, n_threads=2, batch_size=1000,\n-             disable=[], cleanup=False):\n+    def pipe(\n+        self,\n+        texts,\n+        as_tuples=False,\n+        n_threads=2,\n+        batch_size=1000,\n+        disable=[],\n+        cleanup=False,\n+    ):\n         \"\"\"Process texts as a stream, and yield `Doc` objects in order.\n \n         texts (iterator): A sequence of texts to process.\n@@ -555,8 +580,9 @@ class Language(object):\n             text_context1, text_context2 = itertools.tee(texts)\n             texts = (tc[0] for tc in text_context1)\n             contexts = (tc[1] for tc in text_context2)\n-            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n-                             disable=disable)\n+            docs = self.pipe(\n+                texts, n_threads=n_threads, batch_size=batch_size, disable=disable\n+            )\n             for doc, context in izip(docs, contexts):\n                 yield (doc, context)\n             return\n@@ -564,9 +590,8 @@ class Language(object):\n         for name, proc in self.pipeline:\n             if name in disable:\n                 continue\n-            if hasattr(proc, 'pipe'):\n-                docs = proc.pipe(docs, n_threads=n_threads,\n-                                 batch_size=batch_size)\n+            if hasattr(proc, \"pipe\"):\n+                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n             else:\n                 # Apply the function, but yield the doc\n                 docs = _pipe(proc, docs)\n@@ -593,7 +618,9 @@ class Language(object):\n                     if original_strings_data is None:\n                         original_strings_data = list(self.vocab.strings)\n                     else:\n-                        keys, strings = self.vocab.strings._cleanup_stale_strings(original_strings_data)\n+                        keys, strings = self.vocab.strings._cleanup_stale_strings(\n+                            original_strings_data\n+                        )\n                         self.vocab._reset_cache(keys, strings)\n                         self.tokenizer._reset_cache(keys)\n                     nr_seen = 0\n@@ -611,19 +638,21 @@ class Language(object):\n             >>> nlp.to_disk('/path/to/models')\n         \"\"\"\n         path = util.ensure_path(path)\n-        serializers = OrderedDict((\n-            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n-            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n-        ))\n+        serializers = OrderedDict(\n+            (\n+                (\"tokenizer\", lambda p: self.tokenizer.to_disk(p, vocab=False)),\n+                (\"meta.json\", lambda p: p.open(\"w\").write(json_dumps(self.meta))),\n+            )\n+        )\n         for name, proc in self.pipeline:\n-            if not hasattr(proc, 'name'):\n+            if not hasattr(proc, \"name\"):\n                 continue\n             if name in disable:\n                 continue\n-            if not hasattr(proc, 'to_disk'):\n+            if not hasattr(proc, \"to_disk\"):\n                 continue\n             serializers[name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n-        serializers['vocab'] = lambda p: self.vocab.to_disk(p)\n+        serializers[\"vocab\"] = lambda p: self.vocab.to_disk(p)\n         util.to_disk(path, serializers, {p: False for p in disable})\n \n     def from_disk(self, path, disable=tuple()):\n@@ -641,21 +670,27 @@ class Language(object):\n             >>> nlp = Language().from_disk('/path/to/models')\n         \"\"\"\n         path = util.ensure_path(path)\n-        deserializers = OrderedDict((\n-            ('meta.json', lambda p: self.meta.update(util.read_json(p))),\n-            ('vocab', lambda p: (\n-                self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self))),\n-            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n-        ))\n+        deserializers = OrderedDict(\n+            (\n+                (\"meta.json\", lambda p: self.meta.update(util.read_json(p))),\n+                (\n+                    \"vocab\",\n+                    lambda p: (\n+                        self.vocab.from_disk(p) and _fix_pretrained_vectors_name(self)\n+                    ),\n+                ),\n+                (\"tokenizer\", lambda p: self.tokenizer.from_disk(p, vocab=False)),\n+            )\n+        )\n         for name, proc in self.pipeline:\n             if name in disable:\n                 continue\n-            if not hasattr(proc, 'from_disk'):\n+            if not hasattr(proc, \"from_disk\"):\n                 continue\n             deserializers[name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n         exclude = {p: False for p in disable}\n-        if not (path / 'vocab').exists():\n-            exclude['vocab'] = True\n+        if not (path / \"vocab\").exists():\n+            exclude[\"vocab\"] = True\n         util.from_disk(path, deserializers, exclude)\n         self._path = path\n         return self\n@@ -667,15 +702,17 @@ class Language(object):\n             from being serialized.\n         RETURNS (bytes): The serialized form of the `Language` object.\n         \"\"\"\n-        serializers = OrderedDict((\n-            ('vocab', lambda: self.vocab.to_bytes()),\n-            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n-            ('meta', lambda: json_dumps(self.meta))\n-        ))\n+        serializers = OrderedDict(\n+            (\n+                (\"vocab\", lambda: self.vocab.to_bytes()),\n+                (\"tokenizer\", lambda: self.tokenizer.to_bytes(vocab=False)),\n+                (\"meta\", lambda: json_dumps(self.meta)),\n+            )\n+        )\n         for i, (name, proc) in enumerate(self.pipeline):\n             if name in disable:\n                 continue\n-            if not hasattr(proc, 'to_bytes'):\n+            if not hasattr(proc, \"to_bytes\"):\n                 continue\n             serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n         return util.to_bytes(serializers, exclude)\n@@ -687,16 +724,22 @@ class Language(object):\n         disable (list): Names of the pipeline components to disable.\n         RETURNS (Language): The `Language` object.\n         \"\"\"\n-        deserializers = OrderedDict((\n-            ('meta', lambda b: self.meta.update(ujson.loads(b))),\n-            ('vocab', lambda b: (\n-                self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self))),\n-            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n-        ))\n+        deserializers = OrderedDict(\n+            (\n+                (\"meta\", lambda b: self.meta.update(ujson.loads(b))),\n+                (\n+                    \"vocab\",\n+                    lambda b: (\n+                        self.vocab.from_bytes(b) and _fix_pretrained_vectors_name(self)\n+                    ),\n+                ),\n+                (\"tokenizer\", lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n+            )\n+        )\n         for i, (name, proc) in enumerate(self.pipeline):\n             if name in disable:\n                 continue\n-            if not hasattr(proc, 'from_bytes'):\n+            if not hasattr(proc, \"from_bytes\"):\n                 continue\n             deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n         msg = util.from_bytes(bytes_data, deserializers, {})\n@@ -706,26 +749,27 @@ class Language(object):\n def _fix_pretrained_vectors_name(nlp):\n     # TODO: Replace this once we handle vectors consistently as static\n     # data\n-    if 'vectors' in nlp.meta and nlp.meta['vectors'].get('name'):\n-        nlp.vocab.vectors.name = nlp.meta['vectors']['name']\n+    if \"vectors\" in nlp.meta and nlp.meta[\"vectors\"].get(\"name\"):\n+        nlp.vocab.vectors.name = nlp.meta[\"vectors\"][\"name\"]\n     elif not nlp.vocab.vectors.size:\n         nlp.vocab.vectors.name = None\n-    elif 'name' in nlp.meta and 'lang' in nlp.meta:\n-        vectors_name = '%s_%s.vectors' % (nlp.meta['lang'], nlp.meta['name'])\n+    elif \"name\" in nlp.meta and \"lang\" in nlp.meta:\n+        vectors_name = \"%s_%s.vectors\" % (nlp.meta[\"lang\"], nlp.meta[\"name\"])\n         nlp.vocab.vectors.name = vectors_name\n     else:\n         raise ValueError(Errors.E092)\n     if nlp.vocab.vectors.size != 0:\n         link_vectors_to_models(nlp.vocab)\n     for name, proc in nlp.pipeline:\n-        if not hasattr(proc, 'cfg'):\n+        if not hasattr(proc, \"cfg\"):\n             continue\n-        proc.cfg.setdefault('deprecation_fixes', {})\n-        proc.cfg['deprecation_fixes']['vectors_name'] = nlp.vocab.vectors.name\n+        proc.cfg.setdefault(\"deprecation_fixes\", {})\n+        proc.cfg[\"deprecation_fixes\"][\"vectors_name\"] = nlp.vocab.vectors.name\n \n \n class DisabledPipes(list):\n     \"\"\"Manager for temporary pipeline disabling.\"\"\"\n+\n     def __init__(self, nlp, *names):\n         self.nlp = nlp\n         self.names = names\n@@ -743,10 +787,9 @@ class DisabledPipes(list):\n         self.restore()\n \n     def restore(self):\n-        '''Restore the pipeline to its state when DisabledPipes was created.'''\n+        \"\"\"Restore the pipeline to its state when DisabledPipes was created.\"\"\"\n         current, self.nlp.pipeline = self.nlp.pipeline, self.original_pipeline\n-        unexpected = [name for name, pipe in current\n-                      if not self.nlp.has_pipe(name)]\n+        unexpected = [name for name, pipe in current if not self.nlp.has_pipe(name)]\n         if unexpected:\n             # Don't change the pipeline if we're raising an error.\n             self.nlp.pipeline = current\n",
          "files_name_in_blame_commit": [
            "_pronouns_irreg.py",
            "_participles.py",
            "_auxiliary_verbs_irreg.py",
            "_adjectives_irreg.py",
            "about.py",
            "entity_rules.py",
            "__init__.py",
            "underscore.py",
            "_tokenizer_exceptions_list.py",
            "_nouns.py",
            "_dets.py",
            "_adverbs_irreg.py",
            "_ml.py",
            "util.py",
            "cythonize.py",
            "irish_morphology_helpers.py",
            "load_reddit.py",
            "examples.py",
            "compat.py",
            "_adjectives.py",
            "language.py",
            "_verbs_irreg.py",
            "_test_issue2800.py",
            "scorer.py",
            "punctuation.py",
            "tag_map.py",
            "tag_map_general.py",
            "_adverbs.py",
            "norm_exceptions.py",
            "_serialize.py",
            "_proper_names.py",
            "char_classes.py",
            "errors.py",
            "_verbs_exc.py",
            "_verbs.py",
            "morph_rules.py",
            "stop_words.py",
            "syntax_iterators.py",
            "_nouns_exc.py",
            "tokenizer_exceptions.py",
            "_lemma_rules.py",
            "get_pos_from_wiktionary.py",
            "lex_attrs.py",
            "lemmatizer.py",
            "glossary.py",
            "render.py",
            "templates.py",
            "_dets_irreg.py"
          ]
        }
      },
      "212c8f071180c9ce134a74b85603e48c14199595": {
        "commit": {
          "commit_id": "212c8f071180c9ce134a74b85603e48c14199595",
          "commit_message": "Implement new Language methods and pipeline API",
          "commit_author": "ines",
          "commit_date": "2017-10-07 00:25:54",
          "commit_parent": "3468d535ad2ae0074683600c8b1dadaad89ca1cb"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds, verbose=False):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for pipe in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            for doc in docs:\n                pipe(doc)\n        else:\n            docs = list(pipe.pipe(docs))\n    assert len(docs) == len(golds)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        scorer.score(doc, gold, verbose=verbose)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for (name, pipe) in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            for doc in docs:\n                pipe(doc)\n        else:\n            docs = list(pipe.pipe(docs))\n    assert len(docs) == len(golds)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        scorer.score(doc, gold, verbose=verbose)\n    return scorer",
          "function_before_start_line": 391,
          "function_before_end_line": 407,
          "function_after_start_line": 424,
          "function_after_end_line": 440,
          "function_before_token_count": 118,
          "function_after_token_count": 120,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "tagger",
            "use_params",
            "from_bytes",
            "get_pipe",
            "tensorizer",
            "resume_training",
            "remove_pipe",
            "make_doc",
            "create_pipe",
            "create_tokenizer",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "to_bytes",
            "create_lemmatizer",
            "rename_pipe"
          ],
          "functions_name_all_files": [
            "create_vocab",
            "read_regex",
            "matcher",
            "pipe_names",
            "preprocess_gold",
            "get_lang_class",
            "load_model_from_package",
            "print_markdown",
            "get_async",
            "replace_pipe",
            "_pipe",
            "parser",
            "entity",
            "use_gpu",
            "from_disk",
            "add_lookups",
            "evaluate",
            "prints",
            "compounding",
            "minify_html",
            "tagger",
            "use_params",
            "expand_exc",
            "compile_infix_regex",
            "from_bytes",
            "decaying",
            "get_model_meta",
            "get_raw_input",
            "get_data_path",
            "get_pipe",
            "tensorizer",
            "get_package_path",
            "load_model_from_init_py",
            "resume_training",
            "set_lang_class",
            "load_model_from_link",
            "remove_pipe",
            "load_model_from_path",
            "make_doc",
            "set_data_path",
            "create_pipe",
            "normalize_slice",
            "create_tokenizer",
            "read_json",
            "itershuffle",
            "pipe",
            "meta",
            "compile_suffix_regex",
            "print_table",
            "to_disk",
            "__init__",
            "load_model",
            "update",
            "__call__",
            "add_pipe",
            "begin_training",
            "is_package",
            "compile_prefix_regex",
            "update_exc",
            "_wrap",
            "to_bytes",
            "set_env_log",
            "is_in_jupyter",
            "create_lemmatizer",
            "get_cuda_stream",
            "ensure_path",
            "env_opt",
            "rename_pipe"
          ],
          "functions_name_co_evolved_modified_file": [
            "pipe_names",
            "preprocess_gold",
            "matcher",
            "replace_pipe",
            "parser",
            "entity",
            "from_disk",
            "create_tagger",
            "tagger",
            "use_params",
            "from_bytes",
            "get_pipe",
            "tensorizer",
            "create_parser",
            "remove_pipe",
            "create_entity",
            "create_pipe",
            "get_component",
            "create_pipeline",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "begin_training",
            "add_pipe",
            "to_bytes",
            "rename_pipe"
          ],
          "functions_name_co_evolved_all_files": [
            "pipe_names",
            "preprocess_gold",
            "matcher",
            "replace_pipe",
            "parser",
            "entity",
            "from_disk",
            "create_tagger",
            "tagger",
            "use_params",
            "from_bytes",
            "get_pipe",
            "tensorizer",
            "create_parser",
            "remove_pipe",
            "load_model_from_path",
            "create_entity",
            "create_pipe",
            "get_component",
            "create_pipeline",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "begin_training",
            "add_pipe",
            "to_bytes",
            "rename_pipe"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 429,
          "file_complexity": 119,
          "file_token_count": 3274,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None, disable=tuple()):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in meta.get('pipeline', []):\n            if entry in disable or getattr(entry, 'name', entry) in disable:\n                continue\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'parser': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize],\n        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n        # Temporary compatibility -- delete after pivot\n        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'dependencies': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize,\n        ],\n        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n                 meta={}, disable=tuple(), **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self, disable)\n        elif pipeline:\n            # Careful not to do getattr(p, 'name', None) here\n            # If we had disable=[None], we'd disable everything!\n            self.pipeline = [p for p in pipeline\n                             if p not in disable\n                             and getattr(p, 'name', p) not in disable]\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n        flat_list = []\n        for pipe in self.pipeline:\n            if isinstance(pipe, list):\n                flat_list.extend(pipe)\n            else:\n                flat_list.append(pipe)\n        self.pipeline = flat_list\n        self._optimizer = None\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        pipeline = []\n        for component in self.pipeline:\n            if hasattr(component, 'name'):\n                pipeline.append(component.name)\n        self._meta['pipeline'] = pipeline\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_component('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_component('tagger')\n\n    @property\n    def parser(self):\n        return self.get_component('parser')\n\n    @property\n    def entity(self):\n        return self.get_component('ner')\n\n    @property\n    def matcher(self):\n        return self.get_component('matcher')\n\n    def get_component(self, name):\n        if self.pipeline in (True, None):\n            return None\n        for proc in self.pipeline:\n            if hasattr(proc, 'name') and proc.name.endswith(name):\n                return proc\n        return None\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = Adam(Model.ops, 0.001)\n            sgd = self._optimizer\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        for proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def resume_training(self, **cfg):\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def begin_training(self, get_gold_tuples=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        **cfg: Config parameters.\n        returns: An optimizer\n        \"\"\"\n        # Populate vocab\n        if get_gold_tuples is not None:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        link_vectors_to_models(self.vocab)\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def evaluate(self, docs_golds, verbose=False):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for pipe in self.pipeline:\n            if not hasattr(pipe, 'pipe'):\n                for doc in docs:\n                    pipe(doc)\n            else:\n                docs = list(pipe.pipe(docs))\n        assert len(docs) == len(golds)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            scorer.score(doc, gold, verbose=verbose)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, as_tuples=False, n_threads=2, batch_size=1000,\n            disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        serializers['vocab'] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    pipe_names = ['tensorizer', 'tagger', 'parser', 'ner']\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    factories = {\n        'tokenizer': lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n        'tensorizer': lambda nlp, **cfg: TokenVectorEncoder(nlp.vocab, **cfg),\n        'tagger': lambda nlp, **cfg: NeuralTagger(nlp.vocab, **cfg),\n        'parser': lambda nlp, **cfg: NeuralDependencyParser(nlp.vocab, **cfg),  # nonproj.deprojectivize,\n        'ner': lambda nlp, **cfg: NeuralEntityRecognizer(nlp.vocab, **cfg),\n        'similarity': lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n        'textcat': lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg)\n    }\n\n    def __init__(self, vocab=True, make_doc=True, meta={}, **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        self.pipeline = []\n        self._optimizer = None\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        self._meta['pipeline'] = self.pipe_names\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_pipe('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_pipe('tagger')\n\n    @property\n    def parser(self):\n        return self.get_pipe('parser')\n\n    @property\n    def entity(self):\n        return self.get_pipe('ner')\n\n    @property\n    def matcher(self):\n        return self.get_pipe('matcher')\n\n    @property\n    def pipe_names(self):\n        \"\"\"Get names of available pipeline components.\n\n        RETURNS (list): List of component name strings, in order.\n        \"\"\"\n        return [pipe_name for pipe_name, _ in self.pipeline]\n\n    def get_pipe(self, name):\n        \"\"\"Get a pipeline component for a given component name.\n\n        name (unicode): Name of pipeline component to get.\n        RETURNS (callable): The pipeline component.\n        \"\"\"\n        for pipe_name, component in self.pipeline:\n            if pipe_name == name:\n                return component\n        msg = \"No component '{}' found in pipeline. Available names: {}\"\n        raise KeyError(msg.format(name, self.pipe_names))\n\n    def create_pipe(self, name, config=dict()):\n        \"\"\"Create a pipeline component from a factory.\n\n        name (unicode): Factory name to look up in `Language.factories`.\n        RETURNS (callable): Pipeline component.\n        \"\"\"\n        if name not in self.factories:\n            raise KeyError(\"Can't find factory for '{}'.\".format(name))\n        factory = self.factories[name]\n        return factory(self, **config)\n\n    def add_pipe(self, component, name=None, before=None, after=None,\n                 first=None, last=None):\n        \"\"\"Add a component to the processing pipeline. Valid components are\n        callables that take a `Doc` object, modify it and return it. Only one of\n        before, after, first or last can be set. Default behaviour is \"last\".\n\n        component (callable): The pipeline component.\n        name (unicode): Name of pipeline component. Overwrites existing\n            component.name attribute if available. If no name is set and\n            the component exposes no name attribute, component.__name__ is\n            used. An error is raised if the name already exists in the pipeline.\n        before (unicode): Component name to insert component directly before.\n        after (unicode): Component name to insert component directly after.\n        first (bool): Insert component first / not first in the pipeline.\n        last (bool): Insert component last / not last in the pipeline.\n\n        EXAMPLE:\n            >>> nlp.add_pipe(component, before='ner')\n            >>> nlp.add_pipe(component, name='custom_name', last=True)\n        \"\"\"\n        if name is None:\n            name = getattr(component, 'name', component.__name__)\n        if name in self.pipe_names:\n            raise ValueError(\"'{}' already exists in pipeline.\".format(name))\n        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n            msg = (\"Invalid constraints. You can only set one of the \"\n                   \"following: before, after, first, last.\")\n            raise ValueError(msg)\n        pipe = (name, component)\n        if last or not any([first, before, after]):\n            self.pipeline.append(pipe)\n        elif first:\n            self.pipeline.insert(0, pipe)\n        elif before and before in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(before), pipe)\n        elif after and after in self.pipe_names:\n            self.pipeline.insert(self.pipe_names.index(after), pipe)\n        else:\n            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n            unfound = before or after\n            raise ValueError(msg.format(unfound, self.pipe_names))\n\n    def replace_pipe(self, name, component):\n        \"\"\"Replace a component in the pipeline.\n\n        name (unicode): Name of the component to replace.\n        component (callable): Pipeline component.\n        \"\"\"\n        if name not in self.pipe_names:\n            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n            raise ValueError(msg.format(name, self.pipe_names))\n        self.pipeline[self.pipe_names.index(name)] = (name, component)\n\n    def rename_pipe(self, old_name, new_name):\n        \"\"\"Rename a pipeline component.\n\n        old_name (unicode): Name of the component to rename.\n        new_name (unicode): New name of the component.\n        \"\"\"\n        if old_name not in self.pipe_names:\n            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n            raise ValueError(msg.format(old_name, self.pipe_names))\n        if new_name in self.pipe_names:\n            msg = \"'{}' already exists in pipeline. Existing names: {}\"\n            raise ValueError(msg.format(new_name, self.pipe_names))\n        i = self.pipe_names.index(old_name)\n        self.pipeline[i] = (new_name, self.pipeline[i][1])\n\n    def remove_pipe(self, name):\n        \"\"\"Remove a component from the pipeline.\n\n        name (unicode): Name of the component to remove.\n        RETURNS (tuple): A (name, component) tuple of the removed component.\n        \"\"\"\n        if name not in self.pipe_names:\n            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n            raise ValueError(msg.format(name, self.pipe_names))\n        return self.pipeline.pop(self.pipe_names.index(name))\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = Adam(Model.ops, 0.001)\n            sgd = self._optimizer\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        for name, proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for name, proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def resume_training(self, **cfg):\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def begin_training(self, get_gold_tuples=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        **cfg: Config parameters.\n        returns: An optimizer\n        \"\"\"\n        # Populate vocab\n        if get_gold_tuples is not None:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        link_vectors_to_models(self.vocab)\n        for name, proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def evaluate(self, docs_golds, verbose=False):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for name, pipe in self.pipeline:\n            if not hasattr(pipe, 'pipe'):\n                for doc in docs:\n                    pipe(doc)\n            else:\n                docs = list(pipe.pipe(docs))\n        assert len(docs) == len(golds)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            scorer.score(doc, gold, verbose=verbose)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for name, pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, as_tuples=False, n_threads=2, batch_size=1000,\n            disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for name, proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        serializers['vocab'] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for name, proc in self.pipeline:\n            if name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, (name, proc) in enumerate(self.pipeline):\n            if name in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, (name, proc) in enumerate(self.pipeline):\n            if name in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_patch": "@@ -70,59 +70,7 @@ class BaseDefaults(object):\n                          prefix_search=prefix_search, suffix_search=suffix_search,\n                          infix_finditer=infix_finditer, token_match=token_match)\n \n-    @classmethod\n-    def create_tagger(cls, nlp=None, **cfg):\n-        if nlp is None:\n-            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n-        else:\n-            return NeuralTagger(nlp.vocab, **cfg)\n-\n-    @classmethod\n-    def create_parser(cls, nlp=None, **cfg):\n-        if nlp is None:\n-            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n-        else:\n-            return NeuralDependencyParser(nlp.vocab, **cfg)\n-\n-    @classmethod\n-    def create_entity(cls, nlp=None, **cfg):\n-        if nlp is None:\n-            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n-        else:\n-            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n-\n-    @classmethod\n-    def create_pipeline(cls, nlp=None, disable=tuple()):\n-        meta = nlp.meta if nlp is not None else {}\n-        # Resolve strings, like \"cnn\", \"lstm\", etc\n-        pipeline = []\n-        for entry in meta.get('pipeline', []):\n-            if entry in disable or getattr(entry, 'name', entry) in disable:\n-                continue\n-            factory = cls.Defaults.factories[entry]\n-            pipeline.append(factory(nlp, **meta.get(entry, {})))\n-        return pipeline\n-\n-    factories = {\n-        'make_doc': create_tokenizer,\n-        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n-        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n-        'parser': lambda nlp, **cfg: [\n-            NeuralDependencyParser(nlp.vocab, **cfg),\n-            nonproj.deprojectivize],\n-        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n-        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n-        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n-        # Temporary compatibility -- delete after pivot\n-        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n-        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n-        'dependencies': lambda nlp, **cfg: [\n-            NeuralDependencyParser(nlp.vocab, **cfg),\n-            nonproj.deprojectivize,\n-        ],\n-        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n-    }\n-\n+    pipe_names = ['tensorizer', 'tagger', 'parser', 'ner']\n     token_match = TOKEN_MATCH\n     prefixes = tuple(TOKENIZER_PREFIXES)\n     suffixes = tuple(TOKENIZER_SUFFIXES)\n@@ -152,8 +100,17 @@ class Language(object):\n     Defaults = BaseDefaults\n     lang = None\n \n-    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n-                 meta={}, disable=tuple(), **kwargs):\n+    factories = {\n+        'tokenizer': lambda nlp: nlp.Defaults.create_tokenizer(nlp),\n+        'tensorizer': lambda nlp, **cfg: TokenVectorEncoder(nlp.vocab, **cfg),\n+        'tagger': lambda nlp, **cfg: NeuralTagger(nlp.vocab, **cfg),\n+        'parser': lambda nlp, **cfg: NeuralDependencyParser(nlp.vocab, **cfg),  # nonproj.deprojectivize,\n+        'ner': lambda nlp, **cfg: NeuralEntityRecognizer(nlp.vocab, **cfg),\n+        'similarity': lambda nlp, **cfg: SimilarityHook(nlp.vocab, **cfg),\n+        'textcat': lambda nlp, **cfg: TextCategorizer(nlp.vocab, **cfg)\n+    }\n+\n+    def __init__(self, vocab=True, make_doc=True, meta={}, **kwargs):\n         \"\"\"Initialise a Language object.\n \n         vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n@@ -179,28 +136,7 @@ class Language(object):\n             factory = self.Defaults.create_tokenizer\n             make_doc = factory(self, **meta.get('tokenizer', {}))\n         self.tokenizer = make_doc\n-        if pipeline is True:\n-            self.pipeline = self.Defaults.create_pipeline(self, disable)\n-        elif pipeline:\n-            # Careful not to do getattr(p, 'name', None) here\n-            # If we had disable=[None], we'd disable everything!\n-            self.pipeline = [p for p in pipeline\n-                             if p not in disable\n-                             and getattr(p, 'name', p) not in disable]\n-            # Resolve strings, like \"cnn\", \"lstm\", etc\n-            for i, entry in enumerate(self.pipeline):\n-                if entry in self.Defaults.factories:\n-                    factory = self.Defaults.factories[entry]\n-                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n-        else:\n-            self.pipeline = []\n-        flat_list = []\n-        for pipe in self.pipeline:\n-            if isinstance(pipe, list):\n-                flat_list.extend(pipe)\n-            else:\n-                flat_list.append(pipe)\n-        self.pipeline = flat_list\n+        self.pipeline = []\n         self._optimizer = None\n \n     @property\n@@ -214,11 +150,7 @@ class Language(object):\n         self._meta.setdefault('email', '')\n         self._meta.setdefault('url', '')\n         self._meta.setdefault('license', '')\n-        pipeline = []\n-        for component in self.pipeline:\n-            if hasattr(component, 'name'):\n-                pipeline.append(component.name)\n-        self._meta['pipeline'] = pipeline\n+        self._meta['pipeline'] = self.pipe_names\n         return self._meta\n \n     @meta.setter\n@@ -228,31 +160,133 @@ class Language(object):\n     # Conveniences to access pipeline components\n     @property\n     def tensorizer(self):\n-        return self.get_component('tensorizer')\n+        return self.get_pipe('tensorizer')\n \n     @property\n     def tagger(self):\n-        return self.get_component('tagger')\n+        return self.get_pipe('tagger')\n \n     @property\n     def parser(self):\n-        return self.get_component('parser')\n+        return self.get_pipe('parser')\n \n     @property\n     def entity(self):\n-        return self.get_component('ner')\n+        return self.get_pipe('ner')\n \n     @property\n     def matcher(self):\n-        return self.get_component('matcher')\n+        return self.get_pipe('matcher')\n+\n+    @property\n+    def pipe_names(self):\n+        \"\"\"Get names of available pipeline components.\n+\n+        RETURNS (list): List of component name strings, in order.\n+        \"\"\"\n+        return [pipe_name for pipe_name, _ in self.pipeline]\n+\n+    def get_pipe(self, name):\n+        \"\"\"Get a pipeline component for a given component name.\n+\n+        name (unicode): Name of pipeline component to get.\n+        RETURNS (callable): The pipeline component.\n+        \"\"\"\n+        for pipe_name, component in self.pipeline:\n+            if pipe_name == name:\n+                return component\n+        msg = \"No component '{}' found in pipeline. Available names: {}\"\n+        raise KeyError(msg.format(name, self.pipe_names))\n+\n+    def create_pipe(self, name, config=dict()):\n+        \"\"\"Create a pipeline component from a factory.\n+\n+        name (unicode): Factory name to look up in `Language.factories`.\n+        RETURNS (callable): Pipeline component.\n+        \"\"\"\n+        if name not in self.factories:\n+            raise KeyError(\"Can't find factory for '{}'.\".format(name))\n+        factory = self.factories[name]\n+        return factory(self, **config)\n+\n+    def add_pipe(self, component, name=None, before=None, after=None,\n+                 first=None, last=None):\n+        \"\"\"Add a component to the processing pipeline. Valid components are\n+        callables that take a `Doc` object, modify it and return it. Only one of\n+        before, after, first or last can be set. Default behaviour is \"last\".\n+\n+        component (callable): The pipeline component.\n+        name (unicode): Name of pipeline component. Overwrites existing\n+            component.name attribute if available. If no name is set and\n+            the component exposes no name attribute, component.__name__ is\n+            used. An error is raised if the name already exists in the pipeline.\n+        before (unicode): Component name to insert component directly before.\n+        after (unicode): Component name to insert component directly after.\n+        first (bool): Insert component first / not first in the pipeline.\n+        last (bool): Insert component last / not last in the pipeline.\n+\n+        EXAMPLE:\n+            >>> nlp.add_pipe(component, before='ner')\n+            >>> nlp.add_pipe(component, name='custom_name', last=True)\n+        \"\"\"\n+        if name is None:\n+            name = getattr(component, 'name', component.__name__)\n+        if name in self.pipe_names:\n+            raise ValueError(\"'{}' already exists in pipeline.\".format(name))\n+        if sum([bool(before), bool(after), bool(first), bool(last)]) >= 2:\n+            msg = (\"Invalid constraints. You can only set one of the \"\n+                   \"following: before, after, first, last.\")\n+            raise ValueError(msg)\n+        pipe = (name, component)\n+        if last or not any([first, before, after]):\n+            self.pipeline.append(pipe)\n+        elif first:\n+            self.pipeline.insert(0, pipe)\n+        elif before and before in self.pipe_names:\n+            self.pipeline.insert(self.pipe_names.index(before), pipe)\n+        elif after and after in self.pipe_names:\n+            self.pipeline.insert(self.pipe_names.index(after), pipe)\n+        else:\n+            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n+            unfound = before or after\n+            raise ValueError(msg.format(unfound, self.pipe_names))\n \n-    def get_component(self, name):\n-        if self.pipeline in (True, None):\n-            return None\n-        for proc in self.pipeline:\n-            if hasattr(proc, 'name') and proc.name.endswith(name):\n-                return proc\n-        return None\n+    def replace_pipe(self, name, component):\n+        \"\"\"Replace a component in the pipeline.\n+\n+        name (unicode): Name of the component to replace.\n+        component (callable): Pipeline component.\n+        \"\"\"\n+        if name not in self.pipe_names:\n+            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n+            raise ValueError(msg.format(name, self.pipe_names))\n+        self.pipeline[self.pipe_names.index(name)] = (name, component)\n+\n+    def rename_pipe(self, old_name, new_name):\n+        \"\"\"Rename a pipeline component.\n+\n+        old_name (unicode): Name of the component to rename.\n+        new_name (unicode): New name of the component.\n+        \"\"\"\n+        if old_name not in self.pipe_names:\n+            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n+            raise ValueError(msg.format(old_name, self.pipe_names))\n+        if new_name in self.pipe_names:\n+            msg = \"'{}' already exists in pipeline. Existing names: {}\"\n+            raise ValueError(msg.format(new_name, self.pipe_names))\n+        i = self.pipe_names.index(old_name)\n+        self.pipeline[i] = (new_name, self.pipeline[i][1])\n+\n+    def remove_pipe(self, name):\n+        \"\"\"Remove a component from the pipeline.\n+\n+        name (unicode): Name of the component to remove.\n+        RETURNS (tuple): A (name, component) tuple of the removed component.\n+        \"\"\"\n+        if name not in self.pipe_names:\n+            msg = \"Can't find '{}' in pipeline. Available names: {}\"\n+            raise ValueError(msg.format(name, self.pipe_names))\n+        return self.pipeline.pop(self.pipe_names.index(name))\n \n     def __call__(self, text, disable=[]):\n         \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n@@ -269,8 +303,7 @@ class Language(object):\n             ('An', 'NN')\n         \"\"\"\n         doc = self.make_doc(text)\n-        for proc in self.pipeline:\n-            name = getattr(proc, 'name', None)\n+        for name, proc in self.pipeline:\n             if name in disable:\n                 continue\n             doc = proc(doc)\n@@ -308,7 +341,7 @@ class Language(object):\n             grads[key] = (W, dW)\n         pipes = list(self.pipeline)\n         random.shuffle(pipes)\n-        for proc in pipes:\n+        for name, proc in pipes:\n             if not hasattr(proc, 'update'):\n                 continue\n             proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n@@ -322,7 +355,7 @@ class Language(object):\n         docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n         YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n         \"\"\"\n-        for proc in self.pipeline:\n+        for name, proc in self.pipeline:\n             if hasattr(proc, 'preprocess_gold'):\n                 docs_golds = proc.preprocess_gold(docs_golds)\n         for doc, gold in docs_golds:\n@@ -371,7 +404,7 @@ class Language(object):\n         else:\n             device = None\n         link_vectors_to_models(self.vocab)\n-        for proc in self.pipeline:\n+        for name, proc in self.pipeline:\n             if hasattr(proc, 'begin_training'):\n                 context = proc.begin_training(get_gold_tuples(),\n                                               pipeline=self.pipeline)\n@@ -393,7 +426,7 @@ class Language(object):\n         docs, golds = zip(*docs_golds)\n         docs = list(docs)\n         golds = list(golds)\n-        for pipe in self.pipeline:\n+        for name, pipe in self.pipeline:\n             if not hasattr(pipe, 'pipe'):\n                 for doc in docs:\n                     pipe(doc)\n@@ -419,7 +452,7 @@ class Language(object):\n             >>> with nlp.use_params(optimizer.averages):\n             >>>     nlp.to_disk('/tmp/checkpoint')\n         \"\"\"\n-        contexts = [pipe.use_params(params) for pipe\n+        contexts = [pipe.use_params(params) for name, pipe\n                     in self.pipeline if hasattr(pipe, 'use_params')]\n         # TODO: Having trouble with contextlib\n         # Workaround: these aren't actually context managers atm.\n@@ -466,8 +499,7 @@ class Language(object):\n                 yield (doc, context)\n             return\n         docs = (self.make_doc(text) for text in texts)\n-        for proc in self.pipeline:\n-            name = getattr(proc, 'name', None)\n+        for name, proc in self.pipeline:\n             if name in disable:\n                 continue\n             if hasattr(proc, 'pipe'):\n@@ -495,14 +527,14 @@ class Language(object):\n             ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n             ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n         ))\n-        for proc in self.pipeline:\n+        for name, proc in self.pipeline:\n             if not hasattr(proc, 'name'):\n                 continue\n-            if proc.name in disable:\n+            if name in disable:\n                 continue\n             if not hasattr(proc, 'to_disk'):\n                 continue\n-            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n+            serializers[name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n         serializers['vocab'] = lambda p: self.vocab.to_disk(p)\n         util.to_disk(path, serializers, {p: False for p in disable})\n \n@@ -526,14 +558,12 @@ class Language(object):\n             ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n             ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n         ))\n-        for proc in self.pipeline:\n-            if not hasattr(proc, 'name'):\n-                continue\n-            if proc.name in disable:\n+        for name, proc in self.pipeline:\n+            if name in disable:\n                 continue\n             if not hasattr(proc, 'to_disk'):\n                 continue\n-            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n+            deserializers[name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n         exclude = {p: False for p in disable}\n         if not (path / 'vocab').exists():\n             exclude['vocab'] = True\n@@ -552,8 +582,8 @@ class Language(object):\n             ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n             ('meta', lambda: ujson.dumps(self.meta))\n         ))\n-        for i, proc in enumerate(self.pipeline):\n-            if getattr(proc, 'name', None) in disable:\n+        for i, (name, proc) in enumerate(self.pipeline):\n+            if name in disable:\n                 continue\n             if not hasattr(proc, 'to_bytes'):\n                 continue\n@@ -572,8 +602,8 @@ class Language(object):\n             ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n             ('meta', lambda b: self.meta.update(ujson.loads(b)))\n         ))\n-        for i, proc in enumerate(self.pipeline):\n-            if getattr(proc, 'name', None) in disable:\n+        for i, (name, proc) in enumerate(self.pipeline):\n+            if name in disable:\n                 continue\n             if not hasattr(proc, 'from_bytes'):\n                 continue\n",
          "files_name_in_blame_commit": [
            "language.py",
            "util.py"
          ]
        }
      },
      "96da86b3e5d3a515f0f8db57ef1704750233ff38": {
        "commit": {
          "commit_id": "96da86b3e5d3a515f0f8db57ef1704750233ff38",
          "commit_message": "Add support for verbose flag to Language",
          "commit_author": "Matthew Honnibal",
          "commit_date": "2017-10-03 09:14:57",
          "commit_parent": "02586a52431865a165439098bff8482cae96397a"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for pipe in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            for doc in docs:\n                pipe(doc)\n        else:\n            docs = list(pipe.pipe(docs))\n    assert len(docs) == len(golds)\n    for (doc, gold) in zip(docs, golds):\n        scorer.score(doc, gold)\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds, verbose=False):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for pipe in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            for doc in docs:\n                pipe(doc)\n        else:\n            docs = list(pipe.pipe(docs))\n    assert len(docs) == len(golds)\n    for (doc, gold) in zip(docs, golds):\n        if verbose:\n            print(doc)\n        scorer.score(doc, gold, verbose=verbose)\n    return scorer",
          "function_before_start_line": 391,
          "function_before_end_line": 405,
          "function_after_start_line": 391,
          "function_after_end_line": 407,
          "function_before_token_count": 103,
          "function_after_token_count": 118,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "preprocess_gold",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "create_tagger",
            "tagger",
            "use_params",
            "from_bytes",
            "tensorizer",
            "resume_training",
            "create_parser",
            "create_entity",
            "make_doc",
            "create_tokenizer",
            "get_component",
            "create_pipeline",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "begin_training",
            "to_bytes",
            "create_lemmatizer"
          ],
          "functions_name_all_files": [
            "create_vocab",
            "matcher",
            "preprocess_gold",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "create_tagger",
            "tagger",
            "use_params",
            "from_bytes",
            "tensorizer",
            "resume_training",
            "create_parser",
            "create_entity",
            "make_doc",
            "create_tokenizer",
            "get_component",
            "create_pipeline",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "begin_training",
            "to_bytes",
            "create_lemmatizer"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 454,
          "file_complexity": 121,
          "file_token_count": 3312,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None, disable=tuple()):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in meta.get('pipeline', []):\n            if entry in disable or getattr(entry, 'name', entry) in disable:\n                continue\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'parser': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize],\n        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n        # Temporary compatibility -- delete after pivot\n        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'dependencies': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize,\n        ],\n        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n                 meta={}, disable=tuple(), **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self, disable)\n        elif pipeline:\n            # Careful not to do getattr(p, 'name', None) here\n            # If we had disable=[None], we'd disable everything!\n            self.pipeline = [p for p in pipeline\n                             if p not in disable\n                             and getattr(p, 'name', p) not in disable]\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n        flat_list = []\n        for pipe in self.pipeline:\n            if isinstance(pipe, list):\n                flat_list.extend(pipe)\n            else:\n                flat_list.append(pipe)\n        self.pipeline = flat_list\n        self._optimizer = None\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        pipeline = []\n        for component in self.pipeline:\n            if hasattr(component, 'name'):\n                pipeline.append(component.name)\n        self._meta['pipeline'] = pipeline\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_component('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_component('tagger')\n\n    @property\n    def parser(self):\n        return self.get_component('parser')\n\n    @property\n    def entity(self):\n        return self.get_component('ner')\n\n    @property\n    def matcher(self):\n        return self.get_component('matcher')\n\n    def get_component(self, name):\n        if self.pipeline in (True, None):\n            return None\n        for proc in self.pipeline:\n            if hasattr(proc, 'name') and proc.name.endswith(name):\n                return proc\n        return None\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = Adam(Model.ops, 0.001)\n            sgd = self._optimizer\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        for proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def resume_training(self, **cfg):\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def begin_training(self, get_gold_tuples=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        **cfg: Config parameters.\n        returns: An optimizer\n        \"\"\"\n        # Populate vocab\n        if get_gold_tuples is not None:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        link_vectors_to_models(self.vocab)\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def evaluate(self, docs_golds):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for pipe in self.pipeline:\n            if not hasattr(pipe, 'pipe'):\n                for doc in docs:\n                    pipe(doc)\n            else:\n                docs = list(pipe.pipe(docs))\n        assert len(docs) == len(golds)\n        for doc, gold in zip(docs, golds):\n            scorer.score(doc, gold)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, as_tuples=False, n_threads=2, batch_size=1000,\n            disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        serializers['vocab'] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\nfrom ._ml import link_vectors_to_models\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None, disable=tuple()):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in meta.get('pipeline', []):\n            if entry in disable or getattr(entry, 'name', entry) in disable:\n                continue\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'parser': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize],\n        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n        # Temporary compatibility -- delete after pivot\n        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'dependencies': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize,\n        ],\n        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n                 meta={}, disable=tuple(), **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self, disable)\n        elif pipeline:\n            # Careful not to do getattr(p, 'name', None) here\n            # If we had disable=[None], we'd disable everything!\n            self.pipeline = [p for p in pipeline\n                             if p not in disable\n                             and getattr(p, 'name', p) not in disable]\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n        flat_list = []\n        for pipe in self.pipeline:\n            if isinstance(pipe, list):\n                flat_list.extend(pipe)\n            else:\n                flat_list.append(pipe)\n        self.pipeline = flat_list\n        self._optimizer = None\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        pipeline = []\n        for component in self.pipeline:\n            if hasattr(component, 'name'):\n                pipeline.append(component.name)\n        self._meta['pipeline'] = pipeline\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_component('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_component('tagger')\n\n    @property\n    def parser(self):\n        return self.get_component('parser')\n\n    @property\n    def entity(self):\n        return self.get_component('ner')\n\n    @property\n    def matcher(self):\n        return self.get_component('matcher')\n\n    def get_component(self, name):\n        if self.pipeline in (True, None):\n            return None\n        for proc in self.pipeline:\n            if hasattr(proc, 'name') and proc.name.endswith(name):\n                return proc\n        return None\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        if sgd is None:\n            if self._optimizer is None:\n                self._optimizer = Adam(Model.ops, 0.001)\n            sgd = self._optimizer\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline)\n        random.shuffle(pipes)\n        for proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            proc.update(docs, golds, drop=drop, sgd=get_grads, losses=losses)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def resume_training(self, **cfg):\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def begin_training(self, get_gold_tuples=None, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        get_gold_tuples (function): Function returning gold data\n        **cfg: Config parameters.\n        returns: An optimizer\n        \"\"\"\n        # Populate vocab\n        if get_gold_tuples is not None:\n            for _, annots_brackets in get_gold_tuples():\n                for annots, _ in annots_brackets:\n                    for word in annots[1]:\n                        _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            device = util.use_gpu(cfg['device'])\n            if self.vocab.vectors.data.shape[1] >= 1:\n                self.vocab.vectors.data = Model.ops.asarray(\n                    self.vocab.vectors.data)\n        else:\n            device = None\n        link_vectors_to_models(self.vocab)\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        self._optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                              beta2=beta2, eps=eps)\n        self._optimizer.max_grad_norm = max_grad_norm\n        self._optimizer.device = device\n        return self._optimizer\n\n    def evaluate(self, docs_golds, verbose=False):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for pipe in self.pipeline:\n            if not hasattr(pipe, 'pipe'):\n                for doc in docs:\n                    pipe(doc)\n            else:\n                docs = list(pipe.pipe(docs))\n        assert len(docs) == len(golds)\n        for doc, gold in zip(docs, golds):\n            if verbose:\n                print(doc)\n            scorer.score(doc, gold, verbose=verbose)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, as_tuples=False, n_threads=2, batch_size=1000,\n            disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        as_tuples (bool):\n            If set to True, inputs should be a sequence of\n            (text, context) tuples. Output will then be a sequence of\n            (doc, context) tuples. Defaults to False.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if as_tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        serializers['vocab'] = lambda p: self.vocab.to_disk(p)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_patch": "@@ -388,7 +388,7 @@ class Language(object):\n         self._optimizer.device = device\n         return self._optimizer\n \n-    def evaluate(self, docs_golds):\n+    def evaluate(self, docs_golds, verbose=False):\n         scorer = Scorer()\n         docs, golds = zip(*docs_golds)\n         docs = list(docs)\n@@ -401,7 +401,9 @@ class Language(object):\n                 docs = list(pipe.pipe(docs))\n         assert len(docs) == len(golds)\n         for doc, gold in zip(docs, golds):\n-            scorer.score(doc, gold)\n+            if verbose:\n+                print(doc)\n+            scorer.score(doc, gold, verbose=verbose)\n         return scorer\n \n     @contextmanager\n",
          "files_name_in_blame_commit": [
            "language.py"
          ]
        }
      },
      "11c31d285ce0bc7d64099f29e0d5c4cd26ce7e99": {
        "commit": {
          "commit_id": "11c31d285ce0bc7d64099f29e0d5c4cd26ce7e99",
          "commit_message": "Restore changes from nn-beam-parser",
          "commit_author": "Matthew Honnibal",
          "commit_date": "2017-08-18 22:26:12",
          "commit_parent": "ce321b03225149aaa0d847e9ac4e00fac96ec801"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds):\n    (docs, golds) = zip(*docs_golds)\n    scorer = Scorer()\n    for (doc, gold) in zip(self.pipe(docs, batch_size=32), golds):\n        scorer.score(doc, gold)\n        doc.tensor = None\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for pipe in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            for doc in docs:\n                pipe(doc)\n        else:\n            docs = list(pipe.pipe(docs))\n    assert len(docs) == len(golds)\n    for (doc, gold) in zip(docs, golds):\n        scorer.score(doc, gold)\n        doc.tensor = None\n    return scorer",
          "function_before_start_line": 383,
          "function_before_end_line": 389,
          "function_after_start_line": 387,
          "function_after_end_line": 402,
          "function_before_token_count": 57,
          "function_after_token_count": 108,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "preprocess_gold",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "create_tagger",
            "tagger",
            "use_params",
            "from_bytes",
            "tensorizer",
            "create_parser",
            "create_entity",
            "make_doc",
            "create_tokenizer",
            "get_component",
            "create_pipeline",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "begin_training",
            "to_bytes",
            "create_lemmatizer"
          ],
          "functions_name_all_files": [
            "convert",
            "create_vocab",
            "matcher",
            "preprocess_gold",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "create_tagger",
            "tagger",
            "use_params",
            "from_bytes",
            "print_results",
            "tensorizer",
            "_render_parses",
            "print_progress",
            "create_parser",
            "create_entity",
            "make_doc",
            "create_tokenizer",
            "get_component",
            "create_pipeline",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "train",
            "begin_training",
            "to_bytes",
            "create_lemmatizer"
          ],
          "functions_name_co_evolved_modified_file": [
            "update"
          ],
          "functions_name_co_evolved_all_files": [
            "convert",
            "update",
            "train"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 440,
          "file_complexity": 119,
          "file_token_count": 3155,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None, disable=tuple()):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in cls.pipeline:\n            if entry in disable or getattr(entry, 'name', entry) in disable:\n                continue\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'parser': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize],\n        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n        # Temporary compatibility -- delete after pivot\n        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'dependencies': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize,\n        ],\n        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n                 meta={}, disable=tuple(), **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self, disable)\n        elif pipeline:\n            # Careful not to do getattr(p, 'name', None) here\n            # If we had disable=[None], we'd disable everything!\n            self.pipeline = [p for p in pipeline\n                             if p not in disable\n                             and getattr(p, 'name', p) not in disable]\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n        flat_list = []\n        for pipe in self.pipeline:\n            if isinstance(pipe, list):\n                flat_list.extend(pipe)\n            else:\n                flat_list.append(pipe)\n        self.pipeline = flat_list\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        pipeline = []\n        for component in self.pipeline:\n            if hasattr(component, 'name'):\n                pipeline.append(component.name)\n        self._meta['pipeline'] = pipeline\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_component('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_component('tagger')\n\n    @property\n    def parser(self):\n        return self.get_component('parser')\n\n    @property\n    def entity(self):\n        return self.get_component('ner')\n\n    @property\n    def matcher(self):\n        return self.get_component('matcher')\n\n    def get_component(self, name): \n        if self.pipeline in (True, None):\n            return None\n        for proc in self.pipeline:\n            if hasattr(proc, 'name') and proc.name.endswith(name):\n                return proc\n        return None\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        tok2vec = self.pipeline[0]\n        feats = tok2vec.doc2feats(docs)\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline[1:])\n        random.shuffle(pipes)\n        for proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n            d_tokvecses = proc.update((docs, tokvecses), golds,\n                                      drop=drop, sgd=get_grads, losses=losses)\n            if d_tokvecses is not None:\n                bp_tokvecses(d_tokvecses, sgd=sgd)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n        # Clear the tensor variable, to free GPU memory.\n        # If we don't do this, the memory leak gets pretty\n        # bad, because we may be holding part of a batch.\n        for doc in docs:\n            doc.tensor = None\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        gold_tuples (iterable): Gold-standard training data.\n        **cfg: Config parameters.\n        YIELDS (tuple): A trainer and an optimizer.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if self.parser:\n            self.pipeline.append(NeuralLabeller(self.vocab))\n        # Populate vocab\n        for _, annots_brackets in get_gold_tuples():\n            for annots, _ in annots_brackets:\n                for word in annots[1]:\n                    _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            import cupy.cuda.device\n            device = cupy.cuda.device.Device(cfg['device'])\n            device.use()\n            Model.ops = CupyOps()\n            Model.Ops = CupyOps\n        else:\n            device = None\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                         beta2=beta2, eps=eps)\n        optimizer.max_grad_norm = max_grad_norm\n        optimizer.device = device\n        return optimizer\n\n    def evaluate(self, docs_golds):\n        docs, golds = zip(*docs_golds)\n        scorer = Scorer()\n        for doc, gold in zip(self.pipe(docs, batch_size=32), golds):\n            scorer.score(doc, gold)\n            doc.tensor = None\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, tuples=False, n_threads=2, batch_size=1000, disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.to_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None, disable=tuple()):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in cls.pipeline:\n            if entry in disable or getattr(entry, 'name', entry) in disable:\n                continue\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'parser': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize],\n        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n        # Temporary compatibility -- delete after pivot\n        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'dependencies': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize,\n        ],\n        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n                 meta={}, disable=tuple(), **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self, disable)\n        elif pipeline:\n            # Careful not to do getattr(p, 'name', None) here\n            # If we had disable=[None], we'd disable everything!\n            self.pipeline = [p for p in pipeline\n                             if p not in disable\n                             and getattr(p, 'name', p) not in disable]\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n        flat_list = []\n        for pipe in self.pipeline:\n            if isinstance(pipe, list):\n                flat_list.extend(pipe)\n            else:\n                flat_list.append(pipe)\n        self.pipeline = flat_list\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        pipeline = []\n        for component in self.pipeline:\n            if hasattr(component, 'name'):\n                pipeline.append(component.name)\n        self._meta['pipeline'] = pipeline\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_component('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_component('tagger')\n\n    @property\n    def parser(self):\n        return self.get_component('parser')\n\n    @property\n    def entity(self):\n        return self.get_component('ner')\n\n    @property\n    def matcher(self):\n        return self.get_component('matcher')\n\n    def get_component(self, name): \n        if self.pipeline in (True, None):\n            return None\n        for proc in self.pipeline:\n            if hasattr(proc, 'name') and proc.name.endswith(name):\n                return proc\n        return None\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None,\n            update_tensors=False):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        tok2vec = self.pipeline[0]\n        feats = tok2vec.doc2feats(docs)\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline[1:])\n        random.shuffle(pipes)\n        tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n        all_d_tokvecses = [tok2vec.model.ops.allocate(tv.shape) for tv in tokvecses]\n        for proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            d_tokvecses = proc.update((docs, tokvecses), golds,\n                                      drop=drop, sgd=get_grads, losses=losses)\n            if update_tensors and d_tokvecses is not None:\n                for i, d_tv in enumerate(d_tokvecses):\n                    all_d_tokvecses[i] += d_tv\n        bp_tokvecses(all_d_tokvecses, sgd=sgd)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n        # Clear the tensor variable, to free GPU memory.\n        # If we don't do this, the memory leak gets pretty\n        # bad, because we may be holding part of a batch.\n        for doc in docs:\n            doc.tensor = None\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        gold_tuples (iterable): Gold-standard training data.\n        **cfg: Config parameters.\n        YIELDS (tuple): A trainer and an optimizer.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if self.parser:\n            self.pipeline.append(NeuralLabeller(self.vocab))\n        # Populate vocab\n        for _, annots_brackets in get_gold_tuples():\n            for annots, _ in annots_brackets:\n                for word in annots[1]:\n                    _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            import cupy.cuda.device\n            device = cupy.cuda.device.Device(cfg['device'])\n            device.use()\n            Model.ops = CupyOps()\n            Model.Ops = CupyOps\n        else:\n            device = None\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                         beta2=beta2, eps=eps)\n        optimizer.max_grad_norm = max_grad_norm\n        optimizer.device = device\n        return optimizer\n\n    def evaluate(self, docs_golds):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for pipe in self.pipeline:\n            if not hasattr(pipe, 'pipe'):\n                for doc in docs:\n                    pipe(doc)\n            else:\n                docs = list(pipe.pipe(docs))\n        assert len(docs) == len(golds)\n        for doc, gold in zip(docs, golds):\n            scorer.score(doc, gold)\n            doc.tensor = None\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, tuples=False, n_threads=2, batch_size=1000, disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.to_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_patch": "@@ -277,7 +277,8 @@ class Language(object):\n     def make_doc(self, text):\n         return self.tokenizer(text)\n \n-    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n+    def update(self, docs, golds, drop=0., sgd=None, losses=None,\n+            update_tensors=False):\n         \"\"\"Update the models in the pipeline.\n \n         docs (iterable): A batch of `Doc` objects.\n@@ -304,14 +305,17 @@ class Language(object):\n             grads[key] = (W, dW)\n         pipes = list(self.pipeline[1:])\n         random.shuffle(pipes)\n+        tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n+        all_d_tokvecses = [tok2vec.model.ops.allocate(tv.shape) for tv in tokvecses]\n         for proc in pipes:\n             if not hasattr(proc, 'update'):\n                 continue\n-            tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n             d_tokvecses = proc.update((docs, tokvecses), golds,\n                                       drop=drop, sgd=get_grads, losses=losses)\n-            if d_tokvecses is not None:\n-                bp_tokvecses(d_tokvecses, sgd=sgd)\n+            if update_tensors and d_tokvecses is not None:\n+                for i, d_tv in enumerate(d_tokvecses):\n+                    all_d_tokvecses[i] += d_tv\n+        bp_tokvecses(all_d_tokvecses, sgd=sgd)\n         for key, (W, dW) in grads.items():\n             sgd(W, dW, key=key)\n         # Clear the tensor variable, to free GPU memory.\n@@ -381,9 +385,18 @@ class Language(object):\n         return optimizer\n \n     def evaluate(self, docs_golds):\n-        docs, golds = zip(*docs_golds)\n         scorer = Scorer()\n-        for doc, gold in zip(self.pipe(docs, batch_size=32), golds):\n+        docs, golds = zip(*docs_golds)\n+        docs = list(docs)\n+        golds = list(golds)\n+        for pipe in self.pipeline:\n+            if not hasattr(pipe, 'pipe'):\n+                for doc in docs:\n+                    pipe(doc)\n+            else:\n+                docs = list(pipe.pipe(docs))\n+        assert len(docs) == len(golds)\n+        for doc, gold in zip(docs, golds):\n             scorer.score(doc, gold)\n             doc.tensor = None\n         return scorer\n",
          "files_name_in_blame_commit": [
            "language.py",
            "convert.py",
            "train.py"
          ]
        }
      },
      "52c180ecf5474e62f305424065d645d14fc43b7b": {
        "commit": {
          "commit_id": "52c180ecf5474e62f305424065d645d14fc43b7b",
          "commit_message": "Revert \"Merge branch 'develop' of https://github.com/explosion/spaCy into develop\"\n\nThis reverts commit ea8de11ad57199e5abc3db3e7a8ecc920ef356fd, reversing\nchanges made to 08e443e083c5300433bca99ac11c7719d1dd07b5.",
          "commit_author": "Matthew Honnibal",
          "commit_date": "2017-08-14 13:00:23",
          "commit_parent": "ea8de11ad57199e5abc3db3e7a8ecc920ef356fd"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "def evaluate(self, docs_golds):\n    scorer = Scorer()\n    (docs, golds) = zip(*docs_golds)\n    docs = list(docs)\n    golds = list(golds)\n    for pipe in self.pipeline:\n        if not hasattr(pipe, 'pipe'):\n            for doc in docs:\n                pipe(doc)\n        else:\n            docs = list(pipe.pipe(docs))\n    assert len(docs) == len(golds)\n    for (doc, gold) in zip(docs, golds):\n        scorer.score(doc, gold)\n        doc.tensor = None\n    return scorer",
          "function_code_after": "def evaluate(self, docs_golds):\n    (docs, golds) = zip(*docs_golds)\n    scorer = Scorer()\n    for (doc, gold) in zip(self.pipe(docs, batch_size=32), golds):\n        scorer.score(doc, gold)\n        doc.tensor = None\n    return scorer",
          "function_before_start_line": 387,
          "function_before_end_line": 402,
          "function_after_start_line": 383,
          "function_after_end_line": 389,
          "function_before_token_count": 108,
          "function_after_token_count": 57,
          "functions_name_modified_file": [
            "create_vocab",
            "matcher",
            "preprocess_gold",
            "_pipe",
            "parser",
            "entity",
            "from_disk",
            "evaluate",
            "create_tagger",
            "tagger",
            "use_params",
            "from_bytes",
            "tensorizer",
            "create_parser",
            "create_entity",
            "make_doc",
            "create_tokenizer",
            "get_component",
            "create_pipeline",
            "pipe",
            "meta",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "begin_training",
            "to_bytes",
            "create_lemmatizer"
          ],
          "functions_name_all_files": [
            "convert",
            "doc",
            "create_vocab",
            "test_can_init_nn_parser",
            "chdir",
            "matcher",
            "preprocess_gold",
            "logistic",
            "_pipe",
            "tok2vec",
            "parser",
            "entity",
            "begin_update",
            "from_disk",
            "evaluate",
            "create_tagger",
            "test_predict_doc",
            "vocab",
            "test_predict_doc_beam",
            "asarray",
            "tagger",
            "use_params",
            "model",
            "_preprocess_doc",
            "from_bytes",
            "Tok2Vec",
            "flatten",
            "build_options",
            "_divide_array",
            "print_results",
            "preprocess_doc",
            "print_shape",
            "_init_for_precomputed",
            "tensorizer",
            "_render_parses",
            "setup_package",
            "build_extensions",
            "_zero_init",
            "_logistic",
            "get_col",
            "print_progress",
            "is_source_release",
            "test_update_doc",
            "create_parser",
            "create_entity",
            "rebatch",
            "make_doc",
            "create_tokenizer",
            "arc_eager",
            "clean",
            "create_pipeline",
            "get_component",
            "meta",
            "pipe",
            "test_build_model",
            "to_disk",
            "__init__",
            "gold",
            "update",
            "zero_init",
            "__call__",
            "train",
            "begin_training",
            "get_token_vectors",
            "generate_cython",
            "doc2feats",
            "foreach",
            "to_bytes",
            "build_text_classifier",
            "_flatten_add_lengths",
            "create_lemmatizer"
          ],
          "functions_name_co_evolved_modified_file": [
            "update"
          ],
          "functions_name_co_evolved_all_files": [
            "beam",
            "build_tagger_model",
            "convert",
            "scores",
            "test_update_doc_beam",
            "add_tuples",
            "docs",
            "moves",
            "golds",
            "getitem",
            "vocab",
            "test_create_beam",
            "Tok2Vec",
            "drop_layer",
            "states",
            "test_beam_advance",
            "test_beam_advance_too_few_scores",
            "tokvecs",
            "beam_width",
            "update",
            "fine_tune",
            "train",
            "doc2feats",
            "build_text_classifier",
            "batch_size",
            "vector_size"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 427,
          "file_complexity": 113,
          "file_token_count": 3062,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None, disable=tuple()):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in cls.pipeline:\n            if entry in disable or getattr(entry, 'name', entry) in disable:\n                continue\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'parser': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize],\n        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n        # Temporary compatibility -- delete after pivot\n        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'dependencies': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize,\n        ],\n        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n                 meta={}, disable=tuple(), **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self, disable)\n        elif pipeline:\n            # Careful not to do getattr(p, 'name', None) here\n            # If we had disable=[None], we'd disable everything!\n            self.pipeline = [p for p in pipeline\n                             if p not in disable\n                             and getattr(p, 'name', p) not in disable]\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n        flat_list = []\n        for pipe in self.pipeline:\n            if isinstance(pipe, list):\n                flat_list.extend(pipe)\n            else:\n                flat_list.append(pipe)\n        self.pipeline = flat_list\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        pipeline = []\n        for component in self.pipeline:\n            if hasattr(component, 'name'):\n                pipeline.append(component.name)\n        self._meta['pipeline'] = pipeline\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_component('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_component('tagger')\n\n    @property\n    def parser(self):\n        return self.get_component('parser')\n\n    @property\n    def entity(self):\n        return self.get_component('ner')\n\n    @property\n    def matcher(self):\n        return self.get_component('matcher')\n\n    def get_component(self, name): \n        if self.pipeline in (True, None):\n            return None\n        for proc in self.pipeline:\n            if hasattr(proc, 'name') and proc.name.endswith(name):\n                return proc\n        return None\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None,\n            update_tensors=False):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        tok2vec = self.pipeline[0]\n        feats = tok2vec.doc2feats(docs)\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline[1:])\n        random.shuffle(pipes)\n        tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n        all_d_tokvecses = [tok2vec.model.ops.allocate(tv.shape) for tv in tokvecses]\n        for proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            d_tokvecses = proc.update((docs, tokvecses), golds,\n                                      drop=drop, sgd=get_grads, losses=losses)\n            if update_tensors and d_tokvecses is not None:\n                for i, d_tv in enumerate(d_tokvecses):\n                    all_d_tokvecses[i] += d_tv\n        bp_tokvecses(all_d_tokvecses, sgd=sgd)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n        # Clear the tensor variable, to free GPU memory.\n        # If we don't do this, the memory leak gets pretty\n        # bad, because we may be holding part of a batch.\n        for doc in docs:\n            doc.tensor = None\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        gold_tuples (iterable): Gold-standard training data.\n        **cfg: Config parameters.\n        YIELDS (tuple): A trainer and an optimizer.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if self.parser:\n            self.pipeline.append(NeuralLabeller(self.vocab))\n        # Populate vocab\n        for _, annots_brackets in get_gold_tuples():\n            for annots, _ in annots_brackets:\n                for word in annots[1]:\n                    _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            import cupy.cuda.device\n            device = cupy.cuda.device.Device(cfg['device'])\n            device.use()\n            Model.ops = CupyOps()\n            Model.Ops = CupyOps\n        else:\n            device = None\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                         beta2=beta2, eps=eps)\n        optimizer.max_grad_norm = max_grad_norm\n        optimizer.device = device\n        return optimizer\n\n    def evaluate(self, docs_golds):\n        scorer = Scorer()\n        docs, golds = zip(*docs_golds)\n        docs = list(docs)\n        golds = list(golds)\n        for pipe in self.pipeline:\n            if not hasattr(pipe, 'pipe'):\n                for doc in docs:\n                    pipe(doc)\n            else:\n                docs = list(pipe.pipe(docs))\n        assert len(docs) == len(golds)\n        for doc, gold in zip(docs, golds):\n            scorer.score(doc, gold)\n            doc.tensor = None\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, tuples=False, n_threads=2, batch_size=1000, disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.to_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam, SGD\nimport random\nimport ujson\nfrom collections import OrderedDict\nimport itertools\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax import nonproj\n\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .pipeline import NeuralLabeller\nfrom .pipeline import SimilarityHook\nfrom .pipeline import TextCategorizer\nfrom . import about\n\nfrom .compat import json_dumps, izip\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None, disable=tuple()):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in cls.pipeline:\n            if entry in disable or getattr(entry, 'name', entry) in disable:\n                continue\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'tensorizer': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tagger': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'parser': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize],\n        'ner': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n        'similarity': lambda nlp, **cfg: [SimilarityHook(nlp.vocab, **cfg)],\n        'textcat': lambda nlp, **cfg: [TextCategorizer(nlp.vocab, **cfg)],\n        # Temporary compatibility -- delete after pivot\n        'token_vectors': lambda nlp, **cfg: [TokenVectorEncoder(nlp.vocab, **cfg)],\n        'tags': lambda nlp, **cfg: [NeuralTagger(nlp.vocab, **cfg)],\n        'dependencies': lambda nlp, **cfg: [\n            NeuralDependencyParser(nlp.vocab, **cfg),\n            nonproj.deprojectivize,\n        ],\n        'entities': lambda nlp, **cfg: [NeuralEntityRecognizer(nlp.vocab, **cfg)],\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n    syntax_iterators = {}\n\n\nclass Language(object):\n    \"\"\"A text-processing pipeline. Usually you'll load this once per process,\n    and pass the instance around your application.\n\n    Defaults (class): Settings, data and factory methods for creating the `nlp`\n        object and processing pipeline.\n    lang (unicode): Two-letter language ID, i.e. ISO code.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None,\n                 meta={}, disable=tuple(), **kwargs):\n        \"\"\"Initialise a Language object.\n\n        vocab (Vocab): A `Vocab` object. If `True`, a vocab is created via\n            `Language.Defaults.create_vocab`.\n        make_doc (callable): A function that takes text and returns a `Doc`\n            object. Usually a `Tokenizer`.\n        pipeline (list): A list of annotation processes or IDs of annotation,\n            processes, e.g. a `Tagger` object, or `'tagger'`. IDs are looked\n            up in `Language.Defaults.factories`.\n        disable (list): A list of component names to exclude from the pipeline.\n            The disable list has priority over the pipeline list -- if the same\n            string occurs in both, the component is not loaded.\n        meta (dict): Custom meta data for the Language class. Is written to by\n            models to add model meta data.\n        RETURNS (Language): The newly constructed object.\n        \"\"\"\n        self._meta = dict(meta)\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.tokenizer = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self, disable)\n        elif pipeline:\n            # Careful not to do getattr(p, 'name', None) here\n            # If we had disable=[None], we'd disable everything!\n            self.pipeline = [p for p in pipeline\n                             if p not in disable\n                             and getattr(p, 'name', p) not in disable]\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n        flat_list = []\n        for pipe in self.pipeline:\n            if isinstance(pipe, list):\n                flat_list.extend(pipe)\n            else:\n                flat_list.append(pipe)\n        self.pipeline = flat_list\n\n    @property\n    def meta(self):\n        self._meta.setdefault('lang', self.vocab.lang)\n        self._meta.setdefault('name', '')\n        self._meta.setdefault('version', '0.0.0')\n        self._meta.setdefault('spacy_version', about.__version__)\n        self._meta.setdefault('description', '')\n        self._meta.setdefault('author', '')\n        self._meta.setdefault('email', '')\n        self._meta.setdefault('url', '')\n        self._meta.setdefault('license', '')\n        pipeline = []\n        for component in self.pipeline:\n            if hasattr(component, 'name'):\n                pipeline.append(component.name)\n        self._meta['pipeline'] = pipeline\n        return self._meta\n\n    @meta.setter\n    def meta(self, value):\n        self._meta = value\n\n    # Conveniences to access pipeline components\n    @property\n    def tensorizer(self):\n        return self.get_component('tensorizer')\n\n    @property\n    def tagger(self):\n        return self.get_component('tagger')\n\n    @property\n    def parser(self):\n        return self.get_component('parser')\n\n    @property\n    def entity(self):\n        return self.get_component('ner')\n\n    @property\n    def matcher(self):\n        return self.get_component('matcher')\n\n    def get_component(self, name): \n        if self.pipeline in (True, None):\n            return None\n        for proc in self.pipeline:\n            if hasattr(proc, 'name') and proc.name.endswith(name):\n                return proc\n        return None\n\n    def __call__(self, text, disable=[]):\n        \"\"\"'Apply the pipeline to some text. The text can span multiple sentences,\n        and can contain arbtrary whitespace. Alignment into the original string\n        is preserved.\n\n        text (unicode): The text to be processed.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Doc): A container for accessing the annotations.\n\n        EXAMPLE:\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].text, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            doc = proc(doc)\n        return doc\n\n    def make_doc(self, text):\n        return self.tokenizer(text)\n\n    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n        \"\"\"Update the models in the pipeline.\n\n        docs (iterable): A batch of `Doc` objects.\n        golds (iterable): A batch of `GoldParse` objects.\n        drop (float): The droput rate.\n        sgd (callable): An optimizer.\n        RETURNS (dict): Results from the update.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if len(docs) != len(golds):\n            raise IndexError(\"Update expects same number of docs and golds \"\n                \"Got: %d, %d\" % (len(docs), len(golds)))\n        if len(docs) == 0:\n            return\n        tok2vec = self.pipeline[0]\n        feats = tok2vec.doc2feats(docs)\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        pipes = list(self.pipeline[1:])\n        random.shuffle(pipes)\n        for proc in pipes:\n            if not hasattr(proc, 'update'):\n                continue\n            tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n            d_tokvecses = proc.update((docs, tokvecses), golds,\n                                      drop=drop, sgd=get_grads, losses=losses)\n            if d_tokvecses is not None:\n                bp_tokvecses(d_tokvecses, sgd=sgd)\n        for key, (W, dW) in grads.items():\n            sgd(W, dW, key=key)\n        # Clear the tensor variable, to free GPU memory.\n        # If we don't do this, the memory leak gets pretty\n        # bad, because we may be holding part of a batch.\n        for doc in docs:\n            doc.tensor = None\n\n    def preprocess_gold(self, docs_golds):\n        \"\"\"Can be called before training to pre-process gold data. By default,\n        it handles nonprojectivity and adds missing tags to the tag map.\n\n        docs_golds (iterable): Tuples of `Doc` and `GoldParse` objects.\n        YIELDS (tuple): Tuples of preprocessed `Doc` and `GoldParse` objects.\n        \"\"\"\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples, **cfg):\n        \"\"\"Allocate models, pre-process training data and acquire a trainer and\n        optimizer. Used as a contextmanager.\n\n        gold_tuples (iterable): Gold-standard training data.\n        **cfg: Config parameters.\n        YIELDS (tuple): A trainer and an optimizer.\n\n        EXAMPLE:\n            >>> with nlp.begin_training(gold, use_gpu=True) as (trainer, optimizer):\n            >>>    for epoch in trainer.epochs(gold):\n            >>>        for docs, golds in epoch:\n            >>>            state = nlp.update(docs, golds, sgd=optimizer)\n        \"\"\"\n        if self.parser:\n            self.pipeline.append(NeuralLabeller(self.vocab))\n        # Populate vocab\n        for _, annots_brackets in get_gold_tuples():\n            for annots, _ in annots_brackets:\n                for word in annots[1]:\n                    _ = self.vocab[word]\n        contexts = []\n        if cfg.get('device', -1) >= 0:\n            import cupy.cuda.device\n            device = cupy.cuda.device.Device(cfg['device'])\n            device.use()\n            Model.ops = CupyOps()\n            Model.Ops = CupyOps\n        else:\n            device = None\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        learn_rate = util.env_opt('learn_rate', 0.001)\n        beta1 = util.env_opt('optimizer_B1', 0.9)\n        beta2 = util.env_opt('optimizer_B2', 0.999)\n        eps = util.env_opt('optimizer_eps', 1e-08)\n        L2 = util.env_opt('L2_penalty', 1e-6)\n        max_grad_norm = util.env_opt('grad_norm_clip', 1.)\n        optimizer = Adam(Model.ops, learn_rate, L2=L2, beta1=beta1,\n                         beta2=beta2, eps=eps)\n        optimizer.max_grad_norm = max_grad_norm\n        optimizer.device = device\n        return optimizer\n\n    def evaluate(self, docs_golds):\n        docs, golds = zip(*docs_golds)\n        scorer = Scorer()\n        for doc, gold in zip(self.pipe(docs, batch_size=32), golds):\n            scorer.score(doc, gold)\n            doc.tensor = None\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        \"\"\"Replace weights of models in the pipeline with those provided in the\n        params dictionary. Can be used as a contextmanager, in which case,\n        models go back to their original weights after the block.\n\n        params (dict): A dictionary of parameters keyed by model ID.\n        **cfg: Config parameters.\n\n        EXAMPLE:\n            >>> with nlp.use_params(optimizer.averages):\n            >>>     nlp.to_disk('/tmp/checkpoint')\n        \"\"\"\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, tuples=False, n_threads=2, batch_size=1000, disable=[]):\n        \"\"\"Process texts as a stream, and yield `Doc` objects in order. Supports\n        GIL-free multi-threading.\n\n        texts (iterator): A sequence of texts to process.\n        n_threads (int): The number of worker threads to use. If -1, OpenMP will\n            decide how many to use at run time. Default is 2.\n        batch_size (int): The number of texts to buffer.\n        disable (list): Names of the pipeline components to disable.\n        YIELDS (Doc): Documents in the order of the original text.\n\n        EXAMPLE:\n            >>> texts = [u'One document.', u'...', u'Lots of documents']\n            >>>     for doc in nlp.pipe(texts, batch_size=50, n_threads=4):\n            >>>         assert doc.is_parsed\n        \"\"\"\n        if tuples:\n            text_context1, text_context2 = itertools.tee(texts)\n            texts = (tc[0] for tc in text_context1)\n            contexts = (tc[1] for tc in text_context2)\n            docs = self.pipe(texts, n_threads=n_threads, batch_size=batch_size,\n                             disable=disable)\n            for doc, context in izip(docs, contexts):\n                yield (doc, context)\n            return\n        docs = (self.make_doc(text) for text in texts)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disable:\n                continue\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                # Apply the function, but yield the doc\n                docs = _pipe(proc, docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, disable=tuple()):\n        \"\"\"Save the current state to a directory.  If a model is loaded, this\n        will include the model.\n\n        path (unicode or Path): A path to a directory, which will be created if\n            it doesn't exist. Paths may be either strings or `Path`-like objects.\n        disable (list): Names of pipeline components to disable and prevent\n            from being saved.\n\n        EXAMPLE:\n            >>> nlp.to_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        serializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.to_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.to_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            serializers[proc.name] = lambda p, proc=proc: proc.to_disk(p, vocab=False)\n        util.to_disk(path, serializers, {p: False for p in disable})\n\n    def from_disk(self, path, disable=tuple()):\n        \"\"\"Loads state from a directory. Modifies the object in place and\n        returns it. If the saved `Language` object contains a model, the\n        model will be loaded.\n\n        path (unicode or Path): A path to a directory. Paths may be either\n            strings or `Path`-like objects.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The modified `Language` object.\n\n        EXAMPLE:\n            >>> from spacy.language import Language\n            >>> nlp = Language().from_disk('/path/to/models')\n        \"\"\"\n        path = util.ensure_path(path)\n        deserializers = OrderedDict((\n            ('vocab', lambda p: self.vocab.from_disk(p)),\n            ('tokenizer', lambda p: self.tokenizer.from_disk(p, vocab=False)),\n            ('meta.json', lambda p: p.open('w').write(json_dumps(self.meta)))\n        ))\n        for proc in self.pipeline:\n            if not hasattr(proc, 'name'):\n                continue\n            if proc.name in disable:\n                continue\n            if not hasattr(proc, 'to_disk'):\n                continue\n            deserializers[proc.name] = lambda p, proc=proc: proc.from_disk(p, vocab=False)\n        exclude = {p: False for p in disable}\n        if not (path / 'vocab').exists():\n            exclude['vocab'] = True\n        util.from_disk(path, deserializers, exclude)\n        return self\n\n    def to_bytes(self, disable=[]):\n        \"\"\"Serialize the current state to a binary string.\n\n        disable (list): Nameds of pipeline components to disable and prevent\n            from being serialized.\n        RETURNS (bytes): The serialized form of the `Language` object.\n        \"\"\"\n        serializers = OrderedDict((\n            ('vocab', lambda: self.vocab.to_bytes()),\n            ('tokenizer', lambda: self.tokenizer.to_bytes(vocab=False)),\n            ('meta', lambda: ujson.dumps(self.meta))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'to_bytes'):\n                continue\n            serializers[i] = lambda proc=proc: proc.to_bytes(vocab=False)\n        return util.to_bytes(serializers, {})\n\n    def from_bytes(self, bytes_data, disable=[]):\n        \"\"\"Load state from a binary string.\n\n        bytes_data (bytes): The data to load from.\n        disable (list): Names of the pipeline components to disable.\n        RETURNS (Language): The `Language` object.\n        \"\"\"\n        deserializers = OrderedDict((\n            ('vocab', lambda b: self.vocab.from_bytes(b)),\n            ('tokenizer', lambda b: self.tokenizer.from_bytes(b, vocab=False)),\n            ('meta', lambda b: self.meta.update(ujson.loads(b)))\n        ))\n        for i, proc in enumerate(self.pipeline):\n            if getattr(proc, 'name', None) in disable:\n                continue\n            if not hasattr(proc, 'from_bytes'):\n                continue\n            deserializers[i] = lambda b, proc=proc: proc.from_bytes(b, vocab=False)\n        msg = util.from_bytes(bytes_data, deserializers, {})\n        return self\n\n\ndef _pipe(func, docs):\n    for doc in docs:\n        func(doc)\n        yield doc\n",
          "file_patch": "@@ -277,8 +277,7 @@ class Language(object):\n     def make_doc(self, text):\n         return self.tokenizer(text)\n \n-    def update(self, docs, golds, drop=0., sgd=None, losses=None,\n-            update_tensors=False):\n+    def update(self, docs, golds, drop=0., sgd=None, losses=None):\n         \"\"\"Update the models in the pipeline.\n \n         docs (iterable): A batch of `Doc` objects.\n@@ -305,17 +304,14 @@ class Language(object):\n             grads[key] = (W, dW)\n         pipes = list(self.pipeline[1:])\n         random.shuffle(pipes)\n-        tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n-        all_d_tokvecses = [tok2vec.model.ops.allocate(tv.shape) for tv in tokvecses]\n         for proc in pipes:\n             if not hasattr(proc, 'update'):\n                 continue\n+            tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n             d_tokvecses = proc.update((docs, tokvecses), golds,\n                                       drop=drop, sgd=get_grads, losses=losses)\n-            if update_tensors and d_tokvecses is not None:\n-                for i, d_tv in enumerate(d_tokvecses):\n-                    all_d_tokvecses[i] += d_tv\n-        bp_tokvecses(all_d_tokvecses, sgd=sgd)\n+            if d_tokvecses is not None:\n+                bp_tokvecses(d_tokvecses, sgd=sgd)\n         for key, (W, dW) in grads.items():\n             sgd(W, dW, key=key)\n         # Clear the tensor variable, to free GPU memory.\n@@ -385,18 +381,9 @@ class Language(object):\n         return optimizer\n \n     def evaluate(self, docs_golds):\n-        scorer = Scorer()\n         docs, golds = zip(*docs_golds)\n-        docs = list(docs)\n-        golds = list(golds)\n-        for pipe in self.pipeline:\n-            if not hasattr(pipe, 'pipe'):\n-                for doc in docs:\n-                    pipe(doc)\n-            else:\n-                docs = list(pipe.pipe(docs))\n-        assert len(docs) == len(golds)\n-        for doc, gold in zip(docs, golds):\n+        scorer = Scorer()\n+        for doc, gold in zip(self.pipe(docs, batch_size=32), golds):\n             scorer.score(doc, gold)\n             doc.tensor = None\n         return scorer\n",
          "files_name_in_blame_commit": [
            "language.py",
            "convert.py",
            "_beam_utils.pyx",
            "nn_parser.pyx",
            "arc_eager.pyx",
            "setup.py",
            "_ml.py",
            "transition_system.pyx",
            "train.py",
            "beam_parser.pyx",
            "test_nn_beam.py",
            "test_neural_parser.py",
            "pipeline.pyx"
          ]
        }
      },
      "4c9202249d820d45dde13abae5e3f6b448785225": {
        "commit": {
          "commit_id": "4c9202249d820d45dde13abae5e3f6b448785225",
          "commit_message": "Refactor training, to fix memory leak",
          "commit_author": "Matthew Honnibal",
          "commit_date": "2017-05-21 09:07:06",
          "commit_parent": "4803b3b69eb47aba2a9847c9cd5ab4bcd8ae1879"
        },
        "function": {
          "function_name": "evaluate",
          "function_code_before": "",
          "function_code_after": "def evaluate(self, docs_golds):\n    (docs, golds) = zip(*docs_golds)\n    scorer = Scorer()\n    for (doc, gold) in zip(self.pipe(docs), golds):\n        scorer.score(doc, gold)\n    return scorer",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 226,
          "function_after_end_line": 231,
          "function_before_token_count": 0,
          "function_after_token_count": 48,
          "functions_name_modified_file": [
            "create_vocab",
            "preprocess_gold",
            "from_disk",
            "evaluate",
            "create_tagger",
            "use_params",
            "from_bytes",
            "create_parser",
            "create_entity",
            "create_tokenizer",
            "create_pipeline",
            "pipe",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "begin_training",
            "to_bytes",
            "create_lemmatizer"
          ],
          "functions_name_all_files": [
            "convert",
            "create_vocab",
            "preprocess_gold",
            "from_disk",
            "evaluate",
            "create_tagger",
            "package",
            "model",
            "use_params",
            "from_bytes",
            "print_results",
            "_render_parses",
            "print_progress",
            "create_parser",
            "create_entity",
            "link",
            "create_tokenizer",
            "create_pipeline",
            "pipe",
            "to_disk",
            "__init__",
            "update",
            "__call__",
            "train",
            "download",
            "begin_training",
            "to_bytes",
            "info",
            "create_lemmatizer",
            "__missing__"
          ],
          "functions_name_co_evolved_modified_file": [
            "update",
            "begin_training",
            "preprocess_gold"
          ],
          "functions_name_co_evolved_all_files": [
            "update",
            "begin_training",
            "train",
            "train_model",
            "preprocess_gold",
            "train_config"
          ]
        },
        "file": {
          "file_name": "language.py",
          "file_nloc": 250,
          "file_complexity": 80,
          "file_token_count": 1885,
          "file_before": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .train import Trainer\nfrom .syntax.parser import get_templates\nfrom .syntax.nonproj import PseudoProjectivity\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .compat import json_dumps\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in cls.pipeline:\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'token_vectors': lambda nlp, **cfg: TokenVectorEncoder(nlp.vocab, **cfg),\n        'tags': lambda nlp, **cfg: NeuralTagger(nlp.vocab, **cfg),\n        'dependencies': lambda nlp, **cfg: NeuralDependencyParser(nlp.vocab, **cfg),\n        'entities': lambda nlp, **cfg: NeuralEntityRecognizer(nlp.vocab, **cfg),\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n\n\nclass Language(object):\n    \"\"\"\n    A text-processing pipeline. Usually you'll load this once per process, and\n    pass the instance around your program.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None, meta={}):\n        self.meta = dict(meta)\n\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.make_doc = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self)\n        elif pipeline:\n            self.pipeline = list(pipeline)\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n\n    def __call__(self, text, **disabled):\n        \"\"\"\n        Apply the pipeline to some text.  The text can span multiple sentences,\n        and can contain arbtrary whitespace.  Alignment into the original string\n        is preserved.\n\n        Args:\n            text (unicode): The text to be processed.\n\n        Returns:\n            doc (Doc): A container for accessing the annotations.\n\n        Example:\n            >>> from spacy.en import English\n            >>> nlp = English()\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].orth_, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disabled and not disabled[name]:\n                continue\n            proc(doc)\n        return doc\n\n    def update(self, docs, golds, drop=0., sgd=None):\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        tok2vec = self.pipeline[0]\n        feats = tok2vec.doc2feats(docs)\n        for proc in self.pipeline[1:]:\n            grads = {}\n            tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n            d_tokvecses = proc.update((docs, tokvecses), golds, sgd=get_grads, drop=drop)\n            bp_tokvecses(d_tokvecses, sgd=get_grads)\n            if sgd is not None:\n                for key, (W, dW) in grads.items():\n                    # TODO: Unhack this when thinc improves\n                    if isinstance(W, numpy.ndarray):\n                        sgd.ops = NumpyOps()\n                    else:\n                        sgd.ops = CupyOps()\n                    sgd(W, dW, key=key)\n\n    @contextmanager\n    def begin_training(self, gold_tuples, **cfg):\n        # Populate vocab\n        for _, annots_brackets in gold_tuples:\n            for annots, _ in annots_brackets:\n                for word in annots[1]:\n                    _ = self.vocab[word]\n        # Handle crossing dependencies\n        gold_tuples = PseudoProjectivity.preprocess_training_data(gold_tuples)\n        contexts = []\n        if cfg.get('use_gpu'):\n            Model.ops = CupyOps()\n            Model.Ops = CupyOps\n            print(\"Use GPU\")\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(gold_tuples,\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        trainer = Trainer(self, gold_tuples, **cfg)\n        yield trainer, trainer.optimizer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, n_threads=2, batch_size=1000, **disabled):\n        \"\"\"\n        Process texts as a stream, and yield Doc objects in order.\n\n        Supports GIL-free multi-threading.\n\n        Arguments:\n            texts (iterator)\n            tag (bool)\n            parse (bool)\n            entity (bool)\n        \"\"\"\n        #docs = (self.make_doc(text) for text in texts)\n        docs = texts\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disabled and not disabled[name]:\n                continue\n\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                docs = (proc(doc) for doc in docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, **exclude):\n        \"\"\"Save the current state to a directory.\n\n        Args:\n            path: A path to a directory, which will be created if it doesn't\n                    exist. Paths may be either strings or pathlib.Path-like\n                    objects.\n            **exclude: Prevent named attributes from being saved.\n        \"\"\"\n        path = util.ensure_path(path)\n        if not path.exists():\n            path.mkdir()\n        if not path.is_dir():\n            raise IOError(\"Output path must be a directory\")\n        props = {}\n        for name, value in self.__dict__.items():\n            if name in exclude:\n                continue\n            if hasattr(value, 'to_disk'):\n                value.to_disk(path / name)\n            else:\n                props[name] = value\n        with (path / 'props.pickle').open('wb') as file_:\n            dill.dump(props, file_)\n\n    def from_disk(self, path, **exclude):\n        \"\"\"Load the current state from a directory.\n\n        Args:\n            path: A path to a directory. Paths may be either strings or\n                pathlib.Path-like objects.\n            **exclude: Prevent named attributes from being saved.\n        \"\"\"\n        path = util.ensure_path(path)\n        for name in path.iterdir():\n            if name not in exclude and hasattr(self, str(name)):\n                getattr(self, name).from_disk(path / name)\n        with (path / 'props.pickle').open('rb') as file_:\n            bytes_data = file_.read()\n        self.from_bytes(bytes_data, **exclude)\n        return self\n\n    def to_bytes(self, **exclude):\n        \"\"\"Serialize the current state to a binary string.\n\n        Args:\n            path: A path to a directory. Paths may be either strings or\n                pathlib.Path-like objects.\n            **exclude: Prevent named attributes from being serialized.\n        \"\"\"\n        props = dict(self.__dict__)\n        for key in exclude:\n            if key in props:\n                props.pop(key)\n        return dill.dumps(props, -1)\n\n    def from_bytes(self, bytes_data, **exclude):\n        \"\"\"Load state from a binary string.\n\n        Args:\n            bytes_data (bytes): The data to load from.\n            **exclude: Prevent named attributes from being loaded.\n        \"\"\"\n        props = dill.loads(bytes_data)\n        for key, value in props.items():\n            if key not in exclude:\n                setattr(self, key, value)\n        return self\n\n",
          "file_after": "# coding: utf8\nfrom __future__ import absolute_import, unicode_literals\nfrom contextlib import contextmanager\nimport dill\n\nimport numpy\nfrom thinc.neural import Model\nfrom thinc.neural.ops import NumpyOps, CupyOps\nfrom thinc.neural.optimizers import Adam\n\nfrom .tokenizer import Tokenizer\nfrom .vocab import Vocab\nfrom .tagger import Tagger\nfrom .lemmatizer import Lemmatizer\nfrom .syntax.parser import get_templates\nfrom .syntax.nonproj import PseudoProjectivity\nfrom .pipeline import NeuralDependencyParser, EntityRecognizer\nfrom .pipeline import TokenVectorEncoder, NeuralTagger, NeuralEntityRecognizer\nfrom .compat import json_dumps\nfrom .attrs import IS_STOP\nfrom .lang.punctuation import TOKENIZER_PREFIXES, TOKENIZER_SUFFIXES, TOKENIZER_INFIXES\nfrom .lang.tokenizer_exceptions import TOKEN_MATCH\nfrom .lang.tag_map import TAG_MAP\nfrom .lang.lex_attrs import LEX_ATTRS\nfrom . import util\nfrom .scorer import Scorer\n\n\nclass BaseDefaults(object):\n    @classmethod\n    def create_lemmatizer(cls, nlp=None):\n        return Lemmatizer(cls.lemma_index, cls.lemma_exc, cls.lemma_rules)\n\n    @classmethod\n    def create_vocab(cls, nlp=None):\n        lemmatizer = cls.create_lemmatizer(nlp)\n        lex_attr_getters = dict(cls.lex_attr_getters)\n        # This is messy, but it's the minimal working fix to Issue #639.\n        lex_attr_getters[IS_STOP] = lambda string: string.lower() in cls.stop_words\n        vocab = Vocab(lex_attr_getters=lex_attr_getters, tag_map=cls.tag_map,\n                      lemmatizer=lemmatizer)\n        for tag_str, exc in cls.morph_rules.items():\n            for orth_str, attrs in exc.items():\n                vocab.morphology.add_special_case(tag_str, orth_str, attrs)\n        return vocab\n\n    @classmethod\n    def create_tokenizer(cls, nlp=None):\n        rules = cls.tokenizer_exceptions\n        token_match = cls.token_match\n        prefix_search = util.compile_prefix_regex(cls.prefixes).search \\\n                        if cls.prefixes else None\n        suffix_search = util.compile_suffix_regex(cls.suffixes).search \\\n                        if cls.suffixes else None\n        infix_finditer = util.compile_infix_regex(cls.infixes).finditer \\\n                         if cls.infixes else None\n        vocab = nlp.vocab if nlp is not None else cls.create_vocab(nlp)\n        return Tokenizer(vocab, rules=rules,\n                         prefix_search=prefix_search, suffix_search=suffix_search,\n                         infix_finditer=infix_finditer, token_match=token_match)\n\n    @classmethod\n    def create_tagger(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralTagger(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralTagger(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_parser(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralDependencyParser(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralDependencyParser(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_entity(cls, nlp=None, **cfg):\n        if nlp is None:\n            return NeuralEntityRecognizer(cls.create_vocab(nlp), **cfg)\n        else:\n            return NeuralEntityRecognizer(nlp.vocab, **cfg)\n\n    @classmethod\n    def create_pipeline(cls, nlp=None):\n        meta = nlp.meta if nlp is not None else {}\n        # Resolve strings, like \"cnn\", \"lstm\", etc\n        pipeline = []\n        for entry in cls.pipeline:\n            factory = cls.Defaults.factories[entry]\n            pipeline.append(factory(nlp, **meta.get(entry, {})))\n        return pipeline\n\n    factories = {\n        'make_doc': create_tokenizer,\n        'token_vectors': lambda nlp, **cfg: TokenVectorEncoder(nlp.vocab, **cfg),\n        'tags': lambda nlp, **cfg: NeuralTagger(nlp.vocab, **cfg),\n        'dependencies': lambda nlp, **cfg: NeuralDependencyParser(nlp.vocab, **cfg),\n        'entities': lambda nlp, **cfg: NeuralEntityRecognizer(nlp.vocab, **cfg),\n    }\n\n    token_match = TOKEN_MATCH\n    prefixes = tuple(TOKENIZER_PREFIXES)\n    suffixes = tuple(TOKENIZER_SUFFIXES)\n    infixes = tuple(TOKENIZER_INFIXES)\n    tag_map = dict(TAG_MAP)\n    tokenizer_exceptions = {}\n    parser_features = get_templates('parser')\n    entity_features = get_templates('ner')\n    tagger_features = Tagger.feature_templates # TODO -- fix this\n    stop_words = set()\n    lemma_rules = {}\n    lemma_exc = {}\n    lemma_index = {}\n    morph_rules = {}\n    lex_attr_getters = LEX_ATTRS\n\n\nclass Language(object):\n    \"\"\"\n    A text-processing pipeline. Usually you'll load this once per process, and\n    pass the instance around your program.\n    \"\"\"\n    Defaults = BaseDefaults\n    lang = None\n\n    def __init__(self, vocab=True, make_doc=True, pipeline=None, meta={}):\n        self.meta = dict(meta)\n\n        if vocab is True:\n            factory = self.Defaults.create_vocab\n            vocab = factory(self, **meta.get('vocab', {}))\n        self.vocab = vocab\n        if make_doc is True:\n            factory = self.Defaults.create_tokenizer\n            make_doc = factory(self, **meta.get('tokenizer', {}))\n        self.make_doc = make_doc\n        if pipeline is True:\n            self.pipeline = self.Defaults.create_pipeline(self)\n        elif pipeline:\n            self.pipeline = list(pipeline)\n            # Resolve strings, like \"cnn\", \"lstm\", etc\n            for i, entry in enumerate(self.pipeline):\n                if entry in self.Defaults.factories:\n                    factory = self.Defaults.factories[entry]\n                    self.pipeline[i] = factory(self, **meta.get(entry, {}))\n        else:\n            self.pipeline = []\n\n    def __call__(self, text, **disabled):\n        \"\"\"\n        Apply the pipeline to some text.  The text can span multiple sentences,\n        and can contain arbtrary whitespace.  Alignment into the original string\n        is preserved.\n\n        Args:\n            text (unicode): The text to be processed.\n\n        Returns:\n            doc (Doc): A container for accessing the annotations.\n\n        Example:\n            >>> from spacy.en import English\n            >>> nlp = English()\n            >>> tokens = nlp('An example sentence. Another example sentence.')\n            >>> tokens[0].orth_, tokens[0].head.tag_\n            ('An', 'NN')\n        \"\"\"\n        doc = self.make_doc(text)\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disabled and not disabled[name]:\n                continue\n            proc(doc)\n        return doc\n\n    def update(self, docs, golds, drop=0., sgd=None):\n        grads = {}\n        def get_grads(W, dW, key=None):\n            grads[key] = (W, dW)\n        tok2vec = self.pipeline[0]\n        feats = tok2vec.doc2feats(docs)\n        for proc in self.pipeline[1:]:\n            grads = {}\n            tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n            d_tokvecses = proc.update((docs, tokvecses), golds, sgd=sgd, drop=drop)\n            bp_tokvecses(d_tokvecses, sgd=sgd)\n            if sgd is not None:\n                for key, (W, dW) in grads.items():\n                    # TODO: Unhack this when thinc improves\n                    if isinstance(W, numpy.ndarray):\n                        sgd.ops = NumpyOps()\n                    else:\n                        sgd.ops = CupyOps()\n                    sgd(W, dW, key=key)\n                for key in list(grads.keys()):\n                    grads.pop(key)\n        for doc in docs:\n            doc.tensor = None\n\n    def preprocess_gold(self, docs_golds):\n        for proc in self.pipeline:\n            if hasattr(proc, 'preprocess_gold'):\n                docs_golds = proc.preprocess_gold(docs_golds)\n        for doc, gold in docs_golds:\n            yield doc, gold\n\n    def begin_training(self, get_gold_tuples, **cfg):\n        # Populate vocab\n        for _, annots_brackets in get_gold_tuples():\n            for annots, _ in annots_brackets:\n                for word in annots[1]:\n                    _ = self.vocab[word]\n        contexts = []\n        if cfg.get('use_gpu'):\n            Model.ops = CupyOps()\n            Model.Ops = CupyOps\n            print(\"Use GPU\")\n        for proc in self.pipeline:\n            if hasattr(proc, 'begin_training'):\n                context = proc.begin_training(get_gold_tuples(),\n                                              pipeline=self.pipeline)\n                contexts.append(context)\n        optimizer = Adam(Model.ops, 0.001)\n        return optimizer\n\n    def evaluate(self, docs_golds):\n        docs, golds = zip(*docs_golds)\n        scorer = Scorer()\n        for doc, gold in zip(self.pipe(docs), golds):\n            scorer.score(doc, gold)\n        return scorer\n\n    @contextmanager\n    def use_params(self, params, **cfg):\n        contexts = [pipe.use_params(params) for pipe\n                    in self.pipeline if hasattr(pipe, 'use_params')]\n        # TODO: Having trouble with contextlib\n        # Workaround: these aren't actually context managers atm.\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n        yield\n        for context in contexts:\n            try:\n                next(context)\n            except StopIteration:\n                pass\n\n    def pipe(self, texts, n_threads=2, batch_size=1000, **disabled):\n        \"\"\"\n        Process texts as a stream, and yield Doc objects in order.\n\n        Supports GIL-free multi-threading.\n\n        Arguments:\n            texts (iterator)\n            tag (bool)\n            parse (bool)\n            entity (bool)\n        \"\"\"\n        #docs = (self.make_doc(text) for text in texts)\n        docs = texts\n        for proc in self.pipeline:\n            name = getattr(proc, 'name', None)\n            if name in disabled and not disabled[name]:\n                continue\n\n            if hasattr(proc, 'pipe'):\n                docs = proc.pipe(docs, n_threads=n_threads, batch_size=batch_size)\n            else:\n                docs = (proc(doc) for doc in docs)\n        for doc in docs:\n            yield doc\n\n    def to_disk(self, path, **exclude):\n        \"\"\"Save the current state to a directory.\n\n        Args:\n            path: A path to a directory, which will be created if it doesn't\n                    exist. Paths may be either strings or pathlib.Path-like\n                    objects.\n            **exclude: Prevent named attributes from being saved.\n        \"\"\"\n        path = util.ensure_path(path)\n        if not path.exists():\n            path.mkdir()\n        if not path.is_dir():\n            raise IOError(\"Output path must be a directory\")\n        props = {}\n        for name, value in self.__dict__.items():\n            if name in exclude:\n                continue\n            if hasattr(value, 'to_disk'):\n                value.to_disk(path / name)\n            else:\n                props[name] = value\n        with (path / 'props.pickle').open('wb') as file_:\n            dill.dump(props, file_)\n\n    def from_disk(self, path, **exclude):\n        \"\"\"Load the current state from a directory.\n\n        Args:\n            path: A path to a directory. Paths may be either strings or\n                pathlib.Path-like objects.\n            **exclude: Prevent named attributes from being saved.\n        \"\"\"\n        path = util.ensure_path(path)\n        for name in path.iterdir():\n            if name not in exclude and hasattr(self, str(name)):\n                getattr(self, name).from_disk(path / name)\n        with (path / 'props.pickle').open('rb') as file_:\n            bytes_data = file_.read()\n        self.from_bytes(bytes_data, **exclude)\n        return self\n\n    def to_bytes(self, **exclude):\n        \"\"\"Serialize the current state to a binary string.\n\n        Args:\n            path: A path to a directory. Paths may be either strings or\n                pathlib.Path-like objects.\n            **exclude: Prevent named attributes from being serialized.\n        \"\"\"\n        props = dict(self.__dict__)\n        for key in exclude:\n            if key in props:\n                props.pop(key)\n        return dill.dumps(props, -1)\n\n    def from_bytes(self, bytes_data, **exclude):\n        \"\"\"Load state from a binary string.\n\n        Args:\n            bytes_data (bytes): The data to load from.\n            **exclude: Prevent named attributes from being loaded.\n        \"\"\"\n        props = dill.loads(bytes_data)\n        for key, value in props.items():\n            if key not in exclude:\n                setattr(self, key, value)\n        return self\n\n",
          "file_patch": "@@ -6,12 +6,12 @@ import dill\n import numpy\n from thinc.neural import Model\n from thinc.neural.ops import NumpyOps, CupyOps\n+from thinc.neural.optimizers import Adam\n \n from .tokenizer import Tokenizer\n from .vocab import Vocab\n from .tagger import Tagger\n from .lemmatizer import Lemmatizer\n-from .train import Trainer\n from .syntax.parser import get_templates\n from .syntax.nonproj import PseudoProjectivity\n from .pipeline import NeuralDependencyParser, EntityRecognizer\n@@ -23,6 +23,7 @@ from .lang.tokenizer_exceptions import TOKEN_MATCH\n from .lang.tag_map import TAG_MAP\n from .lang.lex_attrs import LEX_ATTRS\n from . import util\n+from .scorer import Scorer\n \n \n class BaseDefaults(object):\n@@ -181,8 +182,8 @@ class Language(object):\n         for proc in self.pipeline[1:]:\n             grads = {}\n             tokvecses, bp_tokvecses = tok2vec.model.begin_update(feats, drop=drop)\n-            d_tokvecses = proc.update((docs, tokvecses), golds, sgd=get_grads, drop=drop)\n-            bp_tokvecses(d_tokvecses, sgd=get_grads)\n+            d_tokvecses = proc.update((docs, tokvecses), golds, sgd=sgd, drop=drop)\n+            bp_tokvecses(d_tokvecses, sgd=sgd)\n             if sgd is not None:\n                 for key, (W, dW) in grads.items():\n                     # TODO: Unhack this when thinc improves\n@@ -191,16 +192,24 @@ class Language(object):\n                     else:\n                         sgd.ops = CupyOps()\n                     sgd(W, dW, key=key)\n+                for key in list(grads.keys()):\n+                    grads.pop(key)\n+        for doc in docs:\n+            doc.tensor = None\n \n-    @contextmanager\n-    def begin_training(self, gold_tuples, **cfg):\n+    def preprocess_gold(self, docs_golds):\n+        for proc in self.pipeline:\n+            if hasattr(proc, 'preprocess_gold'):\n+                docs_golds = proc.preprocess_gold(docs_golds)\n+        for doc, gold in docs_golds:\n+            yield doc, gold\n+\n+    def begin_training(self, get_gold_tuples, **cfg):\n         # Populate vocab\n-        for _, annots_brackets in gold_tuples:\n+        for _, annots_brackets in get_gold_tuples():\n             for annots, _ in annots_brackets:\n                 for word in annots[1]:\n                     _ = self.vocab[word]\n-        # Handle crossing dependencies\n-        gold_tuples = PseudoProjectivity.preprocess_training_data(gold_tuples)\n         contexts = []\n         if cfg.get('use_gpu'):\n             Model.ops = CupyOps()\n@@ -208,11 +217,18 @@ class Language(object):\n             print(\"Use GPU\")\n         for proc in self.pipeline:\n             if hasattr(proc, 'begin_training'):\n-                context = proc.begin_training(gold_tuples,\n+                context = proc.begin_training(get_gold_tuples(),\n                                               pipeline=self.pipeline)\n                 contexts.append(context)\n-        trainer = Trainer(self, gold_tuples, **cfg)\n-        yield trainer, trainer.optimizer\n+        optimizer = Adam(Model.ops, 0.001)\n+        return optimizer\n+\n+    def evaluate(self, docs_golds):\n+        docs, golds = zip(*docs_golds)\n+        scorer = Scorer()\n+        for doc, gold in zip(self.pipe(docs), golds):\n+            scorer.score(doc, gold)\n+        return scorer\n \n     @contextmanager\n     def use_params(self, params, **cfg):\n",
          "files_name_in_blame_commit": [
            "language.py",
            "train.py",
            "__main__.py"
          ]
        }
      }
    }
  }
}
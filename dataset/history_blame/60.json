{
  "id": "60",
  "blame_commit": {
    "commit": {
      "commit_id": "aa84ac8e3e305d76e71c0c1b31237517948fa12f",
      "commit_message": ":sparkles: Implement support for Pydantic's ORM mode (#322)\n\n* :sparkles: Implement support for Pydantic's ORM mode\r\n\r\n* :building_construction: Re-structure/augment SQL tutorial source using ORM mode\r\n\r\n* :memo: Update SQL docs with SQLAlchemy, ORM mode, relationships\r\n\r\n* :fire: Remove unused util in tutorial\r\n\r\n* :memo: Add tutorials for simple dict bodies and responses\r\n\r\n* :fire: Remove old SQL tutorial\r\n\r\n* :white_check_mark: Add/update tests for SQL tutorial\r\n\r\n* :white_check_mark: Add tests for simple dicts (body and response)\r\n\r\n* :bug: Fix cloning field from original field",
      "commit_author": "Sebasti\u00e1n Ram\u00edrez",
      "commit_date": "2019-06-20 11:31:32",
      "commit_parent": "4ed2bd1feaf15b22cb7e38d0515c55e9f6658fb5"
    },
    "function": {
      "function_name": "create_cloned_field",
      "function_code_before": "",
      "function_code_after": "def create_cloned_field(field: Field) -> Field:\n    original_type = field.type_\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = create_model(original_type.__name__, __config__=original_type.__config__, __validators__=original_type.__validators__)\n        for f in original_type.__fields__.values():\n            use_type.__fields__[f.name] = f\n    new_field = Field(name=field.name, type_=use_type, class_validators={}, default=None, required=False, model_config=BaseConfig, schema=Schema(None))\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.schema = field.schema\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [create_cloned_field(sub_field) for sub_field in field.sub_fields]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field)\n    new_field.validators = field.validators\n    new_field.whole_pre_validators = field.whole_pre_validators\n    new_field.whole_post_validators = field.whole_post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field._populate_validators()\n    return new_field",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 55,
      "function_after_end_line": 97,
      "function_before_token_count": 0,
      "function_after_token_count": 258,
      "functions_name_modified_file": [
        "get_flat_models_from_routes",
        "get_path_param_names",
        "get_model_definitions",
        "create_cloned_field"
      ],
      "functions_name_all_files": [
        "test_inexistent_user",
        "get_user",
        "test_get_user",
        "get_model_definitions",
        "test_post_invalid_body",
        "include_router",
        "get_flat_models_from_routes",
        "read_items",
        "get_websocket_app",
        "add_api_route",
        "post",
        "get_user_by_email",
        "api_route",
        "create_cloned_field",
        "test_create_user",
        "test_get_items",
        "get_db",
        "test_openapi_schema",
        "create_index_weights",
        "create_item_for_user",
        "websocket",
        "options",
        "create_user",
        "get_users",
        "test_post_body",
        "test_create_item",
        "test_read_items",
        "put",
        "add_api_websocket_route",
        "create_user_item",
        "get",
        "patch",
        "test_get_users",
        "delete",
        "__init__",
        "read_keyword_weights",
        "trace",
        "read_users",
        "get_path_param_names",
        "serialize_response",
        "db_session_middleware",
        "get_app",
        "head",
        "read_user",
        "get_items"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "test_inexistent_user",
        "get_user",
        "test_get_user",
        "test_post_invalid_body",
        "read_items",
        "get_user_by_email",
        "test_create_user",
        "__tablename__",
        "test_get_items",
        "get_db",
        "test_openapi_schema",
        "create_index_weights",
        "create_item_for_user",
        "test_create_item",
        "create_user",
        "test_post_body",
        "get_users",
        "test_first_user",
        "test_read_items",
        "create_user_item",
        "test_get_users",
        "__init__",
        "read_keyword_weights",
        "read_users",
        "serialize_response",
        "db_session_middleware",
        "read_user",
        "get_items"
      ]
    },
    "file": {
      "file_name": "utils.py",
      "file_nloc": 88,
      "file_complexity": 17,
      "file_token_count": 579,
      "file_before": "import re\nfrom typing import Any, Dict, List, Sequence, Set, Type\n\nfrom fastapi import routing\nfrom fastapi.openapi.constants import REF_PREFIX\nfrom pydantic import BaseModel\nfrom pydantic.fields import Field\nfrom pydantic.schema import get_flat_models_from_fields, model_process_schema\nfrom starlette.routing import BaseRoute\n\n\ndef get_flat_models_from_routes(\n    routes: Sequence[Type[BaseRoute]]\n) -> Set[Type[BaseModel]]:\n    body_fields_from_routes: List[Field] = []\n    responses_from_routes: List[Field] = []\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, Field\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n    flat_models = get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes, known_models=set()\n    )\n    return flat_models\n\n\ndef get_model_definitions(\n    *, flat_models: Set[Type[BaseModel]], model_name_map: Dict[Type[BaseModel], str]\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict] = {}\n    for model in flat_models:\n        m_schema, m_definitions = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions\n\n\ndef get_path_param_names(path: str) -> Set[str]:\n    return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n",
      "file_after": "import re\nfrom typing import Any, Dict, List, Sequence, Set, Type, cast\n\nfrom fastapi import routing\nfrom fastapi.openapi.constants import REF_PREFIX\nfrom pydantic import BaseConfig, BaseModel, Schema, create_model\nfrom pydantic.fields import Field\nfrom pydantic.schema import get_flat_models_from_fields, model_process_schema\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.routing import BaseRoute\n\n\ndef get_flat_models_from_routes(\n    routes: Sequence[Type[BaseRoute]]\n) -> Set[Type[BaseModel]]:\n    body_fields_from_routes: List[Field] = []\n    responses_from_routes: List[Field] = []\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, Field\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n    flat_models = get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes, known_models=set()\n    )\n    return flat_models\n\n\ndef get_model_definitions(\n    *, flat_models: Set[Type[BaseModel]], model_name_map: Dict[Type[BaseModel], str]\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict] = {}\n    for model in flat_models:\n        m_schema, m_definitions = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions\n\n\ndef get_path_param_names(path: str) -> Set[str]:\n    return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n\n\ndef create_cloned_field(field: Field) -> Field:\n    original_type = field.type_\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = create_model(  # type: ignore\n            original_type.__name__,\n            __config__=original_type.__config__,\n            __validators__=original_type.__validators__,\n        )\n        for f in original_type.__fields__.values():\n            use_type.__fields__[f.name] = f\n    new_field = Field(\n        name=field.name,\n        type_=use_type,\n        class_validators={},\n        default=None,\n        required=False,\n        model_config=BaseConfig,\n        schema=Schema(None),\n    )\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.schema = field.schema\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [\n            create_cloned_field(sub_field) for sub_field in field.sub_fields\n        ]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field)\n    new_field.validators = field.validators\n    new_field.whole_pre_validators = field.whole_pre_validators\n    new_field.whole_post_validators = field.whole_post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field._populate_validators()\n    return new_field\n",
      "file_patch": "@@ -1,11 +1,12 @@\n import re\n-from typing import Any, Dict, List, Sequence, Set, Type\n+from typing import Any, Dict, List, Sequence, Set, Type, cast\n \n from fastapi import routing\n from fastapi.openapi.constants import REF_PREFIX\n-from pydantic import BaseModel\n+from pydantic import BaseConfig, BaseModel, Schema, create_model\n from pydantic.fields import Field\n from pydantic.schema import get_flat_models_from_fields, model_process_schema\n+from pydantic.utils import lenient_issubclass\n from starlette.routing import BaseRoute\n \n \n@@ -49,3 +50,48 @@ def get_model_definitions(\n \n def get_path_param_names(path: str) -> Set[str]:\n     return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n+\n+\n+def create_cloned_field(field: Field) -> Field:\n+    original_type = field.type_\n+    use_type = original_type\n+    if lenient_issubclass(original_type, BaseModel):\n+        original_type = cast(Type[BaseModel], original_type)\n+        use_type = create_model(  # type: ignore\n+            original_type.__name__,\n+            __config__=original_type.__config__,\n+            __validators__=original_type.__validators__,\n+        )\n+        for f in original_type.__fields__.values():\n+            use_type.__fields__[f.name] = f\n+    new_field = Field(\n+        name=field.name,\n+        type_=use_type,\n+        class_validators={},\n+        default=None,\n+        required=False,\n+        model_config=BaseConfig,\n+        schema=Schema(None),\n+    )\n+    new_field.has_alias = field.has_alias\n+    new_field.alias = field.alias\n+    new_field.class_validators = field.class_validators\n+    new_field.default = field.default\n+    new_field.required = field.required\n+    new_field.model_config = field.model_config\n+    new_field.schema = field.schema\n+    new_field.allow_none = field.allow_none\n+    new_field.validate_always = field.validate_always\n+    if field.sub_fields:\n+        new_field.sub_fields = [\n+            create_cloned_field(sub_field) for sub_field in field.sub_fields\n+        ]\n+    if field.key_field:\n+        new_field.key_field = create_cloned_field(field.key_field)\n+    new_field.validators = field.validators\n+    new_field.whole_pre_validators = field.whole_pre_validators\n+    new_field.whole_post_validators = field.whole_post_validators\n+    new_field.parse_json = field.parse_json\n+    new_field.shape = field.shape\n+    new_field._populate_validators()\n+    return new_field\n",
      "files_name_in_blame_commit": [
        "models.py",
        "routing.py",
        "test_tutorial005.py",
        "crud.py",
        "utils.py",
        "tutorial005.py",
        "test_sql_databases.py",
        "tutorial009.py",
        "test_tutorial009.py",
        "tutorial001.py",
        "__init__.py",
        "schemas.py",
        "database.py",
        "main.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 22
  },
  "recursive_blame_commits": {}
}
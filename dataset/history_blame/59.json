{
  "id": "59",
  "blame_commit": {
    "commit": {
      "commit_id": "2f266c3345ec65c721d4599a685fde6611fb8609",
      "commit_message": "Fix bug where progress indicator doesn't always complete (#8066)\n\n* Fix bug where progress indicator doesn't complete\r\n\r\n* Change progbar interval from 0.05 to 0.1\r\n\r\n...as an experiment to see if makes a difference in test running times. 50 ms is too fast for a human anyway.\r\n\r\n* Break long line, and revert interval change.\r\n\r\n...to address comments in PR.\r\n\r\n* pep8\r\n\r\n* pep8\r\n\r\nTravis pep8 (but not autopep8 -d on my box) complains that\r\n/home/travis/build/fchollet/keras/keras/utils/generic_utils.py:296:21: W503 line break before binary operator\r\n                    and current < self.target):\r\n                    ^",
      "commit_author": "Oleg Zabluda",
      "commit_date": "2017-10-08 18:09:24",
      "commit_parent": "c03482506bf7a82906edcd9f91e3abc8ef88bbed"
    },
    "function": {
      "function_name": "update",
      "function_code_before": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        if self.target is not -1:\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += '=' * (prog_width - 1)\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += '.' * (self.width - prog_width)\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target and self.target is not -1:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
      "function_code_after": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval and (current < self.target):\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        if self.target is not -1:\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += '=' * (prog_width - 1)\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += '.' * (self.width - prog_width)\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current <= self.target and self.target is not -1:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    elif self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
      "function_before_start_line": 273,
      "function_before_end_line": 362,
      "function_after_start_line": 273,
      "function_after_end_line": 363,
      "function_before_token_count": 614,
      "function_after_token_count": 622,
      "functions_name_modified_file": [
        "__init__",
        "update",
        "serialize_keras_object",
        "has_arg",
        "deserialize_keras_object",
        "func_dump",
        "__enter__",
        "func_load",
        "add",
        "custom_object_scope",
        "get_custom_objects",
        "__exit__"
      ],
      "functions_name_all_files": [
        "__init__",
        "update",
        "serialize_keras_object",
        "has_arg",
        "deserialize_keras_object",
        "func_dump",
        "__enter__",
        "func_load",
        "add",
        "custom_object_scope",
        "get_custom_objects",
        "__exit__"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": []
    },
    "file": {
      "file_name": "generic_utils.py",
      "file_nloc": 240,
      "file_complexity": 73,
      "file_token_count": 1544,
      "file_before": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            custom_objects = custom_objects or {}\n            if has_arg(cls.from_config, 'custom_objects'):\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            with CustomObjectScope(custom_objects):\n                return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            custom_objects = custom_objects or {}\n            with CustomObjectScope(custom_objects):\n                return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\ndef has_arg(fn, name, accept_all=False):\n    \"\"\"Checks if a callable accepts a given keyword argument.\n\n    For Python 2, checks if there is an argument with the given name.\n\n    For Python 3, checks if there is an argument with the given name, and\n    also whether this argument can be called with a keyword (i.e. if it is\n    not a positional-only argument).\n\n    # Arguments\n        fn: Callable to inspect.\n        name: Check if `fn` can be called with `name` as a keyword argument.\n        accept_all: What to return if there is no parameter called `name`\n                    but the function accepts a `**kwargs` argument.\n\n    # Returns\n        bool, whether `fn` accepts a `name` keyword argument.\n    \"\"\"\n    if sys.version_info < (3,):\n        arg_spec = inspect.getargspec(fn)\n        if accept_all and arg_spec.keywords is not None:\n            return True\n        return (name in arg_spec.args)\n    elif sys.version_info < (3, 3):\n        arg_spec = inspect.getfullargspec(fn)\n        if accept_all and arg_spec.varkw is not None:\n            return True\n        return (name in arg_spec.args or\n                name in arg_spec.kwonlyargs)\n    else:\n        signature = inspect.signature(fn)\n        parameter = signature.parameters.get(name)\n        if parameter is None:\n            if accept_all:\n                for param in signature.parameters.values():\n                    if param.kind == inspect.Parameter.VAR_KEYWORD:\n                        return True\n            return False\n        return (parameter.kind in (inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                                   inspect.Parameter.KEYWORD_ONLY))\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected, None if unknown.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        if target is None:\n            target = -1\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            if self.target is not -1:\n                numdigits = int(np.floor(np.log10(self.target))) + 1\n                barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n                bar = barstr % (current, self.target)\n                prog = float(current) / self.target\n                prog_width = int(self.width * prog)\n                if prog_width > 0:\n                    bar += ('=' * (prog_width - 1))\n                    if current < self.target:\n                        bar += '>'\n                    else:\n                        bar += '='\n                bar += ('.' * (self.width - prog_width))\n                bar += ']'\n                sys.stdout.write(bar)\n                self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target and self.target is not -1:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
      "file_after": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            custom_objects = custom_objects or {}\n            if has_arg(cls.from_config, 'custom_objects'):\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            with CustomObjectScope(custom_objects):\n                return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            custom_objects = custom_objects or {}\n            with CustomObjectScope(custom_objects):\n                return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\ndef has_arg(fn, name, accept_all=False):\n    \"\"\"Checks if a callable accepts a given keyword argument.\n\n    For Python 2, checks if there is an argument with the given name.\n\n    For Python 3, checks if there is an argument with the given name, and\n    also whether this argument can be called with a keyword (i.e. if it is\n    not a positional-only argument).\n\n    # Arguments\n        fn: Callable to inspect.\n        name: Check if `fn` can be called with `name` as a keyword argument.\n        accept_all: What to return if there is no parameter called `name`\n                    but the function accepts a `**kwargs` argument.\n\n    # Returns\n        bool, whether `fn` accepts a `name` keyword argument.\n    \"\"\"\n    if sys.version_info < (3,):\n        arg_spec = inspect.getargspec(fn)\n        if accept_all and arg_spec.keywords is not None:\n            return True\n        return (name in arg_spec.args)\n    elif sys.version_info < (3, 3):\n        arg_spec = inspect.getfullargspec(fn)\n        if accept_all and arg_spec.varkw is not None:\n            return True\n        return (name in arg_spec.args or\n                name in arg_spec.kwonlyargs)\n    else:\n        signature = inspect.signature(fn)\n        parameter = signature.parameters.get(name)\n        if parameter is None:\n            if accept_all:\n                for param in signature.parameters.values():\n                    if param.kind == inspect.Parameter.VAR_KEYWORD:\n                        return True\n            return False\n        return (parameter.kind in (inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                                   inspect.Parameter.KEYWORD_ONLY))\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected, None if unknown.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        if target is None:\n            target = -1\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if (not force and (now - self.last_update) < self.interval and\n                    current < self.target):\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            if self.target is not -1:\n                numdigits = int(np.floor(np.log10(self.target))) + 1\n                barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n                bar = barstr % (current, self.target)\n                prog = float(current) / self.target\n                prog_width = int(self.width * prog)\n                if prog_width > 0:\n                    bar += ('=' * (prog_width - 1))\n                    if current < self.target:\n                        bar += '>'\n                    else:\n                        bar += '='\n                bar += ('.' * (self.width - prog_width))\n                bar += ']'\n                sys.stdout.write(bar)\n                self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current <= self.target and self.target is not -1:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        elif self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
      "file_patch": "@@ -292,7 +292,8 @@ class Progbar(object):\n \n         now = time.time()\n         if self.verbose == 1:\n-            if not force and (now - self.last_update) < self.interval:\n+            if (not force and (now - self.last_update) < self.interval and\n+                    current < self.target):\n                 return\n \n             prev_total_width = self.total_width\n@@ -322,7 +323,7 @@ class Progbar(object):\n                 time_per_unit = 0\n             eta = time_per_unit * (self.target - current)\n             info = ''\n-            if current < self.target and self.target is not -1:\n+            if current <= self.target and self.target is not -1:\n                 info += ' - ETA: %ds' % eta\n             else:\n                 info += ' - %ds' % (now - self.start)\n@@ -347,7 +348,7 @@ class Progbar(object):\n             if current >= self.target:\n                 sys.stdout.write('\\n')\n \n-        if self.verbose == 2:\n+        elif self.verbose == 2:\n             if current >= self.target:\n                 info = '%ds' % (now - self.start)\n                 for k in self.unique_values:\n",
      "files_name_in_blame_commit": [
        "generic_utils.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 75
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "273": {
        "commit_id": "7aa3114d9ff1cfbeb4128934fec05878fb7cf633",
        "line_code": "    def update(self, current, values=None, force=False):",
        "commit_date": "2017-01-11 15:02:52",
        "valid": 1
      },
      "274": {
        "commit_id": "8f7574437951a8f1042407d25bffb57292e3b6a6",
        "line_code": "        \"\"\"Updates the progress bar.",
        "commit_date": "2017-01-10 15:34:16",
        "valid": 1
      },
      "275": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 0
      },
      "276": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "        # Arguments",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "277": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "            current: Index of current step.",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "278": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "            values: List of tuples (name, value_for_last_step).",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "279": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                The progress bar will display averages for these values.",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "280": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "            force: Whether to force visual progress update.",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "281": {
        "commit_id": "8f7574437951a8f1042407d25bffb57292e3b6a6",
        "line_code": "        \"\"\"",
        "commit_date": "2017-01-10 15:34:16",
        "valid": 1
      },
      "282": {
        "commit_id": "7aa3114d9ff1cfbeb4128934fec05878fb7cf633",
        "line_code": "        values = values or []",
        "commit_date": "2017-01-11 15:02:52",
        "valid": 1
      },
      "283": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "        for k, v in values:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "284": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            if k not in self.sum_values:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "285": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "                self.sum_values[k] = [v * (current - self.seen_so_far),",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "286": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "                                      current - self.seen_so_far]",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "287": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                self.unique_values.append(k)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "288": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            else:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "289": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                self.sum_values[k][0] += v * (current - self.seen_so_far)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "290": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                self.sum_values[k][1] += (current - self.seen_so_far)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "291": {
        "commit_id": "9390d63056e9e787a1942bb74b582d3224c75892",
        "line_code": "        self.seen_so_far = current",
        "commit_date": "2015-05-09 18:14:19",
        "valid": 1
      },
      "292": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 0
      },
      "293": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "        now = time.time()",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 1
      },
      "294": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "        if self.verbose == 1:",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 1
      },
      "295": {
        "commit_id": "1a89b13cb4ac52b7dad40e671b618e42921a4c48",
        "line_code": "            if not force and (now - self.last_update) < self.interval:",
        "commit_date": "2017-05-08 09:33:42",
        "valid": 1
      },
      "296": {
        "commit_id": "5a71090476da28a7258ed8653bf89d831d03cf22",
        "line_code": "                return",
        "commit_date": "2016-06-02 13:06:37",
        "valid": 1
      },
      "297": {
        "commit_id": "5a71090476da28a7258ed8653bf89d831d03cf22",
        "line_code": "",
        "commit_date": "2016-06-02 13:06:37",
        "valid": 0
      },
      "298": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            prev_total_width = self.total_width",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "299": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "            sys.stdout.write('\\b' * prev_total_width)",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "300": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "            sys.stdout.write('\\r')",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "301": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 0
      },
      "302": {
        "commit_id": "cf57d28452a901e3400c706685d416037caeadc4",
        "line_code": "            if self.target is not -1:",
        "commit_date": "2017-05-22 12:04:33",
        "valid": 1
      },
      "303": {
        "commit_id": "77fb6a3873ca6bd82a7dc1620eeb706c66177fc5",
        "line_code": "                numdigits = int(np.floor(np.log10(self.target))) + 1",
        "commit_date": "2015-05-18 15:52:04",
        "valid": 1
      },
      "304": {
        "commit_id": "77fb6a3873ca6bd82a7dc1620eeb706c66177fc5",
        "line_code": "                barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)",
        "commit_date": "2015-05-18 15:52:04",
        "valid": 1
      },
      "305": {
        "commit_id": "77fb6a3873ca6bd82a7dc1620eeb706c66177fc5",
        "line_code": "                bar = barstr % (current, self.target)",
        "commit_date": "2015-05-18 15:52:04",
        "valid": 1
      },
      "306": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                prog = float(current) / self.target",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "307": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                prog_width = int(self.width * prog)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "308": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                if prog_width > 0:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "309": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                    bar += ('=' * (prog_width - 1))",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "310": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                    if current < self.target:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "311": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                        bar += '>'",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "312": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                    else:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "313": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                        bar += '='",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "314": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                bar += ('.' * (self.width - prog_width))",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "315": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                bar += ']'",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "316": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                sys.stdout.write(bar)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "317": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                self.total_width = len(bar)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "318": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 0
      },
      "319": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            if current:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "320": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                time_per_unit = (now - self.start) / current",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "321": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            else:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "322": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                time_per_unit = 0",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "323": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            eta = time_per_unit * (self.target - current)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "324": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            info = ''",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "325": {
        "commit_id": "cf57d28452a901e3400c706685d416037caeadc4",
        "line_code": "            if current < self.target and self.target is not -1:",
        "commit_date": "2017-05-22 12:04:33",
        "valid": 1
      },
      "326": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                info += ' - ETA: %ds' % eta",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "327": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            else:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "328": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "                info += ' - %ds' % (now - self.start)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "329": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            for k in self.unique_values:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "330": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                info += ' - %s:' % k",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "331": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "                if isinstance(self.sum_values[k], list):",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "332": {
        "commit_id": "d687c6eda4d9cb58756822fd77402274db309da8",
        "line_code": "                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))",
        "commit_date": "2017-08-11 11:05:46",
        "valid": 1
      },
      "333": {
        "commit_id": "729f0765da577a4ebd879331f651b6d241a10632",
        "line_code": "                    if abs(avg) > 1e-3:",
        "commit_date": "2015-12-29 16:00:39",
        "valid": 1
      },
      "334": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                        info += ' %.4f' % avg",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "335": {
        "commit_id": "b9403cb2621a048a885e30f5a9527a14f061a0a6",
        "line_code": "                    else:",
        "commit_date": "2015-09-20 15:26:27",
        "valid": 1
      },
      "336": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                        info += ' %.4e' % avg",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "337": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                else:",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "338": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                    info += ' %s' % self.sum_values[k]",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "339": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 0
      },
      "340": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            self.total_width += len(info)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "341": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            if prev_total_width > self.total_width:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "342": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "                info += ((prev_total_width - self.total_width) * ' ')",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "343": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 0
      },
      "344": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            sys.stdout.write(info)",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "345": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            sys.stdout.flush()",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "346": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 0
      },
      "347": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "            if current >= self.target:",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 1
      },
      "348": {
        "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
        "line_code": "                sys.stdout.write('\\n')",
        "commit_date": "2016-12-13 19:13:04",
        "valid": 1
      },
      "349": {
        "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
        "line_code": "",
        "commit_date": "2015-03-27 17:59:42",
        "valid": 0
      },
      "350": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "        if self.verbose == 2:",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 1
      },
      "351": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "            if current >= self.target:",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 1
      },
      "352": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "                info = '%ds' % (now - self.start)",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 1
      },
      "353": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "                for k in self.unique_values:",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 1
      },
      "354": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                    info += ' - %s:' % k",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "355": {
        "commit_id": "d687c6eda4d9cb58756822fd77402274db309da8",
        "line_code": "                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))",
        "commit_date": "2017-08-11 11:05:46",
        "valid": 1
      },
      "356": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                    if avg > 1e-3:",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "357": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                        info += ' %.4f' % avg",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "358": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                    else:",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "359": {
        "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
        "line_code": "                        info += ' %.4e' % avg",
        "commit_date": "2015-12-08 03:08:16",
        "valid": 1
      },
      "360": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "                sys.stdout.write(info + \"\\n\")",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 1
      },
      "361": {
        "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
        "line_code": "",
        "commit_date": "2015-04-18 17:15:33",
        "valid": 0
      },
      "362": {
        "commit_id": "5a71090476da28a7258ed8653bf89d831d03cf22",
        "line_code": "        self.last_update = now",
        "commit_date": "2016-06-02 13:06:37",
        "valid": 1
      }
    },
    "commits": {
      "d687c6eda4d9cb58756822fd77402274db309da8": {
        "commit": {
          "commit_id": "d687c6eda4d9cb58756822fd77402274db309da8",
          "commit_message": "model.fit(steps_per_epoch), \tmnist_tfrecord.py, progbar np.mean (#7113)\n\n* generic_utils.py don't crash when dealing with batched data\r\n\r\n* Progbar() unit test\r\n\r\n* mnist_tfrecord.py added (#7061, #7072, #6928, #7046)\r\n\r\n* Fix mnist_tfrecord.py runtime errors\r\n\r\n* mnist_tfrecord.py pep8\r\n\r\n* mnist_tfrecord.py add parallelism option\r\n\r\n* reorder inputs\r\n\r\n* mnist_tfrecord.py indentation fix\r\n\r\n* lower batch size and epochs\r\n\r\n* loss defaults to None in compile()\r\n\r\n* mnist_tfrecord.py\r\n\r\n* model.fit(steps_per_epoch) added\r\n\r\n* added _check_num_samples for cases when batch_size does not apply\r\n\r\n* fix test failures\r\n\r\n* remove inaccurate warning\r\n\r\n* improved fit(steps_per_epoch) with separate internal epoch loop in _fit_loop\r\n\r\n* fit(steps_per_epoch) initial validation support\r\n\r\n* training.py pep8\r\n\r\n* mnist_tfrecord.py fix key missing lines\r\n\r\n* mnist_tfrecord.py add coordinator\r\n\r\n* removed extraneous line\r\n\r\n* mnist_tfrecord.py and training.py clean up based on review (#7113)\r\n\r\n* mnist_tfrecord.py extended description\r\n\r\n* training.py fix test error\r\n\r\n* mnist_tfrecord.py and training.py fixed review comments, docs, and error messages (#7113)\r\n\r\n* training.py fix unit test error for steps_per_epoch\r\n\r\n* fix docstring comments from review (#7113)\r\n\r\n* training.py improve docstrings and error case",
          "commit_author": "Andrew Hundt",
          "commit_date": "2017-08-11 11:05:46",
          "commit_parent": "1e9ee7e1651f201c3b2f86e534c551e9688949e5"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        if self.target is not -1:\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += '=' * (prog_width - 1)\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += '.' * (self.width - prog_width)\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target and self.target is not -1:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_code_after": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        if self.target is not -1:\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += '=' * (prog_width - 1)\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += '.' * (self.width - prog_width)\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target and self.target is not -1:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_before_start_line": 273,
          "function_before_end_line": 362,
          "function_after_start_line": 273,
          "function_after_end_line": 362,
          "function_before_token_count": 604,
          "function_after_token_count": 614,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "serialize_keras_object",
            "has_arg",
            "deserialize_keras_object",
            "func_dump",
            "__enter__",
            "func_load",
            "add",
            "custom_object_scope",
            "get_custom_objects",
            "__exit__"
          ],
          "functions_name_all_files": [
            "_batch_shuffle",
            "_check_array_lengths",
            "has_arg",
            "test_check_bad_shape",
            "test_check_last_is_one",
            "test_weighted_masked_objective",
            "test_progbar",
            "predict_on_batch",
            "_weighted_masked_objective",
            "_standardize_sample_or_class_weights",
            "fit",
            "train_on_batch",
            "_standardize_class_weights",
            "_make_predict_function",
            "custom_object_scope",
            "evaluate",
            "test_on_batch",
            "func_dump",
            "test_check_array_lengths",
            "test_sparse_input_validation_split",
            "test_has_arg_positional_only",
            "_collect_metrics",
            "serialize_keras_object",
            "test_model_with_partial_loss",
            "predict_generator",
            "_make_batches",
            "_standardize_input_data",
            "_standardize_weights",
            "predict",
            "_fit_loop",
            "__enter__",
            "test_trainable_argument",
            "test_custom_objects_scope",
            "add",
            "_check_num_samples",
            "test_slice_arrays",
            "deserialize_keras_object",
            "_standardize_user_data",
            "on_epoch_end",
            "_masked_objective",
            "_test_loop",
            "fit_generator",
            "_slice_arrays",
            "__getitem__",
            "test_model_methods",
            "test_model_with_external_loss",
            "__init__",
            "update",
            "evaluate_generator",
            "cnn_layers",
            "test_warnings",
            "test_check_not_failing",
            "test_model_with_input_feed_tensor",
            "_check_loss_and_target_compatibility",
            "__len__",
            "func_load",
            "test_has_arg",
            "_make_train_function",
            "_get_deduped_metrics_names",
            "_predict_loop",
            "get_custom_objects",
            "_standardize_sample_weights",
            "__exit__",
            "_make_test_function",
            "compile"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "cnn_layers",
            "test_progbar",
            "fit",
            "predict",
            "_fit_loop",
            "_test_loop",
            "_predict_loop",
            "_check_num_samples",
            "test_model_methods",
            "test_model_with_external_loss"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 239,
          "file_complexity": 72,
          "file_token_count": 1536,
          "file_before": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            custom_objects = custom_objects or {}\n            if has_arg(cls.from_config, 'custom_objects'):\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            with CustomObjectScope(custom_objects):\n                return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            custom_objects = custom_objects or {}\n            with CustomObjectScope(custom_objects):\n                return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\ndef has_arg(fn, name, accept_all=False):\n    \"\"\"Checks if a callable accepts a given keyword argument.\n\n    For Python 2, checks if there is an argument with the given name.\n\n    For Python 3, checks if there is an argument with the given name, and\n    also whether this argument can be called with a keyword (i.e. if it is\n    not a positional-only argument).\n\n    # Arguments\n        fn: Callable to inspect.\n        name: Check if `fn` can be called with `name` as a keyword argument.\n        accept_all: What to return if there is no parameter called `name`\n                    but the function accepts a `**kwargs` argument.\n\n    # Returns\n        bool, whether `fn` accepts a `name` keyword argument.\n    \"\"\"\n    if sys.version_info < (3,):\n        arg_spec = inspect.getargspec(fn)\n        if accept_all and arg_spec.keywords is not None:\n            return True\n        return (name in arg_spec.args)\n    elif sys.version_info < (3, 3):\n        arg_spec = inspect.getfullargspec(fn)\n        if accept_all and arg_spec.varkw is not None:\n            return True\n        return (name in arg_spec.args or\n                name in arg_spec.kwonlyargs)\n    else:\n        signature = inspect.signature(fn)\n        parameter = signature.parameters.get(name)\n        if parameter is None:\n            if accept_all:\n                for param in signature.parameters.values():\n                    if param.kind == inspect.Parameter.VAR_KEYWORD:\n                        return True\n            return False\n        return (parameter.kind in (inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                                   inspect.Parameter.KEYWORD_ONLY))\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected, None if unknown.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        if target is None:\n            target = -1\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            if self.target is not -1:\n                numdigits = int(np.floor(np.log10(self.target))) + 1\n                barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n                bar = barstr % (current, self.target)\n                prog = float(current) / self.target\n                prog_width = int(self.width * prog)\n                if prog_width > 0:\n                    bar += ('=' * (prog_width - 1))\n                    if current < self.target:\n                        bar += '>'\n                    else:\n                        bar += '='\n                bar += ('.' * (self.width - prog_width))\n                bar += ']'\n                sys.stdout.write(bar)\n                self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target and self.target is not -1:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
          "file_after": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            custom_objects = custom_objects or {}\n            if has_arg(cls.from_config, 'custom_objects'):\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            with CustomObjectScope(custom_objects):\n                return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            custom_objects = custom_objects or {}\n            with CustomObjectScope(custom_objects):\n                return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\ndef has_arg(fn, name, accept_all=False):\n    \"\"\"Checks if a callable accepts a given keyword argument.\n\n    For Python 2, checks if there is an argument with the given name.\n\n    For Python 3, checks if there is an argument with the given name, and\n    also whether this argument can be called with a keyword (i.e. if it is\n    not a positional-only argument).\n\n    # Arguments\n        fn: Callable to inspect.\n        name: Check if `fn` can be called with `name` as a keyword argument.\n        accept_all: What to return if there is no parameter called `name`\n                    but the function accepts a `**kwargs` argument.\n\n    # Returns\n        bool, whether `fn` accepts a `name` keyword argument.\n    \"\"\"\n    if sys.version_info < (3,):\n        arg_spec = inspect.getargspec(fn)\n        if accept_all and arg_spec.keywords is not None:\n            return True\n        return (name in arg_spec.args)\n    elif sys.version_info < (3, 3):\n        arg_spec = inspect.getfullargspec(fn)\n        if accept_all and arg_spec.varkw is not None:\n            return True\n        return (name in arg_spec.args or\n                name in arg_spec.kwonlyargs)\n    else:\n        signature = inspect.signature(fn)\n        parameter = signature.parameters.get(name)\n        if parameter is None:\n            if accept_all:\n                for param in signature.parameters.values():\n                    if param.kind == inspect.Parameter.VAR_KEYWORD:\n                        return True\n            return False\n        return (parameter.kind in (inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                                   inspect.Parameter.KEYWORD_ONLY))\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected, None if unknown.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        if target is None:\n            target = -1\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            if self.target is not -1:\n                numdigits = int(np.floor(np.log10(self.target))) + 1\n                barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n                bar = barstr % (current, self.target)\n                prog = float(current) / self.target\n                prog_width = int(self.width * prog)\n                if prog_width > 0:\n                    bar += ('=' * (prog_width - 1))\n                    if current < self.target:\n                        bar += '>'\n                    else:\n                        bar += '='\n                bar += ('.' * (self.width - prog_width))\n                bar += ']'\n                sys.stdout.write(bar)\n                self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target and self.target is not -1:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
          "file_patch": "@@ -329,7 +329,7 @@ class Progbar(object):\n             for k in self.unique_values:\n                 info += ' - %s:' % k\n                 if isinstance(self.sum_values[k], list):\n-                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n+                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                     if abs(avg) > 1e-3:\n                         info += ' %.4f' % avg\n                     else:\n@@ -352,7 +352,7 @@ class Progbar(object):\n                 info = '%ds' % (now - self.start)\n                 for k in self.unique_values:\n                     info += ' - %s:' % k\n-                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n+                    avg = np.mean(self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                     if avg > 1e-3:\n                         info += ' %.4f' % avg\n                     else:\n",
          "files_name_in_blame_commit": [
            "training.py",
            "test_training.py",
            "generic_utils.py",
            "generic_utils_test.py",
            "mnist_tfrecord.py"
          ]
        }
      },
      "cf57d28452a901e3400c706685d416037caeadc4": {
        "commit": {
          "commit_id": "cf57d28452a901e3400c706685d416037caeadc4",
          "commit_message": "get_file() progbar fix (#6670)\n\n* Fix get_file download progress bar\r\n\r\n* Added a comment to clarify the purpose of the \"enclosed\" dictionary\r\n\r\n* pep8\r\n\r\n* Fix get_file download progress bar, including no Content-Length header.\r\n\r\n* Progbar accepts target None in addition to -1.\r\n\r\n* #6670 Remove Progbar implementation details from docstring\r\nOnly None should be supported on the Progbar target parameter,\r\ntarget values of -1 are an unsupported implementation detail\r\nthat may be removed in the future.",
          "commit_author": "Andrew Hundt",
          "commit_date": "2017-05-22 12:04:33",
          "commit_parent": "c1a1c33ef962c6fdf379c3b45fe30bb7f0d9496d"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_code_after": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        if self.target is not -1:\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += '=' * (prog_width - 1)\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += '.' * (self.width - prog_width)\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target and self.target is not -1:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_before_start_line": 227,
          "function_before_end_line": 315,
          "function_after_start_line": 229,
          "function_after_end_line": 318,
          "function_before_token_count": 587,
          "function_after_token_count": 604,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "serialize_keras_object",
            "deserialize_keras_object",
            "func_dump",
            "__enter__",
            "func_load",
            "add",
            "custom_object_scope",
            "get_custom_objects",
            "__exit__"
          ],
          "functions_name_all_files": [
            "__init__",
            "urlretrieve",
            "get_custom_objects",
            "serialize_keras_object",
            "update",
            "deserialize_keras_object",
            "func_dump",
            "_extract_archive",
            "get_file",
            "__enter__",
            "func_load",
            "_hash_file",
            "custom_object_scope",
            "add",
            "validate_file",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "urlretrieve",
            "get_file"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 214,
          "file_complexity": 59,
          "file_token_count": 1345,
          "file_before": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            arg_spec = inspect.getargspec(cls.from_config)\n            if 'custom_objects' in arg_spec.args:\n                custom_objects = custom_objects or {}\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width - 1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
          "file_after": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            arg_spec = inspect.getargspec(cls.from_config)\n            if 'custom_objects' in arg_spec.args:\n                custom_objects = custom_objects or {}\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected, None if unknown.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        if target is None:\n            target = -1\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            if self.target is not -1:\n                numdigits = int(np.floor(np.log10(self.target))) + 1\n                barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n                bar = barstr % (current, self.target)\n                prog = float(current) / self.target\n                prog_width = int(self.width * prog)\n                if prog_width > 0:\n                    bar += ('=' * (prog_width - 1))\n                    if current < self.target:\n                        bar += '>'\n                    else:\n                        bar += '='\n                bar += ('.' * (self.width - prog_width))\n                bar += ']'\n                sys.stdout.write(bar)\n                self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target and self.target is not -1:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
          "file_patch": "@@ -208,12 +208,14 @@ class Progbar(object):\n     \"\"\"Displays a progress bar.\n \n     # Arguments\n-        target: Total number of steps expected.\n+        target: Total number of steps expected, None if unknown.\n         interval: Minimum visual progress update interval (in seconds).\n     \"\"\"\n \n     def __init__(self, target, width=30, verbose=1, interval=0.05):\n         self.width = width\n+        if target is None:\n+            target = -1\n         self.target = target\n         self.sum_values = {}\n         self.unique_values = []\n@@ -253,21 +255,22 @@ class Progbar(object):\n             sys.stdout.write('\\b' * prev_total_width)\n             sys.stdout.write('\\r')\n \n-            numdigits = int(np.floor(np.log10(self.target))) + 1\n-            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n-            bar = barstr % (current, self.target)\n-            prog = float(current) / self.target\n-            prog_width = int(self.width * prog)\n-            if prog_width > 0:\n-                bar += ('=' * (prog_width - 1))\n-                if current < self.target:\n-                    bar += '>'\n-                else:\n-                    bar += '='\n-            bar += ('.' * (self.width - prog_width))\n-            bar += ']'\n-            sys.stdout.write(bar)\n-            self.total_width = len(bar)\n+            if self.target is not -1:\n+                numdigits = int(np.floor(np.log10(self.target))) + 1\n+                barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n+                bar = barstr % (current, self.target)\n+                prog = float(current) / self.target\n+                prog_width = int(self.width * prog)\n+                if prog_width > 0:\n+                    bar += ('=' * (prog_width - 1))\n+                    if current < self.target:\n+                        bar += '>'\n+                    else:\n+                        bar += '='\n+                bar += ('.' * (self.width - prog_width))\n+                bar += ']'\n+                sys.stdout.write(bar)\n+                self.total_width = len(bar)\n \n             if current:\n                 time_per_unit = (now - self.start) / current\n@@ -275,7 +278,7 @@ class Progbar(object):\n                 time_per_unit = 0\n             eta = time_per_unit * (self.target - current)\n             info = ''\n-            if current < self.target:\n+            if current < self.target and self.target is not -1:\n                 info += ' - ETA: %ds' % eta\n             else:\n                 info += ' - %ds' % (now - self.start)\n",
          "files_name_in_blame_commit": [
            "data_utils.py",
            "generic_utils.py"
          ]
        }
      },
      "1a89b13cb4ac52b7dad40e671b618e42921a4c48": {
        "commit": {
          "commit_id": "1a89b13cb4ac52b7dad40e671b618e42921a4c48",
          "commit_message": "Try reverting previously merged PR.",
          "commit_author": "Francois Chollet",
          "commit_date": "2017-05-08 09:33:42",
          "commit_parent": "268672df65941fcc2e1727b877aa457c05acfc45"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval and (current < self.target):\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_code_after": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_before_start_line": 227,
          "function_before_end_line": 315,
          "function_after_start_line": 227,
          "function_after_end_line": 315,
          "function_before_token_count": 593,
          "function_after_token_count": 587,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "serialize_keras_object",
            "deserialize_keras_object",
            "func_dump",
            "__enter__",
            "func_load",
            "add",
            "custom_object_scope",
            "get_custom_objects",
            "__exit__"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "serialize_keras_object",
            "deserialize_keras_object",
            "func_dump",
            "__enter__",
            "func_load",
            "add",
            "custom_object_scope",
            "get_custom_objects",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 211,
          "file_complexity": 56,
          "file_token_count": 1319,
          "file_before": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            arg_spec = inspect.getargspec(cls.from_config)\n            if 'custom_objects' in arg_spec.args:\n                custom_objects = custom_objects or {}\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval and current < self.target:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width - 1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
          "file_after": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\nimport inspect\n\n_GLOBAL_CUSTOM_OBJECTS = {}\n\n\nclass CustomObjectScope(object):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with CustomObjectScope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n    \"\"\"\n\n    def __init__(self, *args):\n        self.custom_objects = args\n        self.backup = None\n\n    def __enter__(self):\n        self.backup = _GLOBAL_CUSTOM_OBJECTS.copy()\n        for objects in self.custom_objects:\n            _GLOBAL_CUSTOM_OBJECTS.update(objects)\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        _GLOBAL_CUSTOM_OBJECTS.clear()\n        _GLOBAL_CUSTOM_OBJECTS.update(self.backup)\n\n\ndef custom_object_scope(*args):\n    \"\"\"Provides a scope that changes to `_GLOBAL_CUSTOM_OBJECTS` cannot escape.\n\n    Convenience wrapper for `CustomObjectScope`.\n    Code within a `with` statement will be able to access custom objects\n    by name. Changes to global custom objects persist\n    within the enclosing `with` statement. At end of the `with` statement,\n    global custom objects are reverted to state\n    at beginning of the `with` statement.\n\n    # Example\n\n    Consider a custom object `MyObject`\n\n    ```python\n        with custom_object_scope({'MyObject':MyObject}):\n            layer = Dense(..., kernel_regularizer='MyObject')\n            # save, load, etc. will recognize custom object by name\n    ```\n\n    # Arguments\n        *args: Variable length list of dictionaries of name,\n            class pairs to add to custom objects.\n\n    # Returns\n        Object of type `CustomObjectScope`.\n    \"\"\"\n    return CustomObjectScope(*args)\n\n\ndef get_custom_objects():\n    \"\"\"Retrieves a live reference to the global dictionary of custom objects.\n\n    Updating and clearing custom objects using `custom_object_scope`\n    is preferred, but `get_custom_objects` can\n    be used to directly access `_GLOBAL_CUSTOM_OBJECTS`.\n\n    # Example\n\n    ```python\n        get_custom_objects().clear()\n        get_custom_objects()['MyObject'] = MyObject\n    ```\n\n    # Returns\n        Global dictionary of names to classes (`_GLOBAL_CUSTOM_OBJECTS`).\n    \"\"\"\n    return _GLOBAL_CUSTOM_OBJECTS\n\n\ndef serialize_keras_object(instance):\n    if instance is None:\n        return None\n    if hasattr(instance, 'get_config'):\n        return {\n            'class_name': instance.__class__.__name__,\n            'config': instance.get_config()\n        }\n    if hasattr(instance, '__name__'):\n        return instance.__name__\n    else:\n        raise ValueError('Cannot serialize', instance)\n\n\ndef deserialize_keras_object(identifier, module_objects=None,\n                             custom_objects=None,\n                             printable_module_name='object'):\n    if isinstance(identifier, dict):\n        # In this case we are dealing with a Keras config dictionary.\n        config = identifier\n        if 'class_name' not in config or 'config' not in config:\n            raise ValueError('Improper config format: ' + str(config))\n        class_name = config['class_name']\n        if custom_objects and class_name in custom_objects:\n            cls = custom_objects[class_name]\n        elif class_name in _GLOBAL_CUSTOM_OBJECTS:\n            cls = _GLOBAL_CUSTOM_OBJECTS[class_name]\n        else:\n            module_objects = module_objects or {}\n            cls = module_objects.get(class_name)\n            if cls is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ': ' + class_name)\n        if hasattr(cls, 'from_config'):\n            arg_spec = inspect.getargspec(cls.from_config)\n            if 'custom_objects' in arg_spec.args:\n                custom_objects = custom_objects or {}\n                return cls.from_config(config['config'],\n                                       custom_objects=dict(list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n                                                           list(custom_objects.items())))\n            return cls.from_config(config['config'])\n        else:\n            # Then `cls` may be a function returning a class.\n            # in this case by convention `config` holds\n            # the kwargs of the function.\n            return cls(**config['config'])\n    elif isinstance(identifier, six.string_types):\n        function_name = identifier\n        if custom_objects and function_name in custom_objects:\n            fn = custom_objects.get(function_name)\n        elif function_name in _GLOBAL_CUSTOM_OBJECTS:\n            fn = _GLOBAL_CUSTOM_OBJECTS[function_name]\n        else:\n            fn = module_objects.get(function_name)\n            if fn is None:\n                raise ValueError('Unknown ' + printable_module_name +\n                                 ':' + function_name)\n        return fn\n    else:\n        raise ValueError('Could not interpret serialized ' +\n                         printable_module_name + ': ' + identifier)\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n        if isinstance(defaults, list):\n            defaults = tuple(defaults)\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.05):\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width - 1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n",
          "file_patch": "@@ -246,7 +246,7 @@ class Progbar(object):\n \n         now = time.time()\n         if self.verbose == 1:\n-            if not force and (now - self.last_update) < self.interval and current < self.target:\n+            if not force and (now - self.last_update) < self.interval:\n                 return\n \n             prev_total_width = self.total_width\n",
          "files_name_in_blame_commit": [
            "generic_utils.py"
          ]
        }
      },
      "7aa3114d9ff1cfbeb4128934fec05878fb7cf633": {
        "commit": {
          "commit_id": "7aa3114d9ff1cfbeb4128934fec05878fb7cf633",
          "commit_message": "Further style fixes.",
          "commit_author": "Francois Chollet",
          "commit_date": "2017-01-11 15:02:52",
          "commit_parent": "8bfd8511332282565efc7aed9cd7500356e92255"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[], force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_code_after": "def update(self, current, values=None, force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    values = values or []\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_before_start_line": 84,
          "function_before_end_line": 171,
          "function_after_start_line": 123,
          "function_after_end_line": 211,
          "function_before_token_count": 582,
          "function_after_token_count": 587,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "display_table",
            "make_tuple",
            "func_load",
            "add",
            "func_dump",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "to_categorical",
            "display_table",
            "make_tuple",
            "binary_logloss",
            "get_params",
            "check_params",
            "func_dump",
            "fit",
            "validate_file",
            "score",
            "get_from_module",
            "urlretrieve",
            "conv_input_length",
            "normalize",
            "get_file",
            "categorical_probas_to_classes",
            "predict",
            "conv_output_length",
            "add",
            "accuracy",
            "multiclass_logloss",
            "__init__",
            "update",
            "convert_kernel",
            "set_params",
            "probas_to_classes",
            "func_load",
            "filter_sk_params",
            "predict_proba"
          ],
          "functions_name_co_evolved_modified_file": [
            "func_load",
            "get_from_module",
            "add",
            "func_dump"
          ],
          "functions_name_co_evolved_all_files": [
            "to_categorical",
            "convert_kernel",
            "set_params",
            "get_file",
            "check_params",
            "predict",
            "func_load",
            "filter_sk_params",
            "predict_proba",
            "add",
            "func_dump",
            "fit",
            "validate_file",
            "score",
            "get_from_module"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 152,
          "file_complexity": 42,
          "file_token_count": 1084,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif isinstance(identifier, dict):\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef func_dump(func):\n    \"\"\"Serializes user defined function.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes user defined function.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.01):\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[], force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width - 1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_after": "\"\"\"Python utilities required by Keras.\"\"\"\nfrom __future__ import absolute_import\n\nimport numpy as np\n\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    \"\"\"Retrieves a class of function member of a module.\n\n    # Arguments\n        identifier: the object to retrieve. It could be specified\n            by name (as a string), or by dict. In any other case,\n            `identifier` itself will be returned without any changes.\n        module_params: the members of a module\n            (e.g. the output of `globals()`).\n        module_name: string; the name of the target module. Only used\n            to format error messages.\n        instantiate: whether to instantiate the returned object\n            (if it's a class).\n        kwargs: a dictionary of keyword arguments to pass to the\n            class constructor if `instantiate` is `True`.\n\n    # Returns\n        The target object.\n\n    # Raises\n        ValueError: if the identifier cannot be found.\n    \"\"\"\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif isinstance(identifier, dict):\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef func_dump(func):\n    \"\"\"Serializes a user defined function.\n\n    # Arguments\n        func: the function to serialize.\n\n    # Returns\n        A tuple `(code, defaults, closure)`.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserializes a user defined function.\n\n    # Arguments\n        code: bytecode of the function.\n        defaults: defaults of the function.\n        closure: closure of the function.\n        globs: dictionary of global objects.\n\n    # Returns\n        A function object.\n    \"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n    \"\"\"Displays a progress bar.\n\n    # Arguments\n        target: Total number of steps expected.\n        interval: Minimum visual progress update interval (in seconds).\n    \"\"\"\n\n    def __init__(self, target, width=30, verbose=1, interval=0.01):\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=None, force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        values = values or []\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width - 1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=None):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_patch": "@@ -1,5 +1,8 @@\n+\"\"\"Python utilities required by Keras.\"\"\"\n from __future__ import absolute_import\n+\n import numpy as np\n+\n import time\n import sys\n import six\n@@ -9,6 +12,27 @@ import types as python_types\n \n def get_from_module(identifier, module_params, module_name,\n                     instantiate=False, kwargs=None):\n+    \"\"\"Retrieves a class of function member of a module.\n+\n+    # Arguments\n+        identifier: the object to retrieve. It could be specified\n+            by name (as a string), or by dict. In any other case,\n+            `identifier` itself will be returned without any changes.\n+        module_params: the members of a module\n+            (e.g. the output of `globals()`).\n+        module_name: string; the name of the target module. Only used\n+            to format error messages.\n+        instantiate: whether to instantiate the returned object\n+            (if it's a class).\n+        kwargs: a dictionary of keyword arguments to pass to the\n+            class constructor if `instantiate` is `True`.\n+\n+    # Returns\n+        The target object.\n+\n+    # Raises\n+        ValueError: if the identifier cannot be found.\n+    \"\"\"\n     if isinstance(identifier, six.string_types):\n         res = module_params.get(identifier)\n         if not res:\n@@ -36,7 +60,13 @@ def make_tuple(*args):\n \n \n def func_dump(func):\n-    \"\"\"Serializes user defined function.\n+    \"\"\"Serializes a user defined function.\n+\n+    # Arguments\n+        func: the function to serialize.\n+\n+    # Returns\n+        A tuple `(code, defaults, closure)`.\n     \"\"\"\n     code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n     defaults = func.__defaults__\n@@ -48,7 +78,16 @@ def func_dump(func):\n \n \n def func_load(code, defaults=None, closure=None, globs=None):\n-    \"\"\"Deserializes user defined function.\n+    \"\"\"Deserializes a user defined function.\n+\n+    # Arguments\n+        code: bytecode of the function.\n+        defaults: defaults of the function.\n+        closure: closure of the function.\n+        globs: dictionary of global objects.\n+\n+    # Returns\n+        A function object.\n     \"\"\"\n     if isinstance(code, (tuple, list)):  # unpack previous dump\n         code, defaults, closure = code\n@@ -81,7 +120,7 @@ class Progbar(object):\n         self.seen_so_far = 0\n         self.verbose = verbose\n \n-    def update(self, current, values=[], force=False):\n+    def update(self, current, values=None, force=False):\n         \"\"\"Updates the progress bar.\n \n         # Arguments\n@@ -90,6 +129,7 @@ class Progbar(object):\n                 The progress bar will display averages for these values.\n             force: Whether to force visual progress update.\n         \"\"\"\n+        values = values or []\n         for k, v in values:\n             if k not in self.sum_values:\n                 self.sum_values[k] = [v * (current - self.seen_so_far),\n@@ -170,7 +210,7 @@ class Progbar(object):\n \n         self.last_update = now\n \n-    def add(self, n, values=[]):\n+    def add(self, n, values=None):\n         self.update(self.seen_so_far + n, values)\n \n \n",
          "files_name_in_blame_commit": [
            "data_utils.py",
            "scikit_learn.py",
            "generic_utils.py",
            "np_utils.py"
          ]
        }
      },
      "8f7574437951a8f1042407d25bffb57292e3b6a6": {
        "commit": {
          "commit_id": "8f7574437951a8f1042407d25bffb57292e3b6a6",
          "commit_message": "Further style fixes (still incomplete).",
          "commit_author": "Francois Chollet",
          "commit_date": "2017-01-10 15:34:16",
          "commit_parent": "ea47e6de279397cb1adf953ae971cf884587447d"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[], force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_code_after": "def update(self, current, values=[], force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_before_start_line": 82,
          "function_before_end_line": 169,
          "function_after_start_line": 83,
          "function_after_end_line": 170,
          "function_before_token_count": 582,
          "function_after_token_count": 582,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "display_table",
            "make_tuple",
            "func_load",
            "add",
            "func_dump",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "flow",
            "pool3d",
            "flow_from_directory",
            "librosa_exists",
            "reverse",
            "_assert_has_capability",
            "create_node",
            "_updated_config",
            "ctc_cost",
            "batch_normalization",
            "lecun_uniform",
            "InceptionV3",
            "step",
            "stateful",
            "stack",
            "eval",
            "_old_theano_conv3d",
            "identity_block",
            "VGG16",
            "VGG19",
            "equal",
            "save_model",
            "cast_to_floatx",
            "shape",
            "load_data",
            "greater",
            "trainable_weights",
            "conv_step",
            "moving_average_update",
            "ask_to_proceed_with_overwrite",
            "manual_variable_initialization",
            "get_updates",
            "test_on_batch",
            "asymmetric_spatial_2d_padding",
            "lesser",
            "next",
            "_fix_unknown_dimension",
            "__next__",
            "call",
            "in_train_phase",
            "permute_dimensions",
            "updates",
            "l2_normalize",
            "load_model",
            "random_normal_variable",
            "get_session",
            "apply_transform",
            "_convert_string_dtype",
            "asymmetric_temporal_padding",
            "make_sampling_table",
            "relu",
            "_preprocess_border_mode",
            "clear_session",
            "one",
            "random_normal",
            "zeros_like",
            "_pooling_function",
            "squared_hinge",
            "object_list_uid",
            "binary_crossentropy",
            "_cond",
            "random_shear",
            "_gather_list_attr",
            "non_trainable_weights",
            "__call__",
            "abs",
            "optimizer_from_config",
            "ctc_decode",
            "trainable",
            "model_from_json",
            "floatx",
            "in_test_phase",
            "state_updates",
            "resize_images",
            "predict_on_batch",
            "normal",
            "he_normal",
            "is_keras_tensor",
            "to_yaml",
            "tile",
            "_old_theano_pool3d",
            "pow",
            "_preprocess_conv2d_filter_shape",
            "regularizers",
            "_gather_dict_attr",
            "argmin",
            "clip_norm",
            "random_uniform_variable",
            "repeat",
            "Xception",
            "to_json",
            "ndim",
            "_flow_index",
            "update",
            "set_params",
            "random_binomial",
            "ctc_create_skip_idxs",
            "display_table",
            "standardize",
            "run_internal_graph",
            "texts_to_sequences",
            "validate_file",
            "resize_volumes",
            "evaluate",
            "conv2d_bn",
            "get_input_shape_at",
            "random_rotation",
            "get_fans",
            "text_to_word_sequence",
            "get_test_data",
            "ones",
            "get_variable_shape",
            "foldl",
            "orthogonal",
            "decode_predictions",
            "__getitem__",
            "sqrt",
            "get_output_shape_for",
            "spatial_2d_padding",
            "evaluate_generator",
            "categorical_crossentropy",
            "conv2d",
            "_preprocess_conv3d_kernel",
            "save",
            "batch_set_value",
            "cast",
            "int_shape",
            "compile",
            "atrous_conv2d",
            "pattern_broadcast",
            "reshape",
            "lesser_equal",
            "func_dump",
            "set_learning_phase",
            "mean_absolute_error",
            "image_dim_ordering",
            "print_tensor",
            "fit_on_texts",
            "softplus",
            "ctc_path_probs",
            "create_input_layer",
            "uniform",
            "conv_output_length",
            "add_inbound_node",
            "get_uid",
            "merge",
            "get_losses_for",
            "fit_generator",
            "ones_like",
            "output_shape",
            "prod",
            "add_update",
            "pool2d",
            "add_loss",
            "ctc_batch_cost",
            "reset_states",
            "switch",
            "count_params",
            "any",
            "set_image_dim_ordering",
            "function",
            "_old_batch_normalization",
            "get_output_mask_at",
            "predict_generator",
            "mean_squared_logarithmic_error",
            "normalize",
            "softsign",
            "preprocess_input",
            "count_total_params",
            "softmax",
            "mean_absolute_percentage_error",
            "sparse_categorical_crossentropy",
            "model_from_yaml",
            "placeholder",
            "clip",
            "dot",
            "get_word_index",
            "one_hot",
            "weights",
            "_old_normalize_batch_in_training",
            "reset_uids",
            "set_value",
            "to_dense",
            "conv_input_length",
            "categorical_probas_to_classes",
            "__iter__",
            "conv1d",
            "output_mask",
            "get_initial_states",
            "is_sparse",
            "get",
            "input_spec",
            "get_output_at",
            "summary",
            "img_to_array",
            "gradients",
            "flattened_layers",
            "training_data",
            "assert_input_compatibility",
            "arange",
            "gather",
            "is_explicit_shape",
            "_normalize_axis",
            "output",
            "get_params",
            "print_summary",
            "dropout",
            "get_layer",
            "tanh",
            "map_fn",
            "base_filter",
            "_initialize_variables",
            "get_weights",
            "dtype",
            "hard_sigmoid",
            "__init__",
            "expand_dims",
            "fit_on_sequences",
            "random_channel_shift",
            "get_output_shape_at",
            "set_epsilon",
            "fit",
            "random_zoom",
            "get_config",
            "random_transform",
            "reset",
            "cosine_proximity",
            "load_array",
            "std",
            "backend",
            "normalize_batch_in_training",
            "add_weight",
            "array_to_img",
            "sign",
            "__len__",
            "random_uniform",
            "identity",
            "var",
            "_preprocess_conv3d_filter_shape",
            "batch_get_value",
            "_recursive_list",
            "input",
            "get_source_inputs",
            "_get_node_attribute_at_index",
            "accuracy",
            "validation_data",
            "elu",
            "square",
            "multiclass_logloss",
            "all",
            "legacy_weight_ordering",
            "get_input_mask_at",
            "max",
            "poisson",
            "binary_logloss",
            "_to_tensor",
            "train_on_batch",
            "model_from_config",
            "minimum",
            "foldr",
            "argmax",
            "get_updates_for",
            "get_file",
            "conv_step_hidden",
            "temporal_padding",
            "set_session",
            "layer_test",
            "Input",
            "get_value",
            "uses_learning_phase",
            "pad_sequences",
            "MusicTaggerCRNN",
            "layer_from_config",
            "ResNet50",
            "greater_equal",
            "not_equal",
            "maximum",
            "_assert_sparse_module",
            "get_gradients",
            "ctc_update_log_p",
            "save_weights",
            "check_params",
            "skipgrams",
            "kullback_leibler_divergence",
            "random_barrel_transform",
            "convert_all_kernels_in_model",
            "in_top_k",
            "_preprocess_conv3d_input",
            "texts_to_sequences_generator",
            "rnn",
            "_get_noise_shape",
            "cos",
            "pop",
            "_preprocess_conv2d_input",
            "compute_mask",
            "get_input_at",
            "get_constants",
            "load_img",
            "deconv2d",
            "random_shift",
            "ctc_label_dense_to_sparse",
            "batch_dot",
            "set_floatx",
            "concatenate",
            "list_pictures",
            "losses",
            "urlretrieve",
            "eye",
            "predict",
            "zero",
            "glorot_uniform",
            "spatial_3d_padding",
            "save_weights_to_hdf5_group",
            "build",
            "sequences_to_matrix",
            "keras_test",
            "sigmoid",
            "_preprocess_conv2d_kernel",
            "probas_to_classes",
            "_preprocess_deconv_output_shape",
            "predict_proba",
            "conv3d",
            "update_add",
            "repeat_elements",
            "separable_conv2d",
            "log",
            "ctc_interleave_blanks",
            "stop_gradient",
            "to_list",
            "make_tuple",
            "sin",
            "flip_axis",
            "hinge",
            "score",
            "get_from_module",
            "update_sub",
            "set_weights",
            "he_uniform",
            "load_weights",
            "texts_to_matrix",
            "batch_flatten",
            "save_array",
            "input_mask",
            "conv_block",
            "squeeze",
            "input_shape",
            "constraints",
            "_preprocess_conv2d_image_shape",
            "epsilon",
            "learning_phase",
            "mean",
            "func_load",
            "variable",
            "exp",
            "_postprocess_conv2d_output",
            "set_legacy_weight_ordering",
            "to_categorical",
            "sum",
            "transform_matrix_offset_center",
            "_preprocess_conv3d_volume_shape",
            "_arguments_validation",
            "zeros",
            "flatten",
            "add",
            "round",
            "load_weights_from_hdf5_group_by_name",
            "transpose",
            "predict_classes",
            "load_weights_from_hdf5_group",
            "mean_squared_error",
            "time_distributed_dense",
            "from_config",
            "_postprocess_conv3d_output",
            "glorot_normal",
            "convert_kernel",
            "min",
            "filter_sk_params"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "func_load",
            "func_dump"
          ],
          "functions_name_co_evolved_all_files": [
            "output",
            "save_weights",
            "get_params",
            "check_params",
            "run_internal_graph",
            "texts_to_sequences",
            "print_summary",
            "dropout",
            "get_layer",
            "resize_volumes",
            "skipgrams",
            "reverse",
            "tanh",
            "evaluate",
            "validate_file",
            "get_input_shape_at",
            "_updated_config",
            "map_fn",
            "batch_normalization",
            "lecun_uniform",
            "InceptionV3",
            "get_weights",
            "in_top_k",
            "text_to_word_sequence",
            "texts_to_sequences_generator",
            "rnn",
            "eval",
            "identity_block",
            "ones",
            "cos",
            "VGG16",
            "foldl",
            "dtype",
            "VGG19",
            "orthogonal",
            "equal",
            "cast_to_floatx",
            "hard_sigmoid",
            "pop",
            "decode_predictions",
            "__init__",
            "compute_mask",
            "sqrt",
            "get_output_shape_for",
            "spatial_2d_padding",
            "evaluate_generator",
            "get_input_at",
            "shape",
            "expand_dims",
            "categorical_crossentropy",
            "load_img",
            "save",
            "load_data",
            "batch_set_value",
            "fit_on_sequences",
            "int_shape",
            "cast",
            "greater",
            "compile",
            "batch_dot",
            "set_floatx",
            "get_output_shape_at",
            "concatenate",
            "set_epsilon",
            "reshape",
            "manual_variable_initialization",
            "lesser_equal",
            "fit",
            "func_dump",
            "test_on_batch",
            "asymmetric_spatial_2d_padding",
            "get_config",
            "set_learning_phase",
            "lesser",
            "image_dim_ordering",
            "eye",
            "print_tensor",
            "softplus",
            "fit_on_texts",
            "_fix_unknown_dimension",
            "predict",
            "conv_output_length",
            "add_inbound_node",
            "get_uid",
            "std",
            "spatial_3d_padding",
            "merge",
            "build",
            "backend",
            "in_train_phase",
            "call",
            "permute_dimensions",
            "sequences_to_matrix",
            "l2_normalize",
            "normalize_batch_in_training",
            "add_weight",
            "fit_generator",
            "ones_like",
            "keras_test",
            "output_shape",
            "sigmoid",
            "prod",
            "random_normal_variable",
            "sign",
            "get_session",
            "predict_proba",
            "repeat_elements",
            "asymmetric_temporal_padding",
            "log",
            "make_sampling_table",
            "stop_gradient",
            "to_list",
            "ctc_batch_cost",
            "sin",
            "relu",
            "switch",
            "count_params",
            "var",
            "any",
            "set_image_dim_ordering",
            "batch_get_value",
            "clear_session",
            "score",
            "function",
            "_old_batch_normalization",
            "set_weights",
            "zeros_like",
            "get_output_mask_at",
            "input",
            "predict_generator",
            "softsign",
            "load_weights",
            "binary_crossentropy",
            "get_source_inputs",
            "texts_to_matrix",
            "preprocess_input",
            "_cond",
            "softmax",
            "batch_flatten",
            "_get_node_attribute_at_index",
            "elu",
            "square",
            "sparse_categorical_crossentropy",
            "input_mask",
            "conv_block",
            "squeeze",
            "input_shape",
            "model_from_yaml",
            "__call__",
            "epsilon",
            "learning_phase",
            "abs",
            "placeholder",
            "all",
            "clip",
            "mean",
            "ctc_decode",
            "model_from_json",
            "dot",
            "func_load",
            "floatx",
            "variable",
            "exp",
            "in_test_phase",
            "state_updates",
            "one_hot",
            "get_input_mask_at",
            "to_categorical",
            "resize_images",
            "max",
            "sum",
            "predict_on_batch",
            "_old_normalize_batch_in_training",
            "binary_logloss",
            "train_on_batch",
            "minimum",
            "he_normal",
            "foldr",
            "is_keras_tensor",
            "argmax",
            "_arguments_validation",
            "zeros",
            "set_value",
            "to_yaml",
            "to_dense",
            "pow",
            "get_file",
            "argmin",
            "add",
            "conv1d",
            "round",
            "output_mask",
            "random_uniform_variable",
            "temporal_padding",
            "set_session",
            "repeat",
            "load_weights_from_hdf5_group_by_name",
            "layer_test",
            "Xception",
            "get_value",
            "is_sparse",
            "to_json",
            "transpose",
            "uses_learning_phase",
            "ndim",
            "load_weights_from_hdf5_group",
            "get_output_at",
            "predict_classes",
            "pad_sequences",
            "gradients",
            "MusicTaggerCRNN",
            "time_distributed_dense",
            "from_config",
            "glorot_normal",
            "convert_kernel",
            "assert_input_compatibility",
            "arange",
            "min",
            "ResNet50",
            "greater_equal",
            "layer_from_config",
            "set_params",
            "filter_sk_params",
            "not_equal",
            "gather",
            "maximum"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 144,
          "file_complexity": 41,
          "file_token_count": 1078,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif isinstance(identifier, dict):\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef func_dump(func):\n    '''Serialize user defined function.'''\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    '''Deserialize user defined function.'''\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n\n    def __init__(self, target, width=30, verbose=1, interval=0.01):\n        '''Dislays a progress bar.\n\n        # Arguments:\n            target: Total number of steps expected.\n            interval: Minimum visual progress update interval (in seconds).\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[], force=False):\n        '''Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif isinstance(identifier, dict):\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef func_dump(func):\n    \"\"\"Serialize user defined function.\n    \"\"\"\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    \"\"\"Deserialize user defined function.\"\"\"\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n\n    def __init__(self, target, width=30, verbose=1, interval=0.01):\n        \"\"\"Dislays a progress bar.\n\n        # Arguments:\n            target: Total number of steps expected.\n            interval: Minimum visual progress update interval (in seconds).\n        \"\"\"\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[], force=False):\n        \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_patch": "@@ -36,7 +36,8 @@ def make_tuple(*args):\n \n \n def func_dump(func):\n-    '''Serialize user defined function.'''\n+    \"\"\"Serialize user defined function.\n+    \"\"\"\n     code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n     defaults = func.__defaults__\n     if func.__closure__:\n@@ -47,7 +48,7 @@ def func_dump(func):\n \n \n def func_load(code, defaults=None, closure=None, globs=None):\n-    '''Deserialize user defined function.'''\n+    \"\"\"Deserialize user defined function.\"\"\"\n     if isinstance(code, (tuple, list)):  # unpack previous dump\n         code, defaults, closure = code\n     code = marshal.loads(code.encode('raw_unicode_escape'))\n@@ -62,12 +63,12 @@ def func_load(code, defaults=None, closure=None, globs=None):\n class Progbar(object):\n \n     def __init__(self, target, width=30, verbose=1, interval=0.01):\n-        '''Dislays a progress bar.\n+        \"\"\"Dislays a progress bar.\n \n         # Arguments:\n             target: Total number of steps expected.\n             interval: Minimum visual progress update interval (in seconds).\n-        '''\n+        \"\"\"\n         self.width = width\n         self.target = target\n         self.sum_values = {}\n@@ -80,14 +81,14 @@ class Progbar(object):\n         self.verbose = verbose\n \n     def update(self, current, values=[], force=False):\n-        '''Updates the progress bar.\n+        \"\"\"Updates the progress bar.\n \n         # Arguments\n             current: Index of current step.\n             values: List of tuples (name, value_for_last_step).\n                 The progress bar will display averages for these values.\n             force: Whether to force visual progress update.\n-        '''\n+        \"\"\"\n         for k, v in values:\n             if k not in self.sum_values:\n                 self.sum_values[k] = [v * (current - self.seen_so_far),\n",
          "files_name_in_blame_commit": [
            "embeddings.py",
            "vgg19.py",
            "convolutional_recurrent.py",
            "scikit_learn.py",
            "noise.py",
            "generic_utils.py",
            "topology.py",
            "theano_backend.py",
            "text.py",
            "__init__.py",
            "audio_conv_utils.py",
            "inception_v3.py",
            "local.py",
            "core.py",
            "recurrent.py",
            "common.py",
            "sequence.py",
            "models.py",
            "layer_utils.py",
            "music_tagger_crnn.py",
            "np_utils.py",
            "pooling.py",
            "vgg16.py",
            "normalization.py",
            "initializations.py",
            "io_utils.py",
            "objectives.py",
            "test_utils.py",
            "wrappers.py",
            "optimizers.py",
            "imdb.py",
            "data_utils.py",
            "image.py",
            "convolutional.py",
            "advanced_activations.py",
            "resnet50.py",
            "tensorflow_backend.py",
            "xception.py",
            "reuters.py"
          ]
        }
      },
      "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7": {
        "commit": {
          "commit_id": "edae1785327dd7a418ac06c2fe85a8c1f6ea05b7",
          "commit_message": "Style fixes in utils.",
          "commit_author": "Francois Chollet",
          "commit_date": "2016-12-13 19:13:04",
          "commit_parent": "a0a0308061bcedd2913a8b755297f12958a8f4bd"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[], force=False):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n            @param force: force visual progress update\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if type(self.sum_values[k]) is list:\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_code_after": "def update(self, current, values=[], force=False):\n    \"\"\"Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if isinstance(self.sum_values[k], list):\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_before_start_line": 92,
          "function_before_end_line": 176,
          "function_after_start_line": 82,
          "function_after_end_line": 169,
          "function_before_token_count": 582,
          "function_after_token_count": 582,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "display_table",
            "make_tuple",
            "func_load",
            "add",
            "func_dump",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "display_table",
            "make_tuple",
            "convert_all_kernels_in_model",
            "layer_from_config",
            "func_load",
            "add",
            "func_dump",
            "print_summary",
            "get_from_module"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "func_reconstruct_closure",
            "func_load",
            "get_from_module"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "func_reconstruct_closure",
            "func_load",
            "print_summary",
            "get_from_module"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 144,
          "file_complexity": 41,
          "file_token_count": 1078,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif type(identifier) is dict:\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef func_dump(func):\n    '''Serialize user defined function.'''\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    '''Deserialize user defined function.'''\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if closure is not None:\n        closure = func_reconstruct_closure(closure)\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs, name=code.co_name, argdefs=defaults, closure=closure)\n\n\ndef func_reconstruct_closure(values):\n    '''Deserialization helper that reconstructs a closure.'''\n    nums = range(len(values))\n    src = [\"def func(arg):\"]\n    src += [\"  _%d = arg[%d]\" % (n, n) for n in nums]\n    src += [\"  return lambda:(%s)\" % ','.join([\"_%d\" % n for n in nums]), \"\"]\n    src = '\\n'.join(src)\n    try:\n        exec(src, globals())\n    except:\n        raise SyntaxError(src)\n    return func(values).__closure__\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1, interval=0.01):\n        '''\n            @param target: total number of steps expected\n            @param interval: minimum visual progress update interval (in seconds)\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[], force=False):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n            @param force: force visual progress update\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if type(self.sum_values[k]) is list:\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\nimport marshal\nimport types as python_types\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif isinstance(identifier, dict):\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise ValueError('Invalid ' + str(module_name) + ': ' +\n                             str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef func_dump(func):\n    '''Serialize user defined function.'''\n    code = marshal.dumps(func.__code__).decode('raw_unicode_escape')\n    defaults = func.__defaults__\n    if func.__closure__:\n        closure = tuple(c.cell_contents for c in func.__closure__)\n    else:\n        closure = None\n    return code, defaults, closure\n\n\ndef func_load(code, defaults=None, closure=None, globs=None):\n    '''Deserialize user defined function.'''\n    if isinstance(code, (tuple, list)):  # unpack previous dump\n        code, defaults, closure = code\n    code = marshal.loads(code.encode('raw_unicode_escape'))\n    if globs is None:\n        globs = globals()\n    return python_types.FunctionType(code, globs,\n                                     name=code.co_name,\n                                     argdefs=defaults,\n                                     closure=closure)\n\n\nclass Progbar(object):\n\n    def __init__(self, target, width=30, verbose=1, interval=0.01):\n        '''Dislays a progress bar.\n\n        # Arguments:\n            target: Total number of steps expected.\n            interval: Minimum visual progress update interval (in seconds).\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[], force=False):\n        '''Updates the progress bar.\n\n        # Arguments\n            current: Index of current step.\n            values: List of tuples (name, value_for_last_step).\n                The progress bar will display averages for these values.\n            force: Whether to force visual progress update.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far),\n                                      current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write('\\b' * prev_total_width)\n            sys.stdout.write('\\r')\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if isinstance(self.sum_values[k], list):\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * ' ')\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write('\\n')\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_patch": "@@ -12,22 +12,22 @@ def get_from_module(identifier, module_params, module_name,\n     if isinstance(identifier, six.string_types):\n         res = module_params.get(identifier)\n         if not res:\n-            raise Exception('Invalid ' + str(module_name) + ': ' +\n-                            str(identifier))\n+            raise ValueError('Invalid ' + str(module_name) + ': ' +\n+                             str(identifier))\n         if instantiate and not kwargs:\n             return res()\n         elif instantiate and kwargs:\n             return res(**kwargs)\n         else:\n             return res\n-    elif type(identifier) is dict:\n+    elif isinstance(identifier, dict):\n         name = identifier.pop('name')\n         res = module_params.get(name)\n         if res:\n             return res(**identifier)\n         else:\n-            raise Exception('Invalid ' + str(module_name) + ': ' +\n-                            str(identifier))\n+            raise ValueError('Invalid ' + str(module_name) + ': ' +\n+                             str(identifier))\n     return identifier\n \n \n@@ -51,32 +51,22 @@ def func_load(code, defaults=None, closure=None, globs=None):\n     if isinstance(code, (tuple, list)):  # unpack previous dump\n         code, defaults, closure = code\n     code = marshal.loads(code.encode('raw_unicode_escape'))\n-    if closure is not None:\n-        closure = func_reconstruct_closure(closure)\n     if globs is None:\n         globs = globals()\n-    return python_types.FunctionType(code, globs, name=code.co_name, argdefs=defaults, closure=closure)\n-\n-\n-def func_reconstruct_closure(values):\n-    '''Deserialization helper that reconstructs a closure.'''\n-    nums = range(len(values))\n-    src = [\"def func(arg):\"]\n-    src += [\"  _%d = arg[%d]\" % (n, n) for n in nums]\n-    src += [\"  return lambda:(%s)\" % ','.join([\"_%d\" % n for n in nums]), \"\"]\n-    src = '\\n'.join(src)\n-    try:\n-        exec(src, globals())\n-    except:\n-        raise SyntaxError(src)\n-    return func(values).__closure__\n+    return python_types.FunctionType(code, globs,\n+                                     name=code.co_name,\n+                                     argdefs=defaults,\n+                                     closure=closure)\n \n \n class Progbar(object):\n+\n     def __init__(self, target, width=30, verbose=1, interval=0.01):\n-        '''\n-            @param target: total number of steps expected\n-            @param interval: minimum visual progress update interval (in seconds)\n+        '''Dislays a progress bar.\n+\n+        # Arguments:\n+            target: Total number of steps expected.\n+            interval: Minimum visual progress update interval (in seconds).\n         '''\n         self.width = width\n         self.target = target\n@@ -90,15 +80,18 @@ class Progbar(object):\n         self.verbose = verbose\n \n     def update(self, current, values=[], force=False):\n-        '''\n-            @param current: index of current step\n-            @param values: list of tuples (name, value_for_last_step).\n-            The progress bar will display averages for these values.\n-            @param force: force visual progress update\n+        '''Updates the progress bar.\n+\n+        # Arguments\n+            current: Index of current step.\n+            values: List of tuples (name, value_for_last_step).\n+                The progress bar will display averages for these values.\n+            force: Whether to force visual progress update.\n         '''\n         for k, v in values:\n             if k not in self.sum_values:\n-                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n+                self.sum_values[k] = [v * (current - self.seen_so_far),\n+                                      current - self.seen_so_far]\n                 self.unique_values.append(k)\n             else:\n                 self.sum_values[k][0] += v * (current - self.seen_so_far)\n@@ -111,8 +104,8 @@ class Progbar(object):\n                 return\n \n             prev_total_width = self.total_width\n-            sys.stdout.write(\"\\b\" * prev_total_width)\n-            sys.stdout.write(\"\\r\")\n+            sys.stdout.write('\\b' * prev_total_width)\n+            sys.stdout.write('\\r')\n \n             numdigits = int(np.floor(np.log10(self.target))) + 1\n             barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n@@ -142,7 +135,7 @@ class Progbar(object):\n                 info += ' - %ds' % (now - self.start)\n             for k in self.unique_values:\n                 info += ' - %s:' % k\n-                if type(self.sum_values[k]) is list:\n+                if isinstance(self.sum_values[k], list):\n                     avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                     if abs(avg) > 1e-3:\n                         info += ' %.4f' % avg\n@@ -153,13 +146,13 @@ class Progbar(object):\n \n             self.total_width += len(info)\n             if prev_total_width > self.total_width:\n-                info += ((prev_total_width - self.total_width) * \" \")\n+                info += ((prev_total_width - self.total_width) * ' ')\n \n             sys.stdout.write(info)\n             sys.stdout.flush()\n \n             if current >= self.target:\n-                sys.stdout.write(\"\\n\")\n+                sys.stdout.write('\\n')\n \n         if self.verbose == 2:\n             if current >= self.target:\n",
          "files_name_in_blame_commit": [
            "generic_utils.py",
            "layer_utils.py"
          ]
        }
      },
      "5a71090476da28a7258ed8653bf89d831d03cf22": {
        "commit": {
          "commit_id": "5a71090476da28a7258ed8653bf89d831d03cf22",
          "commit_message": "limit progress bar update rate (#2860)\n\n* limit progress bar update rate\r\n\r\nLimit progress bar update rate in verbose=1 mode. This patch allows to\r\nreduce terminal I/O throughput while keeping reasonable high visual\r\nupdate rate (defaults to 100 refreshes per second). It helps greatly\r\nwhen working with large but simple data sets with small batches, which\r\nleads to millions of relatively useless screen updates per second. Also\r\nit helps to keep network traffic at reasonable rates, which\r\nexceptionally useful within laggy networking conditions when using\r\nkeras over telnet/ssh, and improve web browser responsibility when\r\nusing keras within Jupyter Notebook.\r\n\r\n* add docstrings for 'interval' and 'force' arguments",
          "commit_author": "Andrew Stromnov",
          "commit_date": "2016-06-02 13:06:37",
          "commit_parent": "76cae0ec4463d350379e1da312386d97996040c4"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if type(self.sum_values[k]) is list:\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')",
          "function_code_after": "def update(self, current, values=[], force=False):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n            @param force: force visual progress update\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        if not force and now - self.last_update < self.interval:\n            return\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if type(self.sum_values[k]) is list:\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')\n    self.last_update = now",
          "function_before_start_line": 50,
          "function_before_end_line": 128,
          "function_after_start_line": 53,
          "function_after_end_line": 137,
          "function_before_token_count": 556,
          "function_after_token_count": 582,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "display_table",
            "make_tuple",
            "add",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "on_batch_begin",
            "on_batch_end",
            "_set_params",
            "on_epoch_end",
            "display_table",
            "make_tuple",
            "on_train_end",
            "get_from_module",
            "append",
            "on_epoch_begin",
            "add",
            "_set_model",
            "on_train_begin"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "on_epoch_end",
            "__init__"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 123,
          "file_complexity": 35,
          "file_token_count": 931,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif type(identifier) is dict:\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if type(self.sum_values[k]) is list:\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    elif type(identifier) is dict:\n        name = identifier.pop('name')\n        res = module_params.get(name)\n        if res:\n            return res(**identifier)\n        else:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1, interval=0.01):\n        '''\n            @param target: total number of steps expected\n            @param interval: minimum visual progress update interval (in seconds)\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.last_update = 0\n        self.interval = interval\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[], force=False):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n            @param force: force visual progress update\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            if not force and (now - self.last_update) < self.interval:\n                return\n\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current) / self.target\n            prog_width = int(self.width * prog)\n            if prog_width > 0:\n                bar += ('=' * (prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.' * (self.width - prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit * (self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if type(self.sum_values[k]) is list:\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width - self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n        self.last_update = now\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far + n, values)\n\n\ndef display_table(rows, positions):\n\n    def display_row(objects, positions):\n        line = ''\n        for i in range(len(objects)):\n            line += str(objects[i])\n            line = line[:positions[i]]\n            line += ' ' * (positions[i] - len(line))\n        print(line)\n\n    for objects in rows:\n        display_row(objects, positions)\n",
          "file_patch": "@@ -34,24 +34,28 @@ def make_tuple(*args):\n \n \n class Progbar(object):\n-    def __init__(self, target, width=30, verbose=1):\n+    def __init__(self, target, width=30, verbose=1, interval=0.01):\n         '''\n             @param target: total number of steps expected\n+            @param interval: minimum visual progress update interval (in seconds)\n         '''\n         self.width = width\n         self.target = target\n         self.sum_values = {}\n         self.unique_values = []\n         self.start = time.time()\n+        self.last_update = 0\n+        self.interval = interval\n         self.total_width = 0\n         self.seen_so_far = 0\n         self.verbose = verbose\n \n-    def update(self, current, values=[]):\n+    def update(self, current, values=[], force=False):\n         '''\n             @param current: index of current step\n             @param values: list of tuples (name, value_for_last_step).\n             The progress bar will display averages for these values.\n+            @param force: force visual progress update\n         '''\n         for k, v in values:\n             if k not in self.sum_values:\n@@ -64,6 +68,9 @@ class Progbar(object):\n \n         now = time.time()\n         if self.verbose == 1:\n+            if not force and (now - self.last_update) < self.interval:\n+                return\n+\n             prev_total_width = self.total_width\n             sys.stdout.write(\"\\b\" * prev_total_width)\n             sys.stdout.write(\"\\r\")\n@@ -127,6 +134,8 @@ class Progbar(object):\n                         info += ' %.4e' % avg\n                 sys.stdout.write(info + \"\\n\")\n \n+        self.last_update = now\n+\n     def add(self, n, values=[]):\n         self.update(self.seen_so_far + n, values)\n \n",
          "files_name_in_blame_commit": [
            "generic_utils.py",
            "callbacks.py"
          ]
        }
      },
      "729f0765da577a4ebd879331f651b6d241a10632": {
        "commit": {
          "commit_id": "729f0765da577a4ebd879331f651b6d241a10632",
          "commit_message": "Progbar: scientific notation only for small values",
          "commit_author": "Francois Chollet",
          "commit_date": "2015-12-29 16:00:39",
          "commit_parent": "161b31dcf360b32eba5ac769c4f27f0adacb951b"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if type(self.sum_values[k]) is list:\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')",
          "function_code_after": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if type(self.sum_values[k]) is list:\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if abs(avg) > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')",
          "function_before_start_line": 42,
          "function_before_end_line": 120,
          "function_after_start_line": 42,
          "function_after_end_line": 120,
          "function_before_token_count": 553,
          "function_after_token_count": 556,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "get_from_module"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 100,
          "file_complexity": 27,
          "file_token_count": 758,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if type(self.sum_values[k]) is list:\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name,\n                    instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' +\n                            str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if type(self.sum_values[k]) is list:\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if abs(avg) > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_patch": "@@ -90,7 +90,7 @@ class Progbar(object):\n                 info += ' - %s:' % k\n                 if type(self.sum_values[k]) is list:\n                     avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n-                    if avg > 1e-3:\n+                    if abs(avg) > 1e-3:\n                         info += ' %.4f' % avg\n                     else:\n                         info += ' %.4e' % avg\n",
          "files_name_in_blame_commit": [
            "generic_utils.py"
          ]
        }
      },
      "f200b190562d78c684cf019c1b9c4f3ccc03d3de": {
        "commit": {
          "commit_id": "f200b190562d78c684cf019c1b9c4f3ccc03d3de",
          "commit_message": "Increased Progbar precision",
          "commit_author": "smauq",
          "commit_date": "2015-12-08 03:08:16",
          "commit_parent": "526c8a58b3779d066015dc21066bddbd0aff7dc7"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            if type(self.sum_values[k]) is list:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n            else:\n                info += ' - %s: %s' % (k, self.sum_values[k])\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n            sys.stdout.write(info + '\\n')",
          "function_code_after": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s:' % k\n            if type(self.sum_values[k]) is list:\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            else:\n                info += ' %s' % self.sum_values[k]\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                if avg > 0.001:\n                    info += ' %.4f' % avg\n                else:\n                    info += ' %.4e' % avg\n            sys.stdout.write(info + '\\n')",
          "function_before_start_line": 62,
          "function_before_end_line": 130,
          "function_after_start_line": 62,
          "function_after_end_line": 140,
          "function_before_token_count": 521,
          "function_after_token_count": 553,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "printv",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "printv",
            "get_from_module"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 118,
          "file_complexity": 34,
          "file_token_count": 901,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef printv(v, prefix=''):\n    if type(v) == dict:\n        if 'name' in v:\n            print(prefix + '#' + v['name'])\n            del v['name']\n        prefix += '...'\n        for nk, nv in v.items():\n            if type(nv) in [dict, list]:\n                print(prefix + nk + ':')\n                printv(nv, prefix)\n            else:\n                print(prefix + nk + ':' + str(nv))\n    elif type(v) == list:\n        prefix += '...'\n        for i, nv in enumerate(v):\n            print(prefix + '#' + str(i))\n            printv(nv, prefix)\n    else:\n        prefix += '...'\n        print(prefix + str(v))\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                if type(self.sum_values[k]) is list:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                else:\n                    info += ' - %s: %s' % (k, self.sum_values[k])\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                sys.stdout.write(info + \"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef printv(v, prefix=''):\n    if type(v) == dict:\n        if 'name' in v:\n            print(prefix + '#' + v['name'])\n            del v['name']\n        prefix += '...'\n        for nk, nv in v.items():\n            if type(nv) in [dict, list]:\n                print(prefix + nk + ':')\n                printv(nv, prefix)\n            else:\n                print(prefix + nk + ':' + str(nv))\n    elif type(v) == list:\n        prefix += '...'\n        for i, nv in enumerate(v):\n            print(prefix + '#' + str(i))\n            printv(nv, prefix)\n    else:\n        prefix += '...'\n        print(prefix + str(v))\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s:' % k\n                if type(self.sum_values[k]) is list:\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                else:\n                    info += ' %s' % self.sum_values[k]\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s:' % k\n                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n                    if avg > 1e-3:\n                        info += ' %.4f' % avg\n                    else:\n                        info += ' %.4e' % avg\n                sys.stdout.write(info + \"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_patch": "@@ -107,10 +107,15 @@ class Progbar(object):\n             else:\n                 info += ' - %ds' % (now - self.start)\n             for k in self.unique_values:\n+                info += ' - %s:' % k\n                 if type(self.sum_values[k]) is list:\n-                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n+                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n+                    if avg > 1e-3:\n+                        info += ' %.4f' % avg\n+                    else:\n+                        info += ' %.4e' % avg\n                 else:\n-                    info += ' - %s: %s' % (k, self.sum_values[k])\n+                    info += ' %s' % self.sum_values[k]\n \n             self.total_width += len(info)\n             if prev_total_width > self.total_width:\n@@ -126,7 +131,12 @@ class Progbar(object):\n             if current >= self.target:\n                 info = '%ds' % (now - self.start)\n                 for k in self.unique_values:\n-                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n+                    info += ' - %s:' % k\n+                    avg = self.sum_values[k][0] / max(1, self.sum_values[k][1])\n+                    if avg > 1e-3:\n+                        info += ' %.4f' % avg\n+                    else:\n+                        info += ' %.4e' % avg\n                 sys.stdout.write(info + \"\\n\")\n \n     def add(self, n, values=[]):\n",
          "files_name_in_blame_commit": [
            "generic_utils.py"
          ]
        }
      },
      "b9403cb2621a048a885e30f5a9527a14f061a0a6": {
        "commit": {
          "commit_id": "b9403cb2621a048a885e30f5a9527a14f061a0a6",
          "commit_message": "Add a bit of flexibility in Progbar.update\n\nBy allowing sum_values[k] to be other things than lists, it makes it easier for children classes to print \"any value\" (in my case, a timedelta object).",
          "commit_author": "Rodrigo Benenson",
          "commit_date": "2015-09-20 15:26:27",
          "commit_parent": "e379fff4258a39f3617df256d2a50adc301109ef"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n            sys.stdout.write(info + '\\n')",
          "function_code_after": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * prev_total_width)\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            if type(self.sum_values[k]) is list:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n            else:\n                info += ' - %s: %s' % (k, self.sum_values[k])\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n            sys.stdout.write(info + '\\n')",
          "function_before_start_line": 62,
          "function_before_end_line": 127,
          "function_after_start_line": 62,
          "function_after_end_line": 130,
          "function_before_token_count": 492,
          "function_after_token_count": 521,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "printv",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "printv",
            "get_from_module"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 108,
          "file_complexity": 32,
          "file_token_count": 869,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef printv(v, prefix=''):\n    if type(v) == dict:\n        if 'name' in v:\n            print(prefix + '#' + v['name'])\n            del v['name']\n        prefix += '...'\n        for nk, nv in v.items():\n            if type(nv) in [dict, list]:\n                print(prefix + nk + ':')\n                printv(nv, prefix)\n            else:\n                print(prefix + nk + ':' + str(nv))\n    elif type(v) == list:\n        prefix += '...'\n        for i, nv in enumerate(v):\n            print(prefix + '#' + str(i))\n            printv(nv, prefix)\n    else:\n        prefix += '...'\n        print(prefix + str(v))\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                sys.stdout.write(info + \"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\nimport six\n\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False, kwargs=None):\n    if isinstance(identifier, six.string_types):\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate and not kwargs:\n            return res()\n        elif instantiate and kwargs:\n            return res(**kwargs)\n        else:\n            return res\n    return identifier\n\n\ndef make_tuple(*args):\n    return args\n\n\ndef printv(v, prefix=''):\n    if type(v) == dict:\n        if 'name' in v:\n            print(prefix + '#' + v['name'])\n            del v['name']\n        prefix += '...'\n        for nk, nv in v.items():\n            if type(nv) in [dict, list]:\n                print(prefix + nk + ':')\n                printv(nv, prefix)\n            else:\n                print(prefix + nk + ':' + str(nv))\n    elif type(v) == list:\n        prefix += '...'\n        for i, nv in enumerate(v):\n            print(prefix + '#' + str(i))\n            printv(nv, prefix)\n    else:\n        prefix += '...'\n        print(prefix + str(v))\n\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current - self.seen_so_far)\n                self.sum_values[k][1] += (current - self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * prev_total_width)\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n\n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                if type(self.sum_values[k]) is list:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                else:\n                    info += ' - %s: %s' % (k, self.sum_values[k])\n                \n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n                sys.stdout.write(info + \"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_patch": "@@ -107,8 +107,11 @@ class Progbar(object):\n             else:\n                 info += ' - %ds' % (now - self.start)\n             for k in self.unique_values:\n-                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n-\n+                if type(self.sum_values[k]) is list:\n+                    info += ' - %s: %.4f' % (k, self.sum_values[k][0] / max(1, self.sum_values[k][1]))\n+                else:\n+                    info += ' - %s: %s' % (k, self.sum_values[k])\n+                \n             self.total_width += len(info)\n             if prev_total_width > self.total_width:\n                 info += ((prev_total_width-self.total_width) * \" \")\n",
          "files_name_in_blame_commit": [
            "generic_utils.py"
          ]
        }
      },
      "77fb6a3873ca6bd82a7dc1620eeb706c66177fc5": {
        "commit": {
          "commit_id": "77fb6a3873ca6bd82a7dc1620eeb706c66177fc5",
          "commit_message": "Pad the progress bar strings so formatting stays when going from 99 to 100, etc.",
          "commit_author": "Stephen Roller",
          "commit_date": "2015-05-18 15:52:04",
          "commit_parent": "a9922197f2e113c10cbebb2a0bc0665ba676c0e8"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * (self.total_width + 1))\n        sys.stdout.write('\\r')\n        bar = '%d/%d [' % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n            sys.stdout.write(info + '\\n')",
          "function_code_after": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * (self.total_width + 1))\n        sys.stdout.write('\\r')\n        numdigits = int(np.floor(np.log10(self.target))) + 1\n        barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n        bar = barstr % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n            sys.stdout.write(info + '\\n')",
          "function_before_start_line": 55,
          "function_before_end_line": 118,
          "function_after_start_line": 55,
          "function_after_end_line": 120,
          "function_before_token_count": 459,
          "function_after_token_count": 488,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "printv",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "printv",
            "get_from_module"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 102,
          "file_complexity": 28,
          "file_token_count": 814,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False):\n    if type(identifier) is str:\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate:\n            return res()\n        else:\n            return res\n    return identifier\n\ndef make_tuple(*args):\n    return args\n\ndef printv(v, prefix=''):\n    if type(v) == dict:\n        if 'name' in v:\n            print(prefix + '#' + v['name'])\n            del v['name']\n        prefix += '...'\n        for nk, nv in v.items():\n            if type(nv) in [dict, list]:\n                print(prefix + nk + ':')\n                printv(nv, prefix)\n            else:\n                print(prefix + nk + ':' + str(nv))\n    elif type(v) == list:\n        prefix += '...'\n        for i, nv in enumerate(v):\n            print(prefix + '#' + str(i))\n            printv(nv, prefix) \n    else:\n        prefix += '...'\n        print(prefix + str(v))\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current-self.seen_so_far), current-self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current-self.seen_so_far)\n                self.sum_values[k][1] += (current-self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * (self.total_width+1))\n            sys.stdout.write(\"\\r\")\n\n            bar = '%d/%d [' % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n            \n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n                sys.stdout.write(info + \"\\n\")\n\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False):\n    if type(identifier) is str:\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate:\n            return res()\n        else:\n            return res\n    return identifier\n\ndef make_tuple(*args):\n    return args\n\ndef printv(v, prefix=''):\n    if type(v) == dict:\n        if 'name' in v:\n            print(prefix + '#' + v['name'])\n            del v['name']\n        prefix += '...'\n        for nk, nv in v.items():\n            if type(nv) in [dict, list]:\n                print(prefix + nk + ':')\n                printv(nv, prefix)\n            else:\n                print(prefix + nk + ':' + str(nv))\n    elif type(v) == list:\n        prefix += '...'\n        for i, nv in enumerate(v):\n            print(prefix + '#' + str(i))\n            printv(nv, prefix) \n    else:\n        prefix += '...'\n        print(prefix + str(v))\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current-self.seen_so_far), current-self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current-self.seen_so_far)\n                self.sum_values[k][1] += (current-self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * (self.total_width+1))\n            sys.stdout.write(\"\\r\")\n\n            numdigits = int(np.floor(np.log10(self.target))) + 1\n            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n            bar = barstr % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n            \n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n                sys.stdout.write(info + \"\\n\")\n\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_patch": "@@ -73,7 +73,9 @@ class Progbar(object):\n             sys.stdout.write(\"\\b\" * (self.total_width+1))\n             sys.stdout.write(\"\\r\")\n \n-            bar = '%d/%d [' % (current, self.target)\n+            numdigits = int(np.floor(np.log10(self.target))) + 1\n+            barstr = '%%%dd/%%%dd [' % (numdigits, numdigits)\n+            bar = barstr % (current, self.target)\n             prog = float(current)/self.target\n             prog_width = int(self.width*prog)\n             if prog_width > 0:\n",
          "files_name_in_blame_commit": [
            "generic_utils.py"
          ]
        }
      },
      "9390d63056e9e787a1942bb74b582d3224c75892": {
        "commit": {
          "commit_id": "9390d63056e9e787a1942bb74b582d3224c75892",
          "commit_message": "model.fit() return training history",
          "commit_author": "fchollet",
          "commit_date": "2015-05-09 18:14:19",
          "commit_parent": "376373d159d9a5e3ff0c6a3919b4003028276faa"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v, 1]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * (self.total_width + 1))\n        sys.stdout.write('\\r')\n        bar = '%d/%d [' % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        self.seen_so_far = current\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n            sys.stdout.write(info + '\\n')",
          "function_code_after": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v * (current - self.seen_so_far), current - self.seen_so_far]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    self.seen_so_far = current\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * (self.total_width + 1))\n        sys.stdout.write('\\r')\n        bar = '%d/%d [' % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n            sys.stdout.write(info + '\\n')",
          "function_before_start_line": 34,
          "function_before_end_line": 97,
          "function_after_start_line": 34,
          "function_after_end_line": 97,
          "function_before_token_count": 447,
          "function_after_token_count": 459,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "standardize_y",
            "make_tuple",
            "save_weights",
            "fit",
            "evaluate",
            "get_from_module",
            "get_output",
            "test",
            "ndim_tensor",
            "load_weights",
            "add",
            "make_batches",
            "predict_classes",
            "__init__",
            "update",
            "train",
            "describe",
            "predict_proba",
            "compile"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "fit"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 80,
          "file_complexity": 21,
          "file_token_count": 639,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False):\n    if type(identifier) is str:\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate:\n            return res()\n        else:\n            return res\n    return identifier\n\ndef make_tuple(*args):\n    return args\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v, 1]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current-self.seen_so_far)\n                self.sum_values[k][1] += (current-self.seen_so_far)\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * (self.total_width+1))\n            sys.stdout.write(\"\\r\")\n\n            bar = '%d/%d [' % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n            \n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n            self.seen_so_far = current\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n                sys.stdout.write(info + \"\\n\")\n\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False):\n    if type(identifier) is str:\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate:\n            return res()\n        else:\n            return res\n    return identifier\n\ndef make_tuple(*args):\n    return args\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v * (current-self.seen_so_far), current-self.seen_so_far]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current-self.seen_so_far)\n                self.sum_values[k][1] += (current-self.seen_so_far)\n        self.seen_so_far = current\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * (self.total_width+1))\n            sys.stdout.write(\"\\r\")\n\n            bar = '%d/%d [' % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n            \n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n                sys.stdout.write(info + \"\\n\")\n\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_patch": "@@ -39,11 +39,12 @@ class Progbar(object):\n         '''\n         for k, v in values:\n             if k not in self.sum_values:\n-                self.sum_values[k] = [v, 1]\n+                self.sum_values[k] = [v * (current-self.seen_so_far), current-self.seen_so_far]\n                 self.unique_values.append(k)\n             else:\n                 self.sum_values[k][0] += v * (current-self.seen_so_far)\n                 self.sum_values[k][1] += (current-self.seen_so_far)\n+        self.seen_so_far = current\n \n         now = time.time()\n         if self.verbose == 1:\n@@ -84,7 +85,6 @@ class Progbar(object):\n \n             sys.stdout.write(info)\n             sys.stdout.flush()\n-            self.seen_so_far = current\n \n             if current >= self.target:\n                 sys.stdout.write(\"\\n\")\n",
          "files_name_in_blame_commit": [
            "models.py",
            "generic_utils.py"
          ]
        }
      },
      "c224482190b8d4a057f9546753b8331e18a6d953": {
        "commit": {
          "commit_id": "c224482190b8d4a057f9546753b8331e18a6d953",
          "commit_message": "Move verbosity modes to progbar. Cleaner models.py",
          "commit_author": "fchollet",
          "commit_date": "2015-04-18 17:15:33",
          "commit_parent": "bdc1de1a75f0fa9e7840063f7f7bb366a590ea63"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v, 1]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    prev_total_width = self.total_width\n    sys.stdout.write('\\x08' * (self.total_width + 1))\n    bar = '%d/%d [' % (current, self.target)\n    prog = float(current) / self.target\n    prog_width = int(self.width * prog)\n    if prog_width > 0:\n        bar += '=' * (prog_width - 1)\n        if current < self.target:\n            bar += '>'\n        else:\n            bar += '='\n    bar += '.' * (self.width - prog_width)\n    bar += ']'\n    sys.stdout.write(bar)\n    self.total_width = len(bar)\n    now = time.time()\n    if current:\n        time_per_unit = (now - self.start) / current\n    else:\n        time_per_unit = 0\n    eta = time_per_unit * (self.target - current)\n    info = ''\n    if current < self.target:\n        info += ' - ETA: %ds' % eta\n    else:\n        info += ' - %ds' % (now - self.start)\n    for k in self.unique_values:\n        info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n    self.total_width += len(info)\n    if prev_total_width > self.total_width:\n        info += (prev_total_width - self.total_width) * ' '\n    sys.stdout.write(info)\n    sys.stdout.flush()\n    self.seen_so_far = current\n    if current >= self.target:\n        sys.stdout.write('\\n')",
          "function_code_after": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v, 1]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    now = time.time()\n    if self.verbose == 1:\n        prev_total_width = self.total_width\n        sys.stdout.write('\\x08' * (self.total_width + 1))\n        bar = '%d/%d [' % (current, self.target)\n        prog = float(current) / self.target\n        prog_width = int(self.width * prog)\n        if prog_width > 0:\n            bar += '=' * (prog_width - 1)\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += '.' * (self.width - prog_width)\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit * (self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += (prev_total_width - self.total_width) * ' '\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        self.seen_so_far = current\n        if current >= self.target:\n            sys.stdout.write('\\n')\n    if self.verbose == 2:\n        if current >= self.target:\n            info = '%ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n            sys.stdout.write(info + '\\n')",
          "function_before_start_line": 33,
          "function_before_end_line": 87,
          "function_after_start_line": 34,
          "function_after_end_line": 96,
          "function_before_token_count": 363,
          "function_after_token_count": 439,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "__init__",
            "update",
            "train",
            "standardize_y",
            "test",
            "make_tuple",
            "make_batches",
            "save",
            "predict_proba",
            "add",
            "fit",
            "predict_classes",
            "evaluate",
            "get_from_module",
            "compile"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "save",
            "evaluate",
            "fit"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 79,
          "file_complexity": 21,
          "file_token_count": 619,
          "file_before": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False):\n    if type(identifier) is str:\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate:\n            return res()\n        else:\n            return res\n    return identifier\n\ndef make_tuple(*args):\n    return args\n\nclass Progbar(object):\n    def __init__(self, target, width=30):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v, 1]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current-self.seen_so_far)\n                self.sum_values[k][1] += (current-self.seen_so_far)\n\n        prev_total_width = self.total_width\n        sys.stdout.write(\"\\b\" * (self.total_width+1))\n\n        bar = '%d/%d [' % (current, self.target)\n        prog = float(current)/self.target\n        prog_width = int(self.width*prog)\n        if prog_width > 0:\n            bar += ('='*(prog_width-1))\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += ('.'*(self.width-prog_width))\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n\n        now = time.time()\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit*(self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += ((prev_total_width-self.total_width) * \" \")\n\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        self.seen_so_far = current\n\n        if current >= self.target:\n            sys.stdout.write(\"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_after": "from __future__ import absolute_import\nimport numpy as np\nimport time\nimport sys\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False):\n    if type(identifier) is str:\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid ' + str(module_name) + ': ' + str(identifier))\n        if instantiate:\n            return res()\n        else:\n            return res\n    return identifier\n\ndef make_tuple(*args):\n    return args\n\nclass Progbar(object):\n    def __init__(self, target, width=30, verbose=1):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n        self.verbose = verbose\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v, 1]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current-self.seen_so_far)\n                self.sum_values[k][1] += (current-self.seen_so_far)\n\n        now = time.time()\n        if self.verbose == 1:\n            prev_total_width = self.total_width\n            sys.stdout.write(\"\\b\" * (self.total_width+1))\n\n            bar = '%d/%d [' % (current, self.target)\n            prog = float(current)/self.target\n            prog_width = int(self.width*prog)\n            if prog_width > 0:\n                bar += ('='*(prog_width-1))\n                if current < self.target:\n                    bar += '>'\n                else:\n                    bar += '='\n            bar += ('.'*(self.width-prog_width))\n            bar += ']'\n            sys.stdout.write(bar)\n            self.total_width = len(bar)\n            \n            if current:\n                time_per_unit = (now - self.start) / current\n            else:\n                time_per_unit = 0\n            eta = time_per_unit*(self.target - current)\n            info = ''\n            if current < self.target:\n                info += ' - ETA: %ds' % eta\n            else:\n                info += ' - %ds' % (now - self.start)\n            for k in self.unique_values:\n                info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n\n            self.total_width += len(info)\n            if prev_total_width > self.total_width:\n                info += ((prev_total_width-self.total_width) * \" \")\n\n            sys.stdout.write(info)\n            sys.stdout.flush()\n            self.seen_so_far = current\n\n            if current >= self.target:\n                sys.stdout.write(\"\\n\")\n\n        if self.verbose == 2:\n            if current >= self.target:\n                info = '%ds' % (now - self.start)\n                for k in self.unique_values:\n                    info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n                sys.stdout.write(info + \"\\n\")\n\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_patch": "@@ -18,7 +18,7 @@ def make_tuple(*args):\n     return args\n \n class Progbar(object):\n-    def __init__(self, target, width=30):\n+    def __init__(self, target, width=30, verbose=1):\n         '''\n             @param target: total number of steps expected\n         '''\n@@ -29,6 +29,7 @@ class Progbar(object):\n         self.start = time.time()\n         self.total_width = 0\n         self.seen_so_far = 0\n+        self.verbose = verbose\n \n     def update(self, current, values=[]):\n         '''\n@@ -44,47 +45,56 @@ class Progbar(object):\n                 self.sum_values[k][0] += v * (current-self.seen_so_far)\n                 self.sum_values[k][1] += (current-self.seen_so_far)\n \n-        prev_total_width = self.total_width\n-        sys.stdout.write(\"\\b\" * (self.total_width+1))\n+        now = time.time()\n+        if self.verbose == 1:\n+            prev_total_width = self.total_width\n+            sys.stdout.write(\"\\b\" * (self.total_width+1))\n \n-        bar = '%d/%d [' % (current, self.target)\n-        prog = float(current)/self.target\n-        prog_width = int(self.width*prog)\n-        if prog_width > 0:\n-            bar += ('='*(prog_width-1))\n+            bar = '%d/%d [' % (current, self.target)\n+            prog = float(current)/self.target\n+            prog_width = int(self.width*prog)\n+            if prog_width > 0:\n+                bar += ('='*(prog_width-1))\n+                if current < self.target:\n+                    bar += '>'\n+                else:\n+                    bar += '='\n+            bar += ('.'*(self.width-prog_width))\n+            bar += ']'\n+            sys.stdout.write(bar)\n+            self.total_width = len(bar)\n+            \n+            if current:\n+                time_per_unit = (now - self.start) / current\n+            else:\n+                time_per_unit = 0\n+            eta = time_per_unit*(self.target - current)\n+            info = ''\n             if current < self.target:\n-                bar += '>'\n+                info += ' - ETA: %ds' % eta\n             else:\n-                bar += '='\n-        bar += ('.'*(self.width-prog_width))\n-        bar += ']'\n-        sys.stdout.write(bar)\n-        self.total_width = len(bar)\n+                info += ' - %ds' % (now - self.start)\n+            for k in self.unique_values:\n+                info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n \n-        now = time.time()\n-        if current:\n-            time_per_unit = (now - self.start) / current\n-        else:\n-            time_per_unit = 0\n-        eta = time_per_unit*(self.target - current)\n-        info = ''\n-        if current < self.target:\n-            info += ' - ETA: %ds' % eta\n-        else:\n-            info += ' - %ds' % (now - self.start)\n-        for k in self.unique_values:\n-            info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n+            self.total_width += len(info)\n+            if prev_total_width > self.total_width:\n+                info += ((prev_total_width-self.total_width) * \" \")\n+\n+            sys.stdout.write(info)\n+            sys.stdout.flush()\n+            self.seen_so_far = current\n \n-        self.total_width += len(info)\n-        if prev_total_width > self.total_width:\n-            info += ((prev_total_width-self.total_width) * \" \")\n+            if current >= self.target:\n+                sys.stdout.write(\"\\n\")\n \n-        sys.stdout.write(info)\n-        sys.stdout.flush()\n-        self.seen_so_far = current\n+        if self.verbose == 2:\n+            if current >= self.target:\n+                info = '%ds' % (now - self.start)\n+                for k in self.unique_values:\n+                    info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n+                sys.stdout.write(info + \"\\n\")\n \n-        if current >= self.target:\n-            sys.stdout.write(\"\\n\")\n \n     def add(self, n, values=[]):\n         self.update(self.seen_so_far+n, values)\n",
          "files_name_in_blame_commit": [
            "models.py",
            "reuters_mlp.py",
            "generic_utils.py"
          ]
        }
      },
      "37a1db225420851cc668600c49697d9a2057f098": {
        "commit": {
          "commit_id": "37a1db225420851cc668600c49697d9a2057f098",
          "commit_message": "Add initial public version of Keras",
          "commit_author": "Francois",
          "commit_date": "2015-03-27 17:59:42",
          "commit_parent": "1f0bd8cac393d7da2e5845b5ffce5f4a8568006f"
        },
        "function": {
          "function_name": "update",
          "function_code_before": "",
          "function_code_after": "def update(self, current, values=[]):\n    \"\"\"\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        \"\"\"\n    for (k, v) in values:\n        if k not in self.sum_values:\n            self.sum_values[k] = [v, 1]\n            self.unique_values.append(k)\n        else:\n            self.sum_values[k][0] += v * (current - self.seen_so_far)\n            self.sum_values[k][1] += current - self.seen_so_far\n    prev_total_width = self.total_width\n    sys.stdout.write('\\x08' * (self.total_width + 1))\n    bar = '%d/%d [' % (current, self.target)\n    prog = float(current) / self.target\n    prog_width = int(self.width * prog)\n    if prog_width > 0:\n        bar += '=' * (prog_width - 1)\n        if current < self.target:\n            bar += '>'\n        else:\n            bar += '='\n    bar += '.' * (self.width - prog_width)\n    bar += ']'\n    sys.stdout.write(bar)\n    self.total_width = len(bar)\n    now = time.time()\n    if current:\n        time_per_unit = (now - self.start) / current\n    else:\n        time_per_unit = 0\n    eta = time_per_unit * (self.target - current)\n    info = ''\n    if current < self.target:\n        info += ' - ETA: %ds' % eta\n    else:\n        info += ' - %ds' % (now - self.start)\n    for k in self.unique_values:\n        info += ' - %s: %.4f' % (k, self.sum_values[k][0] / self.sum_values[k][1])\n    self.total_width += len(info)\n    if prev_total_width > self.total_width:\n        info += (prev_total_width - self.total_width) * ' '\n    sys.stdout.write(info)\n    sys.stdout.flush()\n    self.seen_so_far = current\n    if current >= self.target:\n        sys.stdout.write('\\n')",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 32,
          "function_after_end_line": 86,
          "function_before_token_count": 0,
          "function_after_token_count": 363,
          "functions_name_modified_file": [
            "__init__",
            "update",
            "make_tuple",
            "add",
            "get_from_module"
          ],
          "functions_name_all_files": [
            "flow",
            "output",
            "get_gradients",
            "standardize",
            "texts_to_sequences",
            "sharedX",
            "tanh",
            "evaluate",
            "random_rotation",
            "lecun_uniform",
            "random_barrel_transform",
            "base_filter",
            "get_weights",
            "text_to_word_sequence",
            "floatX",
            "vertical_flip",
            "orthogonal",
            "hard_sigmoid",
            "__init__",
            "categorical_crossentropy",
            "load_img",
            "load_data",
            "fit_on_sequences",
            "random_shift",
            "compile",
            "random_channel_shift",
            "list_pictures",
            "connect",
            "get_updates",
            "fit",
            "random_zoom",
            "_step",
            "shared_ones",
            "mean_absolute_error",
            "fit_on_texts",
            "random_transform",
            "softplus",
            "test",
            "uniform",
            "load_array",
            "sequences_to_matrix",
            "sigmoid",
            "shared_zeros",
            "array_to_img",
            "probas_to_classes",
            "predict_proba",
            "make_tuple",
            "relu",
            "get_input",
            "hinge",
            "get_from_module",
            "set_weights",
            "squared_hinge",
            "linear",
            "binary_crossentropy",
            "texts_to_matrix",
            "shared_scalar",
            "softmax",
            "random_shear",
            "accuracy",
            "save_array",
            "multiclass_logloss",
            "train",
            "one_hot",
            "to_categorical",
            "make_reuters_dataset",
            "standardize_y",
            "binary_logloss",
            "horizontal_flip",
            "normal",
            "get_file",
            "categorical_probas_to_classes",
            "add",
            "clip_norm",
            "get",
            "predict_classes",
            "pad_sequences",
            "img_to_array",
            "mean_squared_error",
            "update",
            "alloc_zeros_matrix"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "make_tuple",
            "add",
            "get_from_module"
          ],
          "functions_name_co_evolved_all_files": [
            "flow",
            "output",
            "get_gradients",
            "standardize",
            "texts_to_sequences",
            "sharedX",
            "tanh",
            "evaluate",
            "random_rotation",
            "lecun_uniform",
            "random_barrel_transform",
            "base_filter",
            "get_weights",
            "text_to_word_sequence",
            "floatX",
            "vertical_flip",
            "orthogonal",
            "hard_sigmoid",
            "__init__",
            "categorical_crossentropy",
            "load_img",
            "load_data",
            "fit_on_sequences",
            "random_shift",
            "compile",
            "random_channel_shift",
            "list_pictures",
            "connect",
            "get_updates",
            "fit",
            "random_zoom",
            "_step",
            "shared_ones",
            "mean_absolute_error",
            "fit_on_texts",
            "random_transform",
            "softplus",
            "test",
            "uniform",
            "load_array",
            "sequences_to_matrix",
            "sigmoid",
            "shared_zeros",
            "array_to_img",
            "probas_to_classes",
            "predict_proba",
            "make_tuple",
            "relu",
            "get_input",
            "hinge",
            "get_from_module",
            "set_weights",
            "squared_hinge",
            "linear",
            "binary_crossentropy",
            "texts_to_matrix",
            "shared_scalar",
            "softmax",
            "random_shear",
            "accuracy",
            "save_array",
            "multiclass_logloss",
            "train",
            "one_hot",
            "to_categorical",
            "make_reuters_dataset",
            "standardize_y",
            "binary_logloss",
            "horizontal_flip",
            "normal",
            "get_file",
            "categorical_probas_to_classes",
            "add",
            "clip_norm",
            "get",
            "predict_classes",
            "pad_sequences",
            "img_to_array",
            "mean_squared_error",
            "alloc_zeros_matrix"
          ]
        },
        "file": {
          "file_name": "generic_utils.py",
          "file_nloc": 70,
          "file_complexity": 17,
          "file_token_count": 524,
          "file_before": null,
          "file_after": "import numpy as np\nimport time\nimport sys\n\ndef get_from_module(identifier, module_params, module_name, instantiate=False):\n    if type(identifier) is str:\n        res = module_params.get(identifier)\n        if not res:\n            raise Exception('Invalid', module_name, ': ' + identifier)\n        if instantiate:\n            return res()\n        else:\n            return res\n    return identifier\n\ndef make_tuple(*args):\n    return args\n\nclass Progbar(object):\n    def __init__(self, target, width=30):\n        '''\n            @param target: total number of steps expected\n        '''\n        self.width = width\n        self.target = target\n        self.sum_values = {}\n        self.unique_values = []\n        self.start = time.time()\n        self.total_width = 0\n        self.seen_so_far = 0\n\n    def update(self, current, values=[]):\n        '''\n            @param current: index of current step\n            @param values: list of tuples (name, value_for_last_step).\n            The progress bar will display averages for these values.\n        '''\n        for k, v in values:\n            if k not in self.sum_values:\n                self.sum_values[k] = [v, 1]\n                self.unique_values.append(k)\n            else:\n                self.sum_values[k][0] += v * (current-self.seen_so_far)\n                self.sum_values[k][1] += (current-self.seen_so_far)\n\n        prev_total_width = self.total_width\n        sys.stdout.write(\"\\b\" * (self.total_width+1))\n\n        bar = '%d/%d [' % (current, self.target)\n        prog = float(current)/self.target\n        prog_width = int(self.width*prog)\n        if prog_width > 0:\n            bar += ('='*(prog_width-1))\n            if current < self.target:\n                bar += '>'\n            else:\n                bar += '='\n        bar += ('.'*(self.width-prog_width))\n        bar += ']'\n        sys.stdout.write(bar)\n        self.total_width = len(bar)\n\n        now = time.time()\n        if current:\n            time_per_unit = (now - self.start) / current\n        else:\n            time_per_unit = 0\n        eta = time_per_unit*(self.target - current)\n        info = ''\n        if current < self.target:\n            info += ' - ETA: %ds' % eta\n        else:\n            info += ' - %ds' % (now - self.start)\n        for k in self.unique_values:\n            info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n\n        self.total_width += len(info)\n        if prev_total_width > self.total_width:\n            info += ((prev_total_width-self.total_width) * \" \")\n\n        sys.stdout.write(info)\n        sys.stdout.flush()\n        self.seen_so_far = current\n\n        if current >= self.target:\n            sys.stdout.write(\"\\n\")\n\n    def add(self, n, values=[]):\n        self.update(self.seen_so_far+n, values)\n",
          "file_patch": "@@ -0,0 +1,89 @@\n+import numpy as np\n+import time\n+import sys\n+\n+def get_from_module(identifier, module_params, module_name, instantiate=False):\n+    if type(identifier) is str:\n+        res = module_params.get(identifier)\n+        if not res:\n+            raise Exception('Invalid', module_name, ': ' + identifier)\n+        if instantiate:\n+            return res()\n+        else:\n+            return res\n+    return identifier\n+\n+def make_tuple(*args):\n+    return args\n+\n+class Progbar(object):\n+    def __init__(self, target, width=30):\n+        '''\n+            @param target: total number of steps expected\n+        '''\n+        self.width = width\n+        self.target = target\n+        self.sum_values = {}\n+        self.unique_values = []\n+        self.start = time.time()\n+        self.total_width = 0\n+        self.seen_so_far = 0\n+\n+    def update(self, current, values=[]):\n+        '''\n+            @param current: index of current step\n+            @param values: list of tuples (name, value_for_last_step).\n+            The progress bar will display averages for these values.\n+        '''\n+        for k, v in values:\n+            if k not in self.sum_values:\n+                self.sum_values[k] = [v, 1]\n+                self.unique_values.append(k)\n+            else:\n+                self.sum_values[k][0] += v * (current-self.seen_so_far)\n+                self.sum_values[k][1] += (current-self.seen_so_far)\n+\n+        prev_total_width = self.total_width\n+        sys.stdout.write(\"\\b\" * (self.total_width+1))\n+\n+        bar = '%d/%d [' % (current, self.target)\n+        prog = float(current)/self.target\n+        prog_width = int(self.width*prog)\n+        if prog_width > 0:\n+            bar += ('='*(prog_width-1))\n+            if current < self.target:\n+                bar += '>'\n+            else:\n+                bar += '='\n+        bar += ('.'*(self.width-prog_width))\n+        bar += ']'\n+        sys.stdout.write(bar)\n+        self.total_width = len(bar)\n+\n+        now = time.time()\n+        if current:\n+            time_per_unit = (now - self.start) / current\n+        else:\n+            time_per_unit = 0\n+        eta = time_per_unit*(self.target - current)\n+        info = ''\n+        if current < self.target:\n+            info += ' - ETA: %ds' % eta\n+        else:\n+            info += ' - %ds' % (now - self.start)\n+        for k in self.unique_values:\n+            info += ' - %s: %.4f' % (k, self.sum_values[k][0]/self.sum_values[k][1])\n+\n+        self.total_width += len(info)\n+        if prev_total_width > self.total_width:\n+            info += ((prev_total_width-self.total_width) * \" \")\n+\n+        sys.stdout.write(info)\n+        sys.stdout.flush()\n+        self.seen_so_far = current\n+\n+        if current >= self.target:\n+            sys.stdout.write(\"\\n\")\n+\n+    def add(self, n, values=[]):\n+        self.update(self.seen_so_far+n, values)\n",
          "files_name_in_blame_commit": [
            "activations.py",
            "generic_utils.py",
            "text.py",
            "__init__.py",
            "recurrent.py",
            "core.py",
            "sequence.py",
            "models.py",
            "np_utils.py",
            "normalization.py",
            "cifar10.py",
            "cifar10_cnn.py",
            "initializations.py",
            "imdb_lstm.py",
            "objectives.py",
            "optimizers.py",
            "imdb.py",
            "data_utils.py",
            "image.py",
            "convolutional.py",
            "reuters_mlp.py",
            "advanced_activations.py",
            "theano_utils.py",
            "reuters.py"
          ]
        }
      }
    }
  }
}
{
  "id": "29",
  "blame_commit": {
    "commit": {
      "commit_id": "c0683137245ae37cb7403a8158e151b8b5a0e6ee",
      "commit_message": "BUG: Change IntervalDtype.kind from None to \"O\" (#30569)\n\n* BUG: Change IntervalDtype.kind from None to \"O\"",
      "commit_author": "Jeremy Schendel",
      "commit_date": "2019-12-31 06:26:13",
      "commit_parent": "95be0776d61c47f8a4cdfeaf53220156a026bcf5"
    },
    "function": {
      "function_name": "is_string_dtype",
      "function_code_before": "def is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype) -> bool:\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
      "function_code_after": "def is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype) -> bool:\n        return dtype.kind in ('O', 'S', 'U') and (not is_excluded_dtype(dtype))\n\n    def is_excluded_dtype(dtype) -> bool:\n        \"\"\"\n        These have kind = \"O\" but aren't string dtypes so need to be explicitly excluded\n        \"\"\"\n        is_excluded_checks = (is_period_dtype, is_interval_dtype)\n        return any((is_excluded(dtype) for is_excluded in is_excluded_checks))\n    return _is_dtype(arr_or_dtype, condition)",
      "function_before_start_line": 605,
      "function_before_end_line": 638,
      "function_after_start_line": 605,
      "function_after_end_line": 645,
      "function_before_token_count": 17,
      "function_after_token_count": 19,
      "functions_name_modified_file": [
        "is_numeric_v_string_like",
        "is_datetime64_ns_dtype",
        "is_any_int_dtype",
        "ensure_float",
        "is_numeric_dtype",
        "ensure_python_int",
        "is_period_arraylike",
        "_get_dtype",
        "is_int64_dtype",
        "is_period_dtype",
        "is_string_like_dtype",
        "is_timedelta64_dtype",
        "is_categorical_dtype",
        "is_timedelta64_ns_dtype",
        "is_extension_array_dtype",
        "pandas_dtype",
        "is_signed_integer_dtype",
        "is_offsetlike",
        "is_datetime64_dtype",
        "is_dtype_equal",
        "is_complex_dtype",
        "is_unsigned_integer_dtype",
        "_is_dtype",
        "is_datetime_arraylike",
        "ensure_str",
        "is_datetime_or_timedelta_dtype",
        "needs_i8_conversion",
        "is_categorical",
        "_is_dtype_type",
        "is_datetime64_any_dtype",
        "is_float_dtype",
        "is_bool_dtype",
        "is_sparse",
        "is_interval_dtype",
        "infer_dtype_from_object",
        "ensure_categorical",
        "_validate_date_like_dtype",
        "is_scipy_sparse",
        "classes_and_not_datetimelike",
        "is_integer_dtype",
        "_is_unorderable_exception",
        "is_datetime64tz_dtype",
        "is_extension_type",
        "classes",
        "ensure_int_or_float",
        "is_object_dtype",
        "is_string_dtype",
        "is_datetimelike_v_numeric"
      ],
      "functions_name_all_files": [
        "test_construction_errors",
        "_parse_dtype_strict",
        "test_from_values_or_dtype_raises",
        "test_name",
        "ensure_python_int",
        "categories",
        "freq",
        "test_categorical_equality",
        "test_equality",
        "test_construction_generic",
        "register_extension_dtype",
        "is_timedelta64_ns_dtype",
        "subtype",
        "is_offsetlike",
        "test_str_vs_repr",
        "is_dtype_equal",
        "is_complex_dtype",
        "_is_dtype",
        "create",
        "test_is_dtype_from_self",
        "setup_method",
        "test_update_dtype",
        "test_is_bool_dtype",
        "ordered",
        "_from_values_or_dtype",
        "test_basic_dtype",
        "test_invalid_raises",
        "test_is_not_object_type",
        "test_array_type",
        "__new__",
        "test_nan_invalid",
        "validate_categories",
        "test_mixed",
        "__init__",
        "is_integer_dtype",
        "reset_cache",
        "__setstate__",
        "test_name_repr",
        "classes",
        "is_extension_array_dtype",
        "ensure_int_or_float",
        "is_object_dtype",
        "unit",
        "is_any_int_dtype",
        "construct_array_type",
        "test_categories",
        "is_period_arraylike",
        "test_numpy_informed",
        "test_same_categories_different_order",
        "is_period_dtype",
        "test_construction_not_supported",
        "test_not_string",
        "is_string_like_dtype",
        "pandas_dtype",
        "test_identity",
        "is_datetime64_dtype",
        "_is_boolean",
        "test_caching",
        "ensure_str",
        "is_datetime_or_timedelta_dtype",
        "type",
        "test_compat",
        "test_order_matters",
        "test_construction_from_string_error_subtype",
        "test_unordered_same",
        "test_construct_from_string",
        "test_construct_from_string_raises",
        "__str__",
        "test_tz_standardize",
        "__getstate__",
        "test_subclass",
        "classes_and_not_datetimelike",
        "test_update_dtype_string",
        "is_extension_type",
        "is_datetime64_ns_dtype",
        "name",
        "ensure_float",
        "test_registry_find",
        "update_dtype",
        "_get_dtype",
        "validate_ordered",
        "test_categorical_equality_strings",
        "test_is_bool_dtype_sparse",
        "test_str",
        "test_registry",
        "_from_categorical_dtype",
        "construct_from_string",
        "test_check_dtype",
        "is_categorical_dtype",
        "test_is_dtype_unboxes_dtype",
        "is_signed_integer_dtype",
        "is_unsigned_integer_dtype",
        "is_datetime_arraylike",
        "__hash__",
        "test_is_boolean",
        "needs_i8_conversion",
        "test_from_categorical_dtype_ordered",
        "test_categorical_categories",
        "is_categorical",
        "test_update_dtype_errors",
        "is_datetime64_any_dtype",
        "test_alias_to_unit_raises",
        "is_float_dtype",
        "is_bool_dtype",
        "test_is_dtype_from_name",
        "is_interval_dtype",
        "__eq__",
        "__repr__",
        "test_eq_with_self",
        "_from_fastpath",
        "test_equality_invalid",
        "test_empty",
        "test_construction_from_string_errors",
        "test_hash",
        "test_constructor_invalid",
        "test_eq_with_numpy_object",
        "test_kind",
        "is_string_dtype",
        "is_numeric_v_string_like",
        "test_construct_from_string_another_type_raises",
        "test_parser",
        "test_equality_generic",
        "is_numeric_dtype",
        "find",
        "register",
        "test_alias_to_unit_bad_alias_raises",
        "test_tuple_categories",
        "test_hashable",
        "test_from_categorical_dtype_identity",
        "test_from_categorical_dtype_categories",
        "test_is_dtype_no_warning",
        "is_int64_dtype",
        "test_eq",
        "is_dtype",
        "test_from_values_or_dtype",
        "test_order_hashes_different",
        "is_timedelta64_dtype",
        "test_is_dtype",
        "test_construction",
        "test_name_repr_generic",
        "test_construction_from_string",
        "test_from_categorical_dtype_both",
        "test_construct_from_string_own_name",
        "_hash_categories",
        "test_eq_with_str",
        "na_value",
        "_finalize",
        "_is_dtype_type",
        "test_equal_but_different",
        "test_non_unique_invalid",
        "test_pickle",
        "test_dst",
        "is_sparse",
        "infer_dtype_from_object",
        "ensure_categorical",
        "_validate_date_like_dtype",
        "test_basic",
        "is_scipy_sparse",
        "_is_unorderable_exception",
        "is_datetime64tz_dtype",
        "test_hash_vs_equality",
        "tz",
        "test_is_not_string_type",
        "is_datetimelike_v_numeric"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "test_kind",
        "test_not_string"
      ]
    },
    "file": {
      "file_name": "common.py",
      "file_nloc": 1549,
      "file_complexity": 154,
      "file_token_count": 2403,
      "file_before": "\"\"\" common type operations \"\"\"\nfrom typing import Any, Callable, Union\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas._typing import ArrayLike\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype,\n    DatetimeTZDtype,\n    ExtensionDtype,\n    IntervalDtype,\n    PeriodDtype,\n    registry,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical,\n    ABCDateOffset,\n    ABCDatetimeIndex,\n    ABCIndexClass,\n    ABCPeriodArray,\n    ABCPeriodIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like,\n    is_bool,\n    is_complex,\n    is_decimal,\n    is_dict_like,\n    is_file_like,\n    is_float,\n    is_hashable,\n    is_integer,\n    is_interval,\n    is_iterator,\n    is_list_like,\n    is_named_tuple,\n    is_nested_list_like,\n    is_number,\n    is_re,\n    is_re_compilable,\n    is_scalar,\n    is_sequence,\n)\n\n_POSSIBLY_CAST_DTYPES = {\n    np.dtype(t).name\n    for t in [\n        \"O\",\n        \"int8\",\n        \"uint8\",\n        \"int16\",\n        \"uint16\",\n        \"int32\",\n        \"uint32\",\n        \"int64\",\n        \"uint64\",\n    ]\n}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_str(value: Union[bytes, Any]) -> str:\n    \"\"\"\n    Ensure that bytes and non-strings get converted into ``str`` objects.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n    elif not isinstance(value, str):\n        value = str(value)\n    return value\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int_or_float(arr: ArrayLike, copy: bool = False) -> np.array:\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible.\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: bool\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n\n    Notes\n    -----\n    If the array is explicitly of type uint64 the type\n    will remain unchanged.\n    \"\"\"\n    # TODO: GH27506 potential bug with ExtensionArrays\n    try:\n        return arr.astype(\"int64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        pass\n    try:\n        return arr.astype(\"uint64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        return arr.astype(\"float64\", copy=copy)\n\n\ndef ensure_python_int(value: Union[int, np.integer]) -> int:\n    \"\"\"\n    Ensure that a value is a python int.\n\n    Parameters\n    ----------\n    value: int or numpy.integer\n\n    Returns\n    -------\n    int\n\n    Raises\n    ------\n    TypeError: if the value isn't an int or can't be converted to one.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(f\"Value needs to be a scalar value, was type {type(value)}\")\n    msg = \"Wrong type {} for value {}\"\n    try:\n        new_value = int(value)\n        assert new_value == value\n    except (TypeError, ValueError, AssertionError):\n        raise TypeError(msg.format(type(value), value))\n    return new_value\n\n\ndef classes(*klasses) -> Callable:\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses) -> Callable:\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (\n        issubclass(tipo, klasses)\n        and not issubclass(tipo, (np.datetime64, np.timedelta64))\n    )\n\n\ndef is_object_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.Series(pd.SparseArray([0, 0, 1, 0])))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, \"dtype\", arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    assert _is_scipy_sparse is not None\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj) -> bool:\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean\n        Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif is_list_like(arr_or_obj) and len(arr_or_obj) and is_object_dtype(arr_or_obj):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_datetime64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype) -> bool:\n        return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)\n\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical array-like or\n        PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, \"inferred_type\", None) == \"period\"\n\n\ndef is_datetime_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like or\n        DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (\n            is_object_dtype(arr.dtype)\n            and lib.infer_dtype(arr, skipna=False) == \"datetime\"\n        )\n    return getattr(arr, \"inferred_type\", None) == \"datetime\"\n\n\ndef is_dtype_equal(source, target) -> bool:\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    -------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a signed integer dtype\n        and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger)\n    )\n\n\ndef is_int64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, \"base\", None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a timedelta64,\n        or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e: TypeError) -> bool:\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n    return \"'>' not supported between instances of\" in str(e)\n\n\n# This exists to silence numpy deprecation warnings, see GH#29553\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a string-like object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(1, 1)\n    False\n    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n    False\n    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n    False\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and isinstance(a, str)\n    is_b_scalar_string_like = not is_b_array and isinstance(b, str)\n\n    return (\n        (is_a_numeric_array and is_b_scalar_string_like)\n        or (is_b_numeric_array and is_a_scalar_string_like)\n        or (is_a_numeric_array and is_b_string_array)\n        or (is_b_numeric_array and is_a_string_array)\n    )\n\n\n# This exists to silence numpy deprecation warnings, see GH#29553\ndef is_datetimelike_v_numeric(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to a numeric object.\n    By \"numeric,\" we mean an object that is either of an int or float dtype.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a datetime-like to a numeric object.\n\n    Examples\n    --------\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_numeric(1, 1)\n    False\n    >>> is_datetimelike_v_numeric(dt, dt)\n    False\n    >>> is_datetimelike_v_numeric(1, dt)\n    True\n    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n    False\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, \"dtype\"):\n        a = np.asarray(a)\n    if not hasattr(b, \"dtype\"):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        \"\"\"\n        Check if an object has a numeric dtype (i.e. integer or float).\n        \"\"\"\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    return (needs_i8_conversion(a) and is_numeric(b)) or (\n        needs_i8_conversion(b) and is_numeric(a)\n    )\n\n\ndef needs_i8_conversion(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (\n        is_datetime_or_timedelta_dtype(arr_or_dtype)\n        or is_datetime64tz_dtype(arr_or_dtype)\n        or is_period_dtype(arr_or_dtype)\n    )\n\n\ndef is_numeric_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_)\n    )\n\n\ndef is_string_like_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in (\"S\", \"U\"))\n\n\ndef is_float_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return arr_or_dtype.is_object and arr_or_dtype.inferred_type == \"boolean\"\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    .. deprecated:: 1.0.0\n        Use ``is_extension_array_dtype`` instead.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a pandas extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n    warnings.warn(\n        \"'is_extension_type' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_extension_array_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n    return isinstance(dtype, ExtensionDtype) or registry.find(dtype) is not None\n\n\ndef is_complex_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a complex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisfied for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, ExtensionDtype):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, str):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in [\"datetimetz\", \"datetime64tz\"]:\n            return DatetimeTZDtype.type\n        elif dtype in [\"period\"]:\n            raise NotImplementedError\n\n        if dtype == \"datetime\" or dtype == \"timedelta\":\n            dtype += \"64\"\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype) -> None:\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError(e)\n    if typ != \"generic\" and typ != \"ns\":\n        raise ValueError(\n            f\"{repr(dtype.name)} is too specific of a frequency, \"\n            f\"try passing {repr(dtype.type.__name__)}\"\n        )\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Convert input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except SyntaxError:\n        # np.dtype uses `eval` which can raise SyntaxError\n        raise TypeError(f\"data type '{dtype}' not understood\")\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, \"object\", \"O\"]:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == \"O\":\n        raise TypeError(f\"dtype '{dtype}' not understood\")\n\n    return npdtype\n",
      "file_after": "\"\"\" common type operations \"\"\"\nfrom typing import Any, Callable, Union\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas._typing import ArrayLike\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype,\n    DatetimeTZDtype,\n    ExtensionDtype,\n    IntervalDtype,\n    PeriodDtype,\n    registry,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical,\n    ABCDateOffset,\n    ABCDatetimeIndex,\n    ABCIndexClass,\n    ABCPeriodArray,\n    ABCPeriodIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like,\n    is_bool,\n    is_complex,\n    is_decimal,\n    is_dict_like,\n    is_file_like,\n    is_float,\n    is_hashable,\n    is_integer,\n    is_interval,\n    is_iterator,\n    is_list_like,\n    is_named_tuple,\n    is_nested_list_like,\n    is_number,\n    is_re,\n    is_re_compilable,\n    is_scalar,\n    is_sequence,\n)\n\n_POSSIBLY_CAST_DTYPES = {\n    np.dtype(t).name\n    for t in [\n        \"O\",\n        \"int8\",\n        \"uint8\",\n        \"int16\",\n        \"uint16\",\n        \"int32\",\n        \"uint32\",\n        \"int64\",\n        \"uint64\",\n    ]\n}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_str(value: Union[bytes, Any]) -> str:\n    \"\"\"\n    Ensure that bytes and non-strings get converted into ``str`` objects.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n    elif not isinstance(value, str):\n        value = str(value)\n    return value\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int_or_float(arr: ArrayLike, copy: bool = False) -> np.array:\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible.\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: bool\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n\n    Notes\n    -----\n    If the array is explicitly of type uint64 the type\n    will remain unchanged.\n    \"\"\"\n    # TODO: GH27506 potential bug with ExtensionArrays\n    try:\n        return arr.astype(\"int64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        pass\n    try:\n        return arr.astype(\"uint64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        return arr.astype(\"float64\", copy=copy)\n\n\ndef ensure_python_int(value: Union[int, np.integer]) -> int:\n    \"\"\"\n    Ensure that a value is a python int.\n\n    Parameters\n    ----------\n    value: int or numpy.integer\n\n    Returns\n    -------\n    int\n\n    Raises\n    ------\n    TypeError: if the value isn't an int or can't be converted to one.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(f\"Value needs to be a scalar value, was type {type(value)}\")\n    msg = \"Wrong type {} for value {}\"\n    try:\n        new_value = int(value)\n        assert new_value == value\n    except (TypeError, ValueError, AssertionError):\n        raise TypeError(msg.format(type(value), value))\n    return new_value\n\n\ndef classes(*klasses) -> Callable:\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses) -> Callable:\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (\n        issubclass(tipo, klasses)\n        and not issubclass(tipo, (np.datetime64, np.timedelta64))\n    )\n\n\ndef is_object_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.Series(pd.SparseArray([0, 0, 1, 0])))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, \"dtype\", arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    assert _is_scipy_sparse is not None\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj) -> bool:\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean\n        Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif is_list_like(arr_or_obj) and len(arr_or_obj) and is_object_dtype(arr_or_obj):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_datetime64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype) -> bool:\n        return dtype.kind in (\"O\", \"S\", \"U\") and not is_excluded_dtype(dtype)\n\n    def is_excluded_dtype(dtype) -> bool:\n        \"\"\"\n        These have kind = \"O\" but aren't string dtypes so need to be explicitly excluded\n        \"\"\"\n        is_excluded_checks = (is_period_dtype, is_interval_dtype)\n        return any(is_excluded(dtype) for is_excluded in is_excluded_checks)\n\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical array-like or\n        PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, \"inferred_type\", None) == \"period\"\n\n\ndef is_datetime_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like or\n        DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (\n            is_object_dtype(arr.dtype)\n            and lib.infer_dtype(arr, skipna=False) == \"datetime\"\n        )\n    return getattr(arr, \"inferred_type\", None) == \"datetime\"\n\n\ndef is_dtype_equal(source, target) -> bool:\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    -------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a signed integer dtype\n        and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger)\n    )\n\n\ndef is_int64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, \"base\", None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a timedelta64,\n        or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e: TypeError) -> bool:\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n    return \"'>' not supported between instances of\" in str(e)\n\n\n# This exists to silence numpy deprecation warnings, see GH#29553\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a string-like object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(1, 1)\n    False\n    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n    False\n    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n    False\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and isinstance(a, str)\n    is_b_scalar_string_like = not is_b_array and isinstance(b, str)\n\n    return (\n        (is_a_numeric_array and is_b_scalar_string_like)\n        or (is_b_numeric_array and is_a_scalar_string_like)\n        or (is_a_numeric_array and is_b_string_array)\n        or (is_b_numeric_array and is_a_string_array)\n    )\n\n\n# This exists to silence numpy deprecation warnings, see GH#29553\ndef is_datetimelike_v_numeric(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to a numeric object.\n    By \"numeric,\" we mean an object that is either of an int or float dtype.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a datetime-like to a numeric object.\n\n    Examples\n    --------\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_numeric(1, 1)\n    False\n    >>> is_datetimelike_v_numeric(dt, dt)\n    False\n    >>> is_datetimelike_v_numeric(1, dt)\n    True\n    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n    False\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, \"dtype\"):\n        a = np.asarray(a)\n    if not hasattr(b, \"dtype\"):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        \"\"\"\n        Check if an object has a numeric dtype (i.e. integer or float).\n        \"\"\"\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    return (needs_i8_conversion(a) and is_numeric(b)) or (\n        needs_i8_conversion(b) and is_numeric(a)\n    )\n\n\ndef needs_i8_conversion(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (\n        is_datetime_or_timedelta_dtype(arr_or_dtype)\n        or is_datetime64tz_dtype(arr_or_dtype)\n        or is_period_dtype(arr_or_dtype)\n    )\n\n\ndef is_numeric_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_)\n    )\n\n\ndef is_string_like_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in (\"S\", \"U\"))\n\n\ndef is_float_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return arr_or_dtype.is_object and arr_or_dtype.inferred_type == \"boolean\"\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    .. deprecated:: 1.0.0\n        Use ``is_extension_array_dtype`` instead.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a pandas extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n    warnings.warn(\n        \"'is_extension_type' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_extension_array_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n    return isinstance(dtype, ExtensionDtype) or registry.find(dtype) is not None\n\n\ndef is_complex_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a complex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisfied for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, ExtensionDtype):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, str):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in [\"datetimetz\", \"datetime64tz\"]:\n            return DatetimeTZDtype.type\n        elif dtype in [\"period\"]:\n            raise NotImplementedError\n\n        if dtype == \"datetime\" or dtype == \"timedelta\":\n            dtype += \"64\"\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype) -> None:\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError(e)\n    if typ != \"generic\" and typ != \"ns\":\n        raise ValueError(\n            f\"{repr(dtype.name)} is too specific of a frequency, \"\n            f\"try passing {repr(dtype.type.__name__)}\"\n        )\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Convert input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except SyntaxError:\n        # np.dtype uses `eval` which can raise SyntaxError\n        raise TypeError(f\"data type '{dtype}' not understood\")\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, \"object\", \"O\"]:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == \"O\":\n        raise TypeError(f\"dtype '{dtype}' not understood\")\n\n    return npdtype\n",
      "file_patch": "@@ -633,7 +633,14 @@ def is_string_dtype(arr_or_dtype) -> bool:\n \n     # TODO: gh-15585: consider making the checks stricter.\n     def condition(dtype) -> bool:\n-        return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)\n+        return dtype.kind in (\"O\", \"S\", \"U\") and not is_excluded_dtype(dtype)\n+\n+    def is_excluded_dtype(dtype) -> bool:\n+        \"\"\"\n+        These have kind = \"O\" but aren't string dtypes so need to be explicitly excluded\n+        \"\"\"\n+        is_excluded_checks = (is_period_dtype, is_interval_dtype)\n+        return any(is_excluded(dtype) for is_excluded in is_excluded_checks)\n \n     return _is_dtype(arr_or_dtype, condition)\n \n",
      "files_name_in_blame_commit": [
        "common.py",
        "dtypes.py",
        "test_dtypes.py",
        "dtype.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 117
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "605": {
        "commit_id": "eabf89d174ed8164a09ae28c80e03e1fe5bf14c5",
        "line_code": "def is_string_dtype(arr_or_dtype) -> bool:",
        "commit_date": "2019-11-12 18:38:26",
        "valid": 1
      },
      "606": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    \"\"\"",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "607": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    Check whether the provided array or dtype is of the string dtype.",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "608": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 0
      },
      "609": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    Parameters",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "610": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    ----------",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "611": {
        "commit_id": "1a0c878f733c5fc2b37e6f6ab655e943685036f9",
        "line_code": "    arr_or_dtype : array-like",
        "commit_date": "2017-05-04 17:37:14",
        "valid": 1
      },
      "612": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "        The array or dtype to check.",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "613": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 0
      },
      "614": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    Returns",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "615": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    -------",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "616": {
        "commit_id": "88318e3066b5394a007d2ffaab33d866c2f066a7",
        "line_code": "    boolean",
        "commit_date": "2019-02-04 07:56:02",
        "valid": 1
      },
      "617": {
        "commit_id": "88318e3066b5394a007d2ffaab33d866c2f066a7",
        "line_code": "        Whether or not the array or dtype is of the string dtype.",
        "commit_date": "2019-02-04 07:56:02",
        "valid": 1
      },
      "618": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 0
      },
      "619": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    Examples",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "620": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    --------",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "621": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    >>> is_string_dtype(str)",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "622": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    True",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "623": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    >>> is_string_dtype(object)",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "624": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    True",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "625": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    >>> is_string_dtype(int)",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "626": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    False",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "627": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    >>>",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "628": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    >>> is_string_dtype(np.array(['a', 'b']))",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "629": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    True",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "630": {
        "commit_id": "1a0c878f733c5fc2b37e6f6ab655e943685036f9",
        "line_code": "    >>> is_string_dtype(pd.Series([1, 2]))",
        "commit_date": "2017-05-04 17:37:14",
        "valid": 1
      },
      "631": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    False",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "632": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    \"\"\"",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "633": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 0
      },
      "634": {
        "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
        "line_code": "    # TODO: gh-15585: consider making the checks stricter.",
        "commit_date": "2017-04-07 18:42:29",
        "valid": 1
      },
      "635": {
        "commit_id": "7ba0e0281da63b3496dc8b0382f9c5e03810fdcc",
        "line_code": "    def condition(dtype) -> bool:",
        "commit_date": "2019-11-15 09:56:01",
        "valid": 1
      },
      "636": {
        "commit_id": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
        "line_code": "        return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)",
        "commit_date": "2019-07-03 23:28:23",
        "valid": 1
      },
      "637": {
        "commit_id": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
        "line_code": "",
        "commit_date": "2019-07-03 23:28:23",
        "valid": 0
      },
      "638": {
        "commit_id": "19f715c51d16995fc6cd0c102fdba2f213a83a0f",
        "line_code": "    return _is_dtype(arr_or_dtype, condition)",
        "commit_date": "2019-01-04 08:55:43",
        "valid": 1
      }
    },
    "commits": {
      "7ba0e0281da63b3496dc8b0382f9c5e03810fdcc": {
        "commit": {
          "commit_id": "7ba0e0281da63b3496dc8b0382f9c5e03810fdcc",
          "commit_message": "CLN:Typing in pandas/core/dtypes/ (#29606)",
          "commit_author": "MomIsBestFriend",
          "commit_date": "2019-11-15 09:56:01",
          "commit_parent": "710d82c0d393c9031e469ec0371660d8187b7dc3"
        },
        "function": {
          "function_name": "is_string_dtype",
          "function_code_before": "def is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
          "function_code_after": "def is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype) -> bool:\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
          "function_before_start_line": 699,
          "function_before_end_line": 732,
          "function_after_start_line": 699,
          "function_after_end_line": 732,
          "function_before_token_count": 17,
          "function_after_token_count": 17,
          "functions_name_modified_file": [
            "is_datetime64_ns_dtype",
            "is_period",
            "is_any_int_dtype",
            "ensure_float",
            "is_numeric_dtype",
            "ensure_python_int",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "is_extension_array_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "_is_dtype",
            "is_datetime_arraylike",
            "ensure_str",
            "is_datetime_or_timedelta_dtype",
            "needs_i8_conversion",
            "is_categorical",
            "_is_dtype_type",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "is_sparse",
            "is_datetimetz",
            "is_interval_dtype",
            "infer_dtype_from_object",
            "ensure_categorical",
            "_validate_date_like_dtype",
            "is_scipy_sparse",
            "classes_and_not_datetimelike",
            "is_integer_dtype",
            "_is_unorderable_exception",
            "is_datetime64tz_dtype",
            "is_extension_type",
            "classes",
            "ensure_int_or_float",
            "is_object_dtype",
            "is_string_dtype"
          ],
          "functions_name_all_files": [
            "_parse_dtype_strict",
            "get_dtype_kinds",
            "ensure_python_int",
            "kind",
            "categories",
            "freq",
            "na_value_for_dtype",
            "register_extension_dtype",
            "is_timedelta64_ns_dtype",
            "subtype",
            "is_offsetlike",
            "is_dtype_equal",
            "is_complex_dtype",
            "_is_dtype",
            "ordered",
            "_from_values_or_dtype",
            "_concat_sparse",
            "__new__",
            "is_datetimetz",
            "notna",
            "_infer_fill_value",
            "validate_categories",
            "__init__",
            "is_integer_dtype",
            "reset_cache",
            "__setstate__",
            "classes",
            "is_extension_array_dtype",
            "ensure_int_or_float",
            "is_object_dtype",
            "unit",
            "is_any_int_dtype",
            "construct_array_type",
            "is_period_arraylike",
            "_maybe_fill",
            "is_period_dtype",
            "is_string_like_dtype",
            "remove_na_arraylike",
            "pandas_dtype",
            "is_datetime64_dtype",
            "_is_boolean",
            "ensure_str",
            "is_datetime_or_timedelta_dtype",
            "type",
            "concat_categorical",
            "_isna_new",
            "_isna_ndarraylike",
            "__str__",
            "_is_numeric",
            "_isna_compat",
            "__getstate__",
            "classes_and_not_datetimelike",
            "is_extension_type",
            "array_equivalent",
            "is_datetime64_ns_dtype",
            "name",
            "names",
            "is_period",
            "ensure_float",
            "update_dtype",
            "_get_dtype",
            "validate_ordered",
            "_from_categorical_dtype",
            "construct_from_string",
            "is_categorical_dtype",
            "is_signed_integer_dtype",
            "is_unsigned_integer_dtype",
            "__hash__",
            "is_datetime_arraylike",
            "isna",
            "needs_i8_conversion",
            "_concat_datetimetz",
            "_isna_ndarraylike_old",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "is_interval_dtype",
            "__eq__",
            "__repr__",
            "_from_fastpath",
            "is_string_dtype",
            "_concatenate_2d",
            "_isna_old",
            "is_numeric_dtype",
            "find",
            "register",
            "is_valid_nat_for_dtype",
            "is_int64_dtype",
            "is_dtype",
            "_convert_datetimelike_to_object",
            "concat_datetime",
            "is_timedelta64_dtype",
            "_hash_categories",
            "na_value",
            "_finalize",
            "_is_dtype_type",
            "is_sparse",
            "infer_dtype_from_object",
            "ensure_categorical",
            "_validate_date_like_dtype",
            "is_scipy_sparse",
            "_is_unorderable_exception",
            "_use_inf_as_na",
            "is_datetime64tz_dtype",
            "union_categoricals",
            "tz",
            "__ne__",
            "concat_compat"
          ],
          "functions_name_co_evolved_modified_file": [
            "is_extension_array_dtype",
            "is_extension_type"
          ],
          "functions_name_co_evolved_all_files": [
            "is_extension_type",
            "array_equivalent",
            "__ne__",
            "concat_compat",
            "__eq__",
            "is_extension_array_dtype",
            "_isna_compat"
          ]
        },
        "file": {
          "file_name": "common.py",
          "file_nloc": 1602,
          "file_complexity": 133,
          "file_token_count": 2285,
          "file_before": "\"\"\" common type operations \"\"\"\nfrom typing import Any, Callable, Union\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype,\n    DatetimeTZDtype,\n    ExtensionDtype,\n    IntervalDtype,\n    PeriodDtype,\n    registry,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical,\n    ABCDateOffset,\n    ABCDatetimeIndex,\n    ABCIndexClass,\n    ABCPeriodArray,\n    ABCPeriodIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like,\n    is_bool,\n    is_complex,\n    is_decimal,\n    is_dict_like,\n    is_file_like,\n    is_float,\n    is_hashable,\n    is_integer,\n    is_interval,\n    is_iterator,\n    is_list_like,\n    is_named_tuple,\n    is_nested_list_like,\n    is_number,\n    is_re,\n    is_re_compilable,\n    is_scalar,\n    is_sequence,\n)\n\nfrom pandas._typing import ArrayLike\n\n_POSSIBLY_CAST_DTYPES = {\n    np.dtype(t).name\n    for t in [\n        \"O\",\n        \"int8\",\n        \"uint8\",\n        \"int16\",\n        \"uint16\",\n        \"int32\",\n        \"uint32\",\n        \"int64\",\n        \"uint64\",\n    ]\n}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_str(value: Union[bytes, Any]) -> str:\n    \"\"\"\n    Ensure that bytes and non-strings get converted into ``str`` objects.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n    elif not isinstance(value, str):\n        value = str(value)\n    return value\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int_or_float(arr: ArrayLike, copy: bool = False) -> np.array:\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible.\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: bool\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n\n    Notes\n    -----\n    If the array is explicitly of type uint64 the type\n    will remain unchanged.\n    \"\"\"\n    # TODO: GH27506 potential bug with ExtensionArrays\n    try:\n        return arr.astype(\"int64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        pass\n    try:\n        return arr.astype(\"uint64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        return arr.astype(\"float64\", copy=copy)\n\n\ndef ensure_python_int(value: Union[int, np.integer]) -> int:\n    \"\"\"\n    Ensure that a value is a python int.\n\n    Parameters\n    ----------\n    value: int or numpy.integer\n\n    Returns\n    -------\n    int\n\n    Raises\n    ------\n    TypeError: if the value isn't an int or can't be converted to one.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(\n            \"Value needs to be a scalar value, was type {}\".format(type(value))\n        )\n    msg = \"Wrong type {} for value {}\"\n    try:\n        new_value = int(value)\n        assert new_value == value\n    except (TypeError, ValueError, AssertionError):\n        raise TypeError(msg.format(type(value), value))\n    return new_value\n\n\ndef classes(*klasses) -> Callable:\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses) -> Callable:\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (\n        issubclass(tipo, klasses)\n        and not issubclass(tipo, (np.datetime64, np.timedelta64))\n    )\n\n\ndef is_object_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.Series(pd.SparseArray([0, 0, 1, 0])))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, \"dtype\", arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    assert _is_scipy_sparse is not None\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like with a\n        timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_datetimetz' is deprecated and will be removed in a \"\n        \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj) -> bool:\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean\n        Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif is_list_like(arr_or_obj) and len(arr_or_obj) and is_object_dtype(arr_or_obj):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_period' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n        \"instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)\n\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical array-like or\n        PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, \"inferred_type\", None) == \"period\"\n\n\ndef is_datetime_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like or\n        DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (\n            is_object_dtype(arr.dtype)\n            and lib.infer_dtype(arr, skipna=False) == \"datetime\"\n        )\n    return getattr(arr, \"inferred_type\", None) == \"datetime\"\n\n\ndef is_dtype_equal(source, target) -> bool:\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    -------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a signed integer dtype\n        and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger)\n    )\n\n\ndef is_int64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, \"base\", None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a timedelta64,\n        or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e: TypeError) -> bool:\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n    return \"'>' not supported between instances of\" in str(e)\n\n\ndef needs_i8_conversion(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (\n        is_datetime_or_timedelta_dtype(arr_or_dtype)\n        or is_datetime64tz_dtype(arr_or_dtype)\n        or is_period_dtype(arr_or_dtype)\n    )\n\n\ndef is_numeric_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_)\n    )\n\n\ndef is_string_like_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in (\"S\", \"U\"))\n\n\ndef is_float_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return arr_or_dtype.is_object and arr_or_dtype.inferred_type == \"boolean\"\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    .. deprecated:: 1.0.0\n        Use ``is_extension_array_dtype`` instead.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a pandas extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n    warnings.warn(\n        \"'is_extension_type' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_extension_array_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype):\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n    return isinstance(dtype, ExtensionDtype) or registry.find(dtype) is not None\n\n\ndef is_complex_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a complex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisfied for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, ExtensionDtype):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, str):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in [\"datetimetz\", \"datetime64tz\"]:\n            return DatetimeTZDtype.type\n        elif dtype in [\"period\"]:\n            raise NotImplementedError\n\n        if dtype == \"datetime\" or dtype == \"timedelta\":\n            dtype += \"64\"\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype) -> None:\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError(\"{error}\".format(error=e))\n    if typ != \"generic\" and typ != \"ns\":\n        msg = \"{name!r} is too specific of a frequency, try passing {type!r}\"\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Convert input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except SyntaxError:\n        # np.dtype uses `eval` which can raise SyntaxError\n        raise TypeError(\"data type '{}' not understood\".format(dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, \"object\", \"O\"]:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == \"O\":\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_after": "\"\"\" common type operations \"\"\"\nfrom typing import Any, Callable, Union\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype,\n    DatetimeTZDtype,\n    ExtensionDtype,\n    IntervalDtype,\n    PeriodDtype,\n    registry,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical,\n    ABCDateOffset,\n    ABCDatetimeIndex,\n    ABCIndexClass,\n    ABCPeriodArray,\n    ABCPeriodIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like,\n    is_bool,\n    is_complex,\n    is_decimal,\n    is_dict_like,\n    is_file_like,\n    is_float,\n    is_hashable,\n    is_integer,\n    is_interval,\n    is_iterator,\n    is_list_like,\n    is_named_tuple,\n    is_nested_list_like,\n    is_number,\n    is_re,\n    is_re_compilable,\n    is_scalar,\n    is_sequence,\n)\n\nfrom pandas._typing import ArrayLike\n\n_POSSIBLY_CAST_DTYPES = {\n    np.dtype(t).name\n    for t in [\n        \"O\",\n        \"int8\",\n        \"uint8\",\n        \"int16\",\n        \"uint16\",\n        \"int32\",\n        \"uint32\",\n        \"int64\",\n        \"uint64\",\n    ]\n}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_str(value: Union[bytes, Any]) -> str:\n    \"\"\"\n    Ensure that bytes and non-strings get converted into ``str`` objects.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n    elif not isinstance(value, str):\n        value = str(value)\n    return value\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int_or_float(arr: ArrayLike, copy: bool = False) -> np.array:\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible.\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: bool\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n\n    Notes\n    -----\n    If the array is explicitly of type uint64 the type\n    will remain unchanged.\n    \"\"\"\n    # TODO: GH27506 potential bug with ExtensionArrays\n    try:\n        return arr.astype(\"int64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        pass\n    try:\n        return arr.astype(\"uint64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        return arr.astype(\"float64\", copy=copy)\n\n\ndef ensure_python_int(value: Union[int, np.integer]) -> int:\n    \"\"\"\n    Ensure that a value is a python int.\n\n    Parameters\n    ----------\n    value: int or numpy.integer\n\n    Returns\n    -------\n    int\n\n    Raises\n    ------\n    TypeError: if the value isn't an int or can't be converted to one.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(\n            \"Value needs to be a scalar value, was type {}\".format(type(value))\n        )\n    msg = \"Wrong type {} for value {}\"\n    try:\n        new_value = int(value)\n        assert new_value == value\n    except (TypeError, ValueError, AssertionError):\n        raise TypeError(msg.format(type(value), value))\n    return new_value\n\n\ndef classes(*klasses) -> Callable:\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses) -> Callable:\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (\n        issubclass(tipo, klasses)\n        and not issubclass(tipo, (np.datetime64, np.timedelta64))\n    )\n\n\ndef is_object_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.Series(pd.SparseArray([0, 0, 1, 0])))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, \"dtype\", arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    assert _is_scipy_sparse is not None\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like with a\n        timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_datetimetz' is deprecated and will be removed in a \"\n        \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj) -> bool:\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean\n        Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif is_list_like(arr_or_obj) and len(arr_or_obj) and is_object_dtype(arr_or_obj):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_period' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n        \"instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype) -> bool:\n        return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)\n\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical array-like or\n        PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, \"inferred_type\", None) == \"period\"\n\n\ndef is_datetime_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like or\n        DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (\n            is_object_dtype(arr.dtype)\n            and lib.infer_dtype(arr, skipna=False) == \"datetime\"\n        )\n    return getattr(arr, \"inferred_type\", None) == \"datetime\"\n\n\ndef is_dtype_equal(source, target) -> bool:\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    -------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a signed integer dtype\n        and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger)\n    )\n\n\ndef is_int64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, \"base\", None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a timedelta64,\n        or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e: TypeError) -> bool:\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n    return \"'>' not supported between instances of\" in str(e)\n\n\ndef needs_i8_conversion(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (\n        is_datetime_or_timedelta_dtype(arr_or_dtype)\n        or is_datetime64tz_dtype(arr_or_dtype)\n        or is_period_dtype(arr_or_dtype)\n    )\n\n\ndef is_numeric_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_)\n    )\n\n\ndef is_string_like_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in (\"S\", \"U\"))\n\n\ndef is_float_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return arr_or_dtype.is_object and arr_or_dtype.inferred_type == \"boolean\"\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    .. deprecated:: 1.0.0\n        Use ``is_extension_array_dtype`` instead.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a pandas extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n    warnings.warn(\n        \"'is_extension_type' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_extension_array_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n    return isinstance(dtype, ExtensionDtype) or registry.find(dtype) is not None\n\n\ndef is_complex_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a complex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisfied for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, ExtensionDtype):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, str):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in [\"datetimetz\", \"datetime64tz\"]:\n            return DatetimeTZDtype.type\n        elif dtype in [\"period\"]:\n            raise NotImplementedError\n\n        if dtype == \"datetime\" or dtype == \"timedelta\":\n            dtype += \"64\"\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype) -> None:\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError(\"{error}\".format(error=e))\n    if typ != \"generic\" and typ != \"ns\":\n        msg = \"{name!r} is too specific of a frequency, try passing {type!r}\"\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Convert input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except SyntaxError:\n        # np.dtype uses `eval` which can raise SyntaxError\n        raise TypeError(\"data type '{}' not understood\".format(dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, \"object\", \"O\"]:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == \"O\":\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_patch": "@@ -726,7 +726,7 @@ def is_string_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n \n     # TODO: gh-15585: consider making the checks stricter.\n-    def condition(dtype):\n+    def condition(dtype) -> bool:\n         return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)\n \n     return _is_dtype(arr_or_dtype, condition)\n@@ -1496,7 +1496,7 @@ def is_bool_dtype(arr_or_dtype) -> bool:\n     return issubclass(dtype.type, np.bool_)\n \n \n-def is_extension_type(arr):\n+def is_extension_type(arr) -> bool:\n     \"\"\"\n     Check whether an array-like is of a pandas extension class instance.\n \n@@ -1561,7 +1561,7 @@ def is_extension_type(arr):\n     return False\n \n \n-def is_extension_array_dtype(arr_or_dtype):\n+def is_extension_array_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check if an object is a pandas extension array type.\n \n",
          "files_name_in_blame_commit": [
            "common.py",
            "base.py",
            "concat.py",
            "dtypes.py",
            "missing.py"
          ]
        }
      },
      "eabf89d174ed8164a09ae28c80e03e1fe5bf14c5": {
        "commit": {
          "commit_id": "eabf89d174ed8164a09ae28c80e03e1fe5bf14c5",
          "commit_message": "CLN: annotations in core.dtypes (#29503)",
          "commit_author": "jbrockmendel",
          "commit_date": "2019-11-12 18:38:26",
          "commit_parent": "17db6c565d6985989759fbb4c3b92f8ecd859de1"
        },
        "function": {
          "function_name": "is_string_dtype",
          "function_code_before": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
          "function_code_after": "def is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
          "function_before_start_line": 699,
          "function_before_end_line": 732,
          "function_after_start_line": 700,
          "function_after_end_line": 733,
          "function_before_token_count": 15,
          "function_after_token_count": 17,
          "functions_name_modified_file": [
            "is_datetime64_ns_dtype",
            "is_period",
            "is_any_int_dtype",
            "ensure_float",
            "is_numeric_dtype",
            "ensure_python_int",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "is_extension_array_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "_is_dtype",
            "is_datetime_arraylike",
            "ensure_str",
            "is_datetime_or_timedelta_dtype",
            "needs_i8_conversion",
            "is_categorical",
            "_is_dtype_type",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "is_sparse",
            "is_datetimetz",
            "is_interval_dtype",
            "infer_dtype_from_object",
            "ensure_categorical",
            "_validate_date_like_dtype",
            "is_scipy_sparse",
            "classes_and_not_datetimelike",
            "is_integer_dtype",
            "_is_unorderable_exception",
            "is_datetime64tz_dtype",
            "is_extension_type",
            "classes",
            "ensure_int_or_float",
            "is_object_dtype",
            "is_string_dtype"
          ],
          "functions_name_all_files": [
            "_parse_dtype_strict",
            "get_dtype_kinds",
            "maybe_castable",
            "ensure_python_int",
            "kind",
            "categories",
            "freq",
            "na_value_for_dtype",
            "cast_scalar_to_array",
            "register_extension_dtype",
            "is_timedelta64_ns_dtype",
            "subtype",
            "is_offsetlike",
            "is_dtype_equal",
            "is_complex_dtype",
            "_is_dtype",
            "is_dict_like",
            "ordered",
            "_from_values_or_dtype",
            "_concat_sparse",
            "__new__",
            "infer_dtype_from_array",
            "is_datetimetz",
            "notna",
            "_infer_fill_value",
            "validate_categories",
            "__init__",
            "maybe_convert_objects",
            "is_integer_dtype",
            "reset_cache",
            "is_nested_object",
            "maybe_convert_platform",
            "__setstate__",
            "classes",
            "infer_dtype_from_scalar",
            "ensure_int_or_float",
            "is_extension_array_dtype",
            "is_object_dtype",
            "unit",
            "__instancecheck__",
            "is_any_int_dtype",
            "construct_array_type",
            "is_period_arraylike",
            "_maybe_fill",
            "is_period_dtype",
            "is_string_like_dtype",
            "remove_na_arraylike",
            "pandas_dtype",
            "is_datetime64_dtype",
            "find_common_type",
            "_is_boolean",
            "ensure_str",
            "is_datetime_or_timedelta_dtype",
            "type",
            "is_sequence",
            "concat_categorical",
            "construct_1d_ndarray_preserving_na",
            "_isna_new",
            "_isna_ndarraylike",
            "__str__",
            "is_re",
            "_is_numeric",
            "is_iterator",
            "_isna_compat",
            "__getstate__",
            "maybe_promote",
            "classes_and_not_datetimelike",
            "is_extension_type",
            "array_equivalent",
            "create_pandas_abc_type",
            "maybe_cast_to_integer_array",
            "_iterable_not_string",
            "is_datetime64_ns_dtype",
            "name",
            "names",
            "maybe_infer_dtype_type",
            "is_period",
            "is_nested_list_like",
            "ensure_float",
            "update_dtype",
            "_get_dtype",
            "validate_ordered",
            "_from_categorical_dtype",
            "construct_from_string",
            "is_named_tuple",
            "is_categorical_dtype",
            "invalidate_string_dtypes",
            "is_signed_integer_dtype",
            "maybe_downcast_to_dtype",
            "is_unsigned_integer_dtype",
            "__hash__",
            "is_datetime_arraylike",
            "isna",
            "needs_i8_conversion",
            "is_hashable",
            "_concat_datetimetz",
            "_isna_ndarraylike_old",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "is_interval_dtype",
            "__eq__",
            "__repr__",
            "_from_fastpath",
            "maybe_cast_to_datetime",
            "is_array_like",
            "is_string_dtype",
            "_concatenate_2d",
            "maybe_infer_to_datetimelike",
            "_isna_old",
            "is_numeric_dtype",
            "find",
            "register",
            "soft_convert_objects",
            "is_valid_nat_for_dtype",
            "coerce_indexer_dtype",
            "is_int64_dtype",
            "is_dtype",
            "_convert_datetimelike_to_object",
            "infer_dtype_from",
            "concat_datetime",
            "is_timedelta64_dtype",
            "_hash_categories",
            "construct_1d_object_array_from_listlike",
            "na_value",
            "_finalize",
            "_is_dtype_type",
            "is_number",
            "maybe_upcast_putmask",
            "is_sparse",
            "infer_dtype_from_object",
            "maybe_downcast_numeric",
            "ensure_categorical",
            "_validate_date_like_dtype",
            "is_scipy_sparse",
            "_ensure_dtype_type",
            "_is_unorderable_exception",
            "is_re_compilable",
            "_use_inf_as_na",
            "coerce_to_dtypes",
            "is_datetime64tz_dtype",
            "construct_1d_arraylike_from_scalar",
            "union_categoricals",
            "tz",
            "is_file_like",
            "__ne__",
            "concat_compat",
            "astype_nansafe",
            "maybe_upcast"
          ],
          "functions_name_co_evolved_modified_file": [
            "is_datetime64_ns_dtype",
            "is_period",
            "is_numeric_dtype",
            "is_period_arraylike",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_timedelta64_ns_dtype",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_float_dtype",
            "is_sparse",
            "is_interval_dtype",
            "is_datetimetz",
            "is_scipy_sparse",
            "is_integer_dtype",
            "is_datetime64tz_dtype",
            "is_object_dtype"
          ],
          "functions_name_co_evolved_all_files": [
            "_concatenate_2d",
            "_iterable_not_string",
            "maybe_infer_to_datetimelike",
            "is_datetime64_ns_dtype",
            "names",
            "maybe_infer_dtype_type",
            "is_period",
            "maybe_castable",
            "name",
            "__instancecheck__",
            "is_nested_list_like",
            "is_numeric_dtype",
            "_isna_old",
            "is_period_arraylike",
            "na_value_for_dtype",
            "is_valid_nat_for_dtype",
            "is_int64_dtype",
            "is_dtype",
            "is_period_dtype",
            "infer_dtype_from",
            "construct_from_string",
            "is_string_like_dtype",
            "cast_scalar_to_array",
            "is_timedelta64_dtype",
            "is_named_tuple",
            "is_timedelta64_ns_dtype",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_unsigned_integer_dtype",
            "__hash__",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_hashable",
            "is_dict_like",
            "is_number",
            "is_sequence",
            "concat_categorical",
            "is_float_dtype",
            "infer_dtype_from_array",
            "construct_1d_ndarray_preserving_na",
            "is_sparse",
            "is_interval_dtype",
            "is_datetimetz",
            "__eq__",
            "is_re",
            "__repr__",
            "is_iterator",
            "is_scipy_sparse",
            "is_integer_dtype",
            "is_re_compilable",
            "maybe_cast_to_datetime",
            "_use_inf_as_na",
            "is_datetime64tz_dtype",
            "is_nested_object",
            "create_pandas_abc_type",
            "maybe_cast_to_integer_array",
            "construct_1d_arraylike_from_scalar",
            "union_categoricals",
            "is_file_like",
            "array_equivalent",
            "concat_compat",
            "is_array_like",
            "is_object_dtype",
            "infer_dtype_from_scalar",
            "astype_nansafe",
            "maybe_upcast"
          ]
        },
        "file": {
          "file_name": "common.py",
          "file_nloc": 1516,
          "file_complexity": 134,
          "file_token_count": 2295,
          "file_before": "\"\"\" common type operations \"\"\"\nfrom typing import Any, Callable, Union\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.compat import PY36\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype,\n    DatetimeTZDtype,\n    ExtensionDtype,\n    IntervalDtype,\n    PeriodDtype,\n    registry,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical,\n    ABCDateOffset,\n    ABCDatetimeIndex,\n    ABCIndexClass,\n    ABCPeriodArray,\n    ABCPeriodIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like,\n    is_bool,\n    is_complex,\n    is_decimal,\n    is_dict_like,\n    is_file_like,\n    is_float,\n    is_hashable,\n    is_integer,\n    is_interval,\n    is_iterator,\n    is_list_like,\n    is_named_tuple,\n    is_nested_list_like,\n    is_number,\n    is_re,\n    is_re_compilable,\n    is_scalar,\n    is_sequence,\n)\n\nfrom pandas._typing import ArrayLike\n\n_POSSIBLY_CAST_DTYPES = {\n    np.dtype(t).name\n    for t in [\n        \"O\",\n        \"int8\",\n        \"uint8\",\n        \"int16\",\n        \"uint16\",\n        \"int32\",\n        \"uint32\",\n        \"int64\",\n        \"uint64\",\n    ]\n}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_str(value: Union[bytes, Any]) -> str:\n    \"\"\"\n    Ensure that bytes and non-strings get converted into ``str`` objects.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n    elif not isinstance(value, str):\n        value = str(value)\n    return value\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int_or_float(arr: ArrayLike, copy: bool = False) -> np.array:\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible.\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: bool\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n\n    Notes\n    -----\n    If the array is explicitly of type uint64 the type\n    will remain unchanged.\n    \"\"\"\n    # TODO: GH27506 potential bug with ExtensionArrays\n    try:\n        return arr.astype(\"int64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        pass\n    try:\n        return arr.astype(\"uint64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        return arr.astype(\"float64\", copy=copy)\n\n\ndef ensure_python_int(value: Union[int, np.integer]) -> int:\n    \"\"\"\n    Ensure that a value is a python int.\n\n    Parameters\n    ----------\n    value: int or numpy.integer\n\n    Returns\n    -------\n    int\n\n    Raises\n    ------\n    TypeError: if the value isn't an int or can't be converted to one.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(\n            \"Value needs to be a scalar value, was type {}\".format(type(value))\n        )\n    msg = \"Wrong type {} for value {}\"\n    try:\n        new_value = int(value)\n        assert new_value == value\n    except (TypeError, ValueError, AssertionError):\n        raise TypeError(msg.format(type(value), value))\n    return new_value\n\n\ndef classes(*klasses) -> Callable:\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses) -> Callable:\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (\n        issubclass(tipo, klasses)\n        and not issubclass(tipo, (np.datetime64, np.timedelta64))\n    )\n\n\ndef is_object_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.Series(pd.SparseArray([0, 0, 1, 0])))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, \"dtype\", arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like with a\n        timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_datetimetz' is deprecated and will be removed in a \"\n        \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj):\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean\n        Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif is_list_like(arr_or_obj) and len(arr_or_obj) and is_object_dtype(arr_or_obj):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr):\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_period' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n        \"instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)\n\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical array-like or\n        PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, \"inferred_type\", None) == \"period\"\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like or\n        DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (\n            is_object_dtype(arr.dtype)\n            and lib.infer_dtype(arr, skipna=False) == \"datetime\"\n        )\n    return getattr(arr, \"inferred_type\", None) == \"datetime\"\n\n\ndef is_dtype_equal(source, target):\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    -------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a signed integer dtype\n        and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger)\n    )\n\n\ndef is_int64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, \"base\", None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a timedelta64,\n        or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e: TypeError) -> bool:\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    return \"unorderable\" in str(e)\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (\n        is_datetime_or_timedelta_dtype(arr_or_dtype)\n        or is_datetime64tz_dtype(arr_or_dtype)\n        or is_period_dtype(arr_or_dtype)\n    )\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_)\n    )\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in (\"S\", \"U\"))\n\n\ndef is_float_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return arr_or_dtype.is_object and arr_or_dtype.inferred_type == \"boolean\"\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    .. deprecated:: 1.0.0\n        Use ``is_extension_array_dtype`` instead.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a pandas extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n    warnings.warn(\n        \"'is_extension_type' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_extension_array_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype):\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n    return isinstance(dtype, ExtensionDtype) or registry.find(dtype) is not None\n\n\ndef is_complex_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a complex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisfied for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, ExtensionDtype):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, str):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in [\"datetimetz\", \"datetime64tz\"]:\n            return DatetimeTZDtype.type\n        elif dtype in [\"period\"]:\n            raise NotImplementedError\n\n        if dtype == \"datetime\" or dtype == \"timedelta\":\n            dtype += \"64\"\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype) -> None:\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError(\"{error}\".format(error=e))\n    if typ != \"generic\" and typ != \"ns\":\n        msg = \"{name!r} is too specific of a frequency, try passing {type!r}\"\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Convert input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except SyntaxError:\n        # np.dtype uses `eval` which can raise SyntaxError\n        raise TypeError(\"data type '{}' not understood\".format(dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, \"object\", \"O\"]:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == \"O\":\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_after": "\"\"\" common type operations \"\"\"\nfrom typing import Any, Callable, Union\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.compat import PY36\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype,\n    DatetimeTZDtype,\n    ExtensionDtype,\n    IntervalDtype,\n    PeriodDtype,\n    registry,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical,\n    ABCDateOffset,\n    ABCDatetimeIndex,\n    ABCIndexClass,\n    ABCPeriodArray,\n    ABCPeriodIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like,\n    is_bool,\n    is_complex,\n    is_decimal,\n    is_dict_like,\n    is_file_like,\n    is_float,\n    is_hashable,\n    is_integer,\n    is_interval,\n    is_iterator,\n    is_list_like,\n    is_named_tuple,\n    is_nested_list_like,\n    is_number,\n    is_re,\n    is_re_compilable,\n    is_scalar,\n    is_sequence,\n)\n\nfrom pandas._typing import ArrayLike\n\n_POSSIBLY_CAST_DTYPES = {\n    np.dtype(t).name\n    for t in [\n        \"O\",\n        \"int8\",\n        \"uint8\",\n        \"int16\",\n        \"uint16\",\n        \"int32\",\n        \"uint32\",\n        \"int64\",\n        \"uint64\",\n    ]\n}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_str(value: Union[bytes, Any]) -> str:\n    \"\"\"\n    Ensure that bytes and non-strings get converted into ``str`` objects.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n    elif not isinstance(value, str):\n        value = str(value)\n    return value\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int_or_float(arr: ArrayLike, copy: bool = False) -> np.array:\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible.\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: bool\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n\n    Notes\n    -----\n    If the array is explicitly of type uint64 the type\n    will remain unchanged.\n    \"\"\"\n    # TODO: GH27506 potential bug with ExtensionArrays\n    try:\n        return arr.astype(\"int64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        pass\n    try:\n        return arr.astype(\"uint64\", copy=copy, casting=\"safe\")  # type: ignore\n    except TypeError:\n        return arr.astype(\"float64\", copy=copy)\n\n\ndef ensure_python_int(value: Union[int, np.integer]) -> int:\n    \"\"\"\n    Ensure that a value is a python int.\n\n    Parameters\n    ----------\n    value: int or numpy.integer\n\n    Returns\n    -------\n    int\n\n    Raises\n    ------\n    TypeError: if the value isn't an int or can't be converted to one.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(\n            \"Value needs to be a scalar value, was type {}\".format(type(value))\n        )\n    msg = \"Wrong type {} for value {}\"\n    try:\n        new_value = int(value)\n        assert new_value == value\n    except (TypeError, ValueError, AssertionError):\n        raise TypeError(msg.format(type(value), value))\n    return new_value\n\n\ndef classes(*klasses) -> Callable:\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses) -> Callable:\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (\n        issubclass(tipo, klasses)\n        and not issubclass(tipo, (np.datetime64, np.timedelta64))\n    )\n\n\ndef is_object_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.Series(pd.SparseArray([0, 0, 1, 0])))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, \"dtype\", arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    assert _is_scipy_sparse is not None\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like with a\n        timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_datetimetz' is deprecated and will be removed in a \"\n        \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj) -> bool:\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean\n        Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif is_list_like(arr_or_obj) and len(arr_or_obj) and is_object_dtype(arr_or_obj):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\n        \"'is_period' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n        \"instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in (\"O\", \"S\", \"U\") and not is_period_dtype(dtype)\n\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical array-like or\n        PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, \"inferred_type\", None) == \"period\"\n\n\ndef is_datetime_arraylike(arr) -> bool:\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like or\n        DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (\n            is_object_dtype(arr.dtype)\n            and lib.infer_dtype(arr, skipna=False) == \"datetime\"\n        )\n    return getattr(arr, \"inferred_type\", None) == \"datetime\"\n\n\ndef is_dtype_equal(source, target) -> bool:\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    -------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a signed integer dtype\n        and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger)\n    )\n\n\ndef is_int64_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, \"base\", None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a timedelta64,\n        or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e: TypeError) -> bool:\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    return \"unorderable\" in str(e)\n\n\ndef needs_i8_conversion(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (\n        is_datetime_or_timedelta_dtype(arr_or_dtype)\n        or is_datetime64tz_dtype(arr_or_dtype)\n        or is_period_dtype(arr_or_dtype)\n    )\n\n\ndef is_numeric_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_)\n    )\n\n\ndef is_string_like_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in (\"S\", \"U\"))\n\n\ndef is_float_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return arr_or_dtype.is_object and arr_or_dtype.inferred_type == \"boolean\"\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    .. deprecated:: 1.0.0\n        Use ``is_extension_array_dtype`` instead.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a pandas extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n    warnings.warn(\n        \"'is_extension_type' is deprecated and will be removed in a future \"\n        \"version.  Use 'is_extension_array_dtype' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype):\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, \"dtype\", arr_or_dtype)\n    return isinstance(dtype, ExtensionDtype) or registry.find(dtype) is not None\n\n\ndef is_complex_dtype(arr_or_dtype) -> bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a complex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition) -> bool:\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisfied for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, ExtensionDtype):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, \"dtype\"):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, str):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in [\"datetimetz\", \"datetime64tz\"]:\n            return DatetimeTZDtype.type\n        elif dtype in [\"period\"]:\n            raise NotImplementedError\n\n        if dtype == \"datetime\" or dtype == \"timedelta\":\n            dtype += \"64\"\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype) -> None:\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError(\"{error}\".format(error=e))\n    if typ != \"generic\" and typ != \"ns\":\n        msg = \"{name!r} is too specific of a frequency, try passing {type!r}\"\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Convert input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except SyntaxError:\n        # np.dtype uses `eval` which can raise SyntaxError\n        raise TypeError(\"data type '{}' not understood\".format(dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, \"object\", \"O\"]:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == \"O\":\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_patch": "@@ -222,7 +222,7 @@ def classes_and_not_datetimelike(*klasses) -> Callable:\n     )\n \n \n-def is_object_dtype(arr_or_dtype):\n+def is_object_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether an array-like or dtype is of the object dtype.\n \n@@ -252,7 +252,7 @@ def is_object_dtype(arr_or_dtype):\n     return _is_dtype_type(arr_or_dtype, classes(np.object_))\n \n \n-def is_sparse(arr):\n+def is_sparse(arr) -> bool:\n     \"\"\"\n     Check whether an array-like is a 1-D pandas sparse array.\n \n@@ -304,7 +304,7 @@ def is_sparse(arr):\n     return isinstance(dtype, SparseDtype)\n \n \n-def is_scipy_sparse(arr):\n+def is_scipy_sparse(arr) -> bool:\n     \"\"\"\n     Check whether an array-like is a scipy.sparse.spmatrix instance.\n \n@@ -339,6 +339,7 @@ def is_scipy_sparse(arr):\n         except ImportError:\n             _is_scipy_sparse = lambda _: False\n \n+    assert _is_scipy_sparse is not None\n     return _is_scipy_sparse(arr)\n \n \n@@ -375,7 +376,7 @@ def is_categorical(arr) -> bool:\n     return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n \n \n-def is_datetimetz(arr):\n+def is_datetimetz(arr) -> bool:\n     \"\"\"\n     Check whether an array-like is a datetime array-like with a timezone\n     component in its dtype.\n@@ -425,7 +426,7 @@ def is_datetimetz(arr):\n     return is_datetime64tz_dtype(arr)\n \n \n-def is_offsetlike(arr_or_obj):\n+def is_offsetlike(arr_or_obj) -> bool:\n     \"\"\"\n     Check if obj or all elements of list-like is DateOffset\n \n@@ -456,7 +457,7 @@ def is_offsetlike(arr_or_obj):\n     return False\n \n \n-def is_period(arr):\n+def is_period(arr) -> bool:\n     \"\"\"\n     Check whether an array-like is a periodical index.\n \n@@ -493,7 +494,7 @@ def is_period(arr):\n     return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n \n \n-def is_datetime64_dtype(arr_or_dtype):\n+def is_datetime64_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether an array-like or dtype is of the datetime64 dtype.\n \n@@ -524,7 +525,7 @@ def is_datetime64_dtype(arr_or_dtype):\n     return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n \n \n-def is_datetime64tz_dtype(arr_or_dtype):\n+def is_datetime64tz_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n \n@@ -562,7 +563,7 @@ def is_datetime64tz_dtype(arr_or_dtype):\n     return DatetimeTZDtype.is_dtype(arr_or_dtype)\n \n \n-def is_timedelta64_dtype(arr_or_dtype):\n+def is_timedelta64_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether an array-like or dtype is of the timedelta64 dtype.\n \n@@ -593,7 +594,7 @@ def is_timedelta64_dtype(arr_or_dtype):\n     return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n \n \n-def is_period_dtype(arr_or_dtype):\n+def is_period_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether an array-like or dtype is of the Period dtype.\n \n@@ -627,7 +628,7 @@ def is_period_dtype(arr_or_dtype):\n     return PeriodDtype.is_dtype(arr_or_dtype)\n \n \n-def is_interval_dtype(arr_or_dtype):\n+def is_interval_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether an array-like or dtype is of the Interval dtype.\n \n@@ -696,7 +697,7 @@ def is_categorical_dtype(arr_or_dtype) -> bool:\n     return CategoricalDtype.is_dtype(arr_or_dtype)\n \n \n-def is_string_dtype(arr_or_dtype):\n+def is_string_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of the string dtype.\n \n@@ -732,7 +733,7 @@ def is_string_dtype(arr_or_dtype):\n     return _is_dtype(arr_or_dtype, condition)\n \n \n-def is_period_arraylike(arr):\n+def is_period_arraylike(arr) -> bool:\n     \"\"\"\n     Check whether an array-like is a periodical array-like or PeriodIndex.\n \n@@ -764,7 +765,7 @@ def is_period_arraylike(arr):\n     return getattr(arr, \"inferred_type\", None) == \"period\"\n \n \n-def is_datetime_arraylike(arr):\n+def is_datetime_arraylike(arr) -> bool:\n     \"\"\"\n     Check whether an array-like is a datetime array-like or DatetimeIndex.\n \n@@ -799,7 +800,7 @@ def is_datetime_arraylike(arr):\n     return getattr(arr, \"inferred_type\", None) == \"datetime\"\n \n \n-def is_dtype_equal(source, target):\n+def is_dtype_equal(source, target) -> bool:\n     \"\"\"\n     Check if two dtypes are equal.\n \n@@ -889,7 +890,7 @@ def is_any_int_dtype(arr_or_dtype) -> bool:\n     return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))\n \n \n-def is_integer_dtype(arr_or_dtype):\n+def is_integer_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of an integer dtype.\n \n@@ -944,7 +945,7 @@ def is_integer_dtype(arr_or_dtype):\n     return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))\n \n \n-def is_signed_integer_dtype(arr_or_dtype):\n+def is_signed_integer_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of a signed integer dtype.\n \n@@ -1001,7 +1002,7 @@ def is_signed_integer_dtype(arr_or_dtype):\n     return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n \n \n-def is_unsigned_integer_dtype(arr_or_dtype):\n+def is_unsigned_integer_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of an unsigned integer dtype.\n \n@@ -1050,7 +1051,7 @@ def is_unsigned_integer_dtype(arr_or_dtype):\n     )\n \n \n-def is_int64_dtype(arr_or_dtype):\n+def is_int64_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of the int64 dtype.\n \n@@ -1141,7 +1142,7 @@ def is_datetime64_any_dtype(arr_or_dtype) -> bool:\n     return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)\n \n \n-def is_datetime64_ns_dtype(arr_or_dtype):\n+def is_datetime64_ns_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of the datetime64[ns] dtype.\n \n@@ -1191,7 +1192,7 @@ def is_datetime64_ns_dtype(arr_or_dtype):\n     return tipo == _NS_DTYPE or getattr(tipo, \"base\", None) == _NS_DTYPE\n \n \n-def is_timedelta64_ns_dtype(arr_or_dtype):\n+def is_timedelta64_ns_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n \n@@ -1222,7 +1223,7 @@ def is_timedelta64_ns_dtype(arr_or_dtype):\n     return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n \n \n-def is_datetime_or_timedelta_dtype(arr_or_dtype):\n+def is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of\n     a timedelta64 or datetime64 dtype.\n@@ -1285,7 +1286,7 @@ def _is_unorderable_exception(e: TypeError) -> bool:\n     return \"unorderable\" in str(e)\n \n \n-def needs_i8_conversion(arr_or_dtype):\n+def needs_i8_conversion(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the array or dtype should be converted to int64.\n \n@@ -1329,7 +1330,7 @@ def needs_i8_conversion(arr_or_dtype):\n     )\n \n \n-def is_numeric_dtype(arr_or_dtype):\n+def is_numeric_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of a numeric dtype.\n \n@@ -1372,7 +1373,7 @@ def is_numeric_dtype(arr_or_dtype):\n     )\n \n \n-def is_string_like_dtype(arr_or_dtype):\n+def is_string_like_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of a string-like dtype.\n \n@@ -1404,7 +1405,7 @@ def is_string_like_dtype(arr_or_dtype):\n     return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in (\"S\", \"U\"))\n \n \n-def is_float_dtype(arr_or_dtype):\n+def is_float_dtype(arr_or_dtype) -> bool:\n     \"\"\"\n     Check whether the provided array or dtype is of a float dtype.\n \n",
          "files_name_in_blame_commit": [
            "common.py",
            "base.py",
            "concat.py",
            "dtypes.py",
            "generic.py",
            "inference.py",
            "missing.py",
            "cast.py"
          ]
        }
      },
      "bb6135880e5e453d7701764b9f2e4ad3356a68d7": {
        "commit": {
          "commit_id": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
          "commit_message": "STYLE: Apply black formatting",
          "commit_author": "Joris Van den Bossche",
          "commit_date": "2019-07-03 23:28:23",
          "commit_parent": "4199c98a26ed51674b5d21cba039867640225510"
        },
        "function": {
          "function_name": "is_string_dtype",
          "function_code_before": "",
          "function_code_after": "",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": "",
          "function_after_end_line": "",
          "function_before_token_count": 0,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "get_callable_name",
            "is_full_slice",
            "standardize_mapping",
            "maybe_box_datetimelike",
            "dict_keys_to_ordered_list",
            "_pipe",
            "random_state",
            "count_not_none",
            "dict_compat",
            "_get_rename_function",
            "flatten",
            "is_null_slice",
            "_any_none",
            "_not_none",
            "index_labels_to_array",
            "cast_scalar_indexer",
            "asarray_tuplesafe",
            "apply_if_callable",
            "_any_not_none",
            "maybe_iterable_to_list",
            "_all_not_none",
            "consensus_name_attr",
            "is_true_slices",
            "is_bool_indexer",
            "_all_none",
            "maybe_make_list",
            "try_sort",
            "maybe_box"
          ],
          "functions_name_all_files": [
            "check_funs",
            "test_fifth_week_of_month_infer",
            "check_for_ordered",
            "test_to_records_dict_like",
            "test_truncate_ndots",
            "test_apply_iteration",
            "test_join_on_series_buglet",
            "time_merge_ordered",
            "test_spam_url",
            "test_equality",
            "test_wide_repr_multiindex_cols",
            "test_to_offset_no_evaluate",
            "test_to_latex_format",
            "test_td64arr_mod_int",
            "test_rank_empty_group",
            "test_set_index_pass_arrays",
            "test_inf_na_values_with_int_index",
            "test_pivot_no_values",
            "test_datetime64tz_aware",
            "select",
            "ordered",
            "test_groupby_bool_aggs",
            "test_long_strings",
            "_handle_lowerdim_multi_index_axis0",
            "time_iter",
            "_box_func",
            "test_loc_multiindex_missing_label_raises",
            "test_nbytes_integer",
            "test_merge_on_extension_array",
            "test_upsampling_ohlc",
            "_sqlalchemy_type",
            "_clean_spaces_backtick_quoted_names",
            "test_groupby_multilevel_with_transform",
            "is_nested_tuple",
            "test_dt64arr_add_sub_DateOffsets",
            "period_index",
            "test_datetime64formatter_yearmonth",
            "test_groupby_with_hier_columns",
            "test_same_len_hash_collisions",
            "test_from_coo",
            "in_interactive_session",
            "test_to_json_compression",
            "test_omit_nuisance_python_multiple",
            "test_format_timedelta_ticks_narrow",
            "_transform_should_cast",
            "_build_xpath_expr",
            "test_interp_unlimited",
            "test_usecols_with_parse_dates2",
            "from_range",
            "test_loc_getitem_label_list",
            "drop_duplicates",
            "test_dti_equals_with_tz",
            "test_numpy_type_funcs",
            "test_match",
            "test_set_index_pass_arrays_duplicate",
            "test_is_unique_class_ne",
            "test_split_blank_string",
            "test_multilevel_name_print",
            "_format_datetime64",
            "test_constructor_with_datetimelike",
            "test_first_last_tz_multi_column",
            "test_to_csv_from_csv2",
            "test_constructor_map",
            "test_columns_dtypes",
            "get_calendar",
            "test_set_index_cast",
            "test_comparison_flex_alignment",
            "test_get_indexer_consistency",
            "test_dataframe_constructor_with_dtype",
            "assert_class_equal",
            "_convert_axes",
            "_get_splitter",
            "test_dataframe_dummies_subset",
            "test_name_printing",
            "__next__",
            "is_datetime_or_timedelta_dtype",
            "test_setitem_single_column_mixed_datetime",
            "test_read_with_bad_header",
            "get_sheet_by_index",
            "test_frame_equal_index_mismatch",
            "test_empty_constructor",
            "test_frame_non_unique_index",
            "_infer_types",
            "test_query_with_partially_named_multiindex",
            "test_replace",
            "test_drop_preserve_names",
            "test_rolling_sum",
            "_get_axis_resolvers",
            "test_expanding_corr",
            "test_categorical_conversion",
            "test_round_trip_frame",
            "test_numpy_take",
            "test_to_offset_pd_timedelta",
            "test_date_export_formats",
            "test_read_gbq_without_deprecated_kwargs",
            "test_asarray_datetime64",
            "test_ragged_max",
            "test_iterator2",
            "test_query_with_named_multiindex",
            "test_3",
            "test_failing_subscript_with_name_error",
            "test_assert_almost_equal_dicts",
            "test_union_misc",
            "test_read_with_parse_dates_scalar_non_bool",
            "test_coerce_outside_ns_bounds",
            "test_regex_replace_list_to_scalar",
            "test_td64arr_add_sub_float",
            "test_convert_nested",
            "test_bytes_io",
            "_get_errorbars",
            "_add_series_only_operations",
            "_check_for_default_values",
            "validate_ordered",
            "test_take_allow_fill",
            "test_frame_equal_block_mismatch",
            "test_cmov_window_na_min_periods",
            "test_conversions",
            "test_column_select_via_attr",
            "test_partially_invalid_plot_data",
            "test_str_accessor_no_new_attributes",
            "test_map_with_nan",
            "test_merge_index_singlekey_inner",
            "test_right_outer_join",
            "no_description_period",
            "test_left_outer_join",
            "time_rename_axis0",
            "test_ensure_platform_int",
            "get_series_na",
            "test_parse_dates_implicit_first_col",
            "test_grouper_iter",
            "test_slice_floats",
            "test_partial_setting_mixed_dtype",
            "_f1",
            "sequence_to_dt64ns",
            "test_sum_bool",
            "test_intersection_non_monotonic_non_unique",
            "mixed_int_frame",
            "test_trailing_delimiters",
            "test_lookup_nan",
            "time_index_from_array_string",
            "time_isnull_floats_no_null",
            "test_nan_irregular_index",
            "test_multi_function_flexible_mix",
            "test_frame_to_time_stamp",
            "get_locator",
            "_time_shift",
            "_not_in",
            "multi_line",
            "_generate_marginal_results_without_values",
            "header_style",
            "test_encoding_latin1_118",
            "test_constructor_freq_mult",
            "test_tdi_total_seconds",
            "test_2d_other_dtypes",
            "test_set_index_append_to_multiindex",
            "test_overlaps_interval_container",
            "test_copy_name",
            "test_grouper_getting_correct_binner",
            "test_infer_freq_index",
            "test_repr_obeys_max_seq_limit",
            "from_scalars",
            "_get_axes_layout",
            "_read",
            "test_reindex_level",
            "storable",
            "test_reader_dtype",
            "test_read_map_header",
            "test_series_map_box_timestamps",
            "test_missing_unicode_key",
            "test_at_time_raises",
            "is_dtype",
            "test_excel_sheet_by_name_raise",
            "__divmod__",
            "test_boolean_indexing_mixed",
            "time_days_in_month",
            "by_blocks_fixture",
            "_get_object_parser",
            "test_difference_incomparable_true",
            "test_reindex_dtype",
            "test_missing_right_by",
            "_skew_kurt_wrap",
            "argmin",
            "test_fillna_series_timedelta64",
            "test_interp_limit_bad_direction",
            "test_date_range_int64_overflow_non_recoverable",
            "test_date_range_timestamp_equiv_from_datetime_instance",
            "test_empty_fancy_raises",
            "time_frame_xs",
            "test_group_selection_cache",
            "ensure_categorical",
            "_get_nearest_indexer",
            "_set_categories",
            "test_complex",
            "test_to_records_with_Mapping_type",
            "test_to_string_without_index",
            "test_complex_series_frame_alignment",
            "get_random_path",
            "tsplot",
            "test_tz_localize_roundtrip",
            "string_dtype",
            "_typ",
            "test_pi_sub_isub_pi",
            "test_get_loc_closed",
            "time_parse_iso8601_no_tz",
            "test_dataframe_dummies_drop_first_with_na",
            "_replace_nans",
            "test_default_date_load",
            "clip_lower",
            "time_series_timedeltas",
            "rsplit",
            "test_set_option_multiple",
            "compat_props",
            "test_nearest",
            "test_resample_with_nat",
            "test_value_counts_normalized",
            "test_extractall_no_matches",
            "test_to_string_line_width",
            "test_get_attr",
            "_load_test1_data",
            "test_constructor_bad_file",
            "test_constructor_invalid_dtype_raises",
            "test_excel_roundtrip_datetime",
            "time_rank",
            "pad_1d",
            "time_iteritems_cached",
            "test_arith_ops_df_compat",
            "_get_unique_index",
            "to_feather",
            "test_xs_loc_equality",
            "test_set_value_resize",
            "test_update_from_non_df",
            "pytest_addoption",
            "render_pep440_post",
            "test_replace_multiple",
            "test_binop_typecasting",
            "str_slice_replace",
            "test_getitem_simple",
            "_parse_errorbars",
            "test_apply_multi_index",
            "test_closed_median_quantile",
            "makeCategoricalIndex",
            "test_read_excel_multiindex_header_only",
            "test_to_string_left_justify_cols",
            "test_astype_str_compat",
            "any_numpy_array",
            "test_cmov_window_frame",
            "test_take_bounds",
            "test_downcast_conversion_no_nan",
            "_format_datetime64_dateonly",
            "validate_kwargs",
            "cython_table_items",
            "time_week",
            "test_filter_single_column_df",
            "_verify_integrity",
            "write_index",
            "test_maybe_promote_datetimetz_with_any_numpy_dtype",
            "_assert_insert_conversion",
            "obj",
            "test_concat_bug_3602",
            "test_nat_ops",
            "time_read_excel",
            "test_array_equivalent_compat",
            "test_pct_max_many_rows",
            "test_mixed_index_at_iat_loc_iloc_dataframe",
            "test_invalid_xy_args_dup_cols",
            "test_construction_not_supported",
            "test_after_nearest_workday",
            "test_add_string",
            "test_sort_nat",
            "test_iloc_getitem_array",
            "_get_opstr",
            "test_td64arr_add_td64_array",
            "test_iso_conversion",
            "test_reset_index_name",
            "test_query_scope",
            "test_apply_out_of_range",
            "test_euro_decimal_format",
            "_write_map",
            "test_to_integer_array_error",
            "test_fancy_slice_partial",
            "test_getitem_boolean_empty",
            "time_unique",
            "test_pindex_fieldaccessor_nat",
            "time_to_time",
            "test_line_plot_datetime_frame",
            "test_dti_date",
            "test_new_axis",
            "_get_op_name",
            "test_merge_incompat_infer_boolean_object",
            "time_series_datetimeindex_repr",
            "test_agg_period_index",
            "test_frame_mixedtype_orient",
            "test_cython_with_timestamp_and_nat",
            "test_as_index_series_return_frame",
            "test_join_multi",
            "test_set_levels_categorical",
            "test_downcast_not8bit",
            "_is_multi_agg_with_relabel",
            "test_mean",
            "test_closed_one_entry_groupby",
            "test_hash_scalar",
            "test_dti_tz_localize_nonexistent_raise_coerce",
            "test_na_values_dict_aliasing",
            "test_build_table_schema",
            "test_numpy_array",
            "read_index",
            "notnull",
            "test_set_categories_inplace",
            "zip_html",
            "test_datetime_invalid_datatype",
            "test_where_other",
            "_partial_tup_index",
            "_check_bar_alignment",
            "tz_localize",
            "test_td64arr_floordiv_tdscalar",
            "test_groupby_dtype_inference_empty",
            "from_codes",
            "construct_from_string",
            "test_round_nonunique_categorical",
            "test_warns_non_roundtrippable_names",
            "test_join_append_timedeltas",
            "test_split",
            "get_flattened_iterator",
            "test_to_hdf_with_object_column_names",
            "time_plot_table",
            "test_get_loc_bad_tolerance_raises",
            "test_identical",
            "nankurt",
            "_make_selectors",
            "test_get_filepath_or_buffer_with_buffer",
            "test_repeat",
            "test_fake_qtconsole_repr_html",
            "time_float_int_lines",
            "is_categorical",
            "test_agg_reduce",
            "_apply_loffset",
            "test_df_arith_2d_array_rowlike_broadcasts",
            "test_sub_delta",
            "test_date_range_out_of_bounds",
            "_check_method_works",
            "test_value_counts_bins",
            "_from_selection",
            "test_reindex_positional_warns",
            "test_lines_with_compression",
            "dataframe_with_duplicate_index",
            "is_interval",
            "test_unit_ignore_keeps_name",
            "plus_or_dot",
            "_get_group_keys",
            "test_hash",
            "test_cython_agg_boolean",
            "test_loc_axis_arguments",
            "sortlevel",
            "time_dt_accessor_month_name",
            "test_dti_custom_getitem_matplotlib_hackaround",
            "test_join_index_mixed",
            "dot",
            "_check_parser",
            "time_sortlevel_int64",
            "test_value_counts_int",
            "test_maybe_indices_to_slice_middle",
            "test_get_locales_at_least_one",
            "build_fill",
            "test_str_uses_object",
            "test_constructor_int_overflow",
            "test_rmod_invalid",
            "test_series_tz_convert",
            "test_tdi_sub_dt64_array",
            "_convert_to_indexer",
            "_from_sequence",
            "test_seriesgroupby_name_attr",
            "test_str_bool_series_indexing",
            "test_empty_dtypes",
            "_addsub_offset_array",
            "test_at_time_errors",
            "test_read_csv_buglet_4x_multi_index2",
            "time_float_int",
            "is_timedelta64_dtype",
            "test_ufuncs",
            "test_to_datetime_pydatetime",
            "_maybe_clear_freq",
            "test_two_backtick_variables_query",
            "time_on_int",
            "test_contains_dunder",
            "test_pi_comp_period_nat",
            "test_fillna_index_period",
            "test_unsorted_index",
            "exists",
            "test_css_to_excel_good_colors",
            "test_replace_dst_fold",
            "test_setitem_empty_indxer",
            "test_multiindex_period_datetime",
            "test_keys",
            "test_default_handler_numpy_unsupported_dtype",
            "_check_promote",
            "test_parse_public_s3_bucket_chunked_python",
            "_evaluate_with_timedelta_like",
            "_read_old_header",
            "test_calendar_roundtrip_issue",
            "test_localized_at_time_between_time",
            "test_matmul",
            "test_is_all_dates",
            "test_timedelta_mode",
            "correct_parameters",
            "test_label_overflow",
            "test_getitem_boolean_list",
            "visit_Index",
            "test_hash_collisions",
            "test_basic_downsample",
            "test_append_series_dict",
            "end_time",
            "read_coordinates",
            "test_combine_add",
            "test_to_records_with_multindex",
            "is_datelike_mixed_type",
            "test_groupby_multiindex_missing_pair",
            "test_tsplot_deprecated",
            "test_format_with_name_time_info",
            "test_secondary_bar_frame",
            "maybe_upcast",
            "test_setitem_invalidates_datetime_index_freq",
            "test_bar_barwidth_position",
            "test_argsort_missing_array",
            "generate_filter_op",
            "_check_op_integer",
            "test_at",
            "test_resample_to_quarterly",
            "test_store_timezone",
            "test_range_misspecified",
            "test_expanding_func",
            "time_series_categorical",
            "_bool_method_SERIES",
            "test_register_writer",
            "swaplevel",
            "ex",
            "mem_itertuples_to_list",
            "test_info_wide",
            "test_to_sql_method_callable",
            "_format_value",
            "test_add_iadd_timedeltalike_annual",
            "test_bar_align_left_0points",
            "_check_thousands",
            "test_reset_index_range",
            "test_dt64arr_sub_datetime64_not_ns",
            "test_take_na_value_other_decimal",
            "_get_formatter",
            "test_to_csv_write_to_open_file",
            "tolist",
            "test_is_float_dtype",
            "engine_has_neg_frac",
            "_flex_method_SERIES",
            "test_getitem_scalar",
            "test_sub_single_tz",
            "time_chained_indexing",
            "time_getitem_pos_slice",
            "test_to_string_with_formatters",
            "test_sort_index_level_and_column_label",
            "test_agg_ser_multi_key",
            "_rows_to_cols",
            "cummin",
            "_clean_index_names",
            "set_atom_data",
            "test_sub_n_gt_1_offsets",
            "test_hash_equivalent",
            "test_holiday_dates",
            "test_categorical_concat_append",
            "_get_canonical_key",
            "test_replace_str_to_str_chain",
            "test_frame_setitem",
            "time_reindex_missing",
            "codes",
            "test_constructor_ragged",
            "test_cumcount_mi",
            "test_rw_nthreads",
            "test_if_scatterplot_colorbar_affects_xaxis_visibility",
            "test_concat_ignore_index",
            "test_concat_sorts_index",
            "test_constructor_keyword",
            "test_split_no_pat_with_nonzero_n",
            "test_isna_isnull",
            "df_duplabels",
            "df",
            "test_view_index",
            "test_buffer_rd_bytes",
            "test_dropna_no_nan",
            "axis_series",
            "test_tz_convert_nat",
            "test_groupby_dict_mapping",
            "_validate_td64_dtype",
            "test_total_seconds",
            "test_reindex_preserves_name_if_target_is_list_or_ndarray",
            "test_read_hdf_iterator",
            "test_allow_exact_matches_forward",
            "test1_index",
            "test_construct_errors",
            "test_duplicate_argument",
            "test_replace_mixed_types",
            "_cast_values_for_fillna",
            "test_union_bug_1745",
            "set_eng_float_format",
            "test_subclassed_melt",
            "dst",
            "unconvert",
            "_validate_index_level",
            "test_concat_datetime_timezone",
            "test_extractall_single_group_with_quantifier",
            "test_generic",
            "test_astype_idempotent",
            "test_add_datetimelike_and_dti",
            "on_right",
            "test_getitem_unordered_dup",
            "test_bar_align_mid_axis_none",
            "_align_core",
            "any_numpy_dtype",
            "cast_scalar_indexer",
            "test_str_for_named_is_name",
            "format_date_labels",
            "test_nth_column_order",
            "test_get_loc_datetimelike_nonoverlapping",
            "from_spmatrix",
            "test_corr_callable_method",
            "sort_with_none",
            "box_expected",
            "test_encode_numeric_overflow_nested",
            "test_iloc_getitem_neg_int",
            "test_iso_8601_strings_with_different_offsets",
            "test_loc_getitem_dups2",
            "test_date_index_query_with_NaT",
            "test_multiple_header_rows",
            "test_frame_getitem_not_sorted",
            "test_roundtrip_pickle_with_tz",
            "test_na_actions_categorical",
            "ror_",
            "test_maybe_promote_float_with_int",
            "test_astype_to_incorrect_datetimelike",
            "numpy_dtype",
            "check_setitem_lengths",
            "test_categorical_dtype_latin1",
            "test_file_handle_string_io",
            "test_nanall",
            "time_read_sql_query",
            "test_apply_categorical_with_nan_values",
            "_convert_to_font",
            "test_groupby_level",
            "testStrictUnicodePack",
            "testRollforward2",
            "justify",
            "time_index_slice",
            "test_constructor_single_value",
            "_background_gradient",
            "test_eval_resolvers_as_list",
            "test_all_values_single_bin",
            "test_nat_vector_field_access",
            "test_setslice",
            "test_describe_empty_object",
            "coerce_to_target_dtype",
            "test_css_to_excel_multiple",
            "test_indexing",
            "test_resample_empty_series",
            "test_merge_on_multikey",
            "load_iris_data",
            "var",
            "to_ea_dtypes",
            "test_pivot_with_interval_index",
            "test_td_floordiv_numeric_scalar",
            "run_binary",
            "translate_In",
            "_summary",
            "test_ops_general",
            "test_index_ctor_infer_periodindex",
            "test_categorical_comparisons",
            "test_index_subclass_constructor_wrong_kwargs",
            "test_join_multi_to_multi",
            "test_partition_to_dataframe",
            "test_to_csv_from_csv_w_all_infs",
            "_process_date_conversion",
            "test_decode_broken_json_leak",
            "to_numpy",
            "time_get_indexer_list",
            "strict_data_files",
            "test_reset_index_with_drop",
            "test_fillna_raise",
            "test_datetime_nan_mask",
            "test_drop_column",
            "_selection_list",
            "_read_value_labels",
            "test_tdarr_div_length_mismatch",
            "build_kwargs",
            "test_nested_dict_construction",
            "test_sum_corner",
            "time_qcut_timedelta",
            "test_rank_avg_even_vals",
            "to_period",
            "_process_columntext_subheader",
            "test_whitespace_preservation",
            "_handle_date_column",
            "test_ix_deprecation",
            "test__bn_ok_dtype",
            "time_cache_readonly",
            "time_rolling",
            "test_concat_empty_series_dtypes_roundtrips",
            "test_categorical_equal_ordered_mismatch",
            "test_encode_with_decimal",
            "test_getslice_tuple",
            "test_put_string_index",
            "test_add_signed_zeros",
            "_choose_path",
            "test_join_many_non_unique_index",
            "test_to_string_with_datetime64_monthformatter",
            "test_minmax_nat_dataframe",
            "_maybe_convert_index",
            "_stop",
            "test_constructor_from_index_series_period",
            "test_where_setitem_invalid",
            "test_maybe_promote_bytes_with_any",
            "test_consistent_names",
            "test_astype_to_datetimelike_unit",
            "test_info_categorical",
            "test_downsample_non_unique",
            "test_constructor_convert_index_once",
            "month_classes",
            "register",
            "test_td64arr_with_offset_series",
            "test_map_with_categorical_series",
            "_check_grid_settings",
            "from_records",
            "test_to_timestamp",
            "test_encode_date_conversion",
            "test_file_binary_mode",
            "test_is_empty",
            "test_quantile_interpolation_dtype",
            "test_interpolate_invalid_nonpositive_limit",
            "_setup_subplots",
            "test_validate_bool_kwarg",
            "test_datetime_fractional_seconds",
            "test_td_add_sub_numeric_raises",
            "test_not_equal",
            "test_extension_array",
            "test_from_freq_recreate_from_data",
            "double_blank_lines",
            "test_is_numeric_v_string_like",
            "time_timedelta_seconds",
            "_finalize",
            "test_series_ix_getitem_fancy",
            "decons_group_index",
            "test_read_excel_chunksize",
            "test_setitem_iloc_scalar_multiple_homogoneous",
            "test_compression_blosc",
            "test_replace_aware",
            "test_rank_average_pct",
            "test_ops_properties_basic",
            "test_isAnchored",
            "test_write_bytes",
            "_construct_axes_dict",
            "_compute_grand_margin",
            "test_axis_share_x",
            "test_frame_from_records_utc",
            "_from_factorized",
            "test_repr_set",
            "test_resample_base_with_timedeltaindex",
            "col",
            "test_get_loc_length_one_scalar",
            "test_iterator",
            "try_sort",
            "test_cython_agg_empty_buckets_nanops",
            "test_empty_field_eof",
            "_args_adjust",
            "_check_comparison_ops",
            "_importers",
            "_get_call_args",
            "test_groupby_as_index_cython",
            "test_decode_array_with_big_int",
            "test_usecols_index_col_conflict",
            "test_returned_dtype",
            "test_join_on",
            "test_dt_accessor_api",
            "time_from_datetime_timedelta",
            "test_dti_tz_localize_nonexistent_shift",
            "test_select_with_dups",
            "test_tdi_add_timestamp_nat_masking",
            "test_handle_empty_objects",
            "get_object",
            "test_dropna_array",
            "test_new_empty_index",
            "test_unstack_unobserved_keys",
            "create_index",
            "test_add_offset",
            "count_empty_vals",
            "test_aggfuncs",
            "test_replace_method",
            "test_secondary_y_non_ts_xlim",
            "test_left_outer_join_bug",
            "test_resample_apply_with_additional_args",
            "test_equals",
            "test_maybe_promote_any_with_bytes",
            "isnumeric",
            "_reindex_with_indexers",
            "test_setting_fill_value_updates",
            "_sanitize_column",
            "test_mod_numeric",
            "test_reduce_series_numeric",
            "wrap_results_for_axis",
            "test_fillna_float64",
            "test_ignore_display_max_colwidth",
            "test_from_arrays_index_series_categorical",
            "interpolate_1d",
            "test_deepcopy_empty",
            "test_constructor_mixed_type_rows",
            "test_astype",
            "test_get",
            "test_multiindex_slicers_edges",
            "test_interpolate_non_ts",
            "time_intersection",
            "test_where_none",
            "_format_header",
            "test_isoformat",
            "_make_skipna_wrapper",
            "test_multi_index_naming_not_all_at_beginning",
            "_check_box_return_type",
            "test_to_latex_non_string_index",
            "_interpolate_with_fill",
            "test_setitem_na",
            "_assert_not_series_equal_both",
            "is_overlapping",
            "time_frame_series_dot",
            "time_categorical_contains",
            "_is_memory_usage_qualified",
            "test_range_with_millisecond_resolution",
            "test_reader_converters",
            "test_dt_round_tz",
            "test_delta_to_nanoseconds",
            "test_td64arr_mul_int_series",
            "test_constructor_dict_input",
            "test_dataframe_dummies_prefix_sep_bad_length",
            "test_conv_weekly_legacy",
            "test_subclass_unstack_multi",
            "test_add_series_with_period_index",
            "any_real_dtype",
            "test_css_absolute_font_size",
            "time_repr_tall",
            "test_astype_cannot_cast",
            "render_git_describe",
            "_reindex_multi",
            "test_reset_index_multiindex_columns",
            "test_resolution_bumping",
            "test_float_subtype",
            "test_cat",
            "offset",
            "_get_binner_for_time",
            "_apply",
            "test_binary_ufunc_with_array",
            "test_loc_name",
            "test_dti_reset_index_round_trip",
            "_formatter_func",
            "_convert_1d",
            "test_parallel_coordinates",
            "test_naive_aware_conflicts",
            "_make_plot_keywords",
            "test_identity",
            "_get_valid_sqlite_name",
            "test_max_bin_len",
            "parametrize_fixture_doc",
            "test_series_equal_values_mismatch",
            "test_setitem_ambiguous_keyerror",
            "test_mod_timedeltalike",
            "test_reindex_with_nans",
            "test_constructor_list_of_series_aligned_index",
            "test_decode_pairs_hook",
            "test_to_excel_periodindex",
            "test_to_frame_with_falsey_names",
            "time_downcast",
            "nearest_workday",
            "test_css_to_excel_inherited",
            "time_write_store_table_wide",
            "test_numpy_sum",
            "_write_table",
            "test_drop_by_str_label_errors_ignore",
            "test_select_dtypes_include_using_scalars",
            "_set_codes",
            "test_intervals",
            "test_to_coo_text_names_integer_row_levels_nosort",
            "test_update_raise_bad_parameter",
            "test_series_equal_index_dtype",
            "_write_strls",
            "test_drop_multiindex_not_lexsorted",
            "time_frame_int_div_by_zero",
            "test_validate_n_error",
            "test_can_set_locale_valid_set",
            "fast_apply",
            "_ixs",
            "test_table_mixed_dtypes",
            "groupby",
            "test_astype_cast_nan_inf_int",
            "test_from_sequence_dtype",
            "test_parr_cmp_period_scalar",
            "test_replace_list",
            "test_agg_cython_table_transform",
            "test_raises_on_usecols_names_mismatch",
            "test_roundtrip_tz_aware_index",
            "test_constructor_ordered_dict_preserve_order",
            "test_td_sub_timedelta64",
            "_f2",
            "test_comparison_object_numeric_nas",
            "test_agg_consistency",
            "test_coordinates",
            "test_basic_frame_series_alignment",
            "test_in_numeric_groupby",
            "test_pivot_table",
            "test_offset_freqstr",
            "test_bool_properties",
            "_create_sql_schema",
            "test_NaT_scalar",
            "_raise_on_incompatible",
            "test_empty_with_multi_index",
            "test_multi",
            "test_dti_tz_localize_roundtrip",
            "remove_categories",
            "maybe_downcast_to_dtype",
            "test_overwrite_warns",
            "test_frame_no_datetime64_dtype",
            "time_frame_multi_and",
            "check_cython_extensions",
            "is_integer",
            "test_sparse_series_ops_z",
            "_apply_filter",
            "test_allow_exact_matches_and_tolerance2",
            "time_sum",
            "write_result",
            "_list_of_series_to_arrays",
            "test_period_immutable",
            "_get_bool_data",
            "test_query_builtin",
            "test_bad_url_protocol",
            "test_excel_sep_warning",
            "to_xarray",
            "test_apply_categorical",
            "test_xs_level_series",
            "test_rowspan_at_end_of_row",
            "test_copy_delim_warning",
            "test_dti_shift_localized",
            "test_nonfile_writing",
            "test_nat_methods_nan",
            "_maybe_normalize_endpoints",
            "test_corrwith_with_objects",
            "set_table_styles",
            "test_numpy_minmax_timedelta64",
            "test_numeric_range_too_wide",
            "reindex",
            "test_to_latex_no_header",
            "test_read_gbq_without_new_kwargs",
            "test_timedelta64_analytics",
            "test_agg_multiple_functions_maintain_order",
            "nanargmin",
            "_write_data",
            "_join_compat",
            "test_ufunc_reduce_raises",
            "test_items",
            "fillna_method",
            "test_constructor_ordereddict",
            "test_wide_repr_wide_columns",
            "test_join_on_singlekey_list",
            "test_intersection_difference",
            "test_readbytes",
            "test_iterable",
            "time_rank_string",
            "_get_dummies_1d",
            "test_kind_both_ways",
            "test_merge_all_na_column",
            "test_allow_exact_matches_and_tolerance3",
            "test_iteration",
            "test_getitem_preserve_name",
            "test_int_max",
            "test_nanosecond_index_access",
            "test_dates_display",
            "test_guess_datetime_format_with_parseable_formats",
            "test_bar_categorical",
            "test_pickle",
            "test_construct_DataFrame_with_sp_series",
            "time_frame_float_equal",
            "test_constructor_simple_new_empty",
            "test_broadcast",
            "test_column_dups_indexing2",
            "test_categorical_concat_preserve",
            "test_integer_arithmetic_frame",
            "test_concat_same_type_different_freq",
            "test_ceil",
            "test_constructor_multi_index",
            "test_date_query_with_non_date",
            "test_setitem_datetimelike_with_inference",
            "test_to_csv_with_mix_columns",
            "test_ensure_categorical",
            "assert_frame_equal",
            "test_dups_index",
            "test_sparse_frame_stack",
            "test_comparison_tuples",
            "generic_parser",
            "test_groupby_series_whitelist",
            "_convert_to_number_format",
            "test_count_objects",
            "test_add_prefix_suffix",
            "check_metadata",
            "test_statsmodels",
            "setup_ops",
            "test_area_lim",
            "time_iso8601",
            "test_frame_inferred",
            "test_construction_generic",
            "test_constructor_categorical_dtype",
            "test_timestamp_to_datetime_tzoffset",
            "test_datetime_assignment_with_NaT_and_diff_time_units",
            "_expand_colspan_rowspan",
            "test_copy_names",
            "test_datetime_NaT",
            "test_getitem",
            "test_class_axis",
            "test_pivot_table_categorical",
            "parameter_type",
            "test_set_na",
            "test_dtype_and_names_error",
            "_is_dtype",
            "test_ufunc",
            "test_constructor_cast_object",
            "test_select_dtypes_include_exclude_using_scalars",
            "_fill_mi_header",
            "slice_shift",
            "is_dict_like",
            "eval",
            "test_factorize_repeated",
            "test_sort_index_and_reconstruction",
            "test_multiple_functions_tuples_and_non_tuples",
            "test_parse_dates_list",
            "test_datetime64tz_fillna_round_issue",
            "test_keyword_as_column_names",
            "check_modulus",
            "test_slice_specialised",
            "test_iloc_getitem_invalid_scalar",
            "test_concat_empty_series",
            "test_applymap_subset",
            "test_apply_bug",
            "_buffered_line",
            "test_query",
            "test_to_datetime_errors_ignore_utc_true",
            "test_update_nan",
            "_format_header_mi",
            "test_tz_convert_unsorted",
            "test_rename_set_name",
            "test_transform_with_non_scalar_group",
            "_extended_gcd",
            "test_resample_as_freq_with_subperiod",
            "test_python_engine_file_no_next",
            "test_crosstab_errors",
            "test_where_ordered_differs_rasies",
            "hash_tuple",
            "test_binary_ufuncs",
            "test_to_numpy_alias",
            "_convert",
            "raw",
            "background_gradient",
            "test_pie_series",
            "test_filter_series",
            "test_dt_namespace_accessor",
            "test_interp_leading_nans",
            "test_stat_op_corner",
            "maybe_infer_freq",
            "test_set_option_invalid_single_argument_type",
            "test_maybe_mangle_lambdas_named",
            "_prep_values",
            "test_rolling_cov_pairwise",
            "test_constructor_Series_copy_bug",
            "test_div_td64arr",
            "test_float_types",
            "test_east_asian_unicode_series",
            "test_read_nokey_table",
            "test_usecols_with_mixed_encoding_strings",
            "_trim_excel_header",
            "test_is_names_tuple_fails",
            "_apply_axis_properties",
            "test_path_pathlib",
            "to_html",
            "_convert_bin_to_datelike_type",
            "test_to_csv_float32_nanrep",
            "test_at_and_iat_get",
            "test_asfreq_near_zero",
            "test_secondary_kde",
            "time_asfreq",
            "test_align_int_fill_bug",
            "test_more_na_comparisons",
            "test_unstack_fill_frame_object",
            "test_rename_inplace",
            "test_frame_iloc_callable_setitem",
            "nanpercentile",
            "test_is_one_of_factory",
            "test_to_frame_expanddim",
            "test_from_frame_valid_names",
            "time_transform_multi_key4",
            "dates",
            "test_get_complex",
            "_get_level_number",
            "test_to_timestamp_out_of_bounds",
            "test_append_numpy_bug_1681",
            "time_get_index",
            "time_convert_string_days",
            "test_concat_multiindex_dfs_with_deepcopy",
            "test_blockplacement_add_int",
            "test_read_array_header",
            "test_scalar_error",
            "makeTimedeltaIndex",
            "test_round_invalid_arg",
            "utcoffset",
            "start_blank_lines",
            "time_read_csv_dayfirst",
            "test_getitem_int_dtype",
            "test_kde_df",
            "downsample_method",
            "test_options_auto",
            "test_1000_sep",
            "test_to_string_truncate_indices",
            "combine_concat_plans",
            "test_binops_level",
            "test_unsupported",
            "_stat_axis",
            "test_encode_unicode_conversion",
            "test_loc_setitem_slice",
            "test_categorical_series_repr_ordered",
            "test_parsers_time",
            "test_from_tdi",
            "test_to_string_no_header",
            "time_len",
            "_parse_float_vec",
            "test_api_per_dtype",
            "test_merge_left_empty_right_notempty",
            "time_query_store_table",
            "test_default_handler",
            "test_combine_first_align_nan",
            "test_math_floordiv",
            "test_encode_array_of_doubles",
            "test_preserve_metadata",
            "test_rolling_axis_sum",
            "is_datetimelike",
            "time_frame_assign_timeseries_index",
            "test_to_sql_fail",
            "test_from_arrays_index_series_datetimetz",
            "_is_monotonic_increasing",
            "right",
            "pad",
            "to_timedelta",
            "test_construct_timestamp_near_dst",
            "test_asfreq_keep_index_name",
            "peakmem_float",
            "test_to_records_with_unicode_column_names",
            "test_wide_repr_unicode",
            "test_rank_pct_true",
            "test_fillna_series",
            "test_file_url",
            "time_store_str",
            "test_concat_categoricalindex",
            "read_msgpack",
            "test_notna_dtype",
            "test_categorical_concat",
            "time_series_plot",
            "test_bigint",
            "time_loc",
            "test_shift_month_dt",
            "__neg__",
            "test_set_codes",
            "test_intersection_base",
            "test_multi_thread_path_multipart_read_csv",
            "test_loc_uint64",
            "test_is_dtype",
            "test_arith_mixed",
            "_fillna_prep",
            "time_read_msgpack",
            "test_corr",
            "test_subplots_timeseries",
            "test_is_scipy_sparse",
            "_aggregate_series_pure_python",
            "_nbytes",
            "test_query_index_with_name",
            "test_to_hdf_errors",
            "test_if_exists",
            "test_rank_apply",
            "_check_mixed_int",
            "get_result",
            "test_tdi_isub_int",
            "_find_non_overlapping_monotonic_bounds",
            "test_ms_vs_capital_ms",
            "get_test_result",
            "test_align_fill_method",
            "hour_deltas",
            "test_line_plot_datetime_series",
            "test_already_underscore_variable",
            "test_union_dt_as_obj",
            "test_skiprows_int",
            "test_large_dataframe_indexing",
            "randu",
            "str_split",
            "test_to_offset",
            "test_resampler_is_iterable",
            "test_encode_to_utf8",
            "_check_ew",
            "test_unsortable",
            "test_categorical_from_codes",
            "test_read_non_existant",
            "test_freq_name_separation",
            "test_fillna_method_doesnt_change_orig",
            "test_end_time",
            "test_header_multi_index_common_format_malformed2",
            "test_construction_errors",
            "test_columns_multiindex_modified",
            "test_to_period_tz_utc_offset_consistency",
            "test_apply_series_to_frame",
            "itertuples",
            "test_categorical_equality",
            "_validate_sort_keyword",
            "test_agg_relabel_other_raises",
            "load",
            "_data_to_frame",
            "test_nat_arithmetic_index",
            "test_generic_errors",
            "test_non_monotonic",
            "_get_names",
            "test_diff_timedelta",
            "test_usecols_with_parse_dates4",
            "read_metadata",
            "_validate_key",
            "test_round_trip_exception_",
            "test_value_counts_dup",
            "test_only_one_obj_hook",
            "test_is_unique",
            "test_is_level_or_label_reference_df_simple",
            "time_get_dummies_1d_sparse",
            "test_constructor_categorical_valid",
            "head1",
            "infer_dtype_from_array",
            "test_inplace_ops_alignment",
            "test_pi_sub_pdnat",
            "testPackBytes",
            "_simple_blockify",
            "infer",
            "test_to_csv_dtnat",
            "not_hourly",
            "test_constructor_mixed_dict_and_Series",
            "_write_expansion_fields",
            "test_bool_same_index",
            "test_pindex_multiples",
            "numeric_indexing_engine_type_and_dtype",
            "_intersection_unique",
            "test_empty_with_reversed_multi_index",
            "test_pickle_path_pathlib",
            "test_hist_legacy",
            "test_time",
            "test_construct_cast_invalid",
            "test_filter_condition_raises",
            "apply_empty_result",
            "test_drop_duplicates_empty",
            "read_multi_index",
            "test_compact_numerical_values",
            "test_contains_nan",
            "_where_numexpr",
            "test_setitem_index_object",
            "test_concat_axis1_different_fill",
            "testPack",
            "test_pprint",
            "_evaluate_standard",
            "test_Second",
            "read_csv",
            "test_na_flags_int_categories",
            "_get_codes_for_sorting",
            "test_non_scalar_raises",
            "test_perf_min",
            "nonzero",
            "_get_data_to_aggregate",
            "test_to_datetime_iso_week_year_format",
            "test_categorical_series_repr",
            "test_fillna_series_complex128",
            "test_constructor_dtypes_timedelta",
            "test_constructor_dict_multiindex",
            "_tick_comp",
            "tsd",
            "test_boolean_cmp",
            "time_concat_small_frames",
            "time_all_nan",
            "test_periodindex",
            "test_cython_right_outer_join",
            "test_from_tuples_with_tuple_label",
            "_trim_zeros_float",
            "add_flex_arithmetic_methods",
            "test_quote_char_various",
            "test_concat_named_keys",
            "test_reindex_frame_add_nat",
            "test_set_axis_inplace",
            "test_encode_unicode_surrogate_pair",
            "test_xs_corner",
            "test_infs_n_nans",
            "_list_of_dict_to_arrays",
            "test_maybe_promote_timedelta64_with_any",
            "test_loc_getitem_bool",
            "onOffset",
            "test_cut_duplicates_bin",
            "init_dict",
            "autoscale",
            "test_numpy_array_complex",
            "test_pivot_periods",
            "test_sum_prod_nanops",
            "test_pi_sub_period_nat",
            "test_replace_mixed_types_with_string",
            "test_copy_blocks",
            "test_axis_aliases",
            "test_groupby_with_timegrouper_methods",
            "test_to_string_format_inf",
            "_check_decimal",
            "safe_remove",
            "str_find",
            "test_groupby_groups_periods",
            "test_excel_table_sheet_by_index",
            "test_astype_datetime64",
            "test_categorical_sorting",
            "test_series_pos",
            "_assert_series_equal",
            "test_asfreq_ts",
            "test_get_backfill_indexer",
            "test_left_join_index_preserve_order",
            "test_int32_overflow",
            "test_inner_join_indexer",
            "test_getitem_generator",
            "time_fastpath",
            "update_kwargs",
            "time_title",
            "test_nonzero_base",
            "test_concat_NaT_series",
            "test_describe_categorical",
            "test_decode_big_escape",
            "test_negative_log",
            "test_tdi_cmp_str_invalid",
            "visit_Div",
            "test_join_inner_multiindex",
            "test_assignment_in_query",
            "_close_conn",
            "merge_ordered",
            "test_categorical_repr_period_ordered",
            "assert_array_dicts_equal",
            "test_daily",
            "test_dti_add_tdi",
            "test_append_with_timezones_dateutil",
            "test_append_many",
            "_slice",
            "test_fillna_int",
            "_blknos",
            "test_group_fill_methods",
            "test_pandas_datareader",
            "_gen_eval_kwargs",
            "test_overlaps_na",
            "test_to_coo_bad_partition_nonnull_intersection",
            "test_concat_columns",
            "test_concat_dataframe",
            "test_frame_fillna_limit",
            "test_filter_maintains_ordering",
            "maybe_cythonize",
            "test_to_datetime_other_datetime64_units",
            "time_bool_indexer",
            "_get_roll",
            "test_end_time_timevalues",
            "check_values",
            "read_pickle",
            "test_to_sql_index_label_multiindex",
            "test_split_nan_expand",
            "test_repr_with_unicode_data",
            "assert_level_values",
            "test_merge_empty_frame",
            "test_slice_to_array_conversion",
            "test_eq_with_str",
            "_format_regular_rows",
            "test_deprecated_numpy_func_call",
            "_needs_reindex_multi",
            "_start_base",
            "test_both_offset_observance_raises",
            "test_ix_frame_align",
            "test_at_fill_value",
            "test_decode_too_extreme_numbers",
            "test_max_ext_len",
            "test_write_bytes_multi_buffer",
            "time_reindex",
            "maybe_upcast_putmask",
            "_search_replace_num_columns",
            "test_css_to_excel_bad_colors",
            "test_delimit_whitespace",
            "test_105",
            "_default_locale_getter",
            "test_difference",
            "test_read_empty_with_usecols",
            "test_recreate_from_data",
            "test_not_all_none",
            "test_series_given_mismatched_index_raises",
            "test_to_frame",
            "time_argsort",
            "_dispatch",
            "test_disallow_setting_tz",
            "test_set_frame_overwrite_object",
            "test_get_loc_decreasing",
            "test_standardize_mapping",
            "_datetime_to_stata_elapsed_vec",
            "test_sort_nan",
            "test_stack_timezone_aware_values",
            "test_greater",
            "test_roundtrip_thru_setitem",
            "test_deprecated",
            "test_merge_misspecified",
            "test_color_single_series_list",
            "test_pickle_path_localpath",
            "time_series_groups",
            "test_unicode_print",
            "check_alignment",
            "test_df_subplots_patterns_minorticks",
            "test_append_different_columns_types_raises",
            "test_loc",
            "test_index_tab_completion",
            "test_scalar_from_string",
            "test_subclassed_apply",
            "test_set_locale",
            "list_of_str",
            "_unconvert_index",
            "test_td64arr_pow_invalid",
            "_get_rename_function",
            "test_quantile_datetime",
            "test_to_html_border",
            "test_parse_all_fields",
            "test_value_counts_categorical_ordered",
            "test_level_with_tuples",
            "_insert_strls",
            "test_unstack_nan_index",
            "test_ewma",
            "_union_incompatible_dtypes",
            "_ndim",
            "test_cov",
            "test_text_color_threshold_raises",
            "test_mask_inplace",
            "_getitem_iterable",
            "test_ngroup_cumcount_pair",
            "construction_error",
            "test_take",
            "test_loc_setitem_consistency_slice_column_len",
            "test_groupby_mean_no_overflow",
            "operand_types",
            "test_shift_month_ts",
            "test_nan_invalid",
            "infer_setup",
            "test_index_mixed_closed",
            "_get_all_lines",
            "test_to_string_float_na_spacing",
            "test_vars_work_with_multiindex",
            "test_to_datetime_format_weeks",
            "test_plot_scatter_with_categorical_data",
            "test_dayfirst",
            "time_replace_across_dst",
            "test_corrwith_dup_cols",
            "test_fill_corner",
            "test_timestamp_sub_datetime",
            "update_pr",
            "test_interp_inplace_row",
            "remove_unused_categories",
            "test_different_number_of_cols",
            "test_eng_float_formatter",
            "_sub_datetime_arraylike",
            "test_period_mean",
            "test_align_same_index",
            "test_tz_localize_errors_coerce",
            "_getitem_nested_tuple",
            "_get_consensus_names",
            "test_pi_ops_array_int",
            "time_html_repr_trunc_si",
            "test_td64arr_add_offset_array",
            "test_stack_preserve_categorical_dtype_values",
            "test_agg_callables",
            "df1",
            "test_readjson_chunks_multiple_empty_lines",
            "test_constructor_categorical_string",
            "_format_header_regular",
            "run_cmd",
            "test_corrwith_series",
            "local_name",
            "test_aggregate_api_consistency",
            "nargsort",
            "test_unstack_group_index_overflow",
            "validate_argmax_with_skipna",
            "_get_repr",
            "_get_root",
            "test_info_memory_usage_deep_pypy",
            "test_loc_setitem_consistency",
            "test_swapcase",
            "test_constructor_list_str",
            "test_add_different_nans",
            "time_fromordinal",
            "test_can_hold_identifiers",
            "test_ops_properties",
            "test_left_join_index_multi_match_multiindex",
            "time_iteritems",
            "test_diff_datetime_axis0",
            "test_assert_not_almost_equal_strings",
            "test_arith_flex_frame_mixed",
            "test_raises_attribute_error",
            "assert_timedelta_array_equal",
            "assert_raises_regex",
            "test_lookup_float",
            "df_compat",
            "test_setitem_chained_no_consolidate",
            "get_slice",
            "time_list_of_dict",
            "test_merge_nocopy",
            "__invert__",
            "_write_variable_types",
            "right_multi",
            "test_nearest_by",
            "test_cache_readonly_preserve_docstrings",
            "pprint_hits",
            "test_radviz",
            "test_frame_info_encoding",
            "test_parse_time_quarter_with_dash",
            "_get_fill",
            "test_ewm_domain_checks",
            "test_unpack_ext_type",
            "test_outer_join_indexer",
            "test_astype_column_metadata",
            "test_map_header",
            "test_encode_builtin_values_conversion",
            "test_read_missing_key_close_store",
            "test_tick_offset",
            "test_date_range_timestamp_equiv",
            "_from_categorical_dtype",
            "test_if_hexbin_xaxis_label_is_visible",
            "test_concat_period_other_series",
            "test_retain_index_attributes",
            "test_pass_args_kwargs",
            "test_usecols_name_length_conflict",
            "build_font",
            "_execute_insert",
            "_non_reducing_slice",
            "test_no_keep_default_na_dict_na_values",
            "test_single_vars_work_with_multiindex",
            "test_value_vars_types",
            "test_take_filling_fill_value",
            "test_categorical_category_dtype",
            "_convert_grouper",
            "test_logical_ops_label_based",
            "time_float_int_str",
            "test_banklist",
            "test_pos_object",
            "test_is_bool",
            "df_idx",
            "_safe_reshape",
            "is_bool_dtype",
            "_convert_wrapper",
            "test_int",
            "test_consistency",
            "_coerce_method",
            "_clean_dict",
            "test_monotonic_on",
            "test_nlevels",
            "test_join_on_fails_with_different_column_counts",
            "test_empty_fancy",
            "test_numeric_like_ops",
            "test_get_timestamp_range_edges",
            "test_nancorr_pearson",
            "test_array_not_registered",
            "time_multi_int_nunique",
            "test_tick_equality",
            "test_fillna_mixed_float",
            "_format_hierarchical_rows",
            "test_to_html_multiindex_index_false",
            "test_typ",
            "make_empty",
            "test_on_float",
            "_upsample_others",
            "test_repr_truncation_column_size",
            "has_info_repr",
            "test_get_locales_prefix",
            "test_setitem_sequence",
            "test_decode_hook",
            "set",
            "test_multi_func",
            "test_to_string_index_formatter",
            "set_atom",
            "tz_aware_fixture",
            "backtick_quote_name_with_no_spaces",
            "test_read_writer_table",
            "test_readjson_invalid_chunksize",
            "take_data",
            "render_git_describe_long",
            "test_reindex_boolean",
            "argmax",
            "test_notna_notnull",
            "test_apply_datetimetz",
            "test_rank_methods_series",
            "test_complex_across_dimensions_fixed",
            "test_loc_getitem",
            "test_mutate_groups",
            "is_unique",
            "test_append_concat_tz_explicit_pytz",
            "test_line_comment",
            "test_frame_timeseries_column",
            "test_constructor_generic_timestamp_no_frequency",
            "test_getitem_boolean",
            "test_read_chunksize_bad",
            "test_convert_pandas_type_to_json_field_datetime",
            "test_sortlevel_not_sort_remaining",
            "test_other_dtypes_for_array",
            "test_basic_no_by",
            "_is_empty_array",
            "test_frame_setitem_copy_no_write",
            "test_create_and_drop_table",
            "test_constructor_dtypes_to_categorical",
            "_write_value_labels",
            "test_set_levels",
            "test_iloc_setitem_with_scalar_index",
            "test_append_same_columns_type",
            "_convert_to_line_delimits",
            "get_default_ax",
            "generate_index_types",
            "_validate_codes",
            "test_append_to_multiple",
            "test_pi_add_sub_timedeltalike_freq_mismatch_daily",
            "test_dt64_mean",
            "test_getitem_slice_fill_value",
            "test_index",
            "test_catch_oob",
            "test_min_max_categorical",
            "test_index_not_contains",
            "_get_column_repeat",
            "test_value_counts_inferred",
            "test_categorical_nan_equality",
            "test_dropna_multiple_axes",
            "test_categorical_repr_timedelta_ordered",
            "test_agg_namedtuple",
            "test_fillna_datelike",
            "test_to_excel_multiindex",
            "test_to_html_with_classes",
            "test_dtypes",
            "test_asfreq",
            "test_fixed_offset_tz",
            "test_sparsea_max_row_truncated",
            "test_constructor_nan",
            "test_searchsorted",
            "time_dtype_as_field",
            "test_read_csv_dataframe",
            "cd_and_set_engine",
            "test_na_value_for_dtype",
            "test_setitem_index_period",
            "is_dtype_equal",
            "test_shift_nat",
            "test_where_other_categorical",
            "_reindex_non_unique",
            "_assert_ytickslabels_visibility",
            "test_corr_kendall",
            "test_decode_numeric_int_exp",
            "new_func",
            "test_categorical_dtype_chunksize_infer_categories",
            "_create_sp_series",
            "_arr_to_str",
            "time_frame_get_numeric_data",
            "_maybe_coerce_values",
            "test_tuple_width",
            "test_fillna_index_int64",
            "test_already_encoded",
            "_maybe_cast_indexed",
            "makeStringIndex",
            "test_encode_decode",
            "test_tz_pytz",
            "test_where_int64",
            "test_rolling_min",
            "test_read_dta2",
            "time_crosstab",
            "nearest",
            "test_integer_thousands",
            "test_pie_df_nan",
            "ftype",
            "isin",
            "test_read",
            "_prepare_data",
            "tz_replacer",
            "test_td64arr_mul_too_short_raises",
            "_make_parser_function",
            "ensure_clean_path",
            "test_loc_setitem_frame_multiples",
            "test_resample_weekly_all_na",
            "hist_series",
            "test_reindex_nan",
            "test_bar_align_zero_pos_and_neg",
            "test_upsample_with_limit",
            "_codes_to_ints",
            "test_gold_canyon",
            "test_ragged_mean",
            "_from_derivatives",
            "test_pass_TimedeltaIndex_to_index",
            "test_concat_different_columns",
            "_make_field_arrays",
            "test_apply_none",
            "test_setitem_datetime_coercion",
            "test_repr_min_rows",
            "biggie_df_fixture",
            "_validate_usecols_arg",
            "test_mangled",
            "test_str_attribute_raises",
            "test_read_from_file_url",
            "test_fwf_thousands",
            "test_to_string_int_formatting",
            "tsframe",
            "test_expand_user_normal_path",
            "test_loc_setitem_consistency_empty",
            "test_only_1dim_accepted",
            "test_config_default_off",
            "test_array_ufunc",
            "test_column_in",
            "_validate_read_indexer",
            "test_wrap",
            "datetime64_dtype",
            "get_weeks",
            "c_parser_only",
            "ts2",
            "test_to_datetime_infer_datetime_format_series_with_nans",
            "test_skiprows_slice_short",
            "makeBoolIndex",
            "test_construction_with_alt_tz_localize",
            "test_numpy_array_equal_object",
            "test_dti_convert_tz_aware_datetime_datetime",
            "_maybe_mask_result",
            "_add_nat",
            "test_where_unsafe_upcast",
            "convert_to_index_sliceable",
            "time_large_get_loc_warm",
            "disallow",
            "test_donot_drop_nonevalues",
            "test_groupby_multilevel",
            "test_rands",
            "test_date_range_timestamp_equiv_dateutil",
            "test_dti_constructor_static_tzinfo",
            "test_diff_datetime_axis1",
            "test_normalize_nat",
            "test_to_string_float_format",
            "deprecation_in_wrong_order",
            "test_agg_structs_dataframe",
            "test_getitem_setitem_fancy_exceptions",
            "compare_frame_dt_mixed_tzs",
            "test_pickle_preserve_name",
            "cov",
            "time_center",
            "create_index_with_nan",
            "test_parse_dates_custom_euro_format",
            "test_maybe_promote_any_with_datetime64",
            "test_getitem_ix_mixed_integer",
            "test_parse_date_time_multi_level_column_name",
            "test_mul_float_series",
            "test_isin_df_dupe_values",
            "_have_mixed_levels",
            "_maybe_coerce_merge_keys",
            "test_usecols_list",
            "test_index_resolvers_come_after_columns_with_the_same_name",
            "test_union_categoricals_empty",
            "test_float_scalar",
            "test_not_monotonic",
            "test_valid_object_plot",
            "_check_engine",
            "time_floats_with_int_idex_lines",
            "_check_timedeltalike_freq_compat",
            "test_dataframe_dtypes",
            "test_excelwriter_fspath",
            "time_merge_cat",
            "test_unsortedindex_doc_examples",
            "test_to_html_with_col_space_units",
            "test_start_stop_multiple",
            "ljust",
            "test_replace_with_empty_dictlike",
            "_write_hierarchical_rows",
            "test_no_header",
            "_formatter",
            "test_set_group_name",
            "test_corner_union",
            "missing_whitespace_around_arithmetic_operator",
            "test_select_dtypes_bad_arg_raises",
            "test_is_numeric_dtype",
            "test_apply_with_mixed_types",
            "str_index",
            "test_dropna_categorical_interval_index",
            "time_loc_list_like",
            "test_sum_nanops_timedelta",
            "test_flex_comparison_nat",
            "test_to_datetime_box_deprecated",
            "test_datetime_units",
            "test_constructor_infer_period",
            "time_copy_function_multi_col",
            "makePeriodFrame",
            "test_dtype_conversion",
            "invert",
            "test_sort_index_preserve_levels",
            "test_union_categorical_same_categories_different_order",
            "test_frame_column_inplace_sort_exception",
            "_get_cython_table_params",
            "is_string_dtype",
            "test_constructor_DataFrame",
            "test_constructor_with_naive_string_and_datetimetz_dtype",
            "_concatenate_2d",
            "_simple_ts",
            "test_overwrite_node",
            "test_consolidate_ordering_issues",
            "test_reindex_single_named_indexer",
            "series_generator",
            "test_date_format_frame",
            "test_where_error",
            "validate_inferred_freq",
            "is_int64_dtype",
            "dict_compat",
            "two_hours",
            "test_values_lcd",
            "test_list_numeric",
            "assert_dict_equal",
            "iget",
            "test_pi_offset_errors",
            "test_merge_incompat_dtypes_error",
            "test_rmod_timedelta64",
            "test_constructor_dict_order_insertion",
            "time_isin_categorical",
            "test_too_many_ndims",
            "test_implicit_label",
            "str_contains",
            "test_iterator_skipfooter_errors",
            "test_print_none_width",
            "test_frame_setitem_multi_column",
            "test_assignment",
            "string_parameter",
            "test_hypothesis_delimited_date",
            "test_overlap_public_nat_methods",
            "_get_dtypes",
            "test_to_latex_specified_header",
            "test_read_chunksize_compat",
            "test_mod_invalid",
            "_maybe_to_dense",
            "test_objarr_add_str",
            "test_header_multi_index",
            "test_linspace_dst_transition",
            "_get_codes",
            "test_select_bad_cols",
            "test_cummin_datetime64",
            "test_exit_status_errors_for_validate_all",
            "test_indicator",
            "_highlight_extrema",
            "test_escaped_table_name",
            "test_concat_sparse_dense_cols",
            "join",
            "test_round_frequencies",
            "checknull_old",
            "test_crossed_dtypes_weird_corner",
            "write_metadata",
            "test_missing_raises",
            "test_to_offset_whitespace",
            "is_exists",
            "test_add_integer",
            "time_rename_single",
            "_get_default_annual_spacing",
            "test_extractall_same_as_extract",
            "test_nancov",
            "mem_itertuples_raw_to_list",
            "_combine_series_frame",
            "left_right_dtypes",
            "linebreak_at_end_of_docstring",
            "test_apply_chunk_view",
            "test_mixed_arithmetic_series",
            "maybe_expression",
            "test_shallow_copy_i8",
            "test_roll_qtr_day_mod_equal",
            "test_iloc_getitem_int",
            "date_format",
            "test_add_offset_nat",
            "s_main_dtypes_split",
            "test_grouping_ndarray",
            "test_series_with_dtype",
            "test_maybe_promote_any_with_bool",
            "test_is_full",
            "test_str_vs_repr",
            "test_importcheck_thread_safety",
            "test_categorical_margins",
            "test_categorical_preserves_tz",
            "test_empty_method",
            "test_tz_dtype_mismatch_raises",
            "_to_M8",
            "test_write_explicit_bad",
            "test_arith_flex_frame",
            "test_shift_dtype",
            "test_constructor_no_pandas_array",
            "ngroup",
            "test_invalid_index_types_unicode",
            "test_assert_numpy_array_equal_value_mismatch6",
            "test_interval_array_equal_periods_mismatch",
            "test_multiindex_column_lookup",
            "_delegate_property_set",
            "test_freq_code",
            "set_caption",
            "_assert_setitem_index_conversion",
            "test_categorical_with_nan_consistency",
            "_apply_meta",
            "test_round_int64",
            "test_float_array_comparison",
            "test_to_html_empty_dataframe",
            "test_properties_hourly",
            "test_groupby_level_no_obs",
            "test_replace_series_no_regex",
            "test_concat_tz_frame",
            "hide_columns",
            "test_duplicated_drop_duplicates",
            "write_block_index",
            "test_is_leap_year",
            "_expand_elements",
            "test_td_floordiv_timedeltalike_array",
            "test_error_on_using_partition_cols_and_partition_on",
            "construct_array_type",
            "test_divmod_numeric",
            "test_get_indexer_strings",
            "test_constructor_ndarray",
            "test_ix_multiindex_missing_label_raises",
            "time_write_msgpack",
            "time_chained_cmp",
            "time_ix_scalar",
            "raise_with_traceback",
            "test_hist_kde",
            "test_path_path_lib",
            "test_validate_bool_args",
            "test_non_matching",
            "test_getitem_get",
            "_get_vars",
            "test_arith_getitem_commute",
            "test_basic_drop_first_one_level",
            "remove_na_arraylike",
            "test_from_pandas_array",
            "test_get_offset_day_error",
            "test_intersect_identical",
            "test_multi_assign",
            "test_merge_on_ints_floats_warning",
            "test_iloc_returns_scalar",
            "validate_attr",
            "test_take_fill_value_datetime",
            "test_equals_different_blocks",
            "test_observed_groups",
            "nanmean",
            "is_instance_factory",
            "test_fy5253_last_onoffset",
            "return_type",
            "time_set_categories",
            "test_get_loc_interval",
            "test_astype_unicode",
            "_check_stat_op",
            "test_interp_multiIndex",
            "new_func_no_docstring",
            "_validate_integer",
            "test_finder_daily",
            "time_is_month_start",
            "list_of_tuples",
            "test_from_product_empty_two_levels",
            "test_boxplot_return_type_none",
            "test_zip",
            "test_sub_object",
            "_get_objs_combined_axis",
            "test_dti_sub_offset_index",
            "test_from_product_datetimeindex",
            "test_partition_cols_supported",
            "detect_console_encoding",
            "rmod",
            "test_loc_getitem_int",
            "test_from_records_tuples_generator",
            "_check_ndim",
            "__nonzero__",
            "result_columns",
            "test_is_datetimelike_v_numeric",
            "test_table",
            "test_apply_series_on_date_time_index_aware_series",
            "test_spam_no_match",
            "test_interpolate",
            "test_hash_keys",
            "_concat_index_asobject",
            "_doc_parms",
            "test_constructor_with_timedelta_window",
            "test_to_html_truncate",
            "test_isin_level_kwarg_bad_level_raises",
            "test_apply_with_args_kwds",
            "test_series_getitem_corner_generator",
            "test_to_basic",
            "test_other_datetime_unit",
            "test_woy_boundary",
            "_get_column_name_list",
            "load_newobj",
            "test_numpy_ops",
            "test_take_empty",
            "_use_window",
            "prng",
            "test_partition_series",
            "test_xarray",
            "test_hash_error",
            "atomize",
            "test_timedelta64_conversions",
            "test_decode_invalid_dict",
            "test_encode_unicode_4bytes_utf8highest",
            "test_multiindex_roundtrip",
            "needs_i8_conversion",
            "test_categorical_coerces_timestamp",
            "test_default_color_cycle",
            "_unstack",
            "test_addition_subtraction_types",
            "test_cummin_timedelta64",
            "test_to_latex_escape",
            "test_compression_roundtrip",
            "test_resample_size",
            "__array__",
            "make_block",
            "test_read_dta3",
            "test_difference_identity",
            "timedelta_index",
            "time_get_loc_sorted",
            "test_order_of_appearance",
            "test_groupby_frame_whitelist",
            "levshape",
            "test_to_html",
            "test_timedelta64_equal_timedelta_supported_ops",
            "build_alignment",
            "test_apply_series_yield_constant",
            "test_to_latex_multiindex_nans",
            "test_parallel",
            "test_constructor_list_of_iterators",
            "test_to_datetime_unprocessable_input",
            "test_arg_passthru",
            "test_td64arr_sub_NaT",
            "test_iterable_items",
            "dispatch_to_extension_op",
            "test_skiprows_infield_quote",
            "test_methods",
            "test_conv_business",
            "test_reindex_nearest",
            "wide_multi_index",
            "test_tdi_addsub_integer_array_no_freq",
            "test_single_bin",
            "test_utc_z_designator",
            "mem_itertuples_raw_start",
            "time_read_uint64_na_values",
            "test_numpy_reduction",
            "test_constructor_generic_timestamp_bad_frequency",
            "test_options_py",
            "test_secondary_bar",
            "test_constructor_from_unknown_type",
            "test_unexpected_kwargs_raises",
            "test_raises_for_invalid_attribute_name",
            "test_labels",
            "intframe",
            "assert_resolves",
            "test_invalid_dtype_per_column",
            "test_table_values_dtypes_roundtrip",
            "render",
            "test_safe_import_dummy",
            "test_encode_time_conversion_basic",
            "test_objects",
            "test_reindex_axes",
            "test_accessor_works",
            "test_xcompat",
            "has_horizontally_truncated_repr",
            "_add_datetimelike_scalar",
            "test_to_pytimedelta",
            "test_skiprows_set",
            "test_nunique_with_empty_series",
            "test_bounds_check_small",
            "test_comparison_different_length",
            "_select_options",
            "test_dataframe_dummies_prefix_bad_length",
            "test_series_plot_color_kwargs",
            "apply_if_callable",
            "test_is_string_like_dtype",
            "test_where",
            "test_from_records_misc_brokenness",
            "test_select_columns_in_where",
            "test_read_excel_nrows_greater_than_nrows_in_file",
            "test_round_dst_border_nonexistent",
            "test_getname_categorical_accessor",
            "test_unstack_categorical",
            "test_fillna_mixed_type",
            "set_atom_complex",
            "test_is_integer",
            "test_int_df",
            "time_frame_float_unequal",
            "test_constructor_freq_combined",
            "_harmonize_columns",
            "read_feather",
            "test_mangle_series_groupby",
            "test_interp_limit_to_ends",
            "test_map_with_tuples_mi",
            "test_productsales",
            "test_transform_dtype",
            "test_timedelta_ops",
            "test_method_on_bytes",
            "_add_delta_tdi",
            "_parse",
            "test_plot_int_columns",
            "_define_paths",
            "test_join_unconsolidated",
            "test_float_precision_round_trip_with_text",
            "test_time_formatter",
            "_get_numeric_data",
            "test_mul_datelike_raises",
            "assert_numpy_array_equal",
            "rpow",
            "_managle_lambda_list",
            "test_single_line",
            "nanargmax",
            "test_merge_common",
            "array",
            "test_bar_align_mid_pos_and_neg",
            "test_string_index_repr",
            "_create_dtype_data",
            "test_setitem_expand_columns",
            "_check_colors",
            "test_conv_secondly",
            "test_put_mixed_type",
            "test_getitem_list_duplicates",
            "test_scalarop_preserve_name",
            "test_rw_use_threads",
            "test_bar_align_zero_nans",
            "_add_arithmetic_ops",
            "test_not_equals_object",
            "mixed_float",
            "_compute_plot_data",
            "_get_metadata_path",
            "test_read_sql_parameter",
            "test_option_no_warning",
            "time_remove_categories",
            "test_reorder_categories",
            "test_filter_enforces_scalarness",
            "add_categories",
            "test_concat_multiple_frames_dtypes",
            "test_extension_type",
            "test_to_html_multiindex_sparsify",
            "test_div_equiv_binop",
            "_check_columns",
            "test_construction_index_with_mixed_timezones_with_NaT",
            "test_direct_arith_with_series_returns_not_implemented",
            "test_constructor_string",
            "test_invalid_value",
            "test_unordered_compare_equal",
            "test_string_categorical_index_repr",
            "time_read_special_date",
            "test_convert",
            "test_deprecate_order",
            "get_indexer_non_unique",
            "test_boxplot_vertical",
            "idx_dup",
            "check_mutable_error",
            "test_binary_ufunc_scalar",
            "check_ops_properties",
            "_assert_almost_equal_both",
            "test_to_csv_moar",
            "examples",
            "test_where_complex",
            "_is_sup",
            "_parse_thead_tbody_tfoot",
            "test_cast_on_putmask",
            "test_sort_values_frame",
            "_unstack_multiple",
            "test_numeric_values",
            "test_replace_series",
            "test_td64arr_add_sub_numeric_scalar_invalid",
            "makeMissingCustomDataframe",
            "_try_aggregate_string_function",
            "test_rename_axis_inplace",
            "test_subplots_sharex_axes_existing_axes",
            "test_caching",
            "test_setitem_clears_freq",
            "time_corr",
            "test_lookup_bool",
            "fp",
            "non_coercible_categorical",
            "test_categorical_coerces_datetime",
            "test_astype_categorical_to_categorical",
            "test_shallow_copy_changing_freq_raises",
            "test_where_series_timedelta64",
            "test_mode_intoverflow",
            "test_index_repr_in_frame_with_nan",
            "test_iloc_slice_fill_value",
            "test_options_get_engine",
            "test_is_extension_type",
            "test_getitem_setitem_float_labels",
            "_create_comparison_method",
            "mixed_float_frame",
            "test_nbytes",
            "time_read_store",
            "prod",
            "test_get_loc_single_level",
            "test_parse_public_s3_bucket_python",
            "_highlight_null",
            "test_infer_objects",
            "test_at_time_between_time_datetimeindex",
            "_wrap_setop_result",
            "_groups_or_na_fun",
            "test_valid_join_keys",
            "test_properties_secondly",
            "time_asof",
            "test_index_equal_values_too_far",
            "test_value_counts_datetime64",
            "maybe_set_size",
            "test_as_json_table_type_date_data",
            "test_compound_invert_op",
            "test_nanmin",
            "time_isin_long_series_short_values",
            "test_dti_tz_localize_ambiguous_times",
            "test_comp_ops_df_compat",
            "test_safe_import_non_existent",
            "crosstab",
            "read_hdf",
            "mock_clipboard",
            "test_margins_no_values_two_row_two_cols",
            "test_arith_coerce_scalar",
            "test_series_broadcasting",
            "test_to_csv_unicode_index",
            "test_encode_long_conversion",
            "test_dates",
            "_create_arithmetic_method",
            "test_loc_multiindex_indexer_none",
            "test_excel_sheet_size",
            "test_apply_corner",
            "test_dropna_intervals",
            "test_put_deprecated",
            "time_repeat",
            "test_timezone_comparaison_assert",
            "test_nancorr_kendall",
            "test_constructor_name",
            "time_frame_object_unequal",
            "test_nbytes_block",
            "test_map_with_tuples",
            "item",
            "test_deprecate_wrong_docstring",
            "test_nyse_wsj_commas_table",
            "test_join_dups",
            "test_constructor_empty_with_string_dtype",
            "test_interp_all_good",
            "test_parse_failure_unseekable",
            "test_from_codes_neither",
            "test_apply_simple_series",
            "test_pi_sub_isub_timedeltalike_hourly",
            "clip",
            "month_position_check",
            "test_copy_from_callable_insertion_method",
            "test_timestamp_timetz_equivalent_with_datetime_tz",
            "test_get_label_or_level_values_df_duplabels",
            "test_is_mixed_dtype",
            "test_invalid_double_precision",
            "test_slice_locs_indexerror",
            "test_transform_datetime_to_timedelta",
            "test_unpack_buffer",
            "test_divmod_series",
            "config_prefix",
            "test_bfill",
            "test_agg_timezone_round_trip",
            "test_is_not_extension_array_dtype",
            "time_get_value",
            "test_isna_lists",
            "test_fspath",
            "test_logical_ops_df_compat",
            "test_rename_by_series",
            "_unpickle_series_compat",
            "_from_ordinal",
            "test_repr_large",
            "_formatting_values",
            "_asof_function",
            "test_series_index_name",
            "dtype_fill_out_dtype",
            "_is_view",
            "test_pandas_dtype_valid",
            "test_rolling",
            "test_merge_categorical",
            "test_normalize_date_sub_types",
            "test_group_apply_once_per_group",
            "select_column",
            "get",
            "set_atom_timedelta64",
            "test_contains_interval",
            "test_more_flexible_frame_multi_function",
            "test_join_with_period_index",
            "test_with_tz",
            "arithmetic_win_operators",
            "test_parsing_timezone_offsets",
            "render_pep440_old",
            "test_construction_with_categorical_index",
            "_badobj_wrap",
            "test_dti_business_summary",
            "parse",
            "test_maybe_promote_datetime64_with_any",
            "_should_parse_dates",
            "_use_inf_as_na",
            "has_vertically_truncated_repr",
            "test_rolling_axis_count",
            "test_union_different_type_base",
            "_has_infs",
            "test_take_fill_value_with_timezone",
            "_in_travis_environment",
            "time_microsecond",
            "_from_sequence_of_strings",
            "test_n_duplicate_index",
            "test_empty_lines",
            "_local_timestamps",
            "test_date_time",
            "test_diff",
            "_selection_name",
            "test_numpy_unique",
            "test_nanosecond_timestamp",
            "_to_sql",
            "test_date_range_timestamp_equiv_explicit_pytz",
            "test_hash_array_errors",
            "test_read_dta18",
            "test_line_area_nan_df",
            "test_database_uri_string",
            "test_read_gbq_with_new_kwargs",
            "radviz",
            "test_astype_with_tz",
            "validate_periods",
            "test_combineSeries",
            "test_rolling_skew_eq_value_fperr",
            "delta",
            "test_excel_multiindex_index",
            "test_ewm_alpha",
            "test_error",
            "test_non_unique",
            "_convert_tuple",
            "test_missing_deprecate_kwarg",
            "categorical_index",
            "_has_valid_positional_setitem_indexer",
            "test_deprecated_get_dtype_counts",
            "time_lookup_iloc",
            "test_divmod",
            "time_count_level_mixed_dtypes_multi",
            "test_append_missing_column_proper_upcast",
            "test_api_per_method",
            "test_getitem_fancy_scalar",
            "test_get_indexer_non_unique",
            "use_numpy",
            "test_infer_row_shape",
            "time_add_overflow_b_mask_nan",
            "test_dti_add_series",
            "test_index_equal_values_close",
            "test_fillna_downcast",
            "test__isfinite",
            "_check_plot_works",
            "test_constructor_tuple",
            "_delegate_property_get",
            "as_ordered",
            "get_names_from_index",
            "test_ix_weird_slicing",
            "test_resample_anchored_monthstart",
            "test_tuples_have_na",
            "test_arg_for_errors_in_astype",
            "test_put_compression_blosc",
            "test_isin_multiIndex",
            "test_rsub",
            "reindex_like",
            "test_resample_nunique_preserves_column_level_names",
            "test_not_string",
            "time_frame_get_dtype_counts",
            "test_skip_row_with_quote",
            "time_boolean_rows_object",
            "test_handle_dict_return_value",
            "time_timedelta_plus_datetime",
            "test_slice_locs_with_ints_and_floats_succeeds",
            "_make_fixed_width",
            "_test_moments_consistency",
            "test_setitem_clear_caches",
            "test_floating_misc",
            "_get_nobs",
            "test_array_inference",
            "test_datetime_time",
            "test_categorical_category_dtype_unsorted",
            "set_default_names",
            "multiple_elts",
            "_write_file_close_tag",
            "test_resample_upsample",
            "get_cmdclass",
            "test_nunique",
            "test_negative_non_tick_frequency_descending_dates",
            "test_converter_index_col_bug",
            "time_different_numpy_functions",
            "test_guess_datetime_format_with_locale_specific_formats",
            "_all_not_none",
            "test_annual_upsample_cases",
            "test_meta_name_conflict",
            "test_setitem_None",
            "test_multiple_types",
            "test_repeated_column_labels",
            "time_cov_series",
            "test_categorial_datetimelike",
            "test_get_datevalue",
            "test_1d_fill_nonna",
            "test_skiprows_inference_empty",
            "test_asfreq_non_unique",
            "fix_version_from_branch",
            "test_mi_falsey_name",
            "test_greater_Raises_Value",
            "test_quantile_box",
            "astype",
            "test_write_infer",
            "is_full_slice",
            "test_join_non_int_index",
            "test_frame_getitem_setitem_boolean",
            "load_reduce",
            "to_hdf",
            "is_truncated",
            "test_is_bool_dtype_sparse",
            "test_replicate_describe",
            "test_shift",
            "test_get_standard_colors_no_appending",
            "test_divide_decimal",
            "test_numpy_compress",
            "test_constructor_coerce_float_valid",
            "time_convert_direct",
            "test_series_constructor_coerce_data_to_extension_dtype_raises",
            "test_shift_empty",
            "test_to_csv_unicode",
            "concat",
            "_compare_utc_to_local",
            "test_series_constructor",
            "test_swapaxes",
            "_get_interval",
            "_convert_to_side",
            "test_string_methods_dont_fail",
            "_check_align_fill",
            "test_tuple_warns",
            "test_from_codes_with_nan_code",
            "_write_regular_rows",
            "_prep_index",
            "test_constructor_start_end_with_tz",
            "get_versions",
            "test_union_sort_special_true",
            "test_clip_with_datetimes",
            "test_get_freq_code",
            "test_weeks_onoffset",
            "_block_shape",
            "set_closed",
            "indexables",
            "test_concat_tz_series_with_datetimelike",
            "test_raises_on_dtype_object",
            "test_td_floordiv_offsets",
            "test_iteration_and_str",
            "test_contains_moar",
            "test_append_empty",
            "test_ix_empty_list_indexer_is_ok",
            "test_td64arr_div_td64nat",
            "testPackUnicode",
            "test_interval_array_equal_start_mismatch",
            "_next_line",
            "test_union_not_cacheable",
            "_set_tz",
            "test_per_axis_per_level_doc_examples",
            "test_to_datetime_with_space_in_series",
            "_dir_additions",
            "time_unstack",
            "test_dt_timetz_accessor",
            "check_min_structure",
            "corr",
            "test_setitem_frame_float",
            "test_dti_constructor_with_fixed_tz",
            "dtype_format_for_platform",
            "_unstack_extension_series",
            "test_tuple_correct_keyerror",
            "get_block_values",
            "test_fancy_getitem_slice_mixed",
            "test_multiindex_setitem",
            "html",
            "test_array_equivalent",
            "test_name_repr_generic",
            "test_round_30min",
            "_dtype_to_stata_type",
            "highlight_null",
            "author_missing_data",
            "test_df_add_2d_array_rowlike_broadcasts",
            "time_read_json_lines",
            "parse_table_schema",
            "test_sortlevel",
            "_class_to_alias",
            "levels",
            "test_rule_code",
            "_set_with",
            "test_ax_plot",
            "test_resolution_string",
            "compress_group_index",
            "time_append_homogenous",
            "test_floating_index_doc_example",
            "test_large_difference_in_columns",
            "test_interpolate_akima",
            "test_to_numpy",
            "test_nunique_with_timegrouper",
            "test_to_csv_mixed",
            "test_datetime_shift_always_copy",
            "_validate_date_like_dtype",
            "test_density",
            "test_unstack_fill_frame_period",
            "test_adjoin_unicode",
            "test_nat_handling",
            "test_to_offset_leading_plus",
            "test_readonly_axis_zlib_to_sql",
            "set_ordered",
            "test_categorical_ordering",
            "get_rule_code_suffix",
            "test_codes_immutable",
            "test_indexer_caching",
            "test_empty_with_index_col_false",
            "test_repr_tuples",
            "test_empty_sequence_concat",
            "_align_frame",
            "test_timegrouper_with_reg_groups",
            "test_negative_skiprows",
            "test_strip_lstrip_rstrip_args",
            "test_get_loc_length_one_interval",
            "categories",
            "_downsample",
            "test_constructor_dict_of_tuples",
            "_get_prev_label",
            "test_week_without_day_and_calendar_year",
            "test_compression_zlib",
            "test_corner_cases",
            "sp_index",
            "test_take_fill_valid",
            "_skip_if_not_us_locale",
            "_check_divmod_op",
            "test_dataframe_box_false",
            "test_to_latex_multindex_header",
            "_offset_str",
            "test_apply_empty_infer_type",
            "test_encoding",
            "compare_sp_series_ts",
            "test_getitem_with_duplicates_indices",
            "test_asfreq_MS",
            "test_period_cons_mult",
            "test_to_datetime_bijective",
            "test_pivot_index_with_nan",
            "test_npoints",
            "test_datetime64_with_index",
            "test_is_unsigned_integer_dtype",
            "test_insert_index_bool",
            "_convert_listlike",
            "test_mixed_freq_irregular_first_df",
            "read_ext",
            "_init_dict",
            "test_fy5253_nearest_onoffset",
            "time_concat_empty_right",
            "_count_level",
            "time_dict_rename_both_axes",
            "test_read_from_s3_url",
            "test_to_string_complex_float_formatting",
            "test_set_index_custom_label_type_raises",
            "test_period_ordinal_week",
            "desc_no_period",
            "test_iloc_sparse_propegate_fill_value",
            "test_bad_apply_shape",
            "_read_header",
            "scatter",
            "set_codes",
            "test_fast_unique_multiple_list_gen_sort",
            "_infer_compression",
            "itemsize",
            "fields",
            "test_resample_anchored_ticks",
            "test_underlying_data_conversion",
            "idx",
            "test_pivot_table_multiple",
            "test_pivot_dtypes",
            "_add_numeric_methods_add_sub_disabled",
            "time_shape",
            "test_assert_almost_equal_iterable_values_mismatch",
            "test_ewmcorr_pairwise",
            "test_irregular_ts_shared_ax_xlim",
            "test_factorize_nan",
            "test_df_add_td64_columnwise",
            "test_unsupported_other",
            "test_translate",
            "test_sort_nat_values_in_int_column",
            "test_td_constructor_on_nanoseconds",
            "test_msgpacks_legacy",
            "test_reindex_doesnt_preserve_type_if_target_is_empty_index",
            "test_roundtrip_chunksize",
            "test_compare_unknown_type",
            "test_pipe_tuple",
            "_get_default_writer",
            "test_series_getitem_indexing_errors",
            "test_series_operators",
            "test_spss_usecols",
            "test_to_coo_bad_ilevel",
            "test_dti_shift_near_midnight",
            "test_constructor_scalar_inference",
            "test_setattr_column",
            "test_ngroup_groupby_not_col",
            "_set_labels",
            "time_read_uint64",
            "test_nth_multi_index_as_expected",
            "test_freq_conversion",
            "_maybe_resample",
            "test_1d_other_dtypes",
            "test_nonunicode_nonascii_alignment",
            "test_extract_series",
            "visit_Module",
            "test_boxplot_series",
            "testFixMap",
            "wrong_line",
            "test_plot_figsize_and_title",
            "test_constructor_default_index",
            "test_astype_cast_object_int",
            "_open_file_binary_write",
            "test_time_loc",
            "book",
            "test_length_one",
            "test_con_string_import_error",
            "test_inferred_dtype",
            "test_categorical_series_repr_datetime",
            "_generate_range_overflow_safe_signed",
            "test_setitem_tuple",
            "test_array_to_slice_conversion",
            "test_setitem_scalar",
            "get_corr_func",
            "test_to_datetime_overflow",
            "bad_colon_spacing",
            "test_rollforward",
            "test_validation",
            "test_guess_datetime_format_no_padding",
            "test_naneq",
            "test_infer_freq_custom",
            "test_td64arr_add_intlike",
            "test_unary_ops",
            "test_frame_any_all_group",
            "cumsum",
            "_where_standard",
            "test_slice_consolidate_invalidate_item_cache",
            "test_to_latex_midrule_location",
            "test_split_maxsplit",
            "test_single_mgr_ctor",
            "test_array_list",
            "test_json_normalize_errors",
            "test_frame_nonprintable_bytes",
            "test_factorize_dst",
            "test_expand_user",
            "test_to_timestamp_1703",
            "test_index_unique",
            "test_to_datetime_infer_datetime_format_consistent_format",
            "test_groupby_transform_rename",
            "test_where_series_bool",
            "test_ensure_index_from_sequences",
            "test_groupby",
            "test_coercion_with_setitem_and_series",
            "test_duplicate_level_names_access_raises",
            "_data",
            "test_header_multi_index_invalid",
            "test_start_time",
            "test_offset",
            "_subplots",
            "time_rank_string_cat_ordered",
            "test_agg_nested_dicts",
            "df2",
            "test_get_group",
            "test_timestamp_constructor_near_dst_boundary",
            "test_nanany",
            "test_dtype_on_merged_different",
            "test_getitem_listlike",
            "time_iteritems_indexing",
            "test_compare_series_interval_keyword",
            "_combine_lines",
            "test_empty_nonzero",
            "test_reindex_items",
            "test_join_multiindex_leftright",
            "test_concat_categorical_empty",
            "rand_",
            "test_constructor_same",
            "_insert_index",
            "test_unit_consistency",
            "test_to_latex_multiindex",
            "test_drop_names",
            "test_mixed_type_suffix",
            "_get_freq",
            "test_arith_integer_array",
            "test_ngroup_descending",
            "test_not_slice_like_arrays",
            "pprint_thing",
            "holder",
            "test_parse_public_s3_bucket_nrows_python",
            "register_index_accessor",
            "test_hist_df_with_nonnumerics",
            "test_comparison_tzawareness_compat",
            "test_skip_group_keys",
            "test_compression_warning",
            "test_rolling_quantile_interpolation_options",
            "test_is_datetime_arraylike",
            "test_to_html_with_col_space",
            "test_parse_date_all_fields",
            "test_default_date_conversion",
            "test_infer_output_shape_columns",
            "__rdivmod__",
            "_unbox_scalar",
            "test_loads_non_str_bytes_raises",
            "test_repr_html_wide",
            "test_constructor_unsortable",
            "test_formatting_values_deprecated",
            "test_iter_python_types",
            "test_duplicate_column_name",
            "test_ragged_apply",
            "simple_date_range_series",
            "__ne__",
            "test_maybe_mangle_lambdas_args",
            "test_iloc_getitem_dups",
            "test_tfoot_read",
            "mixed_frame",
            "test_minmax_timedelta64",
            "sort",
            "effective_dtype",
            "test_pi_add_offset_n_gt1",
            "test_get_level_values_box",
            "test_apply_corner_cases",
            "test_df_div_zero_int",
            "test_multitype_list_index_access",
            "test_float_comparison_bin_op",
            "test_ravel",
            "test_repr_np_nat_with_object",
            "test_to_datetime_tz",
            "time_infer_freq",
            "test_nonunique_raises",
            "validate_clip_with_axis",
            "sparse_reindex",
            "test_replace_int_to_int_chain",
            "test_dti_take_dont_lose_meta",
            "test_datetime_invalid_scalar",
            "date",
            "test_dataframe_constructor_from_dict",
            "test_pairwise_with_self",
            "tick_classes",
            "time_rank_ties",
            "test_groupby_grouper",
            "day_deltas",
            "period_code_item",
            "_can_hold_identifiers_and_holds_name",
            "test_from_records_decimal",
            "test_mixed_freq_second_millisecond",
            "time_replace",
            "test_take_pandas_style_negative_raises",
            "test_as_json_table_type_date_dtypes",
            "test_to_csv_defualt_encoding",
            "time_categorical_index_contains",
            "test_slice_locs_negative_step",
            "test_accessor_raises",
            "test_dti_custom_business_summary_dateutil",
            "signature_parameters",
            "test_constructor_spindex_dtype",
            "_infer_precision",
            "_get_layout",
            "test_corner",
            "test_assignment_fails",
            "test_unstack_bool",
            "test_tz_convert_corner",
            "_is_url",
            "test_tdi_add_overflow",
            "test_constructor_dict_timedelta_index",
            "test_casefold",
            "test_frame_setitem_slice",
            "test_interpolate_timedelta_index",
            "test_from_arrays",
            "diff",
            "test_slice_locs_not_sorted",
            "test_default_handler_raises",
            "test_categories",
            "test__cython_agg_general",
            "test_rename_axis_mapper",
            "visit_Subscript",
            "test_slice_floats2",
            "data_missing",
            "test_multi_index_header",
            "test_resample_dup_index",
            "test_result_types",
            "test_at_time",
            "_get_foo",
            "test_factorize_equivalence",
            "_parse_metadata",
            "test_scalar_comparison_tzawareness",
            "test_validate_ordered",
            "test_incomplete_first_row",
            "test_series_negate",
            "test_align_nocopy",
            "time_dropna_axis_mixed_dtypes",
            "_bar",
            "test_to_integer_array_inferred_dtype",
            "test_concat_dataframe_keys_bug",
            "test_to_html_float_format_no_fixed_width",
            "test_str_cat_align_mixed_inputs",
            "test_get_dummies",
            "test_to_sql_index_label",
            "test_empty_dtype_coerce",
            "_is_dtype_compat",
            "test_mod_offset",
            "test_default_separator",
            "test_rhs_alignment",
            "test_from_resampling_area_line_mixed",
            "test_rolling_apply",
            "_create_consistency_data",
            "hist",
            "test_replace_unicode_with_number",
            "test_interpolate_pchip",
            "test_swapped_columns",
            "test_recode_to_categories",
            "time_get_loc_non_unique",
            "test_with_kwargs",
            "pytables_hdf5_file",
            "test_pivot_table_not_series",
            "test_item_section",
            "time_dt_accessor",
            "_get_offset_day",
            "test_getitem_box_float64",
            "test_attribute_access",
            "test_series_from_json_to_json",
            "test_mixed_depth_drop",
            "test_bool_handling",
            "test_whitespace_lines",
            "test_dictwrapper_getattr",
            "test_unique",
            "extract_index",
            "time_iloc_slice",
            "test_astype_duplicate_col",
            "_get_combined_index",
            "test_assert_produces_warning_honors_filter",
            "test_construction_dti_with_mixed_timezones",
            "test_round_frac_just_works",
            "test_nanvar_all_finite",
            "test_join_sort",
            "test_boxplot_return_type",
            "test_dt_accessor_api_for_categorical",
            "test_select_dtypes",
            "apply_raw",
            "test_suppress_error_output",
            "test_frame_to_json_except",
            "draw",
            "interval_values",
            "no_period_multi",
            "test_inf",
            "test_invalid_terms",
            "test_constructor_from_categorical_with_dtype",
            "test_read_expands_user_home_dir",
            "test_unstack_preserve_dtypes",
            "time_isin_nans",
            "test_nan_fullcolumn",
            "test_unicode_encoding",
            "test_datelike",
            "test_tdi_shift_empty",
            "has_level_label",
            "test_incorrect_type_nested_map",
            "time_add_offset",
            "test_union_categoricals_sort_false",
            "test_hash_tuples_err",
            "test_masked_setitem",
            "agg_axis",
            "test_read_duplicate_index_implicit",
            "test_pairwise_with_series",
            "test_store_datetime_mixed",
            "all_index_generator",
            "test_round",
            "abs",
            "test_corr_pearson",
            "test_more_values",
            "test_groupby_complex",
            "test_recode_to_categories_large",
            "test_setitem_listlike",
            "pivot",
            "_get_fmtlist",
            "_add_timedeltalike_scalar",
            "test_unicode",
            "assert_series_equal",
            "_cat_compare_op",
            "time_stack",
            "latex_forced",
            "rfind",
            "test_to_csv_dups_cols",
            "test_interp_basic",
            "is_terminal",
            "test_deprecate_kwarg",
            "test_reindex_bool_pad",
            "_check_method",
            "test_date_range_with_tz",
            "test_int64_nocopy",
            "test_conv_annual",
            "spmatrix",
            "test_to_csv_from_csv1",
            "test_export",
            "_setup_build_doc",
            "examples_errors",
            "test_can_set_locale_invalid_get",
            "_protect_consolidate",
            "test_reduce_series_boolean",
            "test_from_tuples_iterator",
            "test_multi_index_names",
            "test_mode_numerical_nan",
            "reindex_axis",
            "test_symmetric_difference",
            "test_constructor_coerce_float_fail",
            "test_read_table_columns",
            "test_compare_str",
            "_scalar_from_string",
            "test_hide_single_index",
            "test_sparse_mi_max_row",
            "test_to_sql_series",
            "maybe_convert_dtype",
            "test_filter_corner",
            "test_listlike_setitem",
            "test_merge_on_datetime64tz_empty",
            "test_nanosecond_getitem_setitem_with_tz",
            "_get_ax",
            "test_read_infer",
            "other_closed",
            "makePeriodIndex",
            "_maybe_convert",
            "_get_unit",
            "test_decode_numeric_int",
            "test_nsmallest",
            "test_sparse_frame_fillna_limit",
            "test_uuid",
            "test_get_dummies_all_sparse",
            "str_get",
            "test_encode_dict_conversion",
            "_getitem_scalar",
            "_write_sortlist",
            "test_fromValue",
            "test_iloc_getitem_slice_dups",
            "test_frame_groupby_columns",
            "test_dict_compat",
            "test_skip_rows_bad_callable",
            "test_mangled_unnamed_placeholders",
            "_convert_to_ndarrays",
            "test_categorical_dtype_high_cardinality_numeric",
            "test_nested_scope",
            "test_read_write_dta10",
            "test_convert_preserve_all_bool",
            "test_values_consistent",
            "test_isna",
            "to_time",
            "time_write_store_table",
            "test_shift_empty_array",
            "after_nearest_workday",
            "_convert_expression",
            "get_test_data",
            "test_reindex_dups",
            "_setup_axes",
            "test_cython_group_transform_cumsum",
            "test_exponents_without_eng_prefix",
            "rank",
            "_maybe_remove",
            "test_no_na_values_no_keep_default",
            "gen_binary_data",
            "test_nan_to_nat_conversions",
            "time_store_repr",
            "test_range_float_union_dtype",
            "test_slice_iter",
            "test_assert_almost_equal_strings",
            "test_same_tz_min_max_axis_1",
            "setup",
            "test_performance_warning_for_poor_alignment",
            "test_dataframe_dummies_prefix_str",
            "test_get_callable_name",
            "test_subclass_sparse_transpose",
            "make_invalid_op",
            "test_infer_freq_business_hour",
            "to_string",
            "test_setitem_scalar_series",
            "_write_col_header",
            "test_maybe_promote_any_numpy_dtype_with_datetimetz",
            "test_constructor_list_like",
            "is_na",
            "test_excel_stop_iterator",
            "test_series_named_agg_duplicates_raises",
            "test_max_rows_eq_one",
            "test_spline",
            "is_string_like",
            "_validate_indexer",
            "test_datetime_invalid_index",
            "set_table_attributes",
            "test_constructor_datetime64arr_ok",
            "_join_unicode",
            "time_col_select_numpy_sum",
            "test_business_daily",
            "test_at_and_iat_set",
            "test_render_empty_dfs",
            "test_pivot_with_tuple_of_values",
            "test_take_coerces_list",
            "test_frame_from_json_bad_data",
            "test_assign_with_sparse_frame",
            "test_invalid_origin",
            "_get_op_result_fill_value",
            "test_difference_sort_incomparable",
            "test_generate_bins",
            "base",
            "_ndarray_values",
            "test_objarr_radd_str",
            "test_ser_flex_cmp_return_dtypes_empty",
            "test_concat_mixed_dtypes",
            "_wrap_agged_blocks",
            "_get_fill_indexer",
            "test_to_datetime_dt64s",
            "test_loc_coerceion",
            "test_empty_str_inp",
            "test_path",
            "test_c_engine",
            "test_check_many_exprs",
            "test_infer_tz_utc_localize",
            "_is_sqlalchemy_connectable",
            "test_duplicated_do_not_fail_on_wide_dataframes",
            "test_setitem_corner",
            "_isna_new",
            "test_count",
            "test_assert_almost_equal_shape_mismatch_override",
            "time_parse_today",
            "test_rolling_kurt_eq_value_fperr",
            "deltas_asi8",
            "test_groupby_resample_api",
            "time_series_align_int64_index",
            "holidays",
            "time_period_constructor",
            "_check_unsupported",
            "time_floats_with_dt_index",
            "setup_indices",
            "skip_numpy_object",
            "test_unstack_fill_frame_datetime",
            "test_kde_kwargs",
            "test_mean_datetimelike",
            "test_constructor_interval",
            "test_constructor_miscast_na_int_dtype",
            "test_to_tuples_na",
            "test_datetime_likes_nan",
            "test_numpy_round_nan",
            "test_assert_extension_array_equal_non_extension_array",
            "test_timegrouper_apply_return_type_value",
            "test_to_offset_pd_timedelta_invalid",
            "test_column_dups2",
            "test_too_many_names",
            "test_hash_equal",
            "test_union_categoricals_sort",
            "test_map_dict_subclass_without_missing",
            "test_transform_casting",
            "test_astype_str_float",
            "test_repr_roundtrip_raises",
            "time_query_datetime_index",
            "_run_test",
            "__hash__",
            "test_multiindex_header_skiprows",
            "test_interpolate_from_derivatives",
            "test_from_categorical_dtype_ordered",
            "init_osx_clipboard",
            "units",
            "_get_option",
            "rollforward",
            "dtype_str",
            "rpartition",
            "test_setitem_datetimeindex_tz",
            "test_ignore_empty_rows_when_inferring_header",
            "test_mode_str_obj",
            "test_table_styles",
            "test_style_by_column",
            "_minmax",
            "test_to_csv_path_is_none",
            "create_block_manager_from_arrays",
            "test_week_of_month_infer",
            "str_startswith",
            "test_multigroup",
            "is_copy",
            "test_int_name_format",
            "test_setitem_frame_mixed",
            "time_getitem_array",
            "test_datetime_understood",
            "get_node",
            "time_from_iso_format",
            "test_constructor_name_unhashable",
            "test_resample_entirly_nat_window",
            "get_group_levels",
            "time_dataframe_describe",
            "test_agg_over_numpy_arrays",
            "from_tuples",
            "test_rank_args_missing",
            "test_multiindex_slicers_non_unique",
            "test_rename_bug",
            "test_where_series_datetime64",
            "test_not_all_defaults",
            "test_mode_mixeddtype",
            "test_astype_specific_casting",
            "test_set_index_custom_label_type",
            "test_pickles",
            "test_index_col_empty_data",
            "test_constructor_dtype_timedelta64",
            "test_time_zone_aware_index",
            "test_transpose",
            "test_timestamp",
            "setup_cache",
            "assert_index_parameters",
            "test_get_loc_multiple_dtypes",
            "test_loc_frame",
            "test_ops_series",
            "test_to_timestamp_mult",
            "test_indexing_doesnt_change_class",
            "test_resample_loffset_arg_type",
            "test_infer_dtype_timedelta",
            "time_plot_regular",
            "time_nlargest",
            "test_datetime64_ops_nat",
            "test_set_ContextManager",
            "test_greaterEqual",
            "test_resample_fill_missing",
            "test_groupby_multiindex_categorical_datetime",
            "test_detect_string_na",
            "test_as_frame_columns",
            "test_astype_to_timedelta_unit",
            "test_slice_can_reorder_not_uniquely_indexed",
            "make_block_same_class",
            "test_equal",
            "test_chunk_whitespace_on_boundary",
            "test_type_coercion_at_construction",
            "_transform",
            "test_at_iat_coercion",
            "test_closed_empty",
            "test_frame_setitem_view_direct",
            "test_super_sub_symmetry",
            "_get_columns_formatted_values",
            "convert_from_missing_indexer_tuple",
            "test_append",
            "test_empty_series_add_sub",
            "test_get_group_grouped_by_tuple",
            "test_dt_round_tz_ambiguous",
            "test_constant_series",
            "test_spss_umlauts",
            "test_value_array_record_prefix",
            "test_maybe_convert_i8_nat",
            "test_is_datetimelike_array_all_nan_nat_like",
            "time_dtype_as_group",
            "sample",
            "test_iloc",
            "time_remove_unused_levels",
            "test_merge_datatype_categorical_error_raises",
            "test_parse_tz_aware",
            "get_json_no_auth",
            "maybe_box",
            "test_dropna_frame",
            "test_fillna_timedelta",
            "convert",
            "test_getitem_setitem_ellipsis",
            "test_git_version",
            "test_constructor_datetime_outofbound",
            "test_isna_numpy_nat",
            "_fill_value_matches",
            "test_usecols_single_string",
            "test_nat_comparisons_scalar",
            "time_frame_quantile",
            "_sub_nat",
            "test_simple_expr",
            "test_sort_index_multicolumn",
            "test_mixed_timezone_series_ops_object",
            "test_interleave_non_unique_cols",
            "test_to_string_no_index",
            "test_construction_quarter",
            "time_rename_both_axes",
            "test_grouped_hist_legacy2",
            "test_maybe_promote_int_with_float",
            "yield_not_documented",
            "test_merge_right_index_right",
            "test_regex_idempotency",
            "test_fill_value_corner",
            "test_to_records_datetimeindex_with_tz",
            "test_constructor_mixed_dtypes",
            "test_fancy_getitem",
            "test_series_non_unique_index",
            "list_of_lists",
            "test_corr_constant",
            "metadata",
            "test_cross_type_arithmetic",
            "test_type_error_multiindex",
            "_cython_operation",
            "test_select_dtypes_typecodes",
            "test_frame_series_agg_multiple_levels",
            "time_series_int",
            "test_date_index_query_with_NaT_duplicates",
            "test_shift_corner_cases",
            "deprecated",
            "rule_code",
            "test_reindex_series_add_nat",
            "_stringify_path",
            "test_frame_loc_callable_setitem",
            "sp_values",
            "test_inplace_return_self",
            "get_period_alias",
            "test_from_dtype",
            "to_arrays",
            "test_pivot_table_aggfunc_scalar_dropna",
            "test_replace_tzinfo",
            "test_series_datetime_index",
            "test_quarterly_resampling",
            "_arith_method_FRAME",
            "test_left_join_indexer",
            "test_arith_zero_dim_ndarray",
            "test_series_align_aware",
            "test_as_json_table_type_string_data",
            "test_replace_naive",
            "test_constructor_freq_mult_dti_compat",
            "as_matrix",
            "test_constructor_from_items",
            "time_regular",
            "test_passed_bar_colors",
            "test_merge_on_index_with_more_values",
            "test_comparison_flex_alignment_fill",
            "test_detect_console_encoding_fallback_to_locale",
            "test_construct_index",
            "test_series_to_json_except",
            "test_numpy_scalar_float",
            "test_bad_hook",
            "is_any_int_dtype",
            "test_cumcount_groupby_not_col",
            "time_now",
            "import_optional_dependency",
            "_coo_to_sparse_series",
            "test_upcast",
            "test_object",
            "test_logscales",
            "df_none",
            "test_isna_behavior",
            "_index_start",
            "test_to_excel_multiindex_nan_label",
            "set_use_numexpr",
            "time_series_drop_dups_int",
            "test_query_with_string_columns",
            "_to_original_callable",
            "nanmedian",
            "test_to_csv_date_format",
            "test_boxplot_colors",
            "should_show_dimensions",
            "test_td_mul_scalar",
            "test_right",
            "test_dataframe_nested",
            "test_math_div",
            "_get_window",
            "test_complex_cmp_ops",
            "test_td_rdiv_timedeltalike_scalar",
            "test_do_not_mangle_na_values",
            "test_unordered_same",
            "test_construct_from_string",
            "test_hash_pandas_object2",
            "_get_axis_name",
            "test_fillna_series_int64",
            "test_from_spmatrix_raises",
            "_join_multiline",
            "test_invalid_total_length_max_length_one",
            "test_sum_overflow",
            "test_bad_quote_char",
            "test_append_hierarchical",
            "assert_period_array_equal",
            "get_atom_data",
            "test_integer_positional_indexing",
            "test_from_product_index_series_categorical",
            "test_ngroup_distinct",
            "_print_as_set",
            "test_fails_on_no_datetime_index",
            "test_groupby_as_index_apply",
            "test_series_invert",
            "test_api_for_categorical",
            "test_get_numeric_data_extension_dtype",
            "set_locale",
            "test_unicode_dta_118",
            "test_tz_is_utc",
            "test_mixed_freq_alignment",
            "test_cannot_create_instance_of_stolen_buffer",
            "str_join",
            "time_startswith",
            "ensure_float",
            "test__get_dtype_sparse",
            "test_explicit_conversions",
            "time_to_timestamp",
            "test_duplicate_dates_indexing",
            "test_floats",
            "test_dtype_name_in_info",
            "time_pad",
            "test_compression_size",
            "test_crosstab_with_categorial_columns",
            "test_concat_all_na_block",
            "test_interpolate_spline_invalid_order",
            "test_interp_raise_on_all_object_dtype",
            "test_order_aggregate_multiple_funcs",
            "is_signed_integer_dtype",
            "test_loc_multiindex_incomplete",
            "assert_contains_all",
            "test_datelike_mode",
            "test_sunday_to_monday",
            "__enter__",
            "default_fill_value",
            "kde",
            "test_hongkong_tz_convert",
            "test_empty_usecols",
            "get_rows",
            "test_take_filling",
            "_need_convert",
            "test_examples4",
            "test_monthly_infer",
            "time_frame_dtypes",
            "time_itertuples_read_first",
            "test_custom_business_day_freq",
            "_set_is_copy",
            "_sort_labels",
            "_to_str_columns",
            "test_line_plot_period_frame",
            "test_copy_name2",
            "test_date_range_localize",
            "_tuplify",
            "test_builtins_apply",
            "test_int_array_comparison",
            "_create_sp_frame",
            "run_command",
            "_get_series_result_type",
            "_describe_option",
            "test_dt64arr_aware_sub_dt64ndarray_raises",
            "test_kind",
            "test_parr_ops_errors",
            "test_partial_string_timestamp_multiindex",
            "test_no_args_raises",
            "test_coerce_outside_ns_bounds_one_valid",
            "test_assert_not_almost_equal_dicts",
            "test_datapath",
            "test_rands_array_2d",
            "test_dot",
            "test_unstack_timezone_aware_values",
            "test_aaa_group_order",
            "peakmem_itertuples",
            "start",
            "test_read_csv_buglet_4x_multi_index",
            "_try_coerce_args",
            "test_is_dtype_no_warning",
            "test_td_floordiv_timedeltalike_scalar",
            "_hash_scalar",
            "time_from_numeric_str",
            "_check_is_partition",
            "float_frame",
            "time_nlargest_two_columns",
            "test_to_M8",
            "test_read_clipboard_infer_excel",
            "test_from_array_deprecated",
            "time_findall",
            "_generate_body",
            "test_tuple_warns_unhashable",
            "test_repr_embedded_ndarray",
            "test_clip",
            "test_xs_level_eq_2",
            "test_timedelta_plot",
            "test_dti_cmp_nat_behaves_like_float_cmp_nan",
            "_set_axis",
            "test_1",
            "_to_safe_for_reshape",
            "test_difference_sort_special_true",
            "test_mode_numerical",
            "test_slice_bounds_empty",
            "is_dtype_union_equal",
            "time_frame_int_mod",
            "_concat_same_type",
            "test_diff_neg_n",
            "index",
            "test_astype_assignment_with_dups",
            "test_agg_item_by_item_raise_typeerror",
            "test_dti_from_tzaware_datetime",
            "test_intersection_equal",
            "test_header_not_first_line",
            "test_drop_level",
            "test_intersection_bug",
            "test_group_var_large_inputs",
            "test_scalar_ops",
            "test_same_name_scoping",
            "test_difference_incomparable",
            "test_invalid_xy_args",
            "test_repr_big",
            "test_rank_descending",
            "test_to_object_array_width",
            "test_invalid_index_types",
            "test_resample_irregular_sparse",
            "test_comparison",
            "test_dt_subclass_add_timedelta",
            "peakmem_read_json_lines",
            "test_empty_with_mangled_column_pass_dtype_by_indexes",
            "test_compare_len1_raises",
            "test_repr_name_coincide",
            "test_convert_pandas_type_to_json_field_float",
            "test_sort_column_level_and_index_label",
            "test_to_period_quarterlyish",
            "test_from_list_dtype",
            "python_parser_only",
            "test_pivot_datetime_tz",
            "hist_frame",
            "test_basic_drop_first_NA",
            "test_len",
            "test_frame_describe_multikey",
            "df_main_dtypes",
            "test_duplicate_multiindex_codes",
            "test_concat_tz_series",
            "test_bool_ops_raise_on_arithmetic",
            "time_align_level",
            "test_to_datetime_barely_out_of_bounds",
            "test_zip_error_multiple_files",
            "test_filter_against_workaround",
            "test_roll_yearday2",
            "test_read_csv_chunked_download",
            "_format_space",
            "test_constructor_nano",
            "test_assert_almost_equal_pandas",
            "_wrap_joined_index",
            "test_from_product",
            "test_cast_internals",
            "test_apply_keep_sparse_dtype",
            "time_frame_dot",
            "test_merge_on_ints_floats",
            "_get_ax_legend",
            "test_next_monday_or_tuesday",
            "time_plot_irregular",
            "test_validate_stat_keepdims",
            "test_inplace_ops_identity2",
            "test_dti_representation_to_series",
            "test_repr_truncation",
            "remove_flags_docstring",
            "test_constructor_nat",
            "test_assert_almost_equal_unicode",
            "test_spline_extrapolate",
            "validate_categories",
            "test_from_iterator",
            "test_multi_index_no_level_names_implicit",
            "test_multiindex_symmetric_difference",
            "union_many",
            "test_freq_infer_raises",
            "test_promote_datetime_date",
            "_get_axes",
            "test_get_value",
            "get_indexers_list",
            "test_get_indexer2",
            "test_append_list_of_series_dicts",
            "test_empty_string_raises",
            "test_numpy_argmax_deprecated",
            "test_array_interface",
            "test_is_non_overlapping_monotonic",
            "test_dti_construction_nonexistent_endpoint",
            "test_agg_dict_parameter_cast_result_dtypes",
            "test_grouping_labels",
            "test_multi_index_blank_df",
            "test_maybe_convert_i8",
            "_end_apply_index",
            "test_day_of_month",
            "assert_equal",
            "test_out_of_bounds_integer_value",
            "time_append_int_list",
            "test_register_option",
            "test_old_import_warns",
            "test_is_scalar_numpy_arrays",
            "test_construction_outofbounds",
            "test__get_dtype",
            "test_unstack_multiple_hierarchical",
            "test_coercion_with_setitem_and_dataframe",
            "test_to_html_justify",
            "test_to_period_nofreq",
            "test_getitem_dupe_cols",
            "test_groupby_reindex_inside_function",
            "test_to_html_with_empty_string_label",
            "test_constructor_pass_none",
            "test_cummax",
            "initialize_options",
            "test_compat",
            "test_convert_dates",
            "test_date_boolean",
            "test_encoding_non_utf8_multichar_sep",
            "test_mixed_depth_pop",
            "test_rolling_corr_cov",
            "iteritems",
            "test_categorical_zeroes",
            "test_resample_empty_dataframe",
            "test_bar_align_mid_vmin_vmax_clipping",
            "_get_resampler",
            "test_nan_columnname",
            "test_join_mixed_non_unique_index",
            "test_as_index_series_column_slice_raises",
            "test_mod_timedelta64",
            "test_value_counts",
            "test_mask_with_boolean_raises",
            "test_sort_values_na_position",
            "test_dti_summary",
            "test_bool_uint",
            "test_interp_limit_forward",
            "test_merge_by_col_tz_aware",
            "_concat_compat",
            "test_from_sparse_dtype",
            "test_rounding",
            "_merge_blocks",
            "test_raise_on_find_unsupported_value",
            "_shallow_copy",
            "_values_for_factorize",
            "is_datetime64_ns_dtype",
            "labels",
            "name",
            "makeUnicodeIndex",
            "asof",
            "test_get_dummies_dont_sparsify_all_columns",
            "test_parse_integers_above_fp_precision",
            "test_dropna_preserve_name",
            "test_uint64_overflow",
            "test_skip_row_with_newline",
            "lexsort_indexer",
            "test_check_label_or_level_ambiguity_df",
            "time_different_offset",
            "test_ops_ndarray",
            "test_period_array_freq_mismatch",
            "test_integer_array_constructor_none_is_nan",
            "test_where_index_datetime64tz",
            "test_drop_duplicates_bool",
            "test_reindex_level_partial_selection",
            "test_get_offset_name",
            "_get_data_from_filepath",
            "_aggregate_generic",
            "time_pivot_table_categorical",
            "_apply_columns",
            "test_CategoricalAccessor_categorical_deprecation",
            "test_unstack_level_name",
            "test_frame_select",
            "test_constructor_dtypes_to_object",
            "test_resample_dst_anchor",
            "concat_same_type",
            "test_loc_duplicates",
            "test_compare_custom_object",
            "test_read_hdf_generic_buffer_errors",
            "test_concat_period_multiple_freq_series",
            "putmask",
            "test_sort_datetimes",
            "copy",
            "str_findall",
            "test_median_empty_bins",
            "test_pickle_v0_15_2",
            "_create_join_index",
            "test_td_rsub_mixed_most_timedeltalike_object_dtype_array",
            "test_finder_monthly",
            "_check_cast",
            "test_rolling_cov_diff_length",
            "_can_use_numexpr",
            "is_signed_integer",
            "resample",
            "test_stack_mixed_dtype",
            "test_iloc_setitem_dups",
            "test_set_index",
            "test_get_item",
            "test_custom_repr",
            "test_read_tarfile",
            "test_has_duplicates",
            "ensure_index_from_sequences",
            "time_add_overflow_arr_mask_nan",
            "test_series_add_tz_mismatch_converts_to_utc_duplicate",
            "test_dti_add_offset_index",
            "test_drop_labels_or_levels_series",
            "test_getitem_with_datestring_with_UTC_offset",
            "test_constructor_mix_series_nonseries",
            "test_subplots_timeseries_y_axis",
            "test_mixed_type_join_with_suffix",
            "test_fillna_datetime64tz",
            "test_nan_to_missing_value",
            "test_multiby_indexed",
            "test_resample_axis1",
            "test_negate_lt_eq_le",
            "test_to_datetime_utc_true_with_series_single_value",
            "test_parse_time_quarter_with_dash_error",
            "test_nan_stays_float",
            "boxplot_frame_groupby",
            "test_rename_positional",
            "test_bins_not_monotonic",
            "test_to_datetime_cache_scalar",
            "test_as_array_datetime_tz",
            "test_add_sub_nat",
            "test_resample_dtype_preservation",
            "cat_safe",
            "time_frame_nunique",
            "test_set_incompatible_types",
            "test_intersection_name_preservation2",
            "test_assign_dependent",
            "test_parsers_quarter_invalid",
            "_assert_tzawareness_compat",
            "test_pi_cmp_nat",
            "test_unique_ordered",
            "test_bad_engine_raises",
            "has_expanded_repr",
            "test_range_closed",
            "test_resample_ohlc",
            "test_sub_offset",
            "test_unstack_fill",
            "test_margins_dtype_len",
            "test_append_new_columns",
            "test_where_tz",
            "test_excel_010_hemstring",
            "set_files",
            "sample_values",
            "test_line_plot_period_series",
            "test_integer_arithmetic",
            "test_read_json_table_orient",
            "test_dups_fancy_indexing",
            "test_rank_tie_methods_on_infs_nans",
            "_is_ts_plot",
            "test_groupby_nat_exclude",
            "test_dt64_mul_div_numeric_invalid",
            "time_isnull",
            "_write_cell",
            "axis",
            "test_get_schema2",
            "test_is_overlapping_endpoints",
            "tz_naive_fixture",
            "test_maybe_infer_to_datetimelike_df_construct",
            "test_replace2",
            "test_convert_infs",
            "no_description",
            "test_slicing_directly",
            "test_to_hierarchical",
            "test_maybe_promote_float_with_float",
            "test_subclass_align",
            "test_index_equal_category_mismatch",
            "describe",
            "test_rename_objects",
            "_string_data_error",
            "check_pow",
            "test_thorough_mangle_columns",
            "test_secondary_y_mixed_freq_ts_xlim",
            "test_series_add_tz_mismatch_converts_to_utc",
            "test_xs",
            "test_dataframe_insert_column_all_na",
            "test_set_categories_rename_less",
            "test_constructor_int64_nocopy",
            "test_index_tolerance",
            "test_str_cat_raises_intuitive_error",
            "insert_statement",
            "test_tz_localize_ambiguous",
            "test_iloc_getitem_neg_int_can_reach_first_index",
            "test_append_empty_frame_to_series_with_dateutil_tz",
            "test_mixed_integer",
            "test_different",
            "test_construction_from_replaced_timestamps_with_dst",
            "test_multiindex_objects",
            "test_to_csv_string_with_lf",
            "_update_inplace",
            "peakmem_read_json_lines_concat",
            "is_",
            "gen_of_str",
            "test_datetime_with_tz_dtypes",
            "test_to_string_name",
            "testRaw",
            "test_set_reset",
            "split_and_operate",
            "test_period_index_date_overflow",
            "len",
            "is_datetime64_dtype",
            "find_common_type",
            "test_constructor_single_str",
            "test_rank_args",
            "test_character_overlap",
            "nunique",
            "test_timestamp_tz_localize_nonexistent_shift_invalid",
            "test_prod_numpy16_bug",
            "test_align_nested_unary_op",
            "test_copy_index_name_checking",
            "_is_deprecated",
            "test_title",
            "test_put_compression",
            "_check_for_locals",
            "_excel2num",
            "test_read_one_empty_col_with_header",
            "prop",
            "test_quantile_interpolation",
            "test_temporary_file",
            "time_comment",
            "maybe_promote",
            "array_equivalent",
            "inferred_type",
            "_get_adjustment",
            "_reindex_columns",
            "whitelist_method_generator",
            "test_to_hdf_multiindex_extension_dtype",
            "test_merging_with_bool_or_int_cateorical_column",
            "hide_index",
            "test_setitem_same_ordered_rasies",
            "_validate_freq",
            "test_constructor_dtype_nocast_view",
            "test_joins",
            "time_reindex_both_axes",
            "narrow_multi_index",
            "test_pytables_native_read",
            "test_bool_header_arg",
            "test_read_csv_compat",
            "random_state",
            "test_fwf_compression",
            "test_copy_astype",
            "test_tuple_with_strings",
            "test_frame_iloc_callable",
            "decons_obs_group_ids",
            "test_cut_pass_series_name_to_factor",
            "test_iadd",
            "test_csv_to_string",
            "time_mi_series",
            "test_line_continuation",
            "test_from_records_bad_index_column",
            "test_empty_with_nrows_chunksize",
            "test_value_counts_unique_nunique_null",
            "examples_source_code",
            "_use_dynamic_x",
            "should_store",
            "test_to_html_multiindex_odd_even_truncate",
            "test_color_and_style_arguments",
            "test_where_unsafe_float",
            "_apply_index_days",
            "test_constructor_from_too_large_array",
            "test_searchsorted_numeric_dtypes_vector",
            "utc_fixture",
            "test_radd",
            "test_slice_locs_with_interval",
            "_engine_builder",
            "test_timestamp_invalid_key",
            "test_fancy_index_int_labels_exceptions",
            "set_levels",
            "test_invalid_logscale",
            "test_filter",
            "test_max_str_len",
            "test_12659",
            "test_from_product_empty_three_levels",
            "test_constructor_subclassed_datetime",
            "test_should_cache",
            "test_weekly_resample_buglet",
            "_get_hashtable_algo",
            "test_from_buffer",
            "join_type",
            "test_replace_with_empty_list",
            "_set_formats_and_types",
            "_border_style",
            "test_union_categoricals_ordered",
            "_convert_to_protection",
            "test_groupby_return_type",
            "test_sql_open_close",
            "maybe_color_bp",
            "_maybe_null_out",
            "test_int64_overflow_moar",
            "test_subtype_integer",
            "test_dti_to_pydatetime",
            "test_weekofmonth_onoffset",
            "test_slicing_and_getting_ops",
            "test_anchored_lowercase_buglet",
            "test_none_coercion_loc_and_dataframe",
            "test_cumprod",
            "test_is_list_like",
            "test_parse_delimited_date_swap",
            "time_sort_index",
            "data_orientation",
            "test_extract_expand_False",
            "test_normalize",
            "visit_List",
            "test_read_data_list",
            "test_expanding_count",
            "time_rank_string_cat",
            "test_to_dict_index_not_unique_with_index_orient",
            "time_shift",
            "_cython_agg_blocks",
            "test_date_index_query",
            "test_categorical_equal_codes_mismatch",
            "test_construct_timestamp_preserve_original_frequency",
            "test_join_self",
            "test_series_to_categorical",
            "test_reindex_multi",
            "_write_formats",
            "test_drop_by_numeric_label_raises_missing_keys",
            "test_ix_assign_column_mixed",
            "test_cast_j_int",
            "test_ser_flex_cmp_return_dtypes",
            "nblocks",
            "test_apply_issues",
            "_set_default_format",
            "leaf_size",
            "test_take_negative",
            "test_non_unique_invalid",
            "bad_complex_decoder",
            "test_simple_in_ops",
            "repeat",
            "test_count_nonnumeric_types",
            "_preprocess_data",
            "test_read_csv_gcs",
            "test_ix_multi_take_multiindex",
            "add_suffix",
            "_maybe_match_name",
            "_get_series_list",
            "test_series_getitem_multiindex_xs_by_label",
            "read_axes",
            "test_no_cast",
            "test_categorical_order",
            "test_get_indexer_array",
            "time_tz_convert",
            "view",
            "test_constructor_datelike_coercion",
            "test_header_names_backward_compat",
            "test_on_specialized_type",
            "time_unique_seconds_and_unit",
            "test_assert_numpy_array_equal_value_mismatch4",
            "mdiffs",
            "time_frame_float_mod",
            "test_na_values_with_cache",
            "test_constructor_timedelta",
            "test_decode_bad_string",
            "test_assert_not_almost_equal_numbers_with_zeros",
            "set_kind",
            "test_record_prefix",
            "test_timedelta_conversions",
            "read_data",
            "test_getitem_datetime",
            "test_setitem_iloc_scalar_single",
            "_hashed_indexing_key",
            "_format_multicolumn",
            "to_decimal",
            "test_tolerance",
            "test_astype_conversion",
            "test_is_overlapping_trivial",
            "test_groupby_2d_malformed",
            "_parser_dispatch",
            "test_drop_not_lexsorted",
            "test_hist_single_row",
            "time_read_pickle",
            "test_partial_boolean_frame_indexing",
            "get_group_index_sorter",
            "test_parsers_month_freq",
            "default_index",
            "test_to_string_header",
            "test_replace_series_datetime_datetime",
            "colorconverter",
            "test_upcast_error",
            "test_constructor_dtype_str_na_values",
            "test_replace_series_dict",
            "test_array_ufunc_series",
            "test_closed_min_max_minp",
            "test_boolean_indexing",
            "test_get_schema",
            "test_pivot_with_tz",
            "test_pivot_empty",
            "empty_value",
            "_convert_params",
            "test_astype_empty_constructor_equality",
            "test_getitem_overload",
            "setitem",
            "time_iloc_scalar",
            "test_inf_handling",
            "_convert_key",
            "get_expected_pow_result",
            "python_engine",
            "test_getitem_negative_out_of_bounds",
            "test_overflow_on_construction",
            "test_flush",
            "__instancecheck__",
            "test_bar_align_mid_all_pos",
            "test_dict_deprecate_kwarg",
            "_check_cython_group_transform_cumulative",
            "test_filter_with_axis_in_groupby",
            "test_hashtable_factorize",
            "test_concat_categorical",
            "new_child",
            "test_timeseries_preepoch",
            "test_merge_join_different_levels",
            "compare_frame_cat_and_float",
            "_prep_window",
            "test_create_table",
            "test_object_array_eq_ne",
            "_axify",
            "test_concat_inner_join_empty",
            "test_ragged_count",
            "_test_compression",
            "test_any_all_extra",
            "df_ambig",
            "test_intersection2",
            "_get_cythonized_result",
            "_get_axis_number",
            "test_append_with_different_block_ordering",
            "get_chunk",
            "test_symmetric_difference_mi",
            "test_append_different_columns",
            "test_mpl_compat_hack",
            "generate_table",
            "test_to_dense",
            "test_setitem_fancy_mixed_2d",
            "all_compare_operators",
            "test_no_legend",
            "test_infer_s3_compression",
            "test_basic_frame_alignment",
            "test_set_index_pass_single_array",
            "test_astype_object_tz",
            "_get_overlap_public_nat_methods",
            "time_dir_strings",
            "test_timedelta_ops_with_missing_values",
            "test_read_csv_no_index_name",
            "test_constructor_sanitize",
            "test_drop_table",
            "time_from_unit",
            "_apply_style_colors",
            "_post_plot_logic_common",
            "test_uneven_length_cols",
            "test_bday_near_overflow",
            "test_invalid_flavor",
            "test_where_float64",
            "apply_index",
            "test_searchsorted_monotonic",
            "test_freq_setter_deprecated",
            "test_keep_default_na",
            "test_search_sorted_datetime64_list",
            "test_categorical_dtype",
            "test_replace_for_new_dtypes",
            "test_find_nan",
            "assert_almost_equal",
            "test_to_timestamp_tz_arg_dateutil",
            "reset_testing_mode",
            "test_format_sparse_display",
            "test_fillna_integer_limit",
            "test_get_default",
            "test_merge_two_empty_df_no_division_error",
            "test_merge_nan_right",
            "test_ewmcov",
            "_info_axis",
            "test_ser_cmp_result_names",
            "test_setitem_float_labels",
            "expected_html",
            "test_no_header_prefix",
            "test_unstack_bug",
            "test_regex_replace_dict_nested_gh4115",
            "test_as_json_table_type_int_data",
            "array_dtype",
            "test_simple_normalize_with_separator",
            "test_frame_loc_callable_labels",
            "_maybe_cache_changed",
            "test_searchsorted_sorter",
            "get_attr",
            "test_aggregate_with_nat_size",
            "test_repr_truncates_terminal_size",
            "_needs_i8_conversion",
            "test_setitem_slice_array",
            "test_delta_to_nanoseconds_error",
            "test_construction_int_rountrip",
            "test_set",
            "test_binary_ops",
            "test_multilevel_consolidate",
            "test_isin_dict",
            "test_rename_set_name_inplace",
            "generate_value_label",
            "_check_column_names",
            "validate_indices",
            "test_concat_different_kind",
            "_fill",
            "test_combine_first_with_asymmetric_other",
            "test_select",
            "test_str_cat_align_indexed",
            "_parse_suffix",
            "test_stack_ints",
            "test_duplicate_level_names",
            "test_missing",
            "test_set_change_dtype",
            "test_constructor_with_datetime_tz",
            "test_remove",
            "test_last_raises",
            "test_store_datetime_fractional_secs",
            "test_info_memory_usage_bug_on_multiindex",
            "test_infer_output_shape_listlike_columns",
            "test_std_var_pass_ddof",
            "test_interpolate_index_values",
            "test_big_print",
            "test_pyint_engine",
            "test_infer_dtype_from_datetime",
            "test_observed_groups_with_nan",
            "_add_numeric_methods",
            "_set_name",
            "test_datetime_cut_roundtrip",
            "test_bar_log_subplots",
            "test_count_with_datetimelike",
            "has_doubly_truncated_repr",
            "test_parse_bool",
            "test_skip_row_with_newline_and_quote",
            "test_handle_overlap",
            "test_extractall_stringindex",
            "_normalize",
            "_reorder_by_uniques",
            "test_reindex_corner",
            "time_from_np_timedelta",
            "test_is_monotonic",
            "test_values_compatibility",
            "time_frame_repr_wide",
            "test_apply_large_n",
            "_coerce_scalar_to_index",
            "test_nargsort",
            "get_ftypes",
            "_convert_to_fill",
            "test_interval_array_equal_end_mismatch",
            "test_no_tz",
            "test_infinity_sort",
            "parameter_desc",
            "test_nd_raises",
            "test_repr_array_long",
            "test_observed_perf",
            "test_maybe_mangle_lambdas_passthrough",
            "_assert_same_contents",
            "round_trip_pickle",
            "test_info",
            "test_excel_read_buffer",
            "test_usecols_subset_names_mismatch_orig_columns",
            "line",
            "needs_filling",
            "astype_nansafe",
            "test_convert_accepts_unicode",
            "test_concat_bug",
            "df_copy_function",
            "test_assert_numpy_array_equal_bad_type",
            "test_uses_first_kind",
            "groups",
            "test_frame_from_list_subclass",
            "test_unicode_longer_encoded",
            "test_drop_nonunique",
            "_set_ticks_props",
            "kind",
            "period_range",
            "test_combine_first_timedelta",
            "test_ExcelWriter_dispatch",
            "test_decode_from_unicode",
            "test_0d_array",
            "test_conversion",
            "test_merge_equal_cat_dtypes2",
            "test_series_partial_set_period",
            "set_table",
            "test_number_mode",
            "test_parsing_valid_dates",
            "test_join_index_series",
            "test_apply_reduce_Series",
            "_decide_output_index",
            "test_sparse_frame_unstack",
            "test_groupby_whitelist",
            "__rtruediv__",
            "test_infer_dtype_all_nan_nat_like",
            "recons_labels",
            "test_binops",
            "test_dti_tz_localize_bdate_range",
            "test_reset_index_multiindex_col",
            "time_write_store_mixed",
            "test_monthly",
            "test_fillna_nat",
            "test_series_at",
            "test_groupby_apply_identity",
            "first",
            "test_datetime_count",
            "test_crosstab_dup_index_names",
            "_get_pretty_string",
            "test_coercion_with_loc_setitem",
            "__init__",
            "test_td64arr_div_td64_ndarray",
            "test_constructor_with_index",
            "time_groupby_apply_dict_return",
            "_do_select_columns",
            "test_frame_mixed_depth_get",
            "test_array_numpy_labelled",
            "_apply_rule",
            "test_lower_int_prec_count",
            "test_store_index_name_numpy_str",
            "test_skiprows_slice",
            "adjoin",
            "get_schema",
            "time_reindex_columns",
            "tz_convert",
            "test_n_error",
            "check_binary_arith_op",
            "test_crosstab_dropna",
            "test_2d_datetime64",
            "get_indexer_for",
            "test_assert_aliases_deprecated",
            "_cast_to_stata_types",
            "test_merge_non_unique_period_index",
            "_handle_truncated_float_vec",
            "test_value_counts_with_nan",
            "_get_format_datetime64_from_values",
            "test_duplicate_meta_data",
            "test_series_loc_getitem_fancy",
            "test_wide_repr_wide_long_columns",
            "test_format_kwarg_in_constructor",
            "test_method_signatures",
            "test_compare_2100",
            "makeTimeSeries",
            "test_repr_mixed",
            "test_set_index_nan",
            "test_reindex_non_na_fill_value",
            "time_iterrows",
            "test_nonnumeric_exclude",
            "test_to_dict",
            "test_groupby_levels_and_columns",
            "_restrict_to_columns",
            "test_compare_timedelta_ndarray",
            "autocorrelation_plot",
            "test_rename_mi",
            "test_series_tz_localize_nonexistent",
            "test_subtype_datetimelike",
            "test_dict_entries",
            "test_timedelta_invalid_key",
            "test_split_noargs",
            "dt64arr_to_periodarr",
            "cartesian_product_for_groupers",
            "test_no_overlap_more_informative_error",
            "test_empty_array",
            "test_intersection_monotonic",
            "test_invalid_dialect",
            "test_basic_names",
            "_infer_daily_rule",
            "visit_NameConstant",
            "test_chained_union",
            "test_catch_too_many_names",
            "_na_ok_dtype",
            "test_series_grouper_noncontig_index",
            "test_path_pathlib_hdfstore",
            "_get_xlim",
            "test_as_json_table_type_int_dtypes",
            "test_encode_double_tiny_exponential",
            "_box_item_values",
            "test_delete_slice",
            "test_view_with_args_object_array_raises",
            "empty_index",
            "check_array",
            "test_replace_doesnt_replace_without_regex",
            "testArraySize",
            "get_result_as_array",
            "apply_wraps",
            "ts1",
            "test_get_loc_nat",
            "convert_rows_list_to_csv_str",
            "test_unstack_period_series",
            "test_good_class",
            "test_at_time_tz",
            "test_tdi_shift_nonstandard_freq",
            "test_maxbuffersize_bufferfull",
            "test_converters",
            "test_quantile_raises",
            "test_timeseries_periodindex",
            "register_option",
            "test_tricky_container_to_bytes_raises",
            "test_moment_functions_zero_length",
            "test_drop_tz_aware_timestamp_across_dst",
            "test_nan_string",
            "time_reindex_dates",
            "test_categorical_series_repr_timedelta",
            "test_all_offset_classes",
            "test_compare_hour01",
            "test_to_timedelta_invalid",
            "test_agg_regression1",
            "_convert_obj",
            "test_union_categorical",
            "test_item_subsection",
            "test_union_sort_other_empty",
            "encode",
            "test_slice",
            "test_info_max_cols",
            "test_index_dupes_contains",
            "test_usecols_int",
            "_pad_bytes",
            "test_nat_converters",
            "test_round_issue",
            "split",
            "test_series_put_names",
            "test_constructor_no_levels",
            "tokenize_string",
            "backfill_1d",
            "test_loc_getitem_setitem_integer_slice_keyerrors",
            "test_tdi_sub_integer_array",
            "_check_compatible_with",
            "test_fancy_setitem_int_labels",
            "test_constructor_from_series_freq",
            "test_to_coo_integer_names_integer_row_levels_nosort",
            "test_series_invalid_type",
            "test_next_workday",
            "test_conv_hourly",
            "test_duplicates",
            "get_api_items",
            "test_merge_on_datetime64tz",
            "test_alias_to_unit_bad_alias_raises",
            "test_none_comparison",
            "test_multiindex_compare",
            "test_partial_set_empty_series",
            "test_list_numpy_float",
            "test_from_frame_invalid_names",
            "test_seaborn",
            "test_invalid_input",
            "_get_val_at",
            "simple_frame",
            "test_df_string_comparison",
            "has_index_names",
            "test_cant_fill_missing_dups",
            "use_inf_as_na_cb",
            "test_stack_datetime_column_multiIndex",
            "test_pass_array",
            "test_duplicated_drop_duplicates_index",
            "test_cast_NA_to_bool_raises_error",
            "test_period_nat_comp",
            "test_constructor_string_element_string_type",
            "test_round_nonstandard_freq",
            "test_pivot_number_of_levels_larger_than_int32",
            "flags",
            "test_astype_extension_dtypes",
            "test_parsers_nat",
            "test_apply_concat_preserve_names",
            "get_level_lengths",
            "is_unsigned_integer",
            "time_groupby_ordered_nosort",
            "_require_min_periods",
            "test_early_truncation",
            "test_spline_smooth",
            "test_excel_date_datetime_format",
            "test_repr_html_long_multiindex",
            "test_fwf_regression",
            "test_field_access_localize",
            "test_binary_ufunc_other_types",
            "test_to_json_categorical_index",
            "test_get_last_bday",
            "total_seconds",
            "test_index_type_coercion",
            "test_concat_series_partial_columns_names",
            "test_shallow_nested",
            "time_operation",
            "test_iter_python_types_datetime",
            "test_usecols",
            "_get_col_names",
            "test_take_categorical",
            "test_non_datetime_index",
            "test_partial_slicing_with_multiindex",
            "get_sheet_by_name",
            "test_apply_non_numpy_dtype",
            "test_hist_non_numerical_raises",
            "test_where_unsafe_int",
            "check_results",
            "test_to_csv_new_dupe_cols",
            "test_insert_benchmark",
            "test_skiprows_slice_long",
            "to_native_types",
            "test_from_inferred_categories",
            "test_properties",
            "s_main_dtypes",
            "test_ambiguous_warns",
            "test_representation",
            "test_boundary_datetimelike",
            "test_pipe_failures",
            "test_groupby_function_tuple_1677",
            "test_multiple_ouput_binary_ufuncs",
            "test_select_dtypes_not_an_attr_but_still_valid_dtype",
            "test_union_from_iterables",
            "test_excel_multiindex_columns_and_index_true",
            "test_float64_factorize",
            "_assert_not_almost_equal",
            "test_td64arr_add_offset_index",
            "test_file_like",
            "test_drop_duplicates_categorical_bool",
            "test_many_columns",
            "test_range_bug",
            "test_round_trip_valid_encodings",
            "test_reading_all_sheets",
            "assert_range_equal",
            "test_append_dtype_coerce",
            "_generate_range",
            "check_fun",
            "test_invalid_type_for_operator_raises",
            "__setstate__",
            "test_mean_excludeds_datetimes",
            "test_maybe_promote_dimensions",
            "test_concat_aligned_sort_does_not_raise",
            "__rsub__",
            "test_integer_overflow_bug",
            "test_setitem_boolean_mask",
            "test_compatible_inconsistent_pairs",
            "test_na_values_keep_default",
            "test_td_op_timedelta_timedeltalike_array",
            "test_map_with_dict_or_series",
            "peakmem_itertuples_raw_read_first",
            "test_astype_uint",
            "test_same_categories_different_order",
            "scan_setup_py",
            "test_int_index_make_union",
            "get_op_from_name",
            "test_invalid_parser",
            "test_loc_with_overlap",
            "_convert_can_do_setop",
            "test_bad_take",
            "hasnans",
            "test_map_na_exclusion",
            "test_plot_kwargs",
            "test_integers",
            "_from_inferred_categories",
            "test_read_hdf_series_mode_r",
            "list_of_lists_with_none",
            "test_query_syntax_error",
            "barh",
            "init_ndarray",
            "_get_index_resolvers",
            "test_align_series",
            "test_tdi_shift_minutes",
            "test_encode_string_conversion2",
            "test_set_index_raise_keys",
            "test_dti_cmp_datetimelike",
            "is_datetimelike_v_object",
            "check_simple_cmp_op",
            "test_concat_join_axes_deprecated",
            "to_offset",
            "validate_pep8",
            "test_iso_8601_strings_same_offset_no_box",
            "test_groupby_as_index_corner",
            "test_inner_join",
            "test_conversion_outofbounds_datetime",
            "test_convert_strl_name_swap",
            "test_unstack_multiple_no_empty_columns",
            "test_east_asian_unicode_false",
            "test_is_datetime64_ns_dtype",
            "test_transform_doesnt_clobber_ints",
            "test_usecols_excel_range_str",
            "test_to_jsonl",
            "date_range_frame",
            "test_describe_tz_values",
            "test_constructor_nonnan",
            "test_td64arr_div_tdlike_scalar_with_nat",
            "test_repr_html_wide_multiindex_cols",
            "test_frame_from_json_nones",
            "test_convert_no_arg_error",
            "_mpl_version",
            "test_to_csv_na_rep",
            "render_pep440_pre",
            "_get_counts",
            "test_ExcelWriter_dispatch_raises",
            "validate_and_set",
            "check_raw",
            "test_iterrows",
            "_check_box_coord",
            "test_resample_equivalent_offsets",
            "test_replace_with_single_list",
            "test_css_parse_normalisation",
            "test_axis_share_y",
            "test_constructor_inferred_fill_value",
            "_cython_agg_general",
            "test_to_dict_index_dtypes",
            "write_array_empty",
            "test_read_nokey_empty",
            "test_from_sparse_dtype_fill_value",
            "time_dropna",
            "test_round_daily",
            "test_setitem_series_float64",
            "test_categorical_margins_category",
            "test_tick_rdiv",
            "ffill",
            "test_msgpack_period_freq",
            "test_subclass_stack_multi_mixed",
            "test_non_datetime_index2",
            "_reset_identity",
            "test_output_significant_digits",
            "test_read_table_index_col",
            "test_parse_date_time",
            "test_setitem_index_bool",
            "_mpl",
            "time_is_dates_only",
            "test_pivot_table_multi",
            "ip",
            "test_reorder_levels",
            "test_bins",
            "test_timegrouper_apply_return_type_series",
            "_grouped_hist",
            "randu_array",
            "test_constructor_categorical",
            "test_consolidate_inplace",
            "test_timtetonum_accepts_unicode",
            "test_timedelta64_operations_with_timedeltas",
            "test_iso_constructor",
            "_check",
            "test_to_html_index",
            "test_dataframe_clip",
            "_set_endianness",
            "test_combine_first_dt64",
            "test_constructor_numpy_scalar",
            "test_scalar_fail",
            "test_second",
            "test_frame_getitem_slice",
            "_check_align",
            "_apply_window",
            "test_rpow_one_to_na",
            "test_index_convert_to_datetime_array_dateutil",
            "test_read_csv_handles_boto_s3_object",
            "test_set_option_uneven_args",
            "test_is_float",
            "_aggregate_named",
            "test_assert_numpy_array_equal_shape_mismatch_override",
            "test_overlaps_endpoint",
            "_arith_method_SPARSE_SERIES",
            "teardown_method",
            "merge_pr",
            "test_as_json_table_type_float_dtypes",
            "test_concat_categorical_coercion_nan",
            "test_write_with_index",
            "periods",
            "time_apply_lambda_mean",
            "_check_holiday_results",
            "makeFloatSeries",
            "test_categorical_concat_dtypes",
            "test_escapable_characters",
            "test_tz_localize_nonexistent",
            "test_construction_from_string",
            "test_median",
            "test_asof",
            "get_duplicates",
            "test_set_value_keeps_names",
            "test_operation_on_NaT",
            "create_single_mgr",
            "test_index_with_nan",
            "test_from_coo_nodense_index",
            "test_iteration_over_chunksize",
            "query",
            "test_mode_dropna",
            "test_bar_align_left_axis_none",
            "test_filter_and_transform_with_multiple_non_unique_int_index",
            "test_write_column_multiindex",
            "test_replace_dst_border",
            "_maybe_eval",
            "test_selection_api_validation",
            "test_reader_seconds",
            "test_resample_reresample",
            "transpose",
            "test_td64arr_sub_td64_array",
            "_left_indexer_unique",
            "test_index_and_on_parameters_confusion",
            "network",
            "test_constructor_timestamp_near_dst",
            "test_unstack_unused_level",
            "test_corr_rank",
            "get_resampler_for_grouping",
            "test_multiindex_assignment",
            "test_finder_annual",
            "test_maybe_convert_numeric_post_floatify_nan",
            "test_reindex_bool",
            "_pickle_roundtrip",
            "test_invalid_numexpr_version",
            "test_previous_workday",
            "read_spss",
            "test_to_csv_float_format",
            "test_annual_upsample",
            "test_interp_ignore_all_good",
            "test_join_index",
            "time_frame_fancy_lookup_all",
            "_get_cell_value",
            "pad_2d",
            "_preprocess_for_cut",
            "test_infer_dtype_misc",
            "test_maxbuffersize",
            "test_left_join_index_multi_match",
            "test_constructor_iso",
            "test_get_dummies_with_name_dummy",
            "should_cache",
            "test_comment_first_line",
            "test_to_records_with_categorical",
            "test_pprint_pathological_object",
            "test_get_schema_dtypes",
            "set_use_bottleneck",
            "test_bad_version",
            "test_infer_dtype_from_python_scalar",
            "state_data",
            "test_simple_records",
            "test_convertable_values",
            "is_floating",
            "test_basic_right_index",
            "test_use_bottleneck",
            "time_datetime_level_values_copy",
            "test_both_style_and_color",
            "test_td_add_td",
            "_shape",
            "test_join_does_not_recur",
            "_convert_string_array",
            "test_drop_by_str_label_raises_missing_keys",
            "test_monotonic",
            "test_metadata_propagation",
            "_from_values_or_dtype",
            "asarray_tuplesafe",
            "float_dtype",
            "test_nanargmax",
            "_parse_td",
            "test_tuple_union_bug",
            "to_csv",
            "test_groupby_empty_list_raises",
            "convert_json_field_to_pandas_type",
            "test_drop_with_ignore_errors",
            "test_capitalize",
            "test_compare_invalid",
            "test_decode_floating_point",
            "test_object_comparisons",
            "test_td64arr_floordiv_tdlike_scalar",
            "test_reindex_axis_style",
            "test_min_max_numeric_only",
            "test_read_write_reread_dta15",
            "test_construction_index_with_mixed_timezones",
            "stop",
            "test_round_mixed_type",
            "parse_args",
            "test_corr_spearman",
            "test_read_csv_memory_growth_chunksize",
            "compare_element",
            "test_is_datetimetz",
            "test_contains",
            "_highlight_handler",
            "test_constructor_with_non_normalized_pytz",
            "engine",
            "mframe",
            "_open_browser",
            "test_df_mod_zero_series_does_not_commute",
            "set_object_info",
            "datetime_index",
            "test_float_array",
            "time_interpolate",
            "pandas_dtype",
            "test_frame_multi_key_function_list",
            "test_annual",
            "test_large_value_conversion",
            "test_pad_stable_sorting",
            "test_hide_columns_mult_levels",
            "test_union_sort_other_special",
            "get_indexer",
            "test_floor",
            "test_from_coo_dense_index",
            "time_align_series_irregular_string",
            "between",
            "test_numarr_with_dtype_add_nan",
            "test_astype_extension_dtypes_1d",
            "test_value_counts_nunique",
            "test_to_csv_unicode_index_col",
            "test_construction_with_ordered",
            "test_engine_type",
            "test_setitem_series_timedelta64",
            "check_error_on_write",
            "validate_endpoints",
            "time_join_dataframe_index_shuffle_key_bigger_sort",
            "test_tdi_isub_timedeltalike",
            "test_nth_nan_in_grouper",
            "test_chunksize_read",
            "test_dti_isub_tdi",
            "test_assignment_column",
            "test_take_fill_with_negative_one",
            "test_to_dense_fill_value",
            "test_constructor_coerce",
            "test_filter_and_transform_with_non_unique_string_index",
            "test_flex_binary_frame",
            "test_to_string_mixed",
            "test_fillna_dtype_conversion",
            "insert_data",
            "get_numeric_mat",
            "time_iso8601_format_no_sep",
            "test_replace_series_period",
            "test_shallow_copy",
            "test_multiple_date_cols_index",
            "test_zero",
            "test_td64_series_astype_object",
            "time_left_outer_join_index",
            "test_hashtable_unique",
            "_arith_method_SPARSE_ARRAY",
            "test_to_csv_compression",
            "write_file",
            "test_series_named_agg",
            "test_transform_broadcast",
            "test_loc_getitem_int_slice",
            "df_levels",
            "test_group_name_available_in_inference_pass",
            "julian_dates",
            "_encode",
            "test_multi_index_no_level_names",
            "test_fill_value_reindex_coerces_float_int",
            "test_signed_zero",
            "test_get_indexer_nearest_listlike_tolerance",
            "_get_reconciled_name_object",
            "is_hashable",
            "test_series_repr",
            "time_reest_datetimeindex",
            "test_info_duplicate_columns_shows_correct_dtypes",
            "test_to_csv_quoting",
            "test_groupby_multi_corner",
            "all_parsers",
            "test_resample_anchored_multiday",
            "_is_potential_multi_index",
            "_maybe_cast_slice_bound",
            "packb",
            "test_fillna_datetime_columns",
            "test_overlapping_names",
            "test_constructor_dict_dont_upcast",
            "time_to_html_mixed",
            "test_month_range_union_tz_dateutil",
            "test_query_index_without_name",
            "get_ftype_counts",
            "duplicated",
            "_check_numeric_ops",
            "test_get_indexer_with_NA_values",
            "test_coerce_list",
            "test_align_frame",
            "time_baseline",
            "_u",
            "test_timestamp_tz_localize",
            "test_numpy_cumsum",
            "assert_series_or_index_equal",
            "test_rolling_skew_edge_cases",
            "test_read_excel_nrows",
            "_import_path",
            "invalid_comparison",
            "_validate_specification",
            "test_yy_format_with_year_first",
            "_test_data1_zero",
            "test_get_indexer_pad",
            "test_astype_timedelta64",
            "left",
            "test_get_level_values_na",
            "test_pivot_string_func_vs_func",
            "test_dti_with_period_data_raises",
            "test_map_callable",
            "test_default_type_conversion",
            "test_matplotlib_formatters",
            "test_remove_na_deprecation",
            "test_rangeindex_fallback_coercion_bug",
            "_three_digit_exp",
            "coerce_to_array",
            "test_validate_indices_high",
            "test_examples2",
            "test_set_name",
            "_alert_malformed",
            "test_level_get_group",
            "_any_none",
            "test_sas_buffer_format",
            "objects_to_datetime64ns",
            "test_set_categories_private",
            "assert_fp_equal",
            "test_to_html_escaped",
            "validate_one",
            "test_get_complex_nested",
            "test_concat_order",
            "test_from_product_empty_one_level",
            "to_json",
            "droplevel",
            "test_take_axis_0",
            "test_multi_index_naming",
            "test_infer_tz_compat",
            "test_float64_ns_rounded",
            "test_cached_properties_not_settable",
            "test_arg_tz_ns_unit",
            "test_to_timedelta",
            "check_round_trip",
            "test_resample_base",
            "_set_levels",
            "test_expanding_cov_pairwise_diff_length",
            "time_apply_pass_thru",
            "astype3",
            "test_tricky_container_to_bytes",
            "test_assert_almost_equal_value_mismatch4",
            "test_categorical_pivot_index_ordering",
            "test_sniff_delimiter_encoding",
            "test_partial_slice",
            "test_utf",
            "test_loc_getitem_duplicates_multiindex_missing_indexers",
            "test_uint64_type_handling",
            "test_numpy_ufuncs",
            "cast_scalar_to_array",
            "test_error_rename",
            "test_file_handles_with_open",
            "raise_or_return",
            "time_frame_nth",
            "test_is_dtype_from_self",
            "test_downsample_across_dst",
            "test_index_col_with_unnamed",
            "test_missing_value_generator",
            "test_upcast_datetime",
            "makeMissingDataframe",
            "blocks",
            "test_constructor_pass_nan_nat",
            "test_constructor_data_aware_dtype_naive",
            "test_preserve_refs",
            "test_cut_corner",
            "test_timedelta64_dtype_array_returned",
            "test_finder_monthly_long",
            "test_intersection_name_preservation",
            "test_infer_dtype_from_timedelta",
            "test_to_timestamp_preserve_name",
            "test_put_integer",
            "_delegate_class",
            "test_multi_line_expression",
            "_clean_na_values",
            "test_ops_series_period",
            "reset_cache",
            "test_get_set_value_no_partial_indexing",
            "maybe_convert_platform",
            "detect_colspecs",
            "test_groupby_non_arithmetic_agg_int_like_precision",
            "test_encode_time_conversion_pytz",
            "test_store_multiindex",
            "test_to_timestamp_quarterly_bug",
            "time_quarter",
            "test_xs_integer_key",
            "test_sparray_inplace",
            "test_agg_must_agg",
            "_check_moment_func",
            "to_array",
            "test_default_delimiter",
            "_fetchall_as_list",
            "test_getitem_int64",
            "clear",
            "test_extended_gcd",
            "time_from_float",
            "time_categorical_level",
            "test_encoding_options",
            "time_sparse_array",
            "test_expanding_quantile",
            "_validate_parse_dates_arg",
            "_save_header",
            "_next_iter_line",
            "test_operators_none_as_na",
            "test_dti_tz_convert_hour_overflow_dst_timestamps",
            "test_loc_getitem_label_array_like",
            "test_enable_data_resource_formatter",
            "time_read_store_table_wide",
            "_drop_labels_or_levels",
            "test_ignore_leading_whitespace",
            "test_pi_add_timedeltalike_minute_gt1",
            "test_tz_convert_roundtrip",
            "id_func",
            "mmap_file",
            "test_replace_dtypes",
            "remove_unused_levels",
            "test_td_rsub_offset",
            "infer_to_same_shape",
            "test_td_rfloordiv_numeric_series",
            "test_dt_accessor_updates_on_inplace",
            "test_applymap_box",
            "section_titles",
            "test_seriesgroupby_observed_true",
            "test_ix_loc_setitem_consistency",
            "test_ns_index",
            "decompress_file",
            "test_integer_with_zeros",
            "check_nancorr_nancov_2d",
            "makeFY5253LastOfMonth",
            "test_date_range_bms_bug",
            "as_array",
            "__str__",
            "test_custom_asserts",
            "test_subclass_iterrows",
            "test_multiby",
            "getPeriodData",
            "test_integer",
            "test_dataframe_dummies_with_categorical",
            "_assert_not_almost_equal_both",
            "test_dropna_series",
            "test_constructor_no_precision_warns",
            "test_to_coo",
            "test_utf16_example",
            "test_constructor_corner_shape",
            "create_pandas_abc_type",
            "test_multiple_date_col_custom",
            "test_concat_NaT_series_dataframe_all_NaT",
            "test_pad_fillchar",
            "_split_line",
            "_read_group",
            "test_datetime_outofbounds_scalar",
            "time_iloc_array",
            "test_cache_updating",
            "c2f",
            "test_non_array_raises",
            "test_maybe_promote_datetimetz_with_datetimetz",
            "test_dt64arr_naive_sub_dt64ndarray",
            "test_bins_unequal_len",
            "_get_space_character_free_column_resolvers",
            "test_StringIO",
            "test_gcs_not_present_exception",
            "test_mixing_naive_tzaware_raises",
            "time_parallel",
            "pandas_type",
            "pprint_thing_encoded",
            "get_atom_coltype",
            "test_chunksize_read_type",
            "test_replace_truthy",
            "test_fillna_index_timedelta64",
            "test_memory_usage_deep",
            "test_pivot_timegrouper",
            "test_clipboard_copy_strings",
            "test_blockplacement_add",
            "test_from_records_duplicates",
            "write_sparse_intindex",
            "__setattr__",
            "test_write_explicit",
            "time_groupby_sort",
            "test_iterrows_corner",
            "test_stringified_slice_with_tz",
            "test_nanosecond_string_parsing",
            "dtype_can_hold_na",
            "_get_result_dim",
            "check_extension",
            "test_offsets_compare_equal",
            "_get_sqlite_column_type",
            "time_rank_int_cat_ordered",
            "test_ix_duplicate_returns_series",
            "test_read_with_where_tz_aware_index",
            "test_numeric_compat2",
            "test_complibs_default_settings",
            "custom_dialect",
            "test_skip_rows_bug",
            "test_endswith",
            "_unstack_frame",
            "find_class",
            "test_asfreq_combined_pi",
            "test_fillna_index_bool",
            "test_update_deprecation",
            "test_get_level_lengths_un_sorted",
            "test_nth_empty",
            "test_roundtrip_pickle",
            "test_series_box_timestamp",
            "test_ngroup_matches_cumcount",
            "test_conv_quarterly",
            "test_generator_warnings",
            "__getslice__",
            "test_ewma_cases",
            "time_isin_long_series_long_values",
            "test_cython_agg_nothing_to_agg",
            "test_donot_overwrite_index_name",
            "_store_test_result",
            "test_consistent_coerce_for_shapes",
            "_isna_old",
            "test_display_format",
            "time_categorical_index_is_monotonic_increasing",
            "_chop",
            "test_crosstab_tuple_name",
            "test_setitem_raises_length",
            "test_freq_validation_with_nat",
            "_eval_single_bin",
            "time_nested_dict_columns",
            "test_round_trip_frame_string",
            "continue_maybe",
            "test_col_substring_of_stubname",
            "test_is_equal_dtype",
            "_get_subheader_index",
            "test_encode_decimal",
            "test_assign_order",
            "test_map_int",
            "test_thorough_mangle_names",
            "test_from_product_empty_zero_levels",
            "test_iterator_stop_on_chunksize",
            "_not_none",
            "_make_labels",
            "strip",
            "time_boolean_array",
            "test_reading_multiple_specific_sheets",
            "time_getitem_slice",
            "test_timeseries_repr_object_dtype",
            "test_hasnans_unchached_for_series",
            "test_list_float",
            "time_timestamp_series_compare",
            "_convert_listlike_indexer",
            "_get_time_stamp",
            "test_multiindex_name",
            "test_reindex_pad",
            "float_frame_fill0",
            "test_binary_ufunc_with_index",
            "is_re_compilable",
            "test_dtypes_are_correct_after_column_slice",
            "assert_offset_equal",
            "_set_dtype",
            "test_combine_le",
            "test_constructor_list_frames",
            "test_deprecated_contains",
            "test_td64arr_mul_td64arr_raises",
            "test_replace_regex_metachar",
            "test_asarray_homogenous",
            "test_array_unboxes",
            "test_1000_sep_with_decimal",
            "test_dti_date_out_of_range",
            "test_slice_non_numeric",
            "test_different_nans",
            "test_df_div_zero_array",
            "test_as_matrix_deprecated",
            "test_contains_top_level",
            "test_loc_getitem_array",
            "test_read_write_reread_dta14",
            "test_pindex_qaccess",
            "test_multiby_heterogeneous_types",
            "test_get_offset",
            "test_setitem_chained_setfault",
            "chck_ncols",
            "set_info",
            "test_transform_coercion",
            "test_copy_method_kwargs",
            "test_AbstractMethodError_classmethod",
            "_has_valid_tuple",
            "test_stack_order_with_unsorted_levels",
            "_reconstruct_data",
            "test_from_to_scipy_object",
            "test_ewmcorr",
            "test_is_string_dtype",
            "test_get_axis",
            "is_lexsorted_for_tuple",
            "test_nonsense_func",
            "test_spline_interpolation",
            "test_Millisecond",
            "check_comprehensiveness",
            "test_set_index_directly",
            "test_from_tuples_empty",
            "test_to_html_notebook_has_style",
            "parse_results",
            "dtype",
            "test_query_multiindex_get_index_resolvers",
            "time_transform_ufunc_max",
            "searchsorted",
            "test_get_indexer_with_int_and_float",
            "test_fillna_consistency",
            "time_frame_nonunique_equal",
            "_int64index",
            "test_readonly_axis_blosc_to_sql",
            "test_pad_backfill_object_segfault",
            "test_getitem_ellipsis",
            "rewrite_axis_style_signature",
            "test_merge",
            "test_replace_datetimetz",
            "supported_extensions",
            "format_array",
            "_flex_binary_moment",
            "test_chained_cmp_and_in",
            "validate_operand",
            "test_invalid_parse_delimited_date",
            "time_scalar_function_single_col",
            "test_intercept_builtin_sum",
            "test_multiindex_index",
            "_restore_dropped_levels_multijoin",
            "test_fillna_series_bool",
            "time_get_dummies",
            "test_int_to_datetime_format_YYYYMMDD_typeerror",
            "test_ewmvar",
            "bool_frame_with_na",
            "makeCustomIndex",
            "test_constructor_range_based_deprecated_different_freq",
            "test_to_csv_doublequote",
            "assert_is_valid_plot_return_object",
            "test_to_latex_with_formatters",
            "str_translate",
            "_executable_exists",
            "test_geopandas",
            "time_count",
            "test_value_counts_dtypes",
            "test_to_string_unicode_two",
            "test_read_excel_skiprows_list",
            "_range2cols",
            "open",
            "test_nanprod",
            "reset",
            "test_td64arr_rfloordiv_tdscalar_explicit",
            "test_getitem_setitem_datetime_tz_pytz",
            "ensure_str",
            "test_constructor_mixed",
            "test_drop_duplicates_NA_for_take_all",
            "test_index_object_dtype",
            "test_encode_big_set",
            "test_loc_setitem_dups",
            "test_pivot_columns_lexsorted",
            "test_na_values_na_filter_override",
            "test_hist_secondary_legend",
            "test_constructor_unsigned_dtype_overflow",
            "test_round_nat",
            "_is_strictly_monotonic_increasing",
            "test_rank_dense_method",
            "_comp_method_SERIES",
            "test_categorical_index_repr_datetime_ordered",
            "test_read_complete",
            "test_kde_colors",
            "test_plot_xy",
            "test_rank_min_pct",
            "axes",
            "test_frame_basic_dtypes",
            "test_timezones_fixed",
            "_get_column_names_and_types",
            "test_timedelta_range",
            "test_tzlocal_maybe_get_tz",
            "_format_body",
            "test_callable_deprecate_kwarg",
            "_wrap_applied_output",
            "test_infer_dtype_from_scalar_errors",
            "test_apply_with_mutated_index",
            "test_get_numeric_data",
            "_adjust_dates_anchored",
            "test_asarray_tz_naive",
            "test_agg",
            "test_setitem_index_complex128",
            "dtypes",
            "test_get_level_lengths",
            "test_ne",
            "nth",
            "test_date_range_fy5252",
            "test_format_pre_1900_dates",
            "corrwith",
            "parse_all_fields",
            "test_str",
            "test_getitem_setitem_integers",
            "_offset",
            "test_union3",
            "test_encode_decode_errors",
            "frame_random_data_integer_multi_index",
            "test_is_sparse",
            "test_is_null_datetimelike",
            "test_asarray_tz_aware",
            "test_timestamp_equality_different_timezones",
            "test_timestamp_to_datetime_explicit_dateutil",
            "test_unstack_odd_failure",
            "test_downcast",
            "test_where_invalid_input",
            "test_pipe",
            "test_drop_by_numeric_label_errors_ignore",
            "_create_from_codes",
            "_bool_agg",
            "is_list_like",
            "test_repr_summary",
            "test_multiple_open_close",
            "test_nat_operations",
            "test_unary_operators",
            "time_large_get_loc",
            "test_tz_convert_single_matches_tz_convert",
            "test_mixed_dtype",
            "_get_compressed_labels",
            "test_allow_exact_matches",
            "test_crosstab_multiple",
            "test_overflow",
            "all",
            "register_dataframe_accessor",
            "build_border",
            "_mpl_repr",
            "full_scope",
            "test_setitem_scalar_key_sequence_raise",
            "test_loc_setitem_datetime",
            "_bank_data",
            "test_custom_var_name",
            "test_fill_value_reindex",
            "test_sort_values_inplace",
            "test_timestamp_tz_localize_nonexistent_raise",
            "test_agg_apply_corner",
            "soft_convert_objects",
            "_any",
            "lookup",
            "test_invalid_dtype",
            "_compute",
            "_check_isinstance",
            "test_categorical_index_repr_datetime",
            "test_construct_from_string_own_name",
            "test_truncate_with_different_dtypes",
            "test_other_timedelta_unit",
            "test_overlaps_interval",
            "test_frame_empty",
            "test_unary_op",
            "test_convert_numeric_int64_uint64",
            "test_file_handle_mmap",
            "test_object_dtype_ok",
            "test_pass_spec_to_storer",
            "test_pi_sub_period",
            "test_index_equal_class_mismatch",
            "test_equal_but_different",
            "test_no_na_filter_on_index",
            "test_pad_require_monotonicity",
            "_shallow_copy_with_infer",
            "test_to_weekly_resampling",
            "test_reindex_columns_method",
            "test_float_trim_zeros",
            "get_value",
            "test_categorical",
            "test_filter_multiple_timestamp",
            "test_calendar_caching",
            "test_to_timestamp_repr_is_code",
            "assert_framelist_equal",
            "_test_all_offsets",
            "test_pi_add_sub_timedeltalike_freq_mismatch_monthly",
            "test_dataframe_compression_defaults_to_infer",
            "test_merge_index_singlekey_right_vs_left",
            "_check_accum_op",
            "is_object",
            "test_chunksize_with_compression",
            "time_is_leap_year",
            "nanany",
            "test_join_float64_float32",
            "time_lambda_sum",
            "test_str_cat_mixed_inputs",
            "test_unsortedindex",
            "test_hist_df_legacy",
            "test_apply_typecast_fail",
            "test_drop_col_still_multiindex",
            "test_sqlalchemy_type_mapping",
            "test_ohlc_5min",
            "time_by_object",
            "get_json_auth",
            "test_to_records_dtype_mi",
            "to_flat_index",
            "test_regex_replace_list_obj",
            "test_quotechar_unicode",
            "set_defaults",
            "test_infer_from_scalar_tz",
            "test_join_on_fails_with_wrong_object_type",
            "test_grouping_grouper",
            "test_bool_ops_warn_on_arithmetic",
            "test_copy_tzaware",
            "test_fillna_categorical",
            "test_encode_as_null",
            "test_factorize_empty",
            "test_rank_object_raises",
            "test_iso_8601_strings_with_same_offset",
            "validate_bool_kwarg",
            "test_bin32",
            "test_casemethods",
            "test_1700",
            "test_loc_slice",
            "_assert_all_na",
            "_internal_get_values",
            "test_infer_freq",
            "test_next_monday",
            "test_concat_tz_series_tzlocal",
            "test_ops_notimplemented",
            "test_array_reshaped",
            "object_dtype",
            "test_zip_error_invalid_zip",
            "test_class_ops_pytz",
            "test_getitem_pydatetime_tz",
            "test_value_counts_nat",
            "test_loc_getitem_bool_diff_len",
            "test_drop_tuple",
            "test_adjoin",
            "test_read_write_dta11",
            "test_take_fill_value_new_raises",
            "maybe_cast_item",
            "timetz",
            "testPackUTF32",
            "trim_join_unit",
            "parse_tables",
            "test_unbox_scalar",
            "test_variable_labels",
            "test_concat_sparse_dense",
            "test_unique_label_indices",
            "time_cat",
            "test_describe_with_tz",
            "test_mask_with_boolean",
            "test_mul_int_array",
            "test_infer_freq_tz_transition",
            "test_range_slice",
            "test_get_loc_na",
            "test_append_with_empty_string",
            "is_period_arraylike",
            "test_transpose_tzaware_2col_mixed_tz",
            "time_write_store_table_mixed",
            "test_rank_2d_tie_methods",
            "test_index_name_retained",
            "test_duplicated_subset",
            "test_subset",
            "test_date_range_timestamp_equiv_explicit_dateutil",
            "test_flex_binary_moment",
            "get_op_result_name",
            "test_repr_categorical_dates_periods",
            "_convert_to_stop",
            "test_callable_deprecate_kwarg_fail",
            "test_loc_getitem_label_out_of_range",
            "__mod__",
            "test_int_int",
            "median",
            "visit_Expr",
            "time_frame_fancy_lookup",
            "test_loc_empty_list_indexer_is_ok",
            "test_get_combined_index",
            "no_capitalization",
            "test_series_count",
            "test_empty_arr",
            "unary_fns_for_ne",
            "test_frame_apply_dont_convert_datetime64",
            "test_creating_and_reading_multiple_sheets",
            "test_weekmask",
            "test_astype_category",
            "_from_datetime64",
            "test_maybe_match_name",
            "test_frame_setitem_ix",
            "_add_unary_ops",
            "unions",
            "source_file_name",
            "time_series_align_left_monotonic",
            "get_console_size",
            "test_inf_upcast",
            "test_assert_extension_array_equal_missing_values",
            "_concat_index_same_dtype",
            "test_groupby_sort_multiindex_series",
            "wrap_results",
            "test_astype_object_with_nat",
            "test_wide_repr",
            "write_array",
            "test_sharey_and_ax",
            "test_timestamp_in_columns",
            "test_iso_constructor_raises",
            "time_frame_float_div",
            "test_single_variable",
            "test_multi_line_expression_not_inplace",
            "__isub__",
            "test_fillna_scalar",
            "__mul__",
            "test_xs_setting_with_copy_error_multiple",
            "test_nanstd_nans",
            "_convert_tolerance",
            "test_sparse_max_row",
            "test_to_latex",
            "_selected_obj",
            "test_preserve_empty_rows",
            "test_categorical_repr_int_with_nan",
            "test_timestamp_constructor_tz_utc",
            "is_unsigned_integer_dtype",
            "test_basic_binop",
            "sparse",
            "test_bool_ops_with_constants",
            "_grouped_plot",
            "test_frame_datetime64_duplicated",
            "test_query_with_nested_strings",
            "test_v12_compat",
            "test_concat_tz_not_aligned",
            "test_resample_single_group",
            "test_constructor_with_existing_categories",
            "test_groupby_extension_transform",
            "test_skip_rows_blank",
            "test_rank_dense_pct",
            "test_binop_other",
            "test_CategoricalAccessor_index_deprecation",
            "test_setitem_raises",
            "_get_listlike_indexer",
            "epoch_1960",
            "time_get_slice",
            "test_categorical_coerces_timedelta",
            "_groupby_and_merge",
            "test_seriesgroupby_observed_false_or_none",
            "applymap",
            "test_validate_any_all_out_keepdims_raises",
            "test_numeric_columns",
            "test_reindex_int",
            "test_qcut_bounds",
            "test_an_exception_in_objecthook1",
            "test_tdi_round",
            "test_deep_skip_rows",
            "get_table",
            "select_dtypes",
            "test_utf8_bom",
            "_construct_axes_dict_from",
            "test_bad_reduce_raises",
            "test_date_query_with_NaT",
            "test_display_format_raises",
            "test_banklist_no_match",
            "_get_wom_rule",
            "test_from_values_or_dtype",
            "test_from_frame_dtype_fidelity",
            "test_rolling_mean",
            "test_symmetric_difference_missing",
            "test_convert_json_field_to_pandas_type",
            "set_categories",
            "test_show_null_counts",
            "test_constructor_iterable",
            "_create_sp_tsseries",
            "time_subtract_10",
            "run_series",
            "test_format_date_axis",
            "test_query_non_str",
            "test_read_write_dta12",
            "test_asfreq_mult_pi",
            "test_td64_df_add_int_frame",
            "time_addition",
            "is_gcs_url",
            "is_platform_mac",
            "test_timestamp_multiindex_indexer",
            "test_get_indexer_length_one_interval",
            "time_qcut_float",
            "_combine_match_columns",
            "test_subplots_timeseries_y_axis_not_supported",
            "_add_delegate_accessors",
            "use_numexpr",
            "test_string_factorize",
            "test_invalid_dtype_error",
            "test_transactions",
            "testSimpleValue",
            "test_series_frame_radd_bug",
            "test_as_array_int_bool",
            "_convert_arr_indexer",
            "time_timeseries_is_month_start",
            "get_default_val",
            "get_callable_name",
            "time_take1d",
            "time_max_trivial",
            "format",
            "test_rowspan_only_rows",
            "test_to_integer_array",
            "test_dti_iadd_int",
            "real",
            "test_datetimeindex_sub_datetimeindex_overflow",
            "test_usecols_dtypes",
            "_maybe_update_cacher",
            "_new_IntervalIndex",
            "test_union_name_preservation",
            "test_preserve_dtypes",
            "test_series_constructor_with_copy",
            "test_large_mi_dataframe_indexing",
            "test_frame_to_json_float_precision",
            "test_replace_simple_nested_dict_with_nonexistent_value",
            "test_scalar",
            "_repr_html_",
            "get_loc",
            "test_to_latex_multiindex_dupe_level",
            "test_url",
            "is_one_of_factory",
            "get_group_index",
            "test_ufunc_compat",
            "test_size_compat",
            "test_equals_op_mismatched_multiindex_raises",
            "_arith_method_SERIES",
            "test_dont_modify_colors",
            "test_astype_datetime64tz",
            "test_reset_index_datetime",
            "test_ndarray_compat_properties",
            "test_groupby_extension_agg",
            "test_fallback_singular",
            "values_cols",
            "test_parse_public_s3_bucket_chunked",
            "test_take_series",
            "validate_window_func",
            "test_catch_infinite_loop",
            "_getitem_tuple",
            "test_rcParams_bar_colors",
            "is_valid",
            "test_take_misc",
            "time_cut_timedelta",
            "extractall",
            "test_string_slice",
            "_set_ticklabels",
            "test_frame_describe_unstacked_format",
            "test_add_timestamp_raises",
            "shape",
            "test_encode_control_escaping",
            "test_td_add_mixed_timedeltalike_object_dtype_array",
            "test_special_holidays",
            "test_is_categorical",
            "test_dataframe",
            "test_name_repr",
            "test_get_loc_duplicates",
            "test_to_csv_string_array_ascii",
            "test_merge_on_extension_array_duplicates",
            "_convert_for_reindex",
            "_print_cline",
            "test_concat_numerical_names",
            "test_tseries_indices_series",
            "test_addsub_arithmetic",
            "test_read_json_large_numbers",
            "test_insert_index_complex128",
            "test_merge_index_types",
            "_guess_datetime_format_for_array",
            "test_high_freq",
            "test_to_period_monthish",
            "test_constructor_from_items_scalars",
            "test_read_jsonl",
            "_left_join_on_index",
            "test_date_like_qcut_bins",
            "partition",
            "test_api_compat",
            "test_tdi_shift_hours",
            "test_grouped_hist_layout",
            "test_all_any",
            "test_setitem_tuple_index",
            "test_drop_duplicates_for_take_all",
            "test_unexpected_keyword",
            "test_drop_non_empty_list",
            "test_boxplot_axis_limits",
            "test_weekly_infer",
            "_check_basic_constructor",
            "_compare",
            "__getstate__",
            "test_monthly_ambiguous",
            "bool",
            "_get_next_label",
            "test_int_index",
            "_invalid_indexer",
            "test_read_csv_low_memory_no_rows_with_index",
            "test_numpy_argsort",
            "tostring",
            "test_period_deprecated_freq",
            "test_set_frame_expand_extension_with_regular",
            "test_now",
            "homogenize",
            "test_sub_dti_dti",
            "test_basic_left_index_right_index",
            "assert_stat_op_calc",
            "test_concat_rename_index",
            "test_align_mixed_type",
            "test_groupby_apply_return_empty_chunk",
            "_get_all_tables",
            "test_read_csv_utf_aliases",
            "time_multiby",
            "_validate_freeze_panes",
            "test_logical_ops_invalid",
            "time_is_year_start",
            "obj_fixture",
            "_can_fast_union",
            "_get_lines",
            "time_dup_string_dates_and_format",
            "maybe_unwrap_index",
            "inferred_freq",
            "test_map_defaultdict",
            "test_clip_against_frame",
            "_get_credentials",
            "test_drop_by_numeric_label_loc",
            "get_unit_generic",
            "test_cut_out_of_range_more",
            "test_modulo",
            "test_groupby_as_index_agg",
            "sanitize_array",
            "test_constructor_empty",
            "_close",
            "test_take_non_na_fill_value",
            "test_query_lex_compare_strings",
            "test_wrong_number_names",
            "testDecodeBinary",
            "test_binary_ops_docs",
            "test_astype_to_timedelta_unit_ns",
            "test_expanding_corr_pairwise",
            "time_frame_fillna",
            "test_set_option_empty_args",
            "test_internal_null_byte",
            "test_to_timedelta_float",
            "test_really_large_in_arr",
            "pp_options_list",
            "sem",
            "test_datetime_bool",
            "test_default_encoding",
            "test_max_min_range",
            "time_write_excel",
            "test_getitem_dataframe",
            "test_agg_with_datetime_index_list_agg_func",
            "test_slice_keep_name",
            "test_pow_ops_object",
            "_get_data_label",
            "_window_type",
            "test_today",
            "test_frame_mi_access_returns_series",
            "test_info_memory_usage_deep_not_pypy",
            "test_comment_header",
            "test_custom_lineterminator",
            "test_datetime_index",
            "test_mask",
            "_values_for_rank",
            "test_hist_layout_with_by",
            "test_to_html_decimal",
            "test_to_string_specified_header",
            "test_to_string_float_formatting",
            "test_where_with_numeric_data_and_other",
            "test_where_axis",
            "test_transform_and_agg_err",
            "test_to_timestamp_pi_combined",
            "_is_aligned",
            "test_subtype_float",
            "_count_rows",
            "test_boxplot_subplots_return_type",
            "make_mixed_dataframe_v2",
            "test_sum",
            "test_hexbin_with_c",
            "rfloordiv",
            "test_rolling_quantile",
            "check_level_names",
            "test_query_single_element_booleans",
            "_make_engine",
            "test_dt64arr_add_sub_relativedelta_offsets",
            "time_existing_categorical",
            "test_separator_date_conflict",
            "test_setitem_expand_with_extension",
            "test_zero_variables",
            "put",
            "time_isin",
            "test_mod_zero",
            "test_reindex_cast",
            "test_na_handling",
            "slice_locs",
            "test_setitem_dtype",
            "test_dropna_dt_like",
            "test_bool_ops_column_name_dtype",
            "groupby_apply_op",
            "test_to_datetime_fixed_offset",
            "test_dateindex_conversion",
            "_align_core_single_unary_op",
            "test_unique_level",
            "time_pivot_table",
            "test_to_csv_cols_reordering",
            "test_scalar_bool",
            "_is_datetime",
            "_stack_arrays",
            "test_divmod_ndarray",
            "test_ptp",
            "test_deprecate_keyword",
            "test_to_string_with_datetime64_hourformatter",
            "test_xs_values",
            "test_inconsistent_number_of_rows",
            "test_str8",
            "info",
            "test_join_multiindex",
            "cat",
            "make_array",
            "test_encode_num_conversion",
            "_add_redirects",
            "cumprod",
            "test_str_label_slicing_with_negative_step",
            "time_merge_object",
            "equalContents",
            "test_where_raises",
            "test_minmax_nat_datetime64",
            "test_roll_qtr_day_not_mod_unequal",
            "test_dti_tz_convert_hour_overflow_dst",
            "test_internal_eof_byte_to_file",
            "test_mixed_freq_irreg_period",
            "test_array_object_dtype",
            "_constructor_expanddim",
            "_align_series",
            "test_fillna_datetime",
            "test_resample_single_period_timedelta",
            "test_pandas_errors",
            "is_timedelta64_ns_dtype",
            "is_boolean",
            "test_concat_sparse_dense_rows",
            "test_infer_datetimelike_array_timedelta",
            "test_irreg_dtypes",
            "_attributes",
            "test_date_tz",
            "test_dti_business_summary_pytz",
            "do_setup",
            "dispatch_to_index_op",
            "time_crosstab_normalize",
            "_valid_sp_values",
            "slabels",
            "test_to_datetime_default",
            "test_parsers_timestring",
            "_convert_to_alignment",
            "test_sort_index_na_position_with_categories",
            "test_to_datetime_cache_series",
            "test_pivot_no_level_overlap",
            "test_dti_custom_business_summary",
            "test_slice_locs_not_contained",
            "multi_index3",
            "time_ix_array",
            "_get_stacking_id",
            "time_frame_ix",
            "test_is_period",
            "no_type",
            "time_weekday_name",
            "test_select_iterator",
            "test_from_custom_template",
            "test_add_extension_scalar",
            "test_pickle_freq",
            "test_getitem_mask",
            "test_unpack_bytearray",
            "test_css_to_excel",
            "_bn_ok_dtype",
            "as_sparse_array",
            "import_module",
            "test_unimplemented_dtypes_table_columns",
            "test_loc_scalar",
            "time_dt_accessor_date",
            "test_last_week_of_month_on_offset",
            "test_apply_box",
            "test_to_datetime_different_offsets",
            "test_timedelta64",
            "test_basic_setitem_with_labels",
            "test_logical_ops_bool_frame",
            "skip_ods_files",
            "test_integer_thousands_alt",
            "test_invert",
            "test_header_not_enough_lines",
            "compress",
            "test_timestamp_utc_true",
            "_read_subheader_signature",
            "test_convert_dates_infer",
            "test_get_reverse_indexer",
            "cartesian_product",
            "test_repr_array",
            "test_reindex_api_equivalence",
            "test_read_excel_blank",
            "test_to_latex_empty",
            "test_timedelta",
            "test_numeric_embedded_arr_likes",
            "test_cumcount_empty",
            "test_mean_corner",
            "test_drop_duplicates_tuple",
            "test_where_index_datetime",
            "test_construct_from_string_raises",
            "test_try_parse_dates",
            "test_EA_types",
            "_concat_indexes",
            "_reindex_output",
            "test_join_left",
            "test_exceptions",
            "fnx",
            "test_mean_datetimelike_numeric_only_false",
            "test_categorical_writing",
            "test_self_join_multiple_categories",
            "test_ops_series_timedelta",
            "reset_display_options",
            "test_4d_ndarray_fails",
            "test_infer_compression",
            "test_qcut_binning_issues",
            "test_dti_add_tick_tzaware",
            "test_rowwise_alt",
            "test_rank_tie_methods",
            "complex_dtype",
            "assert_categorical_equal",
            "test_pivot_table_with_margins_set_margin_name",
            "test_construction_with_conversions",
            "test_iter_raises",
            "test_length",
            "_parse_subtype",
            "test_i8",
            "_reset_cacher",
            "slice_indexer",
            "test_crosstab_ndarray",
            "test_constructor_cast",
            "test_array_from_scalars",
            "test_get_day_of_month_error",
            "test_line_colors_and_styles_subplots",
            "_check_implicitly_registered",
            "test_apply_empty",
            "test_frame_mi_access",
            "test_read_json_table_dtype_raises",
            "_do_convert_categoricals",
            "test_pivot_preserve_dtypes",
            "test_unpack_array_header_from_file",
            "_get_stacked_values",
            "test_align",
            "test_ops_nat_mixed_datetime64_timedelta64",
            "test_concat_keys_specific_levels",
            "test_to_period_millisecond",
            "test_computer_sales_page",
            "test_concat_datetime_datetime64_frame",
            "time_apply",
            "_convert_index_indexer",
            "time_same_offset",
            "test_pi_sub_isub_timedeltalike_daily",
            "_concat_datetimetz",
            "test_setitem_with_tz_dst",
            "test_dt64_series_add_mixed_tick_DateOffset",
            "test_join_multi_multi",
            "test_infer_tz_mismatch",
            "test_bar_edge",
            "_concat_objects",
            "test_scipy_compat",
            "concatenate_block_managers",
            "test_index_false_to_json_split",
            "test_sort_index_categorical_index",
            "is_type_compatible",
            "test_drop_duplicates_series_vs_dataframe",
            "test_append_with_timedelta",
            "__setitem__",
            "test_hist_bins_legacy",
            "test_quantile_nan",
            "test_dropna_empty",
            "test_arith_flex_frame_corner",
            "test_complex_sorting",
            "test_evaluate_with_empty_groups",
            "test_groupby_agg_observed_true_single_column",
            "test_setitem_dtypes",
            "test_to_datetime_dtarr",
            "test_missing_args_or_kwargs",
            "test_sub_offset_nat",
            "test_setitem_cast",
            "get_slice_bound",
            "_is_cached",
            "test_mismatching_tz_raises_err",
            "test_delete_base",
            "test_coercion_with_loc",
            "test_to_csv_deprecation",
            "test_set_value_with_index_dtype_change",
            "test_take_sequence",
            "test_from_arrays_empty",
            "_format_col",
            "test_mixed_arithmetic_frame",
            "assert_attr_equal",
            "test_bounds_with_different_units",
            "test_fillna_invalid_method",
            "test_join_on_inner",
            "_get_xticks",
            "test_multiple_date_col_multiple_index_compat",
            "_execute_insert_multi",
            "_try_cast",
            "test_minmax_period",
            "_add_comparison_ops",
            "test_dst",
            "_get_with",
            "test_secondary_legend",
            "infer_dtype_from_object",
            "size_to_pt",
            "test_xy_args_integer",
            "get_commit_vitals",
            "time_read_hdf",
            "test_tdi_mul_int_array",
            "test_kde_missing_vals",
            "column_types",
            "test_parse_header_of_non_string_column",
            "test_replace_string_with_number",
            "test_repr_dimensions",
            "test_repr_no_backslash",
            "test_period_set_index_reindex",
            "test_read_sql_delegate",
            "values",
            "test_to_series_with_arguments",
            "_all_none",
            "test_resample_group_info",
            "test_to_xarray",
            "test_read_excel_nrows_non_integer_parameter",
            "test_series_equal_categorical_mismatch",
            "test_crosstab_margins_set_margin_name",
            "test_loc_preserve_names",
            "test_setitem_iloc_scalar_mixed",
            "test_consistency_for_boxed",
            "add_imports",
            "test_pop_non_unique_cols",
            "test_read_sql_view",
            "test_corrwith_index_union",
            "_stack_multi_columns",
            "test_from_scipy_fillna",
            "test_type_check",
            "test_freq",
            "test_round_trip",
            "test_df_flex_cmp_constant_return_types_empty",
            "test_plot_submethod_works",
            "makeMultiIndex",
            "test_sparse_series_round_trip2",
            "test_to_latex_no_bold_rows",
            "test_astype_copies",
            "test_slice_keeps_name",
            "_read_sql_iris_parameter",
            "test_dt64arr_sub_timestamp",
            "test_constructor_from_string",
            "area",
            "compare_operators_no_eq_ne",
            "test_constructor_list_of_derived_dicts",
            "safe_close",
            "nselect_method",
            "test_days_neg",
            "__new__",
            "test_intersection",
            "test_setitem_boolean",
            "test_series_getitem_multiindex",
            "box_with_array",
            "test_multiindex_set_index",
            "visit_Num",
            "legacy_pickle",
            "test_modulo2",
            "expanding",
            "test_subplots",
            "test_getitem_label_list_with_missing",
            "test_cdaterange_weekmask",
            "time_property",
            "time_transform_multi_key1",
            "_is_indexed_like",
            "test_series_box_timedelta",
            "_cast_types",
            "unused_import",
            "test_observed_codes_remap",
            "build_extension",
            "test_getitem_bool_index_single",
            "test_all_custom_freq",
            "last",
            "test_aggregate_normal",
            "sheet_names",
            "test_is_numeric_array",
            "_hasnans",
            "test_2d_bool",
            "test_na_values_with_dtype_str_and_na_filter",
            "_value_formatter",
            "test_where_numeric_with_string",
            "test_index_namedtuple",
            "test_week_of_month_fake",
            "test_long",
            "test_infer_datetimelike_array_date",
            "test_nanvar",
            "test_series_not_equal_value_mismatch",
            "test_isinf_scalar",
            "time_query_store_table_wide",
            "test_line_area_nan_series",
            "test_raise_with_traceback",
            "test_slice_locs_na",
            "test_astype_dict_like",
            "test_datetime64_tz_dropna",
            "test_hash_pandas_empty_object",
            "test_timestamp_constructed_by_date_and_tz",
            "_transform_fast",
            "_convert_range",
            "df_strings",
            "test_td64arr_add_int_series_invalid",
            "datapath",
            "set_data",
            "test_pivot_with_list_like_values",
            "test_take_fill",
            "check_keys_split",
            "test_usecols_relative_to_names",
            "test_constructor_maskedarray_nonfloat",
            "test_set_index_append",
            "test_apply_to_timedelta",
            "_skip_if_no_private_key_path",
            "_get_tz",
            "test_categorical_repr_ordered",
            "test_assign_columns",
            "first_line_ends_in_dot",
            "test_small_strings_no_warn_zlib",
            "test_deprecated_fastpath",
            "get_series",
            "convert_value",
            "assert_bool_op_api",
            "_reverse_indexer",
            "_check_expanding",
            "time_qcut_int",
            "test_value_labels_iterator",
            "test_na_roundtrip",
            "test_frame_ctor_datetime64_column",
            "_test_data1",
            "test_value_counts_uint64",
            "test_decode_jibberish",
            "test_union_same_types",
            "test_dt64arr_add_mixed_offset_array",
            "test_difference_freq",
            "test_datetime_nan_error",
            "test_length_zero_copy",
            "test_result_types2",
            "mixed_type_frame",
            "_getitem_multilevel",
            "_get_label_or_level_values",
            "test_infer_dtype_from_float_scalar",
            "__array_ufunc__",
            "do_vcs_install",
            "test_value_counts_unique_nunique",
            "test_loc_listlike_dtypes",
            "test_excessively_long_string",
            "apply",
            "time_write_store_table_dc",
            "time_frame_plot",
            "isna",
            "validate_metadata",
            "_wrap_output",
            "test_shift_int",
            "cummax",
            "_expand_user",
            "test_to_latex_filename",
            "test_qcut_index",
            "test_tab_completion_with_categorical",
            "test_assert_extension_array_equal_not_exact",
            "to_gbq",
            "read_fwf",
            "test_str_cat_wrong_dtype_raises",
            "test_boolean_context_compat2",
            "test_dti_tz_localize_tzlocal",
            "test_df_gridspec_patterns",
            "test_rolling_corr",
            "test_read_chunks_columns",
            "test_apply_nanoseconds",
            "test_concat_datetimeindex_freq",
            "test_series_pad_backfill_limit",
            "test_constructor_invalid",
            "get_filepath_or_buffer",
            "test_read_xlrd_book",
            "testMap",
            "test_stat_operators_attempt_obj_array",
            "test_index_col_named",
            "test_from_inferred_categories_coerces",
            "time_from_string",
            "test_categorical_dtype_single",
            "test_concat_empty_dataframe_dtypes",
            "test_constructor_list_of_dicts",
            "test_setitem_with_different_tz",
            "test_read_only_header_no_rows",
            "test_all_nan",
            "_reindex_axes",
            "test_fill_consistency",
            "test_default_index",
            "test_idxmax",
            "_minmax_wrap",
            "_permute",
            "test_as_array_float",
            "test_replace_moar",
            "testFixArray",
            "mix_ab",
            "_delta_to_tick",
            "_check_join",
            "time_set_index",
            "test_timestamp_tz_localize_nonexistent_NaT",
            "test_to_html_with_no_bold",
            "test_concat_multiindex_with_tz",
            "_ensure_term",
            "test_ngroup",
            "compare_sp_frame_float",
            "test_constructor_invalid_quarters",
            "test_arith_frame_with_scalar",
            "test_indexing_assignment_dict_already_exists",
            "test_td64arr_rfloordiv_tdscalar",
            "test_can_serialize_dates",
            "test_prod",
            "test_resample_empty_dtypes",
            "test_non_cython_api",
            "test_constructor_fromordinal",
            "test_isin",
            "test_tdi_mul_int_series",
            "testIgnoreErrorsPack",
            "test_to_sql_replace",
            "test_concat_timedelta64_block",
            "test_sub_character",
            "test_columns_dtypes_invalid",
            "test_to_html_invalid_justify",
            "test_update_dtype_raises",
            "test_resample_anchored_intraday",
            "test_rolling_max",
            "test_append_to_multiple_dropna",
            "test_concat_keys_levels_no_overlap",
            "test_indexing_over_size_cutoff",
            "test_insert_index",
            "test_has_duplicates_from_tuples",
            "test_setitem_index_datetime64tz",
            "_scalar_data_error",
            "test_concat_period_series",
            "scipy_sem",
            "test_weird_nested_json",
            "test_comparisons_coverage",
            "test_cross_engine_fp_pa",
            "test_bar_linewidth",
            "test_groupby_first_datetime64",
            "test_datetimeindex_constructor_misc",
            "test_cmov_window_special_linear_range",
            "parsed_114",
            "test_indexing_mixed_frame_bug",
            "testNoEncoding",
            "_maybe_downcast",
            "test_tick_add_sub",
            "test_td_add_pytimedelta",
            "boolean_parameter",
            "_cleanup",
            "test_constructor_sparse_dtype_str",
            "swapkey",
            "mixed_int",
            "_check_binary_ew",
            "test_indexing_dtypes_on_empty",
            "_justify",
            "test_categorical_dtype_coerces_boolean",
            "str_rsplit",
            "test_dt64arr_add_sub_td64_nat",
            "test_isin_cats",
            "test_css_parse_invalid",
            "time_pivot_table_agg",
            "_reset_group_selection",
            "test_td64arr_div_int",
            "to_dict",
            "datetime_frame",
            "test_empty_dtype",
            "test_constructor_int_dtype_float",
            "test_is_homogeneous_type",
            "test_setitem_different_tz_raises",
            "test_timedelta64_operations_with_DateOffset",
            "test_factorize_tuple_list",
            "test_pi_add_iadd_timedeltalike_M",
            "maybe_list_like",
            "test_to_datetime_today",
            "test_to_series",
            "as_unordered",
            "test_inferred_dtype_fixture",
            "test_invalid_date_kwarg_with_string_input",
            "yields",
            "time_tz_localize",
            "test_shift_dtype_fill_value",
            "time_apply_axis_1",
            "test_excel_roundtrip_indexname",
            "test_api_compat_before_use",
            "test_rank",
            "test_from_weekly_resampling",
            "test_arith_non_pandas_object",
            "test_combine_generic",
            "test_dti_cmp_object_dtype",
            "scalar_td",
            "test_filter_bad_shapes",
            "time_from_str",
            "_handle_shared_axes",
            "test_to_timedelta_via_apply",
            "test_infer_datetimelike_array_datetime",
            "test_to_records_index_name",
            "deprecate_kwarg",
            "prune",
            "test_concat_multiindex_with_keys",
            "test_float_same_index_comparison",
            "func",
            "test_setattr_warnings",
            "_daily_finder",
            "test_compression_size_fh",
            "_get_time_delta_bins",
            "_group_selection_context",
            "shift",
            "is_period_dtype",
            "test_string",
            "as_json_table_type",
            "prep_ndarray",
            "test_replace_series_datetime_tz",
            "_freeze",
            "_node_not_implemented",
            "column_data_offsets",
            "test_period_cons_weekly",
            "_get_formatted_values",
            "test_pandas_array",
            "_get_plot_backend",
            "is_sequence",
            "test_bar_align_zero_axis_none",
            "test_op_corners",
            "_check_mixed_float",
            "interval",
            "test_series_group_min_max",
            "test_numeric",
            "test_setitem_raises_type",
            "_maybe_mask_results",
            "_astype",
            "_trim_zeros_complex",
            "test_asfreq_corner",
            "test_append_concat",
            "test_float_index_to_mixed",
            "_info_repr",
            "test_cython_agg_empty_buckets",
            "test_constructor_column_duplicates",
            "test_constructor_timedelta_window_and_minperiods",
            "resolve",
            "test_constructor_tz_mixed_data",
            "_get_ind",
            "_get_center_of_mass",
            "test_concat_datetime64_block",
            "test_select_dtypes_str_raises",
            "test_isna_for_inf",
            "test_mixed_freq_hf_first",
            "test_iloc_non_unique_indexing",
            "test_insert",
            "test_cython_fail_agg",
            "test_unique_index",
            "_engine_type",
            "test_to_csv_stringio",
            "test_set_index_verify_integrity",
            "test_map_identity_mapping",
            "agg_series",
            "test_constructor_fromarraylike",
            "get_version",
            "test_boxplot",
            "rands",
            "test_registry_find",
            "test_to_latex_multicolumnrow",
            "test_merge_datetime64tz_with_dst_transition",
            "rollback",
            "compare_all",
            "test_reset_index_multiindex_nan",
            "test_numpy_array_equal_copy_flag",
            "insert",
            "_validate_color_args",
            "test_constructor_errors",
            "test_get_indexer_numeric_index_boolean_target",
            "test_is_dict_like_fails",
            "test_ignore_error",
            "replace_list",
            "test_publishes",
            "test_map_empty",
            "test_categorical_coerces_numeric",
            "test_sparse_series_fillna_limit",
            "_is_nested_tuple_indexer",
            "test_list_grouper_with_nat",
            "left_df",
            "test_symmetric_difference_non_index",
            "time_by_int",
            "_dtype_to_stata_type_117",
            "test_replace_bool_with_string",
            "test_numpy_argmin_deprecated",
            "test_groupby_nonobject_dtype",
            "test_droplevel_list",
            "test_slice_replace",
            "time_modulo",
            "test_read_csv_parse_simple_list",
            "test_subdays_neg",
            "test_repr_truncates_terminal_size_full",
            "test_is_monotonic_decreasing",
            "test_agg_compat",
            "test_legacy_table_fixed_format_read_py2",
            "test_deprecate_option",
            "test_td_sub_offset",
            "test_convert_non_hashable",
            "test_setitem_mixed_datetime",
            "test_rolling_kurt_edge_cases",
            "test_reconstruct_remove_unused",
            "time_frame_mult",
            "render_pep440",
            "test_publishes_not_implemented",
            "test_setitem_series_complex128",
            "validate_expanding_func",
            "test_read_from_http_url",
            "test_set_index_dst",
            "unknown_section",
            "test_skiprows_inference",
            "_make_min_count_stat_function",
            "test_getitem_setitem_ix_negative_integers",
            "test_read_csv_unicode",
            "test_constructor_empty_boolean",
            "test_fillna_copy_series",
            "time_delta_int_tstamp_lines",
            "test_min_periods",
            "test_join_many",
            "test_fillna_dict_series",
            "test_take_out_of_bounds_raises",
            "test_read_chunksize_and_nrows_changing_size",
            "time_iso8601_tz_spaceformat",
            "test_dti_constructor_numpy_timeunits",
            "test_astype_to_datetime_unit",
            "test_raise_on_info",
            "test_factorize_tz",
            "_update_map",
            "test_datetime_date",
            "construct_1d_object_array_from_listlike",
            "test_filter_dropna_with_empty_groups",
            "test_union_bug_1730",
            "test_stack_sparse_frame",
            "test_verbose_read2",
            "test_append_some_nans",
            "test_no_mutable_funcs",
            "fill_value",
            "test_modf",
            "test_str_accessor_updates_on_inplace",
            "test_loc_getitem_label_slice",
            "test_to_csv_from_csv3",
            "multiindex_dataframe_random_data",
            "_combine_const",
            "test_resample_upsampling_picked_but_not_correct",
            "test_encode_datetime_conversion",
            "test_drop_duplicates_with_duplicate_column_names",
            "test_td_construction_with_np_dtypes",
            "test_constructor_errors_tz",
            "test_to_datetime_utc_true_with_series_datetime_ns",
            "test_inf_roundtrip",
            "time_different_python_functions_singlecol",
            "test_prevent_casting",
            "test_period_ordinal_start_values",
            "test_lookup_raises",
            "no_punctuation",
            "test_repr_utcoffset",
            "__exit__",
            "_from_arrays",
            "test_getitem_setitem_non_ix_labels",
            "test_regex_replace_numeric_to_object_conversion",
            "validate_data_columns",
            "time_float_32",
            "test_loc_label_slicing",
            "test_repeat_range",
            "test_dti_repr_short",
            "time_clip",
            "bytes_dtype",
            "test_binary_arith_ops",
            "current_packers_data",
            "test_dateoffset_misc",
            "test_join_many_mixed",
            "df_whitelist_fixture",
            "test_class_ops_dateutil",
            "time_check_datetimes",
            "test_compound_deprecated",
            "test_pi_add_offset_array",
            "skip_if_no_pandas_parser",
            "_is_homogeneous_type",
            "test_to_timedelta_on_missing_values",
            "test_bs4_version_fails",
            "mem_itertuples_start",
            "test_maybe_booleans_to_slice",
            "time_add_overflow_both_arg_nan",
            "test_operators",
            "test_series_append_dst",
            "test_td_rfloordiv_offsets",
            "test_group_shift_with_null_key",
            "test_repr_nat",
            "test_invalid_separator",
            "test_fromDict",
            "test_read_from_pathlib_path",
            "test_stat_op_api",
            "test_resample_basic_grouper",
            "_pat_wrapper",
            "_get_binner",
            "test_rank_methods_frame",
            "test_timestamp_compare_scalars",
            "is_nested_object",
            "test_view_asi8",
            "time_isin_long_series_long_values_floats",
            "test_random_state",
            "test_groupby_as_index_series_scalar",
            "test_str_bool_return",
            "ensure_int_or_float",
            "test_groupby_mixed_type_columns",
            "test_date_parser_int_bug",
            "time_without_last_row",
            "test_rolling_apply_mutability",
            "_simple_new",
            "test_resolution_deprecated",
            "get_block_type",
            "testMapSize",
            "_drop_axis",
            "time_parse_dateutil",
            "_helper_hypothesis_delimited_date",
            "time_get_loc",
            "test_dti_tz_localize",
            "test_with_listlike_columns",
            "next",
            "_trim_front",
            "test_where_subset",
            "test_rename_categories_dict",
            "_iter_data",
            "setup_class",
            "_join_level",
            "time_frame_from_ndarray",
            "test_monthly_resample_error",
            "test_decompression_regex_sep",
            "test_resample_nunique_with_date_gap",
            "__xor__",
            "test_index_ctor_infer_nan_nat",
            "test_loc_getitem_int_raises_exception",
            "test_compare_timedelta64_zerodim",
            "test_index_str_accessor_visibility",
            "read_index_legacy",
            "test_agg_api",
            "test_slice_with_negative_step",
            "test_is_period_arraylike",
            "test_datetime_categorical_comparison",
            "to_coo",
            "_get_simple_index",
            "test_any_none",
            "_is_empty_row",
            "is_extension_type",
            "test_as_json_table_type_timedelta_dtypes",
            "test_period",
            "test_business_freq",
            "test_excelfile_fspath",
            "base_delta_code_pair",
            "test_irregular_datetime",
            "make_axis_dummies",
            "_make_timestamp",
            "_check_for_bom",
            "test_spam_header",
            "test_write_fspath_hdf5",
            "test_series_append_aware",
            "_validate_where",
            "test_read_nrows",
            "test_constructor_dtype_only",
            "test_read_one_empty_col_no_header",
            "test_replace_bool_with_string_no_op",
            "str_strip",
            "makeIntIndex",
            "series_of_dtype2",
            "test__is_dtype_type_sparse",
            "test_xs_level_multiple",
            "test_parse_dates_empty_string",
            "_op_tests",
            "test_merge_suffix_error",
            "combine",
            "_process_single_doc",
            "test_singleton_header",
            "time_delta_int_tstamp",
            "test_get_loc_datetimelike_overlapping",
            "day_name",
            "test_round_invalid",
            "test_type_coercion_valid",
            "test_tz_convert_single_matches_tz_convert_hourly",
            "test_string_na_nat_conversion",
            "test_parse_public_s3_bucket",
            "_post_plot_logic",
            "test_to_html_timestamp",
            "test_mutability",
            "test_loc_incremental_setitem_with_dst",
            "test_long_series",
            "test_to_csv_numpy_16_bug",
            "test_get_level_values",
            "_maybe_evaluate_binop",
            "tables",
            "assert_labels_dropped",
            "test_read_table_equivalency_to_read_csv",
            "test_readjson_chunks_series",
            "__call__",
            "test_consolidate_datetime64",
            "test_to_hdf_with_min_itemsize",
            "_validate_for_numeric_unaryop",
            "to_numeric",
            "test_any_all_np_func",
            "test_dictify",
            "test_groupby_monotonic",
            "test_monotone_DTI_indexing_bug",
            "test_to_datetime_cache",
            "test_with_local_timezone_pytz",
            "get_storer",
            "_index_factory",
            "time_dtindex_from_series",
            "test_csv_mixed_type",
            "test_cant_compare_tz_naive_w_aware",
            "test_empty_decimal_marker",
            "test_s3_roundtrip",
            "test_select_dtypes_exclude_using_list_like",
            "test_nanvar_nans",
            "is_uniform_join_units",
            "three_days",
            "test_append_records",
            "test_replace_bool_with_bool",
            "_update_strl_names",
            "test_arithmetic_with_frame_or_series",
            "test_xs_with_duplicates",
            "infer_dtype_from",
            "test_hash_tuple",
            "test_constructor_complex_dtypes",
            "test_datapath_missing",
            "test_mutated",
            "test_closed_one_entry",
            "_tidy_repr",
            "test_stack_unstack_multiple",
            "_make_na_block",
            "test_bad_resolver_raises",
            "_get_frame_result_type",
            "test_assert_raises_regex_deprecated",
            "test_negone_ordinals",
            "_bool_and_frame",
            "test_ragged_quantile",
            "test_reindex_with_datetimes",
            "test_view",
            "test_range_in_series_indexing",
            "test_melt_missing_columns_raises",
            "_update_stacker",
            "test_replace_inplace",
            "test_to_csv_index_no_leading_comma",
            "is_freq_type",
            "test_columns_with_dups",
            "test_apply_index_implementations",
            "test_to_latex_bold_rows",
            "show_col_idx_names",
            "test_mixed_ops",
            "makeFY5253NearestEndMonthQuarter",
            "test_value_counts_datetime_tz",
            "test_datetimeindex_accessors",
            "_set_no_thousands_columns",
            "test_na_values_scalar",
            "test_invalid_plot_data",
            "test_contains_not_nans",
            "test_partial_setting_with_datetimelike_dtype",
            "test_iloc_returns_series",
            "_convert_data",
            "_asof_key",
            "test_nonexistent_path",
            "test_dialect_str",
            "test_nat_representations",
            "test_all_any_params",
            "str_pad",
            "test_groupby_datetime64_32_bit",
            "test_astype_to_same",
            "any_extension_types",
            "test_categorical_index_repr_ordered",
            "test_apply_raw",
            "test_loc_multiindex_too_many_dims_raises",
            "compare_series_cat",
            "test_boxplot_legacy1",
            "test_slice_locs_with_ints_and_floats_errors",
            "test_default_col_names",
            "test_slice_quarter",
            "test_multiindex_header_index",
            "test_bool_na_values",
            "test_utf16_bom_skiprows",
            "test_mul",
            "test_apply_mixed_datetimelike",
            "test_multiindex_contains_dropped",
            "test_nanmax",
            "test_set_levels_codes_directly",
            "_convert_bin_to_numeric_type",
            "test_mixed",
            "test_loc_getitem_label_list_fails",
            "_f3",
            "format_type",
            "test_datetimeindex_union_join_empty",
            "str_extractall",
            "test_is_array_like",
            "time_corrwith_rows",
            "frame_of_index_cols",
            "test_resample_not_monotonic",
            "_complib",
            "test_dt_conversion_preserves_name",
            "test_is_timedelta64_dtype",
            "test_processing_order",
            "makeIntervalIndex",
            "test_1d_bool",
            "tzframe",
            "test_slice_year",
            "test_freq_validation",
            "test_is_monotonic_incomparable",
            "test_corr_int",
            "time_period_to_datetime",
            "test_center_ljust_rjust_fillchar",
            "_get_seek_variable_labels",
            "test_read_empty_dta",
            "test_fails_and",
            "test_east_asian_len",
            "test_operators_datetimelike",
            "test_fillna_dataframe",
            "test_to_excel_multiindex_no_write_index",
            "test_period_from_ordinal",
            "is_uniform_reindex",
            "_factorize_keys",
            "_set_group_selection",
            "test_to_sparse_preserve_multiindex_names_columns",
            "test_nonunique_assignment_1750",
            "check_compressed_urls",
            "use_numexpr_cb",
            "test_invalid_complib",
            "test_concatlike_common_period_diff_freq_to_object",
            "is_re",
            "test_constructor_invalid_items_unused",
            "test_constructor_list_of_lists",
            "test_filter_out_no_groups",
            "test_store_index_name",
            "test_pct_change",
            "test_render_double",
            "test_all_not_none",
            "test_on_offset_implementations",
            "test_dt64_series_astype_object",
            "test_add_column_with_pandas_array",
            "test_compare_frame",
            "_validate_usecols_names",
            "test_expanding_corr_diff_index",
            "test_assert_almost_equal_iterables",
            "test_td64arr_rmod_tdscalar",
            "_test_data2",
            "test_applymap_subset_multiindex",
            "test_overflow_offset",
            "test_union_different_types",
            "test_parse_dates_combine",
            "skew",
            "test_xs_partial",
            "aggregate",
            "test_get_value_duplicates",
            "test_get_indexer_strings_raises",
            "test_multiple_date_col_timestamp_parse",
            "test_positional_take_unobserved",
            "test_write_row_by_row",
            "__get__",
            "maybe_convert_ix",
            "test_concat_tz_NaT",
            "test_convert_non_ns",
            "test_unpacker_hook_refcnt",
            "test_list_slice",
            "test_read_nrows_bad",
            "test_constructor_index_dtype",
            "register_plotting_backend_cb",
            "test_nat_iso_format",
            "test_compare_ticks_to_strs",
            "_init_matrix",
            "test_stringify_path_localpath",
            "no_description_period_with_directives",
            "test_time_accessor",
            "test_where_inplace",
            "idxmax",
            "__add__",
            "test_read_py2_hdf_file_in_py3",
            "density",
            "test2",
            "test_asfreq_resample_set_correct_freq",
            "test_dense_to_sparse",
            "test_nan_handling",
            "test_dataframe_dummies_drop_first_with_categorical",
            "test_names",
            "test_td_floordiv_null_scalar",
            "test_construction_caching",
            "curpath",
            "test_rolling_median",
            "_fast_count_smallints",
            "test_slice_len",
            "test_label_precision",
            "test_getitem_fill_value",
            "test_is_names_tuple_passes",
            "test_resample_tz_localized",
            "test_setting_with_copy_bug",
            "time_sparse_series_from_coo",
            "test_to_datetime_tz_pytz",
            "test_parse_nanoseconds_with_formula",
            "test_encode_dict_with_unicode_keys",
            "test_repr_column_name_unicode_truncation_bug",
            "test_sort",
            "is_int64_overflow_possible",
            "test_get_loc_cast_bool",
            "time_apply_index",
            "_join_i8_wrapper",
            "test_union_bug_4564",
            "bar",
            "test_categorical_repr_datetime_ordered",
            "test_to_datetime_infer_datetime_format_inconsistent_format",
            "test_ix_setitem_out_of_bounds_axis_1",
            "test_apply_dict_depr",
            "test_stack",
            "_mklbl",
            "time_replace_tz",
            "test_apply_multiindex_fail",
            "test_misc_example",
            "test_constructor_Series_differently_indexed",
            "apply_series_generator",
            "test_td_floordiv_numeric_series",
            "test_call",
            "test_groupby_transform",
            "_convert_list_indexer",
            "test_ops",
            "test_parsers",
            "time_read_sql_query_select_column",
            "test_array_ufunc_series_scalar_other",
            "_series_name",
            "_is_dtype_type",
            "_align_method_SERIES",
            "test_arg_for_errors_in_astype_dictlist",
            "test_constructor_set",
            "categorical",
            "test_rank_zero_div",
            "test_buffer_overflow",
            "test_invalid_variable_labels",
            "is_sparse",
            "test_integer_values_and_tz_deprecated",
            "test_reindex_empty_series_tz_dtype",
            "test_sort_index_and_reconstruction_doc_example",
            "test_stringify_path_fspath",
            "hash_pandas_object",
            "doc_parameters",
            "is_scipy_sparse",
            "xs",
            "test_parr_add_sub_datetime_scalar",
            "test_ix_categorical_index",
            "_rollback_to_year",
            "test_constructor_for_list_with_dtypes",
            "test_ndarray_inplace",
            "test_constructor_int_dtype_nan_raises",
            "test_unique_na",
            "test_nan_multiple_containment",
            "csv1",
            "test_NanosecondGeneric",
            "test_set_index_drop_inplace",
            "test_constructor_strptime",
            "test_line_plot_inferred_freq",
            "test_reduce_series",
            "test_to_coo_text_names_text_row_levels_nosort",
            "test_2d_float32",
            "_sort_levels_monotonic",
            "test_any_all",
            "test_interp_limit",
            "test_mixed_freq_irregular_first",
            "_hash_categorical",
            "test_max_fitting_element",
            "test_iloc_getitem_doc_issue",
            "test_drop_duplicates_inplace",
            "get_new_index",
            "test_append_mixed_dtypes",
            "test_unicode_repr_doesnt_raise",
            "test_nsmallest_nlargest",
            "create",
            "test_cut_pass_labels_compat",
            "nrows_expected",
            "test_gaps",
            "fail",
            "test_duplicate_groupby_issues",
            "test_interp_rowwise",
            "time_melt_dataframe",
            "test_multiindex_columns_empty_level",
            "test_grouper_index_level_as_string",
            "test_between_time",
            "df_letters",
            "test_constructor_range_based_deprecated",
            "test_execute_closed_connection",
            "test_series_append_aware_naive",
            "test_slicing",
            "test_duplicated",
            "test_delim_whitespace_custom_terminator",
            "data_for_sorting",
            "test_indexing_with_category",
            "test_float_index_non_scalar_assignment",
            "test_where_series_period",
            "test_datetime_name_accessors",
            "test_to_html_invalid_classes_type",
            "maybe_convert_indices",
            "test_read_hdf_errors",
            "test_cut_pass_labels",
            "assert_produces_warning",
            "test_tick_addition",
            "test_agg_transform",
            "test_to_string_utf8_columns",
            "test_to_sql_method_multi",
            "ensure_index",
            "test_invalid_quantile_value",
            "test_duplicated_columns",
            "test_examples1",
            "test_dti_timestamp_freq_fields",
            "test_grouped_box_return_type",
            "test_constructor_non_hashable_name",
            "_get_cells",
            "plot",
            "skip_if_no",
            "test_invalid_filtering",
            "test_categorical_equal",
            "test_constructor_spindex_dtype_scalar_broadcasts",
            "test_groupby_level_with_nas",
            "_index_name",
            "test_resample_with_timedeltas",
            "test_infer_dtype_bytes",
            "test_datetime_bin",
            "time_series_constructor",
            "test_strip_lstrip_rstrip_mixed",
            "rdivmod",
            "test_reindex_preserve_levels",
            "test_get_finder",
            "test_set_dtype_new_categories",
            "test_is_re_fails",
            "test_disallowed_nodes",
            "test_astype_with_view_mixed_float",
            "test_slice_locs_with_type_mismatch",
            "test_anchored_shortcuts",
            "imag",
            "test_reader_closes_file",
            "test_mixed_freq_shared_ax",
            "test_to_datetime_format_YYYYMMDD",
            "_check_results_to_coo",
            "test_parsers_quarterly_with_freq",
            "determine_clipboard",
            "test_isin_empty",
            "test_set_reset_index",
            "test_date_range_unsigned_overflow_handling",
            "_binify",
            "test_dti_shift_across_dst",
            "test_neg_numeric",
            "test_to_period",
            "test_timedeltas",
            "test_clip_types_and_nulls",
            "test_map_box",
            "randbool",
            "test_doc_example",
            "test_not_slice_like_slices",
            "align",
            "test_constructor_U",
            "test_usecols_with_single_byte_unicode_strings",
            "test_is_unique_interval",
            "test_loc_setitem_empty_append_raises",
            "test_safe_import_versions",
            "test_nanops",
            "test_maybe_promote_bool_with_any",
            "test_timestamp_to_datetime_explicit_pytz",
            "interpolate",
            "count_not_none",
            "test_is_period_dtype",
            "test_does_not_convert_mixed_integer",
            "_convert_to_list_like",
            "time_existing_series",
            "test_getitem_fancy_2d",
            "_view_wrapper",
            "test_pi_ops",
            "test_iloc_getitem_bool",
            "time_datetimes",
            "test_too_long",
            "test_read_with_start",
            "test_select_dtypes_include_exclude_mixed_scalars_lists",
            "time_frame_from_lists",
            "test_linspace_behavior",
            "validate_args_and_kwargs",
            "_process_rowsize_subheader",
            "invalidate_string_dtypes",
            "test_df_arith_2d_array_collike_broadcasts",
            "test_trailing_spaces",
            "test_setitem_fancy_boolean",
            "test_to_excel_interval_no_labels",
            "test_colspecs",
            "catch_to_csv_depr",
            "setup_connect",
            "test_rule_from_name",
            "time_is_quarter_end",
            "test_with_string_args",
            "test_shift_periods",
            "test_timetz_accessor",
            "property",
            "test_basic_regression",
            "test_encode_content_write_to_file",
            "test_is_overlapping",
            "test_series_ctor_datetime64",
            "test_type_promote_putmask",
            "test_ndarray_values",
            "_generate_multi_thread_dataframe",
            "test_reindex_fill_value",
            "test_is_strictly_monotonic_decreasing",
            "test_bar_subplots_center",
            "test_string_select",
            "test_wrap_aggregated_output_multindex",
            "test_from_records_dictlike",
            "_transform_item_by_item",
            "test_wom_len",
            "_format_axes",
            "test_constructor_maskedarray",
            "test_query_numexpr",
            "test_usecols_pass_non_existent_column",
            "time_floats_with_dt_index_lines",
            "test_reindex_indexer",
            "read_clipboard",
            "test_any_all_bool_only",
            "makeTimeDataFrame",
            "test_frame_from_json_precise_float",
            "_fletcher32",
            "test_constructor_positional",
            "test_concat_empty_and_non_empty_frame_regression",
            "test_schema",
            "list_incorrect_parameter_type",
            "center",
            "test_regex_replace_list_mixed",
            "test_to_datetime_format_microsecond",
            "test_getitem_dups_with_missing",
            "check_whitelist",
            "test_astype_with_view_float",
            "_get_registered_option",
            "test_compare_different_lengths",
            "test_groupby_sort_multi",
            "test_construction_consistency",
            "test_constructor_with_categorical_categories",
            "test_delta_to_tick",
            "test_iadd_preserves_name",
            "equals",
            "test_from_frame",
            "test_legacy_datetimetz_object",
            "no_change",
            "test_is_recompilable_passes",
            "test_cumcount_dupe_index",
            "test_to_timestamp_to_period_astype",
            "test_parsers_timezone_minute_offsets_roundtrip",
            "test_complibs",
            "test_apply_ignore_failures",
            "test_to_excel_interval_labels",
            "rename",
            "test_all2",
            "_convert_scalar_indexer",
            "test_constructor_range",
            "test_large_series",
            "test_deprecated_start_stop_step_attrs",
            "test_disable_bool_parsing",
            "test_shift_nan",
            "test_unstack_number_of_levels_larger_than_int32",
            "test_dti_business_summary_dateutil",
            "test_read_s3_jsonl",
            "_read_new_header",
            "time_html_repr_trunc_mi",
            "test_isin_nan_common_float64",
            "test_fixraw",
            "_on",
            "test_time_series_plot_color_kwargs",
            "_replacer",
            "test_get_level_number_out_of_bounds",
            "time_is_year_end",
            "test_ndframe_indexing_raises",
            "test_no_exit_status_noerrors_for_validate_all",
            "test_non_coerce_uint64_conflict",
            "is_file_like",
            "nseries",
            "test_convert_rows_list_to_csv_str",
            "test_invalid_arguments",
            "test_groupby_groups_datetimeindex",
            "test_multiple_matches",
            "test_setitem_list_of_tuples",
            "test_east_asian_unicode_true",
            "test_subtraction_ops",
            "test_repr_max_seq_item_setting",
            "_generate_range_overflow_safe",
            "test_to_excel_float_format",
            "test_concat_date_col_fail",
            "time_frame_float_div_by_zero",
            "test_int_conversion",
            "test_applymap_box_timestamps",
            "test_float_scalar_comparison",
            "test_nth_multi_index",
            "test_combineFrame",
            "test_reindex_axis",
            "test_multilevel_preserve_name",
            "quantile",
            "time_read_json",
            "_process_converter",
            "is_complex_dtype",
            "test_empty_csv_input",
            "test_groupby_multiple_columns",
            "test_get_duplicates",
            "test_empty_window_median_quantile",
            "time_align",
            "time_dup_seconds_and_unit",
            "rdiv",
            "test_fails_not",
            "test_to_dict_box_scalars",
            "test_to_excel_styleconverter",
            "test_union_sorted",
            "time_series_string",
            "test_datetimeindex",
            "test_custom_grouper",
            "test_sniff_delimiter",
            "test_is_lexsorted",
            "test_insert_index_datetimes",
            "test_categorical_series_repr_period",
            "_enable_data_resource_formatter",
            "test_reduce_invalid",
            "test_nunique_preserves_column_level_names",
            "test_rolling_apply_with_pandas_objects",
            "time_categorical_index_is_monotonic_decreasing",
            "test_from_tzaware_mixed_object_array",
            "test_setitem_fancy_1d",
            "infer_dtype_from_scalar",
            "test_constructor_dtype_list_data",
            "test_float_arithemtic_frame",
            "test_replace_invalid_kwarg",
            "_join_by_hand",
            "test_labels_deprecated",
            "test_conversion_float",
            "ensure_safe_environment_variables",
            "test_axis",
            "test_list_like_indexing",
            "test_sheets",
            "test_raises_empty_input",
            "_cast_sparse_series_op",
            "test_group_ohlc",
            "test_constructor_explicit",
            "test_datetime64_fillna",
            "test_not_subperiod",
            "test_constructor_with_stringoffset",
            "_searchsorted_monotonic",
            "test_dt64arr_series_sub_tick_DateOffset",
            "get_writer",
            "test",
            "test_unsupported_type",
            "_check_label_or_level_ambiguity",
            "time_convert",
            "test_td_sub_td",
            "_iterate_column_groupbys",
            "test_outside_int64_uint64_range",
            "_read_next_page",
            "test_allow_cmap",
            "test_multiindex_perf_warn",
            "time_parse_now",
            "test_construction_from_string_error_subtype",
            "test_functions_no_warnings",
            "test_infer_dtype_from_array",
            "test_parsers_iso8601_invalid",
            "test_take_preserve_name",
            "test_numpy_minmax_period",
            "test_business_freq_convert",
            "test_no_unnamed_index",
            "test_properties_annually",
            "test_rename_axis_style",
            "value",
            "test_multiple_id_columns",
            "time_upper",
            "test_nearest_workday",
            "needs_summary",
            "test_join_non_unique",
            "holds_integer",
            "test_combine_first_int",
            "test_hist_df",
            "test_more_than_one_ref",
            "time_merge_dataframe_integer_key",
            "test_get_loc_missing_nan",
            "compare",
            "_tables",
            "_nan_idxs",
            "test_getitem_multi_tuple",
            "test_displayed_only",
            "str_decode",
            "test_from_codes_with_float",
            "time_datetime_field_normalize",
            "test_3d_with_out",
            "test_rank_inf",
            "test_groupby_transform_timezone_column",
            "test_ragged_min",
            "test_nonzero_single_element",
            "test_dt64arr_series_add_tick_DateOffset",
            "test_cmov_mean",
            "test_mismatched_timezone_raises",
            "_get_offset",
            "time_get_dummies_1d",
            "test_apply_dup_names_multi_agg",
            "test_join_multi_levels",
            "time_getitem_list",
            "_map",
            "time_from_ints_daily",
            "_get_values",
            "test_write_preserves_original",
            "test_from_dti",
            "test_update_dtype_errors",
            "test_period_cons_nat",
            "test_unsorted_index_lims",
            "test_index_groupby",
            "test_big_dates",
            "test_apply_trivial",
            "test_dataframe_dummies_prefix_sep",
            "test_is_level_reference_df_ambig",
            "test_read_hdf_open_store",
            "test_equals_op",
            "test_numeric_df_columns",
            "test_from_pi",
            "test_resample_ambiguous_time_bin_edge",
            "test_timezone_info",
            "test_to_html_render_links",
            "_new_DatetimeIndex",
            "test_dateutil_tzoffset_support",
            "test_get_duplicates_deprecated",
            "clean_checkout",
            "test_is_datetime_dtypes",
            "test_add_invalid",
            "test_crosstab_pass_values",
            "test_timedelta_other_units",
            "time_map",
            "_repr_footer",
            "items",
            "test_reindex_base",
            "test_init_series",
            "test_append_length0_frame",
            "test_n_all_dtypes",
            "test_lookup_overflow",
            "test_set_labels_deprecated",
            "test_query_by_select_obj",
            "test_compress",
            "test_manualreset",
            "test_to_html_alignment_with_truncation",
            "test_bytes_exceed_2gb",
            "infer_axes",
            "get_pull_requests",
            "build_number_format",
            "test_wide_repr_named",
            "test_iloc_getitem_labels",
            "test_encode_double_conversion",
            "test_string_filename",
            "test_sparse_series_ops_fill",
            "test_take_axis_1",
            "test_single_element_ix_dont_upcast",
            "test_tuple_vars_fail_with_multiindex",
            "test_iloc_empty_list_indexer_is_ok",
            "na_value",
            "test_setitem_series_period",
            "_set_grouper",
            "test_remove_categories",
            "test_business_daily_look_alike",
            "_assemble_from_unit_mappings",
            "test_to_csv_with_dst_transitions",
            "test_array_header",
            "test_converters_no_implicit_conv",
            "test_resample_basic_from_daily",
            "test_pandas_gbq",
            "test_hist_kde_color",
            "time_add_overflow_scalar",
            "test_between_time_axis_raises",
            "test_constructor_spindex_dtype_scalar",
            "_create_missing_idx",
            "test_contains_with_float_index",
            "test_unstack_fill_frame_timedelta",
            "set_properties",
            "_value_counts_arraylike",
            "test_td64arr_div_nat_invalid",
            "time_multiindex_from_iterables",
            "_set_axis_name",
            "min",
            "test_is_not_integer_dtype",
            "test_valid_file_buffer_seems_invalid",
            "test_loc_getitem_not_monotonic",
            "qcut",
            "_flex_comp_method_FRAME",
            "test_values_consolidate",
            "time_parse_iso8601_tz",
            "test_tz_localize_ambiguous_bool",
            "test_equals_missing_values",
            "test_asfreq_mult",
            "test_multiple_date_col",
            "time_intersect",
            "test_extractall_single_group",
            "test_set_closed_errors",
            "test_decimals",
            "_getbool_axis",
            "test_nat_comparison_tzawareness",
            "get_base_missing_value",
            "test_downsample_but_actually_upsampling",
            "walk",
            "test_construction_from_period",
            "_load_test3_data",
            "test_infer_compression_from_path",
            "test_unknown_attribute",
            "test_empty_with_index",
            "test_series_groupby_plotting_nominally_works",
            "test_doc_string",
            "_maybe_process_deprecations",
            "test_plot_single_color",
            "test_from_array_keeps_base",
            "test_frame_add_tz_mismatch_converts_to_utc",
            "validate_cum_func_with_skipna",
            "test_double_quote",
            "_sub_period",
            "test_encode_unicode_4bytes_utf8",
            "test_xs_setting_with_copy_error",
            "test_date_parsing_ignores_format_details",
            "test_frame_to_period",
            "test_rolling_count",
            "_to_ordinalf",
            "test_asi8",
            "time_frame_comparison",
            "assert_matching",
            "test_dti_ne_null_scalar",
            "mid",
            "test_compression_warns_when_decompress_caches_blosc",
            "time_from_components",
            "test_tab_completion",
            "test_constructor_with_nas",
            "test_binary_functions",
            "test_n_identical_values",
            "test_pivot_string_as_func",
            "is_object_dtype",
            "_set_noconvert_columns",
            "test_from_arrays_different_lengths",
            "test_reader_dtype_str",
            "equal_levels",
            "_adjust_binner_for_upsample",
            "test_usecols_with_unicode_strings",
            "test_to_csv_chunking",
            "test_is_gcs_url",
            "test_build_series",
            "_write_body",
            "test_roll_yearday",
            "test_append_join_nondatetimeindex",
            "_ensure_frozen",
            "test_concat_exclude_none",
            "tips_df",
            "test_numpy_informed",
            "test_agg_dict_nested_renaming_depr",
            "test_tz_range_is_utc",
            "test_obj_none_preservation",
            "_delegate_method",
            "test_arithmetic_conversion",
            "test_constructor_cast_failure",
            "test_banklist_header",
            "test_qcut_return_intervals",
            "test_transform",
            "test_dt64arr_add_sub_period_scalar",
            "test_frame_select_complex",
            "time_monotonic_inc",
            "_rolling_consistency_cases",
            "test_unit_parser",
            "_skip_if_has_locale",
            "test_reduce_to_float",
            "test_asfreq_datetimeindex_empty_series",
            "length",
            "cbday_roll",
            "test_replace_preserves_nanos",
            "test_to_html_regression_GH6098",
            "test_string_indexing",
            "time_query_with_boolean_selection",
            "test_last_subset",
            "uint64_frame",
            "parse_date_fields",
            "test_julian_round_trip",
            "time_nested_dict_index",
            "test_append_multiple",
            "test_rolling_skew",
            "test_constructor_lists_to_object_dtype",
            "test_smaller_Raises_Type",
            "test_dt_accessor_no_new_attributes",
            "test_loc_non_unique",
            "testRollback1",
            "time_is_unique",
            "_isna_compat",
            "test_floor_and_ceil_functions_raise_error",
            "test_strl_latin1",
            "test_total_seconds_scalar",
            "test_union_noncomparable",
            "test_numpy_timedelta_scalar_indexing",
            "test_qcut_nat",
            "test_decode_broken_json",
            "test_dt64arr_sub_NaT",
            "test_unnamed_columns",
            "test_dt64_overflow_masking",
            "length_of_indexer",
            "test_pickle_unpickle",
            "test_datetimes",
            "_save_chunk",
            "any_skipna_inferred_dtype",
            "time_append_range_list",
            "test_is_",
            "test_dti_cmp_null_scalar_inequality",
            "test_resample_median_bug_1688",
            "time_series_dates",
            "_bool_arith_check",
            "mgr_locs",
            "highlight_min",
            "test_str_split",
            "test_interp_limit_no_nans",
            "test_cython_agg_frame_columns",
            "test_from_spmatrix_columns",
            "_assure_grouper",
            "compute_expected",
            "test_all_none_exception",
            "test_dt64ser_cmp_date_invalid",
            "value_counts",
            "test_groupby_with_dst_time_change",
            "test_str_list_query_method",
            "test_loc_to_fail",
            "test_rolling_std_1obs",
            "box",
            "test_lhs_expression_subscript",
            "test_insert_missing",
            "test_tzlocal_offset",
            "test_constructor_copy",
            "time_series_timestamp_compare",
            "test_loc_getitem_label_list_with_missing",
            "test_fillna_copy_frame",
            "test_read_dta1",
            "any_numpy_dtype_reduced",
            "test_mixed_index_assignment",
            "test_nan_data_with_int_dtype_raises_error",
            "test_partial_slice_second_precision",
            "test_mixed_underscores_and_spaces",
            "is_bool_indexer",
            "test_pairwise_with_other",
            "test_scientific_no_exponent",
            "test_read_dta4",
            "test_validate_inplace",
            "time_average_old",
            "test_series_period_index",
            "test_ext",
            "test_replace_with_dict_with_bool_keys",
            "na_cmp",
            "test_constructor_Series_named",
            "test_setitem_scalars_no_index",
            "test_replace_mixed",
            "test_bunched_yearends",
            "_left_indexer",
            "test_values_multiindex_periodindex",
            "test_mixin",
            "test_astype_all",
            "test_unsupported_datetype",
            "test_sparse_pow_issue",
            "test_expanding_corr_pairwise_diff_length",
            "_join_non_unique",
            "test_select_dtypes_empty",
            "test_sort_index_multiindex",
            "test_sem",
            "test_fontsize",
            "test_maybe_mangle_lambdas_listlike",
            "test_loc_datetime_length_one",
            "arrays_for_binary_ufunc",
            "get_splitter",
            "internal_values",
            "test_take_mixed_numeric",
            "test_ngroup_respects_groupby_order",
            "test_period_index_indexer",
            "test_npdiff",
            "test_remove_unused_nan",
            "test_to_latex_escape_special_chars",
            "test_no_mutate_but_looks_like",
            "write_legacy_file",
            "test_dti_union_mixed",
            "from_breaks",
            "test_margins_no_values_no_cols",
            "test_add_categories",
            "test_round_trip_preserve_multiindex_names",
            "test_dti_to_period",
            "test_empty_multi",
            "test_comparison_of_ordered_categorical_with_nan_to_scalar",
            "test_extension_array_cross_section",
            "_dtype_to_default_stata_fmt",
            "_parse_tables",
            "test_constructor_from_categorical_string",
            "_check_double_roundtrip",
            "test_series_nested",
            "test_roll_date_object",
            "test_objarr_radd_str_invalid",
            "update",
            "test_delitem_multiindex",
            "test_mixed_freq_regular_first",
            "tz",
            "test_ensure_int32",
            "time_lib_fast_zip",
            "test_ffill_mixed_dtypes_without_missing_data",
            "test_left_merge_empty_dataframe",
            "time_multi_columns",
            "test_frame_on",
            "test_count_level_series",
            "_get_variable_labels",
            "test_downcast_limits",
            "create_pickle_data",
            "test_to_string_with_col_space",
            "test_to_period_tz",
            "time_write_pickle",
            "__fspath__",
            "make_sparse",
            "test_take_fill_value_none_raises",
            "test_read_nokey",
            "test_concatlike_datetimetz",
            "test_detect_chained_assignment_warnings",
            "test_mixed_freq_lf_first",
            "test_agg_multiple_mixed_no_warning",
            "test_multifunc_select_col_integer_cols",
            "test_abs",
            "test_series_from_coo",
            "test_div_zero_inf_signs",
            "test_describe_categorical_columns",
            "test_map_tseries_indices_accsr_return_index",
            "mentioned_private_classes",
            "test_agg_dict_renaming_deprecation",
            "test_pivot_dtaccessor",
            "test_weekend_to_monday",
            "units_from_epochs",
            "bootstrap_plot",
            "test_over_specified",
            "test_groupby_boxplot_sharex",
            "test_array_repr_unicode",
            "test_tz",
            "readline",
            "test_date_range_linspacing_tz",
            "test_to_csv_quote_none",
            "test_astype_str_cast",
            "test_nange",
            "test_unstack",
            "test_null_byte_char",
            "visit_UnaryOp",
            "_get_na_rep",
            "test_regex_replace_scalar",
            "test_dup_datetime_index_plot",
            "test_resample_how_ohlc",
            "test_set_nan",
            "test_setitem_sequence_mismatched_length_raises",
            "test_dt64_series_add_intlike",
            "test_schema_support",
            "test_cmov_window_regular_linear_range",
            "test_to_csv_write_to_open_file_with_newline_py3",
            "_get_label",
            "test_deprecated_to_sparse",
            "check_binop",
            "test_setops_preserve_freq",
            "test_td64arr_floordiv_int",
            "test_stable_descending_sort",
            "testSignedInt",
            "test_string_datetime_like_compat",
            "test_dti_tz_convert_trans_pos_plus_1__bug",
            "test_dataframe_numpy_labelled",
            "test_index_equal_values_less_close",
            "_get_comb_axis",
            "test_series_repr_nat",
            "test_rolling_cov",
            "test_on",
            "platform_name",
            "validate_axis_style_args",
            "_compare_other",
            "int_frame_const_col",
            "test_mixed_float_int",
            "is_in_table",
            "__rmod__",
            "test_sort_index_intervalindex",
            "test_to_datetime_array_of_dt64s",
            "test_fillna_tzaware",
            "test_rank_mixed_frame",
            "test_weekmask_and_holidays",
            "_create_storer",
            "test_incorrect_dtype_raises",
            "test_groupby_boxplot_sharey",
            "_handle_usecols",
            "backfill_2d",
            "is_datetime",
            "assert_bool_op_calc",
            "test_where_dt_tz_values",
            "test_trim",
            "_get_index_columns",
            "_timezone",
            "test_center_ljust_rjust",
            "test_reset_index_tz",
            "test_frame_pad_backfill_limit",
            "test_categorical_aggfunc",
            "test_corrwith_mixed_dtypes",
            "test_get_period_field_array_raises_on_out_of_range",
            "test_qcut_nas",
            "test_cummin_cummax",
            "test_dti_cmp_list",
            "test_dti_union_aware",
            "test_df_div_zero_df",
            "test_get_indexer_closed",
            "test_partial_set_empty_frame_row",
            "test_standard_colors_all",
            "assert_is_sorted",
            "_is_convertible_to_index",
            "_null_fill_value",
            "_zsqrt",
            "_check_expression",
            "test_ufuncs_single_int",
            "test_inplace_no_assignment",
            "test_drop_empty_list",
            "time_lookup_and_cleanup",
            "test_constructor_invalid_tz",
            "test_repeat_preserves_tz",
            "test_slice_integer_frame_getitem",
            "_conv",
            "test_nlargest",
            "test_tdi_sub_int",
            "test_subclass_stack_multi",
            "test_multiindex",
            "_ensure_encoding",
            "lreshape",
            "test_constructor_ndarray_like",
            "tests_datetimeindex_freq_issue",
            "test_same_nan_is_in",
            "test_is_integer_dtype",
            "test_dtype_all_columns_empty",
            "test_chained_getitem_with_lists",
            "test_missing_minp_zero_variable",
            "test_comment_used",
            "test_raises_for_invalid_module_name",
            "_validate_dtype",
            "test_warning_case_insensitive_table_name",
            "test_ngroup_one_group",
            "test_isin_nan_common_object",
            "ensure_clean_store",
            "build_extensions",
            "test_interp_limit_area",
            "get_group",
            "time_itertuples_to_list",
            "test_memory_leak",
            "_null_terminate",
            "test_nonetype_top_level_bottom_level",
            "test_iadd_string",
            "test_bad_quoting",
            "register_series_accessor",
            "test_drop_duplicates_NA",
            "test_to_json",
            "check_round_trip_frame",
            "test_resample_loffset_upsample",
            "test_nans_equal",
            "month_name",
            "test_ragged_std",
            "test_path_localpath",
            "test_tolerance_forward",
            "test_iloc_setitem_list",
            "test_duplicated_with_nas",
            "test_max_multi_index_display",
            "time_insert",
            "test_datetime_with_timezone",
            "test_set_dtype_many",
            "test_groupby_agg_coercing_bools",
            "test_000constructor_resolution",
            "_get_index_name",
            "_new_PeriodIndex",
            "is_array_like",
            "test_python_docs_table",
            "_to_dict_of_blocks",
            "test_on_specialized_type_by_int",
            "test_setitem_cache_updating",
            "series",
            "test_from_records_to_records",
            "test_pivot_complex_aggfunc",
            "test_categorical_dtype_unsorted",
            "test_where_series",
            "test_reindex_no_type_preserve_target_empty_mi",
            "test_hashable",
            "test_bootstrap_plot",
            "_generate_marginal_results",
            "test_set_index_after_mutation",
            "test_shift_always_copy",
            "test_quoting_various",
            "test_to_csv_string_array_utf8",
            "validate_take_with_convert",
            "test_numeric_dtype",
            "test_zero_step_raises",
            "_get_project_id",
            "test_categories_none_comparisons",
            "test_comparison_of_ordered_categorical_with_nan_to_listlike",
            "test_insert_index_int64",
            "test_pivot_with_non_observable_dropna",
            "test_tz_localize_errors_ambiguous",
            "test_unicode_repr_issues",
            "test_usecols_implicit_index_col",
            "large_val",
            "test_binary_operators",
            "makePeriodSeries",
            "test_float_arithmetic_series",
            "test_int64_add_overflow",
            "test_list_float_complex",
            "_register_accessor",
            "test_is_datetime64_any_dtype",
            "test_concat_series_axis1",
            "test_assert_almost_equal_value_mismatch",
            "_add_margins",
            "test_constructor_sparse_dtype",
            "test_assert_numpy_array_equal_class_mismatch",
            "test_api_default_format",
            "test_set_fill_invalid_non_scalar",
            "_check_freq",
            "test_level_setting_resets_attributes",
            "_is_type",
            "format_dateaxis",
            "test_pi_sub_offset_array",
            "test_replace_dict_no_regex",
            "test_resample_loffset_count",
            "test_comparison_flex_basic",
            "test_indexing_unordered",
            "hash_tuples",
            "test_more_deeply_nested",
            "_maybe_dedup_names",
            "test_infer_freq_tz_transition_custom",
            "test_int64_factorize",
            "on_cols_multi",
            "time_all",
            "_get_converter",
            "test_get_none",
            "test_df_mod_zero_df",
            "test_concat_same_type",
            "setup_data",
            "test_mixed_offsets_with_native_datetime_raises",
            "test_info_repr_html",
            "test_grouped_hist_legacy",
            "test_missing_meta",
            "_clean_options",
            "test_partition_deprecation",
            "test_assert_not_almost_equal_numbers_with_mixed",
            "merge_cells",
            "as_timestamp",
            "test_astype_categorical",
            "to_clipboard",
            "test_repr_html_ok",
            "test_groupby_level_nonmulti",
            "_get_time_period_bins",
            "test_maybe_promote_object_with_any",
            "test_reindexing",
            "test_to_coo_text_names_text_row_levels_nosort_col_level_single",
            "test_get_unique",
            "test_integer_arithmetic_series",
            "test_qcut_include_lowest",
            "_dt_to_float_ordinal",
            "test_series_inconvertible_string",
            "test_categorical_series_repr_timedelta_ordered",
            "test_euro_decimal",
            "test_non_contiguous",
            "nbytes",
            "test_is_bool_dtype",
            "_maybe_add_count",
            "test_write_lists_dict",
            "test_getitem_empty_frame_with_boolean",
            "compare_series_ts",
            "create_block",
            "test_operators_reverse_object",
            "create_msgpack_data",
            "test_nonetype_multiple_levels",
            "box_transpose_fail",
            "time_datetime_field_year",
            "_clip_with_scalar",
            "melt",
            "test_is_scalar_builtin_nonscalars",
            "_check_generated_range",
            "test_to_dense_preserve_name",
            "_maybe_transform_eq_ne",
            "test_infer_dtype_period",
            "test_rgb_tuple_color",
            "test_nanmean_overflow",
            "test_sparse_frame_pad_backfill_limit",
            "time_med_get_loc",
            "parallel_coordinates",
            "clean_interp_method",
            "test_multiindex_na_repr",
            "test_agg_relabel_non_identifier",
            "test_apply_broadcast_error",
            "_check_behavior",
            "test_usecols_regex_sep",
            "test_to_integer_array_dtype_keyword",
            "test_ix_align",
            "maybe_box_datetimelike",
            "sequence_to_td64ns",
            "test_outer_join",
            "test_slice_float_locs",
            "test_colspan_rowspan_copy_values",
            "str_extract",
            "test_setitem_callable",
            "test_to_html_with_index_names_false",
            "test_qcut_duplicates_bin",
            "test_timestamp_tz_localize_nonexistent_shift",
            "test_springforward_singular",
            "simple",
            "_index_end",
            "_process_format_subheader",
            "test_apply_future_warning",
            "test_rolling_corr_diff_length",
            "_pprint_dict",
            "init_xsel_clipboard",
            "test_maybe_promote_datetimetz_with_na",
            "test_no_millisecond_field",
            "test_selection",
            "test_resample_with_only_nat",
            "time_transform_lambda_max",
            "test_regex_replace_list_obj_inplace",
            "test_complex_append",
            "set_metadata",
            "test_td64arr_mul_int",
            "test_constructor_tuple_of_tuples",
            "test_at_inside_string",
            "test_consistency_with_window",
            "test_apply_same_length_inference_bug",
            "test_index_equal_names",
            "test_join_level",
            "test_remove_unused_levels_large",
            "std",
            "test_default_dtype",
            "test_basic2",
            "test_pivot_table_aggfunc_dropna",
            "test_stack_multiple_bug",
            "_isna_ndarraylike",
            "test_tz_aware_asfreq",
            "dispatch_missing",
            "test_dialect",
            "skip_if_installed",
            "test_date_range_convenience_periods",
            "should_series_dispatch",
            "test_daterange_bug_456",
            "get_objs",
            "test_missing_public_nat_methods",
            "test_store_series_name",
            "test_deprecate_ok",
            "_check_expected_dtype",
            "test_validate_indices_ok",
            "test_rank_axis",
            "make_data",
            "test_string_no_dates",
            "test_groupby_non_arithmetic_agg_types",
            "test_expanding",
            "test_warns",
            "names",
            "maybe_infer_dtype_type",
            "_is_valid_endpoint",
            "test_raise_from_object_hook",
            "test_filter_row_groups",
            "test_pi_sub_isub_offset",
            "test_encode_set",
            "test_constructor_no_data_index_order",
            "test_frame_invert",
            "_init_spmatrix",
            "test_dt64arr_timestamp_equality",
            "test_registry",
            "time_month_name",
            "test_shift_no_freq",
            "test_concat_no_unnecessary_upcast",
            "test_how_lambda_functions",
            "test_concat_different_fill",
            "test_resample_quantile",
            "test_read_excel_blank_with_header",
            "test_partial_loc_missing",
            "test_to_dict_errors",
            "test_div_int",
            "test_lag_plot",
            "test_concat_empty_series_timelike",
            "test_flat_stays_flat",
            "test_read_excel_bool_header_arg",
            "test_resample_to_timestamps",
            "test_combine_first",
            "test_container_shift",
            "test_shift_bool",
            "test_update_ctx",
            "test_query_long_float_literal",
            "test_non_sparse_raises",
            "test_invalid",
            "_get_join_indexers",
            "test_from_product_invalid_input",
            "_update_ctx",
            "data_for_grouping",
            "test_expand_frame_repr",
            "_can_reindex",
            "_make_concat_multiindex",
            "test_guess_datetime_format_with_dayfirst",
            "kurt",
            "test_expanding_axis",
            "time_mult",
            "upsample_method",
            "test_series_tz_localize",
            "process_class_docstrings",
            "test_join_on_series",
            "test_constructor_invalid_frequency",
            "max",
            "test_parser",
            "makeFY5253LastOfMonthQuarter",
            "time_append_obj_list",
            "test_freeze_panes",
            "test_stack_partial_multiIndex",
            "test_concat_multiple_tzs",
            "test_constructor_datetime64_tzformat",
            "generate_bins_generic",
            "test_round_dst_border_ambiguous",
            "test_complex_mixed_fixed",
            "index_labels_to_array",
            "test_constructor_dtype_str",
            "test_missing_trailing_delimiters",
            "test_spss_labelled_num_na",
            "test_start_stop_step_attrs",
            "test_where_with_one_style",
            "test_concat_same_type_invalid",
            "test_assert_almost_equal_timestamp",
            "test_na_value_dict_multi_index",
            "read_parquet",
            "_read_int",
            "test_astype_raises",
            "test_readjson_each_chunk",
            "assert_check_nselect_boundary",
            "test_isnumeric",
            "test_grouping_string_repr",
            "test_groupby_timedelta_cython_count",
            "check_chained_cmp_op",
            "test_constructor_simple_new",
            "_get_properties",
            "git_pieces_from_vcs",
            "test_mixed_index_at_iat_loc_iloc_series",
            "_ensure_numeric",
            "_wrap_aggregated_output",
            "__copy__",
            "test_float_index_at_iat",
            "test_nanargmin",
            "_nanminmax",
            "_concat_same_dtype",
            "time_isnull_obj",
            "test_int_series_slicing",
            "test_loc_getitem_series",
            "test_tz_conversion_freq",
            "test_constructor_with_datetimes",
            "test_interpolate_piecewise_polynomial",
            "test_cmov_window_regular",
            "test_reindex_duplicate_target",
            "test_parse_time_string",
            "test_hash_pandas_object",
            "test_frame_group_ops",
            "test_from_records_lists_generator",
            "test_embedded_newline",
            "_evaluate",
            "_save",
            "test_disallow_python_keywords",
            "freqstr",
            "test_finder_hourly",
            "test_dti_to_pydatetime_fizedtz",
            "test_dialect_conflict_delimiter",
            "ints_to_td64ns",
            "test_append_missing_cols",
            "test_constructor_error_msgs",
            "_get_exec",
            "time_loc_list",
            "test_astype_no_copy",
            "test_groupby_function_rename",
            "test_rank_categorical",
            "_from_nested_dict",
            "time_to_julian_date",
            "test_setitem_fancy_2d",
            "check_nancomp",
            "test_array_type",
            "test_stack_int_level_names",
            "test_parametrized_factorize_na_value",
            "test_days",
            "test_constructor_str_category",
            "test_infer_freq_delta",
            "test_unit_rounding",
            "time_loc_dups",
            "test_pivot_table_categorical_observed_equal",
            "notna",
            "test_set_index_multiindexcolumns",
            "test_reindex_lvl_preserves_names_when_target_is_list_or_array",
            "test_centered_axis_validation",
            "maybe_convert_objects",
            "test_from_array",
            "test_period_ordinal_business_day",
            "_get_fill_value",
            "_get_values_tuple",
            "test_setitem_single_column_mixed",
            "_maybe_update_attributes",
            "time_reshape_pivot_time_series",
            "test_from_arrays_iterator",
            "test_large",
            "time_frame_drop_dups_bool",
            "test_interp_raise_on_only_mixed",
            "test_apply_subset",
            "test_guess_datetime_format_for_array",
            "_ts_plot",
            "test_slice_float_get_set",
            "test_repr_html_mathjax",
            "time_crosstab_values",
            "test_validate_bool_kwarg_fail",
            "test_numpy_all",
            "_check_resolvers",
            "test_from_tuples",
            "wrap",
            "test_sort2",
            "test_to_frame_dtype_fidelity",
            "generate_regular_range",
            "rename_axis",
            "test_xticklabels",
            "test_alias_equality",
            "test_assign_multiple",
            "nlevels",
            "test_df_numeric_cmp_dt64_raises",
            "test_strobj_mode",
            "test_unsorted_index_xlim",
            "test_numeric_object_likes",
            "test_from_inferred_categories_sorts",
            "test_convert_objects_no_conversion",
            "test_dt_round",
            "test_datetime_other_units",
            "test_frame_dict_constructor_empty_series",
            "time_series_nth",
            "is_label_like",
            "test_array_interface_tz",
            "test_get_loc_level",
            "test_usecols_relative_to_names2",
            "test_round_trip_equals",
            "_attempt_YYYYMMDD",
            "_preprocess_slice_or_indexer",
            "test_union_sort_other_incomparable",
            "test_table_attributes",
            "test_array_inference_fails",
            "test_fillna_tzaware_different_column",
            "test_extract_optional_groups",
            "time_make_union",
            "test_update_nooverwrite",
            "test_df_arithmetic_subexpression",
            "_convert_freq",
            "errors",
            "test_replace_limit",
            "_assert_take_fillable",
            "_write_value_label_names",
            "test_get_option",
            "test_append_frame_column_oriented",
            "test_frame_subclassing_and_slicing",
            "time_timedelta_microseconds",
            "ydiffs",
            "test_encode_big_escape",
            "test_dropna_invalid_how_raises",
            "read",
            "test_factory",
            "test_basic_series_frame_alignment",
            "test_duplicated_keep",
            "_initialize_stacker",
            "test_fillna_series_method",
            "test_constructor_with_convert",
            "test_iter_object_try_string",
            "test_cummin",
            "test_nan_first_take_datetime",
            "test_getitem_callable",
            "style",
            "_coerce_scalar_to_timedelta_type",
            "test_loc_getitem_tuple_plus_slice",
            "export",
            "test_single_quantile",
            "test_safe_import_exists",
            "test_constructor_list_of_ranges",
            "test_multiple_delimiters",
            "test_insert_index_object",
            "test_apply_with_reduce_empty",
            "_make_cum_function",
            "test_resample_datetime_values",
            "test_asm8",
            "test_constructor_na_dtype",
            "test_iso8601_strings_mixed_offsets_with_naive",
            "time_lower",
            "test_getattr",
            "test_array32",
            "test_apply_dont_convert_dtype",
            "test_constructor_dtype_datetime64",
            "test_sparse_repr_after_set",
            "test_converters_type_must_be_dict",
            "_warn_if_deprecated",
            "test_where_dups",
            "test_multiple_date_cols_int_cast",
            "test_dtype",
            "mean",
            "write_data_chunk",
            "test_join_on_fails_with_different_left_index",
            "_validate_monotonic",
            "_maybe_arg_null_out",
            "test_filter_regex_search",
            "test_interp_non_timedelta_index",
            "test_get_loc_tolerance",
            "test_series_tz_convert_to_utc",
            "test_rounding_on_int_unit_construction",
            "build_xlstyle",
            "test_apply_deprecate_reduce",
            "test_write_index",
            "test_multiple_date_cols_chunked",
            "test_iter_empty",
            "table_schema_cb",
            "test_values_boxed",
            "test_set_fill_value",
            "test_left_join_indexer2",
            "test_encode_empty_set",
            "test_partition_on_supported",
            "test_depreciate_tz_and_tzinfo_in_datetime_input",
            "test_filter_unicode",
            "test_op_duplicate_index",
            "test_outer_join_sort",
            "time_replace_series",
            "test_factorized_sort",
            "test_invalid_arg",
            "test_pi_add_intarray",
            "test_minute",
            "test_sub",
            "test_sparse_bool",
            "test_auto_detect",
            "test_concat_NaT_dataframes",
            "test_dt64arr_add_td64_scalar",
            "test_mode_sortwarning",
            "test_regex_replace_dict_nested_non_first_character",
            "test_info_memory_usage_qualified",
            "test_is_error_nozeroindex",
            "test_execute",
            "test_td_add_timedelta64",
            "to_datetime",
            "observed",
            "box_in_series",
            "time_infer_dst",
            "test_roll",
            "test_array_repr",
            "test_grouping_error_on_multidim_input",
            "test_td64arr_add_sub_tdi",
            "test_set_index_pass_multiindex",
            "test_date_range_with_fixedoffset_noname",
            "between_time",
            "test_unbounded_slice_raises",
            "test_multiple_date_col_name_collision",
            "_check_ax_scales",
            "test_resample_categorical_data_with_timedeltaindex",
            "_get_formatted_column_labels",
            "test_freq_group",
            "test_asfreq_normalize",
            "time_getitem_scalar",
            "floor",
            "_make_iris_table_metadata",
            "test_to_latex_special_escape",
            "testPackFloat",
            "test_parallel_coordinates_with_sorted_labels",
            "HolidayCalendarFactory",
            "test_set_index_empty_column",
            "test_concat_categorical_ordered",
            "test_td64arr_add_timestamp",
            "time_get_loc_non_unique_sorted",
            "test_bar_align_mid_vmin",
            "test_maybe_promote_string_with_any",
            "test_allow_exact_matches_nearest",
            "test_iat",
            "concatenate_join_units",
            "test_series_interpolate_method_values",
            "test_fillna_overlap",
            "test_constructor_from_series",
            "test_frame_repr",
            "test_partial_slice_high_reso",
            "validate_multiindex",
            "test_line_plot_period_mlt_frame",
            "test_constructor_dict_of_ranges",
            "test_subplot_titles",
            "test_construction_with_ndarray",
            "_pickle_roundtrip_name",
            "test_header_multi_index_common_format_malformed1",
            "test_set_dtype_no_overlap",
            "test_isin_tuples",
            "test_no_keep_default_na_dict_na_values_diff_reprs",
            "test_nanvar_axis",
            "_onOffset",
            "test_mixed_array_comparison",
            "test_from_arrays_index_series_period",
            "test_round_minute_freq",
            "test_to_sql_type_mapping",
            "test_groupby_head_tail",
            "_check_merge",
            "test_frame_getitem_multicolumn_empty_level",
            "test_to_dict_not_unique_warning",
            "test_plain",
            "test_rename_axis_none",
            "tshift",
            "test_asfreq_nat",
            "test_remove_unused_categories",
            "_test_compression_warns_when_decompress_caches",
            "is_full",
            "test_make_block_no_pandas_array",
            "test_date_range_businesshour",
            "validate_minmax_axis",
            "unique",
            "visit_Attribute",
            "test_append_index",
            "test_timegrouper_with_reg_groups_freq",
            "mem_itertuples_read_first",
            "test_dt64arr_add_sub_td64ndarray",
            "test_subclass_stack",
            "test_get_loc_tolerance_no_method_raises",
            "_check_equal",
            "time_multi_count",
            "_set_option",
            "test_fillna_columns",
            "as_frame",
            "ngroups",
            "test_to_datetime_format_time",
            "test_different_nan_objects",
            "test_constructor_empty_list",
            "test_parse_dates_string",
            "time_ewm",
            "is_extension_array_dtype",
            "test_frame_index_to_string",
            "test_str_cat",
            "_single_replace",
            "test_series_getitem_multiindex_xs",
            "test_coerce_uint64_conflict",
            "test_bar_log",
            "test_drop_unique_and_non_unique_index",
            "_remove_whitespace",
            "test_equals_object",
            "test_contains_for_object_category",
            "test_get_loc_implicit_cast",
            "test_pop",
            "test_apply_ticks",
            "test_full_file_with_missing",
            "test_iloc_exceeds_bounds",
            "test_upsample_daily_business_daily",
            "assigner",
            "test_series_partial_set",
            "test_fy5253qtr_onoffset_last",
            "time_frame",
            "test_equals_op_multiindex",
            "test_read_from_py_localpath",
            "test_date_explicit_date_format",
            "_map_values",
            "test_replace_literal",
            "objects_to_td64ns",
            "test_to_datetime_list_of_integers",
            "ea_passthrough",
            "git_versions_from_keywords",
            "test_from_json_to_json_table_index_and_columns",
            "test_changing_names",
            "test_where_series_complex128",
            "test_comment_whitespace_delimited",
            "test_float_parser",
            "test_na_substitution",
            "_prev_opening_time",
            "_is_numeric_mixed_type",
            "test_attrs",
            "use",
            "time_convert_int",
            "continue_maybe2",
            "time_frame_getitem_single_column_int",
            "not_daily",
            "test_apply_fill",
            "apply_standard",
            "test_comparison_protected_from_errstate",
            "test_series_fast_transform_date",
            "test_addition_ops",
            "test_column_multiindex",
            "test_is_recompilable_fails",
            "test_reindex_index",
            "test_duplicate_keep_all_ties",
            "test_drop_dst_boundary",
            "test_df_grid_settings",
            "test_fwf_colspecs_is_list_or_tuple_of_two_element_tuples",
            "test_filter_non_bool_raises",
            "test_register_by_default",
            "maybe_make_list",
            "test_getslice",
            "_skip_if_different_combine",
            "test_numpy_array_all_dtypes",
            "test_read_with_startstop",
            "test_downcast_conversion_empty",
            "frame_apply",
            "test_setitem_series_datetime64tz",
            "_quarterly_finder",
            "_repr_categories_info",
            "_extend_blocks",
            "coerce",
            "_get_dtype",
            "test_nan_interpolate",
            "time_from_ints",
            "test_pickle_compat_construction",
            "test_column_dups_operations",
            "uint_dtype",
            "test_sum_uint64_overflow",
            "test_info_shows_column_dtypes",
            "test_non_unique_moar",
            "test_tz_convert_utc_with_system_utc",
            "test_nanne",
            "test_freq_offsets",
            "test_readjson_chunks_closes",
            "test_is_dtype_unboxes_dtype",
            "test_hist_layout",
            "test_loc_setitem",
            "test_join_outer",
            "test_shallow_copying",
            "test_binop_maybe_preserve_name",
            "test_constructor_from_index_dtlike",
            "test_np_sum",
            "test_shape",
            "test_to_datetime_format",
            "test_putmask_with_wrong_mask",
            "test_x_multiindex_values_ticks",
            "test_dups_fancy_indexing2",
            "test_quarterly_upsample",
            "test_get_day_of_year_dt",
            "test_local_syntax",
            "test_between",
            "write_multi_index",
            "_get_business_hours_by_sec",
            "time_datetime_level_values_sliced",
            "time_to_sql_dataframe_column",
            "test_empty",
            "test_get_loc",
            "test_usecols_wrong_type",
            "test_encode_null_character",
            "test_finder_quarterly",
            "test_ts_line_lim",
            "test_get_to_timestamp_base",
            "test_drop_duplicates",
            "test_concatlike_datetimetz_to_object",
            "test_assert_numpy_array_equal_value_mismatch5",
            "_decode_complex",
            "test_clip_against_series",
            "test_hist_colors",
            "test_quantile_axis_parameter",
            "_getitem_bool_array",
            "test_reasonable_key_error",
            "time_datetime_to_period",
            "test_merged_cell_custom_objects",
            "test_getitem_out_of_bounds",
            "_valid_locales",
            "test_rands_array_1d",
            "test_fancy_index_misc",
            "test_union_dtypes",
            "test_is_list_like_disallow_sets",
            "test_replace_integer_args",
            "_is_strictly_monotonic_decreasing",
            "test_math_sub",
            "end_blank_lines",
            "test_colspan_rowspan_1",
            "time_timestamp_ops_diff_with_shift",
            "interp_methods_ind",
            "dtype_for",
            "time_iter_preexit",
            "test_na_tuples",
            "test_attr_wrapper",
            "test_apply_dict",
            "test_where_index_period",
            "test_interleave",
            "test_bool_describe_in_mixed_frame",
            "test_constructor_dtypes_to_datetime",
            "test_frame_getitem_toplevel",
            "test__is_dtype_type",
            "_check_all",
            "_get_time_bins",
            "test_usecols_with_integer_like_header",
            "test_frame_equal_index_dtype_mismatch",
            "add_methods",
            "test_subclassed_wide_to_long",
            "test_engineless_lookup",
            "test_constructor_floats",
            "test_alignment_non_pandas",
            "_ensure_data",
            "test_year_has_extra_week",
            "test_usecols_with_multi_byte_characters",
            "_field_accessor",
            "test_diff_axis",
            "test_astype_dispatches",
            "time_replace_None",
            "test_vector_resize",
            "test_to_frame_datetime_tz",
            "test_cmov_window",
            "test_escapechar",
            "get_sheet_data",
            "test_min",
            "test_hide_multiindex",
            "test_index_ctor_nat_result",
            "peakmem_itertuples_start",
            "time_frame_sort_values_by_columns",
            "_failover_to_python",
            "test_naive_datetimeindex_roundtrip",
            "test_subclass_unstack_multi_mixed",
            "time_rendering",
            "test_reindex_preserves_tz_if_target_is_empty_list_or_array",
            "test_setitem_with_datetime_tz",
            "maybe_upcast_for_op",
            "get_items",
            "symmetric_difference",
            "buffer",
            "test_hasnans_isnans",
            "test_empty_with_dup_column_pass_dtype_by_indexes",
            "_convert_object_array",
            "str_endswith",
            "test_parr_add_sub_float_raises",
            "is_s3_url",
            "test_sparse_series_round_trip",
            "test_object_refcount_bug",
            "no_description_period_with_directive",
            "test_dataframe_utc_true",
            "test_astype_from_object",
            "evaluate",
            "test_from_dtype_from_float",
            "test_union_sort_other_incomparable_sort",
            "time_read_store_table_mixed",
            "test_series_numeric",
            "create_block_manager_from_blocks",
            "test_getitem_arraylike_mask",
            "test_callback",
            "conda_package_to_pip",
            "test_ts_frame",
            "time_kth_smallest",
            "load_newobj_ex",
            "test_str_cat_special_cases",
            "test_set_names_unset",
            "test_groupby_one_row",
            "time_asof_nan",
            "test_loc_multiindex_ints",
            "round_trip_pathlib",
            "test_where_warns",
            "test_concat_categorical_3elem_coercion",
            "test_is_interval_dtype",
            "_concat_sparse",
            "_consolidate",
            "test_constructor_list_of_series",
            "_consolidate_check",
            "test_result_type",
            "test_apply_with_mixed_dtype",
            "test_summary",
            "test_options_fp",
            "test_sub_day",
            "assert_levels_dropped",
            "test_put",
            "test_df_add_flex_filled_mixed_dtypes",
            "_check_arg_length",
            "__getitem__",
            "time_loc_array",
            "test_fillna_skip_certain_blocks",
            "getCols",
            "test_read_local_jsonl",
            "test_duplicate_columns",
            "test_resample_daily_anchored",
            "test_default_handler_indirect",
            "test_operators_datetimelike_invalid",
            "time_corr_series",
            "test_freq_divides_end_in_nanos",
            "test_sort_index_level_large_cardinality",
            "test_read_json_table_convert_axes_raises",
            "test_constructor_use_start_freq",
            "time_med_get_loc_warm",
            "test_rename_categories_series",
            "test_bool_flex_frame",
            "test_dti_constructor_small_int",
            "test_iloc_returns_dataframe",
            "test_range_slice_outofbounds",
            "test_validate_median_initial",
            "to_msgpack",
            "_parse_thead_tr",
            "set_timezone",
            "test_fillna_period",
            "test_to_string_line_width_no_index",
            "test_resample_weekly_bug_1726",
            "test_loc_non_unique_memory_error",
            "test_parser_error_on_empty_header_row",
            "_compare_with_tz",
            "test_nunique_with_timegrouper_and_nat",
            "_filters",
            "_interleaved_dtype",
            "test_repr_missing",
            "_getitem_frame",
            "test_write_variable_labels",
            "test_default_left_closed_label",
            "time_reindex_method",
            "test_argmin_argmax",
            "_init_mgr",
            "test_chained_cmp_op",
            "test_pi_cmp_nat_mismatched_freq_raises",
            "ftypes",
            "is_true_slices",
            "_attr_getter",
            "test_merge_incompat_dtypes_are_ok",
            "test_dt64arr_sub_dtscalar",
            "time_slice",
            "test_floor_division",
            "test_constructor_numeric",
            "get_freq",
            "test_iloc_integer_locations",
            "test_xs_level_series_slice_not_implemented",
            "test_to_csv_quotechar",
            "test_astype_float",
            "test_empty_with_mangled_column_pass_dtype_by_names",
            "test_multiindex_header_index_skiprows",
            "test_display_subset",
            "time_pivot_table_categorical_observed",
            "test_constructor_tz_or_tzinfo",
            "test_quantile_interpolation_datetime",
            "test_get_slice",
            "idxmin",
            "test_non_monotonic_reindex_methods",
            "time_isin_nan_values",
            "test_append_overlap_raises",
            "test_setitem_frame_align",
            "test_plot_multiple_inferred_freq",
            "should_warn",
            "check_coerce",
            "is_categorical_dtype",
            "test_alignment",
            "test_isin_empty_datetimelike",
            "test_get_loc_outside_tolerance_raises",
            "test_groupby_groups_datetimeindex_tz",
            "strides",
            "test_constructor_dict_datetime64_index",
            "test_from_records_len0_with_columns",
            "test_concat_keys_and_levels",
            "test_ix_get_set_consistency",
            "test_series_ctor_plus_datetimeindex",
            "test_header_inferred_from_rows_with_only_th",
            "test_secondary_y_irregular_ts_xlim",
            "_combine_hash_arrays",
            "_sub_datetimelike_scalar",
            "test_isin_level_kwarg_bad_label_raises",
            "test_empty_df_expanding",
            "test_mask_callable",
            "test_unbalanced_quoting",
            "test_rolling_corr_pairwise",
            "test_groupby_cumprod",
            "test_tdi_ops_attributes",
            "test_frame_equal_columns_mismatch",
            "test_block_names",
            "test_assert_extension_array_equal_less_precise",
            "test_labels_dtypes",
            "test_operator_series_comparison_zerorank",
            "test_dti_constructor_preserve_dti_freq",
            "test_concat_different_extension_dtypes_upcasts",
            "test_agg_python_multiindex",
            "nanos",
            "test_maxbuffersize_read_size_exceeds_max_buffer_size",
            "validate_rolling_func",
            "test_no_reference_cycle",
            "test_constructor_dtypes_to_int64",
            "UnicodeWriter",
            "test_to_html_no_index_max_rows",
            "_sparse_series_to_coo",
            "test_astype_array_fallback",
            "test_constructor_sequence",
            "test_search_sorted_datetime64_scalar",
            "test_to_csv_multiindex",
            "time_boolean_series",
            "test_round_subsecond",
            "test_nancorr",
            "value_labels",
            "test_skip_rows_skip_all",
            "test_resample_how_method",
            "nanprod",
            "test_tuples_with_name_string",
            "time_getitem_list_like",
            "test_frame_indexing_single",
            "test_concatlike_datetimetz_short",
            "_normalize_keyword_aggregation",
            "test_reset_option_all",
            "test_rename_bug2",
            "test_order_without_freq",
            "test_from_records_with_index_data",
            "test_categorical_ordered_none_deprecated",
            "test_compare_ticks",
            "test_to_integer_array_float",
            "test_sort_index_nan",
            "rep_stamp",
            "time_scalar_function_multi_col",
            "signed",
            "_is_label_reference",
            "test_to_string_ascii_error",
            "test_convert_numeric_uint64",
            "_series_and_frame",
            "test_invalid_encoding",
            "time_searchsorted",
            "test_astype_str",
            "test_overlapping_datetime",
            "test_comment_skiprows_header",
            "test_min_valid",
            "test_frame_getitem_simple_key_error",
            "test_shift_identity",
            "_get_version",
            "_create_table_setup",
            "test_where_index_datetimetz",
            "test_loc_with_slices",
            "test_tdi_add_dt64_array",
            "test_plot_offset_freq",
            "_can_hold_na",
            "test_is_not_string_type",
            "test_unstack_mixed_extension_types",
            "test_dst_transitions",
            "test_constructor_from_index_series_datetimetz",
            "h",
            "test_mode_single",
            "test_add_matplotlib_datetime64",
            "test_shallow_copy_empty",
            "test_groupby_categorical_index_and_columns",
            "test_read_column",
            "__or__",
            "time_with_nan",
            "test_drop_api_equivalence",
            "test_iloc_series",
            "test_ewma_span_com_args",
            "_filter_usecols",
            "test_raise_when_saving_timezones",
            "test_extract_expand_None",
            "_get_options_with_defaults",
            "is_normalized",
            "makeStringSeries",
            "_add_logical_methods_disabled",
            "index_cols",
            "test_raise_on_drop_duplicate_index",
            "get_validation_data",
            "_set_item",
            "all_timeseries_index_generator",
            "set_attrs",
            "_convert_slice_indexer",
            "test_index_cast_datetime64_other_units",
            "test_interval_array_equal_closed_mismatch",
            "test_merge_datetime_index",
            "test_fillna_datetime64",
            "test_plot_scatter_with_c",
            "epochs",
            "test_invalid_raises",
            "test_read_explicit",
            "rindex",
            "test_day_not_in_month_coerce",
            "test_constructor_dict",
            "time_get_loc_inc",
            "_record_count",
            "test_sort_datetimelike",
            "test_highlight_null",
            "format_query",
            "time_on_offset",
            "test_case_insensitive",
            "compression_only",
            "integer_parameter",
            "time_exact",
            "is_datetimetz",
            "test_apply_convert_objects",
            "test_from_arrays_invalid_input",
            "_load_raw_sql",
            "test_to_datetime_with_non_exact",
            "_test_offset",
            "test_valid",
            "time_reindex_multiindex",
            "salaries_table",
            "set_atom_categorical",
            "test_transform_numeric_to_boolean",
            "test_pairlist",
            "test_concat_invalid_first_argument",
            "test_agg_cython_table_raises",
            "is_platform_32bit",
            "test_set_properties",
            "test_subdays",
            "test_xs_level0",
            "test_spam",
            "test_timestamp_add_timedelta_push_over_dst_boundary",
            "test_repr",
            "test_smallerEqual_Raises_Type",
            "_pipe",
            "test_maybe_promote_any_numpy_dtype_with_na",
            "test_with_datetimelikes",
            "assert_extension_array_equal",
            "_get_method_wrappers",
            "_step",
            "test_reindex_signature",
            "test_resample_frame_basic",
            "_box_values",
            "configure_tests",
            "_indicator_post_merge",
            "test_loffset_returns_datetimeindex",
            "time_datetimes_with_nat",
            "test_array_type_with_arg",
            "UnicodeReader",
            "_na_value",
            "test_groupby_with_small_elem",
            "test_oo_optimizable",
            "test_groupby_agg_ohlc_non_first",
            "prefix_pandas",
            "extended_summary",
            "init_qt_clipboard",
            "test_no_keep_default_na_dict_na_scalar_values",
            "test_full_outer_join",
            "test_sort_index_reorder_on_ops",
            "test_iterator_read_too_much",
            "test_td_div_timedeltalike_scalar",
            "test_to_excel_output_encoding",
            "test_nth",
            "_to_sql_replace",
            "_parse_tbody_tr",
            "test_check_integrity",
            "test_str_cat_name",
            "_maybe_cache",
            "test_empty_with_dup_column_pass_dtype_by_indexes_raises",
            "test_concat_series_axis1_same_names_ignore_index",
            "test_get_loc_raises_missized_tolerance",
            "classmethod",
            "_ensure_valid_index",
            "union",
            "test_cython_inner_join",
            "_get_index_factory",
            "is_categorical_astype",
            "get_numeric_data",
            "test_td_constructor_value_error",
            "_text_getter",
            "test_take_scalar_raises",
            "test_categorical_index_preserver",
            "assert_index_equal",
            "test_loc_slice_index_fill_value",
            "_try_coerce_result",
            "test_nat_doc_strings",
            "get_formatted_cells",
            "test_frame_datetime64_mixed_index_ctor_1681",
            "test_write_unsupported_compression_type",
            "test_from_records_with_datetimes",
            "is_named_tuple",
            "test_to_sparse",
            "_ensure_arraylike",
            "_repr_categories",
            "test_tz_localize_ambiguous_compat",
            "test_corrwith",
            "test_filter_out_all_groups_in_df",
            "test_date_format_series",
            "_import_deprmod",
            "test_copy_in_constructor",
            "_get_setitem_indexer",
            "test_bin16",
            "test_per_axis_per_level_getitem",
            "register_vcs_handler",
            "test_compare_2000",
            "test_bar_barwidth",
            "float_frame_fill0_dense",
            "can_connect",
            "test_show_dimensions",
            "test_numeric_compat",
            "arr_dict",
            "_indicator_pre_merge",
            "test_hash_array_mixed",
            "test_datetime_like",
            "testIgnoreUnicodeErrors",
            "test_issue124",
            "test_basic_frame",
            "test_resample_with_dst_time_change",
            "test_nat_arithmetic_td64_vector",
            "test_join_multi_empty_frames",
            "test_truncate",
            "test_multiindex_header_skiprows_tuples",
            "test_getitem_error",
            "test_string_slice_out_of_bounds",
            "test_interp_limit_direction",
            "test_between_time_formats",
            "test_nrows_skipfooter_errors",
            "test_loc_setitem_with_scalar_index",
            "test_constructor_dtype",
            "remove",
            "test_getitem_numeric_column_names",
            "_is_monotonic_decreasing",
            "_unpickle_frame_compat",
            "__and__",
            "test_maybe_convert_numeric_infinities",
            "np_array_datetime64_compat",
            "test_resample_same_freq",
            "test_correct_type_nested_array",
            "test_overflow_offset_raises",
            "test_malformed",
            "ts",
            "test_append_preserve_index_name",
            "time_getitem_bool_array",
            "_try_convert_to_date",
            "test_sparse_mixed",
            "time_iso8601_nosep",
            "test_getitem_boolean_casting",
            "validate_dtype_freq",
            "_aggregate_multiple_funcs",
            "test_setitem_loc_scalar_mixed",
            "test_map_tseries_indices_return_index",
            "test_elementwise_comparison_warning",
            "test_convert_pandas_type_to_json_period_range",
            "get_locales",
            "test_invalid_engine",
            "test_data_method",
            "test_read_sql_named_parameter",
            "test_rmod_pytimedelta",
            "is_datetime64tz_dtype",
            "test_nangt",
            "construct_1d_arraylike_from_scalar",
            "test_combine_first_mixed",
            "test_nested_dict_frame_constructor",
            "test_update_ctx_flatten_multi",
            "test_is_scalar_numpy_array_scalars",
            "test_invalid_skipfooter_negative",
            "time_merge_dataframe_integer_2key",
            "test_decode_depth_too_big",
            "test_non_reducing_slice",
            "test_skiprows_xrange",
            "test_multi_index",
            "test_replace_tzinfo_equiv_tz_localize_none",
            "test_dt64arr_add_sub_DateOffset",
            "test_numpy_repeat",
            "test_is_datetimelike_v_object",
            "test_1d_with_out",
            "test_getitem_ix_boolean_duplicates_multiple",
            "test_multiples",
            "test_freq_code_match",
            "_homogenize",
            "test_isin_against_series",
            "translate",
            "test_complex_raises",
            "test_holder",
            "bfill",
            "test_reset_index_with_datetimeindex_cols",
            "test_file_handles_mmap",
            "convert_values",
            "test_get_indexer_errors",
            "test_consolidate",
            "test_combine_datetlike_udf",
            "test_rank_signature",
            "time_series_describe",
            "test_pi_add_iadd_timedeltalike_daily",
            "test_repr_empty",
            "test_intersect_equal_sort_true",
            "test_fake_inferred_business",
            "test_read_chunks_115",
            "group_index",
            "test_constructor_name_hashable",
            "test_cant_or_shouldnt_cast",
            "test_astype_datetime",
            "float_frame_with_na",
            "test_non_reducing_slice_on_multiindex",
            "test_to_string_float_format_no_fixed_width",
            "_get_subplots",
            "test_difference_base",
            "test_get_X_columns",
            "test_td_floordiv_invalid_scalar",
            "_roundtrip",
            "test_bar_colors",
            "_round",
            "_td_array_cmp",
            "format_percentiles",
            "is_consolidated",
            "test_constructor_dtype_and_others_raises",
            "test_groupby_empty",
            "test_map_missing_mixed",
            "_check_setitem_copy",
            "test_multiindex_label_slicing_with_negative_step",
            "is_integer_dtype",
            "test_bar_ignore_index",
            "_equals_tag",
            "_consolidate_inplace",
            "_aggregate",
            "test_int64_overflow",
            "test_extract_expand_unspecified",
            "_is_multiple",
            "test_first_last_nth",
            "test_inplace_ops_identity",
            "test_modify_values",
            "test_to_string_small_float_values",
            "test_repr_non_interactive",
            "test_merge_on_nans",
            "test_pad",
            "test_astype_no_pandas_dtype",
            "as_blocks",
            "time_infer_quarter",
            "test_mode_category",
            "test_with_duplicates",
            "test_quantile_invalid",
            "test_encode_array_in_array",
            "test_bar_stacked_center",
            "test_basic_getitem_setitem_corner",
            "test_multiple_date_cols_with_header",
            "test_td64arr_add_timedeltalike",
            "get_compressed_ids",
            "test_series_indexing_single",
            "test_intersection_bug_1708",
            "time_rename_axis1",
            "time_write_hdf",
            "test_should_cache_errors",
            "_monthly_finder",
            "test_full_format_converters",
            "test_interval_array_equal",
            "time_groupby_sum_multiindex",
            "test_equals_multi",
            "test_setitem_scalar_into_readonly_backing_data",
            "to_julian_date",
            "test_resample_float_base",
            "csv_dir_path",
            "test_merge_non_unique_indexes",
            "test_left_merge_na_buglet",
            "asobject",
            "test_from_coo_long_repr",
            "test_dti_custom_business_summary_pytz",
            "test_mixed_index_no_fallback",
            "test_to_html_truncation_index_false_max_rows",
            "_is_business_daily",
            "time_add_timedelta",
            "test_to_numpy_dtype",
            "test_cython_left_outer_join",
            "test_union_categorical_same_category",
            "test_insert_index_period",
            "test_constructor_unwraps_index",
            "test_out_of_range_float",
            "test_expanding_apply",
            "test_select_filter_corner",
            "test_get_loc_raises_object_nearest",
            "wide_to_long",
            "exception_matches",
            "test_transform_mixed_type",
            "test_thousands_macau_index_col",
            "time_write_stata",
            "test_is_categorical_dtype",
            "test_walk",
            "test_concat_multiindex_rangeindex",
            "test_plot_fails_with_dupe_color_and_style",
            "read_excel",
            "test_exceeding_unpacker_read_size",
            "test_demo",
            "test_where_datetime",
            "test_slicing_maintains_type",
            "test_cannot_copy_item",
            "test_reset_option",
            "peakmem_itertuples_raw",
            "test_object_empty",
            "test_getitem_scalar_na",
            "test_preserve_categories",
            "test_decons",
            "test_series_constructor_with_astype",
            "_build_option_description",
            "test_resample_with_pytz",
            "test_ewm_alpha_arg",
            "_is_cython_func",
            "test_first_row_bom",
            "time_crosstab_normalize_margins",
            "test_rolling_quantile_param",
            "previous_workday",
            "test_quantile_axis_mixed",
            "test_pivot_integer_columns",
            "_multi_take_opportunity",
            "test_cmov_window_regular_missing_data",
            "__abs__",
            "_assert_setitem_series_conversion",
            "test_invalid_columns",
            "test_legacy_table_read_py2",
            "mode",
            "set_locs",
            "test_subplots_layout",
            "test_decode_with_trailing_whitespaces",
            "test_other_type_raises",
            "test_date_range_ambiguous_arguments",
            "_combine_match_index",
            "default_units",
            "test_cummax_timedelta64",
            "_convert_to_color",
            "test_constructor_list_of_tuples",
            "test_grouped_plot_fignums",
            "test_ufunc_multiple_return_values",
            "test_is_timedelta",
            "test_construction_with_nat_and_tzlocal",
            "test_groupby_level_apply",
            "_read_page_header",
            "test_view_tz",
            "test_irregular_datetime64_repr_bug",
            "test_deprecated_dense_to_sparse",
            "test_split_with_name",
            "test_append_with_strings",
            "test_stubs",
            "test_int_indexing",
            "_set_foo",
            "test_to_latex_multiindex_empty_name",
            "test_block_shape",
            "_insert_inaxis_grouper_inplace",
            "test_ignore_downcast_cannot_convert_float",
            "test_nanle",
            "test_bad_docstrings",
            "test_period_array_ok",
            "test_dt_round_tz_nonexistent",
            "test_shift_month_error",
            "html_encoding_file",
            "test_line_plot_period_mlt_series",
            "test_bar_align_mid_vmin_vmax_wide",
            "test_divmod_zero",
            "astype2",
            "_concat_datetime",
            "test_agg_grouping_is_list_tuple",
            "_prepare_categoricals",
            "testCall",
            "test_series_describe_single",
            "backfill",
            "sort_idx",
            "test_preserve_timedeltaindex_type",
            "_setitem_slice",
            "validate_names",
            "test_interp_invalid_method",
            "test_argsort",
            "test_bar_user_colors",
            "test_getitem_partial_column_select",
            "test_get_standard_colors_random_seed",
            "_wrap_result",
            "str_get_dummies",
            "_flatten",
            "test_frame_from_json_to_json",
            "test_upsample_apply_functions",
            "test_rolling_quantile_np_percentile",
            "_assert_fillna_conversion",
            "test_empty_series",
            "_pprint_seq",
            "_resolve_name",
            "_read_sql_iris",
            "_process_subheader_counts",
            "test_to_string",
            "test_multiindex_with_columns",
            "test_getitem_fancy_boolean",
            "test_get_day_of_year_numeric",
            "test_duplicate_mi",
            "mem_parser_chunks",
            "test_numpy_transpose",
            "test_radd_tdscalar",
            "_align_method_FRAME",
            "test_getitem_group_select",
            "test_frame_pos",
            "test_duplicate_ref_loc_failure",
            "ignore_xlrd_time_clock_warning",
            "test_rank_int",
            "_get_value",
            "numpy",
            "test_truncated_float_support",
            "num_summary_lines",
            "test_constructor_with_generator",
            "test_duplicates_on_starter_columns",
            "test_getitem_ix_float_duplicates",
            "test_ensure_copied_data",
            "test_next",
            "test_overlaps_self",
            "any_allowed_skipna_inferred_dtype",
            "test_item_function",
            "test_before_nearest_workday",
            "test_drop_duplicates_metadata",
            "test_join_with_len0",
            "_construct_result",
            "test_is_not_int64_dtype",
            "test_reduce_mixed_frame",
            "test_constructor_dict_nan_key",
            "check_cases",
            "_block",
            "test_mock_clipboard",
            "test_no_version_raises",
            "test_from_arrays_index_datetimelike_mixed",
            "test_series_truncate_datetimeindex_tz",
            "test_memorial_day",
            "test_resample_count",
            "test_make_block_same_class",
            "test_anchor_week_end_time",
            "time_value_counts",
            "test_categorical_repr_datetime",
            "test_secondary_upsample",
            "test_matplotlib_scatter_datetime64",
            "checked_add_with_arr",
            "_all_indexes_same",
            "test_index_col_named2",
            "test_types",
            "time_find",
            "components",
            "test_no_values_attribute",
            "_get_cython_type_upcast",
            "test_justify",
            "_parse_date",
            "string_series",
            "test_convert_json_field_to_pandas_type_raises",
            "test_ground_truth",
            "test_is_complex_dtype",
            "test_range_tz_pytz",
            "test_pi_add_sub_td64_array_non_tick_raises",
            "test_date_conversion_overflow",
            "test_construct_from_string_fill_value_raises",
            "_coerce_values",
            "infer_objects",
            "dict_keys_to_ordered_list",
            "clean_fill_method",
            "test_getitem_pop_assign_name",
            "connect",
            "indexer_between_time",
            "ensure_clean",
            "test_iloc_frame",
            "test_bytes_io_input",
            "test_reindex_methods_nearest_special",
            "test_constructor_dtype_copy",
            "test_dti_tz_convert_to_utc",
            "test_read_inline_jsonl",
            "test_corr_nooverlap",
            "test_cumsum",
            "test_clip_against_unordered_columns",
            "test_coerce_of_invalid_datetimes",
            "before_nearest_workday",
            "test_to_integer_array_bool",
            "test_construct_1d_ndarray_preserving_na",
            "test_iloc_setitem_pandas_object",
            "_get_client",
            "test_series_nat_conversion",
            "time_add_td_ts",
            "test_multi_line_expression_callable_local_variable_with_kwargs",
            "_join_monotonic",
            "add_tmp",
            "pa",
            "all_arithmetic_operators",
            "test_ops_np_scalar",
            "test_secondary_y_ts",
            "test_update_filtered",
            "test_to_html_multiindex",
            "test_getitem_ambiguous_keyerror",
            "time_read_sql_table_parse_dates",
            "test_foobar_skip",
            "_get_varlist",
            "test_negative_ordinals",
            "deltas",
            "reset_index",
            "test_small_year_parsing",
            "test_groupby_count_dateparseerror",
            "test_equals_range",
            "test_missing_field",
            "test_series",
            "_iterable_not_string",
            "test_slice_with_zero_step_raises",
            "gen_of_tuples",
            "is_period",
            "test_fwf_colspecs_is_list_or_tuple",
            "test_insert_error_msmgs",
            "test_simple_bool_ops",
            "test_reflected_comparison_with_scalars",
            "test_sort_values",
            "test_tick_division",
            "_check_roundtrip",
            "get_locs",
            "test_set_frame_expand_regular_with_extension",
            "time_asof_single_early",
            "test_constructor_Series_named_and_columns",
            "has_non_verbose_info_repr",
            "test_astype_categorical_to_other",
            "test_astype_category_ordered_none_deprecated",
            "test_quantile_multi",
            "test_unique_all_sparse",
            "test_float",
            "test_bad_arg_length_max_value_multiple",
            "_get_join_info",
            "test_difference_sort_incomparable_true",
            "_write_characteristics",
            "test_dti_tz_nat",
            "ensure_removed",
            "_isna_ndarraylike_old",
            "test_concat_sorts_columns",
            "test_arith_flex_series",
            "test_properties_weekly_legacy",
            "test_setitem_more",
            "test_index_equal_length_mismatch",
            "test_safe_names_warning",
            "test_describe_timedelta_values",
            "test_dti_isub_int",
            "test_to_datetime_format_integer",
            "_from_fastpath",
            "tree",
            "test_fillna_bug",
            "sunday_to_monday",
            "test_slice_locs",
            "test_print",
            "test_read_procedure",
            "test_cython_agg_nothing_to_agg_with_dates",
            "test_vectorized_offset_addition",
            "test_frame_equal_unicode",
            "test_onOffset",
            "test_freq_setter",
            "test_mixed_freq_regular_first_df",
            "test_uneven_lines_with_usecols",
            "test_categorical_index_repr",
            "test_grouper_index_level_as_string_series",
            "time_loc_slice",
            "test_dti_cmp_str",
            "test_usecols_with_parse_dates",
            "test_reindex_datetimeindexes_tz_naive_and_aware",
            "test_getitem_multi",
            "test_from_records_sequencelike",
            "test_apply_bad_return",
            "_unconvert_index_legacy",
            "test_to_dict_wide",
            "coerce_indexer_dtype",
            "test_cumcount",
            "test_plain_axes",
            "test_compare_hour13",
            "test_subplots_dup_columns",
            "test_wrap_agg_out",
            "test_reader_list",
            "test_precision",
            "test_excel_writer_context_manager",
            "test_ser_div_ser",
            "seed_df",
            "test_dataframe_duplicate_column_names",
            "_expand_axes",
            "test_crosstab_normalize",
            "assert_label_reference",
            "test_background_gradient_axis",
            "test_median_duplicate_columns",
            "test_find",
            "test_dt64tz_setitem_does_not_mutate_dti",
            "test_interp_various",
            "test_count_with_only_nans_in_first_group",
            "test_value_counts_unique",
            "test_itertuples",
            "test_partial_set",
            "test_factorize",
            "test_setitem_ndarray_1d",
            "test_intersect_str_dates",
            "test_coercion_with_setitem",
            "validate_argmin_with_skipna",
            "test_errorbar_with_integer_column_names",
            "test_string_slice_get_syntax",
            "test_parr_sub_pi_mismatched_freq",
            "test_parse_subtype",
            "ndim",
            "test_to_latex_decimal",
            "delete",
            "test_mixed_integer_from_list",
            "test_tdi_rmul_arraylike",
            "next_bday",
            "_is_unorderable_exception",
            "test_range_tz_dateutil",
            "all_data",
            "test_2d_fill_nonna",
            "result_index",
            "test_raise_on_mixed_dtype_usecols",
            "test_with_dictlike_columns",
            "_stata_elapsed_date_to_datetime_vec",
            "test_dti_tz_convert_tzlocal",
            "test_math_add",
            "_can_hold_element",
            "test_is_sequence",
            "test_divmod_scalar",
            "test_comment_skiprows",
            "_reset_option",
            "test_apply_reduce_rows_to_dict",
            "test_series_groupby_value_counts",
            "test_constructor_with_embedded_frames",
            "test_none_coercion_mixed_dtypes",
            "test_dataframe_dummies_mix_default",
            "test_dataframe_dummies_all_obj",
            "test_empty_index_name_doesnt_display",
            "test_arithmetic_overflow",
            "test_getitem_setitem_boolean_misaligned",
            "test_full_file_with_spaces_and_missing",
            "test_to_string_dtype",
            "test_axis_share_xy",
            "test_set_index_raise_on_len",
            "test_constructor_nonhashable_names",
            "test_ops_consistency_on_empty",
            "_add_numeric_methods_disabled",
            "set_index",
            "_is_scalar_access",
            "test_parse_public_s3_bucket_nrows",
            "test_exit_status_for_validate_one",
            "test_pytables_native2_read",
            "_parse_tfoot_tr",
            "test_categorical_equal_categories_mismatch",
            "time_loc_scalar",
            "clean",
            "test_iterator_loop",
            "time_to_datetime_dayfirst",
            "test_column_dups_indexing",
            "test_to_datetime_iso8601_noleading_0s",
            "keys",
            "get_bool_data",
            "from_custom_template",
            "test_from_to_scipy",
            "test_stable_categorial",
            "test_groupsort_indexer",
            "time_join_dataframe_index_single_key_bigger",
            "test_rsplit_to_multiindex_expand",
            "test_dtypes_gh8722",
            "test_one_level_deep_flattens",
            "test_constructor_rec",
            "test_nan_selection_bug_4858",
            "test_agg_list_like_func",
            "test_union_categorical_unwrap",
            "run_arithmetic",
            "test_series_unnamed",
            "test_qcut",
            "test_series_partial_set_datetime",
            "test_convert_array_of_periods",
            "time_frame_drop_dups",
            "_skip_if_no_project_id",
            "test_frame_reset_index",
            "test_read_chunksize_and_nrows",
            "sparse_df",
            "test_good_functions",
            "infer_freq",
            "test_timedelta_hash_equality",
            "test_ufunc_coercions",
            "test_plot",
            "test_tolerance_nearest",
            "previous_friday",
            "assert_multiindex_copied",
            "test_constructor_cant_cast_period",
            "test_usecols_excel_range_str_invalid",
            "test_sort_non_lexsorted",
            "_convert_index",
            "_get_skiprows",
            "check_is_index",
            "test_to_string_repr_unicode",
            "_check_file_or_buffer",
            "test_dt64ser_sub_datetime_dtype",
            "test_ops_error_str",
            "compare_index_period",
            "test_groupby_name_propagation",
            "test_header_with_index_col",
            "test_to_datetime_parse_timezone_keeps_name",
            "test_double_precision",
            "type",
            "create_data",
            "test_datetime_cut",
            "test_pyarrow",
            "test_setindex",
            "test_groupby_aggregation_mixed_dtype",
            "test_isin_with_string_scalar",
            "test_value_vars",
            "test_combine_first_period",
            "_is_label_like",
            "test_sum_bools",
            "test_convert_preserve_bool",
            "test_union_categoricals_ignore_order",
            "test_contains_nans",
            "time_groupby_nosort",
            "classes_and_not_datetimelike",
            "test_to_object_array_tuples",
            "frame",
            "is_all_dates",
            "assert_same_resolution",
            "time_resample",
            "test_op",
            "_decode",
            "_construct",
            "_interp_limit",
            "test_categorical_no_compress",
            "test_get_dtype_error_catch",
            "test_sort_index_na_position",
            "write_to_version_file",
            "_generate_regular_range",
            "test_getitem_nat",
            "test_sorting_repr_8017",
            "test_validate_reduction_keyword_args",
            "test_droplevel_with_names",
            "test_where_empty_df_and_empty_cond_having_non_bool_dtypes",
            "test_concat_series_axis1_names_applied",
            "test_begin_year_alias",
            "read_block_index",
            "_is_compatible_with_other",
            "test_dict_numpy_complex",
            "test_construction_with_dtype",
            "test_deepcopy",
            "monotonic_index",
            "test_rdivmod_pytimedelta",
            "test_non_hashable",
            "test_strip_lstrip_rstrip",
            "test_count_cross_type",
            "test_sort_index_level_by_name",
            "_take_nd_object",
            "test_context",
            "visit_Assign",
            "test_cast_1d_array",
            "__radd__",
            "_interleave",
            "test_integer_index_astype_datetime",
            "time_frame_object_equal",
            "test_is_level_reference_series_axis1_error",
            "slice_replace",
            "time_get_loc_scalar",
            "test_memory_map",
            "_get_take_nd_function",
            "test_map_dict_with_tuple_keys",
            "test_compare_1700",
            "_try_convert_data",
            "test_categorical_series_repr_period_ordered",
            "test_is_not_signed_integer_dtype",
            "__repr__",
            "test_equality_invalid",
            "_read_float",
            "test_dt64arr_add_dt64ndarray_raises",
            "test_rich_comparison_with_unsupported_type",
            "test_parse_public_s3a_bucket",
            "_to_ijv",
            "test_range_tz_dst_straddle_pytz",
            "test_header_and_index_with_types",
            "test_uhf",
            "test_constructor_maskedarray_hardened",
            "test_iloc_duplicates",
            "_get_level_indexer",
            "test_sort_multi_index",
            "test_ragged_var",
            "_repr_attrs",
            "test_basic_left_by_right_by",
            "test_qcut_all_bins_same",
            "_argminmax_wrap",
            "test_kde_colors_and_styles_subplots",
            "_ensure_datetimelike_to_i8",
            "test_index_col_label_error",
            "test_with_nan",
            "test_get_attributes",
            "get_config_from_root",
            "time_category_size",
            "_infer_tz_from_endpoints",
            "test_loc_str_slicing",
            "test_split_compat",
            "close",
            "test_astype_assignment",
            "test_implementation_limits",
            "test_rolling_apply_out_of_bounds",
            "test_float_suffix",
            "test_intercept_astype_object",
            "to_pickle",
            "test_append_misc",
            "test_align_mixed_float",
            "_maybe_numeric_slice",
            "test_dict_float",
            "test_merge_indexes_and_columns_on",
            "summary",
            "test_reading_all_sheets_with_blank",
            "time_reindex_upcast",
            "test_maybe_promote_any_with_object",
            "test_comparison_tzawareness_compat_scalars",
            "test_categorical_index_repr_period_ordered",
            "test_tidy_repr",
            "test_constructor_dict_of_generators",
            "test_groupby_apply_all_none",
            "test_multi_iter_frame",
            "test_get_indexer_length_one",
            "test_non_unique_pickle",
            "read_stata",
            "test_rank_max_pct",
            "test_get_freq_roundtrip",
            "test_infer_freq_tz",
            "test_day_not_in_month_raise",
            "test_intra_day_conversion_factors",
            "_sql_type_name",
            "_get_fill_indexer_searchsorted",
            "test_transform_multiple",
            "_check_iris_loaded_frame",
            "test_basic_period_index_subscript_expression",
            "test_any_all_object",
            "test_td64arr_addsub_anchored_offset_arraylike",
            "test_lookup_basics",
            "check_reduce",
            "test_unstack_dtypes",
            "test_margins",
            "test_ufuncs_single_float",
            "time_ix_list_like",
            "test_date_range_multiplication_overflow",
            "_copy",
            "right_df",
            "test_default_fill_value_with_no_data",
            "reindex_indexer",
            "test_figsize",
            "_drop_from_level",
            "dt64arr_cmp_non_datetime",
            "test_CategoricalAccessor_name_deprecation",
            "is_offsetlike",
            "rxor",
            "test_getitem_ndarray_3d",
            "test_series_from_coo_incorrect_format_raises",
            "test_compare_tick",
            "resolution",
            "test_replace_gh5319",
            "test_pack_ext_type",
            "ascending",
            "test_timeseries_coercion",
            "test_infinity_against_nan",
            "test_skip_rows_callable",
            "rjust",
            "test_skiprows_list",
            "test_cdaterange_weekmask_and_holidays",
            "str_slice",
            "test_concat_will_upcast",
            "object_series",
            "test_series_from_json_precise_float",
            "test_repr_chop_threshold_column_below",
            "test_read_timezone_information",
            "test_period_array_non_period_series_raies",
            "_filter_nodes",
            "_infer_fill_value",
            "test_ix_setitem_out_of_bounds_axis_0",
            "test_assert_almost_equal_value_mismatch2",
            "test_reindex_methods",
            "_get_format_datetime64",
            "test_setops_disallow_true",
            "test_fillna_copies",
            "test_invalid_file_not_written",
            "test_dt64_ser_cmp_date_warning",
            "test_df_mod_zero_array",
            "test_setitem_list",
            "test_aggregate_item_by_item",
            "test_assert_almost_equal_numbers",
            "test_setitem_index_float64",
            "get_pairs",
            "test_tdi_shift_int",
            "test_double_long_numbers",
            "test_subclass_sparse_to_frame",
            "test_rename_axis_raises",
            "test_bounds_check_large",
            "test_iteration_open_handle",
            "test_numpy_compat",
            "test_end_year_alias",
            "test_left_join_indexer_unique",
            "test_nulls",
            "test_constructor_int_dtype_nan",
            "test_series_fillna_limit",
            "test_bool_types",
            "test_to_datetime_types",
            "test_bool_arith_expr",
            "test_from_tuples_index_values",
            "test_bool_ops_fails_on_scalars",
            "time_iloc_list_like",
            "test_color_empty_string",
            "test_numpy_any",
            "test_series_getitem_not_sorted",
            "test_astype_from_datetimelike_to_objectt",
            "test_eof_states",
            "test_dt_namespace_accessor_categorical",
            "test_astype_more",
            "test_missing_values",
            "test_stata_111",
            "test_array_float",
            "test_empty_frame_dtypes_ftypes",
            "setup_import",
            "table_type_short",
            "test_header_and_one_column",
            "test_apply_axis1",
            "test_deprecated_to_dense",
            "test_subclass_pivot",
            "test_merge_left_empty_right_empty",
            "test_constructor_dtype_no_cast",
            "test_to_csv_unicodewriter_quoting",
            "test_constructor_subclass_dict",
            "test_rank_desc_mix_nans_infs",
            "test_reindex_preserves_names_when_target_is_list_or_ndarray",
            "test_cannot_item_assign",
            "test_to_offset_leading_zero",
            "test_tz_standardize",
            "test_partial_slicing_dataframe",
            "test_skiprows_invalid",
            "_get_data_algo",
            "validate_read",
            "_validate_flavor",
            "test_single_invert_op",
            "test_dti_tz_localize_ambiguous_nat",
            "__len__",
            "test_scalar_unary",
            "test_zip_error_no_files",
            "_return_parsed_timezone_results",
            "empty_frame",
            "test_fillna_empty",
            "test_constructor_invalid_args",
            "_take",
            "test_upsample_sum",
            "_maybe_parse_dates",
            "test_mi_sparse_disabled",
            "masked_rec_array_to_mgr",
            "_maybe_cast",
            "test_numpy_func_call",
            "ordered_fixture",
            "test_maybe_mangle_lambdas",
            "test_get_standard_colors_default_num_colors",
            "test_mixed_timedelta_datetime",
            "_get_level_lengths",
            "test_ragged_kurt",
            "test_constructor_from_series_dtlike",
            "take_invalid_kwargs",
            "test_arith_alignment_non_pandas_object",
            "_to_sql_save_index",
            "test_fields",
            "test_tdi_iadd_timedeltalike",
            "test_constructor_preserve_attr",
            "test_get_unique_index",
            "test_unstack_fill_frame_categorical",
            "_is_visible",
            "time_subtract",
            "test_floordiv_zero",
            "test_datetime64_dtype_array_returned",
            "_slice_take_blocks_ax0",
            "where",
            "_floatify_na_values",
            "_factorize_from_iterable",
            "test_store_hierarchical",
            "_setitem_frame",
            "test_get_dtype_kinds",
            "test_on_and_index",
            "test_local_file",
            "test_sparse_series_unstack",
            "_check_has_errorbars",
            "test_categorical_sideeffects_free",
            "test_constructor_limit_copies",
            "test_errorbar_with_partial_columns",
            "test_store_index_name_with_tz",
            "test_conv_minutely",
            "_zip_axes_from_type",
            "time_series_drop_dups_string",
            "test_repr_html_long",
            "test_decode_number_with_32bit_sign_bit",
            "test_setitem_array",
            "rstrip",
            "_construct_axes_dict_for_slice",
            "test_grow_boundary_at_cap",
            "test_spss_labelled_num",
            "test_sparse_to_dense",
            "_process_subheader_pointers",
            "testMult1",
            "test_where_with_numeric_data",
            "test_agg_apply_evaluate_lambdas_the_same",
            "read_column",
            "_series",
            "_get_page_title",
            "time_c_ordered",
            "validate_version",
            "_intersection_non_unique",
            "test_iloc_col",
            "_check_all_fields",
            "test_gzip_writing",
            "_construct_divmod_result",
            "test_tuple_categories",
            "test_consistent_format",
            "test_unstack_sparse_keyspace",
            "test_where_unsafe",
            "test_fillna_categorical_nan",
            "test_read_nrows_large",
            "test_usecols_diff_positional_int_columns_order",
            "test_is_offsetlike",
            "test_wide_repr_multiindex",
            "test_series_density",
            "_combine_frame",
            "test_apply_nonuq",
            "test_bad_month_fail",
            "test_as_json_table_type_bool_data",
            "test_iloc_mask",
            "datetime_tz_utc",
            "test_index_ctor_infer_nat_dt_like",
            "test_td_sub_mixed_most_timedeltalike_object_dtype_array",
            "test_generated_op_names",
            "day_opt",
            "test_sub_fail",
            "_make_wrapped_arith_op",
            "test_select_as_multiple",
            "test_nanskew",
            "parser_and_data",
            "_get_sheet_name",
            "_partial_date_slice",
            "test_datetimeindex_from_empty_datetime64_array",
            "test_groupby_selection_with_methods",
            "_get_timestamp_range_edges",
            "test_setitem_series_object",
            "test_dt64arr_add_sub_offset_ndarray",
            "test_read_dta12",
            "test_period_cons_quarterly",
            "_read_sql_iris_named_parameter",
            "_do_convert_missing",
            "test_operators_timedelta64_with_timedelta",
            "test_map_datetimetz",
            "test_construction_with_categorical_dtype",
            "optional_args",
            "test_construction_overflow",
            "time_itertuples_raw_read_first",
            "_handle",
            "test_apply_axis",
            "read_sql_query",
            "test_groupby_corner",
            "test_head_tail",
            "test_setitem_loc_scalar_multiple_homogoneous",
            "test_concat_categorical_coercion",
            "test_td_rfloordiv_invalid_scalar",
            "_make_table",
            "_is_single_block",
            "test_with_dictlike_columns_with_infer",
            "test_constructor_pi_nat",
            "test_array_hook",
            "row_levels",
            "test_to_tuples",
            "time_freqstr",
            "_first_fill_value_loc",
            "get_fill_func",
            "_convert_listlike_datetimes",
            "test_transpose_object_to_tzaware_mixed_tz",
            "test_malformed_skipfooter",
            "test_combine_first_with_dense",
            "get_engine",
            "time_read_uint64_neg_values",
            "start_time",
            "test_file_like_no_next",
            "time_datetime_field_daysinmonth",
            "test_series_interpolate_intraday",
            "test_getitem_boolean_iadd",
            "test_swaplevel",
            "test_iat_fill_value",
            "error",
            "test_dti_convert_datetime_list",
            "test_nanmedian",
            "method_returns_something",
            "test_append_raise",
            "test_maybe_indices_to_slice_both_edges",
            "test_ffill_not_in_axis",
            "tzinfo",
            "time_floats_with_int_index",
            "is_multi_index",
            "test_xs_keep_level",
            "test_ngroup_dupe_index",
            "test_update_raise_on_overlap",
            "time_series_float",
            "test_pivot_integer_bug",
            "test_mixed_dtype_insert",
            "ewm",
            "_aggregate_item_by_item",
            "pop",
            "check_opname",
            "_indexed_same",
            "nsmallest",
            "pipe",
            "test_index_make_union",
            "test_neg_raises",
            "test_construction_month",
            "test_filename_with_special_chars",
            "test_valid_dt_with_missing_values",
            "test_decode_with_trailing_non_whitespaces",
            "test_where_align",
            "test_read_excel_multiindex",
            "test_dti_cmp_nat",
            "test_stack_unstack_preserve_names",
            "test_datetimetz_dtype_match",
            "test_join_on_fails_with_different_right_index",
            "test_with_multi_index",
            "test_get_weeks",
            "time_take",
            "test_drop_labels_or_levels_df",
            "test_date_range_span_dst_transition",
            "test_merge_copy",
            "get_kwargs_from_breaks",
            "test_str_query_method",
            "test_int64_uint64_range",
            "test_update_dtypes",
            "test_representation_to_series",
            "test_incorrect_type_map",
            "test_unpacker_ext_hook",
            "test_index_equal_levels_mismatch",
            "test_sas_read_no_format_or_extension",
            "test_nan_in_object_array",
            "test_isna_nat",
            "test_quantile_interpolation_int",
            "time_lookup_loc",
            "test_excel_multindex_roundtrip",
            "__delitem__",
            "convert_missing_indexer",
            "_codes_for_groupby",
            "test_combine_scalar",
            "read_query",
            "time_series_loc",
            "test_index_col_empty",
            "test_math_mult",
            "test_tdi_add_integer_array",
            "test_frame_non_unique_columns",
            "test_string_index_alias_tz_aware",
            "test_errors_invalid_value",
            "test_timestamp_compare_series",
            "cat_core",
            "test_empty_print",
            "_try_convert_to_int_index",
            "test_groupby_transform_with_nan_group",
            "_validate",
            "TextParser",
            "test_between_time_axis",
            "test_groupby_multiindex_nat",
            "test_datetime_tz",
            "test_filter_nan_is_false",
            "time_rstrip",
            "_op_maker",
            "test_series_groupby_nunique",
            "test_constructor_infer_freq",
            "test_nans",
            "test_groupby_resample_on_api",
            "test_to_html_compat",
            "test_dt64_series_arith_overflow",
            "time_frame_drop_dups_na",
            "_make_reader",
            "test_rename_positional_named",
            "get_iterator",
            "test_plotting_with_float_index_works",
            "write_style",
            "test_ftypes",
            "test_astype_categoricaldtype_class_raises",
            "_populate_tables",
            "period_array",
            "test_to_latex_series",
            "resolve_name",
            "_get_handle",
            "is_monotonic",
            "test_raise_on_sep_with_delim_whitespace",
            "test_str_max_colwidth",
            "test_unstack_level_binding",
            "test_construction_with_alt",
            "test_deprecation",
            "_put_str",
            "test_render",
            "test_concatlike_common_period",
            "test_unary_ufunc",
            "test_getitem_setitem_boolean_corner",
            "pathname",
            "test_td64arr_add_sub_td64_nat",
            "test_pivot_tz_in_values",
            "test_rolling_median_memory_error",
            "test_no_pairwise_with_other",
            "test_series_getitem_duplicates_multiindex",
            "test_get_dtype_kinds_period",
            "test_secondary_y",
            "test_float64index_slicing_bug",
            "render_templates",
            "time_ix_slice",
            "test_illegal_names",
            "test_subtype_conversion",
            "test_mixed_string_strl",
            "_get_attributes_dict",
            "first_valid_index",
            "_build_doc",
            "index_pair",
            "maybe_cast_to_datetime",
            "test_where_invalid_input_single",
            "test_dtype_str",
            "_index_freq",
            "test_gcs_get_filepath_or_buffer",
            "test_astype_invalid_dtype",
            "test_compare_array",
            "test_nearest_upsample_with_limit",
            "test_resample_with_non_zero_base",
            "test_where_index_bool",
            "test_dti_shift_no_freq",
            "test_rename_axis_style_raises",
            "test_table_index_incompatible_dtypes",
            "time_dtindex_from_index_with_series",
            "test_extractall_errors",
            "visit_BinOp",
            "test_constructor_mismatched_raises",
            "time_method",
            "test_setitem_corner2",
            "test_infer_dtype_from_boolean",
            "find",
            "_ensure_str",
            "test_tz_localize_pushes_out_of_bounds",
            "_from_axes",
            "test_constructor_single_level",
            "root",
            "data_repeated",
            "test_numpy_dtypes",
            "test_round_tzaware",
            "test_as_json_table_type_float_data",
            "_coerce_to_ndarray",
            "is_monotonic_increasing",
            "test_constructor_broadcast_list",
            "test_cython_grouper_series_bug_noncontig",
            "test_int_properties",
            "test_numarr_with_dtype_add_int",
            "test_to_datetime_coerce",
            "test_to_datetime_with_apply",
            "test_getitem_setitem_datetimeindex",
            "test_astype_object",
            "test_cdaterange_holidays",
            "test_pass_datetimeindex_to_index",
            "test_add",
            "test_on_offset",
            "test_is_nested_list_like_passes",
            "test_valid_tolerance",
            "test_css_precedence",
            "test_append_duplicates",
            "_convert_strls",
            "_get_colors_mapped",
            "test_corrwith_kendall",
            "test_dask",
            "test_sparse_series_ops_i",
            "test_group_var_generic_1d",
            "from_dict",
            "test_to_string_length",
            "__array_wrap__",
            "test_setitem_list_not_dataframe",
            "test_to_html_unicode",
            "test_first_last_valid",
            "test_frame_equal_row_order_mismatch",
            "validate_dataframe",
            "test_autocorr",
            "test_exactly_one_ref",
            "test_constructor_str_unknown",
            "test_to_frame_resulting_column_order",
            "test_hist_no_overlap",
            "test_index_contains",
            "coerce_to_dtypes",
            "test_2d_with_out",
            "test_transform_function_aliases",
            "test_loc_setitem_corner",
            "test_setitem_series",
            "test_range_closed_boundary",
            "test_split_to_dataframe",
            "head",
            "test_intersection_equal_sort",
            "test_with_nested_series",
            "test_asfreq_datetimeindex",
            "test_getitem_median_slice_bug",
            "test_store_mixed",
            "test_divmod_series_array",
            "masked_arith_op",
            "time_from_date_range",
            "test_invalid_skipfooter_non_int",
            "time_series_nth_all",
            "date_range",
            "test_read_excel_parse_dates",
            "_try_convert_dates",
            "test_replace_simple_nested_dict",
            "test_tick_normalize_raises",
            "check_dtypes",
            "time_dt_accessor_day_name",
            "test_arith_flex_frame_raise",
            "test_return_type",
            "_set_with_engine",
            "test_intersection_non_monotonic",
            "test_comment",
            "test_operators_frame",
            "test_copy_method",
            "time_len_groupby_object",
            "swapaxes",
            "test_alternate_encoding",
            "time_groupby_ordered_sort",
            "test_tolerance_float",
            "test_get_filepath_or_buffer_with_path",
            "test_min_max_empty",
            "test_basic_dtype",
            "test_join",
            "test_dti_representation",
            "test_constructor_with_win_type",
            "is_platform_linux",
            "time_apply_np_dt64",
            "meta",
            "test_bad_date_parse",
            "test_dtype_coerceion",
            "test_resample_extra_index_point",
            "test_years_only",
            "_dense_series_compare",
            "test_line_use_index_false",
            "test_resample_integerarray",
            "load_workbook",
            "test_apply_frame_concat_series",
            "test_ix_slicing_strings",
            "test_extractall",
            "_transform_general",
            "test_td64arr_add_sub_timestamp",
            "test_td_rfloordiv_timedeltalike_array",
            "test_mode_empty",
            "test_raise_if_too_few",
            "test_transform_axis",
            "test_bar_align_left",
            "test_dt64arr_cmp_scalar_invalid",
            "test_td_add_datetimelike_scalar",
            "return_not_documented",
            "test_connectable_issue_example",
            "test_where_ndframe_align",
            "test_out_of_bounds_value",
            "from_product",
            "test_is_strictly_monotonic_increasing",
            "test_sort_index_kind",
            "_get_marker_compat",
            "test_constructor_dict_block",
            "test_complex_across_dimensions",
            "test_groups",
            "test_resample_timegrouper",
            "test_astype_generic_timestamp_no_frequency",
            "_to_sql_append",
            "test_frame_indexing_multiple",
            "argsort",
            "_new_Index",
            "_scalar_type",
            "test_groupby_duplicated_column_errormsg",
            "test_equal_Raises_Value",
            "drop",
            "test_dti_construction_ambiguous_endpoint",
            "_factorize_from_iterables",
            "test_excel_old_index_format",
            "test_categories_assigments",
            "test_pi_add_offset_n_gt1_not_divisible",
            "_get_unicode_name",
            "test_to_string_float_index",
            "test_hexbin_cmap",
            "_make_arithmetic_op",
            "test_scatter_colors",
            "test_properties_weekly",
            "test_interp_quad",
            "test_operators_timedelta64",
            "test_margins_no_values_one_row_one_col",
            "test_nancorr_spearman",
            "sections_in_wrong_order",
            "test_agg_datetimes_mixed",
            "test_cython_transform_frame",
            "test_comparisons_nat",
            "test_series_with_dtype_radd_timedelta",
            "_ensure_scope",
            "test_setitem_empty_frame_with_boolean",
            "test_rsub_object",
            "arrays_to_mgr",
            "pie",
            "test_no_rounding_occurs",
            "test_is_int64_dtype",
            "get_atom_datetime64",
            "tquery",
            "time_frame_float_floor_by_zero",
            "test_append_all_nans",
            "test_categorical_block_pickle",
            "test_empty_dataframe_groupby",
            "test_dti_add_intarray_non_tick",
            "test_subtraction_ops_with_tz",
            "test_loc_iloc_frame_single_dtype",
            "test_maybe_numeric_slice",
            "deprecate",
            "_write_variable_labels",
            "test_timedelta_fillna",
            "test_valid_default_arguments",
            "testStrictUnicodeUnpack",
            "_iterate_slices",
            "test_neg_object",
            "test_to_timestamp_freq",
            "test_replace_with_no_overflowerror",
            "test_stack_level_name",
            "check_bool",
            "_convert_to_border",
            "test_encode_list_long_conversion",
            "test_construction_bday",
            "test_ew_empty_series",
            "test_to_string_truncate_multilevel",
            "_check_axes_shape",
            "test_append_with_data_columns",
            "test_to_csv_single_level_multi_index",
            "time_no_exact",
            "filename",
            "test_delta_preserve_nanos",
            "test_constructor_periodindex",
            "format_timedelta_ticks",
            "test_pivot_table_dropna_categoricals",
            "test_dataframe_dummies_drop_first",
            "test_testing",
            "test_max_array_len",
            "test_store_index_types",
            "test_spss_labelled_str",
            "test_concat_iterables",
            "test_encode_array_of_nested_arrays",
            "test_setitem_slice_mismatch_length_raises",
            "test_finder_minutely",
            "create_table_index",
            "test_period_dtype_match",
            "test_dataframe_repr",
            "time_dup_string_dates",
            "_create_index",
            "test_applymap",
            "test_count_uses_size_on_exception",
            "peakmem_itertuples_to_list",
            "test_pivot_duplicates",
            "test_groupby_blacklist",
            "test_multiple_ouput_ufunc",
            "time_series_ix",
            "time_series_to_frame",
            "_skip_if_no_scipy",
            "time_copy_overhead_single_col",
            "to_sparse",
            "test_epoch",
            "test_join_multi_levels2",
            "test_ops_frame_period",
            "test_parse_date_fields",
            "_assert_not_series_equal",
            "set_function_name",
            "_set_as_cached",
            "_blklocs",
            "test_transform_exclude_nuisance",
            "_get_format_timedelta64",
            "test_fwf_colspecs_infer_nrows",
            "test_extension_array_labels",
            "test_sum_object",
            "test_getitem_setitem_boolean_multi",
            "get_labels_levels",
            "test_join_period_index",
            "test_mixed_comparison",
            "time_to_sql_dataframe",
            "test_constructor_dict_timedelta64_index",
            "test_day_corner",
            "snap",
            "test_ints",
            "test_bool_with_none",
            "test_where_unobserved_nan",
            "test_fixarray",
            "all_numeric_reductions",
            "test_write_append_mode",
            "test_series_set_value",
            "_maybe_wrap_formatter",
            "test_groupby_max_datetime64",
            "test_banklist_url",
            "test_series_not_equal_metadata_mismatch",
            "test_series_setitem",
            "test_downcast_basic",
            "test_loc_with_interval",
            "test_contiguous_mixed_data_table",
            "reorder_categories",
            "test_delete_raises",
            "check_single_invert_op",
            "time_subtract_datetimes",
            "_maybe_promote",
            "test_disallow_scalar_bool_ops",
            "test_multiindex_slice_first_level",
            "test_chunk_begins_with_newline_whitespace",
            "time_getitem_lists",
            "test_loc_setitem_boolean",
            "test_notEqual",
            "test_between_time_types",
            "test_lexsort_indexer",
            "year_has_extra_week",
            "test_stable_descending_multicolumn_sort",
            "test_booleanindex",
            "test_empty_pass_dtype",
            "test_errorbar_timeseries",
            "test_array_i8_dtype",
            "test_nankurt",
            "test_boolean_slice_empty",
            "sort_names",
            "test_object_factorize",
            "test_series_agg_multi_pure_python",
            "maybe_castable",
            "test_setitem_raises_incompatible_freq",
            "_is_dates_only",
            "test_min_fitting_element",
            "sort_values",
            "test_categorical_index_repr_timedelta",
            "test_item_name",
            "test_pandas_plots_register",
            "test_convert_pandas_type_to_json_field_int",
            "test_groupby_transform_with_datetimes",
            "test_match_findall_flags",
            "_skip_if_no_mpl",
            "time_frame_mask_bools",
            "process_skipna",
            "test_isin_nan_pypy",
            "test_time_series_plot_color_with_empty_kwargs",
            "finalize_options",
            "time_iloc_dups",
            "test_period_dtype",
            "test_rolling_std_neg_sqrt",
            "test_isin_df",
            "test_conv_weekly",
            "test_repr_binary_type",
            "test_modulus",
            "test_expanding_apply_args_kwargs",
            "test_bdays_and_open_boundaries",
            "test_write_missing_strings",
            "test_as_json_table_type_string_dtypes",
            "time_concat_mixed_ndims",
            "test_scalar_complex",
            "test_resolution",
            "test_iter",
            "mask_cmp_op",
            "test_assert_not_almost_equal_iterables",
            "test_cython_median",
            "test_crosstab_no_overlap",
            "test_loc_setitem_empty_append",
            "test_boolean_ops",
            "test_groupby_average_dup_values",
            "test_cat_on_filtered_index",
            "test_series_equal_length_mismatch",
            "test_invalid_colormap",
            "test_reshaping_multi_index_categorical",
            "__sub__",
            "test_date_query_no_attribute_access",
            "time_frame_add",
            "test_missing_value_conversion",
            "test_asfreq_fillvalue",
            "test_complex_indexing_error",
            "test_read_sql_iris",
            "test_get_offset_legacy",
            "test_skipfooter_with_decimal",
            "time_wide_to_long_big",
            "test_groupby_groups_in_BaseGrouper",
            "test_datetime_timedelta_quantiles",
            "test_query_inplace",
            "test_timestamp_add_timedelta64_unit",
            "test_astype_str_map",
            "test_invalid_unit",
            "test_decode_array",
            "test_set_item",
            "test_get_label_or_level_values_df_ambig",
            "test_to_coo_nlevels_less_than_two",
            "test_get_code_invalid",
            "nanvar",
            "time_index_from_array_floats",
            "_convert_by",
            "test_basic_indexing",
            "test_time_overflow_for_32bit_machines",
            "test_to_string_na_rep",
            "_create_categorical",
            "test_xs_named_levels_axis_eq_1",
            "_get_footer",
            "test_addition_subtraction_preserve_frequency",
            "test_apply_use_categorical_name",
            "test_timedelta_arithmetic",
            "test_duplicated_nan_none",
            "test_constructor_arrays_negative_year",
            "get_hits",
            "test_non_sorted",
            "test_dti_tz_convert_compat_timestamp",
            "test_info_categorical_column",
            "test_to_sql_save_index",
            "close_open_fixture",
            "test_9",
            "test_infer_types",
            "test_join_empty_bug",
            "_adjust_bin_edges",
            "test_rank_object_bug",
            "test_has_duplicates_overflow",
            "test_constructor_dataframe",
            "_get_time_micros",
            "test_pi_shift_ndarray",
            "test_sortlevel_deterministic",
            "test_parse_date_float",
            "_check_offsetfunc_works",
            "test_observed",
            "_write_varnames",
            "test_argsort_missing",
            "_add_numeric_methods_unary",
            "test_td64arr_sub_timedeltalike",
            "time_i8merge",
            "test_getitem_setitem_slice_integers",
            "test_sparse",
            "merge_asof",
            "test_range_slice_seconds",
            "test_write_multiindex",
            "test_pi_add_sub_td64_array_tick",
            "_box_col_values",
            "test_mul_size_mismatch_raises",
            "test_format_datetime_with_time",
            "test_resample_unequal_times",
            "srcpath",
            "_evaluate_with_datetime_like",
            "_comp_method_OBJECT_ARRAY",
            "_annual_finder",
            "test_get_label_or_level_values_series_axis0",
            "test_interp_limit_before_ends",
            "set_error_bad_lines",
            "test_categorical_dtype_missing",
            "test_replace_callable",
            "any",
            "test_resample_ohlc_result",
            "time_nested_dict",
            "skipif_32bit",
            "format_name",
            "test_join_multi_dtypes",
            "test_all_finite",
            "test_start_stop_table",
            "test_series_grouper",
            "test_pickle_v0_14_1",
            "_has_names",
            "read_dta",
            "_format_with_header",
            "_partial_td_slice",
            "test_nested_raises_on_local_self_reference",
            "normalize",
            "_execute_sql",
            "test_categorical_equal_order_mismatch",
            "time_groupby_extra_cat_sort",
            "test_crosstab_single",
            "test_read_excel_squeeze",
            "test_df_add_2d_array_collike_broadcasts",
            "time_factorize",
            "is_datetime64_any_dtype",
            "test_mi_sparse",
            "test_if_scatterplot_colorbars_are_next_to_parent_axes",
            "test_truthiness",
            "_sparse_series_op",
            "test_with_max_level",
            "_series_and_2d_ndarray",
            "test_set_option",
            "test_with_offset",
            "_get_row_repeat",
            "_has_plotted_object",
            "test_xs_missing_values_in_index",
            "test_raw16",
            "test_basic_period_index_boolean_expression",
            "isnull",
            "test_equals_categorical",
            "test_difference_dupe",
            "test_deprecated_get_values",
            "_kind",
            "test_ignore_downcast_invalid_data",
            "test_regex_replace_dict_mixed",
            "test_annual_ambiguous",
            "test_rdivmod_invalid",
            "test_map_categorical",
            "T",
            "test_concat_inner_sort",
            "test_is_hashable",
            "test_pie_nan",
            "is_numeric_dtype",
            "time_apply_user_func",
            "test_concat_dict",
            "test_simple_normalize",
            "test_compressed_urls",
            "test_properties_business",
            "test_any_all_level_axis_none_raises",
            "_gen_fill_zeros",
            "add_prefix",
            "test_to_sql_empty",
            "test_count_level",
            "test_duplicated_on_empty_frame",
            "test_parse_public_s3n_bucket",
            "_format_attrs",
            "test_window_with_args",
            "test_constructor_compound_dtypes",
            "clean_up",
            "time_corrwith_cols",
            "test_boolean_set_uncons",
            "_check_if_open",
            "test_assert_almost_equal_inf",
            "test_frame_comparison",
            "test_unit_mixed",
            "test_groupby_transform_with_int",
            "test_notna",
            "_validate_for_numeric_binop",
            "test_detect_chained_assignment_warnings_filter_and_dupe_cols",
            "assert_sp_array_equal",
            "test_repr_unsortable",
            "test_set_axis_name_raises",
            "_parse_numpy",
            "test_astype_index",
            "to_parquet",
            "_maybe_get_mask",
            "test_dti_set_index_reindex",
            "test_stack_preserve_categorical_dtype",
            "test_set_axis_prior_to_deprecation_signature",
            "test_is_numeric_honored",
            "test_unknown_engine",
            "from_coo",
            "test_misspecified",
            "test_setitem_with_string_index",
            "create_mgr",
            "test_indexing_over_hashtable_size_cutoff",
            "test_merge_equal_cat_dtypes",
            "test_from_file",
            "test_fillna_col_reordering",
            "fetch",
            "test_td64arr_div_numeric_scalar",
            "_get_single_key",
            "test_setitem_multiindex",
            "test_abc_types",
            "test_is_scalar_pandas_scalars",
            "test_resample_nunique",
            "test_from_sequence_from_cls",
            "ensure_python_int",
            "read_sql",
            "str_encode",
            "na_value_for_dtype",
            "parser",
            "test_no_nonsense_name",
            "test_unicode_string_with_unicode",
            "test_int_bins_with_inf",
            "test_properties_monthly",
            "_maybe_rename_join",
            "make_block_array",
            "test_hash_pandas_object_works",
            "_decorate_axes",
            "_cumcount_array",
            "test_insert_with_columns_dups",
            "time_pivot_table_margins",
            "test_no_new_locals",
            "is_bool",
            "setup_method",
            "time_frame_duplicated",
            "test_select_iterator_many_empty_frames",
            "_replace_booleans",
            "test_quarterly_dont_normalize",
            "test_really_large_scalar",
            "test_concat_axis_parameter",
            "test_cast_1d_array_like_from_scalar_categorical",
            "test_construction_list_mixed_tuples",
            "test_simple_arith_ops",
            "test_value_labels_old_format",
            "_remove_empty_lines",
            "test_cmov_window_special",
            "test_maybe_indices_to_slice_right_edge",
            "can_set_locale",
            "test_repr_html_long_and_wide",
            "test_rename_mapper_multi",
            "test_where_index_complex128",
            "test_construct_over_dst",
            "_get_grouper_for_level",
            "test_frame_setitem_copy_raises",
            "_check_visible",
            "_check_legend_labels",
            "test_constructor_with_tz",
            "test_sort_index_intervals",
            "test_frame_append_datetime64_col_other_units",
            "test_groupby_includes_fill_value",
            "test_make_time_series",
            "test_thead_without_tr",
            "test_contains_method",
            "time_isnull_strngs",
            "test_lookup",
            "test_constructor_period_incompatible_frequency",
            "weekend_to_monday",
            "__rfloordiv__",
            "test_reset_index_with_intervals",
            "_maybe_fill",
            "test_get_label_or_level_values_df_simple",
            "test_to_timestamp_tz_arg_dateutil_from_string",
            "test_fails_or",
            "test_different_normalize_equals",
            "get_config",
            "test_read_unsupported_compression_type",
            "is_string_like_dtype",
            "test_springforward_plural",
            "test_intersection_cases",
            "test_secondary_y_regular_ts_xlim",
            "_translate",
            "test_df_float_none_comparison",
            "test_at_time_axis",
            "test_repeat_raises",
            "test_objarr_add_invalid",
            "test_td64arr_sub_offset_index",
            "_process_subheader",
            "test_order_matters",
            "test_rolling_corr_with_zero_variance",
            "test_td_add_sub_ten_seconds",
            "test_align_series_combinations",
            "test_encode_list_conversion",
            "test_constructor_from_sparse",
            "test_to_html_columns_arg",
            "test_sort_index_na_position_with_categories_raises",
            "_python_agg_general",
            "test_dti_tz_localize_naive",
            "_isfinite",
            "_interpolate",
            "test_delete",
            "test_dti_tz_localize_ambiguous_infer",
            "test_to_csv_decimal",
            "test_iloc_setitem_series",
            "test_apply_modify_traceback",
            "test_all_nans",
            "set_clipboard",
            "test_ensure_index_mixed_closed_intervals",
            "cherry_pick",
            "test_from_records_empty",
            "test_dont_modify_rcParams",
            "test_exception_importable",
            "_plot",
            "test_with_list",
            "_make_date_converter",
            "_plot_colorbar",
            "test_multi_iter",
            "test_max_level_with_records_path",
            "test_ewma_halflife_arg",
            "append",
            "test_subplots_warnings",
            "test_to_flat_index",
            "test_union_base",
            "_cast_inplace",
            "rename_categories",
            "test_searchsorted_numeric_dtypes_scalar",
            "test_ts_plot_format_coord",
            "test_get_label_or_level_values_series_axis1_error",
            "_get_resampler_for_grouping",
            "test_float_series_rdiv_td64arr",
            "time_skipprows",
            "test_dont_clobber_name_column",
            "test_convert_int_overflow",
            "test_read_with_stop",
            "compute",
            "test_default_right_closed_label",
            "test_first_fill_value_loc",
            "test_df_boolean_comparison_error",
            "_compare_stacked_y_cood",
            "test_parsers_dayfirst_yearfirst",
            "test_from_M8_structured",
            "indexer_from_factorized",
            "group_info",
            "test_insert_base",
            "_write_to_group",
            "test_concat_different_columns_buggy",
            "test_map_decimal",
            "test_on_float_by_int",
            "test_bday_overflow_error",
            "test_select_iterator_non_complete_8014",
            "test_to_sparse_pass_name",
            "write_tr",
            "test_concat_invalid",
            "test_ufuncs_binary_int",
            "test_cut_out_of_bounds",
            "test_join_index_mixed_overlap",
            "test_agg_relabel",
            "_maybe_cast_indexer",
            "test_to_period_annualish",
            "test_repr_to_string",
            "get_empty_dtype_and_na",
            "test_dropIncompleteRows",
            "test_multiple_agg_funcs",
            "test_comparison_op_scalar",
            "groupings",
            "test_subclass_attr_err_propagation",
            "test_resample_5minute",
            "test_with_mixed_tuples",
            "test_bad_kwarg",
            "test_shift_fill_value",
            "time_op",
            "test_info_repr_max_cols",
            "test_with_nans",
            "test_reindex_backfill",
            "test_constructor_generator",
            "test_ndarray_compat",
            "_rewrite_assign",
            "_stringify_na_values",
            "maybe_infer_to_datetimelike",
            "_applymap",
            "validate_groupby_func",
            "test_append_with_diff_col_name_types_raises_value_error",
            "test_format_sparse_config",
            "test_frame_select_complex2",
            "test_astype_asfreq",
            "_post_setstate",
            "_value_with_fmt",
            "test_streaming_s3_objects",
            "test_get_accessor_args",
            "test_iloc_fill_value",
            "test_from_categorical_dtype_categories",
            "test_to_csv_from_csv4",
            "test_unstack_period_frame",
            "win_types",
            "test_MillisecondTimestampArithmetic",
            "test_namespace",
            "to_pydatetime",
            "get_finder",
            "test_unique_datetimelike",
            "test_str_cat_all_na",
            "test_loc_index_fill_value",
            "test_data",
            "test_integer_col_names",
            "time_cython_sum",
            "transform_assert_equal",
            "objSeries",
            "test_agg_misc",
            "test_get_str_from_freq",
            "test_is_datetime_or_timedelta_dtype",
            "test_dropEmptyRows",
            "test_smaller",
            "test_parsers_iso8601",
            "test_hexbin_basic",
            "test_apply_differently_indexed",
            "test_normalize_date",
            "_prep_binary",
            "test_groupby_resample_on_api_with_getitem",
            "test_datetimeindex_diff",
            "_compare_or_regex_search",
            "test_merge_suffix_none_error",
            "time_reindexed",
            "with_csv_dialect",
            "test_unbalanced",
            "_format_strings",
            "test_get_loc_raises_bad_label",
            "test_join_overlap",
            "test_timegrouper_get_group",
            "time_categorical_series_is_monotonic_increasing",
            "test_concat_with_group_keys",
            "test_dt_accessor_datetime_name_accessors",
            "test_rng_context",
            "test_from_arrays_tuples",
            "time_dt_accessor_year",
            "test_multi_thread_string_io_read_csv",
            "test_count_level_corner",
            "test_subclass_sparse_slice",
            "test_2",
            "test_xs_level_series_ymd",
            "get_root",
            "test_string_index_series_name_converted",
            "test_minimal_size_col",
            "test_dataframe_dummies_unicode",
            "hexbin",
            "_has_same_tz",
            "test_assigning_ops",
            "orient",
            "test_standard_colors",
            "show_row_idx_names",
            "test_offset_whole_year",
            "test_categorical_repr_timedelta",
            "time_multi_size",
            "time_datetime_difference_disjoint",
            "test_dt64_nat_comparison",
            "test_scalar_non_numeric",
            "rule_from_name",
            "test_encode_non_c_locale",
            "test_index_duplicate_periods",
            "assignment_not_inplace",
            "test_date_accessor",
            "test_td64arr_mul_tdscalar_invalid",
            "test_asfreq_bug",
            "test_version",
            "test_get_set_value",
            "test_basic_names_raise",
            "test_operators_na_handling",
            "_make_plot",
            "test_series_grid_settings",
            "tests_merge_categorical_unordered_equal",
            "test_constructor_nan_dataframe",
            "test_ix_loc_consistency",
            "test_construction_to_datetimelike_unit",
            "test_is_strictly_monotonic",
            "test_rename_errors_raises",
            "test_dtype_equal",
            "test_global_scope",
            "test_parse_failure_rewinds",
            "test_assert_not_almost_equal_numbers",
            "get_dummies",
            "test_usecols_index_col_false",
            "test_datetime_subclass",
            "test_array",
            "get_atom_timedelta64",
            "_rewrite_membership_op",
            "test_check_label_or_level_ambiguity_series",
            "test_array_tz",
            "__doc__",
            "_create_indexer",
            "_maybe_mangle_lambdas",
            "test_constructor_datetimes_with_nulls",
            "test_pipe_args",
            "test_getitem_list_periods",
            "test_onecolumn_of_integer",
            "write_legacy_msgpack",
            "test_nat_comparisons",
            "test_constructor_cant_cast_datetimelike",
            "test_query_default",
            "test_codes_dtypes",
            "test_combine_first_name",
            "test_map_counter",
            "test_date",
            "test_read_write_dta5",
            "test_repr_with_mi_nat",
            "test_filter_and_transform_with_non_unique_timestamp_index",
            "test_value_counts_datetime_outofbounds",
            "test_invalid_timestamp",
            "test_td64_mean",
            "test_parr_add_sub_dt64_array_raises",
            "test_rolling_kurt",
            "test_array_equivalent_str",
            "test_to_string_decimal",
            "test_constructor_mixed_tz",
            "test_loc_multi_tuple",
            "test_ragged_skew",
            "test_from_records_iterator",
            "test_assert_almost_equal_class_mismatch",
            "time_cut_float",
            "test_pi_ops_offset",
            "test_range_kwargs_deprecated",
            "test_string_repr_encoding",
            "test_Nanosecond",
            "test_indices_concatenation_order",
            "test_getitem_fancy_ints",
            "git_get_keywords",
            "default_kind",
            "gen_series_formatting",
            "test_constant",
            "sint_dtype",
            "test_nat_parse",
            "test_ix_dup",
            "time_nsmallest_one_column",
            "boxplot_frame",
            "time_get_loc_dec",
            "test_pi_sub_pi_with_nat",
            "test_nan_numeric",
            "writeable",
            "_exclude_implicit_index",
            "test_write_dta6",
            "test_numpy_minmax_integer",
            "test_numexpr_builtin_raises",
            "test_astype_nan_raises",
            "test_bool",
            "test_to_datetime_infer_datetime_format_series_start_with_nans",
            "get_indexer_dict",
            "_multi_blockify",
            "time_append_mixed",
            "test_difference_empty_arg",
            "merge_class",
            "is_mixed_type",
            "test_repr_html_ipython_config",
            "_calcsize",
            "test_split_to_multiindex_expand",
            "test_invalid_total_length_max_length_multiple",
            "test_rank_resets_each_group",
            "test_categorical_equality_strings",
            "test_parse_timezone",
            "visit_Call",
            "test_reindex_like",
            "time_cut_int",
            "test_is_signed_integer_dtype",
            "test_iterrows_iso8601",
            "use_bottleneck_cb",
            "test_grouped_hist_multiple_axes",
            "test_nonnumeric_suffix",
            "test_to_csv_from_csv5",
            "validate_resampler_func",
            "test_set_axis_name_mi",
            "test_is_object",
            "json_normalize",
            "test_pi_sub_isub_int",
            "_coerce_to_type",
            "test_identity_slice_returns_new_object",
            "test_api",
            "time_is_monotonic",
            "test_constructor_coverage",
            "add_ops",
            "test_stat_non_defaults_args",
            "_static_values",
            "test_other_columns",
            "missing_whitespace_after_comma",
            "_format_multirow",
            "_validate_fill_value",
            "squeeze",
            "test_groupby_multiindex_series_keys_len_equal_group_axis",
            "test_groupby_cum_skipna",
            "test_setitem",
            "_chunk_to_dataframe",
            "time_cut_datetime",
            "test_multifunc_sum_bug",
            "test_view_with_args",
            "test_td_div_numeric_scalar",
            "test_binary_ufunc_with_series",
            "test_csv_custom_parser",
            "test_fillna",
            "test_setitem_series_int8",
            "test_offset_deprecated",
            "time_extract",
            "set_precision",
            "test_is_string_array",
            "test_reindex_columns",
            "test_is_mixed_type",
            "test_sample",
            "test1_basic",
            "test_timedelta64_nan",
            "test_colspan_rowspan_both_not_1",
            "test_where_with_bool_data_and_other",
            "test_pow_float",
            "_style_to_xlwt",
            "test_empty_series_frame",
            "test_on_index_object",
            "nrows",
            "set_attr",
            "test_equality_generic",
            "test_read_invalid_types_raises",
            "test_get_first_bday",
            "test_examples3",
            "execute",
            "test_get_loc_msg",
            "time_groupby_nth_all",
            "test_roundtrip_indexlabels",
            "test_numpy_minmax_range",
            "lines_json_df",
            "test_categorical_nans",
            "test_asof_datetime_partial",
            "test_series_getitem",
            "test_first_last_nth_dtypes",
            "test_setitem_index_timedelta64",
            "_dt_array_cmp",
            "test_set_categories_many",
            "init_xclip_clipboard",
            "test_to_string_unicode_columns",
            "round",
            "all_packers_data",
            "test_resample_loffset",
            "test_pipe_tuple_error",
            "test_frame_operators",
            "test_none",
            "test_maybe_convert_objects_uint64",
            "test_astype_extension_dtypes_duplicate_col",
            "_skip_if_no_pchip",
            "test_buffer_rd_bytes_bad_unicode",
            "test_arith_flex_zero_len_raises",
            "test_astype_mixed_type",
            "test_invalid_local_variable_reference",
            "test_delitem",
            "test_tick_zero",
            "test_stack_multiple_out_of_bounds",
            "_sparsify",
            "test_merge_index_as_on_arg",
            "test_replace_period",
            "test_get_indexer_non_unique_with_int_and_float",
            "test_reverse_ops_with_index",
            "test_string_nas",
            "test_read_fspath_all",
            "test_int64_min_issues",
            "validate_fillna_kwargs",
            "test_xlrd_version_fallback",
            "test_concat_different_columns_sort_warns",
            "test_multiindex_passthru",
            "test_usecols_with_parse_dates_and_names",
            "test_agg_apply",
            "test_empty_sum",
            "time_reindex_axis1",
            "test_fillna_fill_value",
            "_unpickle_sparse_frame_compat",
            "test_wikipedia_states_table",
            "time_to_string_floats",
            "test_registry_resets",
            "test_pivot_with_multiindex",
            "test_Easter",
            "_maybe_convert_timedelta",
            "_maybe_convert_usecols",
            "identical",
            "is_scalar",
            "test_getitem_fancy_1d",
            "test_date_range_nat",
            "test_td_rfloordiv_numeric_scalar",
            "test_ngroup_empty",
            "test_latex_repr",
            "test_join_non_unique_period_index",
            "time_multiple_date",
            "_python_apply_general",
            "test_sort_values_categorical",
            "test_from_dict_columns_parameter",
            "list_of_tuples_with_none",
            "test_inplace_mutation_resets_values",
            "time_rank_int_cat",
            "nulls_fixture",
            "test_first_subset",
            "test_getitem_partial_int",
            "test_invalid_suffixtype",
            "_get_monthly_rule",
            "_unpack_cycler",
            "test_to_datetime_on_datetime64_series",
            "test_idxmin",
            "test_fallback_success",
            "time_get_indexer",
            "test_write_fspath_all",
            "test_from_frame_error",
            "time_write_store",
            "_validate_join_method",
            "test_imethods_with_dups",
            "test_extractall_same_as_extract_subject_index",
            "test_setitem_mask_broadcast",
            "test_set_ordered",
            "read_sql_table",
            "unit",
            "time_intersection_both_duplicate",
            "test_scalar_assignment",
            "timedelta_range",
            "test_interp_inplace",
            "test_ambiguous_width",
            "test_convert_objects",
            "time_on_int32",
            "set_test_mode",
            "test_constructor",
            "test_resample_how_callables",
            "test_to_csv_wide_frame_formatting",
            "_box_as_indexlike",
            "test_constructor_with_int_tz",
            "makeUIntIndex",
            "_start",
            "test_sort_index_duplicates",
            "test_to_period_quarterly",
            "test_properties_quarterly",
            "size",
            "time_unique_date_strings",
            "_putmask_smart",
            "test_pandas_dtypes",
            "time_from_scipy",
            "test_registering_no_warning",
            "rolling",
            "storage_obj_type",
            "test_dispatch_transform",
            "test_properties_daily",
            "makeObjectSeries",
            "test_multiple_aggregators_with_dict_api",
            "test_secondary_axis_font_size",
            "test_groupby_level_mapper",
            "test_iter_single_element",
            "assert_block_equal",
            "_agg_index",
            "test_is_number",
            "test_constructor_invalid_Z0_isostring",
            "test_aggregate_float64_no_int64",
            "test_series_add_aware_naive_raises",
            "file_filter",
            "_create_unary_method",
            "test_infer_objects_series",
            "_get_loc",
            "test_replace_across_dst",
            "time_dup_string_tzoffset_dates",
            "test_bigint_warning",
            "test_align_int",
            "_query_iterator",
            "test_reindex_preserves_type_if_target_is_empty_list_or_array",
            "testFixnum",
            "day",
            "test_subclass",
            "zfill",
            "has_truncated_repr",
            "test_constructor_categorical_series",
            "test_resample_timestamp_to_period",
            "test_take2",
            "time_itertuples_start",
            "test_not_reflect_all_tables",
            "ravel",
            "test_append_different_columns_types",
            "test_period_cons_annual",
            "test_wrong_num_labels",
            "standardize_mapping",
            "_compose2",
            "test_all",
            "test_constructor_range_dtype",
            "update_dtype",
            "_get_formatted_index",
            "test_check_dtype",
            "test_agg_structs_series",
            "test_raw_roundtrip",
            "mask_zero_div_zero",
            "test_slice_month",
            "test_read_excel_without_slicing",
            "_load_test2_data",
            "test_dti_tz_localize_ambiguous_flags",
            "test_scalar_call_versus_list_call",
            "_get_level_values",
            "test_rename_categories",
            "test_multi_index_parse_dates",
            "test_join_indexes_and_columns_on",
            "test_skipfooter_bad_row",
            "test_replace_replacer_equals_replacement",
            "test_date_range_int64_overflow_stride_endpoint_different_signs",
            "test_to_csv_string_with_crlf",
            "test_stack_dropna",
            "test_filter_using_len",
            "test_series_indexing_zerodim_np_array",
            "test_rsplit_to_dataframe_expand",
            "_get_codes_for_values",
            "test_get_loc_scalar",
            "time_rsplit",
            "mgr",
            "test_series_tz_localize_ambiguous_bool",
            "from_params",
            "test_transform_datetime_to_numeric",
            "test_getitem_setitem_tuple_plus_columns",
            "test_repr_max_columns_max_rows",
            "test_integer_passthrough",
            "test_fillna_different_dtype",
            "time_lstrip",
            "test_eq_with_numpy_object",
            "makeMixedDataFrame",
            "test_float_array_different_kind",
            "test_messed_up_data",
            "test_get_loc_raises_object_tolerance",
            "test_scalar_with_mixed",
            "time_small_get_loc_warm",
            "test_create_table_index",
            "test_quantile_sparse",
            "test_fillna_object",
            "_get_index_freq",
            "_get_complex_date_index",
            "test_read_excel_multiindex_empty_level",
            "test_reset_index_level",
            "_unpickle_array",
            "test_pi_add_iadd_timedeltalike_hourly",
            "test_loc_slice_fill_value",
            "test_corrwith_index_intersection",
            "str_repeat",
            "test_set_index_names",
            "test_nat_fields",
            "test_is_monotonic_increasing",
            "_in",
            "test_ops_datetimelike_align",
            "test_construction",
            "test_reindex_axis_style_raises",
            "test_sub_n_gt_1_ticks",
            "test_pow",
            "test_frame_to_dict_tz",
            "test_series_ret_bins",
            "time_add_10",
            "test_tolist",
            "test_parse_date_column_with_empty_string",
            "test_is_scalar_numpy_zerodim_arrays",
            "test_conv_monthly",
            "time_nested_dict_int64",
            "registry_without_decimal",
            "test_drop_exception_raised",
            "test_groupby_with_single_column",
            "test_numpy_round",
            "test_slicing_doc_examples",
            "to_records",
            "test_validate_ndim",
            "test_nat_arithmetic_scalar",
            "test_constructor_casting",
            "_set_result_index_ordered",
            "test_by_int",
            "test_align_series_frame",
            "test_mixed_depth_insert",
            "test_info_repr",
            "test_repr_small",
            "versions_from_file",
            "_get_join_keys",
            "mix_abc",
            "test_to_datetime_today_now_unicode_bytes",
            "test_cr_delimited",
            "test_multi_line_expression_local_variable",
            "_reference_dates",
            "test_needs_i8_conversion",
            "test_transform_bug",
            "test_values_numeric_cols",
            "test_ewmvol",
            "_recast_datetimelike_result",
            "test_subtype_integer_errors",
            "_align",
            "test_constructor_tuples",
            "test1_incremental",
            "mask",
            "test_nansem",
            "test_nat_pinned_docstrings",
            "_compose",
            "test_to_datetime_utc",
            "test_to_csv",
            "to_pytimedelta",
            "test_na_values_uint64",
            "test_argsort_stable",
            "test_mi_sparse_column_names",
            "test_datetime_tz_qcut",
            "test_from_csv",
            "compression",
            "test_apply_multikey_corner",
            "test_config_on",
            "test_resample_timedelta_idempotency",
            "test_contains_with_nat",
            "fill_binop",
            "time_read_csv",
            "test_merge_overlap",
            "time_encode_decode",
            "test_iloc_slice",
            "conform",
            "test_sharex_and_ax",
            "test_no_flex",
            "test_period_ops_offset",
            "test_parse_booleans",
            "validate_all",
            "time_duplicated_unique",
            "test_boolean_index_empty_corner",
            "test_merge_suffix",
            "test_ewmcov_pairwise",
            "test_slice_locs_dup",
            "linkcode_resolve",
            "_remove_labels_from_axis",
            "test_numeric_only_flag",
            "test_scalar_raises",
            "test_multi_line_expression_callable_local_variable",
            "test_parse_dates_no_convert_thousands",
            "test_excel_table",
            "test_apply_attach_name",
            "test_frame_values_with_tz",
            "test_dti_tz_localize_nonexistent",
            "test_list_numpy_float_complex",
            "save",
            "test_indexing_ambiguity_bug_1678",
            "__truediv__",
            "test_true_and_false_value_options",
            "test_operators_bitwise",
            "test_numpy_string_dtype",
            "test_agg_category_nansum",
            "test_tz_localize_errors_invalid_arg",
            "test_join_index_more",
            "load_test_data_and_sql",
            "empty",
            "check_equal",
            "test_basic_sort",
            "test_quantile_empty",
            "test_any",
            "_add_series_or_dataframe_operations",
            "_akima_interpolate",
            "test_td_rfloordiv_null_scalar",
            "test_dti_eq_null_scalar",
            "test_round_trip_frame_sep",
            "_check_frame_ops",
            "test_interp_alt_scipy",
            "test_unicode_repr_level_names",
            "_join_multi",
            "_check_not_equal_with_index",
            "test_merge_on_indexes",
            "is_null_slice",
            "take_2d_multi",
            "to_numpy_dtypes",
            "simple_multiindex_dataframe",
            "test_date_range_gen_error",
            "test_parse_ragged_csv",
            "_resolution",
            "_add_delta",
            "test_to_csv_no_index",
            "test_valid_allow_exact_matches",
            "_create_methods",
            "test_tick_equalities",
            "_get_data_as_items",
            "merge",
            "test_mode_timedelta",
            "test_copy",
            "m_offset",
            "test_resample_interpolate",
            "test_concat_multiindex_with_none_in_index_names",
            "test_where_series_datetime64tz",
            "_write_row_header",
            "_add_offset",
            "test_more_than_one_expression_raises",
            "maybe_cast_to_integer_array",
            "test_stack_unstack",
            "test_unicode_name_in_footer",
            "test_convert_pandas_type_to_json_field_categorical",
            "test_corrwith_spearman",
            "test_verbose_read",
            "peakmem_int",
            "test_number_looking_strings_not_into_datetime",
            "test_selection_by_datetimelike",
            "test_ctor_str_intraday",
            "flush",
            "test_getitem_seconds",
            "_maybe_restore_index_levels",
            "test_append_preserve_name",
            "test_calendar_observance_dates",
            "compress_file",
            "test_mixed_datetime64",
            "clean_reindex_fill_method",
            "ensure_clean_dir",
            "test_td64arr_sub_pi",
            "test_parsing_non_iso_timezone_offset",
            "test_no_invalid_float_truncation",
            "test_resample_segfault",
            "test_sheet_name",
            "test_datetime_tz_cut",
            "_max_fitting_element",
            "test_to_string_with_formatters_unicode",
            "plt",
            "test_kurt",
            "test_strings",
            "test_unordered_different_order_equal",
            "_try_cast_result",
            "_handle_hidden_tables",
            "test_multiple_tbody",
            "test_setitem_index_datetime64",
            "test_from_inferred_categories_dtype",
            "test_idxmin_idxmax_returns_int_types",
            "test_to_datetime_iso8601",
            "time_isin_many_different",
            "test_apply_without_aggregation",
            "_concat_categorical",
            "test_map",
            "test_as_json_table_type_bool_dtypes",
            "test_reindex_non_unique",
            "raise_assert_detail",
            "test_partition_with_name",
            "_get_list_axis",
            "write_th",
            "test_config_prefix",
            "test_checknull",
            "_is_type_compatible",
            "test_regular_min",
            "test_from_records_non_tuple",
            "fill_frame",
            "test_isin_dupe_self",
            "time_rpartition",
            "pytest_runtest_setup",
            "test_override_set_noconvert_columns",
            "test_sparse_series_ops",
            "test_join_right",
            "test_subclass_sparse_addition",
            "test_query_empty_string",
            "format_object_summary",
            "get_key",
            "to_dense",
            "test_constructor_not_sequence",
            "test_neg",
            "test_unit_m_y_deprecated",
            "test_map_missing",
            "test_merge_join_key_dtype_cast",
            "isiterable",
            "test_frame_groupby",
            "test_union",
            "test_rolling_median_resample",
            "set_atom_datetime64",
            "test_read_s3_with_hash_in_key",
            "test_skiprows_lineterminator",
            "time_multiply",
            "last_valid_index",
            "test_maybe_convert_i8_errors",
            "test_delevel_infer_dtype",
            "test_closed_uneven",
            "_join_index",
            "scatter_matrix",
            "_get_item_cache",
            "test_resample_ohlc_dataframe",
            "_setup_dtype",
            "_workbook_class",
            "test_repr_should_return_str",
            "test_rolling_min_max_numeric_types",
            "_union",
            "test_iloc_getitem_frame",
            "test_get_schema_keys",
            "test_resample_groupby_with_label",
            "test_errors_param_filters_errors",
            "test_boxplot_legacy2",
            "time_format_YYYYMMDD",
            "test_getitem_with_scalar",
            "dropna",
            "test_size",
            "test_mi_sparse_index_names",
            "test_is_file_like",
            "_setitem_array",
            "test_fillna_preserves_tz",
            "test_reset_index_period",
            "test_header_multi_index_common_format_malformed3",
            "_get_slice_axis",
            "test_line_lim",
            "test_is_not_unsigned_integer_dtype",
            "test_iteritems",
            "write_td",
            "test_print_unicode_columns",
            "test_exponents_with_eng_prefix",
            "g",
            "test_default_na_values",
            "test_is_s3_url",
            "test_expanding_corr_cov",
            "test_to_offset_negative",
            "search",
            "test_logical_ops_with_index",
            "subtype",
            "test_single_backtick_variable_expr",
            "_get_ax_freq",
            "_read_strls",
            "test_td64arr_mul_numeric_scalar",
            "test_categorical_concat_gh7864",
            "is_non_overlapping_monotonic",
            "test_set_names_with_nlevel_1",
            "generate",
            "test_readjson_chunks_from_file",
            "test_datetime_likes",
            "test_where_different_freq_raises",
            "sql_schema",
            "test_to_html_truncation_index_false_max_cols",
            "test_nanlt",
            "test_basic_left_index",
            "test_error_iso_week_year",
            "test_is_numeric",
            "test_fillna_series_period",
            "_is_metadata_of",
            "test_works_on_valid_markup",
            "integer_array",
            "test_concat_astype_dup_col",
            "test_readjson_chunksize_requires_lines",
            "test_union_identity",
            "test_slice_locs_partial",
            "appends",
            "time_timestamp_ops_diff",
            "test_constructor_list_str_na",
            "test_precise_conversion",
            "_create_blocks",
            "time_duplicated",
            "test_astype_object2",
            "contains",
            "_try_visit_binop",
            "test_getitem_partial",
            "test_boolean_comparison",
            "test_date_range_timestamp_equiv_preserve_frequency",
            "asfreq",
            "test_join_on_tz_aware_datetimeindex",
            "time_setitem_period_column",
            "_any_pandas_objects",
            "form_blocks",
            "test_add_series_with_extension_array",
            "test_merge_on_periods",
            "test_non_string_na_values",
            "_iget_item_cache",
            "at_time",
            "set_names",
            "test_apply_index",
            "test_regex_replace_regex_list_to_numeric",
            "test_basic_getitem_with_labels",
            "init_klipper_clipboard",
            "_maybe_right_yaxis",
            "test_quantile",
            "test_align_mixed_int",
            "test_assert_almost_equal_edge_case_ndarrays",
            "_check_is_chained_assignment_possible",
            "test_truncate_nonsortedindex",
            "test_setitem_slice_into_readonly_backing_data",
            "test_warn_if_chunks_have_mismatched_type",
            "makeFY5253NearestEndMonth",
            "test_frame_append_datetime64_column",
            "is_unique_asi8",
            "test_line_label_none",
            "test_start_stop_fixed",
            "test_iat_setter_incompatible_assignment",
            "test_partial_set_empty_frame",
            "test_ufunc_at",
            "test_factorize_na_sentinel",
            "test_invalid_key",
            "test_read_jsonl_unicode_chars",
            "test_length_timestamp",
            "time_get_groups",
            "valid",
            "current_pickle_data",
            "_right_outer_join",
            "__sizeof__",
            "test_error_bad_lines",
            "test_group_shift_with_fill_value",
            "test_nonzero_warning",
            "test_pivot_table_dropna",
            "_assert_safe_casting",
            "test_logical_operators",
            "_get_deprecated_option",
            "test_groupby_with_empty",
            "df_full",
            "test_to_csv_with_single_column",
            "test_iterable_map",
            "test_nat_rfloordiv_timedelta",
            "test_partial_slice_minutely",
            "test_float_same_index",
            "test_cmp_dt64_arraylike_tznaive",
            "_get_counts_nanvar",
            "test_lookup_array",
            "test_getitem_dups",
            "test_internal_eof_byte",
            "test_assert_almost_equal_value_mismatch1",
            "_maybe_downcast_constants",
            "sort_index",
            "is_list_like_indexer",
            "test_getitem_sparse_column",
            "test_floordiv_div",
            "set_atom_string",
            "stack_sparse_frame",
            "test_apply_trivial_fail",
            "test_assert_not_almost_equal_null",
            "test_normalize_tz",
            "test_raise_on_no_columns",
            "time_read_csv_python_engine",
            "test_inner_join_indexer2",
            "assign",
            "test_setitem_change_dtype",
            "time_nsmallest_two_columns",
            "from_array",
            "test_first_raises",
            "set_atom_datetime64tz",
            "test_set_axis_name",
            "test_airline",
            "test_compare_zerodim_array",
            "test_object_series_ok",
            "time_first",
            "time_fromtimestamp",
            "test_sort_values_missing",
            "test_groupby_series_with_name",
            "test_any_datetime",
            "test_fill_method_and_how_upsample",
            "test_sub_period",
            "test_loc_getitem_iterator",
            "test_numpy_mean",
            "test_type_coercion_fail",
            "test_basic_index",
            "test_rolling_cov_offset",
            "test_pass_names_with_index",
            "_upsample",
            "time_dt_accessor_normalize",
            "test_filter_and_transform_with_non_unique_int_index",
            "test_tab_complete_ipython6_warning",
            "test_dti_custom_getitem",
            "test_mul_int_identity",
            "test_latin_encoding",
            "test_transform_and_agg_error",
            "test_transpose_tzaware_1col_single_tz",
            "_strip_schema",
            "test_read_duplicate_index_explicit",
            "test_resample_across_dst",
            "time_frame_from_records_generator",
            "test_itemsize",
            "indentation_is_not_a_multiple_of_four",
            "test_numpy_array_float",
            "_replace_single",
            "test_constructor_empty_special",
            "convert_pandas_type_to_json_field",
            "test_per_axis_per_level_setitem",
            "test_valid_relativedelta_kwargs",
            "_guess_time_format_for_array",
            "test_str_attribute",
            "test_col_level",
            "named_single_return",
            "test_date_col_as_index_col",
            "test_frame_join_tzaware",
            "test_is_datetimelike",
            "test_legacy_offset_warnings",
            "test_categorical_shift_fill_value",
            "test_header_multi_index_common_format3",
            "_set_values",
            "test_memory_usage",
            "test_unit_with_numeric",
            "test_index_name",
            "datetime_series",
            "_set_names",
            "time_from_missing",
            "test_closed_min_max_datetime",
            "test_legend_name",
            "_is_index_col",
            "test_weekly_upsample",
            "test_basics_with_nan",
            "_filter_indexer_tolerance",
            "test_frame_loc_callable",
            "_convert_to_style",
            "_get_annual_rule",
            "time_transform_multi_key3",
            "test_frame_describe_tupleindex",
            "read_table",
            "recode_from_groupby",
            "test_period_with_agg",
            "test_num_string_disambiguation",
            "test_dti_tz_constructors",
            "test_plot_bar",
            "_disallow_scalar_only_bool_ops",
            "is_type_factory",
            "test_to_string_format_na",
            "test_is_scalar_pandas_containers",
            "test_nan",
            "test_dti_snap",
            "test_infer_from_tdi",
            "test_assert_numpy_array_equal_value_mismatch2",
            "test_float_arithemtic",
            "test_dt64arr_add_sub_tick_DateOffset_smoke",
            "test_frame_mi_access_returns_frame",
            "test_apply_broadcast_deprecated",
            "test_initial_warning",
            "test_tricky_container",
            "test_different_nans_as_float64",
            "time_divide",
            "test_assign_index_sequences",
            "test_concat_mixed_objs",
            "_decorate_ticks",
            "test_set_dataframe_column_ns_dtype",
            "to_tuples",
            "test_is_monotonic_na",
            "time_iso8601_format",
            "test_can_hold_na_valid",
            "test_iloc_setitem_list_of_lists",
            "test_cut_read_only",
            "test_categorical_warnings_and_errors",
            "write_data",
            "time_is_month_end",
            "_infer_columns",
            "test_getitem_iloc",
            "time_groupby_extra_cat_nosort",
            "_engine",
            "test_complex_fixed",
            "test_api_mi_raises",
            "_asof_by_function",
            "test_pivot_table_with_nans",
            "test_nanosecond_resample_error",
            "test_bar_align_single_column",
            "nancov",
            "test_outer_join_indexer2",
            "test_dti_shift_int",
            "_center_window",
            "test_single_common_level",
            "tzname",
            "test_cummax_datetime64",
            "test_positional_take",
            "test_complex_series_error",
            "_outer_indexer",
            "has_duplicates",
            "test_partial_slice_daily",
            "test_constructor_coercion_signed_to_unsigned",
            "test_binary_ufunc_drops_series_name",
            "test_constructor_with_null",
            "test_timestamp_compare_with_early_datetime",
            "test_unary_in_array",
            "test_from_arrays_index_series_timedelta",
            "test_slice_float",
            "write_legacy_pickles",
            "validate",
            "test_take_na_empty",
            "write",
            "test_frame_align_aware",
            "test_mi_data_columns",
            "time_loop",
            "test_multi_char_sep_quotes",
            "test_empty_str_methods_to_frame",
            "test_combined_up_downsampling_of_irregular",
            "test_ncols",
            "test_join_utc_convert",
            "visit",
            "test_repr_mixed_big",
            "test_setitem_series_int64",
            "_next_opening_time",
            "test_to_csv_from_csv_categorical",
            "test_cython_group_transform_cumprod",
            "test_generate_cday",
            "is_open",
            "test_get_loc_nan",
            "block",
            "test_int_types",
            "_parsed_string_to_bounds",
            "time_timedelta_nanoseconds",
            "test_local_variable_with_in",
            "test_dti_business_repr",
            "test_delitem_corner",
            "test_union_with_DatetimeIndex",
            "to_stata",
            "test_getitem_category_type",
            "test_clip_with_na_args",
            "test_concat_series_name_npscalar_tuple",
            "is_old_version",
            "_subtype_with_str",
            "consensus_name_attr",
            "test_read_table",
            "test_to_datetime_YYYYMMDD",
            "test_groupby_multi_timezone",
            "test_mangle_dupe_cols_false",
            "_format_coord",
            "test_subplots_ts_share_axes",
            "test_pct_change_shift_over_nas",
            "test_numeric_column_names",
            "df_duplicates",
            "test_unique_tuples",
            "test_normalize_tz_local",
            "makeDateIndex",
            "_interpolate_scipy_wrapper",
            "getitem_block",
            "no_returns",
            "str_replace",
            "test_date_parser_resolution_if_not_ns",
            "_maybe_utc_convert",
            "test_join_hierarchical_mixed",
            "test_numpy_err_state_is_default",
            "test_categorical_dtype_chunksize_explicit_categories",
            "win_types_special",
            "check",
            "test_inf_parsing",
            "_str_extract_noexpand",
            "test_inconsistent_return_type",
            "test_iloc_row",
            "_assert_xtickslabels_visibility",
            "test_minmax_tz",
            "test_indexing_with_datetimeindex_tz",
            "time_groupby_sum_booleans",
            "set_numexpr_threads",
            "test_arith_series_with_array",
            "_sparse_array_op",
            "test_is_nested_list_like_fails",
            "test_is_re_passes",
            "test_update",
            "test_join_left_sequence_non_unique_index",
            "test_numpy_ufuncs_basic",
            "test_multiindex_is_homogeneous_type",
            "test_boolean",
            "test_max_len_string_array",
            "_parse_date_columns",
            "_missing_double",
            "test_set_levels_with_iterable",
            "get_datevalue",
            "test_create_temp_directory",
            "test_interp_combo",
            "__eq__",
            "to_excel",
            "test_apply_frame_yield_constant",
            "check_nancorr_nancov_1d",
            "test_sub_datetime_compat",
            "test_dti_tz_localize_utc_conversion",
            "_assert_can_do_setop",
            "get_dtype_counts",
            "test_cummethods_bool",
            "test_get_get_value",
            "__matmul__",
            "test_mixed_array_float_int",
            "_make_index",
            "time_transform_mean",
            "test_view_Index",
            "test_values_asarray",
            "test_groupby_keys_same_size_as_index",
            "test_order",
            "test_constructor_float32",
            "test_matplotlib_backend_error",
            "test_categorical_nan_handling",
            "test_skiprows_ndarray",
            "set_engine_and_path",
            "test_datetimelike_frame",
            "test_timedelta_assignment",
            "test_reindex_empty_index",
            "_groupby_and_aggregate",
            "_unpickle_matrix_compat",
            "test_rank_naoption_raises",
            "pandasSQL_builder",
            "time_convert_post",
            "test_constructor_error",
            "show_versions",
            "parse_date_time",
            "dataframe",
            "test_concat_aligned_sort",
            "_get_cython_function",
            "time_ceil",
            "_wrap_results",
            "test_tdi_iadd_int",
            "test_series_equal",
            "test_construction_base_constructor",
            "test_cat_accessor_api",
            "test_truncate_out_of_bounds",
            "_process_columnname_subheader",
            "source_file_def_line",
            "test_pivot_table_margins_name_with_aggfunc_list",
            "test_rolling_min_resample",
            "_get_partial_string_timestamp_match_key",
            "test_constructor_from_categorical_with_unknown_dtype",
            "is_function_or_method",
            "from_items",
            "test_to_latex_float_format_no_fixed_width",
            "test_excel_passes_na",
            "test_readjson_chunks",
            "empty_returns",
            "test_astype_categories_deprecation_raises",
            "test_gb_apply_list_of_unequal_len_arrays",
            "replace",
            "test_to_csv_escapechar",
            "test_dataframe_categorical_with_nan",
            "test_series_slice_partial",
            "_validate_names",
            "_getitem_axis",
            "reorder_arrays",
            "encoding",
            "test_categorial_assigning_ops",
            "test_drop_level_nonunique_datetime",
            "test_bad_class",
            "check_result_type",
            "test_xs_duplicates",
            "union_categoricals",
            "test_is_unique_monotonic",
            "test_categorical_index_repr_timedelta_ordered",
            "_evaluate_numexpr",
            "test_getitem_zerodim_np_array",
            "test_merge_different_column_key_names",
            "time_reindex_level",
            "test_y_listlike",
            "str_match",
            "get_expects",
            "to_manager",
            "test_union_freq_both_none",
            "test_unique_data_ownership",
            "map",
            "register_writer",
            "test_name",
            "test_from_dict",
            "test_pindex_slice_index",
            "_is_line_empty",
            "test_combine_first_mixed_bug",
            "test_with_duplicates_no_on",
            "_make_accessor",
            "test_to_timestamp_tz_arg",
            "str_count",
            "df_ref",
            "read_sas",
            "test_groupby_preserves_sort",
            "test_to_html_formatters",
            "time_datetime_field_day",
            "_constructor_sliced",
            "test_interp_scipy_basic",
            "test_df_series_secondary_legend",
            "test_frame_loc_callable_mixture",
            "stack",
            "test_raises_on_non_datetimelike_index",
            "_validate_dt64_dtype",
            "_encode_complex",
            "test_index_names_multiple_nones",
            "test_getitem_fancy",
            "period_break",
            "safe_sort",
            "two_linebreaks_between_sections",
            "_is_label_or_level_reference",
            "test_built_in_round",
            "test_constructor_arrays_and_scalars",
            "test_getitem_boolean_object",
            "_maybe_coerce_indexer",
            "test_set_column_names_in_parameter",
            "test_get_indexer_same_categories_different_order",
            "time_sortlevel_one",
            "_parse_no_numpy",
            "test_regex_replace_list_mixed_inplace",
            "test_bar_bad_align_raises",
            "test_set_index_makes_timeseries",
            "clip_upper",
            "test_reduce",
            "test_as_array_datetime",
            "test_interpolate_invalid_float_limit",
            "test_getitem_setitem_slice_bug",
            "test__has_infs",
            "test_getitem_regression",
            "test_constructor_no_coercion",
            "test_replace_pure_bool_with_string_no_op",
            "_comp_method_FRAME",
            "test_interpolate_time_raises_for_non_timeseries",
            "test_emptylike_constructor",
            "visit_Str",
            "test_constructor_list_of_namedtuples",
            "test_stata_doc_examples",
            "test_extract_expand_True",
            "_min_fitting_element",
            "test_convert_numeric_uint64_nan_values",
            "test_indexing_with_datetime_tz",
            "test_get_nan_multiple",
            "_f3_mapping",
            "take_nd",
            "test_apply_to_empty_series",
            "_noarg_wrapper",
            "test_select_dtypes_exclude_include_using_list_like",
            "raw_frame",
            "test_to_period_microsecond",
            "test_reindex_categorical",
            "test_to_csv_sparse_dataframe",
            "test_timedelta64_ops_nat",
            "test_corr_cov_independent_index_column",
            "nontemporal_method",
            "run",
            "test_to_datetime_now",
            "test_loc_multiindex_labels",
            "test_no_order",
            "test_ctor_reindex",
            "time_get",
            "test_iat_invalid_args",
            "_translate_key",
            "test_unstack_fill_frame",
            "test_at_with_tz",
            "test_writer_117",
            "_get_suffix_prefix",
            "_check_logical_ops",
            "check_floor_division",
            "test_NaT_cast",
            "test_callable_usecols",
            "test_frame_getitem_setitem_multislice",
            "test_hist_df_kwargs",
            "test_replace_dict_tuple_list_ordering_remains_the_same",
            "__finalize__",
            "test_month_range_union_tz_pytz",
            "test_is_timedelta64_ns_dtype",
            "test_append_empty_dataframe",
            "test_read_write_dta13",
            "test_pivot_table_values_key_error",
            "check_fun_data",
            "_get_closing_time",
            "_ensure_localized",
            "_agg_by_level",
            "test_set_closed",
            "test_partial_slice_doesnt_require_monotonicity",
            "test_reset_index_right_dtype",
            "test_all_invalid_plot_data",
            "test_from_index",
            "test_is_extension_array_dtype",
            "safe_import",
            "test_format_explicit",
            "test_set_dtype_nans",
            "fill_zeros",
            "time",
            "make_nancomp",
            "test_equals_categoridcal_unordered",
            "test_to_html_with_id",
            "test_assert_idxminmax_raises",
            "test_getitem_fancy_slice_integers_step",
            "test_merge_on_int_array",
            "test_concat_NaT_dataframes_all_NaT_axis_1",
            "test_override_inferred_closed",
            "test_smaller_Raises_Value",
            "_convert_to_style_kwargs",
            "test_var_std",
            "test_difference_name_preservation",
            "test_slice_locs_dup_numeric",
            "test_expanding_cov_pairwise",
            "test_missing_required_dependency",
            "_has_valid_setitem_indexer",
            "indices",
            "test_maybe_promote_int_with_int",
            "test_very_wide_info_repr",
            "test_excel_cell_error_na",
            "test_union_categoricals_nan",
            "test_repr_chop_threshold",
            "test_loc_getitem_frame",
            "test_categorical_categories",
            "test_require_integers",
            "test_hist",
            "test_to_csv_gcs",
            "_zero_out_fperr",
            "test_construction_empty_with_bool_categories",
            "is_float_dtype",
            "test_conv_daily",
            "test_unstack_non_unique_index_names",
            "test_get_indexer_categorical_time",
            "test_pi_sub_intarray",
            "test_sparse_accessor_updates_on_inplace",
            "test_subclass_unstack",
            "iterrows",
            "test_allow_exact_matches_and_tolerance_nearest",
            "test_asfreq_combined",
            "test_order_compat",
            "time_any",
            "test_series_partial_set_with_name",
            "test_min_max",
            "test_to_sql",
            "extract",
            "next_monday",
            "test_cat_accessor_no_new_attributes",
            "indent",
            "test_to_string_buffer_all_unicode",
            "test_sum_inf",
            "rsub",
            "test_dataframe_dummies_with_na",
            "test_constructor_year_and_quarter",
            "init_no_clipboard",
            "testMult2",
            "test_thousands_macau_stats",
            "_period_array_cmp",
            "test_to_dict_numeric_names",
            "test_dti_shift_tzaware",
            "test_name_error_exprs",
            "_time_to_micros",
            "test_get_indexer_nearest_error",
            "test_operators_datetimelike_with_timezones",
            "test_nested_exception",
            "test_constructor_dict_of_iterators",
            "test_cython_transform_series",
            "_hash_categories",
            "jsonl_file",
            "max_level_test_input_data",
            "_assert_not_frame_equal_both",
            "test_dropna_corner",
            "test_tz_dateutil",
            "test_expanding_cov_diff_index",
            "test_where_datetime_conversion",
            "test_setitem_different_unordered_raises",
            "test_to_perioddelta",
            "encode_decode",
            "test_read_table_absent_raises",
            "test_na_levels",
            "test_boundary_float",
            "test_precision_finer_than_offset",
            "test_index_equal_values_mismatch",
            "time_split",
            "test_to_html_round_column_headers",
            "_is_na_fill_value",
            "append_to_multiple",
            "test_dti_tz_localize_errors_deprecation",
            "test_construction_list_tuples_nan",
            "test_temporary_table",
            "test_basic_drop_first",
            "test_set_index_custom_label_hashable_iterable",
            "test_getitem_setitem_datetime_tz_dateutil",
            "test_axis_limits",
            "to_frame",
            "test_reindex_lvl_preserves_type_if_target_is_empty_list_or_array",
            "test_fancy",
            "test_multiindex_slicers_datetimelike",
            "makeRangeIndex",
            "test_setitem_with_unaligned_tz_aware_datetime_column",
            "time_from_int",
            "test_compare_timedelta_series",
            "test_usecols_str",
            "test_intersection_different_type_base",
            "test_bins_monotonic_not_overflowing",
            "_reindex_index",
            "test_to_records_dtype",
            "test_pi_ops_nat",
            "test_dataframe_categorical_ordered_observed_sort",
            "test_unique_na_fill",
            "test_setitem_series_datetime64",
            "test_join_inner",
            "frame2",
            "test_sort_index_inplace",
            "_get_merge_keys",
            "test_equals_op_multiindex_identify",
            "test_usecols_out_of_bounds",
            "test_resample_consistency",
            "test_loc_getitem_dups",
            "test_to_csv_from_csv_w_some_infs",
            "test_getitem_day",
            "test_max_nan_bug",
            "get_sys_info",
            "test_create_categorical",
            "time_itertuples_raw_tuples_to_list",
            "maybe_dispatch_ufunc_to_dunder_op",
            "__getattr__",
            "test_rolling_consistency",
            "test_stringify_path_pathlib",
            "test_take_bad_bounds_raises",
            "test_get_level_values_int_with_na",
            "test_set_none",
            "test_constructor_tuples_datetimes",
            "test_dt64arr_iadd_timedeltalike_scalar",
            "test_crosstab_margins",
            "test_mod_timedelta64_nat",
            "test_combineFunc",
            "test_read_chunksize_with_index",
            "_holder",
            "test_to_timestamp_pi_nat",
            "test_preserve_on_ordered_ops",
            "test_max_map_len",
            "test_readonly_axis_blosc",
            "test_odict",
            "test_date_range_normalize",
            "npoints",
            "_round_frac",
            "test_merge_left_notempty_right_empty",
            "test_interpolate_corners",
            "test_setitem_always_copy",
            "astype1",
            "test_repr_html_float",
            "time_frame_mask_floats",
            "_create_method",
            "get_attrs",
            "data_missing_for_sorting",
            "test_concat_series",
            "test_loc_getitem_list_with_fail",
            "test_full_file",
            "compare_series_dt_tz",
            "test_non_space_filler",
            "_range_from_fields",
            "test_append_series",
            "test_dti_shift_freqs",
            "test_read_with_parse_dates_invalid_type",
            "test_area_colors",
            "_is_unique",
            "_raw_hex_id",
            "test_binops_pow",
            "float_frame_int_kind",
            "test_comment_default",
            "test_constructor_dict_order_by_values",
            "_na_map",
            "test_update_datetime_tz",
            "test_values_duplicates",
            "test_get_indexer_invalid",
            "test_astype_cast_object_int_fail",
            "test_aggregate_str_func",
            "from_arrays",
            "test_ngroup_mi",
            "test_map_fallthrough",
            "test_comparators",
            "test_where_bug_mixed",
            "test_complex_table",
            "is_iterator",
            "test_tight_layout",
            "test_sort_index_different_sortorder",
            "test_asfreq_near_zero_weekly",
            "test_merge_datatype_error_raises",
            "_validate_skipfooter_arg",
            "test_check_label_or_level_ambiguity_series_axis1_error",
            "test_unstack_preserve_types",
            "has_table",
            "test_compare_scalar",
            "test_union_sort_other_empty_sort",
            "test_offset_n",
            "test_series_set_tz_timestamp",
            "test_shift_months",
            "set_labels",
            "test_clip_mixed_numeric",
            "test_apply_no_name_column_conflict",
            "_get_numeric_engines",
            "test_empty_groups_corner",
            "_resampler_for_grouping",
            "_get_multiindex_indexer",
            "test_constructor_scalar",
            "test_highlight_max",
            "_rolling_window",
            "test_labels_out_of_bound",
            "teardown",
            "test_dropna_tz_aware_datetime",
            "test_df_bool_mul_int",
            "test_pie_df",
            "test_frame_tz_localize",
            "test_non_callable_aggregates",
            "test_with_na_groups",
            "test_pivot_multi_values",
            "test_neq",
            "empty_series",
            "test_Minute",
            "_maybe_convert_to_int_keys",
            "test_apply_with_string_funcs",
            "get_loc_level",
            "test_take_filling_all_nan",
            "_maybe_convert_i8",
            "test_basic_types",
            "test_ndarray",
            "test_hashtable_large_sizehint",
            "is_valid_dtype_n_method",
            "test_set_index_preserve_categorical_dtype",
            "_convert_and_box_cache",
            "lag_plot",
            "test_annually_infer",
            "test_set_categories",
            "test_sort_index_level",
            "test_series_comparison_scalars",
            "test_iloc_array_not_mutating_negative_indices",
            "test_groupby_with_timezone_selection",
            "test_skip_bad_lines",
            "simple_period_range_series",
            "test_constructor_mrecarray",
            "test_order_with_freq",
            "test_dataframe_metadata",
            "test_invalid_delegation",
            "interpolate_2d",
            "_check_ne_builtin_clash",
            "_take_without_fill",
            "test_scatter_matrix_axis",
            "test_column_contains_raises",
            "skip_if_np_lt",
            "test_nans_skipna",
            "test_loc_getitem_duplicates_multiindex_empty_indexer",
            "test_parsers_iso8601_leading_space",
            "test_allow_exact_matches_and_tolerance_forward",
            "test_where_unobserved_categories",
            "test_dti_timestamp_fields",
            "test_skip_sum_object_raises",
            "_cython_transform",
            "__iter__",
            "mask_missing",
            "_repr_fits_vertical_",
            "test_reopen_handle",
            "test_describe_datetime_columns",
            "test_frame_setitem_timestamp",
            "test_warn_bad_lines",
            "test_logical_compat",
            "test_categorical_index",
            "test_difference_sort",
            "test_doesnt_contain_all_the_things",
            "test_loc_index",
            "test_cat_accessor",
            "run_frame",
            "test_dti_sub_int",
            "test_date_parse_failure",
            "test_hash_vs_equality",
            "test_hist_kwargs",
            "test_block_deprecated",
            "_make_stat_function_ddof",
            "test_assert_not_almost_equal_inf",
            "test_where_bug_transposition",
            "test_datetime64_tz_fillna",
            "test_partition_index",
            "_assert_frame_equal",
            "test_set_value_by_index",
            "test_constructor_with_data",
            "time_read_store_table",
            "assert_sp_series_equal",
            "test_regex_replace_series_of_regexes",
            "get_upcast_box",
            "month_roll",
            "test_iloc_getitem_multiple_items",
            "test_tseries_indices_frame",
            "test_value_counts_categorical_not_ordered",
            "select_as_multiple",
            "test_chunks_have_consistent_numerical_type",
            "test_setitem_ambig",
            "test_replace_compiled_regex",
            "test_type_promotion",
            "test_skiprows_by_index_inference",
            "test_nonoverlapping_monotonic",
            "test_to_latex_longtable",
            "test_meta_parameter_not_modified",
            "test_maybe_indices_to_slice_left_edge",
            "test_infer_index_col",
            "time_concat_empty_left",
            "_check_pairwise_moment",
            "test_update_dtype",
            "peakmem_fixed",
            "time_from_pydatetime",
            "test_mul_td64arr",
            "test_td64arr_div_numeric_array",
            "test_invalid_file_buffer_class",
            "test_loc_listlike",
            "test_to_latex_multiindex_names",
            "test_downsample_across_dst_weekly",
            "test_ts_area_lim",
            "test_basic_categorical",
            "new_func_with_deprecation",
            "test_fwf_comment",
            "test_merge_inner_join_empty",
            "test_setitem_dtype_upcast",
            "to_sql",
            "test_custom_comment_char",
            "test_array16",
            "test_apply_numeric_coercion_when_datetime",
            "slice",
            "test_from_spmatrix",
            "delegate_names",
            "test_set_none_nan",
            "time_match",
            "test_period_index_length",
            "test_to_datetime_format_YYYYMMDD_overflow",
            "test_gap_upsample",
            "test_bool_operators_with_nas",
            "_aggregate_series_fast",
            "test_moment_functions_zero_length_pairwise",
            "_binop",
            "test_iteration_preserves_nanoseconds",
            "test_partial_setting",
            "test_round_trip_current",
            "test_try_aggregate_non_existing_column",
            "test_compress_group_combinations",
            "time_itertuples_raw_tuples",
            "test_to_json_period_index",
            "time_endswith",
            "truncate",
            "test_first_last_max_min_on_time_data",
            "test_intelligently_handle_join_key",
            "test_nunique_with_object",
            "test_invalid_origins",
            "test_scikit_learn",
            "test_convert_numeric_uint64_nan",
            "test_query_with_nested_special_character",
            "test_resample_basic",
            "test_isin_level_kwarg",
            "test_apply_transform",
            "test_generate",
            "test_append_concat_tz_dateutil",
            "test_ewma_nan_handling",
            "buffer_put_lines",
            "test_read_sql",
            "test_handle_overlap_arbitrary_key",
            "test_quarterly_infer",
            "_is_boolean",
            "test_reindex_multi_categorical_time",
            "test_plot_outofbounds_datetime",
            "test_setitem_with_unaligned_sparse_value",
            "test_subclass_align_combinations",
            "_is_level_reference",
            "_get_row",
            "test_slice_duplicate_monotonic",
            "test_intersect",
            "take",
            "test_df_use_case",
            "test_indexing_zerodim_np_array",
            "test_dti_cmp_tdi_tzawareness",
            "data_label",
            "test_crosstab_with_empties",
            "test_make_block_boundary",
            "test_where_subset_compare_with_applymap",
            "testFixRaw",
            "test_complex_mixed_table",
            "_format_labels",
            "test_fillna_categorical_raise",
            "time_string_get_loc",
            "_check_op_float",
            "test_pivot_table_nocols",
            "time_itertuples",
            "_nanpercentile_1d",
            "test_get_indexer",
            "test_has_comprehensive_tests",
            "_process_columnlist_subheader",
            "test_blocks_compat_GH9037",
            "consolidate",
            "test_to_datetime_tz_psycopg2",
            "test_numeric_dtypes",
            "test_bad_arg_length_max_value_single",
            "test_dtype_on_categorical_dates",
            "time_isin_few_different",
            "get_keywords",
            "test_to_html_filename",
            "test_immutable",
            "test_ix_multi_take_nonint_index",
            "test_hist_df_coord",
            "tests_empty_df_rolling",
            "parameter_mismatches",
            "test_roundtrip",
            "float_frame_fill2",
            "test_difference_type",
            "test_valid_deprecated",
            "test_constructor_no_data_string_type",
            "to_hierarchical",
            "test_agg_lambda_with_timezone",
            "test_cat_accessor_updates_on_inplace",
            "test_plot_accessor_updates_on_inplace",
            "assert_onOffset",
            "test_query_with_unnamed_multiindex",
            "test_alias_to_unit_raises",
            "test_margin_dropna",
            "test_td64arr_div_tdlike_scalar",
            "test_int_array",
            "is_interval_dtype",
            "test_reindex_method",
            "test_write_variable_label_errors",
            "test_concat_empty_series_dtypes",
            "test_set_levels_codes_names_bad_input",
            "test_construction_from_string_errors",
            "test_categorical_nan_only_columns",
            "result",
            "test_astype_from_categorical",
            "f",
            "test_loc_series",
            "test_set_attribute",
            "test_resample_incompat_freq",
            "test_constructor_series",
            "time_reindex_axis0",
            "test_describe",
            "_make_sorted_values_labels",
            "_take_new_index",
            "test_loc_setitem_frame",
            "test_format_integer_names",
            "test_to_coo_bad_partition_small_union",
            "test_multiindex_unique",
            "_gotitem",
            "test_size_groupby_all_null",
            "test_keys_ignore_hdf_softlink",
            "has_resolvers",
            "test_fwf_for_uint8",
            "interval_range",
            "test_get_group_empty_bins",
            "test_to_dict_invalid_orient",
            "test_td_from_repr_roundtrip",
            "test_list_mixed",
            "test_read_json_table_orient_raises",
            "test_transpose_non_default_axes",
            "indexer_at_time",
            "test_setitem_index_int64",
            "test_empty_groups",
            "_get_colors",
            "test_misc_coverage",
            "test_summary_deprecated",
            "time_read_stata",
            "test_Hour",
            "test_loc_iterable",
            "time_rank_int",
            "test_max_valid",
            "test_ufunc_fallback",
            "test_assert_almost_equal_numbers_with_zeros",
            "test_transpose_tzaware_2col_single_tz",
            "test_assign_dependent_old_python",
            "test_na_values",
            "test_handle_join_key_pass_array",
            "test_apply_broadcast",
            "test_crosstab_with_numpy_size",
            "_sub_datelike",
            "test_utc_box_timestamp_and_localize",
            "time_intersection_one_duplicate",
            "test_constructor_with_dtype",
            "generate_indices",
            "test_lookup_mixed",
            "unpack",
            "test_where_object",
            "isAnchored",
            "test_with_local_timezone_dateutil",
            "test_metadata_propagation_indiv",
            "test_verify_integrity_deprecated",
            "test_tz_setter_raises",
            "assert_stat_op_api",
            "test_ellipsis",
            "test_bool_array",
            "test_merge_nosort",
            "test_day_not_in_month_ignore",
            "test_datetime64formatter_hoursecond",
            "test_series_constructor_with_dtype",
            "_allow_na_ops",
            "test_quarterly_negative_ordinals",
            "test_raw32",
            "test_assert_almost_equal_dict_like_object",
            "test_parr_cmp_pi_mismatched_freq_raises",
            "test_fillna_inplace",
            "index_subclass_makers_generator",
            "_check_bool_result",
            "test_transform_select_columns",
            "test_argmax_axis_invalid",
            "_check_percentile",
            "test_div_zero",
            "test_concat_bug_2972",
            "test_value_counts_preserves_tz",
            "test_resample_bms_2752",
            "test_repr_corner",
            "test_iloc_getitem_list_int",
            "np_datetime64_compat",
            "_process_parse_dates_argument",
            "test_construct_with_different_start_end_string_format",
            "test_import_optional",
            "time_qcut_datetime",
            "visit_Compare",
            "test_array_copy",
            "test_conflicting_excel_engines",
            "_get_sorted_data",
            "missing_metadata",
            "highlight_max",
            "_check_comments",
            "ntemps",
            "test_greater_Raises_Type",
            "test_assert_almost_equal_value_mismatch3",
            "_maybe_make_multi_index_columns",
            "test_append_sorts",
            "test_constructor_period",
            "_na_for_min_count",
            "validate_args",
            "test_combine_first_dt_tz_values",
            "time_frame_nth_any",
            "test_tolerance_tz",
            "getTimeSeriesData",
            "time_dayofweek",
            "test_corr_sanity",
            "test_setitem_fancy_scalar",
            "test_frame",
            "in_ipython_frontend",
            "test_numpy_squeeze",
            "test_skip_initial_space",
            "test_resample_nonexistent_time_bin_edge",
            "test_getitem_setitem_periodindex",
            "test_info_memory",
            "test_getitem_setitem_ix_bool_keyerror",
            "test_maybe_promote_any_with_timedelta64",
            "test_df_div_zero_series_does_not_commute",
            "axisinfo",
            "_convert_datetime_to_stata_type",
            "format_object_attrs",
            "test_rank_modify_inplace",
            "test_index_equal_level_values_mismatch",
            "test_read_chunksize_jagged_names",
            "test_localize_pydatetime_dt_types",
            "time_fillna",
            "test_merge_na_keys",
            "test_extension_array_cross_section_converts",
            "_from_name",
            "test_where_array_like",
            "test_corr_non_numeric",
            "test_constructor_manager_resize",
            "test_frame_datetime64_handling_groupby",
            "test_merge_join_categorical_multiindex",
            "test_scalar_ops_from_sequence_raises",
            "test_construct_with_different_string_format",
            "test_to_csv_multi_index",
            "test_constructor_bool_fill_value",
            "test_index_false_to_json_table",
            "test_getitem_index",
            "test_multiindex_header",
            "test_get_bool_data",
            "test_from_tzaware_object_array",
            "test_where_index_timedelta64",
            "test_timestamp_repr_pre1900",
            "test_index_false_error_to_json",
            "time_is_quarter_start",
            "zero",
            "test_usecols_with_whitespace",
            "test_to_period_tz_warning",
            "test_dataframe_dummies_preserve_categorical_dtype",
            "test_loc_getitem_lowerdim_corner",
            "autocorr",
            "test_backfill",
            "api_doc",
            "resample_method",
            "_any_not_none",
            "testUnsignedInt",
            "_process_page_meta",
            "time_partition",
            "set_testing_mode",
            "_result_type_many",
            "__reduce__",
            "test_bar_log_no_subplots",
            "no_infinitive",
            "test_shift_categorical",
            "test_sparse_int",
            "test_interp_datetime64",
            "from_frame",
            "test_unstack_unused_levels",
            "test_barely_out_of_bounds",
            "test_cast_scalar_to_array",
            "test_bar_align_mid_vmax",
            "test_coercion_with_loc_and_series",
            "test_multiple_date_col_named_index_compat",
            "test_fillna_length_mismatch",
            "_add_legend_handle",
            "time_dt_accessor_time",
            "_get_block_manager_axis",
            "test_frame_on2",
            "test_frame_negate",
            "test_left_join_multi_index",
            "test_groupby_wrong_multi_labels",
            "check_bool_indexer",
            "test_tdi_add_int",
            "test_header_multi_index_common_format1",
            "test_groupby_extension_apply",
            "test_group_var_generic_2d_some_nan",
            "test_3d_fill_nonna",
            "combine_first",
            "unstack",
            "test_bad_min_fname_arg_count",
            "validate_col",
            "asi8",
            "test_query_compare_column_type",
            "test_write_append_mode_raises",
            "test_array_numpy_except",
            "test_dti_add_intarray_no_freq",
            "test_float_max",
            "test_pivot_margins_name_unicode",
            "test_2000",
            "test_custom_na_values",
            "_get_standard_colors",
            "test_series_agg_multikey",
            "test_empty_with_multi_index_pass_dtype",
            "test_frame_getitem_not_sorted2",
            "test_allow_exact_matches_and_tolerance",
            "peakmem_itertuples_raw_start",
            "time_check_concat",
            "_values_for_argsort",
            "test_apply_bad_labels",
            "_union_indexes",
            "difference",
            "test_set_value",
            "test_large_multiindex_error",
            "test_non_unique_idvars",
            "test_query_doesnt_pickup_local",
            "_to_sql_empty",
            "test_list",
            "test_map_type_inference",
            "_str_extract_frame",
            "test_td64arr_add_datetime64_nat",
            "test_integer_array_constructor",
            "test_to_records_dt64",
            "_format_data",
            "test_to_excel_multiindex_dates",
            "iris",
            "test_concatlike_dtypes_coercion",
            "any_string_method",
            "test_partial_set_empty_frame_empty_consistencies",
            "test_to_json_float_index",
            "test_apply_scaler_on_date_time_index_aware_series",
            "test_set_index_period",
            "test_closed_left_corner",
            "test_order_hashes_different",
            "nanall",
            "test_error_with_zero_monthends",
            "_reduce",
            "test_nanstd",
            "test_date_range_timezone_str_argument",
            "create_description",
            "test_setitem_same_but_unordered",
            "test_millisecond_repr",
            "test_loc_getitem_across_dst",
            "_validate_frequency",
            "_execute_create",
            "test_constructor_invariant",
            "visit_Slice",
            "test_intersection_zero_length",
            "drop_table",
            "test_errorbar_asymmetrical",
            "test_forward_by",
            "test_consistency_with_tz_aware_scalar",
            "test_constructor_imaginary",
            "test_arith_series_with_scalar",
            "missing_params",
            "test_fy5253qtr_onoffset_nearest",
            "_list_to_arrays",
            "test_diff_mixed_dtype",
            "test_partial_set_empty_frame_empty_copy_assignment",
            "test_basic",
            "test_series_bin_grouper",
            "test_info_memory_usage",
            "time_f_ordered",
            "time_quantile",
            "time_floor",
            "test_compression_warns_when_decompress_caches_zlib",
            "test_dti_tz_convert_utc_to_local_no_modify",
            "test_rolling_max_resample",
            "method",
            "test_shift_non_empty_array",
            "test_query_None",
            "test_compare_zerodim",
            "test_parr_cmp_pi",
            "test_bar_align_mid_all_neg",
            "test_invalid_file_buffer_mock",
            "test_set_index_datetime",
            "test_cythonized_aggers",
            "test_get_level_number_integer",
            "test_constructor_mismatched_codes_levels",
            "test_numeric_op_scalar",
            "test_array_ufunc_series_defer",
            "_check_roundtrip_table",
            "df_cross_compat",
            "register_extension_dtype",
            "pivot_table",
            "test_get_indexer_backfill",
            "validate_tz_from_dtype",
            "test_encode_numeric_overflow",
            "test_setitem_series_bool",
            "test_argsort_preserve_name",
            "test_detect_console_encoding_fallback_to_default",
            "build_string",
            "columns",
            "test_get_agg_axis",
            "test_no_color_bar",
            "test_shift2",
            "test_guess_datetime_format_invalid_inputs",
            "test_mixed_index_not_contains",
            "test_select_dtypes_datetime_with_tz",
            "test_td_sub_nat",
            "test_fillna_frame",
            "test_read_csv_wrong_num_columns",
            "test_compression",
            "test_bad_deprecate_kwarg",
            "test_isin_nan_not_pypy",
            "test_unstack_to_series",
            "test_scalar_conversion",
            "test_cython_group_transform_algos",
            "test_set_name_methods",
            "test_to_numpy_copy",
            "test_date_format_raises",
            "test_get_rule_month",
            "test_interp_nan_idx",
            "test_sequence_like_with_categorical",
            "time_convert_string_seconds",
            "process_axes",
            "to_timestamp",
            "test_dti_add_int",
            "test_mpl2_color_cycle_str",
            "test_float_truncation",
            "test_ts_plot_with_tz",
            "test_filter_and_transform_with_non_unique_float_index",
            "test_fwf_colspecs_none",
            "test_eof_has_eol",
            "time_slice_step",
            "time_boolean_rows",
            "test_date_nanos",
            "read_sparse_intindex",
            "test_to_sql_append",
            "test_concatlike_common_period_mixed_dt_to_object",
            "test_concat_keys_with_none",
            "test_array_multiindex_raises",
            "test_boolean_context_compat",
            "test_setitem_multiple_partial",
            "test_validate_indices_low",
            "test_concat_different_fill_value",
            "test_get_freq_roundtrip2",
            "test_get_schema_create_table",
            "__floordiv__",
            "test_keyword_arg",
            "_get_period_range_edges",
            "test_td64arr_mod_tdscalar",
            "test_concat_copy",
            "test_rsplit",
            "test_string_index_repr_with_unicode_option",
            "test_datetime_indexing",
            "test_date_query_with_attribute_access",
            "test_truncate_copy",
            "test_concat_NaT_dataframes_all_NaT_axis_0",
            "test_frame_tz_convert",
            "test_to_offset_invalid",
            "test_pad_nan",
            "test_repr_bool_fails",
            "test_select_dtypes_exclude_using_scalars",
            "test_simple_cmp_ops",
            "test_axis_alias",
            "test_datetimeindex_sub_timestamp_overflow",
            "test_frame_dict_constructor_datetime64_1680",
            "test_to_datetime_parse_timezone_malformed",
            "test_constructor_orient",
            "test_pi_comp_period",
            "test_grouper_index_types",
            "test_empty_timeseries_reductions_return_nat",
            "test_assert_almost_equal_object",
            "test_ix_multi_take",
            "test_repr_matches",
            "test_values_multiindex_datetimeindex",
            "test_bar_align_mid_nans",
            "_is_numeric",
            "test_fails_ampersand",
            "test_index_convert_to_datetime_array",
            "test_excel_raise_error_on_multiindex_columns_and_no_index",
            "test_getitem_bool_index_all",
            "test_constructor_overflow_int64",
            "test_setitem_other_callable",
            "test_multiindex_get_loc",
            "_getitem_lowerdim",
            "pack",
            "test_infer_dtype_from_int_scalar",
            "numeric_idx",
            "test_apply_args",
            "has_invalid_return_type",
            "numeric_as_float",
            "assert_datetime_array_equal",
            "test_components",
            "_repr_fits_horizontal_",
            "test_resample_dtype_coerceion",
            "_set_binner",
            "_complevel",
            "test_apply_standard_nonunique",
            "is_term",
            "test_get_dummies_duplicate_columns",
            "test_dti_with_timedelta64_data_deprecation",
            "test_nonzero",
            "test_infer_datetimelike_array_nan_nat_like",
            "test_subplots_multiple_axes",
            "test_pairs",
            "_sanitize_and_check",
            "test_iloc_getitem_slice",
            "test_styler_to_excel",
            "is_datetime_arraylike",
            "test_df_mod_zero_int",
            "test_extract_single_group_returns_frame",
            "series_of_dtype_all_na",
            "test_operators_empty_int_corner",
            "test_select_dtypes_include_using_list_like",
            "test_bad_generic_functions",
            "time_union",
            "test_can_set_locale_invalid_set",
            "visit_BoolOp",
            "test_unique_id",
            "_should_fill",
            "test_partial_set_invalid",
            "assert_label_values",
            "test_css_relative_font_size",
            "test_ffill",
            "test_comparison_with_unknown_scalars",
            "register_converter_cb",
            "test_date_and_index",
            "test_iter_box",
            "ceil",
            "test_parse_dates_column_list",
            "_try_import",
            "test_float64_unit_conversion",
            "nansem",
            "cumcount",
            "test_dt64arr_add_timedeltalike_scalar",
            "_get_indices",
            "test_custom_value_name",
            "test_smallerEqual_Raises_Value",
            "test_grouper_creation_bug",
            "test_rolling_std",
            "test_concat_bug_1719",
            "_assert_where_conversion",
            "test_comment_empty_line",
            "test_hash_array",
            "test_constructor_nanosecond",
            "time_pandas_dtype_invalid",
            "read_html",
            "test_eq",
            "test_from_categorical_dtype_identity",
            "_assert_not_frame_equal",
            "test_asfreq_fill_value",
            "test_encode_string_conversion",
            "test_pi_add_iadd_int",
            "test_concat_empty_and_non_empty_series_regression",
            "test_stack_mixed_levels",
            "test_cast_1d_array_invalid_scalar",
            "test_setitem_mask_aligned",
            "test_read_gbq_with_deprecated_kwargs",
            "test_infer_dtype_datetime",
            "test_interp_bad_method",
            "test_dti_tz_convert_dst",
            "test_plot_scatter",
            "test_set_ops_error_cases",
            "test_properties_minutely",
            "time_join_dataframe_index_multi",
            "test_ordered_api",
            "test_to_timedelta_box_deprecated",
            "_reindex_axis",
            "test_andrews_curves",
            "queryables",
            "test_from_codes_with_dtype_raises",
            "test_findall",
            "test_cdaterange",
            "test_unary_functions",
            "test_drop_duplicates_categorical_non_bool",
            "time_zfill",
            "test_join_segfault",
            "tests_indexing_with_sparse",
            "_clip_with_one_bound",
            "test_duplicate_int_indexing",
            "test_partial_slice_hourly",
            "_write_header",
            "test_nested_flattens",
            "time_interpolate_some_good",
            "test_merge_series",
            "test_equals_op_index_vs_mi_same_length",
            "getMixedTypeDict",
            "test_corr_invalid_method",
            "test_repr_is_valid_construction_code",
            "test_under_specified",
            "test_same_object_is_in",
            "cvalues",
            "_read_bytes",
            "test_reconstruction_index",
            "_check_inplace_setting",
            "time_iloc",
            "_sub_period_array",
            "test_dti_add_sub_nonzero_mth_offset",
            "test_bins_not_overlapping_from_interval_index",
            "test_fillna_iterable_category",
            "test_iteration_preserves_tz",
            "_set_subtyp",
            "test_lower_upper",
            "test_identical_stubnames",
            "test_where_bug",
            "test_valid_month_attributes",
            "tail",
            "get_atom_string",
            "test_astype_bool",
            "_get_ax_layer",
            "test_bool_indexing",
            "test_unit",
            "time_ix",
            "versions_from_parentdir",
            "test_isnull_for_inf_deprecated",
            "test_count_non_nulls",
            "frame_with_period_index",
            "df_cat",
            "test_map_dictlike",
            "test_describe_empty_categorical_column",
            "test_ceil_floor_edge",
            "time_frame_date_formatting",
            "_bins_to_cuts",
            "test_loc_slicing",
            "test_Microsecond",
            "test_resample_string_kwargs",
            "test_range_closed_with_tz_aware_start_end",
            "test_grouped_box_layout",
            "test_to_int_index",
            "test_replace_value_is_none",
            "test_setitem_empty",
            "match",
            "test_groupby_apply_none_first",
            "test_dialect_conflict_except_delimiter",
            "_values",
            "check_result",
            "attrs",
            "test_unique_index_series",
            "test_pass_dtype",
            "_wrap_transformed_output",
            "test_frame_timeseries_to_records",
            "test_cumsum_corner",
            "ohlc",
            "test_intersect_equal_sort",
            "test_as_json_table_type_categorical_dtypes",
            "_sphinx_build",
            "assert_all",
            "test_maybe_infer_to_datetimelike_ser_construct",
            "test_stats_mixed_type",
            "_assert",
            "test_first_last_tz",
            "test_boolean_selection",
            "_maybe_localize_point",
            "test_group_var_constant",
            "test_comment_arg",
            "assert_copy",
            "time_nested_dict_index_columns",
            "is_platform_little_endian",
            "test_import_error_message",
            "test_parr_add_sub_td64_nat",
            "dups",
            "time_add_timedeltas",
            "test_repr_unicode",
            "test_rolling_max_gh6297",
            "time_lookup_ix",
            "test_get_values_deprecated",
            "test_mixed_arithmetic",
            "test_usecols_with_names",
            "test_dti_sub_tdi",
            "_setop",
            "test_gz_lineend",
            "test_count_object",
            "test_rdivmod_offset",
            "test_parametrized_factorize_na_value_default",
            "test_microsecond_repr",
            "test_where_dataframe_col_match",
            "time_different_str_functions",
            "test_set_item_nan",
            "test_to_pydatetime_nonzero_nano",
            "test_numpy_array_equal_unicode",
            "time_to_date",
            "_where",
            "closed",
            "test_tdi_mul_int_array_zerodim",
            "test_resample_to_period_monthly_buglet",
            "peakmem_itertuples_raw_to_list",
            "test_include_na",
            "test_value_counts_period",
            "test_describe_bool_frame",
            "test_constructor_iterator",
            "test_dti_tz_localize_pass_dates_to_utc",
            "test_bar_barwidth_position_int",
            "has_column_names",
            "left_multi",
            "latex",
            "test_rename_signature",
            "test_usage_via_getsizeof",
            "s_whitelist_fixture",
            "test_get_indexer_with_interval",
            "test_constructor_warns",
            "test_multi_index_unnamed",
            "test_td_mul_nat",
            "wrap_arithmetic_op",
            "test_dti_tdi_numeric_ops",
            "is_lexsorted",
            "test_bins_from_interval_index",
            "_clear_item_cache",
            "_add_deprecation_prefixes",
            "test_categorical_series_repr_datetime_ordered",
            "test_convert_objects_leave_decimal_alone",
            "test_an_exception_in_objecthook2",
            "ne_lt_2_6_9",
            "time_join_dataframe_index_single_key_small",
            "test_date_range_negative_freq",
            "dirpath",
            "test_bin8",
            "test_select_with_many_inputs",
            "_construct_dataframe",
            "test_downcast_invalid_cast",
            "test_copy_and_deepcopy",
            "test_groupby_multiindex_tuple",
            "build_components",
            "test_simple",
            "test_union_coverage",
            "test_from_items_deprecation",
            "test_reset_index_drop_errors",
            "test_isna_extension_array",
            "test_equals_numeric",
            "test_to_datetime_parse_tzname_or_tzoffset",
            "test_td64arr_sub_period",
            "test_from_datetime64_freq_changes",
            "test_group_var_generic_2d_all_finite",
            "test_apply_describe_bug",
            "test_astype_mixed_float",
            "test_cached_range_bug",
            "test_update_ctx_flatten_multi_traliing_semi",
            "build_table_schema",
            "time_sort_values",
            "test_repr_no_warning",
            "test_parsers_iso8601_invalid_offset_invalid",
            "__iadd__",
            "test_tdi_mul_float_series",
            "_get_default_locs",
            "test_irreg_hf",
            "_make_comparison_op",
            "time_dayofyear",
            "to_perioddelta",
            "time_normalize",
            "test_dti_construction_univalent",
            "test_equals_operator",
            "test_dataframe_constructor",
            "test_create_index_existing_name",
            "test_rolling_functions_window_non_shrinkage_binary",
            "test_loc_with_scalar",
            "test_mgr_locs",
            "test_is_period_deprecated",
            "_remove_spaces_column_name",
            "cut",
            "test_replace_swapping_bug",
            "ncols",
            "_get_distinct_objs",
            "time_join",
            "test_data_frame_size_after_to_json",
            "test_slice_float64",
            "test_stringify_columns",
            "set_value",
            "is_leap_year",
            "test_parr_cmp_period_scalar2",
            "test_apply_mixed_dtype_corner",
            "test_to_csv_headers",
            "test_multiindex_negative_level",
            "_maybe_to_categorical",
            "test_clip_against_list_like",
            "idx_cols_multi",
            "test_scalar_na_logical_ops_corners",
            "test_to_datetime_utc_true",
            "test_na_trailing_columns",
            "time_query_datetime_column",
            "_is_sub",
            "test_maybe_convert_timedelta",
            "_load_obj",
            "maybe_iterable_to_list",
            "need_slice",
            "test_invalid_compression",
            "test_astype_period",
            "safe_cast",
            "_has_bool_dtype",
            "test_constructor_bool",
            "test_multi_nan_indexing",
            "test_loc_setitem_with_existing_dst",
            "test_mode",
            "_consolidate_key",
            "test_column_format",
            "test_merge_non_unique_index_many_to_many",
            "test_categorical_repr_period",
            "_check_op",
            "test_categorical_dtype_utf16",
            "test_header_and_index_no_types",
            "test_categorical_consistency",
            "test_offset_corner_case",
            "_dir_deletions",
            "test_mangles_multi_index",
            "test_rename_nocopy",
            "_to_sql_method_callable",
            "test_setitem_with_tz",
            "test_format_percentiles",
            "test_minmax_nat_series",
            "test_select_dtypes_duplicate_columns",
            "assert_level_reference",
            "test_strftime",
            "test_int64_overflow_issues",
            "test_single_char_leading_whitespace",
            "single_level_multiindex",
            "test_integer_array_plot",
            "_adjust_to_origin",
            "test_tsplot",
            "time_and",
            "test_fillna_raises",
            "test_overlaps_invalid_type",
            "test_reset_index",
            "_has_complex_internals",
            "forbid_nonstring_types",
            "test_tab_complete_warning",
            "test_dt64arr_add_sub_parr",
            "test_iloc_setitem_int_multiindex_series",
            "test_divmod_offset",
            "test_write_cells_merge_styled",
            "test_quantile_nat",
            "test_read_columns",
            "test_errorbar_scatter",
            "_has_complex_date_col",
            "check_compound_invert_op",
            "test_autocorrelation_plot",
            "test_tzlocal_repr",
            "test_basics_nanos",
            "variable_labels",
            "_make_logical_function",
            "_maybe_check_integrity",
            "test_option_context_scope",
            "returns",
            "test_filter_bytestring",
            "_transform_index",
            "_run_os",
            "test_line_area_stacked",
            "_validate_header_arg",
            "test_subclass_empty_repr",
            "test_set_index_cast_datetimeindex",
            "test_nanops_independent_of_mask_param",
            "test_shift_dst",
            "test_apply_yield_list",
            "test_period_dt64_round_trip",
            "is_numeric",
            "_pop_header_name",
            "downcast",
            "_transaction_test",
            "test_no_right",
            "test_insert_index_float64",
            "test_groupby_extension_no_sort",
            "test_getitem_setitem_integer_slice_keyerrors",
            "test_time_field_bug",
            "test_period_astype_to_timestamp",
            "test_td64arr_sub_offset_array",
            "test_constructor_datetime64arr",
            "writable",
            "_test_data2_zero",
            "test_bool_array_logical",
            "test_append_empty_preserve_name",
            "test_format_percentiles_integer_idx",
            "test_timestamp_to_datetime",
            "test_append_to_multiple_dropna_false",
            "test_constructor_from_index_series_timedelta",
            "test_short_format_converters",
            "test_sort_index_name",
            "test_frame_equal_shape_mismatch",
            "test_to_html_basic_alignment",
            "test_xs_view",
            "select_as_coordinates",
            "test_interval_index",
            "asof_locs",
            "test_info_duplicate_columns",
            "test_hash_tuples",
            "test_bools",
            "test_uint64_factorize",
            "test_period_compat",
            "test_rename",
            "test_compression_utf16_encoding",
            "multiindex_year_month_day_dataframe_random_data",
            "test_detect_chained_assignment",
            "test_where_callable",
            "test_groupby_withnull",
            "get_reindexed_values",
            "test_path_localpath_hdfstore",
            "test_constructor_ndarray_copy",
            "factorize",
            "test_rdiv_zero_compat",
            "transform",
            "test_categorical_index_repr_period",
            "_test_small_strings_no_warn",
            "test_constructor_dict_cast",
            "test_omit_nuisance",
            "method_wo_docstrings",
            "time_drop_duplicates",
            "test_no_pairwise_with_self",
            "time_info",
            "test_replace_categorical",
            "_get_period_bins",
            "test_colaliases",
            "_set_encoding",
            "test_monthly_upsample",
            "_convert_cell",
            "test_sparse_series",
            "_inferred_type_levels",
            "test_constructor_object_dtype",
            "test_to_native_types",
            "andrews_curves",
            "test_join_nonunique",
            "series_of_dtype",
            "test_map_bug_1677",
            "test_categorical_repr_unicode",
            "test_dtype_all_columns",
            "test_expanding_cov",
            "test_groupby_multiindex_not_lexsorted",
            "test_isna_datetime",
            "test_maybe_convert_i8_numeric",
            "test_stat_op_calc",
            "strftime",
            "test_tz_aware_scalar_comparison",
            "test_infer_from_tdi_mismatch",
            "test_align_multiindex",
            "test_usecols_diff_positional_str_columns_order",
            "test_custom_var_and_value_name",
            "test_numpy_dtype",
            "test_datetimetz_dtype",
            "test_n",
            "test_transpose_get_view",
            "test_evenly_divisible_with_no_extra_bins",
            "to_latex",
            "test_million_record_attribute_error",
            "time_read_sql_table_column",
            "time_rfind",
            "test_map_with_non_function_missing_values",
            "test_decode_extreme_numbers",
            "generate_range",
            "test_select_empty_where",
            "test_small_strings_no_warn_blosc",
            "test_scalar_with_index_infer_dtype",
            "test_pi_sub_intlike",
            "test_hide_columns_single_level",
            "test_td64arr_mul_tdlike_scalar_raises",
            "test_clear",
            "test_read_zipped_json",
            "create_tempfile",
            "_add_logical_methods",
            "_fast_union",
            "test_rolling_var",
            "test_comprehensive",
            "test_timestamp_to_datetime_dateutil",
            "test_dataframe_dummies_prefix_dict",
            "_clear_buffer",
            "test_td64arr_add_sub_numeric_arr_invalid",
            "_add_table",
            "test_dti_add_intarray_tick",
            "time_float_int_str_lines",
            "test_td_rsub_nat",
            "read_array",
            "makeDataFrame",
            "test_really_large_in_arr_consistent",
            "test_opening_time",
            "test_grouper_multilevel_freq",
            "test_converters_euro_decimal_format",
            "test_repr_max_rows",
            "test_float_index",
            "test_sparse_reindex",
            "test_dt64arr_add_sub_float",
            "test_drop",
            "test_transform_numeric_ret",
            "test_grouped_box_multiple_axes",
            "test_decimal_rows",
            "update_info",
            "test_rank_first_pct",
            "test_pandas_array_dtype",
            "test_errors",
            "boxplot",
            "test_try_coerce_arg",
            "_is_convertible_to_td",
            "test_constructor_maskedrecarray_dtype",
            "four_level_index_dataframe",
            "color_to_excel",
            "time_asof_nan_single",
            "test_floating_tuples",
            "test_get_set_boolean_different_order",
            "test_dti_time",
            "test_constructor_dtypes_datetime",
            "test_partial_data",
            "test_merge_indexes_and_columns_lefton_righton",
            "_disabled",
            "test_5",
            "test_logical_typeerror_with_non_valid",
            "time_pairwise",
            "format_signature",
            "test_to_excel_unicode_filename",
            "test_overlaps_disjoint",
            "test_map_with_string_constructor",
            "test_values",
            "test_array_basic",
            "test_to_datetime_unparseable_ignore",
            "test_nanstd_roundoff",
            "is_datetimelike_v_numeric",
            "test_transform_length",
            "test_zero_length_input_index",
            "test_mul_index",
            "see_also",
            "test_truediv",
            "test_fillna_fill_other",
            "test_from_values_or_dtype_raises",
            "test_constructor_wrong_precision_raises",
            "test_to_html_multiindex_max_cols",
            "test_frame_datetime64_pre1900_repr",
            "test_margins_dtype",
            "test_iloc_non_integer_raises",
            "is_view",
            "overlaps",
            "column_data_lengths",
            "time_add_overflow_arr_rev",
            "lstrip",
            "test_to_dict_timestamp",
            "test_to_csv_stdout_file",
            "test_time_musec",
            "test_setitem_frame_upcast",
            "_pad_bytes_new",
            "tips_file",
            "test_get_indexer_nearest_decreasing",
            "test_to_datetime_unit",
            "test_is_not_object_type",
            "test_pass_function",
            "_get_frame_op_default_axis",
            "test_nan_str_index",
            "test_period_str_to_code",
            "time_read_json_lines_concat",
            "test_add_sub_timedeltalike_invalid",
            "_validate_format",
            "test_rolling_functions_window_non_shrinkage",
            "test_outer",
            "legend_title",
            "time_transform_multi_key2",
            "test_downcast_conversion_nan",
            "classes",
            "_get_grouper",
            "test_categorical_repr",
            "test_concatlike_same_dtypes",
            "time_series_nth_any",
            "test_regex_replace_scalar_inplace",
            "test_apply_frame_to_series",
            "is_transposed",
            "test_rotation",
            "test_single_backtick_variable_query",
            "pct_change",
            "test_empty_like",
            "test_int_float_union_dtype",
            "test_to_csv_line_terminators",
            "test_constructor_sequence_like",
            "_replot_ax",
            "get_is_dtype_funcs",
            "test_seriesgroupby_observed_apply_dict",
            "test_business_end_year_alias",
            "test_get_nan",
            "test_groupby_nonstring_columns",
            "_repr_latex_",
            "_get_na_values",
            "test_select_iterator_complete_8014",
            "_maybe_add_join_keys",
            "test_setitem_mulit_index",
            "test_dropna",
            "time_multi_int_count",
            "test_comparison_invalid",
            "test_sort_ascending_list",
            "get_utc_offset_hours",
            "time_frame_duplicated_wide",
            "test_dt64arr_sub_timedeltalike_scalar",
            "test_sparse_series_pad_backfill_limit",
            "test_tz_localize_errors_deprecation",
            "get_level_values",
            "test_shift_across_dst",
            "test_take_mixed_type",
            "all_mixed",
            "main",
            "test_path_local_path",
            "test_cython_agg_return_dict",
            "_repr_data_resource_",
            "test_mixed_dtypes_remain_object_array",
            "test_iloc_setitem",
            "time_store_info",
            "_wrap_generic_output",
            "test_groupby_list_infer_array_like",
            "test_frame_empty_mixedtype",
            "test_multi_key_multiple_functions",
            "int_frame",
            "test_constructor_dict_nan_tuple_key",
            "test_to_coo_text_names_integer_row_levels_sort",
            "test_overlaps_nested",
            "tests_skip_nuisance",
            "test_series_describe_multikey",
            "count",
            "test_squeeze",
            "_add_numeric_methods_binary",
            "is_callable",
            "test_is_scalar_builtin_scalars",
            "test_quote_char_basic",
            "test_tz_localize_convert_copy_inplace_mutate",
            "test_bar_center",
            "test_take_fill_value",
            "test_week_of_month_frequency",
            "test_between_time_raises",
            "test_array_like",
            "_create_data",
            "_prefix",
            "time_wrap",
            "test_decode_null_character",
            "test_groupby_level_index_names",
            "test_concat_odered_dict",
            "time_assign_with_setitem",
            "test_no_index",
            "_assert_can_do_op",
            "_get_single_group_name",
            "timedelta64_dtype",
            "test_numeric_arr_mul_tdscalar",
            "test_set_columns",
            "setup_driver",
            "time_series_dot",
            "test_bar_nan",
            "test_sqlite_type_mapping",
            "test_numpy_minmax_datetime64",
            "test_scalar_float",
            "test_nanvar_ddof",
            "test_td64arr_rmul_numeric_array",
            "test_is_boolean",
            "test_foobar",
            "generate_blob",
            "run_transaction",
            "test_gb_key_len_equal_axis_len",
            "test_array_timedelta_floordiv",
            "test_holidays",
            "test_to_timestamp_pi_mult",
            "time_func",
            "test_idxminmax_with_inf",
            "test_setitem_boolean_column",
            "test_union2",
            "test_construction_interval",
            "test_apply",
            "nansum",
            "_get_concat_axis",
            "test_fails_pipe",
            "test_eq_with_self",
            "test_regression_whitelist_methods",
            "test_from_scipy_correct_ordering",
            "test_parse_trim_buffers",
            "_process_columnattributes_subheader",
            "test_union_dataframe_index",
            "test_logical_ops_empty_frame",
            "test_insert_nat",
            "test_fill_value_when_combine_const",
            "_try_coerce_and_cast_result",
            "test_get_calendar",
            "rmul",
            "test_take_warns",
            "test_loc_getitem_label",
            "test_raise_on_passed_int_dtype_with_nas",
            "test_no_new_globals",
            "is_numeric_v_string_like",
            "test_length_zero",
            "test_str_to_bytes_raises",
            "test_usecols_with_parse_dates3",
            "test_insert_index_timedelta64",
            "_grouped_plot_by_column",
            "test_duplicated_with_misspelled_column_name",
            "test_integer_array_constructor_copy",
            "test_freq_setter_errors",
            "test_pct_change_periods_freq",
            "test_np_array_usecols",
            "test_nansum_buglet",
            "test_replace_input_formats_scalar",
            "time_categorical_series_is_monotonic_decreasing",
            "flatten",
            "test_dataframe_from_series",
            "_get_string_slice",
            "test_constructor_index_mismatch",
            "test_decimal_decode_test_precise",
            "test_integer_series_size",
            "nlargest",
            "float_string_frame",
            "test_constructor_regular",
            "test_groupby_multiple_key",
            "data",
            "create_axes",
            "ax",
            "test_date_unit",
            "offset_types",
            "test_non_convertable_values",
            "test_concatlike_common_coerce_to_pandas_object",
            "nested_to_record",
            "time_frame_sort_values",
            "get_values",
            "_write",
            "test_retain_index_attributes2",
            "makeFloatIndex",
            "test_from_records_empty_with_nonempty_fields_gh3682",
            "test_convert_dti_to_series",
            "test_compare_unordered_different_order",
            "apply_broadcast",
            "all_boolean_reductions",
            "test_to_datetime_utc_true_with_series_tzaware_string",
            "test_dtype_equal_strict",
            "get_dtype_kinds",
            "__dir__",
            "test_slice_locs_na_raises",
            "test_with_large_max_level",
            "test_arrmap",
            "freq",
            "deep_nested",
            "test_to_records_floats",
            "time_to_datetime_format_DD_MM_YYYY",
            "test_smallerEqual",
            "_get_info",
            "test_as_blocks",
            "test_read_chunks_117",
            "_assert_series_equal_both",
            "test_from_json_to_json_table_dtypes",
            "test_null_quote_char",
            "step",
            "_filter_special_cases",
            "test_factorized_sort_ordered",
            "_get_axis",
            "check_arbitrary",
            "test_constructor_ordered_dict_conflicting_orders",
            "_reconstruct_object",
            "test_sort_index_level_mixed",
            "test_offset_timedelta64_arg",
            "test_unequal_categorical_comparison_raises_type_error",
            "_construct_axes_from_arguments",
            "test_is_datetime64tz_dtype",
            "test_boxplot_legacy3",
            "test_merge_type",
            "_addsub_int_array",
            "test_constructor_incompat_freq",
            "test_timestamp_and_label",
            "test_out_of_bounds_string",
            "test_iterable_object_and_category",
            "test_argument_types",
            "_generate_4_axes_via_gridspec",
            "getSeriesData",
            "time_min_trivial",
            "_format_native_types",
            "test_resample_timedelta_values",
            "test_series_compression_defaults_to_infer",
            "test_get_chunk_passed_chunksize",
            "_add_datetime_arraylike",
            "get_commit_info",
            "test_empty_with_index_pass_dtype",
            "test_index_label_overlaps_location",
            "test_to_xarray_index_types",
            "time_from_codes_all_int8",
            "_multi_take",
            "test_parr_add_iadd_parr_raises",
            "test_regex_replace_dict_nested",
            "test_merge_right_vs_left",
            "test_dti_slicing",
            "test_misc",
            "test_readonly_axis_zlib",
            "time_dict_with_timestamp_offsets",
            "assert_sp_frame_equal",
            "_apply_to_column_groupbys",
            "legacy_packer",
            "maybe_convert_platform_interval",
            "constructor",
            "test_dti_drop_dont_lose_tz",
            "test_dt_accessor_invalid",
            "_postprocess_for_cut",
            "test_replace_convert",
            "test_drop_by_str_label",
            "_hashed_values",
            "time_pandas_dtype",
            "test_loc_general",
            "test_bins_from_interval_index_doc_example",
            "test_reindex_name_remains",
            "__contains__",
            "test_constructor_timestamp",
            "test_where_invalid_input_multiple",
            "test_getitem_slice",
            "test_group_var_generic_1d_flat_labels",
            "time_getitem_label_slice",
            "test_get_indexer_same_categories_same_order",
            "test_clipboard_copy_tabs_default",
            "_ftype",
            "test_describe_option",
            "formatting_values",
            "test_read_only_source",
            "_side_expander",
            "test_reindex_objects",
            "test_fillna_positive_limit",
            "test_dt64arr_add_timestamp_raises",
            "test_stack_names_and_numbers",
            "test_combine_first_timezone",
            "test_ragged_median",
            "test_mean_mixed_datetime_numeric",
            "test_to_coo_duplicate_index_entries",
            "test_getitem_slice_not_sorted",
            "test_usecols_index_col_conflict2",
            "test_agg_cython_table",
            "test_deferred_with_groupby",
            "test_nat",
            "hash_array",
            "test_time_change_xlim",
            "box_df_fail",
            "is_nested_list_like",
            "test_setitem_frame_invalid_length",
            "test_deprecated_values",
            "test_period_array_readonly_object",
            "test_to_html_multi_indexes_index_false",
            "test_x_string_values_ticks",
            "test_set_index_raise_on_type",
            "time_different_python_functions_multicol",
            "test_roll_convention",
            "test_deprecate_is_copy",
            "time_apply_ref_by_name",
            "test_infer_dtype_from_period",
            "one",
            "index_names",
            "test_holidays_within_dates",
            "test_unicode_column_name",
            "test_resample_rounding",
            "test_fillna_invalid_value",
            "test_contains_nat",
            "test_index_types",
            "dispatch_to_series",
            "time_read_store_mixed",
            "test_comparisons",
            "test_transform_fast",
            "orientation",
            "time_sortlevel_zero",
            "_factorize_array",
            "is_datelike",
            "set_name",
            "_flatten_visible",
            "test_iloc_getitem_bool_diff_len",
            "test_from_records_nones",
            "test_overlapping_columns_error_message",
            "test_dict_numpy_float",
            "__deepcopy__",
            "test_period_array_raises",
            "read_index_node",
            "test_boolean_compare_transpose_tzindex_with_dst",
            "test_tokenize_CR_with_quoting",
            "test_fontsize_set_correctly",
            "test_pivot_with_list_like_values_nans",
            "test_corr_int_and_boolean",
            "test_grouper_column_and_index",
            "test_css_none_absent",
            "test_td_sub_pytimedelta",
            "test_td_sub_td64_nat",
            "test_pickle_compat_0_14_1",
            "time_overflow",
            "as_series",
            "test_is_dict_like_duck_type",
            "time_translate",
            "add_special_arithmetic_methods",
            "test_ngroup_series_matches_frame",
            "test_variable_width_unicode",
            "test_cmov_window_corner",
            "rands_array",
            "test_tshift",
            "test_non_iso_strings_with_tz_offset",
            "test_resample_how",
            "test_boxplot_return_type_legacy",
            "test_secondary_logy",
            "is_number",
            "test_is_level_reference_series_simple_axis0",
            "test_open_args",
            "test_unicode_index",
            "set_uuid",
            "test_dti_with_offset_series",
            "test_unordered_different_categories_raises",
            "_constructor",
            "test_mixed_index_contains",
            "test_init_non_pandas",
            "test_level_preserve_order",
            "test_join_self_unique",
            "_take_with_fill",
            "_get_agg_axis",
            "_chk_truncate",
            "test_duplicated_large",
            "test_mul_int_series",
            "timezone_frame",
            "test_filter_out_all_groups",
            "to_series",
            "test_loc_and_at_with_categorical_index",
            "test_binary_ops_align",
            "test_skew",
            "mismatched_freq",
            "test_dataframe_dummies_prefix_list",
            "test_boundary_integer",
            "test_crosstab_non_aligned",
            "_parse_dtype_strict",
            "nancorr",
            "_check_data",
            "test_no_mode",
            "test_get_level_values_all_na",
            "validate_argsort_with_ascending",
            "_get_single_indexer",
            "test_setitem_loc_scalar_single",
            "time_itertuples_raw_start",
            "_find_valid_index",
            "test_setitem_sequence_broadcasts",
            "sanitize_index",
            "test_deprecated_from_api_types",
            "test_get_indexer_nearest",
            "test_dti_custom_business_repr",
            "test_deprecate_no_docstring",
            "test_assert_almost_equal_iterable_length_mismatch",
            "is_numeric_mixed_type",
            "float_frame_fill2_dense",
            "test_bar_bottom_left",
            "test_assert_extension_array_equal_dtype_mismatch",
            "test_index_false_from_json_to_json",
            "test_frame_double_encoded_labels",
            "test_pi_add_timedeltalike_mismatched_freq_hourly",
            "test_constructor_series_copy",
            "test_slice_integer",
            "test_reconstruct_sort",
            "test_reader_list_skiprows",
            "test_merge_take_missing_values_from_index_of_other_dtype",
            "test_getitem_multiple",
            "_is_builtin_func",
            "test_nested_period_index_subscript_expression",
            "time_to_pydatetime",
            "test_previous_friday",
            "test_rank_na_option",
            "test_to_csv_withcommas",
            "next_monday_or_tuesday",
            "test_comp_nat",
            "time_col_select_lambda_sum",
            "_make_stat_function",
            "test_basic_subset_columns",
            "test_range_slice_day",
            "test_str_cat_categorical",
            "test_boxplot_empty_column",
            "write_to_compressed",
            "time_strip",
            "test_query_by_text_obj",
            "test_fancy_getitem_int_labels",
            "test_operators_corner",
            "_make_wrapper",
            "test_astype_int",
            "read_gbq",
            "test_cache_keys_are_distinct_for_pytz_vs_dateutil",
            "test_caption",
            "test_dtype_with_converters",
            "private_classes",
            "test_all_apply",
            "_setitem_with_indexer",
            "allow_in_pandas",
            "test_describe_percentiles_integer_idx",
            "test_transform_method_name",
            "test_cut_return_intervals",
            "test_signed_downcast",
            "test_read_csv_local",
            "test_stack_mixed_level",
            "test_file_handle",
            "_replace_pandas_items",
            "test_detect_console_encoding_from_stdout_stdin",
            "test_string_io",
            "test_periods",
            "test_set_properties_subset",
            "df_mixed_floats",
            "test_loc_getitem_nested_indexer",
            "test_replace_datetime",
            "test_range_edges",
            "test_to_html_truncate_multi_index",
            "test_rename_errors",
            "test_repr_dtype",
            "_check_text_labels",
            "test_concat_categorical_multi_coercion",
            "test_slicing_datetimes",
            "test_timestamp_compare",
            "test_sort_index",
            "get_offset",
            "test_skipfooter",
            "get_dtypes",
            "get_new_values",
            "test_tz_dtype_matches",
            "test_join_level_corner_case",
            "file_path_to_url",
            "_extract_multi_indexer_columns",
            "test_raise_if_period_index",
            "_process_columnsize_subheader",
            "test_set_dtype_same",
            "test_no_copy_blocks",
            "test_two_backtick_variables_expr",
            "test_dti_business_getitem",
            "test_df_legend_labels",
            "test_to_string_unicode_three",
            "test_categorical_unexpected_categories",
            "test_offset_mul_ndarray",
            "time_division",
            "test_extract_index_one_two_groups",
            "s3_resource",
            "is_indexed",
            "test_index_convert_to_datetime_array_explicit_pytz",
            "parameter_capitalization",
            "test_reader_special_dtypes",
            "test_nansum",
            "test_calendar",
            "test_just_na",
            "test_period_cons_combined",
            "test_fillna_limit_and_value",
            "test_diff_float_n",
            "test_skipinitialspace",
            "test_margins_no_values_two_rows",
            "test_zfill",
            "_do_date_conversions",
            "test_categorical_delegations",
            "test_unsupported_dtype",
            "time_sparse_series_to_coo",
            "test_constructor_corner",
            "unique_nulls_fixture",
            "test_repeat_freqstr",
            "test_set_axis_inplace_axes",
            "test_datetime_with_timezone_roundtrip",
            "test_missing_minp_zero",
            "test_round_frac",
            "recode_for_groupby",
            "test_s3_fails",
            "_get_cacher",
            "_unconvert_string_array",
            "_add_numeric_operations",
            "_get_lbllist",
            "_replace_locals",
            "test__get_dtype_fails",
            "test_format_missing",
            "test_whitespace_regex_separator",
            "test_set_column_scalar_with_ix",
            "_alias_to_class",
            "test_empty_object",
            "_get_empty_meta",
            "_get_new_axes",
            "nkeys",
            "_is_py3_complex_incompat",
            "test_not_hashable",
            "test_astype_with_exclude_string",
            "test_constructor_from_frame_series_freq",
            "test_aggregate_with_nat",
            "test_constructor_dtypes_to_float64",
            "test_td_add_sub_one_day_ten_seconds",
            "test_query_python",
            "test_ufunc_args",
            "time_timedelta_days",
            "test_as_json_table_type_categorical_data",
            "test_axis_dates",
            "test_unordered_ts",
            "test_syntax_error_exprs",
            "test_plot_fails_when_ax_differs_from_figure",
            "test_invalid_kind",
            "test_rank2",
            "test_registered",
            "test_full_file_with_spaces",
            "fillna",
            "test_periods_number_check",
            "test_td_div_nan",
            "test_as_index",
            "test_period_dtype_mismatch",
            "_concat",
            "time_read_csv_cached",
            "test_first_nan_kept",
            "test_homogenize",
            "test_where_with_bool_data",
            "time_plot_andrews_curves",
            "_get_index_names",
            "test_same_ordering",
            "test_none_delimiter",
            "test_non_int_header",
            "test_numpy_ufuncs_other",
            "test_consistency_name",
            "test_transform_absent_categories",
            "test_numeric_conversions",
            "test_operators_combine",
            "nanskew",
            "test_unicode_problem_decoding_as_ascii",
            "test_expanding_consistency",
            "time_frame_nonunique_unequal",
            "test_align_float",
            "test_validate_indices_empty",
            "test_ismethods",
            "testRollback2",
            "test_frequency_is_original",
            "_reorder_for_extension_array_stack",
            "_skip_if_no_akima",
            "test_assert_almost_equal_null",
            "test_encode_time_conversion_dateutil",
            "test_constructor_from_dense_series",
            "test_logical_ops_int_frame",
            "test_intersection_equal_sort_true",
            "test_interp_nonmono_raise",
            "series_and_frame",
            "blank_lines",
            "test_concat_tuple_keys",
            "intersection",
            "test_to_block_index",
            "test_ignore_downcast_neg_to_unsigned",
            "test_pivot",
            "test_td64arr_rfloordiv_tdlike_scalar",
            "test_neg_freq",
            "test_categorical_equal_object_override",
            "test_filter_multi_column_df",
            "test_pivot_table_with_iterator_values",
            "test_drop_and_dropna_caching",
            "init_windows_clipboard",
            "test_where_timedelta_coerce",
            "test_invalid_date_conversion",
            "__rmatmul__",
            "test_dtype_per_column",
            "test_hist_by_no_extra_plots",
            "test_css_side_shorthands",
            "time_add",
            "test_register",
            "test_is_dict_like_passes",
            "mixed_float2",
            "test_nested_object_record_path",
            "test_metadata_immutable",
            "test_td64arr_sub_timestamp_raises",
            "time_full_product",
            "time_asof_single",
            "nanstd",
            "test_take_positive_no_warning",
            "test_attr_expression",
            "test_startswith",
            "test_closed",
            "test_invalid_url",
            "test_tz_convert_and_localize",
            "test_construction_with_mixed",
            "test_shift_gh8083",
            "test_validate_all_ignore_deprecated",
            "test_compat_replace",
            "test_basic_regular",
            "_items_overlap_with_suffix",
            "time_contains",
            "memory_usage",
            "test_map_compat",
            "is_monotonic_decreasing",
            "test_result_type_error",
            "test_ndim",
            "test_encode",
            "test_validate_sum_initial",
            "test_nanmean",
            "_add_comparison_methods",
            "test_corrwith_matches_corrcoef",
            "test_groupby_grouper_f_sanity_checked",
            "test_setitem_ndarray_3d",
            "__round__",
            "test_constructor_field_arrays",
            "time_tz",
            "test_loc_getitem_duplicates_multiindex_non_scalar_type_object",
            "test_nat_methods_nat",
            "test_versioning",
            "test_equals_block_order_different_dtypes",
            "_concat_rangeindex_same_dtype",
            "test_take_raises",
            "is_mixed",
            "test_agg_relabel_with_level",
            "test_get_values_deprecation",
            "test_dense_repr",
            "test_empty_tables",
            "_add_datetimelike_methods",
            "test_int_internal",
            "test_get_numeric_data_preserve_dtype",
            "test_na_values_dict_col_index",
            "test_basic_upsample",
            "fast_xs",
            "test_intersection_empty",
            "test_undefined_func",
            "write_cells",
            "_make_flex_doc",
            "visit_Name",
            "test_execute_fail",
            "test_constructor_dtypes_to_timedelta",
            "test_at_to_fail",
            "two_paragraph_multi_line",
            "zip_frames",
            "testRollforward1",
            "test_index_col_is_true",
            "test_non_ascii_key",
            "test_strange_column_corruption_issue",
            "test_reductions",
            "test_regex_replace_str_to_numeric",
            "test_parsing_different_timezone_offsets",
            "_tag",
            "test_dti_constructor_years_only",
            "test_cross_engine_pa_fp",
            "table",
            "test_unstack_swaplevel_sortlevel",
            "float_frame_dense",
            "test_dict_complex",
            "_convert_for_op",
            "test_from_product_iterator",
            "method_source",
            "test_join_str_datetime",
            "test_timezone_comparaison_bug",
            "test_separating_character",
            "test_set_name_attribute",
            "test_execute_sql",
            "test_partial_set_empty_frame_set_series",
            "get_value_maybe_box",
            "test_inplace_clip",
            "test_valid_tick_attributes",
            "test_from_records_set_index_name",
            "test_same_name_but_underscores",
            "test_get_pad_indexer",
            "test_set_change_dtype_slice",
            "test_tseries_select_index_column",
            "_check_for_invalid_keys",
            "test_replace_input_formats_listlike",
            "test_td_add_timedeltalike_object_dtype_array",
            "time_frame_drop_dups_int",
            "test_insert_column_bug_4032",
            "test_where_tz_values",
            "test_query_string_scalar_variable",
            "get_year_end",
            "test_df_flex_cmp_constant_return_types",
            "construct_1d_ndarray_preserving_na",
            "test_append_dtypes",
            "test_shift_duplicate_columns",
            "test_invalid_table_attrs",
            "test_max",
            "label_info",
            "test_no_dummy_key_names",
            "_preparse",
            "filter",
            "set_version",
            "test_pos_numeric",
            "test_comparison_operators_with_nas",
            "test_astype_nansafe",
            "test_to_records_with_unicode_index",
            "test_td_add_offset",
            "test_len_specialised",
            "test_getitem_with_listlike",
            "test_sparse_frame",
            "test_combine_from_sequence_raises",
            "test_pivot_multi_functions",
            "test_dont_convert_dateutil_utc_to_pytz_utc",
            "test_to_excel_timedelta",
            "test_pivot_index_none",
            "test_constructor_frame_copy",
            "rtruediv",
            "time_constructor",
            "test_constructor_categorical_with_coercion",
            "test_filter_mixed_df",
            "new_func_wrong_docstring",
            "test_timedelta_cut_roundtrip",
            "_get_index",
            "test_empty_prod",
            "get_new_columns",
            "test_astype_categoricaldtype",
            "_to_sql_fail",
            "test_to_csv_list_entries",
            "test_divmod_array",
            "test_max_min_non_numeric",
            "test_to_string_multindex_header",
            "time_nlargest_one_column",
            "test_from_records_columns_not_modified",
            "test_isin_with_i8",
            "test_backend_is_not_module",
            "validate_min_itemsize",
            "test_filter_has_access_to_grouped_cols",
            "assert_interval_array_equal",
            "test_top_level_method",
            "test_grouping_is_iterable",
            "remove_na",
            "test_assert_numpy_array_equal_shape_mismatch",
            "time_join_non_unique_equal",
            "test_divmod_invalid",
            "test_pi_add_timedeltalike_tick_gt1",
            "decode",
            "test_is_dtype_from_name",
            "test_append_to_another",
            "_check_ticks_props",
            "test_nuiscance_columns",
            "test_getitem_multilevel_index_tuple_not_sorted",
            "test_format",
            "test_series_indexing_multiple",
            "start_shift",
            "test_datetime",
            "test_map_dict_subclass_with_missing",
            "test_preserve_categorical_dtype",
            "test_cmp_series_period_series_mixed_freq",
            "test_repr_roundtrip",
            "time_merge_2intkey",
            "test_out_of_range_double",
            "lexsort_depth",
            "test_setitem_with_sparse_value",
            "test_data_after_quote",
            "test_ordered_none_default_deprecated",
            "test_stat_unexpected_keyword",
            "test_groupby_with_timegrouper",
            "test_pi_add_sub_timedeltalike_freq_mismatch_annual",
            "time_max",
            "teardown_class",
            "test_check_compatible_with",
            "test_ewm_consistency",
            "_convert_datetimelike_to_object",
            "test_numeric_arr_rdiv_tdscalar",
            "test_to_csv_bug",
            "test_dti_astype_asobject_tzinfos",
            "test_write_ignoring_index",
            "test_freq_group_match",
            "test_from_categorical_dtype_both",
            "time_shallow_copy",
            "test_to_excel_multiindex_cols",
            "desc_first_letter_lowercase",
            "test_eq_attribute",
            "test_hour",
            "test_select_dtypes_bad_datetime64",
            "test_fast_apply",
            "github_url",
            "test_difference_sort_special",
            "_get_quarterly_rule",
            "_try_convert_types",
            "set_pos",
            "test_stale_cached_series_bug_473",
            "test_empty_na_values_no_default_with_index",
            "time_thousands",
            "_is_mixed_type",
            "_ensure_has_len",
            "test_reindex",
            "test_construction_with_tz_and_tz_aware_dti",
            "test_bad_stream_exception",
            "test_tuple_index",
            "test_no_warning",
            "test_crosstab_unsorted_order",
            "_get_ordinal_range",
            "test_dti_iadd_tdi",
            "test_dti_intersection",
            "test_get_loc2",
            "test_duplicate_raises",
            "test_concat",
            "_get_unstack_items",
            "test_numpy_scalar_complex",
            "rstjinja",
            "test_asobject_deprecated",
            "test_groupby_args",
            "test_iteritems_names",
            "_recode_for_categories",
            "test_axis_classmethods",
            "test_disallow_set_ops",
            "time_concat_series",
            "from_intervals",
            "time_count_level_multi",
            "test_display_dict",
            "good_imports",
            "test_qcut_specify_quantiles",
            "test_na_value_dict",
            "time_expanding",
            "_get_private_key_path",
            "_evaluate_usecols",
            "_set_value",
            "test_fillna_limit_pad",
            "deregister",
            "test_real_imag_deprecated",
            "test_constructor_more",
            "_prepare_pandas",
            "test_intersect_nosort",
            "test_reversed_logical_ops_with_index",
            "makeCustomDataframe",
            "test_nat_methods_raise",
            "test_flex_method_equivalence",
            "test_exit_status_for_validate_all_json",
            "get_mgr_concatenation_plan",
            "test_empty_frame_roundtrip",
            "test_pi_cmp_period",
            "test_getitem_list_of_columns",
            "test_mpl_nopandas",
            "next_workday",
            "test_auto_conversion",
            "test_datetimetz_dtype_mismatch",
            "test_pos_raises",
            "test_errorbar_plot",
            "create_for_block",
            "radd",
            "description",
            "test_maybe_promote_any_with_string",
            "test_encode_hook",
            "test_append_with_timezones_pytz",
            "test_td_mul_nan",
            "_reset_cache",
            "test_td_sub_timedeltalike_object_dtype_array",
            "test_xs_level",
            "test_rjust",
            "get_authors",
            "test_fancy_setitem",
            "test_decode_invalid_array",
            "test_from_codes",
            "test_concat_categorical_tz",
            "_isnan",
            "test_date_parsing",
            "external_values",
            "_safe_dtype_assert",
            "_take_2d_multi_object",
            "test_iterator_with_string_io",
            "test_frame_set_name_single",
            "test_pad_width",
            "test_value_counts_datetime",
            "test_pickle_round_trip",
            "test_rename_axis_supported",
            "test_getitem_setitem_ix_duplicates",
            "test_get_period_range_edges",
            "test_td_rfloordiv_timedeltalike_scalar",
            "test_less_precise",
            "select_coords",
            "test_assert_numpy_array_equal_value_mismatch3",
            "test_dti_tz_conversion_freq",
            "time2num",
            "test_to_datetime_dt64s_out_of_bounds",
            "test_repr_html",
            "test_categorical_with_stata_missing_values",
            "test_dt64tz_series_sub_dtitz",
            "test_concat_axis1",
            "test_conv_read_write",
            "_get_interval_closed_bounds",
            "_axes",
            "test_period_constructor_offsets",
            "test_incorrect_type_array",
            "test_dt64_data_invalid",
            "time_apply_np_mean",
            "test_medium_complex_frame_alignment",
            "test_total_seconds_precision",
            "test_contiguous_boolean_preserve_freq",
            "month",
            "_process_page_metadata",
            "test_agg_cast_results_dtypes",
            "reorder_levels",
            "test_set_index_timezone",
            "test_min_max_series",
            "time_plot_regular_compat",
            "test_update_dtype_string",
            "test_nanosecond_field",
            "test_non_obj_dtype",
            "_obj_with_exclusions",
            "test_assign_bad",
            "test_setting_fill_value_fillna_still_works",
            "test_series_map_box_timedelta",
            "three_group",
            "time_min",
            "test_td64arr_add_str_invalid",
            "test_mask_edge_case_1xN_frame",
            "tz_to_dtype",
            "test_interp_timedelta64",
            "test_query_undefined_local",
            "__pos__",
            "test_series_tz_localize_empty",
            "time_read_sql_table_all",
            "_assert_frame_equal_both",
            "_inner_indexer",
            "data_for_twos",
            "maybe_droplevels",
            "stack_multiple",
            "test_series_getitem_returns_scalar",
            "test_sparse_with_compression",
            "compare_frame_cat_onecol",
            "test_rdiv_zero",
            "test_constructor_dict_order",
            "test_empty_str_methods",
            "test_parsers_quarterly_with_freq_error",
            "round_trip_localpath",
            "test_apply_without_copy",
            "test_downcast_booleans",
            "test_dti_business_getitem_matplotlib_hackaround",
            "test_series_frame_commutativity",
            "test_python_engine",
            "test_secondary_frame",
            "_compare_local_to_utc",
            "set_axis",
            "_rebuild_blknos_and_blklocs",
            "test_astimezone",
            "test_droplevel",
            "time_vector_slice",
            "_ensure_decoded",
            "test_union_sort_other_incomparable_true",
            "test_dti_with_timezone_repr",
            "is_platform_windows",
            "read_json",
            "test_groupby_series_indexed_differently",
            "test_dims",
            "test_infer_dtype_from_complex",
            "test_assign",
            "test_widths",
            "time_concat",
            "_f4",
            "test_header_multi_index_common_format2",
            "_load_iris_view",
            "time_isin_short_series_long_values",
            "_replace_coerce",
            "test_method_delegation",
            "test_fifth_week_of_month",
            "test_rename_multiindex",
            "_multiindex",
            "test_datetimeindex_highprecision",
            "test_greaterEqual_Raises_Value",
            "test_malformed_chunks",
            "test_mode_datetime",
            "test_text_color_threshold",
            "test_comparison_object_array",
            "deprecate_option",
            "bdate_range",
            "test_repr_name_iterable_indexable",
            "test_format_timedelta_ticks_wide",
            "test_converters_corner_with_nans",
            "sum",
            "_is_datelike_mixed_type",
            "testArray",
            "_adorn_subplots",
            "test_invalid_origins_tzinfo",
            "maybe_infer_tz",
            "_make_legend",
            "test_intersect_empty",
            "test_dti_tz_localize_nonexistent_shift_invalid",
            "random_letters",
            "test_dates_invalid_column",
            "test_scalar_integer",
            "test_dt64arr_isub_timedeltalike_scalar",
            "test_encode_recursion_max",
            "test_cython_api2",
            "test_ix_general",
            "test_with_s3_url",
            "test_nonunique_contains",
            "test_get_indexer_methods",
            "test_logical_with_nas",
            "test_from_codes_with_categorical_categories",
            "test_get_year_end",
            "test_concat_single_with_key",
            "time_frame_getitem_single_column_label",
            "test_getitems_slice_multi",
            "test_infer_datetimelike_array_mixed",
            "test_resolves_class_name",
            "test_take_invalid_kwargs",
            "test_rollback",
            "test_assert_numpy_array_equal_value_mismatch1",
            "test_backend_is_correct",
            "test_cached_data",
            "test_no_mlk_before_1986",
            "time_nsmallest",
            "test_to_datetime_out_of_bounds_with_format_arg",
            "test_append_concat_tz",
            "_reindex_indexer",
            "test_fillna_limit_backfill",
            "test_is_datetime64_dtype",
            "test_block_internal",
            "test_background_gradient",
            "test_ragged_sum",
            "test_freq_str",
            "test_join_on_pass_vector",
            "test_line_colors",
            "test_label",
            "str_wrap",
            "any_int_dtype",
            "test_iloc_getitem_labelled_frame",
            "test_indexing_sliced",
            "test_cut_not_1d_arg"
          ],
          "functions_name_co_evolved_modified_file": [
            "asarray_tuplesafe",
            "get_callable_name",
            "is_full_slice",
            "is_bool_indexer",
            "standardize_mapping",
            "is_null_slice",
            "_pipe",
            "random_state",
            "_get_rename_function"
          ],
          "functions_name_co_evolved_all_files": [
            "check_funs",
            "check_for_ordered",
            "test_to_records_dict_like",
            "test_truncate_ndots",
            "test_apply_iteration",
            "test_join_on_series_buglet",
            "time_merge_ordered",
            "test_spam_url",
            "test_equality",
            "test_wide_repr_multiindex_cols",
            "test_to_latex_format",
            "test_td64arr_mod_int",
            "test_rank_empty_group",
            "test_set_index_pass_arrays",
            "test_inf_na_values_with_int_index",
            "test_pivot_no_values",
            "test_datetime64tz_aware",
            "select",
            "ordered",
            "test_groupby_bool_aggs",
            "test_long_strings",
            "_handle_lowerdim_multi_index_axis0",
            "_box_func",
            "test_loc_multiindex_missing_label_raises",
            "test_nbytes_integer",
            "test_merge_on_extension_array",
            "test_upsampling_ohlc",
            "_sqlalchemy_type",
            "test_dt64arr_add_sub_DateOffsets",
            "period_index",
            "test_datetime64formatter_yearmonth",
            "test_groupby_with_hier_columns",
            "test_same_len_hash_collisions",
            "test_from_coo",
            "in_interactive_session",
            "test_to_json_compression",
            "test_omit_nuisance_python_multiple",
            "test_format_timedelta_ticks_narrow",
            "_transform_should_cast",
            "_build_xpath_expr",
            "test_interp_unlimited",
            "test_usecols_with_parse_dates2",
            "from_range",
            "test_loc_getitem_label_list",
            "drop_duplicates",
            "test_dti_equals_with_tz",
            "test_numpy_type_funcs",
            "test_match",
            "test_set_index_pass_arrays_duplicate",
            "test_split_blank_string",
            "test_multilevel_name_print",
            "_format_datetime64",
            "test_first_last_tz_multi_column",
            "test_to_csv_from_csv2",
            "test_columns_dtypes",
            "test_set_index_cast",
            "test_comparison_flex_alignment",
            "test_dataframe_constructor_with_dtype",
            "assert_class_equal",
            "_convert_axes",
            "test_name_printing",
            "test_dataframe_dummies_subset",
            "__next__",
            "is_datetime_or_timedelta_dtype",
            "test_setitem_single_column_mixed_datetime",
            "get_sheet_by_index",
            "test_frame_equal_index_mismatch",
            "test_empty_constructor",
            "test_frame_non_unique_index",
            "_infer_types",
            "test_query_with_partially_named_multiindex",
            "test_replace",
            "test_drop_preserve_names",
            "test_rolling_sum",
            "_get_axis_resolvers",
            "test_categorical_conversion",
            "test_numpy_take",
            "test_date_export_formats",
            "test_ragged_max",
            "test_asarray_datetime64",
            "test_iterator2",
            "test_query_with_named_multiindex",
            "test_3",
            "test_failing_subscript_with_name_error",
            "test_union_misc",
            "test_read_with_parse_dates_scalar_non_bool",
            "test_regex_replace_list_to_scalar",
            "test_td64arr_add_sub_float",
            "test_convert_nested",
            "_get_errorbars",
            "_add_series_only_operations",
            "_check_for_default_values",
            "validate_ordered",
            "test_take_allow_fill",
            "test_frame_equal_block_mismatch",
            "test_cmov_window_na_min_periods",
            "test_conversions",
            "test_column_select_via_attr",
            "test_partially_invalid_plot_data",
            "test_str_accessor_no_new_attributes",
            "test_merge_index_singlekey_inner",
            "test_right_outer_join",
            "test_left_outer_join",
            "test_ensure_platform_int",
            "get_series_na",
            "test_parse_dates_implicit_first_col",
            "test_grouper_iter",
            "test_partial_setting_mixed_dtype",
            "sequence_to_dt64ns",
            "test_intersection_non_monotonic_non_unique",
            "mixed_int_frame",
            "test_lookup_nan",
            "test_nan_irregular_index",
            "test_multi_function_flexible_mix",
            "test_frame_to_time_stamp",
            "get_locator",
            "_time_shift",
            "_generate_marginal_results_without_values",
            "header_style",
            "test_encoding_latin1_118",
            "test_constructor_freq_mult",
            "test_tdi_total_seconds",
            "test_set_index_append_to_multiindex",
            "test_copy_name",
            "test_grouper_getting_correct_binner",
            "_read",
            "test_reindex_level",
            "storable",
            "test_reader_dtype",
            "test_read_map_header",
            "test_series_map_box_timestamps",
            "test_at_time_raises",
            "is_dtype",
            "test_boolean_indexing_mixed",
            "_get_object_parser",
            "test_difference_incomparable_true",
            "test_reindex_dtype",
            "test_missing_right_by",
            "_skew_kurt_wrap",
            "argmin",
            "test_interp_limit_bad_direction",
            "test_date_range_int64_overflow_non_recoverable",
            "test_date_range_timestamp_equiv_from_datetime_instance",
            "test_group_selection_cache",
            "ensure_categorical",
            "_get_nearest_indexer",
            "_set_categories",
            "test_complex",
            "test_to_records_with_Mapping_type",
            "test_to_string_without_index",
            "test_complex_series_frame_alignment",
            "get_random_path",
            "tsplot",
            "_typ",
            "test_pi_sub_isub_pi",
            "test_get_loc_closed",
            "time_parse_iso8601_no_tz",
            "test_dataframe_dummies_drop_first_with_na",
            "_replace_nans",
            "clip_lower",
            "time_series_timedeltas",
            "test_set_option_multiple",
            "compat_props",
            "test_nearest",
            "test_resample_with_nat",
            "test_value_counts_normalized",
            "test_extractall_no_matches",
            "test_to_string_line_width",
            "test_get_attr",
            "_load_test1_data",
            "test_constructor_bad_file",
            "test_arith_ops_df_compat",
            "to_feather",
            "test_xs_loc_equality",
            "test_set_value_resize",
            "test_update_from_non_df",
            "pytest_addoption",
            "test_replace_multiple",
            "test_binop_typecasting",
            "str_slice_replace",
            "test_getitem_simple",
            "_parse_errorbars",
            "test_apply_multi_index",
            "test_closed_median_quantile",
            "test_to_string_left_justify_cols",
            "test_astype_str_compat",
            "test_cmov_window_frame",
            "test_take_bounds",
            "_format_datetime64_dateonly",
            "test_filter_single_column_df",
            "_verify_integrity",
            "write_index",
            "test_maybe_promote_datetimetz_with_any_numpy_dtype",
            "_assert_insert_conversion",
            "test_concat_bug_3602",
            "test_nat_ops",
            "test_array_equivalent_compat",
            "test_pct_max_many_rows",
            "test_mixed_index_at_iat_loc_iloc_dataframe",
            "test_invalid_xy_args_dup_cols",
            "test_construction_not_supported",
            "test_add_string",
            "test_sort_nat",
            "test_iloc_getitem_array",
            "_get_opstr",
            "test_td64arr_add_td64_array",
            "test_iso_conversion",
            "test_reset_index_name",
            "test_query_scope",
            "test_apply_out_of_range",
            "test_euro_decimal_format",
            "_write_map",
            "test_fancy_slice_partial",
            "test_getitem_boolean_empty",
            "test_pindex_fieldaccessor_nat",
            "test_dti_date",
            "_get_op_name",
            "test_merge_incompat_infer_boolean_object",
            "time_series_datetimeindex_repr",
            "test_agg_period_index",
            "test_frame_mixedtype_orient",
            "test_cython_with_timestamp_and_nat",
            "test_as_index_series_return_frame",
            "test_join_multi",
            "test_set_levels_categorical",
            "_is_multi_agg_with_relabel",
            "test_mean",
            "test_closed_one_entry_groupby",
            "test_dti_tz_localize_nonexistent_raise_coerce",
            "test_build_table_schema",
            "read_index",
            "test_set_categories_inplace",
            "zip_html",
            "test_where_other",
            "_partial_tup_index",
            "_check_bar_alignment",
            "tz_localize",
            "test_groupby_dtype_inference_empty",
            "from_codes",
            "construct_from_string",
            "test_round_nonunique_categorical",
            "test_warns_non_roundtrippable_names",
            "test_join_append_timedeltas",
            "test_split",
            "test_to_hdf_with_object_column_names",
            "test_get_loc_bad_tolerance_raises",
            "test_identical",
            "nankurt",
            "_make_selectors",
            "test_get_filepath_or_buffer_with_buffer",
            "test_repeat",
            "test_fake_qtconsole_repr_html",
            "time_float_int_lines",
            "is_categorical",
            "test_agg_reduce",
            "_apply_loffset",
            "test_df_arith_2d_array_rowlike_broadcasts",
            "test_sub_delta",
            "test_date_range_out_of_bounds",
            "test_value_counts_bins",
            "_from_selection",
            "test_reindex_positional_warns",
            "test_lines_with_compression",
            "dataframe_with_duplicate_index",
            "is_interval",
            "test_unit_ignore_keeps_name",
            "_get_group_keys",
            "test_hash",
            "test_cython_agg_boolean",
            "test_loc_axis_arguments",
            "sortlevel",
            "test_dti_custom_getitem_matplotlib_hackaround",
            "test_join_index_mixed",
            "dot",
            "_check_parser",
            "test_value_counts_int",
            "test_maybe_indices_to_slice_middle",
            "build_fill",
            "test_str_uses_object",
            "test_rmod_invalid",
            "test_series_tz_convert",
            "test_tdi_sub_dt64_array",
            "_convert_to_indexer",
            "_from_sequence",
            "test_seriesgroupby_name_attr",
            "test_str_bool_series_indexing",
            "_addsub_offset_array",
            "test_at_time_errors",
            "test_read_csv_buglet_4x_multi_index2",
            "test_two_backtick_variables_query",
            "time_on_int",
            "test_contains_dunder",
            "test_pi_comp_period_nat",
            "test_unsorted_index",
            "test_css_to_excel_good_colors",
            "test_multiindex_period_datetime",
            "test_keys",
            "test_default_handler_numpy_unsupported_dtype",
            "_check_promote",
            "test_parse_public_s3_bucket_chunked_python",
            "_evaluate_with_timedelta_like",
            "_read_old_header",
            "test_calendar_roundtrip_issue",
            "test_localized_at_time_between_time",
            "test_matmul",
            "test_is_all_dates",
            "test_timedelta_mode",
            "test_label_overflow",
            "test_hash_collisions",
            "test_basic_downsample",
            "test_append_series_dict",
            "end_time",
            "read_coordinates",
            "test_combine_add",
            "test_to_records_with_multindex",
            "test_groupby_multiindex_missing_pair",
            "test_format_with_name_time_info",
            "test_secondary_bar_frame",
            "test_setitem_invalidates_datetime_index_freq",
            "test_bar_barwidth_position",
            "generate_filter_op",
            "_check_op_integer",
            "test_at",
            "test_resample_to_quarterly",
            "test_store_timezone",
            "test_range_misspecified",
            "test_expanding_func",
            "time_series_categorical",
            "_bool_method_SERIES",
            "test_register_writer",
            "swaplevel",
            "ex",
            "test_info_wide",
            "_format_value",
            "test_add_iadd_timedeltalike_annual",
            "test_bar_align_left_0points",
            "_check_thousands",
            "test_reset_index_range",
            "test_dt64arr_sub_datetime64_not_ns",
            "test_take_na_value_other_decimal",
            "test_to_csv_write_to_open_file",
            "test_is_float_dtype",
            "test_getitem_scalar",
            "_flex_method_SERIES",
            "test_to_string_with_formatters",
            "test_sub_single_tz",
            "time_chained_indexing",
            "test_sort_index_level_and_column_label",
            "test_agg_ser_multi_key",
            "_rows_to_cols",
            "cummin",
            "test_sub_n_gt_1_offsets",
            "test_categorical_concat_append",
            "test_replace_str_to_str_chain",
            "test_frame_setitem",
            "time_reindex_missing",
            "codes",
            "test_constructor_ragged",
            "test_cumcount_mi",
            "test_rw_nthreads",
            "test_if_scatterplot_colorbar_affects_xaxis_visibility",
            "test_concat_sorts_index",
            "test_concat_ignore_index",
            "test_constructor_keyword",
            "test_split_no_pat_with_nonzero_n",
            "test_isna_isnull",
            "df_duplabels",
            "df",
            "test_buffer_rd_bytes",
            "test_dropna_no_nan",
            "test_tz_convert_nat",
            "test_groupby_dict_mapping",
            "_validate_td64_dtype",
            "test_reindex_preserves_name_if_target_is_list_or_ndarray",
            "test_read_hdf_iterator",
            "test_allow_exact_matches_forward",
            "test1_index",
            "test_duplicate_argument",
            "test_replace_mixed_types",
            "_cast_values_for_fillna",
            "test_union_bug_1745",
            "test_subclassed_melt",
            "unconvert",
            "_validate_index_level",
            "test_concat_datetime_timezone",
            "test_extractall_single_group_with_quantifier",
            "test_generic",
            "test_astype_idempotent",
            "test_add_datetimelike_and_dti",
            "on_right",
            "test_getitem_unordered_dup",
            "test_bar_align_mid_axis_none",
            "_align_core",
            "test_str_for_named_is_name",
            "format_date_labels",
            "test_nth_column_order",
            "from_spmatrix",
            "test_corr_callable_method",
            "test_iloc_getitem_neg_int",
            "test_iso_8601_strings_with_different_offsets",
            "test_loc_getitem_dups2",
            "test_date_index_query_with_NaT",
            "test_multiple_header_rows",
            "test_frame_getitem_not_sorted",
            "test_roundtrip_pickle_with_tz",
            "test_na_actions_categorical",
            "test_maybe_promote_float_with_int",
            "test_astype_to_incorrect_datetimelike",
            "check_setitem_lengths",
            "test_categorical_dtype_latin1",
            "test_nanall",
            "test_apply_categorical_with_nan_values",
            "_convert_to_font",
            "test_groupby_level",
            "testStrictUnicodePack",
            "testRollforward2",
            "justify",
            "test_constructor_single_value",
            "_background_gradient",
            "test_eval_resolvers_as_list",
            "test_setslice",
            "test_describe_empty_object",
            "coerce_to_target_dtype",
            "test_css_to_excel_multiple",
            "test_indexing",
            "test_resample_empty_series",
            "test_merge_on_multikey",
            "load_iris_data",
            "var",
            "to_ea_dtypes",
            "test_pivot_with_interval_index",
            "run_binary",
            "_summary",
            "test_index_ctor_infer_periodindex",
            "test_categorical_comparisons",
            "test_index_subclass_constructor_wrong_kwargs",
            "test_join_multi_to_multi",
            "test_partition_to_dataframe",
            "test_to_csv_from_csv_w_all_infs",
            "_process_date_conversion",
            "test_fillna_raise",
            "test_datetime_nan_mask",
            "test_drop_column",
            "_selection_list",
            "_read_value_labels",
            "test_tdarr_div_length_mismatch",
            "build_kwargs",
            "test_nested_dict_construction",
            "test_rank_avg_even_vals",
            "to_period",
            "_process_columntext_subheader",
            "test_whitespace_preservation",
            "_handle_date_column",
            "test_ix_deprecation",
            "test__bn_ok_dtype",
            "test_concat_empty_series_dtypes_roundtrips",
            "test_getslice_tuple",
            "test_put_string_index",
            "test_join_many_non_unique_index",
            "_argminmax_wrap",
            "test_to_string_with_datetime64_monthformatter",
            "test_where_setitem_invalid",
            "_maybe_convert_index",
            "_stop",
            "test_constructor_from_index_series_period",
            "test_consistent_names",
            "test_info_categorical",
            "test_downsample_non_unique",
            "register",
            "test_td64arr_with_offset_series",
            "test_map_with_categorical_series",
            "_check_grid_settings",
            "from_records",
            "test_to_timestamp",
            "test_is_empty",
            "test_quantile_interpolation_dtype",
            "test_interpolate_invalid_nonpositive_limit",
            "_setup_subplots",
            "test_datetime_fractional_seconds",
            "test_td_add_sub_numeric_raises",
            "test_extension_array",
            "test_from_freq_recreate_from_data",
            "double_blank_lines",
            "test_is_numeric_v_string_like",
            "_finalize",
            "test_series_ix_getitem_fancy",
            "decons_group_index",
            "test_read_excel_chunksize",
            "test_setitem_iloc_scalar_multiple_homogoneous",
            "test_compression_blosc",
            "test_replace_aware",
            "test_rank_average_pct",
            "test_ops_properties_basic",
            "test_isAnchored",
            "test_write_bytes",
            "_compute_grand_margin",
            "test_axis_share_x",
            "test_frame_from_records_utc",
            "_from_factorized",
            "test_repr_set",
            "test_resample_base_with_timedeltaindex",
            "test_iterator",
            "test_cython_agg_empty_buckets_nanops",
            "test_empty_field_eof",
            "_args_adjust",
            "_check_comparison_ops",
            "_importers",
            "_get_call_args",
            "test_groupby_as_index_cython",
            "test_usecols_index_col_conflict",
            "test_returned_dtype",
            "test_join_on",
            "test_dt_accessor_api",
            "test_dti_tz_localize_nonexistent_shift",
            "test_select_with_dups",
            "test_tdi_add_timestamp_nat_masking",
            "test_handle_empty_objects",
            "test_new_empty_index",
            "create_index",
            "test_add_offset",
            "count_empty_vals",
            "test_aggfuncs",
            "test_replace_method",
            "test_left_outer_join_bug",
            "test_resample_apply_with_additional_args",
            "test_equals",
            "_reindex_with_indexers",
            "_sanitize_column",
            "wrap_results_for_axis",
            "test_fillna_float64",
            "test_ignore_display_max_colwidth",
            "test_from_arrays_index_series_categorical",
            "interpolate_1d",
            "test_deepcopy_empty",
            "test_astype",
            "test_get",
            "test_multiindex_slicers_edges",
            "test_interpolate_non_ts",
            "test_where_none",
            "_format_header",
            "_make_skipna_wrapper",
            "test_multi_index_naming_not_all_at_beginning",
            "_check_box_return_type",
            "_interpolate_with_fill",
            "test_setitem_na",
            "_is_memory_usage_qualified",
            "test_range_with_millisecond_resolution",
            "test_reader_converters",
            "test_dt_round_tz",
            "test_td64arr_mul_int_series",
            "test_constructor_dict_input",
            "test_dataframe_dummies_prefix_sep_bad_length",
            "test_conv_weekly_legacy",
            "test_subclass_unstack_multi",
            "test_add_series_with_period_index",
            "test_css_absolute_font_size",
            "test_astype_cannot_cast",
            "_reindex_multi",
            "test_reset_index_multiindex_columns",
            "test_float_subtype",
            "offset",
            "_get_binner_for_time",
            "_apply",
            "test_binary_ufunc_with_array",
            "test_loc_name",
            "test_dti_reset_index_round_trip",
            "_formatter_func",
            "_convert_1d",
            "test_parallel_coordinates",
            "test_naive_aware_conflicts",
            "_make_plot_keywords",
            "test_identity",
            "_get_valid_sqlite_name",
            "test_max_bin_len",
            "parametrize_fixture_doc",
            "test_reindex_with_nans",
            "test_constructor_list_of_series_aligned_index",
            "test_decode_pairs_hook",
            "test_to_excel_periodindex",
            "time_write_store_table_wide",
            "_write_table",
            "test_drop_by_str_label_errors_ignore",
            "test_select_dtypes_include_using_scalars",
            "_set_codes",
            "test_intervals",
            "test_to_coo_text_names_integer_row_levels_nosort",
            "test_update_raise_bad_parameter",
            "_write_strls",
            "test_drop_multiindex_not_lexsorted",
            "test_validate_n_error",
            "_ixs",
            "test_table_mixed_dtypes",
            "groupby",
            "test_astype_cast_nan_inf_int",
            "test_from_sequence_dtype",
            "test_parr_cmp_period_scalar",
            "test_replace_list",
            "test_raises_on_usecols_names_mismatch",
            "test_roundtrip_tz_aware_index",
            "test_constructor_ordered_dict_preserve_order",
            "test_td_sub_timedelta64",
            "test_comparison_object_numeric_nas",
            "test_agg_consistency",
            "test_coordinates",
            "test_basic_frame_series_alignment",
            "test_in_numeric_groupby",
            "test_pivot_table",
            "test_offset_freqstr",
            "_create_sql_schema",
            "test_NaT_scalar",
            "_raise_on_incompatible",
            "test_empty_with_multi_index",
            "test_multi",
            "test_dti_tz_localize_roundtrip",
            "remove_categories",
            "maybe_downcast_to_dtype",
            "test_overwrite_warns",
            "test_frame_no_datetime64_dtype",
            "check_cython_extensions",
            "is_integer",
            "_apply_filter",
            "test_allow_exact_matches_and_tolerance2",
            "time_sum",
            "write_result",
            "_list_of_series_to_arrays",
            "test_period_immutable",
            "test_query_builtin",
            "test_bad_url_protocol",
            "test_excel_sep_warning",
            "test_apply_categorical",
            "test_xs_level_series",
            "test_rowspan_at_end_of_row",
            "test_copy_delim_warning",
            "test_dti_shift_localized",
            "test_nonfile_writing",
            "test_corrwith_with_objects",
            "test_numpy_minmax_timedelta64",
            "reindex",
            "test_to_latex_no_header",
            "test_timedelta64_analytics",
            "test_agg_multiple_functions_maintain_order",
            "nanargmin",
            "_write_data",
            "_join_compat",
            "test_items",
            "test_constructor_ordereddict",
            "test_wide_repr_wide_columns",
            "test_join_on_singlekey_list",
            "test_intersection_difference",
            "test_readbytes",
            "_get_dummies_1d",
            "test_merge_all_na_column",
            "test_kind_both_ways",
            "test_allow_exact_matches_and_tolerance3",
            "test_iteration",
            "test_nanosecond_index_access",
            "test_dates_display",
            "test_bar_categorical",
            "test_pickle",
            "test_construct_DataFrame_with_sp_series",
            "test_constructor_simple_new_empty",
            "test_broadcast",
            "test_column_dups_indexing2",
            "test_categorical_concat_preserve",
            "test_concat_same_type_different_freq",
            "test_ceil",
            "test_date_query_with_non_date",
            "test_setitem_datetimelike_with_inference",
            "test_to_csv_with_mix_columns",
            "test_ensure_categorical",
            "assert_frame_equal",
            "test_dups_index",
            "_convert_to_number_format",
            "test_add_prefix_suffix",
            "test_statsmodels",
            "setup_ops",
            "test_area_lim",
            "test_frame_inferred",
            "test_constructor_categorical_dtype",
            "test_timestamp_to_datetime_tzoffset",
            "test_datetime_assignment_with_NaT_and_diff_time_units",
            "_expand_colspan_rowspan",
            "test_copy_names",
            "test_datetime_NaT",
            "test_getitem",
            "test_pivot_table_categorical",
            "test_dtype_and_names_error",
            "test_ufunc",
            "test_constructor_cast_object",
            "test_select_dtypes_include_exclude_using_scalars",
            "_fill_mi_header",
            "is_dict_like",
            "eval",
            "test_factorize_repeated",
            "test_sort_index_and_reconstruction",
            "test_multiple_functions_tuples_and_non_tuples",
            "test_parse_dates_list",
            "test_datetime64tz_fillna_round_issue",
            "test_keyword_as_column_names",
            "check_modulus",
            "test_slice_specialised",
            "test_iloc_getitem_invalid_scalar",
            "test_concat_empty_series",
            "test_applymap_subset",
            "test_apply_bug",
            "test_query",
            "test_to_datetime_errors_ignore_utc_true",
            "test_update_nan",
            "_format_header_mi",
            "test_tz_convert_unsorted",
            "test_rename_set_name",
            "test_transform_with_non_scalar_group",
            "test_resample_as_freq_with_subperiod",
            "test_crosstab_errors",
            "test_where_ordered_differs_rasies",
            "hash_tuple",
            "test_to_numpy_alias",
            "_convert",
            "raw",
            "background_gradient",
            "test_pie_series",
            "test_filter_series",
            "test_dt_namespace_accessor",
            "test_interp_leading_nans",
            "maybe_infer_freq",
            "test_maybe_mangle_lambdas_named",
            "_prep_values",
            "test_rolling_cov_pairwise",
            "test_constructor_Series_copy_bug",
            "test_div_td64arr",
            "test_east_asian_unicode_series",
            "test_read_nokey_table",
            "_trim_excel_header",
            "test_path_pathlib",
            "to_html",
            "_convert_bin_to_datelike_type",
            "test_to_csv_float32_nanrep",
            "test_at_and_iat_get",
            "test_asfreq_near_zero",
            "test_secondary_kde",
            "time_asfreq",
            "test_align_int_fill_bug",
            "test_more_na_comparisons",
            "test_unstack_fill_frame_object",
            "test_rename_inplace",
            "test_frame_iloc_callable_setitem",
            "nanpercentile",
            "test_to_frame_expanddim",
            "test_from_frame_valid_names",
            "time_transform_multi_key4",
            "dates",
            "test_get_complex",
            "_get_level_number",
            "test_to_timestamp_out_of_bounds",
            "test_append_numpy_bug_1681",
            "test_concat_multiindex_dfs_with_deepcopy",
            "test_read_array_header",
            "test_scalar_error",
            "makeTimedeltaIndex",
            "test_round_invalid_arg",
            "start_blank_lines",
            "time_read_csv_dayfirst",
            "test_getitem_int_dtype",
            "test_kde_df",
            "test_options_auto",
            "test_1000_sep",
            "test_to_string_truncate_indices",
            "combine_concat_plans",
            "test_binops_level",
            "test_unsupported",
            "test_loc_setitem_slice",
            "test_parsers_time",
            "test_from_tdi",
            "test_to_string_no_header",
            "_parse_float_vec",
            "test_api_per_dtype",
            "test_merge_left_empty_right_notempty",
            "time_query_store_table",
            "test_default_handler",
            "test_combine_first_align_nan",
            "test_math_floordiv",
            "test_encode_array_of_doubles",
            "test_preserve_metadata",
            "test_rolling_axis_sum",
            "is_datetimelike",
            "time_frame_assign_timeseries_index",
            "test_to_sql_fail",
            "test_from_arrays_index_series_datetimetz",
            "pad",
            "right",
            "to_timedelta",
            "test_construct_timestamp_near_dst",
            "test_asfreq_keep_index_name",
            "peakmem_float",
            "test_to_records_with_unicode_column_names",
            "test_wide_repr_unicode",
            "test_file_url",
            "test_fillna_series",
            "test_concat_categoricalindex",
            "read_msgpack",
            "test_notna_dtype",
            "test_categorical_concat",
            "test_bigint",
            "__neg__",
            "test_set_codes",
            "test_intersection_base",
            "test_multi_thread_path_multipart_read_csv",
            "test_loc_uint64",
            "test_is_dtype",
            "test_arith_mixed",
            "test_corr",
            "test_subplots_timeseries",
            "test_is_scipy_sparse",
            "_aggregate_series_pure_python",
            "test_query_index_with_name",
            "test_to_hdf_errors",
            "test_if_exists",
            "test_rank_apply",
            "_check_mixed_int",
            "get_result",
            "test_tdi_isub_int",
            "_find_non_overlapping_monotonic_bounds",
            "test_align_fill_method",
            "test_already_underscore_variable",
            "test_union_dt_as_obj",
            "test_skiprows_int",
            "test_large_dataframe_indexing",
            "randu",
            "test_resampler_is_iterable",
            "_check_ew",
            "test_unsortable",
            "test_categorical_from_codes",
            "test_read_non_existant",
            "test_freq_name_separation",
            "test_fillna_method_doesnt_change_orig",
            "test_end_time",
            "test_header_multi_index_common_format_malformed2",
            "test_construction_errors",
            "test_columns_multiindex_modified",
            "test_to_period_tz_utc_offset_consistency",
            "test_apply_series_to_frame",
            "test_categorical_equality",
            "_validate_sort_keyword",
            "test_agg_relabel_other_raises",
            "_data_to_frame",
            "test_generic_errors",
            "test_non_monotonic",
            "_get_names",
            "test_diff_timedelta",
            "test_usecols_with_parse_dates4",
            "read_metadata",
            "_validate_key",
            "test_round_trip_exception_",
            "test_value_counts_dup",
            "test_only_one_obj_hook",
            "test_is_unique",
            "test_is_level_or_label_reference_df_simple",
            "test_constructor_categorical_valid",
            "infer_dtype_from_array",
            "test_inplace_ops_alignment",
            "test_pi_sub_pdnat",
            "testPackBytes",
            "test_to_csv_dtnat",
            "test_constructor_mixed_dict_and_Series",
            "test_bool_same_index",
            "test_pindex_multiples",
            "_intersection_unique",
            "test_empty_with_reversed_multi_index",
            "test_hist_legacy",
            "test_time",
            "apply_empty_result",
            "read_multi_index",
            "test_compact_numerical_values",
            "test_contains_nan",
            "_where_numexpr",
            "test_setitem_index_object",
            "test_concat_axis1_different_fill",
            "testPack",
            "test_pprint",
            "_evaluate_standard",
            "test_Second",
            "read_csv",
            "_get_codes_for_sorting",
            "test_perf_min",
            "nonzero",
            "test_constructor_dtypes_timedelta",
            "test_constructor_dict_multiindex",
            "_tick_comp",
            "test_boolean_cmp",
            "test_periodindex",
            "test_cython_right_outer_join",
            "test_from_tuples_with_tuple_label",
            "_trim_zeros_float",
            "add_flex_arithmetic_methods",
            "test_quote_char_various",
            "test_concat_named_keys",
            "test_reindex_frame_add_nat",
            "test_set_axis_inplace",
            "test_xs_corner",
            "test_infs_n_nans",
            "_list_of_dict_to_arrays",
            "test_loc_getitem_bool",
            "onOffset",
            "init_dict",
            "test_numpy_array_complex",
            "test_pivot_periods",
            "test_sum_prod_nanops",
            "test_pi_sub_period_nat",
            "test_replace_mixed_types_with_string",
            "test_copy_blocks",
            "test_axis_aliases",
            "test_groupby_with_timegrouper_methods",
            "test_to_string_format_inf",
            "_check_decimal",
            "str_find",
            "test_groupby_groups_periods",
            "test_excel_table_sheet_by_index",
            "test_astype_datetime64",
            "test_categorical_sorting",
            "test_series_pos",
            "test_asfreq_ts",
            "test_left_join_index_preserve_order",
            "test_get_backfill_indexer",
            "test_int32_overflow",
            "update_kwargs",
            "test_nonzero_base",
            "test_concat_NaT_series",
            "test_describe_categorical",
            "test_decode_big_escape",
            "test_negative_log",
            "test_tdi_cmp_str_invalid",
            "visit_Div",
            "test_join_inner_multiindex",
            "test_assignment_in_query",
            "_close_conn",
            "merge_ordered",
            "test_categorical_repr_period_ordered",
            "assert_array_dicts_equal",
            "test_daily",
            "test_dti_add_tdi",
            "test_append_with_timezones_dateutil",
            "test_append_many",
            "_slice",
            "test_fillna_int",
            "test_group_fill_methods",
            "test_pandas_datareader",
            "_gen_eval_kwargs",
            "test_overlaps_na",
            "test_to_coo_bad_partition_nonnull_intersection",
            "test_concat_columns",
            "test_frame_fillna_limit",
            "test_filter_maintains_ordering",
            "maybe_cythonize",
            "test_to_datetime_other_datetime64_units",
            "read_pickle",
            "test_to_sql_index_label_multiindex",
            "test_repr_with_unicode_data",
            "test_merge_empty_frame",
            "test_slice_to_array_conversion",
            "test_eq_with_str",
            "_format_regular_rows",
            "test_deprecated_numpy_func_call",
            "_needs_reindex_multi",
            "test_both_offset_observance_raises",
            "test_at_fill_value",
            "maybe_upcast_putmask",
            "_search_replace_num_columns",
            "test_css_to_excel_bad_colors",
            "test_delimit_whitespace",
            "test_105",
            "_default_locale_getter",
            "test_difference",
            "test_recreate_from_data",
            "test_not_all_none",
            "test_series_given_mismatched_index_raises",
            "test_to_frame",
            "_dispatch",
            "test_disallow_setting_tz",
            "test_set_frame_overwrite_object",
            "test_standardize_mapping",
            "_datetime_to_stata_elapsed_vec",
            "test_sort_nan",
            "test_stack_timezone_aware_values",
            "test_roundtrip_thru_setitem",
            "test_merge_misspecified",
            "test_color_single_series_list",
            "test_pickle_path_localpath",
            "check_alignment",
            "test_unicode_print",
            "test_df_subplots_patterns_minorticks",
            "test_append_different_columns_types_raises",
            "test_loc",
            "test_index_tab_completion",
            "test_scalar_from_string",
            "test_subclassed_apply",
            "_unconvert_index",
            "test_td64arr_pow_invalid",
            "_get_rename_function",
            "test_quantile_datetime",
            "test_to_html_border",
            "test_parse_all_fields",
            "test_value_counts_categorical_ordered",
            "test_level_with_tuples",
            "_insert_strls",
            "test_unstack_nan_index",
            "test_ewma",
            "test_cov",
            "test_text_color_threshold_raises",
            "_getitem_iterable",
            "test_ngroup_cumcount_pair",
            "construction_error",
            "test_take",
            "test_loc_setitem_consistency_slice_column_len",
            "test_groupby_mean_no_overflow",
            "test_index_mixed_closed",
            "_get_all_lines",
            "test_to_string_float_na_spacing",
            "test_vars_work_with_multiindex",
            "test_to_datetime_format_weeks",
            "test_plot_scatter_with_categorical_data",
            "test_dayfirst",
            "test_fill_corner",
            "update_pr",
            "test_interp_inplace_row",
            "remove_unused_categories",
            "test_different_number_of_cols",
            "test_eng_float_formatter",
            "_sub_datetime_arraylike",
            "test_period_mean",
            "test_tz_localize_errors_coerce",
            "_getitem_nested_tuple",
            "_get_consensus_names",
            "test_pi_ops_array_int",
            "test_td64arr_add_offset_array",
            "test_stack_preserve_categorical_dtype_values",
            "test_agg_callables",
            "df1",
            "test_readjson_chunks_multiple_empty_lines",
            "test_constructor_categorical_string",
            "_format_header_regular",
            "run_cmd",
            "test_corrwith_series",
            "local_name",
            "test_aggregate_api_consistency",
            "nargsort",
            "test_unstack_group_index_overflow",
            "_get_repr",
            "_get_root",
            "test_info_memory_usage_deep_pypy",
            "test_loc_setitem_consistency",
            "test_swapcase",
            "test_constructor_list_str",
            "test_add_different_nans",
            "test_can_hold_identifiers",
            "test_left_join_index_multi_match_multiindex",
            "time_iteritems",
            "test_diff_datetime_axis0",
            "assert_timedelta_array_equal",
            "test_arith_flex_frame_mixed",
            "test_raises_attribute_error",
            "assert_raises_regex",
            "df_compat",
            "test_setitem_chained_no_consolidate",
            "get_slice",
            "test_merge_nocopy",
            "__invert__",
            "_write_variable_types",
            "right_multi",
            "test_nearest_by",
            "pprint_hits",
            "test_radviz",
            "test_frame_info_encoding",
            "test_unpack_ext_type",
            "test_outer_join_indexer",
            "test_astype_column_metadata",
            "test_read_missing_key_close_store",
            "test_date_range_timestamp_equiv",
            "_from_categorical_dtype",
            "test_if_hexbin_xaxis_label_is_visible",
            "test_concat_period_other_series",
            "test_retain_index_attributes",
            "test_pass_args_kwargs",
            "test_usecols_name_length_conflict",
            "build_font",
            "_non_reducing_slice",
            "test_no_keep_default_na_dict_na_values",
            "test_single_vars_work_with_multiindex",
            "test_value_vars_types",
            "test_take_filling_fill_value",
            "test_categorical_category_dtype",
            "_convert_grouper",
            "test_logical_ops_label_based",
            "test_banklist",
            "test_pos_object",
            "test_is_bool",
            "is_bool_dtype",
            "test_consistency",
            "_coerce_method",
            "test_monotonic_on",
            "test_join_on_fails_with_different_column_counts",
            "test_get_timestamp_range_edges",
            "test_numeric_like_ops",
            "test_nancorr_pearson",
            "test_array_not_registered",
            "time_multi_int_nunique",
            "test_fillna_mixed_float",
            "_format_hierarchical_rows",
            "test_to_html_multiindex_index_false",
            "test_typ",
            "make_empty",
            "test_on_float",
            "_upsample_others",
            "test_repr_truncation_column_size",
            "has_info_repr",
            "test_decode_hook",
            "set",
            "test_multi_func",
            "test_to_string_index_formatter",
            "set_atom",
            "backtick_quote_name_with_no_spaces",
            "test_read_writer_table",
            "test_readjson_invalid_chunksize",
            "test_reindex_boolean",
            "test_notna_notnull",
            "test_apply_datetimetz",
            "test_rank_methods_series",
            "test_complex_across_dimensions_fixed",
            "test_loc_getitem",
            "test_mutate_groups",
            "test_append_concat_tz_explicit_pytz",
            "test_line_comment",
            "test_frame_timeseries_column",
            "test_getitem_boolean",
            "test_convert_pandas_type_to_json_field_datetime",
            "test_sortlevel_not_sort_remaining",
            "test_other_dtypes_for_array",
            "test_basic_no_by",
            "test_frame_setitem_copy_no_write",
            "test_create_and_drop_table",
            "test_constructor_dtypes_to_categorical",
            "_write_value_labels",
            "test_set_levels",
            "test_iloc_setitem_with_scalar_index",
            "test_append_same_columns_type",
            "_convert_to_line_delimits",
            "test_append_to_multiple",
            "test_dt64_mean",
            "test_pi_add_sub_timedeltalike_freq_mismatch_daily",
            "test_getitem_slice_fill_value",
            "test_index",
            "test_catch_oob",
            "test_min_max_categorical",
            "_get_column_repeat",
            "test_value_counts_inferred",
            "test_categorical_nan_equality",
            "test_dropna_multiple_axes",
            "test_categorical_repr_timedelta_ordered",
            "test_agg_namedtuple",
            "test_fillna_datelike",
            "test_to_excel_multiindex",
            "test_to_html_with_classes",
            "test_dtypes",
            "test_asfreq",
            "test_fixed_offset_tz",
            "test_sparsea_max_row_truncated",
            "test_constructor_nan",
            "test_searchsorted",
            "test_read_csv_dataframe",
            "cd_and_set_engine",
            "test_shift_nat",
            "test_where_other_categorical",
            "test_corr_kendall",
            "new_func",
            "test_categorical_dtype_chunksize_infer_categories",
            "_create_sp_series",
            "_arr_to_str",
            "_maybe_cast_indexed",
            "test_encode_decode",
            "test_rolling_min",
            "test_read_dta2",
            "nearest",
            "test_integer_thousands",
            "test_pie_df_nan",
            "ftype",
            "isin",
            "_prepare_data",
            "tz_replacer",
            "test_td64arr_mul_too_short_raises",
            "_make_parser_function",
            "test_loc_setitem_frame_multiples",
            "test_resample_weekly_all_na",
            "hist_series",
            "test_reindex_nan",
            "test_bar_align_zero_pos_and_neg",
            "test_upsample_with_limit",
            "_codes_to_ints",
            "test_gold_canyon",
            "test_ragged_mean",
            "_from_derivatives",
            "test_pass_TimedeltaIndex_to_index",
            "_make_field_arrays",
            "test_apply_none",
            "test_setitem_datetime_coercion",
            "test_repr_min_rows",
            "biggie_df_fixture",
            "_validate_usecols_arg",
            "test_mangled",
            "test_str_attribute_raises",
            "test_read_from_file_url",
            "test_fwf_thousands",
            "test_to_string_int_formatting",
            "test_expand_user_normal_path",
            "test_loc_setitem_consistency_empty",
            "test_only_1dim_accepted",
            "test_column_in",
            "_validate_read_indexer",
            "test_wrap",
            "test_to_datetime_infer_datetime_format_series_with_nans",
            "test_skiprows_slice_short",
            "test_construction_with_alt_tz_localize",
            "test_dti_convert_tz_aware_datetime_datetime",
            "_maybe_mask_result",
            "_add_nat",
            "convert_to_index_sliceable",
            "time_large_get_loc_warm",
            "disallow",
            "test_donot_drop_nonevalues",
            "test_date_range_timestamp_equiv_dateutil",
            "test_dti_constructor_static_tzinfo",
            "test_diff_datetime_axis1",
            "test_normalize_nat",
            "test_to_string_float_format",
            "test_agg_structs_dataframe",
            "test_getitem_setitem_fancy_exceptions",
            "test_pickle_preserve_name",
            "cov",
            "create_index_with_nan",
            "test_parse_date_time_multi_level_column_name",
            "test_maybe_promote_any_with_datetime64",
            "test_getitem_ix_mixed_integer",
            "test_parse_dates_custom_euro_format",
            "test_mul_float_series",
            "test_isin_df_dupe_values",
            "_have_mixed_levels",
            "_maybe_coerce_merge_keys",
            "test_usecols_list",
            "test_index_resolvers_come_after_columns_with_the_same_name",
            "test_union_categoricals_empty",
            "test_float_scalar",
            "_check_engine",
            "time_floats_with_int_idex_lines",
            "_check_timedeltalike_freq_compat",
            "test_dataframe_dtypes",
            "test_excelwriter_fspath",
            "time_merge_cat",
            "test_unsortedindex_doc_examples",
            "test_to_html_with_col_space_units",
            "test_start_stop_multiple",
            "ljust",
            "test_replace_with_empty_dictlike",
            "_write_hierarchical_rows",
            "test_no_header",
            "_formatter",
            "test_set_group_name",
            "test_select_dtypes_bad_arg_raises",
            "test_is_numeric_dtype",
            "test_apply_with_mixed_types",
            "str_index",
            "test_dropna_categorical_interval_index",
            "test_sum_nanops_timedelta",
            "test_to_datetime_box_deprecated",
            "test_datetime_units",
            "test_constructor_infer_period",
            "time_copy_function_multi_col",
            "test_dtype_conversion",
            "invert",
            "test_union_categorical_same_categories_different_order",
            "test_frame_column_inplace_sort_exception",
            "_get_cython_table_params",
            "test_constructor_with_naive_string_and_datetimetz_dtype",
            "_simple_ts",
            "test_overwrite_node",
            "test_consolidate_ordering_issues",
            "test_reindex_single_named_indexer",
            "series_generator",
            "test_date_format_frame",
            "test_where_error",
            "validate_inferred_freq",
            "test_values_lcd",
            "iget",
            "test_pi_offset_errors",
            "test_merge_incompat_dtypes_error",
            "test_rmod_timedelta64",
            "test_constructor_dict_order_insertion",
            "test_implicit_label",
            "str_contains",
            "test_print_none_width",
            "test_frame_setitem_multi_column",
            "test_assignment",
            "test_hypothesis_delimited_date",
            "_get_dtypes",
            "test_to_latex_specified_header",
            "test_mod_invalid",
            "_maybe_to_dense",
            "test_objarr_add_str",
            "test_header_multi_index",
            "test_cummin_datetime64",
            "test_select_bad_cols",
            "test_exit_status_errors_for_validate_all",
            "test_indicator",
            "_highlight_extrema",
            "test_escaped_table_name",
            "test_concat_sparse_dense_cols",
            "join",
            "test_crossed_dtypes_weird_corner",
            "write_metadata",
            "test_missing_raises",
            "is_exists",
            "test_add_integer",
            "test_extractall_same_as_extract",
            "_combine_series_frame",
            "test_apply_chunk_view",
            "maybe_expression",
            "test_iloc_getitem_int",
            "date_format",
            "test_add_offset_nat",
            "test_grouping_ndarray",
            "test_series_with_dtype",
            "test_maybe_promote_any_with_bool",
            "test_is_full",
            "test_str_vs_repr",
            "test_importcheck_thread_safety",
            "test_categorical_margins",
            "test_categorical_preserves_tz",
            "test_tz_dtype_mismatch_raises",
            "test_arith_flex_frame",
            "test_shift_dtype",
            "test_assert_numpy_array_equal_value_mismatch6",
            "test_multiindex_column_lookup",
            "_delegate_property_set",
            "_assert_setitem_index_conversion",
            "test_categorical_with_nan_consistency",
            "_apply_meta",
            "test_float_array_comparison",
            "test_properties_hourly",
            "test_groupby_level_no_obs",
            "test_replace_series_no_regex",
            "test_concat_tz_frame",
            "test_duplicated_drop_duplicates",
            "write_block_index",
            "test_is_leap_year",
            "_expand_elements",
            "test_td_floordiv_timedeltalike_array",
            "test_error_on_using_partition_cols_and_partition_on",
            "construct_array_type",
            "test_divmod_numeric",
            "test_get_indexer_strings",
            "test_constructor_ndarray",
            "test_ix_multiindex_missing_label_raises",
            "time_chained_cmp",
            "test_hist_kde",
            "test_path_path_lib",
            "test_validate_bool_args",
            "test_getitem_get",
            "_get_vars",
            "test_arith_getitem_commute",
            "test_basic_drop_first_one_level",
            "test_from_pandas_array",
            "test_intersect_identical",
            "test_multi_assign",
            "test_merge_on_ints_floats_warning",
            "validate_attr",
            "test_take_fill_value_datetime",
            "test_equals_different_blocks",
            "test_observed_groups",
            "nanmean",
            "test_fy5253_last_onoffset",
            "return_type",
            "test_get_loc_interval",
            "test_astype_unicode",
            "test_interp_multiIndex",
            "_check_stat_op",
            "new_func_no_docstring",
            "_validate_integer",
            "test_finder_daily",
            "test_from_product_empty_two_levels",
            "test_sub_object",
            "_get_objs_combined_axis",
            "test_dti_sub_offset_index",
            "test_from_product_datetimeindex",
            "test_partition_cols_supported",
            "detect_console_encoding",
            "rmod",
            "test_loc_getitem_int",
            "test_from_records_tuples_generator",
            "_check_ndim",
            "__nonzero__",
            "test_table",
            "test_apply_series_on_date_time_index_aware_series",
            "test_interpolate",
            "_concat_index_asobject",
            "_doc_parms",
            "test_constructor_with_timedelta_window",
            "test_to_html_truncate",
            "test_isin_level_kwarg_bad_level_raises",
            "test_apply_with_args_kwds",
            "test_series_getitem_corner_generator",
            "test_to_basic",
            "test_other_datetime_unit",
            "test_woy_boundary",
            "_get_column_name_list",
            "test_take_empty",
            "test_partition_series",
            "test_xarray",
            "test_hash_error",
            "atomize",
            "test_timedelta64_conversions",
            "test_multiindex_roundtrip",
            "needs_i8_conversion",
            "test_default_color_cycle",
            "_unstack",
            "test_addition_subtraction_types",
            "test_cummin_timedelta64",
            "test_to_latex_escape",
            "test_compression_roundtrip",
            "test_resample_size",
            "__array__",
            "make_block",
            "test_read_dta3",
            "test_difference_identity",
            "timedelta_index",
            "test_order_of_appearance",
            "test_to_html",
            "test_timedelta64_equal_timedelta_supported_ops",
            "build_alignment",
            "test_apply_series_yield_constant",
            "test_to_latex_multiindex_nans",
            "test_parallel",
            "test_to_datetime_unprocessable_input",
            "test_arg_passthru",
            "test_td64arr_sub_NaT",
            "dispatch_to_extension_op",
            "test_skiprows_infield_quote",
            "test_methods",
            "test_conv_business",
            "test_reindex_nearest",
            "wide_multi_index",
            "test_tdi_addsub_integer_array_no_freq",
            "test_utc_z_designator",
            "time_read_uint64_na_values",
            "test_numpy_reduction",
            "test_options_py",
            "test_secondary_bar",
            "test_constructor_from_unknown_type",
            "test_unexpected_kwargs_raises",
            "test_raises_for_invalid_attribute_name",
            "test_labels",
            "intframe",
            "test_table_values_dtypes_roundtrip",
            "render",
            "test_objects",
            "test_reindex_axes",
            "test_accessor_works",
            "test_xcompat",
            "has_horizontally_truncated_repr",
            "_add_datetimelike_scalar",
            "test_skiprows_set",
            "test_nunique_with_empty_series",
            "test_comparison_different_length",
            "_select_options",
            "test_dataframe_dummies_prefix_bad_length",
            "test_series_plot_color_kwargs",
            "test_is_string_like_dtype",
            "test_where",
            "test_from_records_misc_brokenness",
            "test_select_columns_in_where",
            "test_read_excel_nrows_greater_than_nrows_in_file",
            "test_round_dst_border_nonexistent",
            "test_getname_categorical_accessor",
            "test_unstack_categorical",
            "test_fillna_mixed_type",
            "set_atom_complex",
            "test_is_integer",
            "test_int_df",
            "test_constructor_freq_combined",
            "_harmonize_columns",
            "read_feather",
            "test_mangle_series_groupby",
            "test_interp_limit_to_ends",
            "test_map_with_tuples_mi",
            "test_productsales",
            "test_transform_dtype",
            "test_timedelta_ops",
            "test_method_on_bytes",
            "_add_delta_tdi",
            "_parse",
            "_define_paths",
            "test_join_unconsolidated",
            "test_float_precision_round_trip_with_text",
            "_get_numeric_data",
            "test_mul_datelike_raises",
            "assert_numpy_array_equal",
            "_managle_lambda_list",
            "test_single_line",
            "nanargmax",
            "test_merge_common",
            "array",
            "test_bar_align_mid_pos_and_neg",
            "_create_dtype_data",
            "test_setitem_expand_columns",
            "_check_colors",
            "test_conv_secondly",
            "test_put_mixed_type",
            "test_getitem_list_duplicates",
            "test_rw_use_threads",
            "test_bar_align_zero_nans",
            "test_not_equals_object",
            "mixed_float",
            "_compute_plot_data",
            "_get_metadata_path",
            "test_option_no_warning",
            "test_reorder_categories",
            "test_filter_enforces_scalarness",
            "add_categories",
            "test_concat_multiple_frames_dtypes",
            "test_extension_type",
            "test_to_html_multiindex_sparsify",
            "test_div_equiv_binop",
            "_check_columns",
            "test_construction_index_with_mixed_timezones_with_NaT",
            "test_direct_arith_with_series_returns_not_implemented",
            "test_constructor_string",
            "test_unordered_compare_equal",
            "test_string_categorical_index_repr",
            "time_read_special_date",
            "test_convert",
            "test_deprecate_order",
            "get_indexer_non_unique",
            "test_boxplot_vertical",
            "idx_dup",
            "check_ops_properties",
            "test_to_csv_moar",
            "examples",
            "test_where_complex",
            "_is_sup",
            "_parse_thead_tbody_tfoot",
            "test_cast_on_putmask",
            "test_sort_values_frame",
            "_unstack_multiple",
            "test_replace_series",
            "test_td64arr_add_sub_numeric_scalar_invalid",
            "makeMissingCustomDataframe",
            "_try_aggregate_string_function",
            "test_rename_axis_inplace",
            "test_subplots_sharex_axes_existing_axes",
            "test_setitem_clears_freq",
            "test_lookup_bool",
            "fp",
            "test_astype_categorical_to_categorical",
            "test_iloc_slice_fill_value",
            "test_mode_intoverflow",
            "test_options_get_engine",
            "test_is_extension_type",
            "test_getitem_setitem_float_labels",
            "_create_comparison_method",
            "mixed_float_frame",
            "test_nbytes",
            "time_read_store",
            "prod",
            "test_get_loc_single_level",
            "test_parse_public_s3_bucket_python",
            "_highlight_null",
            "test_infer_objects",
            "test_at_time_between_time_datetimeindex",
            "test_properties_secondly",
            "_groups_or_na_fun",
            "test_valid_join_keys",
            "test_index_equal_values_too_far",
            "test_value_counts_datetime64",
            "maybe_set_size",
            "test_as_json_table_type_date_data",
            "test_nanmin",
            "test_dti_tz_localize_ambiguous_times",
            "test_comp_ops_df_compat",
            "crosstab",
            "read_hdf",
            "test_margins_no_values_two_row_two_cols",
            "test_series_broadcasting",
            "test_dates",
            "_create_arithmetic_method",
            "test_loc_multiindex_indexer_none",
            "test_excel_sheet_size",
            "test_dropna_intervals",
            "test_apply_corner",
            "test_timezone_comparaison_assert",
            "test_nancorr_kendall",
            "test_constructor_name",
            "test_nbytes_block",
            "item",
            "test_deprecate_wrong_docstring",
            "test_nyse_wsj_commas_table",
            "test_join_dups",
            "test_constructor_empty_with_string_dtype",
            "test_interp_all_good",
            "test_parse_failure_unseekable",
            "test_pi_sub_isub_timedeltalike_hourly",
            "clip",
            "month_position_check",
            "test_copy_from_callable_insertion_method",
            "test_timestamp_timetz_equivalent_with_datetime_tz",
            "test_get_label_or_level_values_df_duplabels",
            "test_is_mixed_dtype",
            "test_invalid_double_precision",
            "test_slice_locs_indexerror",
            "test_transform_datetime_to_timedelta",
            "test_unpack_buffer",
            "test_divmod_series",
            "config_prefix",
            "test_bfill",
            "test_agg_timezone_round_trip",
            "test_isna_lists",
            "test_fspath",
            "test_logical_ops_df_compat",
            "test_rename_by_series",
            "_unpickle_series_compat",
            "_from_ordinal",
            "test_repr_large",
            "_asof_function",
            "test_series_index_name",
            "test_rolling",
            "test_merge_categorical",
            "test_more_flexible_frame_multi_function",
            "test_join_with_period_index",
            "get",
            "set_atom_timedelta64",
            "test_with_tz",
            "test_construction_with_categorical_index",
            "_badobj_wrap",
            "parse",
            "_should_parse_dates",
            "_use_inf_as_na",
            "has_vertically_truncated_repr",
            "test_rolling_axis_count",
            "_has_infs",
            "test_take_fill_value_with_timezone",
            "_in_travis_environment",
            "_from_sequence_of_strings",
            "test_empty_lines",
            "test_date_time",
            "test_diff",
            "test_nanosecond_timestamp",
            "_to_sql",
            "test_date_range_timestamp_equiv_explicit_pytz",
            "test_read_dta18",
            "test_line_area_nan_df",
            "test_database_uri_string",
            "radviz",
            "test_astype_with_tz",
            "validate_periods",
            "test_combineSeries",
            "test_excel_multiindex_index",
            "test_error",
            "_convert_tuple",
            "categorical_index",
            "_has_valid_positional_setitem_indexer",
            "test_append_missing_column_proper_upcast",
            "test_divmod",
            "test_api_per_method",
            "test_get_indexer_non_unique",
            "time_add_overflow_b_mask_nan",
            "test_dti_add_series",
            "test_index_equal_values_close",
            "test_fillna_downcast",
            "test__isfinite",
            "_check_plot_works",
            "_delegate_property_get",
            "as_ordered",
            "get_names_from_index",
            "test_ix_weird_slicing",
            "test_resample_anchored_monthstart",
            "test_tuples_have_na",
            "test_arg_for_errors_in_astype",
            "test_put_compression_blosc",
            "test_isin_multiIndex",
            "reindex_like",
            "test_resample_nunique_preserves_column_level_names",
            "test_not_string",
            "test_skip_row_with_quote",
            "test_handle_dict_return_value",
            "time_timedelta_plus_datetime",
            "_make_fixed_width",
            "_test_moments_consistency",
            "test_setitem_clear_caches",
            "test_floating_misc",
            "_get_nobs",
            "test_datetime_time",
            "test_categorical_category_dtype_unsorted",
            "set_default_names",
            "get_cmdclass",
            "_write_file_close_tag",
            "test_resample_upsample",
            "test_nunique",
            "test_negative_non_tick_frequency_descending_dates",
            "test_converter_index_col_bug",
            "time_different_numpy_functions",
            "test_annual_upsample_cases",
            "test_meta_name_conflict",
            "test_setitem_None",
            "test_categorial_datetimelike",
            "test_get_datevalue",
            "test_1d_fill_nonna",
            "test_asfreq_non_unique",
            "test_mi_falsey_name",
            "test_quantile_box",
            "astype",
            "is_full_slice",
            "test_join_non_int_index",
            "test_frame_getitem_setitem_boolean",
            "load_reduce",
            "to_hdf",
            "test_replicate_describe",
            "test_shift",
            "test_get_standard_colors_no_appending",
            "test_numpy_compress",
            "time_convert_direct",
            "test_series_constructor_coerce_data_to_extension_dtype_raises",
            "test_shift_empty",
            "test_to_csv_unicode",
            "concat",
            "test_series_constructor",
            "test_swapaxes",
            "_convert_to_side",
            "_check_align_fill",
            "test_tuple_warns",
            "test_from_codes_with_nan_code",
            "_write_regular_rows",
            "_prep_index",
            "test_constructor_start_end_with_tz",
            "get_versions",
            "test_clip_with_datetimes",
            "test_weeks_onoffset",
            "_block_shape",
            "indexables",
            "test_concat_tz_series_with_datetimelike",
            "test_raises_on_dtype_object",
            "test_contains_moar",
            "test_ix_empty_list_indexer_is_ok",
            "test_td64arr_div_td64nat",
            "testPackUnicode",
            "_next_line",
            "test_union_not_cacheable",
            "_set_tz",
            "test_per_axis_per_level_doc_examples",
            "test_to_datetime_with_space_in_series",
            "_dir_additions",
            "test_dt_timetz_accessor",
            "corr",
            "test_setitem_frame_float",
            "test_dti_constructor_with_fixed_tz",
            "dtype_format_for_platform",
            "_unstack_extension_series",
            "test_tuple_correct_keyerror",
            "test_fancy_getitem_slice_mixed",
            "test_multiindex_setitem",
            "html",
            "test_array_equivalent",
            "test_name_repr_generic",
            "test_round_30min",
            "_dtype_to_stata_type",
            "highlight_null",
            "author_missing_data",
            "test_df_add_2d_array_rowlike_broadcasts",
            "time_read_json_lines",
            "parse_table_schema",
            "_class_to_alias",
            "test_rule_code",
            "_set_with",
            "test_ax_plot",
            "test_resolution_string",
            "test_interpolate_akima",
            "test_to_numpy",
            "test_nunique_with_timegrouper",
            "test_to_csv_mixed",
            "_validate_date_like_dtype",
            "test_density",
            "test_unstack_fill_frame_period",
            "test_adjoin_unicode",
            "test_nat_handling",
            "test_readonly_axis_zlib_to_sql",
            "set_ordered",
            "test_categorical_ordering",
            "get_rule_code_suffix",
            "test_codes_immutable",
            "test_repr_tuples",
            "test_empty_sequence_concat",
            "_align_frame",
            "test_timegrouper_with_reg_groups",
            "test_negative_skiprows",
            "test_strip_lstrip_rstrip_args",
            "test_get_loc_length_one_interval",
            "categories",
            "_downsample",
            "test_constructor_dict_of_tuples",
            "_get_prev_label",
            "test_compression_zlib",
            "test_corner_cases",
            "test_take_fill_valid",
            "_skip_if_not_us_locale",
            "test_to_latex_multindex_header",
            "test_dataframe_box_false",
            "_offset_str",
            "test_apply_empty_infer_type",
            "test_encoding",
            "test_getitem_with_duplicates_indices",
            "test_asfreq_MS",
            "test_period_cons_mult",
            "test_to_datetime_bijective",
            "test_pivot_index_with_nan",
            "test_datetime64_with_index",
            "test_mixed_freq_irregular_first_df",
            "_convert_listlike",
            "_init_dict",
            "test_fy5253_nearest_onoffset",
            "_count_level",
            "test_read_from_s3_url",
            "test_to_string_complex_float_formatting",
            "test_set_index_custom_label_type_raises",
            "test_iloc_sparse_propegate_fill_value",
            "test_bad_apply_shape",
            "_read_header",
            "scatter",
            "set_codes",
            "test_fast_unique_multiple_list_gen_sort",
            "_infer_compression",
            "itemsize",
            "test_resample_anchored_ticks",
            "test_underlying_data_conversion",
            "idx",
            "test_pivot_table_multiple",
            "test_pivot_dtypes",
            "_add_numeric_methods_add_sub_disabled",
            "test_ewmcorr_pairwise",
            "test_factorize_nan",
            "test_df_add_td64_columnwise",
            "test_unsupported_other",
            "test_translate",
            "test_sort_nat_values_in_int_column",
            "test_msgpacks_legacy",
            "test_reindex_doesnt_preserve_type_if_target_is_empty_index",
            "test_roundtrip_chunksize",
            "test_compare_unknown_type",
            "test_pipe_tuple",
            "_get_default_writer",
            "test_series_getitem_indexing_errors",
            "test_series_operators",
            "test_to_coo_bad_ilevel",
            "test_dti_shift_near_midnight",
            "test_constructor_scalar_inference",
            "test_setattr_column",
            "test_ngroup_groupby_not_col",
            "_set_labels",
            "time_read_uint64",
            "test_nth_multi_index_as_expected",
            "test_freq_conversion",
            "_maybe_resample",
            "test_nonunicode_nonascii_alignment",
            "test_extract_series",
            "visit_Module",
            "test_boxplot_series",
            "testFixMap",
            "test_plot_figsize_and_title",
            "test_astype_cast_object_int",
            "_open_file_binary_write",
            "test_time_loc",
            "test_con_string_import_error",
            "test_categorical_series_repr_datetime",
            "_generate_range_overflow_safe_signed",
            "test_setitem_tuple",
            "get_corr_func",
            "test_to_datetime_overflow",
            "test_rollforward",
            "test_validation",
            "test_td64arr_add_intlike",
            "test_unary_ops",
            "test_frame_any_all_group",
            "cumsum",
            "_where_standard",
            "test_slice_consolidate_invalidate_item_cache",
            "test_to_latex_midrule_location",
            "test_split_maxsplit",
            "test_single_mgr_ctor",
            "test_array_list",
            "test_json_normalize_errors",
            "test_frame_nonprintable_bytes",
            "test_factorize_dst",
            "test_expand_user",
            "test_to_timestamp_1703",
            "test_index_unique",
            "test_to_datetime_infer_datetime_format_consistent_format",
            "test_groupby_transform_rename",
            "test_duplicate_level_names_access_raises",
            "_data",
            "test_start_time",
            "test_offset",
            "_subplots",
            "df2",
            "test_agg_nested_dicts",
            "test_nanany",
            "test_get_group",
            "test_timestamp_constructor_near_dst_boundary",
            "test_dtype_on_merged_different",
            "test_getitem_listlike",
            "test_compare_series_interval_keyword",
            "_combine_lines",
            "test_empty_nonzero",
            "test_reindex_items",
            "test_join_multiindex_leftright",
            "test_concat_categorical_empty",
            "test_constructor_same",
            "_insert_index",
            "test_unit_consistency",
            "test_to_latex_multiindex",
            "test_drop_names",
            "test_mixed_type_suffix",
            "_get_freq",
            "test_ngroup_descending",
            "pprint_thing",
            "test_parse_public_s3_bucket_nrows_python",
            "register_index_accessor",
            "test_hist_df_with_nonnumerics",
            "test_comparison_tzawareness_compat",
            "test_skip_group_keys",
            "test_compression_warning",
            "test_rolling_quantile_interpolation_options",
            "test_parse_date_all_fields",
            "test_default_date_conversion",
            "test_infer_output_shape_columns",
            "_unbox_scalar",
            "test_repr_html_wide",
            "test_constructor_unsortable",
            "test_formatting_values_deprecated",
            "test_duplicate_column_name",
            "test_ragged_apply",
            "simple_date_range_series",
            "test_maybe_mangle_lambdas_args",
            "test_iloc_getitem_dups",
            "test_tfoot_read",
            "test_minmax_timedelta64",
            "__ne__",
            "sort",
            "test_pi_add_offset_n_gt1",
            "test_get_level_values_box",
            "test_apply_corner_cases",
            "test_df_div_zero_int",
            "test_multitype_list_index_access",
            "test_float_comparison_bin_op",
            "test_repr_np_nat_with_object",
            "test_to_datetime_tz",
            "test_nonunique_raises",
            "sparse_reindex",
            "test_replace_int_to_int_chain",
            "test_dti_take_dont_lose_meta",
            "test_datetime_invalid_scalar",
            "test_dataframe_constructor_from_dict",
            "test_pairwise_with_self",
            "time_rank_ties",
            "test_groupby_grouper",
            "test_from_records_decimal",
            "test_mixed_freq_second_millisecond",
            "time_replace",
            "test_as_json_table_type_date_dtypes",
            "test_to_csv_defualt_encoding",
            "test_slice_locs_negative_step",
            "test_accessor_raises",
            "test_dti_custom_business_summary_dateutil",
            "signature_parameters",
            "test_constructor_spindex_dtype",
            "_get_layout",
            "test_assignment_fails",
            "test_unstack_bool",
            "test_tz_convert_corner",
            "test_tdi_add_overflow",
            "test_constructor_dict_timedelta_index",
            "test_casefold",
            "test_interpolate_timedelta_index",
            "test_from_arrays",
            "diff",
            "test_slice_locs_not_sorted",
            "test_default_handler_raises",
            "test_categories",
            "test_rename_axis_mapper",
            "visit_Subscript",
            "data_missing",
            "test_multi_index_header",
            "test_resample_dup_index",
            "test_at_time",
            "_parse_metadata",
            "test_scalar_comparison_tzawareness",
            "test_validate_ordered",
            "test_align_nocopy",
            "test_series_negate",
            "_bar",
            "test_to_integer_array_inferred_dtype",
            "test_concat_dataframe_keys_bug",
            "test_to_html_float_format_no_fixed_width",
            "test_str_cat_align_mixed_inputs",
            "test_get_dummies",
            "test_to_sql_index_label",
            "test_empty_dtype_coerce",
            "_is_dtype_compat",
            "_create_consistency_data",
            "test_rhs_alignment",
            "test_from_resampling_area_line_mixed",
            "test_rolling_apply",
            "hist",
            "test_replace_unicode_with_number",
            "test_interpolate_pchip",
            "test_swapped_columns",
            "test_with_kwargs",
            "pytables_hdf5_file",
            "test_pivot_table_not_series",
            "_get_offset_day",
            "test_attribute_access",
            "test_series_from_json_to_json",
            "test_mixed_depth_drop",
            "test_whitespace_lines",
            "test_dictwrapper_getattr",
            "test_unique",
            "extract_index",
            "test_astype_duplicate_col",
            "test_assert_produces_warning_honors_filter",
            "test_construction_dti_with_mixed_timezones",
            "test_nanvar_all_finite",
            "test_join_sort",
            "test_boxplot_return_type",
            "test_dt_accessor_api_for_categorical",
            "test_select_dtypes",
            "apply_raw",
            "test_suppress_error_output",
            "test_inf",
            "test_invalid_terms",
            "test_constructor_from_categorical_with_dtype",
            "test_read_expands_user_home_dir",
            "test_unstack_preserve_dtypes",
            "test_nan_fullcolumn",
            "test_unicode_encoding",
            "test_datelike",
            "test_tdi_shift_empty",
            "has_level_label",
            "test_incorrect_type_nested_map",
            "test_union_categoricals_sort_false",
            "test_masked_setitem",
            "test_read_duplicate_index_implicit",
            "test_pairwise_with_series",
            "test_store_datetime_mixed",
            "all_index_generator",
            "test_round",
            "abs",
            "test_corr_pearson",
            "test_setitem_listlike",
            "pivot",
            "_get_fmtlist",
            "_add_timedeltalike_scalar",
            "test_unicode",
            "assert_series_equal",
            "_cat_compare_op",
            "rfind",
            "test_to_csv_dups_cols",
            "test_interp_basic",
            "is_terminal",
            "test_reindex_bool_pad",
            "_check_method",
            "test_date_range_with_tz",
            "test_conv_annual",
            "spmatrix",
            "test_to_csv_from_csv1",
            "test_export",
            "_setup_build_doc",
            "examples_errors",
            "test_from_tuples_iterator",
            "test_multi_index_names",
            "reindex_axis",
            "test_symmetric_difference",
            "test_read_table_columns",
            "_scalar_from_string",
            "test_hide_single_index",
            "test_sparse_mi_max_row",
            "test_to_sql_series",
            "maybe_convert_dtype",
            "test_filter_corner",
            "test_listlike_setitem",
            "test_merge_on_datetime64tz_empty",
            "test_nanosecond_getitem_setitem_with_tz",
            "makePeriodIndex",
            "test_nsmallest",
            "test_sparse_frame_fillna_limit",
            "test_uuid",
            "test_get_dummies_all_sparse",
            "str_get",
            "_write_sortlist",
            "test_fromValue",
            "test_iloc_getitem_slice_dups",
            "test_frame_groupby_columns",
            "test_dict_compat",
            "_convert_to_ndarrays",
            "test_categorical_dtype_high_cardinality_numeric",
            "test_nested_scope",
            "test_read_write_dta10",
            "test_isna",
            "to_time",
            "time_write_store_table",
            "get_test_data",
            "_setup_axes",
            "test_exponents_without_eng_prefix",
            "rank",
            "test_no_na_values_no_keep_default",
            "gen_binary_data",
            "test_nan_to_nat_conversions",
            "test_same_tz_min_max_axis_1",
            "setup",
            "test_performance_warning_for_poor_alignment",
            "test_dataframe_dummies_prefix_str",
            "test_get_callable_name",
            "test_subclass_sparse_transpose",
            "make_invalid_op",
            "to_string",
            "_write_col_header",
            "test_maybe_promote_any_numpy_dtype_with_datetimetz",
            "test_constructor_list_like",
            "is_na",
            "test_excel_stop_iterator",
            "test_series_named_agg_duplicates_raises",
            "test_max_rows_eq_one",
            "test_spline",
            "_validate_indexer",
            "test_datetime_invalid_index",
            "test_constructor_datetime64arr_ok",
            "_join_unicode",
            "time_col_select_numpy_sum",
            "test_at_and_iat_set",
            "test_render_empty_dfs",
            "test_pivot_with_tuple_of_values",
            "test_frame_from_json_bad_data",
            "test_invalid_origin",
            "_get_op_result_fill_value",
            "test_difference_sort_incomparable",
            "test_generate_bins",
            "base",
            "test_objarr_radd_str",
            "test_ser_flex_cmp_return_dtypes_empty",
            "_get_fill_indexer",
            "test_concat_mixed_dtypes",
            "test_to_datetime_dt64s",
            "test_loc_coerceion",
            "test_c_engine",
            "test_path",
            "test_check_many_exprs",
            "_is_sqlalchemy_connectable",
            "test_duplicated_do_not_fail_on_wide_dataframes",
            "test_setitem_corner",
            "_isna_new",
            "test_count",
            "test_assert_almost_equal_shape_mismatch_override",
            "time_parse_today",
            "test_groupby_resample_api",
            "holidays",
            "time_period_constructor",
            "skip_numpy_object",
            "test_unstack_fill_frame_datetime",
            "test_kde_kwargs",
            "test_mean_datetimelike",
            "test_constructor_interval",
            "test_numpy_round_nan",
            "test_assert_extension_array_equal_non_extension_array",
            "test_timegrouper_apply_return_type_value",
            "test_column_dups2",
            "test_union_categoricals_sort",
            "test_map_dict_subclass_without_missing",
            "test_transform_casting",
            "test_astype_str_float",
            "test_repr_roundtrip_raises",
            "time_query_datetime_index",
            "_run_test",
            "__hash__",
            "test_interpolate_from_derivatives",
            "test_from_categorical_dtype_ordered",
            "init_osx_clipboard",
            "dtype_str",
            "rpartition",
            "test_setitem_datetimeindex_tz",
            "test_ignore_empty_rows_when_inferring_header",
            "test_mode_str_obj",
            "test_table_styles",
            "test_style_by_column",
            "_minmax",
            "test_week_of_month_infer",
            "test_multigroup",
            "is_copy",
            "test_int_name_format",
            "test_setitem_frame_mixed",
            "test_datetime_understood",
            "get_node",
            "time_from_iso_format",
            "test_constructor_name_unhashable",
            "test_resample_entirly_nat_window",
            "test_where_series_datetime64",
            "test_agg_over_numpy_arrays",
            "from_tuples",
            "test_rank_args_missing",
            "test_multiindex_slicers_non_unique",
            "test_rename_bug",
            "test_not_all_defaults",
            "test_mode_mixeddtype",
            "test_astype_specific_casting",
            "test_set_index_custom_label_type",
            "test_constructor_dtype_timedelta64",
            "test_time_zone_aware_index",
            "test_transpose",
            "test_timestamp",
            "setup_cache",
            "assert_index_parameters",
            "test_get_loc_multiple_dtypes",
            "test_loc_frame",
            "test_ops_series",
            "test_to_timestamp_mult",
            "test_indexing_doesnt_change_class",
            "test_resample_loffset_arg_type",
            "test_infer_dtype_timedelta",
            "test_set_ContextManager",
            "test_datetime64_ops_nat",
            "test_resample_fill_missing",
            "test_groupby_multiindex_categorical_datetime",
            "test_detect_string_na",
            "test_as_frame_columns",
            "test_slice_can_reorder_not_uniquely_indexed",
            "make_block_same_class",
            "test_equal",
            "test_type_coercion_at_construction",
            "_transform",
            "test_at_iat_coercion",
            "test_closed_empty",
            "test_frame_setitem_view_direct",
            "convert_from_missing_indexer_tuple",
            "test_append",
            "test_empty_series_add_sub",
            "test_get_group_grouped_by_tuple",
            "test_dt_round_tz_ambiguous",
            "test_spss_umlauts",
            "test_value_array_record_prefix",
            "test_is_datetimelike_array_all_nan_nat_like",
            "sample",
            "test_iloc",
            "test_merge_datatype_categorical_error_raises",
            "test_parse_tz_aware",
            "test_dropna_frame",
            "test_fillna_timedelta",
            "convert",
            "test_constructor_datetime_outofbound",
            "test_isna_numpy_nat",
            "_sub_nat",
            "test_simple_expr",
            "test_sort_index_multicolumn",
            "test_interleave_non_unique_cols",
            "test_mixed_timezone_series_ops_object",
            "test_to_string_no_index",
            "test_construction_quarter",
            "test_grouped_hist_legacy2",
            "test_maybe_promote_int_with_float",
            "test_merge_right_index_right",
            "test_regex_idempotency",
            "test_to_records_datetimeindex_with_tz",
            "test_constructor_mixed_dtypes",
            "test_fancy_getitem",
            "test_series_non_unique_index",
            "test_corr_constant",
            "metadata",
            "test_cross_type_arithmetic",
            "test_type_error_multiindex",
            "_cython_operation",
            "test_select_dtypes_typecodes",
            "test_frame_series_agg_multiple_levels",
            "time_series_int",
            "test_date_index_query_with_NaT_duplicates",
            "test_shift_corner_cases",
            "deprecated",
            "rule_code",
            "test_reindex_series_add_nat",
            "_stringify_path",
            "test_frame_loc_callable_setitem",
            "test_inplace_return_self",
            "to_arrays",
            "test_pivot_table_aggfunc_scalar_dropna",
            "test_replace_tzinfo",
            "test_quarterly_resampling",
            "_arith_method_FRAME",
            "test_series_align_aware",
            "test_as_json_table_type_string_data",
            "test_replace_naive",
            "test_constructor_freq_mult_dti_compat",
            "as_matrix",
            "test_constructor_from_items",
            "test_passed_bar_colors",
            "test_merge_on_index_with_more_values",
            "test_comparison_flex_alignment_fill",
            "test_detect_console_encoding_fallback_to_locale",
            "is_any_int_dtype",
            "test_cumcount_groupby_not_col",
            "import_optional_dependency",
            "_coo_to_sparse_series",
            "test_logscales",
            "test_object",
            "df_none",
            "test_to_excel_multiindex_nan_label",
            "test_query_with_string_columns",
            "_to_original_callable",
            "nanmedian",
            "test_to_csv_date_format",
            "test_boxplot_colors",
            "should_show_dimensions",
            "test_right",
            "test_dataframe_nested",
            "test_math_div",
            "test_complex_cmp_ops",
            "test_td_rdiv_timedeltalike_scalar",
            "test_do_not_mangle_na_values",
            "test_unordered_same",
            "test_construct_from_string",
            "_get_axis_name",
            "test_from_spmatrix_raises",
            "_join_multiline",
            "test_invalid_total_length_max_length_one",
            "test_sum_overflow",
            "test_append_hierarchical",
            "assert_period_array_equal",
            "test_integer_positional_indexing",
            "test_from_product_index_series_categorical",
            "test_ngroup_distinct",
            "_print_as_set",
            "test_fails_on_no_datetime_index",
            "test_groupby_as_index_apply",
            "test_series_invert",
            "test_api_for_categorical",
            "test_get_numeric_data_extension_dtype",
            "set_locale",
            "test_unicode_dta_118",
            "test_tz_is_utc",
            "test_mixed_freq_alignment",
            "time_startswith",
            "test__get_dtype_sparse",
            "test_explicit_conversions",
            "test_floats",
            "time_pad",
            "test_interpolate_spline_invalid_order",
            "test_crosstab_with_categorial_columns",
            "test_interp_raise_on_all_object_dtype",
            "test_order_aggregate_multiple_funcs",
            "is_signed_integer_dtype",
            "test_loc_multiindex_incomplete",
            "test_datelike_mode",
            "__enter__",
            "kde",
            "test_hongkong_tz_convert",
            "test_take_filling",
            "_need_convert",
            "test_examples4",
            "test_custom_business_day_freq",
            "_to_str_columns",
            "test_copy_name2",
            "test_date_range_localize",
            "test_builtins_apply",
            "test_int_array_comparison",
            "_create_sp_frame",
            "run_command",
            "_get_series_result_type",
            "_describe_option",
            "test_dt64arr_aware_sub_dt64ndarray_raises",
            "test_kind",
            "test_parr_ops_errors",
            "test_partial_string_timestamp_multiindex",
            "test_no_args_raises",
            "test_dot",
            "test_unstack_timezone_aware_values",
            "test_aaa_group_order",
            "test_read_csv_buglet_4x_multi_index",
            "_try_coerce_args",
            "_hash_scalar",
            "_check_is_partition",
            "float_frame",
            "time_nlargest_two_columns",
            "test_read_clipboard_infer_excel",
            "test_from_array_deprecated",
            "time_findall",
            "_generate_body",
            "test_tuple_warns_unhashable",
            "test_repr_embedded_ndarray",
            "test_timedelta_plot",
            "test_xs_level_eq_2",
            "test_dti_cmp_nat_behaves_like_float_cmp_nan",
            "_set_axis",
            "test_difference_sort_special_true",
            "_to_safe_for_reshape",
            "test_1",
            "test_slice_bounds_empty",
            "_concat_same_type",
            "index",
            "test_astype_assignment_with_dups",
            "test_agg_item_by_item_raise_typeerror",
            "test_intersection_equal",
            "test_drop_level",
            "test_intersection_bug",
            "test_group_var_large_inputs",
            "test_same_name_scoping",
            "test_difference_incomparable",
            "test_invalid_xy_args",
            "test_repr_big",
            "test_rank_descending",
            "test_to_object_array_width",
            "test_invalid_index_types",
            "test_resample_irregular_sparse",
            "test_comparison",
            "peakmem_read_json_lines",
            "test_empty_with_mangled_column_pass_dtype_by_indexes",
            "test_compare_len1_raises",
            "test_repr_name_coincide",
            "test_convert_pandas_type_to_json_field_float",
            "test_sort_column_level_and_index_label",
            "test_to_period_quarterlyish",
            "test_from_list_dtype",
            "test_pivot_datetime_tz",
            "hist_frame",
            "test_basic_drop_first_NA",
            "test_frame_describe_multikey",
            "test_len",
            "df_main_dtypes",
            "test_duplicate_multiindex_codes",
            "test_concat_tz_series",
            "test_bool_ops_raise_on_arithmetic",
            "test_to_datetime_barely_out_of_bounds",
            "test_filter_against_workaround",
            "test_read_csv_chunked_download",
            "_format_space",
            "test_constructor_nano",
            "_wrap_joined_index",
            "test_from_product",
            "test_apply_keep_sparse_dtype",
            "test_merge_on_ints_floats",
            "_get_ax_legend",
            "test_validate_stat_keepdims",
            "test_inplace_ops_identity2",
            "test_dti_representation_to_series",
            "test_repr_truncation",
            "test_constructor_nat",
            "test_assert_almost_equal_unicode",
            "test_spline_extrapolate",
            "validate_categories",
            "test_from_iterator",
            "test_multi_index_no_level_names_implicit",
            "test_multiindex_symmetric_difference",
            "test_freq_infer_raises",
            "test_promote_datetime_date",
            "test_get_value",
            "get_indexers_list",
            "test_get_indexer2",
            "test_append_list_of_series_dicts",
            "test_empty_string_raises",
            "test_numpy_argmax_deprecated",
            "test_array_interface",
            "test_is_non_overlapping_monotonic",
            "test_dti_construction_nonexistent_endpoint",
            "test_agg_dict_parameter_cast_result_dtypes",
            "_end_apply_index",
            "test_register_option",
            "test_old_import_warns",
            "test_is_scalar_numpy_arrays",
            "test_construction_outofbounds",
            "test_unstack_multiple_hierarchical",
            "test_coercion_with_setitem_and_dataframe",
            "test_to_html_justify",
            "test_to_period_nofreq",
            "test_getitem_dupe_cols",
            "test_groupby_reindex_inside_function",
            "test_to_html_with_empty_string_label",
            "test_cummax",
            "initialize_options",
            "test_compat",
            "test_convert_dates",
            "test_date_boolean",
            "test_encoding_non_utf8_multichar_sep",
            "test_mixed_depth_pop",
            "test_rolling_corr_cov",
            "iteritems",
            "test_categorical_zeroes",
            "test_resample_empty_dataframe",
            "test_bar_align_mid_vmin_vmax_clipping",
            "_get_resampler",
            "test_join_mixed_non_unique_index",
            "test_as_index_series_column_slice_raises",
            "test_mod_timedelta64",
            "test_value_counts",
            "test_mask_with_boolean_raises",
            "test_sort_values_na_position",
            "test_dti_summary",
            "test_bool_uint",
            "test_interp_limit_forward",
            "test_merge_by_col_tz_aware",
            "_concat_compat",
            "test_from_sparse_dtype",
            "test_rounding",
            "test_raise_on_find_unsupported_value",
            "_shallow_copy",
            "_values_for_factorize",
            "is_datetime64_ns_dtype",
            "labels",
            "name",
            "asof",
            "test_get_dummies_dont_sparsify_all_columns",
            "test_parse_integers_above_fp_precision",
            "test_uint64_overflow",
            "lexsort_indexer",
            "test_ops_ndarray",
            "test_period_array_freq_mismatch",
            "test_reindex_level_partial_selection",
            "test_get_offset_name",
            "_get_data_from_filepath",
            "_aggregate_generic",
            "time_pivot_table_categorical",
            "_apply_columns",
            "test_CategoricalAccessor_categorical_deprecation",
            "test_unstack_level_name",
            "test_frame_select",
            "test_resample_dst_anchor",
            "concat_same_type",
            "test_loc_duplicates",
            "test_compare_custom_object",
            "test_read_hdf_generic_buffer_errors",
            "test_concat_period_multiple_freq_series",
            "putmask",
            "test_sort_datetimes",
            "copy",
            "test_pickle_v0_15_2",
            "_create_join_index",
            "test_td_rsub_mixed_most_timedeltalike_object_dtype_array",
            "test_finder_monthly",
            "_can_use_numexpr",
            "is_signed_integer",
            "resample",
            "test_stack_mixed_dtype",
            "test_iloc_setitem_dups",
            "test_set_index",
            "test_get_item",
            "test_custom_repr",
            "test_has_duplicates",
            "test_series_add_tz_mismatch_converts_to_utc_duplicate",
            "test_dti_add_offset_index",
            "test_drop_labels_or_levels_series",
            "test_getitem_with_datestring_with_UTC_offset",
            "test_constructor_mix_series_nonseries",
            "test_subplots_timeseries_y_axis",
            "test_mixed_type_join_with_suffix",
            "test_fillna_datetime64tz",
            "test_nan_to_missing_value",
            "test_multiby_indexed",
            "test_resample_axis1",
            "test_negate_lt_eq_le",
            "test_to_datetime_utc_true_with_series_single_value",
            "test_parse_time_quarter_with_dash_error",
            "test_nan_stays_float",
            "boxplot_frame_groupby",
            "test_rename_positional",
            "test_bins_not_monotonic",
            "test_to_datetime_cache_scalar",
            "test_as_array_datetime_tz",
            "test_add_sub_nat",
            "test_resample_dtype_preservation",
            "cat_safe",
            "test_set_incompatible_types",
            "test_intersection_name_preservation2",
            "test_assign_dependent",
            "test_parsers_quarter_invalid",
            "_assert_tzawareness_compat",
            "test_pi_cmp_nat",
            "test_unique_ordered",
            "test_bad_engine_raises",
            "has_expanded_repr",
            "test_resample_ohlc",
            "test_sub_offset",
            "test_unstack_fill",
            "test_margins_dtype_len",
            "test_append_new_columns",
            "test_where_tz",
            "test_excel_010_hemstring",
            "set_files",
            "test_integer_arithmetic",
            "test_dups_fancy_indexing",
            "test_rank_tie_methods_on_infs_nans",
            "test_groupby_nat_exclude",
            "test_dt64_mul_div_numeric_invalid",
            "_write_cell",
            "test_get_schema2",
            "test_is_overlapping_endpoints",
            "test_replace2",
            "test_convert_infs",
            "test_slicing_directly",
            "test_to_hierarchical",
            "test_subclass_align",
            "describe",
            "test_rename_objects",
            "_string_data_error",
            "check_pow",
            "test_secondary_y_mixed_freq_ts_xlim",
            "test_series_add_tz_mismatch_converts_to_utc",
            "test_xs",
            "test_dataframe_insert_column_all_na",
            "test_set_categories_rename_less",
            "test_index_tolerance",
            "test_str_cat_raises_intuitive_error",
            "insert_statement",
            "test_tz_localize_ambiguous",
            "test_iloc_getitem_neg_int_can_reach_first_index",
            "test_append_empty_frame_to_series_with_dateutil_tz",
            "test_mixed_integer",
            "test_different",
            "test_construction_from_replaced_timestamps_with_dst",
            "test_multiindex_objects",
            "test_to_csv_string_with_lf",
            "_update_inplace",
            "peakmem_read_json_lines_concat",
            "is_",
            "test_datetime_with_tz_dtypes",
            "test_to_string_name",
            "testRaw",
            "test_set_reset",
            "split_and_operate",
            "test_period_index_date_overflow",
            "len",
            "find_common_type",
            "test_constructor_single_str",
            "test_rank_args",
            "test_character_overlap",
            "nunique",
            "test_timestamp_tz_localize_nonexistent_shift_invalid",
            "test_prod_numpy16_bug",
            "test_align_nested_unary_op",
            "test_copy_index_name_checking",
            "_is_deprecated",
            "test_title",
            "test_put_compression",
            "_check_for_locals",
            "test_read_one_empty_col_with_header",
            "test_quantile_interpolation",
            "time_comment",
            "array_equivalent",
            "inferred_type",
            "_reindex_columns",
            "whitelist_method_generator",
            "test_to_hdf_multiindex_extension_dtype",
            "test_merging_with_bool_or_int_cateorical_column",
            "test_setitem_same_ordered_rasies",
            "_validate_freq",
            "test_joins",
            "narrow_multi_index",
            "test_pytables_native_read",
            "random_state",
            "test_frame_iloc_callable",
            "decons_obs_group_ids",
            "test_csv_to_string",
            "test_from_records_bad_index_column",
            "test_value_counts_unique_nunique_null",
            "_use_dynamic_x",
            "should_store",
            "test_to_html_multiindex_odd_even_truncate",
            "test_color_and_style_arguments",
            "_apply_index_days",
            "test_slice_locs_with_interval",
            "test_invalid_logscale",
            "test_fancy_index_int_labels_exceptions",
            "set_levels",
            "test_filter",
            "test_max_str_len",
            "test_from_product_empty_three_levels",
            "test_should_cache",
            "test_weekly_resample_buglet",
            "_get_hashtable_algo",
            "test_from_buffer",
            "test_replace_with_empty_list",
            "_set_formats_and_types",
            "_border_style",
            "test_union_categoricals_ordered",
            "test_groupby_return_type",
            "test_sql_open_close",
            "maybe_color_bp",
            "_maybe_null_out",
            "test_int64_overflow_moar",
            "test_subtype_integer",
            "test_dti_to_pydatetime",
            "test_weekofmonth_onoffset",
            "test_slicing_and_getting_ops",
            "test_anchored_lowercase_buglet",
            "test_none_coercion_loc_and_dataframe",
            "test_cumprod",
            "test_is_list_like",
            "test_parse_delimited_date_swap",
            "data_orientation",
            "test_extract_expand_False",
            "test_normalize",
            "test_read_data_list",
            "test_expanding_count",
            "test_to_dict_index_not_unique_with_index_orient",
            "_cython_agg_blocks",
            "test_date_index_query",
            "test_construct_timestamp_preserve_original_frequency",
            "test_join_self",
            "test_series_to_categorical",
            "test_reindex_multi",
            "_write_formats",
            "test_drop_by_numeric_label_raises_missing_keys",
            "test_ix_assign_column_mixed",
            "test_cast_j_int",
            "test_ser_flex_cmp_return_dtypes",
            "test_apply_issues",
            "_set_default_format",
            "test_simple_in_ops",
            "repeat",
            "test_count_nonnumeric_types",
            "_preprocess_data",
            "test_read_csv_gcs",
            "test_ix_multi_take_multiindex",
            "add_suffix",
            "_maybe_match_name",
            "_get_series_list",
            "test_series_getitem_multiindex_xs_by_label",
            "read_axes",
            "test_no_cast",
            "test_categorical_order",
            "test_get_indexer_array",
            "view",
            "test_constructor_datelike_coercion",
            "test_header_names_backward_compat",
            "test_on_specialized_type",
            "time_unique_seconds_and_unit",
            "test_assert_numpy_array_equal_value_mismatch4",
            "mdiffs",
            "test_constructor_timedelta",
            "test_na_values_with_cache",
            "set_kind",
            "test_record_prefix",
            "test_timedelta_conversions",
            "read_data",
            "test_getitem_datetime",
            "test_setitem_iloc_scalar_single",
            "_hashed_indexing_key",
            "_format_multicolumn",
            "test_tolerance",
            "test_astype_conversion",
            "test_groupby_2d_malformed",
            "_parser_dispatch",
            "test_drop_not_lexsorted",
            "test_hist_single_row",
            "test_partial_boolean_frame_indexing",
            "get_group_index_sorter",
            "default_index",
            "test_to_string_header",
            "test_replace_series_datetime_datetime",
            "colorconverter",
            "test_constructor_dtype_str_na_values",
            "test_replace_series_dict",
            "test_closed_min_max_minp",
            "test_boolean_indexing",
            "test_get_schema",
            "test_pivot_with_tz",
            "test_pivot_empty",
            "empty_value",
            "_convert_params",
            "test_astype_empty_constructor_equality",
            "test_getitem_overload",
            "setitem",
            "_convert_key",
            "get_expected_pow_result",
            "test_getitem_negative_out_of_bounds",
            "test_overflow_on_construction",
            "test_flush",
            "test_bar_align_mid_all_pos",
            "_check_cython_group_transform_cumulative",
            "test_filter_with_axis_in_groupby",
            "test_hashtable_factorize",
            "test_concat_categorical",
            "test_timeseries_preepoch",
            "test_merge_join_different_levels",
            "_prep_window",
            "test_create_table",
            "test_object_array_eq_ne",
            "test_concat_inner_join_empty",
            "test_ragged_count",
            "test_any_all_extra",
            "df_ambig",
            "test_intersection2",
            "_get_cythonized_result",
            "_get_axis_number",
            "test_append_with_different_block_ordering",
            "test_symmetric_difference_mi",
            "test_append_different_columns",
            "generate_table",
            "test_to_dense",
            "test_setitem_fancy_mixed_2d",
            "test_no_legend",
            "test_infer_s3_compression",
            "test_basic_frame_alignment",
            "test_set_index_pass_single_array",
            "test_astype_object_tz",
            "_get_overlap_public_nat_methods",
            "test_timedelta_ops_with_missing_values",
            "test_constructor_sanitize",
            "test_read_csv_no_index_name",
            "test_drop_table",
            "time_from_unit",
            "_apply_style_colors",
            "_post_plot_logic_common",
            "test_bday_near_overflow",
            "apply_index",
            "test_searchsorted_monotonic",
            "test_freq_setter_deprecated",
            "test_keep_default_na",
            "test_search_sorted_datetime64_list",
            "test_categorical_dtype",
            "test_replace_for_new_dtypes",
            "test_find_nan",
            "assert_almost_equal",
            "test_to_timestamp_tz_arg_dateutil",
            "reset_testing_mode",
            "test_format_sparse_display",
            "test_get_default",
            "test_merge_two_empty_df_no_division_error",
            "test_merge_nan_right",
            "test_ewmcov",
            "test_ser_cmp_result_names",
            "test_setitem_float_labels",
            "expected_html",
            "test_no_header_prefix",
            "test_unstack_bug",
            "test_regex_replace_dict_nested_gh4115",
            "test_as_json_table_type_int_data",
            "test_simple_normalize_with_separator",
            "test_frame_loc_callable_labels",
            "test_aggregate_with_nat_size",
            "test_repr_truncates_terminal_size",
            "test_set",
            "test_binary_ops",
            "test_multilevel_consolidate",
            "test_isin_dict",
            "test_rename_set_name_inplace",
            "generate_value_label",
            "_check_column_names",
            "validate_indices",
            "test_concat_different_kind",
            "_fill",
            "test_combine_first_with_asymmetric_other",
            "test_select",
            "test_str_cat_align_indexed",
            "_parse_suffix",
            "test_stack_ints",
            "test_missing",
            "test_set_change_dtype",
            "test_constructor_with_datetime_tz",
            "test_remove",
            "test_last_raises",
            "test_store_datetime_fractional_secs",
            "test_info_memory_usage_bug_on_multiindex",
            "test_infer_output_shape_listlike_columns",
            "test_std_var_pass_ddof",
            "test_interpolate_index_values",
            "test_big_print",
            "test_pyint_engine",
            "test_observed_groups_with_nan",
            "test_datetime_cut_roundtrip",
            "_set_name",
            "test_bar_log_subplots",
            "test_count_with_datetimelike",
            "has_doubly_truncated_repr",
            "test_handle_overlap",
            "test_extractall_stringindex",
            "_normalize",
            "test_reindex_corner",
            "time_from_np_timedelta",
            "test_is_monotonic",
            "test_nargsort",
            "_convert_to_fill",
            "parameter_desc",
            "test_nd_raises",
            "test_observed_perf",
            "test_maybe_mangle_lambdas_passthrough",
            "_assert_same_contents",
            "round_trip_pickle",
            "test_excel_read_buffer",
            "test_usecols_subset_names_mismatch_orig_columns",
            "line",
            "astype_nansafe",
            "test_convert_accepts_unicode",
            "test_concat_bug",
            "test_uses_first_kind",
            "groups",
            "test_unicode_longer_encoded",
            "test_drop_nonunique",
            "_set_ticks_props",
            "kind",
            "period_range",
            "test_combine_first_timedelta",
            "test_ExcelWriter_dispatch",
            "test_decode_from_unicode",
            "test_conversion",
            "test_merge_equal_cat_dtypes2",
            "test_number_mode",
            "test_series_partial_set_period",
            "test_join_index_series",
            "test_apply_reduce_Series",
            "_decide_output_index",
            "test_sparse_frame_unstack",
            "test_groupby_whitelist",
            "__rtruediv__",
            "test_infer_dtype_all_nan_nat_like",
            "recons_labels",
            "test_binops",
            "test_dti_tz_localize_bdate_range",
            "test_reset_index_multiindex_col",
            "time_write_store_mixed",
            "test_monthly",
            "test_fillna_nat",
            "test_series_at",
            "test_groupby_apply_identity",
            "first",
            "test_datetime_count",
            "test_crosstab_dup_index_names",
            "__init__",
            "test_td64arr_div_td64_ndarray",
            "test_constructor_with_index",
            "time_groupby_apply_dict_return",
            "_do_select_columns",
            "test_frame_mixed_depth_get",
            "test_array_numpy_labelled",
            "test_lower_int_prec_count",
            "test_store_index_name_numpy_str",
            "test_skiprows_slice",
            "adjoin",
            "tz_convert",
            "test_n_error",
            "check_binary_arith_op",
            "test_crosstab_dropna",
            "test_2d_datetime64",
            "get_indexer_for",
            "_cast_to_stata_types",
            "test_merge_non_unique_period_index",
            "_handle_truncated_float_vec",
            "test_value_counts_with_nan",
            "test_series_loc_getitem_fancy",
            "test_duplicate_meta_data",
            "test_wide_repr_wide_long_columns",
            "test_method_signatures",
            "test_compare_2100",
            "makeTimeSeries",
            "test_set_index_nan",
            "test_nonnumeric_exclude",
            "test_to_dict",
            "test_groupby_levels_and_columns",
            "_restrict_to_columns",
            "test_compare_timedelta_ndarray",
            "autocorrelation_plot",
            "test_rename_mi",
            "test_series_tz_localize_nonexistent",
            "test_subtype_datetimelike",
            "test_dict_entries",
            "test_timedelta_invalid_key",
            "test_split_noargs",
            "dt64arr_to_periodarr",
            "cartesian_product_for_groupers",
            "test_no_overlap_more_informative_error",
            "_infer_daily_rule",
            "test_intersection_monotonic",
            "test_basic_names",
            "test_chained_union",
            "test_catch_too_many_names",
            "_na_ok_dtype",
            "test_path_pathlib_hdfstore",
            "test_as_json_table_type_int_dtypes",
            "test_delete_slice",
            "test_view_with_args_object_array_raises",
            "empty_index",
            "check_array",
            "test_replace_doesnt_replace_without_regex",
            "get_result_as_array",
            "apply_wraps",
            "test_get_loc_nat",
            "test_unstack_period_series",
            "test_good_class",
            "test_at_time_tz",
            "test_tdi_shift_nonstandard_freq",
            "test_maxbuffersize_bufferfull",
            "test_converters",
            "test_quantile_raises",
            "test_timeseries_periodindex",
            "register_option",
            "test_moment_functions_zero_length",
            "test_drop_tz_aware_timestamp_across_dst",
            "test_nan_string",
            "test_categorical_series_repr_timedelta",
            "test_all_offset_classes",
            "test_compare_hour01",
            "test_to_timedelta_invalid",
            "_convert_obj",
            "test_union_categorical",
            "test_union_sort_other_empty",
            "encode",
            "test_slice",
            "test_info_max_cols",
            "test_usecols_int",
            "test_nat_converters",
            "test_round_issue",
            "tokenize_string",
            "test_tdi_sub_integer_array",
            "_check_compatible_with",
            "test_constructor_from_series_freq",
            "test_to_coo_integer_names_integer_row_levels_nosort",
            "test_conv_hourly",
            "test_duplicates",
            "get_api_items",
            "test_merge_on_datetime64tz",
            "test_alias_to_unit_bad_alias_raises",
            "test_none_comparison",
            "test_partial_set_empty_series",
            "test_from_frame_invalid_names",
            "test_seaborn",
            "_get_val_at",
            "simple_frame",
            "test_cant_fill_missing_dups",
            "use_inf_as_na_cb",
            "test_stack_datetime_column_multiIndex",
            "test_pass_array",
            "test_duplicated_drop_duplicates_index",
            "test_cast_NA_to_bool_raises_error",
            "test_period_nat_comp",
            "test_round_nonstandard_freq",
            "test_pivot_number_of_levels_larger_than_int32",
            "flags",
            "test_astype_extension_dtypes",
            "test_parsers_nat",
            "test_apply_concat_preserve_names",
            "get_level_lengths",
            "is_unsigned_integer",
            "time_groupby_ordered_nosort",
            "test_spline_smooth",
            "test_excel_date_datetime_format",
            "test_repr_html_long_multiindex",
            "test_fwf_regression",
            "test_field_access_localize",
            "test_binary_ufunc_other_types",
            "test_to_json_categorical_index",
            "test_index_type_coercion",
            "test_concat_series_partial_columns_names",
            "test_shallow_nested",
            "test_iter_python_types_datetime",
            "test_usecols",
            "test_take_categorical",
            "test_partial_slicing_with_multiindex",
            "test_apply_non_numpy_dtype",
            "check_results",
            "test_to_csv_new_dupe_cols",
            "test_insert_benchmark",
            "test_skiprows_slice_long",
            "to_native_types",
            "test_from_inferred_categories",
            "test_properties",
            "s_main_dtypes",
            "test_representation",
            "test_boundary_datetimelike",
            "test_pipe_failures",
            "test_groupby_function_tuple_1677",
            "test_multiple_ouput_binary_ufuncs",
            "test_select_dtypes_not_an_attr_but_still_valid_dtype",
            "test_excel_multiindex_columns_and_index_true",
            "_assert_not_almost_equal",
            "test_td64arr_add_offset_index",
            "test_file_like",
            "test_drop_duplicates_categorical_bool",
            "test_many_columns",
            "test_reading_all_sheets",
            "assert_range_equal",
            "test_append_dtype_coerce",
            "_generate_range",
            "check_fun",
            "test_invalid_type_for_operator_raises",
            "__setstate__",
            "test_mean_excludeds_datetimes",
            "test_maybe_promote_dimensions",
            "test_concat_aligned_sort_does_not_raise",
            "__rsub__",
            "test_td_op_timedelta_timedeltalike_array",
            "test_map_with_dict_or_series",
            "test_astype_uint",
            "test_same_categories_different_order",
            "get_op_from_name",
            "test_invalid_parser",
            "test_loc_with_overlap",
            "_convert_can_do_setop",
            "test_map_na_exclusion",
            "test_plot_kwargs",
            "test_integers",
            "_from_inferred_categories",
            "test_read_hdf_series_mode_r",
            "test_query_syntax_error",
            "barh",
            "init_ndarray",
            "test_align_series",
            "test_tdi_shift_minutes",
            "test_set_index_raise_keys",
            "test_dti_cmp_datetimelike",
            "is_datetimelike_v_object",
            "check_simple_cmp_op",
            "test_concat_join_axes_deprecated",
            "to_offset",
            "validate_pep8",
            "test_iso_8601_strings_same_offset_no_box",
            "test_inner_join",
            "test_convert_strl_name_swap",
            "test_unstack_multiple_no_empty_columns",
            "test_east_asian_unicode_false",
            "test_is_datetime64_ns_dtype",
            "test_transform_doesnt_clobber_ints",
            "test_usecols_excel_range_str",
            "test_to_jsonl",
            "date_range_frame",
            "test_describe_tz_values",
            "test_constructor_nonnan",
            "test_td64arr_div_tdlike_scalar_with_nat",
            "test_repr_html_wide_multiindex_cols",
            "test_frame_from_json_nones",
            "test_convert_no_arg_error",
            "_mpl_version",
            "test_to_csv_na_rep",
            "_get_counts",
            "test_ExcelWriter_dispatch_raises",
            "_check_box_coord",
            "test_resample_equivalent_offsets",
            "test_replace_with_single_list",
            "test_axis_share_y",
            "test_categorical_margins_category",
            "_cython_agg_general",
            "test_to_dict_index_dtypes",
            "test_from_sparse_dtype_fill_value",
            "test_round_daily",
            "test_tick_rdiv",
            "ffill",
            "test_msgpack_period_freq",
            "test_subclass_stack_multi_mixed",
            "test_output_significant_digits",
            "test_read_table_index_col",
            "test_parse_date_time",
            "test_pivot_table_multi",
            "ip",
            "test_reorder_levels",
            "test_bins",
            "test_timegrouper_apply_return_type_series",
            "_grouped_hist",
            "randu_array",
            "test_constructor_categorical",
            "test_consolidate_inplace",
            "test_timtetonum_accepts_unicode",
            "test_timedelta64_operations_with_timedeltas",
            "test_to_html_index",
            "_set_endianness",
            "test_combine_first_dt64",
            "test_constructor_numpy_scalar",
            "test_second",
            "_check_align",
            "_apply_window",
            "test_index_convert_to_datetime_array_dateutil",
            "test_read_csv_handles_boto_s3_object",
            "test_set_option_uneven_args",
            "test_is_float",
            "_aggregate_named",
            "test_assert_numpy_array_equal_shape_mismatch_override",
            "merge_pr",
            "_arith_method_SPARSE_SERIES",
            "teardown_method",
            "test_as_json_table_type_float_dtypes",
            "test_concat_categorical_coercion_nan",
            "test_write_with_index",
            "_check_holiday_results",
            "test_categorical_concat_dtypes",
            "test_escapable_characters",
            "test_tz_localize_nonexistent",
            "test_construction_from_string",
            "test_median",
            "get_duplicates",
            "test_set_value_keeps_names",
            "test_operation_on_NaT",
            "create_single_mgr",
            "test_index_with_nan",
            "test_iteration_over_chunksize",
            "query",
            "test_mode_dropna",
            "test_bar_align_left_axis_none",
            "test_filter_and_transform_with_multiple_non_unique_int_index",
            "test_write_column_multiindex",
            "test_replace_dst_border",
            "_maybe_eval",
            "test_selection_api_validation",
            "test_reader_seconds",
            "test_resample_reresample",
            "transpose",
            "test_td64arr_sub_td64_array",
            "test_index_and_on_parameters_confusion",
            "network",
            "test_constructor_timestamp_near_dst",
            "test_unstack_unused_level",
            "test_corr_rank",
            "get_resampler_for_grouping",
            "test_multiindex_assignment",
            "test_finder_annual",
            "test_maybe_convert_numeric_post_floatify_nan",
            "test_invalid_numexpr_version",
            "read_spss",
            "test_to_csv_float_format",
            "test_annual_upsample",
            "test_interp_ignore_all_good",
            "test_join_index",
            "_get_cell_value",
            "test_get_dummies_with_name_dummy",
            "_preprocess_for_cut",
            "test_maxbuffersize",
            "test_left_join_index_multi_match",
            "test_constructor_iso",
            "should_cache",
            "test_to_records_with_categorical",
            "test_get_schema_dtypes",
            "test_bad_version",
            "state_data",
            "test_simple_records",
            "test_convertable_values",
            "is_floating",
            "test_basic_right_index",
            "test_use_bottleneck",
            "test_both_style_and_color",
            "test_td_add_td",
            "test_join_does_not_recur",
            "_convert_string_array",
            "test_drop_by_str_label_raises_missing_keys",
            "test_monotonic",
            "test_metadata_propagation",
            "_from_values_or_dtype",
            "asarray_tuplesafe",
            "test_nanargmax",
            "_parse_td",
            "test_tuple_union_bug",
            "to_csv",
            "test_groupby_empty_list_raises",
            "convert_json_field_to_pandas_type",
            "test_drop_with_ignore_errors",
            "test_capitalize",
            "test_compare_invalid",
            "test_decode_floating_point",
            "test_object_comparisons",
            "test_td64arr_floordiv_tdlike_scalar",
            "test_reindex_axis_style",
            "test_min_max_numeric_only",
            "test_read_write_reread_dta15",
            "test_construction_index_with_mixed_timezones",
            "test_round_mixed_type",
            "test_corr_spearman",
            "compare_element",
            "test_contains",
            "_highlight_handler",
            "test_constructor_with_non_normalized_pytz",
            "mframe",
            "_open_browser",
            "datetime_index",
            "test_float_array",
            "pandas_dtype",
            "test_frame_multi_key_function_list",
            "test_annual",
            "test_large_value_conversion",
            "test_pad_stable_sorting",
            "test_hide_columns_mult_levels",
            "get_indexer",
            "test_floor",
            "test_astype_extension_dtypes_1d",
            "test_to_csv_unicode_index_col",
            "test_engine_type",
            "test_setitem_series_timedelta64",
            "time_join_dataframe_index_shuffle_key_bigger_sort",
            "test_tdi_isub_timedeltalike",
            "test_nth_nan_in_grouper",
            "test_chunksize_read",
            "test_dti_isub_tdi",
            "test_assignment_column",
            "test_constructor_coerce",
            "test_filter_and_transform_with_non_unique_string_index",
            "test_flex_binary_frame",
            "test_to_string_mixed",
            "test_fillna_dtype_conversion",
            "insert_data",
            "get_numeric_mat",
            "time_iso8601_format_no_sep",
            "test_multiple_date_cols_index",
            "test_td64_series_astype_object",
            "test_zero",
            "time_left_outer_join_index",
            "test_hashtable_unique",
            "_arith_method_SPARSE_ARRAY",
            "test_to_csv_compression",
            "write_file",
            "test_series_named_agg",
            "test_transform_broadcast",
            "test_loc_getitem_int_slice",
            "test_group_name_available_in_inference_pass",
            "julian_dates",
            "test_multi_index_no_level_names",
            "test_fill_value_reindex_coerces_float_int",
            "test_get_indexer_nearest_listlike_tolerance",
            "test_groupby_multi_corner",
            "test_info_duplicate_columns_shows_correct_dtypes",
            "test_to_csv_quoting",
            "test_resample_anchored_multiday",
            "_is_potential_multi_index",
            "_maybe_cast_slice_bound",
            "test_overlapping_names",
            "test_fillna_datetime_columns",
            "test_constructor_dict_dont_upcast",
            "test_month_range_union_tz_dateutil",
            "test_query_index_without_name",
            "get_ftype_counts",
            "duplicated",
            "_check_numeric_ops",
            "test_get_indexer_with_NA_values",
            "test_align_frame",
            "time_baseline",
            "test_timestamp_tz_localize",
            "test_rolling_skew_edge_cases",
            "test_read_excel_nrows",
            "invalid_comparison",
            "_validate_specification",
            "test_yy_format_with_year_first",
            "test_get_indexer_pad",
            "test_astype_timedelta64",
            "left",
            "test_get_level_values_na",
            "test_pivot_string_func_vs_func",
            "test_dti_with_period_data_raises",
            "test_matplotlib_formatters",
            "test_rangeindex_fallback_coercion_bug",
            "_three_digit_exp",
            "coerce_to_array",
            "test_examples2",
            "test_set_name",
            "_alert_malformed",
            "test_level_get_group",
            "test_sas_buffer_format",
            "objects_to_datetime64ns",
            "test_set_categories_private",
            "test_to_html_escaped",
            "validate_one",
            "test_concat_order",
            "test_from_product_empty_one_level",
            "to_json",
            "droplevel",
            "test_multi_index_naming",
            "test_infer_tz_compat",
            "test_arg_tz_ns_unit",
            "test_to_timedelta",
            "check_round_trip",
            "test_resample_base",
            "_set_levels",
            "test_expanding_cov_pairwise_diff_length",
            "test_assert_almost_equal_value_mismatch4",
            "test_categorical_pivot_index_ordering",
            "test_sniff_delimiter_encoding",
            "test_partial_slice",
            "test_loc_getitem_duplicates_multiindex_missing_indexers",
            "test_uint64_type_handling",
            "test_numpy_ufuncs",
            "time_frame_nth",
            "test_downsample_across_dst",
            "test_index_col_with_unnamed",
            "test_missing_value_generator",
            "makeMissingDataframe",
            "test_constructor_pass_nan_nat",
            "test_constructor_data_aware_dtype_naive",
            "test_timedelta64_dtype_array_returned",
            "test_finder_monthly_long",
            "test_intersection_name_preservation",
            "test_to_timestamp_preserve_name",
            "test_multi_line_expression",
            "test_ops_series_period",
            "test_get_set_value_no_partial_indexing",
            "maybe_convert_platform",
            "detect_colspecs",
            "test_groupby_non_arithmetic_agg_int_like_precision",
            "test_store_multiindex",
            "test_to_timestamp_quarterly_bug",
            "test_xs_integer_key",
            "test_agg_must_agg",
            "_check_moment_func",
            "test_default_delimiter",
            "time_categorical_level",
            "test_encoding_options",
            "test_expanding_quantile",
            "_validate_parse_dates_arg",
            "_save_header",
            "_next_iter_line",
            "test_operators_none_as_na",
            "test_dti_tz_convert_hour_overflow_dst_timestamps",
            "test_loc_getitem_label_array_like",
            "test_enable_data_resource_formatter",
            "time_read_store_table_wide",
            "_drop_labels_or_levels",
            "test_pi_add_timedeltalike_minute_gt1",
            "test_tz_convert_roundtrip",
            "id_func",
            "mmap_file",
            "test_replace_dtypes",
            "test_td_rsub_offset",
            "section_titles",
            "test_dt_accessor_updates_on_inplace",
            "test_applymap_box",
            "test_seriesgroupby_observed_true",
            "test_ix_loc_setitem_consistency",
            "test_ns_index",
            "decompress_file",
            "test_integer_with_zeros",
            "check_nancorr_nancov_2d",
            "test_date_range_bms_bug",
            "__str__",
            "test_custom_asserts",
            "test_subclass_iterrows",
            "test_multiby",
            "test_integer",
            "test_dataframe_dummies_with_categorical",
            "test_constructor_no_precision_warns",
            "test_to_coo",
            "test_multiple_date_col_custom",
            "test_pad_fillchar",
            "create_pandas_abc_type",
            "test_concat_NaT_series_dataframe_all_NaT",
            "_split_line",
            "test_datetime_outofbounds_scalar",
            "test_cache_updating",
            "test_non_array_raises",
            "test_maybe_promote_datetimetz_with_datetimetz",
            "test_dt64arr_naive_sub_dt64ndarray",
            "_get_space_character_free_column_resolvers",
            "test_StringIO",
            "test_gcs_not_present_exception",
            "test_mixing_naive_tzaware_raises",
            "pandas_type",
            "pprint_thing_encoded",
            "get_atom_coltype",
            "test_chunksize_read_type",
            "test_replace_truthy",
            "test_pivot_timegrouper",
            "test_clipboard_copy_strings",
            "test_from_records_duplicates",
            "write_sparse_intindex",
            "__setattr__",
            "time_groupby_sort",
            "test_iterrows_corner",
            "test_stringified_slice_with_tz",
            "test_nanosecond_string_parsing",
            "check_extension",
            "_get_sqlite_column_type",
            "test_ix_duplicate_returns_series",
            "test_read_with_where_tz_aware_index",
            "test_numeric_compat2",
            "test_complibs_default_settings",
            "custom_dialect",
            "test_skip_rows_bug",
            "test_endswith",
            "_unstack_frame",
            "test_asfreq_combined_pi",
            "test_get_level_lengths_un_sorted",
            "test_update_deprecation",
            "test_nth_empty",
            "test_series_box_timestamp",
            "test_ngroup_matches_cumcount",
            "test_conv_quarterly",
            "test_generator_warnings",
            "test_cython_agg_nothing_to_agg",
            "test_donot_overwrite_index_name",
            "test_consistent_coerce_for_shapes",
            "_isna_old",
            "test_display_format",
            "test_freq_validation_with_nat",
            "_eval_single_bin",
            "test_col_substring_of_stubname",
            "test_is_equal_dtype",
            "_get_subheader_index",
            "test_map_int",
            "test_assign_order",
            "test_thorough_mangle_names",
            "test_iterator_stop_on_chunksize",
            "_make_labels",
            "strip",
            "test_reading_multiple_specific_sheets",
            "time_getitem_slice",
            "test_timeseries_repr_object_dtype",
            "test_hasnans_unchached_for_series",
            "_convert_listlike_indexer",
            "_get_time_stamp",
            "test_multiindex_name",
            "test_reindex_pad",
            "float_frame_fill0",
            "test_binary_ufunc_with_index",
            "test_dtypes_are_correct_after_column_slice",
            "assert_offset_equal",
            "_set_dtype",
            "test_combine_le",
            "test_td64arr_mul_td64arr_raises",
            "test_replace_regex_metachar",
            "test_asarray_homogenous",
            "test_array_unboxes",
            "test_1000_sep_with_decimal",
            "test_slice_non_numeric",
            "test_different_nans",
            "test_df_div_zero_array",
            "test_contains_top_level",
            "test_loc_getitem_array",
            "test_read_write_reread_dta14",
            "test_pindex_qaccess",
            "test_multiby_heterogeneous_types",
            "test_get_offset",
            "test_setitem_chained_setfault",
            "chck_ncols",
            "test_transform_coercion",
            "test_copy_method_kwargs",
            "test_stack_order_with_unsorted_levels",
            "_has_valid_tuple",
            "_reconstruct_data",
            "test_from_to_scipy_object",
            "test_ewmcorr",
            "test_is_string_dtype",
            "test_get_axis",
            "test_nonsense_func",
            "test_spline_interpolation",
            "test_Millisecond",
            "check_comprehensiveness",
            "test_set_index_directly",
            "test_from_tuples_empty",
            "parse_results",
            "dtype",
            "test_query_multiindex_get_index_resolvers",
            "time_transform_ufunc_max",
            "searchsorted",
            "test_get_indexer_with_int_and_float",
            "test_fillna_consistency",
            "test_readonly_axis_blosc_to_sql",
            "test_pad_backfill_object_segfault",
            "rewrite_axis_style_signature",
            "test_merge",
            "test_replace_datetimetz",
            "format_array",
            "_flex_binary_moment",
            "test_chained_cmp_and_in",
            "validate_operand",
            "test_invalid_parse_delimited_date",
            "time_scalar_function_single_col",
            "test_intercept_builtin_sum",
            "test_ewmvar",
            "_restore_dropped_levels_multijoin",
            "time_get_dummies",
            "test_int_to_datetime_format_YYYYMMDD_typeerror",
            "makeCustomIndex",
            "test_constructor_range_based_deprecated_different_freq",
            "test_to_csv_doublequote",
            "assert_is_valid_plot_return_object",
            "test_to_latex_with_formatters",
            "_executable_exists",
            "test_geopandas",
            "time_count",
            "test_value_counts_dtypes",
            "test_to_string_unicode_two",
            "test_read_excel_skiprows_list",
            "open",
            "test_nanprod",
            "test_td64arr_rfloordiv_tdscalar_explicit",
            "test_getitem_setitem_datetime_tz_pytz",
            "ensure_str",
            "test_constructor_mixed",
            "test_drop_duplicates_NA_for_take_all",
            "test_loc_setitem_dups",
            "test_pivot_columns_lexsorted",
            "test_na_values_na_filter_override",
            "test_hist_secondary_legend",
            "test_constructor_unsigned_dtype_overflow",
            "test_rank_dense_method",
            "_comp_method_SERIES",
            "test_categorical_index_repr_datetime_ordered",
            "test_kde_colors",
            "test_plot_xy",
            "test_rank_min_pct",
            "test_frame_basic_dtypes",
            "test_timezones_fixed",
            "_get_column_names_and_types",
            "test_timedelta_range",
            "test_tzlocal_maybe_get_tz",
            "_wrap_applied_output",
            "test_apply_with_mutated_index",
            "test_get_numeric_data",
            "_adjust_dates_anchored",
            "test_asarray_tz_naive",
            "test_agg",
            "test_get_level_lengths",
            "dtypes",
            "nth",
            "test_date_range_fy5252",
            "test_format_pre_1900_dates",
            "corrwith",
            "parse_all_fields",
            "test_str",
            "test_getitem_setitem_integers",
            "_offset",
            "test_union3",
            "test_encode_decode_errors",
            "test_is_sparse",
            "test_asarray_tz_aware",
            "test_timestamp_equality_different_timezones",
            "test_timestamp_to_datetime_explicit_dateutil",
            "test_unstack_odd_failure",
            "test_downcast",
            "test_pipe",
            "test_drop_by_numeric_label_errors_ignore",
            "_bool_agg",
            "is_list_like",
            "test_repr_summary",
            "test_multiple_open_close",
            "test_nat_operations",
            "test_unary_operators",
            "time_large_get_loc",
            "test_mixed_dtype",
            "_get_compressed_labels",
            "test_allow_exact_matches",
            "test_crosstab_multiple",
            "test_overflow",
            "register_dataframe_accessor",
            "all",
            "build_border",
            "test_loc_setitem_datetime",
            "_bank_data",
            "test_custom_var_name",
            "test_fill_value_reindex",
            "test_sort_values_inplace",
            "test_timestamp_tz_localize_nonexistent_raise",
            "test_agg_apply_corner",
            "soft_convert_objects",
            "lookup",
            "test_invalid_dtype",
            "_check_isinstance",
            "test_categorical_index_repr_datetime",
            "test_truncate_with_different_dtypes",
            "test_other_timedelta_unit",
            "test_overlaps_interval",
            "test_frame_empty",
            "test_file_handle_mmap",
            "test_object_dtype_ok",
            "test_pass_spec_to_storer",
            "test_pi_sub_period",
            "test_equal_but_different",
            "test_no_na_filter_on_index",
            "test_pad_require_monotonicity",
            "_shallow_copy_with_infer",
            "test_to_weekly_resampling",
            "test_reindex_columns_method",
            "test_float_trim_zeros",
            "get_value",
            "test_categorical",
            "test_filter_multiple_timestamp",
            "test_to_timestamp_repr_is_code",
            "assert_framelist_equal",
            "_test_all_offsets",
            "test_pi_add_sub_timedeltalike_freq_mismatch_monthly",
            "test_dataframe_compression_defaults_to_infer",
            "test_merge_index_singlekey_right_vs_left",
            "_check_accum_op",
            "test_chunksize_with_compression",
            "nanany",
            "test_join_float64_float32",
            "time_lambda_sum",
            "test_str_cat_mixed_inputs",
            "test_unsortedindex",
            "test_hist_df_legacy",
            "test_apply_typecast_fail",
            "test_drop_col_still_multiindex",
            "test_sqlalchemy_type_mapping",
            "test_ohlc_5min",
            "time_by_object",
            "test_regex_replace_list_obj",
            "test_bool_ops_warn_on_arithmetic",
            "test_join_on_fails_with_wrong_object_type",
            "test_grouping_grouper",
            "test_copy_tzaware",
            "test_fillna_categorical",
            "test_rank_object_raises",
            "validate_bool_kwarg",
            "test_bin32",
            "test_casemethods",
            "test_1700",
            "test_loc_slice",
            "_assert_all_na",
            "_internal_get_values",
            "test_infer_freq",
            "test_concat_tz_series_tzlocal",
            "test_ops_notimplemented",
            "test_array_reshaped",
            "test_zip_error_invalid_zip",
            "test_class_ops_pytz",
            "test_getitem_pydatetime_tz",
            "test_value_counts_nat",
            "test_loc_getitem_bool_diff_len",
            "test_drop_tuple",
            "test_adjoin",
            "test_read_write_dta11",
            "test_take_fill_value_new_raises",
            "maybe_cast_item",
            "testPackUTF32",
            "trim_join_unit",
            "test_unbox_scalar",
            "test_variable_labels",
            "test_concat_sparse_dense",
            "test_unique_label_indices",
            "test_describe_with_tz",
            "test_mask_with_boolean",
            "test_mul_int_array",
            "test_range_slice",
            "test_append_with_empty_string",
            "is_period_arraylike",
            "test_transpose_tzaware_2col_mixed_tz",
            "time_write_store_table_mixed",
            "test_rank_2d_tie_methods",
            "test_index_name_retained",
            "test_duplicated_subset",
            "test_subset",
            "test_date_range_timestamp_equiv_explicit_dateutil",
            "test_flex_binary_moment",
            "test_repr_categorical_dates_periods",
            "test_loc_getitem_label_out_of_range",
            "test_int_int",
            "median",
            "test_loc_empty_list_indexer_is_ok",
            "unary_fns_for_ne",
            "test_frame_apply_dont_convert_datetime64",
            "test_weekmask",
            "test_astype_category",
            "test_frame_setitem_ix",
            "time_series_align_left_monotonic",
            "get_console_size",
            "test_groupby_sort_multiindex_series",
            "test_astype_object_with_nat",
            "test_wide_repr",
            "write_array",
            "test_sharey_and_ax",
            "test_timestamp_in_columns",
            "test_iso_constructor_raises",
            "test_single_variable",
            "test_multi_line_expression_not_inplace",
            "test_xs_setting_with_copy_error_multiple",
            "test_nanstd_nans",
            "_convert_tolerance",
            "test_sparse_max_row",
            "test_to_latex",
            "test_preserve_empty_rows",
            "test_timestamp_constructor_tz_utc",
            "is_unsigned_integer_dtype",
            "sparse",
            "test_bool_ops_with_constants",
            "_grouped_plot",
            "test_frame_datetime64_duplicated",
            "test_query_with_nested_strings",
            "test_v12_compat",
            "test_concat_tz_not_aligned",
            "test_resample_single_group",
            "test_groupby_extension_transform",
            "test_skip_rows_blank",
            "test_rank_dense_pct",
            "test_binop_other",
            "test_CategoricalAccessor_index_deprecation",
            "test_setitem_raises",
            "_get_listlike_indexer",
            "epoch_1960",
            "_groupby_and_merge",
            "test_seriesgroupby_observed_false_or_none",
            "applymap",
            "test_validate_any_all_out_keepdims_raises",
            "test_reindex_int",
            "test_an_exception_in_objecthook1",
            "test_tdi_round",
            "test_deep_skip_rows",
            "get_table",
            "select_dtypes",
            "test_utf8_bom",
            "test_bad_reduce_raises",
            "test_date_query_with_NaT",
            "_get_wom_rule",
            "test_banklist_no_match",
            "test_from_values_or_dtype",
            "test_from_frame_dtype_fidelity",
            "test_rolling_mean",
            "test_convert_json_field_to_pandas_type",
            "set_categories",
            "test_show_null_counts",
            "_create_sp_tsseries",
            "test_constructor_iterable",
            "run_series",
            "test_format_date_axis",
            "test_query_non_str",
            "test_read_write_dta12",
            "test_asfreq_mult_pi",
            "test_td64_df_add_int_frame",
            "is_gcs_url",
            "is_platform_mac",
            "test_timestamp_multiindex_indexer",
            "test_get_indexer_length_one_interval",
            "_combine_match_columns",
            "test_subplots_timeseries_y_axis_not_supported",
            "_add_delegate_accessors",
            "use_numexpr",
            "test_string_factorize",
            "test_invalid_dtype_error",
            "test_transactions",
            "testSimpleValue",
            "test_series_frame_radd_bug",
            "test_as_array_int_bool",
            "get_callable_name",
            "format",
            "test_rowspan_only_rows",
            "test_dti_iadd_int",
            "real",
            "test_datetimeindex_sub_datetimeindex_overflow",
            "test_usecols_dtypes",
            "_maybe_update_cacher",
            "test_union_name_preservation",
            "test_preserve_dtypes",
            "test_large_mi_dataframe_indexing",
            "test_replace_simple_nested_dict_with_nonexistent_value",
            "test_scalar",
            "_repr_html_",
            "get_loc",
            "test_to_latex_multiindex_dupe_level",
            "test_url",
            "get_group_index",
            "test_ufunc_compat",
            "test_equals_op_mismatched_multiindex_raises",
            "test_dont_modify_colors",
            "_arith_method_SERIES",
            "test_astype_datetime64tz",
            "test_reset_index_datetime",
            "test_ndarray_compat_properties",
            "test_groupby_extension_agg",
            "test_fallback_singular",
            "test_parse_public_s3_bucket_chunked",
            "test_take_series",
            "validate_window_func",
            "test_catch_infinite_loop",
            "_getitem_tuple",
            "test_rcParams_bar_colors",
            "test_take_misc",
            "test_add_timestamp_raises",
            "test_string_slice",
            "_set_ticklabels",
            "test_frame_describe_unstacked_format",
            "test_td_add_mixed_timedeltalike_object_dtype_array",
            "shape",
            "test_dataframe",
            "test_get_loc_duplicates",
            "test_name_repr",
            "test_to_csv_string_array_ascii",
            "test_merge_on_extension_array_duplicates",
            "_print_cline",
            "test_concat_numerical_names",
            "test_tseries_indices_series",
            "test_read_json_large_numbers",
            "test_merge_index_types",
            "test_high_freq",
            "test_to_period_monthish",
            "test_constructor_from_items_scalars",
            "test_read_jsonl",
            "_left_join_on_index",
            "partition",
            "test_api_compat",
            "test_tdi_shift_hours",
            "test_grouped_hist_layout",
            "test_all_any",
            "test_drop_duplicates_for_take_all",
            "test_unexpected_keyword",
            "test_drop_non_empty_list",
            "test_boxplot_axis_limits",
            "_check_basic_constructor",
            "__getstate__",
            "test_int_index",
            "bool",
            "_get_next_label",
            "_invalid_indexer",
            "test_read_csv_low_memory_no_rows_with_index",
            "test_numpy_argsort",
            "tostring",
            "test_period_deprecated_freq",
            "test_set_frame_expand_extension_with_regular",
            "test_now",
            "homogenize",
            "test_sub_dti_dti",
            "test_basic_left_index_right_index",
            "assert_stat_op_calc",
            "test_concat_rename_index",
            "test_align_mixed_type",
            "test_groupby_apply_return_empty_chunk",
            "_get_all_tables",
            "time_multiby",
            "_validate_freeze_panes",
            "test_logical_ops_invalid",
            "_get_lines",
            "time_dup_string_dates_and_format",
            "test_map_defaultdict",
            "_get_credentials",
            "test_groupby_as_index_agg",
            "sanitize_array",
            "test_constructor_empty",
            "test_binary_ops_docs",
            "test_query_lex_compare_strings",
            "test_expanding_corr_pairwise",
            "test_internal_null_byte",
            "test_to_timedelta_float",
            "test_really_large_in_arr",
            "pp_options_list",
            "sem",
            "test_datetime_bool",
            "test_default_encoding",
            "time_write_excel",
            "test_getitem_dataframe",
            "test_agg_with_datetime_index_list_agg_func",
            "test_slice_keep_name",
            "_get_data_label",
            "test_today",
            "test_frame_mi_access_returns_series",
            "test_info_memory_usage_deep_not_pypy",
            "test_comment_header",
            "_values_for_rank",
            "test_hist_layout_with_by",
            "test_to_html_decimal",
            "test_to_string_specified_header",
            "test_to_string_float_formatting",
            "test_where_with_numeric_data_and_other",
            "test_where_axis",
            "test_transform_and_agg_err",
            "test_to_timestamp_pi_combined",
            "test_boxplot_subplots_return_type",
            "test_subtype_float",
            "_count_rows",
            "make_mixed_dataframe_v2",
            "test_sum",
            "test_hexbin_with_c",
            "test_rolling_quantile",
            "test_query_single_element_booleans",
            "_make_engine",
            "test_dt64arr_add_sub_relativedelta_offsets",
            "test_separator_date_conflict",
            "test_setitem_expand_with_extension",
            "put",
            "test_mod_zero",
            "slice_locs",
            "test_bool_ops_column_name_dtype",
            "test_dateindex_conversion",
            "test_to_datetime_fixed_offset",
            "_align_core_single_unary_op",
            "test_unique_level",
            "time_pivot_table",
            "_stack_arrays",
            "test_divmod_ndarray",
            "test_ptp",
            "test_to_string_with_datetime64_hourformatter",
            "test_xs_values",
            "test_inconsistent_number_of_rows",
            "test_str8",
            "info",
            "test_join_multiindex",
            "cat",
            "_add_redirects",
            "cumprod",
            "test_str_label_slicing_with_negative_step",
            "time_merge_object",
            "test_where_raises",
            "test_roll_qtr_day_not_mod_unequal",
            "test_dti_tz_convert_hour_overflow_dst",
            "test_internal_eof_byte_to_file",
            "test_mixed_freq_irreg_period",
            "test_array_object_dtype",
            "_constructor_expanddim",
            "_align_series",
            "test_fillna_datetime",
            "test_resample_single_period_timedelta",
            "is_boolean",
            "test_concat_sparse_dense_rows",
            "test_irreg_dtypes",
            "test_date_tz",
            "test_dti_business_summary_pytz",
            "do_setup",
            "dispatch_to_index_op",
            "test_to_datetime_default",
            "test_parsers_timestring",
            "test_sort_index_na_position_with_categories",
            "test_to_datetime_cache_series",
            "test_pivot_no_level_overlap",
            "test_dti_custom_business_summary",
            "test_slice_locs_not_contained",
            "test_is_period",
            "test_select_iterator",
            "test_from_custom_template",
            "test_add_extension_scalar",
            "test_pickle_freq",
            "test_unpack_bytearray",
            "_bn_ok_dtype",
            "as_sparse_array",
            "test_unimplemented_dtypes_table_columns",
            "test_loc_scalar",
            "test_last_week_of_month_on_offset",
            "test_apply_box",
            "test_to_datetime_different_offsets",
            "test_timedelta64",
            "test_basic_setitem_with_labels",
            "test_logical_ops_bool_frame",
            "test_integer_thousands_alt",
            "test_header_not_enough_lines",
            "test_invert",
            "compress",
            "test_convert_dates_infer",
            "cartesian_product",
            "test_repr_array",
            "test_reindex_api_equivalence",
            "test_read_excel_blank",
            "test_timedelta",
            "test_cumcount_empty",
            "test_mean_corner",
            "test_drop_duplicates_tuple",
            "test_where_index_datetime",
            "test_construct_from_string_raises",
            "test_EA_types",
            "_reindex_output",
            "test_join_left",
            "test_exceptions",
            "test_mean_datetimelike_numeric_only_false",
            "test_categorical_writing",
            "test_self_join_multiple_categories",
            "test_ops_series_timedelta",
            "reset_display_options",
            "test_4d_ndarray_fails",
            "test_qcut_binning_issues",
            "test_dti_add_tick_tzaware",
            "test_rowwise_alt",
            "test_rank_tie_methods",
            "assert_categorical_equal",
            "test_pivot_table_with_margins_set_margin_name",
            "test_construction_with_conversions",
            "_parse_subtype",
            "test_i8",
            "_reset_cacher",
            "slice_indexer",
            "test_crosstab_ndarray",
            "test_line_colors_and_styles_subplots",
            "_check_implicitly_registered",
            "test_apply_empty",
            "test_frame_mi_access",
            "test_read_json_table_dtype_raises",
            "_do_convert_categoricals",
            "test_pivot_preserve_dtypes",
            "_get_stacked_values",
            "test_align",
            "test_ops_nat_mixed_datetime64_timedelta64",
            "test_concat_keys_specific_levels",
            "test_to_period_millisecond",
            "test_computer_sales_page",
            "test_concat_datetime_datetime64_frame",
            "test_pi_sub_isub_timedeltalike_daily",
            "test_setitem_with_tz_dst",
            "test_dt64_series_add_mixed_tick_DateOffset",
            "test_join_multi_multi",
            "test_bar_edge",
            "_concat_objects",
            "test_scipy_compat",
            "concatenate_block_managers",
            "test_index_false_to_json_split",
            "test_sort_index_categorical_index",
            "is_type_compatible",
            "test_drop_duplicates_series_vs_dataframe",
            "test_append_with_timedelta",
            "__setitem__",
            "test_dropna_empty",
            "test_quantile_nan",
            "test_arith_flex_frame_corner",
            "test_complex_sorting",
            "test_groupby_agg_observed_true_single_column",
            "test_to_datetime_dtarr",
            "test_missing_args_or_kwargs",
            "test_sub_offset_nat",
            "test_setitem_cast",
            "get_slice_bound",
            "_is_cached",
            "test_coercion_with_loc",
            "test_set_value_with_index_dtype_change",
            "test_from_arrays_empty",
            "_format_col",
            "assert_attr_equal",
            "test_bounds_with_different_units",
            "test_fillna_invalid_method",
            "test_join_on_inner",
            "_get_xticks",
            "test_multiple_date_col_multiple_index_compat",
            "_try_cast",
            "test_minmax_period",
            "test_dst",
            "_get_with",
            "test_secondary_legend",
            "infer_dtype_from_object",
            "size_to_pt",
            "test_xy_args_integer",
            "get_commit_vitals",
            "time_read_hdf",
            "test_tdi_mul_int_array",
            "test_kde_missing_vals",
            "column_types",
            "test_parse_header_of_non_string_column",
            "test_replace_string_with_number",
            "test_repr_dimensions",
            "test_repr_no_backslash",
            "test_period_set_index_reindex",
            "test_read_sql_delegate",
            "values",
            "test_to_series_with_arguments",
            "test_resample_group_info",
            "test_to_xarray",
            "test_read_excel_nrows_non_integer_parameter",
            "test_crosstab_margins_set_margin_name",
            "test_loc_preserve_names",
            "test_setitem_iloc_scalar_mixed",
            "test_consistency_for_boxed",
            "add_imports",
            "test_read_sql_view",
            "test_corrwith_index_union",
            "_stack_multi_columns",
            "test_from_scipy_fillna",
            "test_freq",
            "test_round_trip",
            "test_df_flex_cmp_constant_return_types_empty",
            "test_plot_submethod_works",
            "makeMultiIndex",
            "test_sparse_series_round_trip2",
            "test_to_latex_no_bold_rows",
            "test_astype_copies",
            "test_slice_keeps_name",
            "_read_sql_iris_parameter",
            "test_dt64arr_sub_timestamp",
            "area",
            "test_constructor_list_of_derived_dicts",
            "test_days_neg",
            "__new__",
            "test_intersection",
            "test_setitem_boolean",
            "test_multiindex_set_index",
            "test_modulo2",
            "expanding",
            "test_subplots",
            "test_getitem_label_list_with_missing",
            "test_cdaterange_weekmask",
            "time_transform_multi_key1",
            "test_series_box_timedelta",
            "_cast_types",
            "test_observed_codes_remap",
            "test_getitem_bool_index_single",
            "test_all_custom_freq",
            "last",
            "test_aggregate_normal",
            "test_na_values_with_dtype_str_and_na_filter",
            "_value_formatter",
            "test_where_numeric_with_string",
            "test_index_namedtuple",
            "test_week_of_month_fake",
            "test_long",
            "test_nanvar",
            "test_isinf_scalar",
            "time_query_store_table_wide",
            "test_line_area_nan_series",
            "test_astype_dict_like",
            "test_datetime64_tz_dropna",
            "test_timestamp_constructed_by_date_and_tz",
            "_transform_fast",
            "df_strings",
            "test_td64arr_add_int_series_invalid",
            "datapath",
            "test_pivot_with_list_like_values",
            "test_take_fill",
            "check_keys_split",
            "test_usecols_relative_to_names",
            "test_constructor_maskedarray_nonfloat",
            "test_set_index_append",
            "test_apply_to_timedelta",
            "_skip_if_no_private_key_path",
            "test_assign_columns",
            "first_line_ends_in_dot",
            "test_small_strings_no_warn_zlib",
            "test_deprecated_fastpath",
            "get_series",
            "convert_value",
            "assert_bool_op_api",
            "_reverse_indexer",
            "_check_expanding",
            "test_value_labels_iterator",
            "test_frame_ctor_datetime64_column",
            "test_value_counts_uint64",
            "test_dt64arr_add_mixed_offset_array",
            "test_difference_freq",
            "_getitem_multilevel",
            "mixed_type_frame",
            "_get_label_or_level_values",
            "__array_ufunc__",
            "test_value_counts_unique_nunique",
            "test_loc_listlike_dtypes",
            "test_excessively_long_string",
            "apply",
            "time_write_store_table_dc",
            "time_frame_plot",
            "isna",
            "validate_metadata",
            "cummax",
            "test_to_latex_filename",
            "test_tab_completion_with_categorical",
            "to_gbq",
            "read_fwf",
            "test_str_cat_wrong_dtype_raises",
            "test_boolean_context_compat2",
            "test_dti_tz_localize_tzlocal",
            "test_df_gridspec_patterns",
            "test_read_chunks_columns",
            "test_apply_nanoseconds",
            "test_concat_datetimeindex_freq",
            "test_series_pad_backfill_limit",
            "test_constructor_invalid",
            "get_filepath_or_buffer",
            "test_read_xlrd_book",
            "testMap",
            "test_stat_operators_attempt_obj_array",
            "test_index_col_named",
            "test_from_inferred_categories_coerces",
            "time_from_string",
            "test_categorical_dtype_single",
            "test_concat_empty_dataframe_dtypes",
            "test_constructor_list_of_dicts",
            "test_setitem_with_different_tz",
            "_reindex_axes",
            "test_fill_consistency",
            "test_default_index",
            "test_idxmax",
            "_minmax_wrap",
            "test_as_array_float",
            "test_replace_moar",
            "testFixArray",
            "mix_ab",
            "_check_join",
            "time_set_index",
            "test_timestamp_tz_localize_nonexistent_NaT",
            "test_to_html_with_no_bold",
            "test_concat_multiindex_with_tz",
            "test_ngroup",
            "test_constructor_invalid_quarters",
            "test_arith_frame_with_scalar",
            "test_indexing_assignment_dict_already_exists",
            "test_can_serialize_dates",
            "test_prod",
            "test_resample_empty_dtypes",
            "test_non_cython_api",
            "test_constructor_fromordinal",
            "test_isin",
            "test_tdi_mul_int_series",
            "testIgnoreErrorsPack",
            "test_to_sql_replace",
            "test_concat_timedelta64_block",
            "test_columns_dtypes_invalid",
            "test_resample_anchored_intraday",
            "test_rolling_max",
            "test_append_to_multiple_dropna",
            "test_concat_keys_levels_no_overlap",
            "test_indexing_over_size_cutoff",
            "test_has_duplicates_from_tuples",
            "_scalar_data_error",
            "test_concat_period_series",
            "scipy_sem",
            "test_weird_nested_json",
            "test_comparisons_coverage",
            "test_cross_engine_fp_pa",
            "test_groupby_first_datetime64",
            "test_datetimeindex_constructor_misc",
            "test_cmov_window_special_linear_range",
            "parsed_114",
            "test_indexing_mixed_frame_bug",
            "_maybe_downcast",
            "test_td_add_pytimedelta",
            "test_constructor_sparse_dtype_str",
            "mixed_int",
            "_check_binary_ew",
            "test_indexing_dtypes_on_empty",
            "_justify",
            "test_dt64arr_add_sub_td64_nat",
            "time_pivot_table_agg",
            "_reset_group_selection",
            "test_td64arr_div_int",
            "to_dict",
            "test_constructor_int_dtype_float",
            "test_setitem_different_tz_raises",
            "test_timedelta64_operations_with_DateOffset",
            "test_factorize_tuple_list",
            "test_pi_add_iadd_timedeltalike_M",
            "test_to_datetime_today",
            "as_unordered",
            "test_invalid_date_kwarg_with_string_input",
            "yields",
            "test_shift_dtype_fill_value",
            "test_excel_roundtrip_indexname",
            "test_api_compat_before_use",
            "test_rank",
            "test_from_weekly_resampling",
            "test_arith_non_pandas_object",
            "test_combine_generic",
            "test_dti_cmp_object_dtype",
            "test_filter_bad_shapes",
            "_handle_shared_axes",
            "test_to_timedelta_via_apply",
            "deprecate_kwarg",
            "test_to_records_index_name",
            "prune",
            "test_concat_multiindex_with_keys",
            "test_float_same_index_comparison",
            "test_setattr_warnings",
            "_daily_finder",
            "test_compression_size_fh",
            "_get_time_delta_bins",
            "shift",
            "test_string",
            "as_json_table_type",
            "prep_ndarray",
            "test_replace_series_datetime_tz",
            "_node_not_implemented",
            "test_period_cons_weekly",
            "_get_formatted_values",
            "_get_plot_backend",
            "is_sequence",
            "test_bar_align_zero_axis_none",
            "_check_mixed_float",
            "_astype",
            "_trim_zeros_complex",
            "test_asfreq_corner",
            "test_append_concat",
            "test_float_index_to_mixed",
            "_info_repr",
            "test_constructor_column_duplicates",
            "test_constructor_timedelta_window_and_minperiods",
            "test_constructor_tz_mixed_data",
            "_get_ind",
            "_get_center_of_mass",
            "test_concat_datetime64_block",
            "test_select_dtypes_str_raises",
            "test_isna_for_inf",
            "test_mixed_freq_hf_first",
            "test_iloc_non_unique_indexing",
            "test_insert",
            "test_cython_fail_agg",
            "test_unique_index",
            "_engine_type",
            "test_set_index_verify_integrity",
            "test_constructor_fromarraylike",
            "test_boxplot",
            "rands",
            "test_to_latex_multicolumnrow",
            "test_merge_datetime64tz_with_dst_transition",
            "test_numpy_array_equal_copy_flag",
            "test_reset_index_multiindex_nan",
            "insert",
            "_validate_color_args",
            "test_constructor_errors",
            "replace_list",
            "test_publishes",
            "test_sparse_series_fillna_limit",
            "test_list_grouper_with_nat",
            "left_df",
            "test_symmetric_difference_non_index",
            "time_by_int",
            "test_replace_bool_with_string",
            "test_numpy_argmin_deprecated",
            "test_groupby_nonobject_dtype",
            "test_droplevel_list",
            "test_slice_replace",
            "time_modulo",
            "test_subdays_neg",
            "test_repr_truncates_terminal_size_full",
            "test_is_monotonic_decreasing",
            "test_agg_compat",
            "test_legacy_table_fixed_format_read_py2",
            "test_deprecate_option",
            "test_td_sub_offset",
            "test_convert_non_hashable",
            "test_setitem_mixed_datetime",
            "test_rolling_kurt_edge_cases",
            "test_reconstruct_remove_unused",
            "render_pep440",
            "test_publishes_not_implemented",
            "validate_expanding_func",
            "test_read_from_http_url",
            "test_set_index_dst",
            "test_skiprows_inference",
            "_make_min_count_stat_function",
            "test_getitem_setitem_ix_negative_integers",
            "time_delta_int_tstamp_lines",
            "test_min_periods",
            "test_join_many",
            "test_fillna_dict_series",
            "test_dti_constructor_numpy_timeunits",
            "test_factorize_tz",
            "test_datetime_date",
            "construct_1d_object_array_from_listlike",
            "test_filter_dropna_with_empty_groups",
            "test_union_bug_1730",
            "test_stack_sparse_frame",
            "test_append_some_nans",
            "test_modf",
            "test_str_accessor_updates_on_inplace",
            "test_loc_getitem_label_slice",
            "test_to_csv_from_csv3",
            "multiindex_dataframe_random_data",
            "test_resample_upsampling_picked_but_not_correct",
            "test_drop_duplicates_with_duplicate_column_names",
            "test_td_construction_with_np_dtypes",
            "test_constructor_errors_tz",
            "test_to_datetime_utc_true_with_series_datetime_ns",
            "time_different_python_functions_singlecol",
            "test_prevent_casting",
            "test_period_ordinal_start_values",
            "test_lookup_raises",
            "test_repr_utcoffset",
            "test_regex_replace_numeric_to_object_conversion",
            "validate_data_columns",
            "test_loc_label_slicing",
            "test_repeat_range",
            "test_dti_repr_short",
            "test_dateoffset_misc",
            "current_packers_data",
            "test_join_many_mixed",
            "test_class_ops_dateutil",
            "test_compound_deprecated",
            "test_pi_add_offset_array",
            "skip_if_no_pandas_parser",
            "test_to_timedelta_on_missing_values",
            "test_bs4_version_fails",
            "time_add_overflow_both_arg_nan",
            "test_operators",
            "test_series_append_dst",
            "test_group_shift_with_null_key",
            "test_repr_nat",
            "test_invalid_separator",
            "test_fromDict",
            "test_read_from_pathlib_path",
            "test_stat_op_api",
            "test_resample_basic_grouper",
            "_pat_wrapper",
            "test_rank_methods_frame",
            "test_timestamp_compare_scalars",
            "test_view_asi8",
            "test_random_state",
            "test_groupby_as_index_series_scalar",
            "test_str_bool_return",
            "ensure_int_or_float",
            "test_groupby_mixed_type_columns",
            "test_date_parser_int_bug",
            "test_rolling_apply_mutability",
            "_simple_new",
            "_drop_axis",
            "time_parse_dateutil",
            "time_get_loc",
            "test_dti_tz_localize",
            "test_with_listlike_columns",
            "_trim_front",
            "test_where_subset",
            "test_rename_categories_dict",
            "setup_class",
            "_join_level",
            "test_monthly_resample_error",
            "test_decompression_regex_sep",
            "test_resample_nunique_with_date_gap",
            "test_loc_getitem_int_raises_exception",
            "test_compare_timedelta64_zerodim",
            "test_index_str_accessor_visibility",
            "read_index_legacy",
            "test_agg_api",
            "test_slice_with_negative_step",
            "test_datetime_categorical_comparison",
            "to_coo",
            "_get_simple_index",
            "test_any_none",
            "test_as_json_table_type_timedelta_dtypes",
            "test_period",
            "test_business_freq",
            "test_excelfile_fspath",
            "test_irregular_datetime",
            "make_axis_dummies",
            "_make_timestamp",
            "_check_for_bom",
            "test_spam_header",
            "test_write_fspath_hdf5",
            "test_series_append_aware",
            "_validate_where",
            "test_read_nrows",
            "test_read_one_empty_col_no_header",
            "test_replace_bool_with_string_no_op",
            "str_strip",
            "test__is_dtype_type_sparse",
            "test_xs_level_multiple",
            "test_parse_dates_empty_string",
            "_op_tests",
            "combine",
            "_process_single_doc",
            "test_get_loc_datetimelike_overlapping",
            "day_name",
            "test_round_invalid",
            "test_string_na_nat_conversion",
            "test_parse_public_s3_bucket",
            "_post_plot_logic",
            "test_to_html_timestamp",
            "test_mutability",
            "test_long_series",
            "test_to_csv_numpy_16_bug",
            "test_get_level_values",
            "_maybe_evaluate_binop",
            "assert_labels_dropped",
            "test_readjson_chunks_series",
            "__call__",
            "test_consolidate_datetime64",
            "test_to_hdf_with_min_itemsize",
            "_validate_for_numeric_unaryop",
            "to_numeric",
            "test_dictify",
            "test_any_all_np_func",
            "test_groupby_monotonic",
            "test_monotone_DTI_indexing_bug",
            "test_to_datetime_cache",
            "test_with_local_timezone_pytz",
            "get_storer",
            "test_csv_mixed_type",
            "test_cant_compare_tz_naive_w_aware",
            "test_s3_roundtrip",
            "test_select_dtypes_exclude_using_list_like",
            "test_nanvar_nans",
            "is_uniform_join_units",
            "test_append_records",
            "test_xs_with_duplicates",
            "test_constructor_complex_dtypes",
            "test_mutated",
            "test_closed_one_entry",
            "_tidy_repr",
            "test_stack_unstack_multiple",
            "test_bad_resolver_raises",
            "_get_frame_result_type",
            "test_negone_ordinals",
            "test_ragged_quantile",
            "test_reindex_with_datetimes",
            "test_view",
            "test_melt_missing_columns_raises",
            "test_replace_inplace",
            "test_to_csv_index_no_leading_comma",
            "is_freq_type",
            "test_columns_with_dups",
            "test_to_latex_bold_rows",
            "show_col_idx_names",
            "test_mixed_ops",
            "test_value_counts_datetime_tz",
            "test_datetimeindex_accessors",
            "test_invalid_plot_data",
            "test_partial_setting_with_datetimelike_dtype",
            "_convert_data",
            "test_nonexistent_path",
            "test_dialect_str",
            "test_nat_representations",
            "test_all_any_params",
            "str_pad",
            "test_groupby_datetime64_32_bit",
            "test_astype_to_same",
            "test_loc_multiindex_too_many_dims_raises",
            "test_boxplot_legacy1",
            "test_default_col_names",
            "test_slice_quarter",
            "test_bool_na_values",
            "test_utf16_bom_skiprows",
            "test_apply_mixed_datetimelike",
            "test_multiindex_contains_dropped",
            "test_nanmax",
            "test_set_levels_codes_directly",
            "_convert_bin_to_numeric_type",
            "test_mixed",
            "test_loc_getitem_label_list_fails",
            "format_type",
            "test_datetimeindex_union_join_empty",
            "str_extractall",
            "frame_of_index_cols",
            "test_resample_not_monotonic",
            "test_dt_conversion_preserves_name",
            "test_is_timedelta64_dtype",
            "test_processing_order",
            "tzframe",
            "test_slice_year",
            "test_freq_validation",
            "time_period_to_datetime",
            "test_center_ljust_rjust_fillchar",
            "_get_seek_variable_labels",
            "test_read_empty_dta",
            "test_fails_and",
            "test_east_asian_len",
            "test_operators_datetimelike",
            "test_fillna_dataframe",
            "test_to_excel_multiindex_no_write_index",
            "test_period_from_ordinal",
            "is_uniform_reindex",
            "_factorize_keys",
            "_set_group_selection",
            "test_to_sparse_preserve_multiindex_names_columns",
            "test_nonunique_assignment_1750",
            "check_compressed_urls",
            "use_numexpr_cb",
            "test_invalid_complib",
            "test_concatlike_common_period_diff_freq_to_object",
            "test_constructor_list_of_lists",
            "test_constructor_invalid_items_unused",
            "test_filter_out_no_groups",
            "test_store_index_name",
            "test_pct_change",
            "test_render_double",
            "test_all_not_none",
            "test_dt64_series_astype_object",
            "test_add_column_with_pandas_array",
            "test_compare_frame",
            "test_expanding_corr_diff_index",
            "test_td64arr_rmod_tdscalar",
            "test_applymap_subset_multiindex",
            "test_union_different_types",
            "test_parse_dates_combine",
            "skew",
            "test_xs_partial",
            "aggregate",
            "test_get_value_duplicates",
            "test_get_indexer_strings_raises",
            "test_multiple_date_col_timestamp_parse",
            "test_positional_take_unobserved",
            "test_write_row_by_row",
            "test_concat_tz_NaT",
            "test_convert_non_ns",
            "test_unpacker_hook_refcnt",
            "test_list_slice",
            "register_plotting_backend_cb",
            "test_stringify_path_localpath",
            "test_time_accessor",
            "__add__",
            "test_read_py2_hdf_file_in_py3",
            "density",
            "test_asfreq_resample_set_correct_freq",
            "test_dense_to_sparse",
            "test_nan_handling",
            "test_dataframe_dummies_drop_first_with_categorical",
            "test_names",
            "test_td_floordiv_null_scalar",
            "test_construction_caching",
            "test_rolling_median",
            "test_getitem_fill_value",
            "test_resample_tz_localized",
            "test_setting_with_copy_bug",
            "test_to_datetime_tz_pytz",
            "test_parse_nanoseconds_with_formula",
            "test_repr_column_name_unicode_truncation_bug",
            "test_sort",
            "test_get_loc_cast_bool",
            "_join_i8_wrapper",
            "test_union_bug_4564",
            "bar",
            "test_categorical_repr_datetime_ordered",
            "test_to_datetime_infer_datetime_format_inconsistent_format",
            "test_ix_setitem_out_of_bounds_axis_1",
            "test_apply_dict_depr",
            "test_stack",
            "time_replace_tz",
            "test_apply_multiindex_fail",
            "test_misc_example",
            "test_constructor_Series_differently_indexed",
            "apply_series_generator",
            "test_td_floordiv_numeric_series",
            "test_groupby_transform",
            "_convert_list_indexer",
            "test_ops",
            "test_parsers",
            "_series_name",
            "_is_dtype_type",
            "test_arg_for_errors_in_astype_dictlist",
            "categorical",
            "test_invalid_variable_labels",
            "is_sparse",
            "test_integer_values_and_tz_deprecated",
            "test_reindex_empty_series_tz_dtype",
            "test_sort_index_and_reconstruction_doc_example",
            "test_stringify_path_fspath",
            "hash_pandas_object",
            "doc_parameters",
            "xs",
            "test_parr_add_sub_datetime_scalar",
            "test_ix_categorical_index",
            "test_constructor_for_list_with_dtypes",
            "test_unique_na",
            "test_nan_multiple_containment",
            "test_set_index_drop_inplace",
            "test_constructor_strptime",
            "test_to_coo_text_names_text_row_levels_nosort",
            "test_2d_float32",
            "_sort_levels_monotonic",
            "test_any_all",
            "test_interp_limit",
            "test_mixed_freq_irregular_first",
            "_hash_categorical",
            "test_iloc_getitem_doc_issue",
            "test_drop_duplicates_inplace",
            "get_new_index",
            "test_append_mixed_dtypes",
            "test_unicode_repr_doesnt_raise",
            "test_nsmallest_nlargest",
            "create",
            "test_cut_pass_labels_compat",
            "test_duplicate_groupby_issues",
            "test_interp_rowwise",
            "time_melt_dataframe",
            "test_multiindex_columns_empty_level",
            "test_between_time",
            "df_letters",
            "test_constructor_range_based_deprecated",
            "test_series_append_aware_naive",
            "test_slicing",
            "test_duplicated",
            "test_delim_whitespace_custom_terminator",
            "data_for_sorting",
            "test_indexing_with_category",
            "test_float_index_non_scalar_assignment",
            "test_datetime_name_accessors",
            "test_read_hdf_errors",
            "assert_produces_warning",
            "test_agg_transform",
            "test_to_string_utf8_columns",
            "test_to_sql_method_multi",
            "ensure_index",
            "test_invalid_quantile_value",
            "test_duplicated_columns",
            "test_examples1",
            "test_grouped_box_return_type",
            "test_constructor_non_hashable_name",
            "_get_cells",
            "plot",
            "skip_if_no",
            "test_invalid_filtering",
            "test_constructor_spindex_dtype_scalar_broadcasts",
            "test_groupby_level_with_nas",
            "_index_name",
            "test_resample_with_timedeltas",
            "test_infer_dtype_bytes",
            "test_datetime_bin",
            "test_strip_lstrip_rstrip_mixed",
            "test_get_finder",
            "test_set_dtype_new_categories",
            "test_astype_with_view_mixed_float",
            "test_disallowed_nodes",
            "test_slice_locs_with_type_mismatch",
            "imag",
            "test_reader_closes_file",
            "test_mixed_freq_shared_ax",
            "test_to_datetime_format_YYYYMMDD",
            "determine_clipboard",
            "test_isin_empty",
            "test_set_reset_index",
            "test_date_range_unsigned_overflow_handling",
            "test_dti_shift_across_dst",
            "test_neg_numeric",
            "test_map_box",
            "test_timedeltas",
            "test_clip_types_and_nulls",
            "test_to_period",
            "test_doc_example",
            "align",
            "test_constructor_U",
            "test_usecols_with_single_byte_unicode_strings",
            "test_is_unique_interval",
            "test_loc_setitem_empty_append_raises",
            "test_nanops",
            "test_maybe_promote_bool_with_any",
            "test_timestamp_to_datetime_explicit_pytz",
            "interpolate",
            "test_does_not_convert_mixed_integer",
            "_convert_to_list_like",
            "test_getitem_fancy_2d",
            "test_pi_ops",
            "test_iloc_getitem_bool",
            "test_too_long",
            "test_select_dtypes_include_exclude_mixed_scalars_lists",
            "test_linspace_behavior",
            "validate_args_and_kwargs",
            "_process_rowsize_subheader",
            "invalidate_string_dtypes",
            "test_df_arith_2d_array_collike_broadcasts",
            "test_setitem_fancy_boolean",
            "test_to_excel_interval_no_labels",
            "test_colspecs",
            "setup_connect",
            "test_with_string_args",
            "test_shift_periods",
            "test_timetz_accessor",
            "property",
            "test_basic_regression",
            "test_is_overlapping",
            "test_series_ctor_datetime64",
            "test_type_promote_putmask",
            "_generate_multi_thread_dataframe",
            "test_reindex_fill_value",
            "test_is_strictly_monotonic_decreasing",
            "test_bar_subplots_center",
            "test_string_select",
            "test_wrap_aggregated_output_multindex",
            "test_from_records_dictlike",
            "_transform_item_by_item",
            "test_wom_len",
            "_format_axes",
            "test_constructor_maskedarray",
            "test_query_numexpr",
            "test_usecols_pass_non_existent_column",
            "time_floats_with_dt_index_lines",
            "test_reindex_indexer",
            "read_clipboard",
            "test_any_all_bool_only",
            "makeTimeDataFrame",
            "test_frame_from_json_precise_float",
            "test_constructor_positional",
            "test_concat_empty_and_non_empty_frame_regression",
            "test_schema",
            "center",
            "test_regex_replace_list_mixed",
            "test_to_datetime_format_microsecond",
            "test_getitem_dups_with_missing",
            "test_delta_to_tick",
            "test_construction_consistency",
            "test_compare_different_lengths",
            "test_groupby_sort_multi",
            "test_constructor_with_categorical_categories",
            "test_iadd_preserves_name",
            "equals",
            "test_from_frame",
            "test_legacy_datetimetz_object",
            "test_cumcount_dupe_index",
            "test_to_timestamp_to_period_astype",
            "test_parsers_timezone_minute_offsets_roundtrip",
            "test_complibs",
            "test_apply_ignore_failures",
            "test_to_excel_interval_labels",
            "rename",
            "test_all2",
            "_convert_scalar_indexer",
            "test_constructor_range",
            "test_large_series",
            "test_shift_nan",
            "test_unstack_number_of_levels_larger_than_int32",
            "test_dti_business_summary_dateutil",
            "test_read_s3_jsonl",
            "_read_new_header",
            "test_isin_nan_common_float64",
            "_on",
            "test_time_series_plot_color_kwargs",
            "test_no_exit_status_noerrors_for_validate_all",
            "is_file_like",
            "test_invalid_arguments",
            "test_groupby_groups_datetimeindex",
            "test_multiple_matches",
            "test_setitem_list_of_tuples",
            "test_east_asian_unicode_true",
            "test_subtraction_ops",
            "test_repr_max_seq_item_setting",
            "_generate_range_overflow_safe",
            "test_to_excel_float_format",
            "test_applymap_box_timestamps",
            "test_float_scalar_comparison",
            "test_nth_multi_index",
            "test_combineFrame",
            "test_reindex_axis",
            "test_multilevel_preserve_name",
            "quantile",
            "test_empty_csv_input",
            "test_groupby_multiple_columns",
            "test_get_duplicates",
            "time_align",
            "time_dup_seconds_and_unit",
            "test_fails_not",
            "test_to_dict_box_scalars",
            "test_to_excel_styleconverter",
            "time_series_string",
            "test_datetimeindex",
            "test_custom_grouper",
            "test_sniff_delimiter",
            "test_is_lexsorted",
            "test_insert_index_datetimes",
            "test_categorical_series_repr_period",
            "_enable_data_resource_formatter",
            "test_reduce_invalid",
            "test_nunique_preserves_column_level_names",
            "test_rolling_apply_with_pandas_objects",
            "test_from_tzaware_mixed_object_array",
            "test_setitem_fancy_1d",
            "infer_dtype_from_scalar",
            "test_constructor_dtype_list_data",
            "test_replace_invalid_kwarg",
            "_join_by_hand",
            "test_labels_deprecated",
            "test_conversion_float",
            "test_axis",
            "test_list_like_indexing",
            "test_sheets",
            "_cast_sparse_series_op",
            "test_group_ohlc",
            "test_constructor_explicit",
            "test_datetime64_fillna",
            "test_not_subperiod",
            "test_constructor_with_stringoffset",
            "_searchsorted_monotonic",
            "test_dt64arr_series_sub_tick_DateOffset",
            "get_writer",
            "test",
            "test_unsupported_type",
            "_check_label_or_level_ambiguity",
            "test_td_sub_td",
            "_iterate_column_groupbys",
            "_read_next_page",
            "test_allow_cmap",
            "test_multiindex_perf_warn",
            "time_parse_now",
            "test_construction_from_string_error_subtype",
            "test_functions_no_warnings",
            "test_parsers_iso8601_invalid",
            "test_take_preserve_name",
            "test_numpy_minmax_period",
            "test_business_freq_convert",
            "test_no_unnamed_index",
            "test_properties_annually",
            "test_rename_axis_style",
            "test_multiple_id_columns",
            "test_join_non_unique",
            "holds_integer",
            "test_combine_first_int",
            "test_hist_df",
            "test_more_than_one_ref",
            "time_merge_dataframe_integer_key",
            "compare",
            "_tables",
            "test_getitem_multi_tuple",
            "test_displayed_only",
            "test_from_codes_with_float",
            "time_datetime_field_normalize",
            "test_rank_inf",
            "test_groupby_transform_timezone_column",
            "test_ragged_min",
            "test_nonzero_single_element",
            "test_dt64arr_series_add_tick_DateOffset",
            "test_cmov_mean",
            "test_mismatched_timezone_raises",
            "_get_offset",
            "test_apply_dup_names_multi_agg",
            "test_join_multi_levels",
            "_map",
            "_get_values",
            "test_write_preserves_original",
            "test_from_dti",
            "test_update_dtype_errors",
            "test_period_cons_nat",
            "test_unsorted_index_lims",
            "test_index_groupby",
            "test_big_dates",
            "test_apply_trivial",
            "test_dataframe_dummies_prefix_sep",
            "test_is_level_reference_df_ambig",
            "test_read_hdf_open_store",
            "test_equals_op",
            "test_numeric_df_columns",
            "test_resample_ambiguous_time_bin_edge",
            "test_timezone_info",
            "test_to_html_render_links",
            "test_dateutil_tzoffset_support",
            "clean_checkout",
            "test_is_datetime_dtypes",
            "test_add_invalid",
            "test_crosstab_pass_values",
            "test_timedelta_other_units",
            "_repr_footer",
            "test_append_length0_frame",
            "test_reindex_base",
            "test_n_all_dtypes",
            "test_lookup_overflow",
            "test_set_labels_deprecated",
            "test_query_by_select_obj",
            "test_compress",
            "test_manualreset",
            "test_to_html_alignment_with_truncation",
            "test_bytes_exceed_2gb",
            "test_wide_repr_named",
            "get_pull_requests",
            "build_number_format",
            "test_iloc_getitem_labels",
            "test_take_axis_1",
            "test_single_element_ix_dont_upcast",
            "test_tuple_vars_fail_with_multiindex",
            "test_iloc_empty_list_indexer_is_ok",
            "_set_grouper",
            "test_remove_categories",
            "_assemble_from_unit_mappings",
            "test_to_csv_with_dst_transitions",
            "test_converters_no_implicit_conv",
            "test_resample_basic_from_daily",
            "test_pandas_gbq",
            "test_hist_kde_color",
            "test_between_time_axis_raises",
            "_create_missing_idx",
            "test_unstack_fill_frame_timedelta",
            "set_properties",
            "test_td64arr_div_nat_invalid",
            "_set_axis_name",
            "min",
            "qcut",
            "_flex_comp_method_FRAME",
            "test_values_consolidate",
            "time_parse_iso8601_tz",
            "test_tz_localize_ambiguous_bool",
            "test_equals_missing_values",
            "test_asfreq_mult",
            "test_multiple_date_col",
            "test_extractall_single_group",
            "test_decimals",
            "test_nat_comparison_tzawareness",
            "get_base_missing_value",
            "test_downsample_but_actually_upsampling",
            "walk",
            "test_construction_from_period",
            "_load_test3_data",
            "test_infer_compression_from_path",
            "test_unknown_attribute",
            "test_series_groupby_plotting_nominally_works",
            "test_doc_string",
            "_maybe_process_deprecations",
            "test_plot_single_color",
            "test_from_array_keeps_base",
            "test_frame_add_tz_mismatch_converts_to_utc",
            "test_double_quote",
            "_sub_period",
            "test_xs_setting_with_copy_error",
            "test_rolling_count",
            "test_frame_to_period",
            "_to_ordinalf",
            "test_asi8",
            "test_dti_ne_null_scalar",
            "test_compression_warns_when_decompress_caches_blosc",
            "time_from_components",
            "test_tab_completion",
            "test_constructor_with_nas",
            "test_binary_functions",
            "test_n_identical_values",
            "test_pivot_string_as_func",
            "_set_noconvert_columns",
            "test_from_arrays_different_lengths",
            "_adjust_binner_for_upsample",
            "test_usecols_with_unicode_strings",
            "test_to_csv_chunking",
            "test_build_series",
            "_write_body",
            "test_append_join_nondatetimeindex",
            "tips_df",
            "test_agg_dict_nested_renaming_depr",
            "test_tz_range_is_utc",
            "test_obj_none_preservation",
            "_delegate_method",
            "test_arithmetic_conversion",
            "test_constructor_cast_failure",
            "test_banklist_header",
            "test_qcut_return_intervals",
            "test_transform",
            "test_dt64arr_add_sub_period_scalar",
            "test_frame_select_complex",
            "test_unit_parser",
            "test_reduce_to_float",
            "test_asfreq_datetimeindex_empty_series",
            "length",
            "cbday_roll",
            "test_replace_preserves_nanos",
            "test_to_html_regression_GH6098",
            "test_string_indexing",
            "time_query_with_boolean_selection",
            "test_last_subset",
            "uint64_frame",
            "test_julian_round_trip",
            "test_append_multiple",
            "test_rolling_skew",
            "test_constructor_lists_to_object_dtype",
            "test_dt_accessor_no_new_attributes",
            "test_loc_non_unique",
            "testRollback1",
            "_isna_compat",
            "test_floor_and_ceil_functions_raise_error",
            "test_strl_latin1",
            "test_total_seconds_scalar",
            "test_union_noncomparable",
            "test_numpy_timedelta_scalar_indexing",
            "test_qcut_nat",
            "test_dt64arr_sub_NaT",
            "test_unnamed_columns",
            "test_dt64_overflow_masking",
            "test_datetimes",
            "_save_chunk",
            "test_is_",
            "test_dti_cmp_null_scalar_inequality",
            "test_resample_median_bug_1688",
            "time_series_dates",
            "_bool_arith_check",
            "highlight_min",
            "test_interp_limit_no_nans",
            "test_str_split",
            "test_cython_agg_frame_columns",
            "test_from_spmatrix_columns",
            "compute_expected",
            "test_all_none_exception",
            "test_dt64ser_cmp_date_invalid",
            "value_counts",
            "test_groupby_with_dst_time_change",
            "test_str_list_query_method",
            "test_loc_to_fail",
            "test_rolling_std_1obs",
            "box",
            "test_lhs_expression_subscript",
            "test_insert_missing",
            "test_constructor_copy",
            "test_loc_getitem_label_list_with_missing",
            "test_read_dta1",
            "test_mixed_index_assignment",
            "test_nan_data_with_int_dtype_raises_error",
            "test_partial_slice_second_precision",
            "test_mixed_underscores_and_spaces",
            "is_bool_indexer",
            "test_pairwise_with_other",
            "test_scientific_no_exponent",
            "test_read_dta4",
            "test_validate_inplace",
            "test_ext",
            "test_replace_with_dict_with_bool_keys",
            "na_cmp",
            "test_constructor_Series_named",
            "test_setitem_scalars_no_index",
            "test_replace_mixed",
            "test_bunched_yearends",
            "test_values_multiindex_periodindex",
            "test_astype_all",
            "test_unsupported_datetype",
            "test_sparse_pow_issue",
            "test_expanding_corr_pairwise_diff_length",
            "_join_non_unique",
            "test_select_dtypes_empty",
            "test_sort_index_multiindex",
            "test_sem",
            "test_fontsize",
            "test_maybe_mangle_lambdas_listlike",
            "test_loc_datetime_length_one",
            "arrays_for_binary_ufunc",
            "test_ngroup_respects_groupby_order",
            "test_take_mixed_numeric",
            "test_period_index_indexer",
            "test_npdiff",
            "test_remove_unused_nan",
            "test_to_latex_escape_special_chars",
            "test_no_mutate_but_looks_like",
            "write_legacy_file",
            "test_dti_union_mixed",
            "from_breaks",
            "test_margins_no_values_no_cols",
            "test_add_categories",
            "test_round_trip_preserve_multiindex_names",
            "test_dti_to_period",
            "test_empty_multi",
            "test_comparison_of_ordered_categorical_with_nan_to_scalar",
            "test_extension_array_cross_section",
            "_dtype_to_default_stata_fmt",
            "_parse_tables",
            "test_constructor_from_categorical_string",
            "_check_double_roundtrip",
            "test_series_nested",
            "test_objarr_radd_str_invalid",
            "update",
            "test_delitem_multiindex",
            "test_mixed_freq_regular_first",
            "tz",
            "test_ensure_int32",
            "test_left_merge_empty_dataframe",
            "time_multi_columns",
            "test_frame_on",
            "test_count_level_series",
            "_get_variable_labels",
            "test_to_period_tz",
            "test_take_fill_value_none_raises",
            "make_sparse",
            "test_read_nokey",
            "test_concatlike_datetimetz",
            "test_mixed_freq_lf_first",
            "test_agg_multiple_mixed_no_warning",
            "test_multifunc_select_col_integer_cols",
            "test_abs",
            "test_series_from_coo",
            "test_div_zero_inf_signs",
            "test_describe_categorical_columns",
            "test_map_tseries_indices_accsr_return_index",
            "test_agg_dict_renaming_deprecation",
            "test_pivot_dtaccessor",
            "bootstrap_plot",
            "test_groupby_boxplot_sharex",
            "test_tz",
            "test_date_range_linspacing_tz",
            "test_to_csv_quote_none",
            "test_astype_str_cast",
            "test_unstack",
            "visit_UnaryOp",
            "_get_na_rep",
            "test_regex_replace_scalar",
            "test_dup_datetime_index_plot",
            "test_resample_how_ohlc",
            "test_setitem_sequence_mismatched_length_raises",
            "test_dt64_series_add_intlike",
            "test_schema_support",
            "test_to_csv_write_to_open_file_with_newline_py3",
            "_get_label",
            "test_deprecated_to_sparse",
            "test_setops_preserve_freq",
            "test_td64arr_floordiv_int",
            "test_stable_descending_sort",
            "testSignedInt",
            "test_dti_tz_convert_trans_pos_plus_1__bug",
            "test_dataframe_numpy_labelled",
            "test_index_equal_values_less_close",
            "_get_comb_axis",
            "test_series_repr_nat",
            "test_on",
            "platform_name",
            "validate_axis_style_args",
            "_compare_other",
            "int_frame_const_col",
            "test_sort_index_intervalindex",
            "test_to_datetime_array_of_dt64s",
            "test_fillna_tzaware",
            "test_rank_mixed_frame",
            "test_weekmask_and_holidays",
            "_create_storer",
            "test_incorrect_dtype_raises",
            "test_groupby_boxplot_sharey",
            "_handle_usecols",
            "assert_bool_op_calc",
            "test_where_dt_tz_values",
            "test_trim",
            "_get_index_columns",
            "test_center_ljust_rjust",
            "test_reset_index_tz",
            "test_frame_pad_backfill_limit",
            "test_categorical_aggfunc",
            "test_corrwith_mixed_dtypes",
            "test_cummin_cummax",
            "test_dti_cmp_list",
            "test_dti_union_aware",
            "test_df_div_zero_df",
            "test_get_indexer_closed",
            "test_partial_set_empty_frame_row",
            "_is_convertible_to_index",
            "_zsqrt",
            "test_constructor_invalid_tz",
            "test_repeat_preserves_tz",
            "test_slice_integer_frame_getitem",
            "_conv",
            "test_nlargest",
            "test_tdi_sub_int",
            "test_subclass_stack_multi",
            "test_multiindex",
            "lreshape",
            "tests_datetimeindex_freq_issue",
            "test_chained_getitem_with_lists",
            "test_missing_minp_zero_variable",
            "test_comment_used",
            "_validate_dtype",
            "test_warning_case_insensitive_table_name",
            "test_ngroup_one_group",
            "test_isin_nan_common_object",
            "ensure_clean_store",
            "build_extensions",
            "test_interp_limit_area",
            "test_memory_leak",
            "_null_terminate",
            "test_nonetype_top_level_bottom_level",
            "test_iadd_string",
            "register_series_accessor",
            "test_drop_duplicates_NA",
            "test_to_json",
            "check_round_trip_frame",
            "test_resample_loffset_upsample",
            "test_nans_equal",
            "month_name",
            "test_ragged_std",
            "test_path_localpath",
            "test_tolerance_forward",
            "test_iloc_setitem_list",
            "test_duplicated_with_nas",
            "test_max_multi_index_display",
            "time_insert",
            "test_datetime_with_timezone",
            "test_groupby_agg_coercing_bools",
            "test_set_dtype_many",
            "_get_index_name",
            "_new_PeriodIndex",
            "test_python_docs_table",
            "_to_dict_of_blocks",
            "test_on_specialized_type_by_int",
            "test_setitem_cache_updating",
            "series",
            "test_from_records_to_records",
            "test_pivot_complex_aggfunc",
            "test_categorical_dtype_unsorted",
            "test_where_series",
            "test_reindex_no_type_preserve_target_empty_mi",
            "test_bootstrap_plot",
            "_generate_marginal_results",
            "test_set_index_after_mutation",
            "test_to_csv_string_array_utf8",
            "validate_take_with_convert",
            "test_pivot_with_non_observable_dropna",
            "test_tz_localize_errors_ambiguous",
            "_get_project_id",
            "test_categories_none_comparisons",
            "test_comparison_of_ordered_categorical_with_nan_to_listlike",
            "test_unicode_repr_issues",
            "test_usecols_implicit_index_col",
            "test_binary_operators",
            "test_int64_add_overflow",
            "test_list_float_complex",
            "_register_accessor",
            "test_is_datetime64_any_dtype",
            "test_concat_series_axis1",
            "_add_margins",
            "test_constructor_sparse_dtype",
            "test_assert_numpy_array_equal_class_mismatch",
            "test_api_default_format",
            "test_level_setting_resets_attributes",
            "format_dateaxis",
            "test_pi_sub_offset_array",
            "test_replace_dict_no_regex",
            "test_resample_loffset_count",
            "test_comparison_flex_basic",
            "test_indexing_unordered",
            "hash_tuples",
            "test_more_deeply_nested",
            "_maybe_dedup_names",
            "test_infer_freq_tz_transition_custom",
            "test_int64_factorize",
            "on_cols_multi",
            "_get_converter",
            "test_df_mod_zero_df",
            "test_concat_same_type",
            "setup_data",
            "test_mixed_offsets_with_native_datetime_raises",
            "test_info_repr_html",
            "test_grouped_hist_legacy",
            "test_missing_meta",
            "_clean_options",
            "test_partition_deprecation",
            "test_astype_categorical",
            "to_clipboard",
            "test_groupby_level_nonmulti",
            "_get_time_period_bins",
            "test_maybe_promote_object_with_any",
            "test_reindexing",
            "test_to_coo_text_names_text_row_levels_nosort_col_level_single",
            "test_get_unique",
            "test_qcut_include_lowest",
            "_dt_to_float_ordinal",
            "test_categorical_series_repr_timedelta_ordered",
            "test_euro_decimal",
            "test_non_contiguous",
            "nbytes",
            "test_is_bool_dtype",
            "_maybe_add_count",
            "test_write_lists_dict",
            "create_block",
            "test_operators_reverse_object",
            "create_msgpack_data",
            "test_nonetype_multiple_levels",
            "_check_generated_range",
            "time_datetime_field_year",
            "_clip_with_scalar",
            "melt",
            "test_is_scalar_builtin_nonscalars",
            "test_to_dense_preserve_name",
            "_maybe_transform_eq_ne",
            "test_infer_dtype_period",
            "test_rgb_tuple_color",
            "test_sparse_frame_pad_backfill_limit",
            "time_med_get_loc",
            "parallel_coordinates",
            "clean_interp_method",
            "test_multiindex_na_repr",
            "test_agg_relabel_non_identifier",
            "test_apply_broadcast_error",
            "test_usecols_regex_sep",
            "test_to_integer_array_dtype_keyword",
            "sequence_to_td64ns",
            "test_outer_join",
            "test_colspan_rowspan_copy_values",
            "test_setitem_callable",
            "test_to_html_with_index_names_false",
            "test_timestamp_tz_localize_nonexistent_shift",
            "test_springforward_singular",
            "simple",
            "_process_format_subheader",
            "_pprint_dict",
            "init_xsel_clipboard",
            "test_maybe_promote_datetimetz_with_na",
            "test_selection",
            "test_resample_with_only_nat",
            "time_transform_lambda_max",
            "test_regex_replace_list_obj_inplace",
            "test_complex_append",
            "test_td64arr_mul_int",
            "test_at_inside_string",
            "test_consistency_with_window",
            "test_join_level",
            "test_remove_unused_levels_large",
            "std",
            "test_default_dtype",
            "test_basic2",
            "test_pivot_table_aggfunc_dropna",
            "test_stack_multiple_bug",
            "_isna_ndarraylike",
            "test_tz_aware_asfreq",
            "dispatch_missing",
            "test_dialect",
            "skip_if_installed",
            "test_date_range_convenience_periods",
            "should_series_dispatch",
            "test_daterange_bug_456",
            "get_objs",
            "test_missing_public_nat_methods",
            "test_store_series_name",
            "test_deprecate_ok",
            "_check_expected_dtype",
            "test_string_no_dates",
            "test_rank_axis",
            "make_data",
            "test_groupby_non_arithmetic_agg_types",
            "test_expanding",
            "test_warns",
            "maybe_infer_dtype_type",
            "_is_valid_endpoint",
            "test_raise_from_object_hook",
            "test_filter_row_groups",
            "test_pi_sub_isub_offset",
            "test_constructor_no_data_index_order",
            "test_frame_invert",
            "_init_spmatrix",
            "test_dt64arr_timestamp_equality",
            "test_shift_no_freq",
            "test_concat_no_unnecessary_upcast",
            "test_how_lambda_functions",
            "test_concat_different_fill",
            "test_resample_quantile",
            "test_read_excel_blank_with_header",
            "test_partial_loc_missing",
            "test_div_int",
            "test_lag_plot",
            "test_concat_empty_series_timelike",
            "test_flat_stays_flat",
            "test_read_excel_bool_header_arg",
            "test_resample_to_timestamps",
            "test_container_shift",
            "test_combine_first",
            "test_shift_bool",
            "test_update_ctx",
            "test_query_long_float_literal",
            "test_non_sparse_raises",
            "test_invalid",
            "_get_join_indexers",
            "test_from_product_invalid_input",
            "data_for_grouping",
            "test_expand_frame_repr",
            "_make_concat_multiindex",
            "test_guess_datetime_format_with_dayfirst",
            "kurt",
            "test_expanding_axis",
            "time_mult",
            "test_series_tz_localize",
            "process_class_docstrings",
            "test_join_on_series",
            "test_constructor_invalid_frequency",
            "max",
            "test_parser",
            "test_stack_partial_multiIndex",
            "test_concat_multiple_tzs",
            "test_constructor_datetime64_tzformat",
            "generate_bins_generic",
            "test_round_dst_border_ambiguous",
            "test_complex_mixed_fixed",
            "test_constructor_dtype_str",
            "test_missing_trailing_delimiters",
            "test_where_with_one_style",
            "test_concat_same_type_invalid",
            "test_na_value_dict_multi_index",
            "read_parquet",
            "test_astype_raises",
            "test_readjson_each_chunk",
            "assert_check_nselect_boundary",
            "test_isnumeric",
            "test_grouping_string_repr",
            "test_groupby_timedelta_cython_count",
            "check_chained_cmp_op",
            "test_constructor_simple_new",
            "_get_properties",
            "git_pieces_from_vcs",
            "test_mixed_index_at_iat_loc_iloc_series",
            "_ensure_numeric",
            "_wrap_aggregated_output",
            "test_nanargmin",
            "_nanminmax",
            "_concat_same_dtype",
            "test_int_series_slicing",
            "test_loc_getitem_series",
            "test_tz_conversion_freq",
            "test_constructor_with_datetimes",
            "test_interpolate_piecewise_polynomial",
            "test_cmov_window_regular",
            "test_reindex_duplicate_target",
            "test_frame_group_ops",
            "test_from_records_lists_generator",
            "test_embedded_newline",
            "_evaluate",
            "test_disallow_python_keywords",
            "freqstr",
            "test_finder_hourly",
            "test_dti_to_pydatetime_fizedtz",
            "test_dialect_conflict_delimiter",
            "test_append_missing_cols",
            "test_constructor_error_msgs",
            "_get_exec",
            "test_rank_categorical",
            "test_groupby_function_rename",
            "test_setitem_fancy_2d",
            "check_nancomp",
            "test_stack_int_level_names",
            "test_days",
            "test_constructor_str_category",
            "test_unit_rounding",
            "test_pivot_table_categorical_observed_equal",
            "notna",
            "test_set_index_multiindexcolumns",
            "test_reindex_lvl_preserves_names_when_target_is_list_or_array",
            "test_centered_axis_validation",
            "maybe_convert_objects",
            "test_from_array",
            "_get_fill_value",
            "_get_values_tuple",
            "test_setitem_single_column_mixed",
            "_maybe_update_attributes",
            "time_reshape_pivot_time_series",
            "test_from_arrays_iterator",
            "test_large",
            "test_interp_raise_on_only_mixed",
            "test_apply_subset",
            "test_guess_datetime_format_for_array",
            "_ts_plot",
            "test_slice_float_get_set",
            "test_repr_html_mathjax",
            "time_crosstab_values",
            "test_validate_bool_kwarg_fail",
            "test_numpy_all",
            "_check_resolvers",
            "test_from_tuples",
            "test_sort2",
            "test_to_frame_dtype_fidelity",
            "generate_regular_range",
            "rename_axis",
            "test_xticklabels",
            "test_assign_multiple",
            "test_df_numeric_cmp_dt64_raises",
            "test_strobj_mode",
            "test_unsorted_index_xlim",
            "test_numeric_object_likes",
            "test_from_inferred_categories_sorts",
            "test_convert_objects_no_conversion",
            "test_dt_round",
            "test_datetime_other_units",
            "test_frame_dict_constructor_empty_series",
            "time_series_nth",
            "test_array_interface_tz",
            "test_get_loc_level",
            "test_usecols_relative_to_names2",
            "test_round_trip_equals",
            "_attempt_YYYYMMDD",
            "_preprocess_slice_or_indexer",
            "test_union_sort_other_incomparable",
            "test_fillna_tzaware_different_column",
            "test_extract_optional_groups",
            "test_update_nooverwrite",
            "test_df_arithmetic_subexpression",
            "_assert_take_fillable",
            "_write_value_label_names",
            "test_get_option",
            "test_append_frame_column_oriented",
            "test_frame_subclassing_and_slicing",
            "ydiffs",
            "test_encode_big_escape",
            "test_dropna_invalid_how_raises",
            "read",
            "test_factory",
            "test_basic_series_frame_alignment",
            "test_duplicated_keep",
            "_initialize_stacker",
            "test_fillna_series_method",
            "test_constructor_with_convert",
            "test_iter_object_try_string",
            "test_cummin",
            "test_nan_first_take_datetime",
            "test_getitem_callable",
            "style",
            "_coerce_scalar_to_timedelta_type",
            "test_loc_getitem_tuple_plus_slice",
            "test_single_quantile",
            "test_multiple_delimiters",
            "test_insert_index_object",
            "test_apply_with_reduce_empty",
            "_make_cum_function",
            "test_resample_datetime_values",
            "test_asm8",
            "test_iso8601_strings_mixed_offsets_with_naive",
            "test_getattr",
            "test_constructor_dtype_datetime64",
            "test_sparse_repr_after_set",
            "_warn_if_deprecated",
            "test_where_dups",
            "test_multiple_date_cols_int_cast",
            "test_dtype",
            "mean",
            "write_data_chunk",
            "test_join_on_fails_with_different_left_index",
            "_validate_monotonic",
            "_maybe_arg_null_out",
            "test_filter_regex_search",
            "test_interp_non_timedelta_index",
            "test_series_tz_convert_to_utc",
            "build_xlstyle",
            "test_write_index",
            "test_multiple_date_cols_chunked",
            "table_schema_cb",
            "test_values_boxed",
            "test_set_fill_value",
            "test_partition_on_supported",
            "test_depreciate_tz_and_tzinfo_in_datetime_input",
            "test_filter_unicode",
            "test_outer_join_sort",
            "test_factorized_sort",
            "test_invalid_arg",
            "test_pi_add_intarray",
            "test_minute",
            "test_sub",
            "test_sparse_bool",
            "test_auto_detect",
            "test_concat_NaT_dataframes",
            "test_dt64arr_add_td64_scalar",
            "test_mode_sortwarning",
            "test_regex_replace_dict_nested_non_first_character",
            "test_info_memory_usage_qualified",
            "test_execute",
            "test_td_add_timedelta64",
            "to_datetime",
            "time_infer_dst",
            "test_array_repr",
            "test_grouping_error_on_multidim_input",
            "test_td64arr_add_sub_tdi",
            "test_set_index_pass_multiindex",
            "_check_ax_scales",
            "between_time",
            "test_resample_categorical_data_with_timedeltaindex",
            "_get_formatted_column_labels",
            "test_asfreq_normalize",
            "floor",
            "_make_iris_table_metadata",
            "testPackFloat",
            "test_parallel_coordinates_with_sorted_labels",
            "HolidayCalendarFactory",
            "test_set_index_empty_column",
            "test_concat_categorical_ordered",
            "test_td64arr_add_timestamp",
            "test_bar_align_mid_vmin",
            "test_maybe_promote_string_with_any",
            "test_allow_exact_matches_nearest",
            "test_series_interpolate_method_values",
            "concatenate_join_units",
            "test_iat",
            "test_constructor_from_series",
            "test_frame_repr",
            "test_partial_slice_high_reso",
            "validate_multiindex",
            "test_line_plot_period_mlt_frame",
            "test_constructor_dict_of_ranges",
            "test_subplot_titles",
            "test_construction_with_ndarray",
            "test_header_multi_index_common_format_malformed1",
            "test_set_dtype_no_overlap",
            "test_isin_tuples",
            "test_no_keep_default_na_dict_na_values_diff_reprs",
            "test_nanvar_axis",
            "_onOffset",
            "test_mixed_array_comparison",
            "test_from_arrays_index_series_period",
            "test_to_sql_type_mapping",
            "test_groupby_head_tail",
            "_check_merge",
            "test_frame_getitem_multicolumn_empty_level",
            "test_to_dict_not_unique_warning",
            "test_rename_axis_none",
            "tshift",
            "test_asfreq_nat",
            "test_remove_unused_categories",
            "_test_compression_warns_when_decompress_caches",
            "is_full",
            "test_date_range_businesshour",
            "validate_minmax_axis",
            "unique",
            "visit_Attribute",
            "test_append_index",
            "test_timegrouper_with_reg_groups_freq",
            "test_dt64arr_add_sub_td64ndarray",
            "test_subclass_stack",
            "test_get_loc_tolerance_no_method_raises",
            "time_multi_count",
            "_set_option",
            "test_fillna_columns",
            "test_to_datetime_format_time",
            "test_different_nan_objects",
            "test_constructor_empty_list",
            "test_parse_dates_string",
            "is_extension_array_dtype",
            "test_str_cat",
            "test_frame_index_to_string",
            "_single_replace",
            "test_series_getitem_multiindex_xs",
            "test_bar_log",
            "test_drop_unique_and_non_unique_index",
            "_remove_whitespace",
            "test_equals_object",
            "test_contains_for_object_category",
            "test_get_loc_implicit_cast",
            "test_pop",
            "test_apply_ticks",
            "test_iloc_exceeds_bounds",
            "test_upsample_daily_business_daily",
            "assigner",
            "test_series_partial_set",
            "test_fy5253qtr_onoffset_last",
            "test_equals_op_multiindex",
            "test_read_from_py_localpath",
            "test_date_explicit_date_format",
            "test_replace_literal",
            "_map_values",
            "objects_to_td64ns",
            "test_to_datetime_list_of_integers",
            "test_from_json_to_json_table_index_and_columns",
            "git_versions_from_keywords",
            "test_comment_whitespace_delimited",
            "test_attrs",
            "time_convert_int",
            "test_apply_fill",
            "apply_standard",
            "test_comparison_protected_from_errstate",
            "test_series_fast_transform_date",
            "test_addition_ops",
            "test_column_multiindex",
            "test_df_grid_settings",
            "test_duplicate_keep_all_ties",
            "test_drop_dst_boundary",
            "test_filter_non_bool_raises",
            "test_register_by_default",
            "frame_apply",
            "test_setitem_series_datetime64tz",
            "_quarterly_finder",
            "_repr_categories_info",
            "_extend_blocks",
            "test_nan_interpolate",
            "_get_dtype",
            "test_pickle_compat_construction",
            "test_column_dups_operations",
            "test_sum_uint64_overflow",
            "test_info_shows_column_dtypes",
            "test_non_unique_moar",
            "test_tz_convert_utc_with_system_utc",
            "test_freq_offsets",
            "test_readjson_chunks_closes",
            "test_hist_layout",
            "test_join_outer",
            "test_binop_maybe_preserve_name",
            "test_np_sum",
            "test_shape",
            "test_to_datetime_format",
            "test_putmask_with_wrong_mask",
            "test_x_multiindex_values_ticks",
            "test_dups_fancy_indexing2",
            "test_quarterly_upsample",
            "test_local_syntax",
            "test_between",
            "write_multi_index",
            "test_empty",
            "time_to_sql_dataframe_column",
            "test_get_loc",
            "test_usecols_wrong_type",
            "test_finder_quarterly",
            "test_assert_numpy_array_equal_value_mismatch5",
            "test_drop_duplicates",
            "test_concatlike_datetimetz_to_object",
            "_decode_complex",
            "test_clip_against_series",
            "test_hist_colors",
            "test_quantile_axis_parameter",
            "_getitem_bool_array",
            "test_reasonable_key_error",
            "time_datetime_to_period",
            "test_merged_cell_custom_objects",
            "test_is_list_like_disallow_sets",
            "test_replace_integer_args",
            "test_math_sub",
            "end_blank_lines",
            "test_colspan_rowspan_1",
            "interp_methods_ind",
            "test_attr_wrapper",
            "test_apply_dict",
            "test_interleave",
            "test_bool_describe_in_mixed_frame",
            "test_frame_getitem_toplevel",
            "_get_time_bins",
            "add_methods",
            "test_subclassed_wide_to_long",
            "test_engineless_lookup",
            "test_constructor_floats",
            "test_alignment_non_pandas",
            "_ensure_data",
            "test_year_has_extra_week",
            "test_usecols_with_multi_byte_characters",
            "_field_accessor",
            "test_diff_axis",
            "test_astype_dispatches",
            "test_vector_resize",
            "test_to_frame_datetime_tz",
            "test_cmov_window",
            "test_escapechar",
            "get_sheet_data",
            "test_min",
            "test_hide_multiindex",
            "test_index_ctor_nat_result",
            "time_frame_sort_values_by_columns",
            "test_naive_datetimeindex_roundtrip",
            "test_subclass_unstack_multi_mixed",
            "test_reindex_preserves_tz_if_target_is_empty_list_or_array",
            "test_setitem_with_datetime_tz",
            "symmetric_difference",
            "test_empty_with_dup_column_pass_dtype_by_indexes",
            "_convert_object_array",
            "test_parr_add_sub_float_raises",
            "is_s3_url",
            "test_sparse_series_round_trip",
            "test_object_refcount_bug",
            "test_dataframe_utc_true",
            "test_astype_from_object",
            "evaluate",
            "test_from_dtype_from_float",
            "test_union_sort_other_incomparable_sort",
            "time_read_store_table_mixed",
            "create_block_manager_from_blocks",
            "test_callback",
            "conda_package_to_pip",
            "test_str_cat_special_cases",
            "test_groupby_one_row",
            "test_loc_multiindex_ints",
            "round_trip_pathlib",
            "test_where_warns",
            "test_concat_categorical_3elem_coercion",
            "_concat_sparse",
            "_consolidate",
            "test_constructor_list_of_series",
            "test_result_type",
            "test_apply_with_mixed_dtype",
            "test_summary",
            "test_options_fp",
            "test_sub_day",
            "assert_levels_dropped",
            "test_put",
            "test_df_add_flex_filled_mixed_dtypes",
            "_check_arg_length",
            "__getitem__",
            "test_read_local_jsonl",
            "test_duplicate_columns",
            "test_resample_daily_anchored",
            "test_default_handler_indirect",
            "test_operators_datetimelike_invalid",
            "test_freq_divides_end_in_nanos",
            "test_read_json_table_convert_axes_raises",
            "test_constructor_use_start_freq",
            "time_med_get_loc_warm",
            "test_rename_categories_series",
            "test_bool_flex_frame",
            "test_dti_constructor_small_int",
            "test_range_slice_outofbounds",
            "test_validate_median_initial",
            "to_msgpack",
            "_parse_thead_tr",
            "set_timezone",
            "test_fillna_period",
            "test_to_string_line_width_no_index",
            "test_resample_weekly_bug_1726",
            "test_loc_non_unique_memory_error",
            "test_parser_error_on_empty_header_row",
            "_compare_with_tz",
            "test_nunique_with_timegrouper_and_nat",
            "_interleaved_dtype",
            "test_repr_missing",
            "_getitem_frame",
            "test_write_variable_labels",
            "test_default_left_closed_label",
            "test_argmin_argmax",
            "_init_mgr",
            "test_chained_cmp_op",
            "test_pi_cmp_nat_mismatched_freq_raises",
            "ftypes",
            "test_merge_incompat_dtypes_are_ok",
            "test_dt64arr_sub_dtscalar",
            "test_floor_division",
            "test_constructor_numeric",
            "get_freq",
            "test_iloc_integer_locations",
            "test_xs_level_series_slice_not_implemented",
            "test_to_csv_quotechar",
            "test_astype_float",
            "test_empty_with_mangled_column_pass_dtype_by_names",
            "test_display_subset",
            "time_pivot_table_categorical_observed",
            "test_constructor_tz_or_tzinfo",
            "test_quantile_interpolation_datetime",
            "test_get_slice",
            "test_non_monotonic_reindex_methods",
            "test_setitem_frame_align",
            "test_plot_multiple_inferred_freq",
            "should_warn",
            "test_alignment",
            "test_isin_empty_datetimelike",
            "test_get_loc_outside_tolerance_raises",
            "test_groupby_groups_datetimeindex_tz",
            "strides",
            "test_constructor_dict_datetime64_index",
            "test_from_records_len0_with_columns",
            "test_concat_keys_and_levels",
            "test_ix_get_set_consistency",
            "test_series_ctor_plus_datetimeindex",
            "test_header_inferred_from_rows_with_only_th",
            "_combine_hash_arrays",
            "_sub_datetimelike_scalar",
            "test_isin_level_kwarg_bad_label_raises",
            "test_empty_df_expanding",
            "test_mask_callable",
            "test_unbalanced_quoting",
            "test_rolling_corr_pairwise",
            "test_groupby_cumprod",
            "test_tdi_ops_attributes",
            "test_frame_equal_columns_mismatch",
            "test_block_names",
            "test_labels_dtypes",
            "test_dti_constructor_preserve_dti_freq",
            "test_concat_different_extension_dtypes_upcasts",
            "test_agg_python_multiindex",
            "validate_rolling_func",
            "test_no_reference_cycle",
            "test_to_html_no_index_max_rows",
            "_sparse_series_to_coo",
            "test_constructor_sequence",
            "test_search_sorted_datetime64_scalar",
            "test_to_csv_multiindex",
            "test_round_subsecond",
            "test_nancorr",
            "test_resample_how_method",
            "nanprod",
            "test_tuples_with_name_string",
            "test_frame_indexing_single",
            "test_concatlike_datetimetz_short",
            "_normalize_keyword_aggregation",
            "test_reset_option_all",
            "test_rename_bug2",
            "test_order_without_freq",
            "test_from_records_with_index_data",
            "test_categorical_ordered_none_deprecated",
            "test_to_integer_array_float",
            "test_sort_index_nan",
            "time_scalar_function_multi_col",
            "_is_label_reference",
            "test_to_string_ascii_error",
            "test_convert_numeric_uint64",
            "_series_and_frame",
            "test_invalid_encoding",
            "time_searchsorted",
            "test_astype_str",
            "test_overlapping_datetime",
            "test_comment_skiprows_header",
            "test_frame_getitem_simple_key_error",
            "_get_version",
            "_create_table_setup",
            "test_where_index_datetimetz",
            "test_loc_with_slices",
            "test_tdi_add_dt64_array",
            "test_plot_offset_freq",
            "test_unstack_mixed_extension_types",
            "test_dst_transitions",
            "test_constructor_from_index_series_datetimetz",
            "test_mode_single",
            "test_add_matplotlib_datetime64",
            "test_shallow_copy_empty",
            "test_groupby_categorical_index_and_columns",
            "test_read_column",
            "test_drop_api_equivalence",
            "_filter_usecols",
            "test_raise_when_saving_timezones",
            "test_extract_expand_None",
            "_get_options_with_defaults",
            "get_validation_data",
            "_add_logical_methods_disabled",
            "test_raise_on_drop_duplicate_index",
            "test_index_cast_datetime64_other_units",
            "_convert_slice_indexer",
            "test_merge_datetime_index",
            "test_fillna_datetime64",
            "test_plot_scatter_with_c",
            "epochs",
            "test_invalid_raises",
            "rindex",
            "test_day_not_in_month_coerce",
            "test_constructor_dict",
            "test_sort_datetimelike",
            "_record_count",
            "test_highlight_null",
            "test_case_insensitive",
            "time_exact",
            "is_datetimetz",
            "test_apply_convert_objects",
            "_load_raw_sql",
            "test_to_datetime_with_non_exact",
            "_test_offset",
            "test_valid",
            "salaries_table",
            "set_atom_categorical",
            "test_transform_numeric_to_boolean",
            "test_pairlist",
            "test_concat_invalid_first_argument",
            "test_set_properties",
            "test_subdays",
            "test_xs_level0",
            "test_spam",
            "test_timestamp_add_timedelta_push_over_dst_boundary",
            "test_repr",
            "_pipe",
            "test_maybe_promote_any_numpy_dtype_with_na",
            "test_with_datetimelikes",
            "assert_extension_array_equal",
            "_step",
            "test_reindex_signature",
            "test_resample_frame_basic",
            "configure_tests",
            "_indicator_post_merge",
            "test_loffset_returns_datetimeindex",
            "_na_value",
            "test_groupby_with_small_elem",
            "test_groupby_agg_ohlc_non_first",
            "extended_summary",
            "test_no_keep_default_na_dict_na_scalar_values",
            "test_full_outer_join",
            "test_sort_index_reorder_on_ops",
            "test_iterator_read_too_much",
            "test_td_div_timedeltalike_scalar",
            "test_to_excel_output_encoding",
            "test_nth",
            "_to_sql_replace",
            "_parse_tbody_tr",
            "test_str_cat_name",
            "_maybe_cache",
            "test_empty_with_dup_column_pass_dtype_by_indexes_raises",
            "test_concat_series_axis1_same_names_ignore_index",
            "test_get_loc_raises_missized_tolerance",
            "classmethod",
            "_ensure_valid_index",
            "union",
            "test_cython_inner_join",
            "_get_index_factory",
            "test_td_constructor_value_error",
            "assert_index_equal",
            "test_categorical_index_preserver",
            "test_loc_slice_index_fill_value",
            "_try_coerce_result",
            "get_formatted_cells",
            "test_frame_datetime64_mixed_index_ctor_1681",
            "test_from_records_with_datetimes",
            "is_named_tuple",
            "_ensure_arraylike",
            "_repr_categories",
            "test_tz_localize_ambiguous_compat",
            "test_corrwith",
            "test_filter_out_all_groups_in_df",
            "test_date_format_series",
            "_import_deprmod",
            "test_copy_in_constructor",
            "_get_setitem_indexer",
            "test_bin16",
            "test_per_axis_per_level_getitem",
            "register_vcs_handler",
            "test_compare_2000",
            "float_frame_fill0_dense",
            "test_show_dimensions",
            "test_numeric_compat",
            "_indicator_pre_merge",
            "testIgnoreUnicodeErrors",
            "test_issue124",
            "test_resample_with_dst_time_change",
            "test_join_multi_empty_frames",
            "test_truncate",
            "test_string_slice_out_of_bounds",
            "test_interp_limit_direction",
            "test_between_time_formats",
            "test_loc_setitem_with_scalar_index",
            "test_constructor_dtype",
            "remove",
            "test_getitem_numeric_column_names",
            "test_maybe_convert_numeric_infinities",
            "np_array_datetime64_compat",
            "test_resample_same_freq",
            "test_correct_type_nested_array",
            "test_overflow_offset_raises",
            "ts",
            "test_append_preserve_index_name",
            "_try_convert_to_date",
            "test_sparse_mixed",
            "test_getitem_boolean_casting",
            "validate_dtype_freq",
            "_aggregate_multiple_funcs",
            "test_setitem_loc_scalar_mixed",
            "test_elementwise_comparison_warning",
            "test_convert_pandas_type_to_json_period_range",
            "get_locales",
            "test_invalid_engine",
            "construct_1d_arraylike_from_scalar",
            "test_combine_first_mixed",
            "test_nested_dict_frame_constructor",
            "test_update_ctx_flatten_multi",
            "test_is_scalar_numpy_array_scalars",
            "test_multi_index",
            "test_non_reducing_slice",
            "test_skiprows_xrange",
            "test_replace_tzinfo_equiv_tz_localize_none",
            "test_dt64arr_add_sub_DateOffset",
            "test_numpy_repeat",
            "test_getitem_ix_boolean_duplicates_multiple",
            "test_multiples",
            "_homogenize",
            "test_isin_against_series",
            "test_complex_raises",
            "bfill",
            "test_reset_index_with_datetimeindex_cols",
            "convert_values",
            "test_get_indexer_errors",
            "test_consolidate",
            "test_rank_signature",
            "time_series_describe",
            "test_pi_add_iadd_timedeltalike_daily",
            "test_intersect_equal_sort_true",
            "test_fake_inferred_business",
            "test_read_chunks_115",
            "test_constructor_name_hashable",
            "test_cant_or_shouldnt_cast",
            "test_astype_datetime",
            "test_non_reducing_slice_on_multiindex",
            "test_to_string_float_format_no_fixed_width",
            "_get_subplots",
            "test_difference_base",
            "test_get_X_columns",
            "test_td_floordiv_invalid_scalar",
            "_roundtrip",
            "test_bar_colors",
            "_td_array_cmp",
            "format_percentiles",
            "test_groupby_empty",
            "test_constructor_dtype_and_others_raises",
            "_check_setitem_copy",
            "test_multiindex_label_slicing_with_negative_step",
            "is_integer_dtype",
            "test_bar_ignore_index",
            "_aggregate",
            "test_int64_overflow",
            "test_extract_expand_unspecified",
            "test_first_last_nth",
            "test_inplace_ops_identity",
            "test_modify_values",
            "test_to_string_small_float_values",
            "test_repr_non_interactive",
            "test_merge_on_nans",
            "test_pad",
            "as_blocks",
            "test_mode_category",
            "test_with_duplicates",
            "test_quantile_invalid",
            "test_encode_array_in_array",
            "test_bar_stacked_center",
            "test_multiple_date_cols_with_header",
            "test_td64arr_add_timedeltalike",
            "test_series_indexing_single",
            "test_intersection_bug_1708",
            "time_write_hdf",
            "_monthly_finder",
            "test_full_format_converters",
            "test_equals_multi",
            "to_julian_date",
            "test_resample_float_base",
            "test_merge_non_unique_indexes",
            "test_left_merge_na_buglet",
            "asobject",
            "test_dti_custom_business_summary_pytz",
            "test_mixed_index_no_fallback",
            "test_to_html_truncation_index_false_max_rows",
            "_is_business_daily",
            "test_union_categorical_same_category",
            "test_cython_left_outer_join",
            "test_to_numpy_dtype",
            "test_insert_index_period",
            "test_constructor_unwraps_index",
            "test_out_of_range_float",
            "test_expanding_apply",
            "test_select_filter_corner",
            "test_get_loc_raises_object_nearest",
            "wide_to_long",
            "exception_matches",
            "test_transform_mixed_type",
            "test_thousands_macau_index_col",
            "test_walk",
            "test_concat_multiindex_rangeindex",
            "test_plot_fails_with_dupe_color_and_style",
            "read_excel",
            "test_demo",
            "test_where_datetime",
            "test_reset_option",
            "test_preserve_categories",
            "test_decons",
            "_build_option_description",
            "test_resample_with_pytz",
            "test_first_row_bom",
            "test_rolling_quantile_param",
            "test_quantile_axis_mixed",
            "test_pivot_integer_columns",
            "test_cmov_window_regular_missing_data",
            "_assert_setitem_series_conversion",
            "test_invalid_columns",
            "test_legacy_table_read_py2",
            "mode",
            "set_locs",
            "test_subplots_layout",
            "test_other_type_raises",
            "test_date_range_ambiguous_arguments",
            "_combine_match_index",
            "default_units",
            "test_cummax_timedelta64",
            "test_constructor_list_of_tuples",
            "test_grouped_plot_fignums",
            "test_ufunc_multiple_return_values",
            "test_is_timedelta",
            "test_construction_with_nat_and_tzlocal",
            "test_groupby_level_apply",
            "_read_page_header",
            "test_view_tz",
            "test_deprecated_dense_to_sparse",
            "test_split_with_name",
            "test_append_with_strings",
            "test_stubs",
            "test_int_indexing",
            "test_to_latex_multiindex_empty_name",
            "test_block_shape",
            "_insert_inaxis_grouper_inplace",
            "test_bad_docstrings",
            "test_dt_round_tz_nonexistent",
            "html_encoding_file",
            "test_line_plot_period_mlt_series",
            "test_bar_align_mid_vmin_vmax_wide",
            "test_divmod_zero",
            "_concat_datetime",
            "_prepare_categoricals",
            "backfill",
            "test_preserve_timedeltaindex_type",
            "test_argsort",
            "test_bar_user_colors",
            "test_getitem_partial_column_select",
            "test_get_standard_colors_random_seed",
            "_wrap_result",
            "str_get_dummies",
            "test_frame_from_json_to_json",
            "test_upsample_apply_functions",
            "test_rolling_quantile_np_percentile",
            "_assert_fillna_conversion",
            "_pprint_seq",
            "_resolve_name",
            "test_to_string",
            "test_multiindex_with_columns",
            "test_getitem_fancy_boolean",
            "test_duplicate_mi",
            "test_numpy_transpose",
            "_align_method_FRAME",
            "test_getitem_group_select",
            "test_frame_pos",
            "test_duplicate_ref_loc_failure",
            "ignore_xlrd_time_clock_warning",
            "test_rank_int",
            "test_truncated_float_support",
            "num_summary_lines",
            "test_constructor_with_generator",
            "test_duplicates_on_starter_columns",
            "test_getitem_ix_float_duplicates",
            "test_ensure_copied_data",
            "test_next",
            "test_drop_duplicates_metadata",
            "test_join_with_len0",
            "test_reduce_mixed_frame",
            "test_constructor_dict_nan_key",
            "check_cases",
            "test_mock_clipboard",
            "test_no_version_raises",
            "test_from_arrays_index_datetimelike_mixed",
            "test_series_truncate_datetimeindex_tz",
            "test_memorial_day",
            "test_resample_count",
            "test_make_block_same_class",
            "test_anchor_week_end_time",
            "test_categorical_repr_datetime",
            "test_secondary_upsample",
            "test_matplotlib_scatter_datetime64",
            "checked_add_with_arr",
            "test_index_col_named2",
            "time_find",
            "components",
            "test_no_values_attribute",
            "_get_cython_type_upcast",
            "test_justify",
            "string_series",
            "test_convert_json_field_to_pandas_type_raises",
            "test_ground_truth",
            "test_is_complex_dtype",
            "test_range_tz_pytz",
            "test_pi_add_sub_td64_array_non_tick_raises",
            "test_date_conversion_overflow",
            "test_construct_from_string_fill_value_raises",
            "_coerce_values",
            "infer_objects",
            "clean_fill_method",
            "test_getitem_pop_assign_name",
            "connect",
            "indexer_between_time",
            "ensure_clean",
            "test_iloc_frame",
            "test_bytes_io_input",
            "test_reindex_methods_nearest_special",
            "test_constructor_dtype_copy",
            "test_dti_tz_convert_to_utc",
            "test_read_inline_jsonl",
            "test_corr_nooverlap",
            "test_cumsum",
            "test_clip_against_unordered_columns",
            "test_coerce_of_invalid_datetimes",
            "test_to_integer_array_bool",
            "test_series_nat_conversion",
            "test_multi_line_expression_callable_local_variable_with_kwargs",
            "_join_monotonic",
            "add_tmp",
            "pa",
            "test_ops_np_scalar",
            "test_secondary_y_ts",
            "test_update_filtered",
            "test_to_html_multiindex",
            "time_read_sql_table_parse_dates",
            "test_foobar_skip",
            "_get_varlist",
            "test_negative_ordinals",
            "reset_index",
            "test_small_year_parsing",
            "test_groupby_count_dateparseerror",
            "test_equals_range",
            "test_missing_field",
            "test_series",
            "test_slice_with_zero_step_raises",
            "is_period",
            "test_insert_error_msmgs",
            "test_simple_bool_ops",
            "test_reflected_comparison_with_scalars",
            "test_sort_values",
            "test_tick_division",
            "_check_roundtrip",
            "get_locs",
            "test_set_frame_expand_regular_with_extension",
            "test_constructor_Series_named_and_columns",
            "test_astype_categorical_to_other",
            "has_non_verbose_info_repr",
            "test_astype_category_ordered_none_deprecated",
            "test_quantile_multi",
            "test_bad_arg_length_max_value_multiple",
            "_get_join_info",
            "test_difference_sort_incomparable_true",
            "_write_characteristics",
            "_isna_ndarraylike_old",
            "test_concat_sorts_columns",
            "test_arith_flex_series",
            "test_properties_weekly_legacy",
            "test_setitem_more",
            "test_safe_names_warning",
            "test_describe_timedelta_values",
            "test_dti_isub_int",
            "test_to_datetime_format_integer",
            "_from_fastpath",
            "test_fillna_bug",
            "test_slice_locs",
            "test_print",
            "test_read_procedure",
            "test_cython_agg_nothing_to_agg_with_dates",
            "test_vectorized_offset_addition",
            "test_frame_equal_unicode",
            "test_onOffset",
            "test_mixed_freq_regular_first_df",
            "test_uneven_lines_with_usecols",
            "test_dti_cmp_str",
            "test_usecols_with_parse_dates",
            "test_reindex_datetimeindexes_tz_naive_and_aware",
            "test_getitem_multi",
            "test_from_records_sequencelike",
            "test_apply_bad_return",
            "_unconvert_index_legacy",
            "test_to_dict_wide",
            "test_cumcount",
            "test_plain_axes",
            "test_compare_hour13",
            "test_subplots_dup_columns",
            "test_wrap_agg_out",
            "test_precision",
            "test_dataframe_duplicate_column_names",
            "test_ser_div_ser",
            "seed_df",
            "_expand_axes",
            "test_crosstab_normalize",
            "test_background_gradient_axis",
            "test_median_duplicate_columns",
            "test_find",
            "test_dt64tz_setitem_does_not_mutate_dti",
            "test_interp_various",
            "test_count_with_only_nans_in_first_group",
            "test_value_counts_unique",
            "test_itertuples",
            "test_partial_set",
            "test_factorize",
            "test_setitem_ndarray_1d",
            "test_intersect_str_dates",
            "test_string_slice_get_syntax",
            "test_parr_sub_pi_mismatched_freq",
            "test_to_latex_decimal",
            "delete",
            "test_mixed_integer_from_list",
            "test_tdi_rmul_arraylike",
            "next_bday",
            "_is_unorderable_exception",
            "test_range_tz_dateutil",
            "all_data",
            "test_2d_fill_nonna",
            "result_index",
            "test_with_dictlike_columns",
            "_stata_elapsed_date_to_datetime_vec",
            "test_dti_tz_convert_tzlocal",
            "test_math_add",
            "_can_hold_element",
            "test_is_sequence",
            "test_divmod_scalar",
            "test_comment_skiprows",
            "_reset_option",
            "test_series_groupby_value_counts",
            "test_constructor_with_embedded_frames",
            "test_none_coercion_mixed_dtypes",
            "test_dataframe_dummies_mix_default",
            "test_dataframe_dummies_all_obj",
            "test_empty_index_name_doesnt_display",
            "test_arithmetic_overflow",
            "test_getitem_setitem_boolean_misaligned",
            "test_full_file_with_spaces_and_missing",
            "test_to_string_dtype",
            "test_axis_share_xy",
            "test_set_index_raise_on_len",
            "test_constructor_nonhashable_names",
            "test_ops_consistency_on_empty",
            "_add_numeric_methods_disabled",
            "set_index",
            "_is_scalar_access",
            "test_parse_public_s3_bucket_nrows",
            "test_exit_status_for_validate_one",
            "test_pytables_native2_read",
            "_parse_tfoot_tr",
            "clean",
            "test_iterator_loop",
            "time_to_datetime_dayfirst",
            "test_column_dups_indexing",
            "test_to_datetime_iso8601_noleading_0s",
            "from_custom_template",
            "test_from_to_scipy",
            "test_stable_categorial",
            "test_groupsort_indexer",
            "time_join_dataframe_index_single_key_bigger",
            "test_rsplit_to_multiindex_expand",
            "test_dtypes_gh8722",
            "test_one_level_deep_flattens",
            "test_constructor_rec",
            "test_nan_selection_bug_4858",
            "test_agg_list_like_func",
            "test_union_categorical_unwrap",
            "run_arithmetic",
            "test_series_unnamed",
            "test_qcut",
            "test_series_partial_set_datetime",
            "test_convert_array_of_periods",
            "time_frame_drop_dups",
            "_skip_if_no_project_id",
            "test_frame_reset_index",
            "test_good_functions",
            "infer_freq",
            "test_timedelta_hash_equality",
            "test_ufunc_coercions",
            "test_plot",
            "test_tolerance_nearest",
            "test_constructor_cant_cast_period",
            "test_sort_non_lexsorted",
            "_convert_index",
            "_get_skiprows",
            "test_to_string_repr_unicode",
            "_check_file_or_buffer",
            "test_dt64ser_sub_datetime_dtype",
            "test_ops_error_str",
            "compare_index_period",
            "test_groupby_name_propagation",
            "test_header_with_index_col",
            "test_to_datetime_parse_timezone_keeps_name",
            "test_double_precision",
            "test_datetime_cut",
            "create_data",
            "test_pyarrow",
            "test_setindex",
            "test_groupby_aggregation_mixed_dtype",
            "test_isin_with_string_scalar",
            "test_value_vars",
            "test_combine_first_period",
            "_is_label_like",
            "test_convert_preserve_bool",
            "test_union_categoricals_ignore_order",
            "time_groupby_nosort",
            "classes_and_not_datetimelike",
            "test_to_object_array_tuples",
            "frame",
            "time_resample",
            "test_op",
            "_decode",
            "_construct",
            "_interp_limit",
            "test_categorical_no_compress",
            "test_sort_index_na_position",
            "write_to_version_file",
            "_generate_regular_range",
            "test_getitem_nat",
            "test_sorting_repr_8017",
            "test_droplevel_with_names",
            "test_concat_series_axis1_names_applied",
            "test_begin_year_alias",
            "read_block_index",
            "_is_compatible_with_other",
            "test_dict_numpy_complex",
            "test_construction_with_dtype",
            "test_deepcopy",
            "monotonic_index",
            "test_strip_lstrip_rstrip",
            "test_count_cross_type",
            "test_sort_index_level_by_name",
            "test_context",
            "visit_Assign",
            "_interleave",
            "test_integer_index_astype_datetime",
            "test_is_level_reference_series_axis1_error",
            "test_memory_map",
            "_get_take_nd_function",
            "test_map_dict_with_tuple_keys",
            "test_compare_1700",
            "_try_convert_data",
            "test_categorical_series_repr_period_ordered",
            "__repr__",
            "test_equality_invalid",
            "test_dt64arr_add_dt64ndarray_raises",
            "test_rich_comparison_with_unsupported_type",
            "test_parse_public_s3a_bucket",
            "_to_ijv",
            "test_range_tz_dst_straddle_pytz",
            "test_header_and_index_with_types",
            "test_uhf",
            "test_constructor_maskedarray_hardened",
            "test_iloc_duplicates",
            "_get_level_indexer",
            "test_sort_multi_index",
            "test_ragged_var",
            "_repr_attrs",
            "test_basic_left_by_right_by",
            "test_kde_colors_and_styles_subplots",
            "_ensure_datetimelike_to_i8",
            "test_index_col_label_error",
            "test_with_nan",
            "get_config_from_root",
            "_infer_tz_from_endpoints",
            "test_loc_str_slicing",
            "close",
            "test_astype_assignment",
            "test_implementation_limits",
            "test_float_suffix",
            "test_intercept_astype_object",
            "to_pickle",
            "test_append_misc",
            "test_align_mixed_float",
            "test_dict_float",
            "summary",
            "test_reading_all_sheets_with_blank",
            "test_maybe_promote_any_with_object",
            "test_comparison_tzawareness_compat_scalars",
            "test_categorical_index_repr_period_ordered",
            "test_tidy_repr",
            "test_constructor_dict_of_generators",
            "test_groupby_apply_all_none",
            "test_multi_iter_frame",
            "test_get_indexer_length_one",
            "test_non_unique_pickle",
            "read_stata",
            "test_rank_max_pct",
            "test_intra_day_conversion_factors",
            "test_day_not_in_month_raise",
            "_sql_type_name",
            "_get_fill_indexer_searchsorted",
            "_check_iris_loaded_frame",
            "test_margins",
            "test_basic_period_index_subscript_expression",
            "test_any_all_object",
            "test_td64arr_addsub_anchored_offset_arraylike",
            "test_lookup_basics",
            "check_reduce",
            "test_unstack_dtypes",
            "test_ufuncs_single_float",
            "test_date_range_multiplication_overflow",
            "right_df",
            "_copy",
            "test_default_fill_value_with_no_data",
            "reindex_indexer",
            "test_figsize",
            "dt64arr_cmp_non_datetime",
            "test_CategoricalAccessor_name_deprecation",
            "is_offsetlike",
            "test_getitem_ndarray_3d",
            "test_series_from_coo_incorrect_format_raises",
            "test_replace_gh5319",
            "test_pack_ext_type",
            "test_skip_rows_callable",
            "rjust",
            "test_skiprows_list",
            "test_cdaterange_weekmask_and_holidays",
            "test_concat_will_upcast",
            "object_series",
            "test_series_from_json_precise_float",
            "test_repr_chop_threshold_column_below",
            "test_read_timezone_information",
            "test_period_array_non_period_series_raies",
            "_filter_nodes",
            "_infer_fill_value",
            "test_ix_setitem_out_of_bounds_axis_0",
            "test_reindex_methods",
            "_get_format_datetime64",
            "test_setops_disallow_true",
            "test_fillna_copies",
            "test_invalid_file_not_written",
            "test_dt64_ser_cmp_date_warning",
            "test_df_mod_zero_array",
            "test_setitem_list",
            "test_aggregate_item_by_item",
            "test_tdi_shift_int",
            "test_subclass_sparse_to_frame",
            "test_rename_axis_raises",
            "test_numpy_compat",
            "test_end_year_alias",
            "test_nulls",
            "test_constructor_int_dtype_nan",
            "test_series_fillna_limit",
            "test_bool_types",
            "test_to_datetime_types",
            "test_bool_arith_expr",
            "test_bool_ops_fails_on_scalars",
            "test_color_empty_string",
            "test_numpy_any",
            "test_series_getitem_not_sorted",
            "test_astype_from_datetimelike_to_objectt",
            "test_dt_namespace_accessor_categorical",
            "test_missing_values",
            "test_stata_111",
            "test_empty_frame_dtypes_ftypes",
            "setup_import",
            "table_type_short",
            "test_header_and_one_column",
            "test_subclass_pivot",
            "test_merge_left_empty_right_empty",
            "test_to_csv_unicodewriter_quoting",
            "test_constructor_subclass_dict",
            "test_rank_desc_mix_nans_infs",
            "test_reindex_preserves_names_when_target_is_list_or_ndarray",
            "test_tz_standardize",
            "test_partial_slicing_dataframe",
            "test_skiprows_invalid",
            "_get_data_algo",
            "validate_read",
            "_validate_flavor",
            "test_dti_tz_localize_ambiguous_nat",
            "test_scalar_unary",
            "_return_parsed_timezone_results",
            "test_fillna_empty",
            "test_constructor_invalid_args",
            "_take",
            "test_upsample_sum",
            "test_mi_sparse_disabled",
            "test_numpy_func_call",
            "test_maybe_mangle_lambdas",
            "test_get_standard_colors_default_num_colors",
            "test_mixed_timedelta_datetime",
            "_get_level_lengths",
            "test_ragged_kurt",
            "take_invalid_kwargs",
            "test_arith_alignment_non_pandas_object",
            "_to_sql_save_index",
            "test_fields",
            "test_tdi_iadd_timedeltalike",
            "test_constructor_preserve_attr",
            "test_get_unique_index",
            "test_unstack_fill_frame_categorical",
            "time_subtract",
            "test_floordiv_zero",
            "test_datetime64_dtype_array_returned",
            "_slice_take_blocks_ax0",
            "where",
            "test_store_hierarchical",
            "_setitem_frame",
            "test_on_and_index",
            "_check_has_errorbars",
            "test_errorbar_with_partial_columns",
            "test_store_index_name_with_tz",
            "test_conv_minutely",
            "_zip_axes_from_type",
            "test_repr_html_long",
            "test_setitem_array",
            "rstrip",
            "_construct_axes_dict_for_slice",
            "test_grow_boundary_at_cap",
            "test_sparse_to_dense",
            "_process_subheader_pointers",
            "read_column",
            "_series",
            "_get_page_title",
            "validate_version",
            "_intersection_non_unique",
            "test_iloc_col",
            "_check_all_fields",
            "test_gzip_writing",
            "_construct_divmod_result",
            "test_tuple_categories",
            "test_consistent_format",
            "test_unstack_sparse_keyspace",
            "test_where_unsafe",
            "test_fillna_categorical_nan",
            "test_read_nrows_large",
            "test_usecols_diff_positional_int_columns_order",
            "test_is_offsetlike",
            "test_wide_repr_multiindex",
            "_combine_frame",
            "test_apply_nonuq",
            "test_as_json_table_type_bool_data",
            "test_iloc_mask",
            "test_index_ctor_infer_nat_dt_like",
            "test_td_sub_mixed_most_timedeltalike_object_dtype_array",
            "test_generated_op_names",
            "test_sub_fail",
            "test_select_as_multiple",
            "test_nanskew",
            "_get_sheet_name",
            "_partial_date_slice",
            "test_datetimeindex_from_empty_datetime64_array",
            "test_groupby_selection_with_methods",
            "_get_timestamp_range_edges",
            "test_setitem_series_object",
            "test_dt64arr_add_sub_offset_ndarray",
            "test_read_dta12",
            "test_period_cons_quarterly",
            "_read_sql_iris_named_parameter",
            "_do_convert_missing",
            "test_map_datetimetz",
            "test_construction_with_categorical_dtype",
            "test_apply_axis",
            "read_sql_query",
            "test_groupby_corner",
            "test_head_tail",
            "test_setitem_loc_scalar_multiple_homogoneous",
            "test_concat_categorical_coercion",
            "test_td_rfloordiv_invalid_scalar",
            "_make_table",
            "_is_single_block",
            "test_with_dictlike_columns_with_infer",
            "test_constructor_pi_nat",
            "test_array_hook",
            "test_transpose_object_to_tzaware_mixed_tz",
            "_convert_listlike_datetimes",
            "test_malformed_skipfooter",
            "get_engine",
            "time_read_uint64_neg_values",
            "start_time",
            "time_datetime_field_daysinmonth",
            "test_series_interpolate_intraday",
            "test_getitem_boolean_iadd",
            "test_swaplevel",
            "test_iat_fill_value",
            "test_dti_convert_datetime_list",
            "test_nanmedian",
            "method_returns_something",
            "test_append_raise",
            "test_xs_keep_level",
            "test_ngroup_dupe_index",
            "test_update_raise_on_overlap",
            "time_series_float",
            "test_pivot_integer_bug",
            "test_mixed_dtype_insert",
            "ewm",
            "_aggregate_item_by_item",
            "_indexed_same",
            "nsmallest",
            "test_neg_raises",
            "test_index_make_union",
            "test_construction_month",
            "test_valid_dt_with_missing_values",
            "test_where_align",
            "test_read_excel_multiindex",
            "test_dti_cmp_nat",
            "test_stack_unstack_preserve_names",
            "test_join_on_fails_with_different_right_index",
            "test_with_multi_index",
            "test_get_weeks",
            "test_drop_labels_or_levels_df",
            "test_date_range_span_dst_transition",
            "test_merge_copy",
            "get_kwargs_from_breaks",
            "test_str_query_method",
            "test_update_dtypes",
            "test_representation_to_series",
            "test_incorrect_type_map",
            "test_unpacker_ext_hook",
            "test_index_equal_levels_mismatch",
            "test_sas_read_no_format_or_extension",
            "test_nan_in_object_array",
            "test_quantile_interpolation_int",
            "test_excel_multindex_roundtrip",
            "__delitem__",
            "convert_missing_indexer",
            "read_query",
            "test_index_col_empty",
            "test_math_mult",
            "test_tdi_add_integer_array",
            "test_frame_non_unique_columns",
            "test_string_index_alias_tz_aware",
            "test_empty_print",
            "test_groupby_transform_with_nan_group",
            "_try_convert_to_int_index",
            "_validate",
            "TextParser",
            "test_between_time_axis",
            "test_groupby_multiindex_nat",
            "test_datetime_tz",
            "test_filter_nan_is_false",
            "time_rstrip",
            "_op_maker",
            "test_series_groupby_nunique",
            "test_constructor_infer_freq",
            "test_groupby_resample_on_api",
            "test_to_html_compat",
            "test_dt64_series_arith_overflow",
            "time_frame_drop_dups_na",
            "_make_reader",
            "test_rename_positional_named",
            "get_iterator",
            "test_plotting_with_float_index_works",
            "write_style",
            "test_ftypes",
            "test_astype_categoricaldtype_class_raises",
            "period_array",
            "test_to_latex_series",
            "resolve_name",
            "_get_handle",
            "is_monotonic",
            "test_str_max_colwidth",
            "test_unstack_level_binding",
            "test_construction_with_alt",
            "test_deprecation",
            "_put_str",
            "test_render",
            "test_concatlike_common_period",
            "test_unary_ufunc",
            "test_getitem_setitem_boolean_corner",
            "test_td64arr_add_sub_td64_nat",
            "test_pivot_tz_in_values",
            "test_no_pairwise_with_other",
            "test_series_getitem_duplicates_multiindex",
            "test_secondary_y",
            "test_float64index_slicing_bug",
            "render_templates",
            "test_illegal_names",
            "test_subtype_conversion",
            "test_mixed_string_strl",
            "first_valid_index",
            "_build_doc",
            "maybe_cast_to_datetime",
            "test_dtype_str",
            "_index_freq",
            "test_gcs_get_filepath_or_buffer",
            "test_astype_invalid_dtype",
            "test_compare_array",
            "test_nearest_upsample_with_limit",
            "test_resample_with_non_zero_base",
            "test_dti_shift_no_freq",
            "test_rename_axis_style_raises",
            "test_table_index_incompatible_dtypes",
            "test_extractall_errors",
            "test_setitem_corner2",
            "find",
            "test_tz_localize_pushes_out_of_bounds",
            "test_constructor_single_level",
            "data_repeated",
            "test_round_tzaware",
            "test_as_json_table_type_float_data",
            "is_monotonic_increasing",
            "test_constructor_broadcast_list",
            "test_on_offset",
            "test_to_datetime_with_apply",
            "test_to_datetime_coerce",
            "test_getitem_setitem_datetimeindex",
            "test_astype_object",
            "test_cdaterange_holidays",
            "test_pass_datetimeindex_to_index",
            "test_add",
            "test_valid_tolerance",
            "test_append_duplicates",
            "_convert_strls",
            "test_corrwith_kendall",
            "test_dask",
            "test_group_var_generic_1d",
            "from_dict",
            "test_to_string_length",
            "__array_wrap__",
            "test_setitem_list_not_dataframe",
            "test_frame_equal_row_order_mismatch",
            "test_first_last_valid",
            "validate_dataframe",
            "test_to_frame_resulting_column_order",
            "test_hist_no_overlap",
            "coerce_to_dtypes",
            "test_transform_function_aliases",
            "test_loc_setitem_corner",
            "test_range_closed_boundary",
            "test_split_to_dataframe",
            "test_intersection_equal_sort",
            "test_with_nested_series",
            "test_asfreq_datetimeindex",
            "test_getitem_median_slice_bug",
            "test_store_mixed",
            "masked_arith_op",
            "time_series_nth_all",
            "date_range",
            "test_read_excel_parse_dates",
            "_try_convert_dates",
            "test_replace_simple_nested_dict",
            "check_dtypes",
            "test_return_type",
            "test_arith_flex_frame_raise",
            "test_intersection_non_monotonic",
            "test_comment",
            "test_operators_frame",
            "test_copy_method",
            "swapaxes",
            "time_groupby_ordered_sort",
            "test_tolerance_float",
            "test_get_filepath_or_buffer_with_path",
            "test_min_max_empty",
            "test_basic_dtype",
            "test_join",
            "test_dti_representation",
            "test_constructor_with_win_type",
            "is_platform_linux",
            "test_dtype_coerceion",
            "meta",
            "test_bad_date_parse",
            "test_resample_extra_index_point",
            "test_years_only",
            "_dense_series_compare",
            "test_line_use_index_false",
            "test_resample_integerarray",
            "load_workbook",
            "test_apply_frame_concat_series",
            "test_ix_slicing_strings",
            "test_extractall",
            "_transform_general",
            "test_td64arr_add_sub_timestamp",
            "test_td_rfloordiv_timedeltalike_array",
            "test_transform_axis",
            "test_bar_align_left",
            "test_dt64arr_cmp_scalar_invalid",
            "test_td_add_datetimelike_scalar",
            "test_connectable_issue_example",
            "test_out_of_bounds_value",
            "test_is_strictly_monotonic_increasing",
            "test_sort_index_kind",
            "_get_marker_compat",
            "test_constructor_dict_block",
            "test_complex_across_dimensions",
            "test_groups",
            "test_resample_timegrouper",
            "test_astype_generic_timestamp_no_frequency",
            "_to_sql_append",
            "test_frame_indexing_multiple",
            "argsort",
            "_new_Index",
            "test_groupby_duplicated_column_errormsg",
            "drop",
            "test_dti_construction_ambiguous_endpoint",
            "test_excel_old_index_format",
            "test_hexbin_cmap",
            "test_pi_add_offset_n_gt1_not_divisible",
            "_get_unicode_name",
            "test_to_string_float_index",
            "test_nancorr_spearman",
            "_make_arithmetic_op",
            "test_scatter_colors",
            "test_properties_weekly",
            "test_interp_quad",
            "test_operators_timedelta64",
            "test_margins_no_values_one_row_one_col",
            "test_agg_datetimes_mixed",
            "test_cython_transform_frame",
            "test_comparisons_nat",
            "test_series_with_dtype_radd_timedelta",
            "_ensure_scope",
            "test_rsub_object",
            "pie",
            "test_no_rounding_occurs",
            "test_append_all_nans",
            "test_categorical_block_pickle",
            "test_empty_dataframe_groupby",
            "test_dti_add_intarray_non_tick",
            "test_subtraction_ops_with_tz",
            "test_loc_iloc_frame_single_dtype",
            "test_maybe_numeric_slice",
            "deprecate",
            "_write_variable_labels",
            "test_timedelta_fillna",
            "testStrictUnicodeUnpack",
            "test_neg_object",
            "test_to_timestamp_freq",
            "test_replace_with_no_overflowerror",
            "test_stack_level_name",
            "check_bool",
            "_convert_to_border",
            "test_encode_list_long_conversion",
            "test_construction_bday",
            "test_to_string_truncate_multilevel",
            "_check_axes_shape",
            "test_append_with_data_columns",
            "test_to_csv_single_level_multi_index",
            "time_no_exact",
            "test_constructor_periodindex",
            "format_timedelta_ticks",
            "test_pivot_table_dropna_categoricals",
            "test_dataframe_dummies_drop_first",
            "test_testing",
            "test_store_index_types",
            "test_concat_iterables",
            "test_encode_array_of_nested_arrays",
            "test_finder_minutely",
            "create_table_index",
            "test_applymap",
            "test_count_uses_size_on_exception",
            "test_groupby_blacklist",
            "test_pivot_duplicates",
            "_skip_if_no_scipy",
            "time_copy_overhead_single_col",
            "to_sparse",
            "test_epoch",
            "test_join_multi_levels2",
            "test_ops_frame_period",
            "test_parse_date_fields",
            "set_function_name",
            "test_transform_exclude_nuisance",
            "_get_format_timedelta64",
            "test_extension_array_labels",
            "test_sum_object",
            "test_getitem_setitem_boolean_multi",
            "get_labels_levels",
            "test_join_period_index",
            "test_mixed_comparison",
            "time_to_sql_dataframe",
            "test_constructor_dict_timedelta64_index",
            "snap",
            "test_bool_with_none",
            "test_where_unobserved_nan",
            "test_write_append_mode",
            "test_series_set_value",
            "_maybe_wrap_formatter",
            "test_groupby_max_datetime64",
            "test_banklist_url",
            "test_series_setitem",
            "test_loc_with_interval",
            "test_contiguous_mixed_data_table",
            "reorder_categories",
            "test_delete_raises",
            "check_single_invert_op",
            "time_subtract_datetimes",
            "_maybe_promote",
            "test_disallow_scalar_bool_ops",
            "test_multiindex_slice_first_level",
            "test_between_time_types",
            "test_lexsort_indexer",
            "test_stable_descending_multicolumn_sort",
            "test_empty_pass_dtype",
            "test_errorbar_timeseries",
            "test_array_i8_dtype",
            "test_nankurt",
            "test_object_factorize",
            "test_series_agg_multi_pure_python",
            "maybe_castable",
            "test_setitem_raises_incompatible_freq",
            "_is_dates_only",
            "sort_values",
            "test_categorical_index_repr_timedelta",
            "test_pandas_plots_register",
            "test_convert_pandas_type_to_json_field_int",
            "test_groupby_transform_with_datetimes",
            "test_match_findall_flags",
            "test_isin_nan_pypy",
            "test_time_series_plot_color_with_empty_kwargs",
            "test_rolling_std_neg_sqrt",
            "test_isin_df",
            "test_conv_weekly",
            "test_repr_binary_type",
            "test_modulus",
            "test_expanding_apply_args_kwargs",
            "test_bdays_and_open_boundaries",
            "test_write_missing_strings",
            "test_as_json_table_type_string_dtypes",
            "test_resolution",
            "test_iter",
            "mask_cmp_op",
            "test_loc_setitem_empty_append",
            "test_boolean_ops",
            "test_cat_on_filtered_index",
            "test_invalid_colormap",
            "test_reshaping_multi_index_categorical",
            "__sub__",
            "test_date_query_no_attribute_access",
            "test_get_offset_legacy",
            "test_missing_value_conversion",
            "test_asfreq_fillvalue",
            "test_complex_indexing_error",
            "test_read_sql_iris",
            "test_skipfooter_with_decimal",
            "time_wide_to_long_big",
            "test_groupby_groups_in_BaseGrouper",
            "test_datetime_timedelta_quantiles",
            "test_query_inplace",
            "test_invalid_unit",
            "test_get_label_or_level_values_df_ambig",
            "nanvar",
            "_convert_by",
            "test_basic_indexing",
            "test_time_overflow_for_32bit_machines",
            "test_to_string_na_rep",
            "_create_categorical",
            "test_xs_named_levels_axis_eq_1",
            "_get_footer",
            "test_addition_subtraction_preserve_frequency",
            "test_apply_use_categorical_name",
            "test_timedelta_arithmetic",
            "test_duplicated_nan_none",
            "get_hits",
            "test_non_sorted",
            "test_dti_tz_convert_compat_timestamp",
            "test_info_categorical_column",
            "test_9",
            "test_infer_types",
            "test_join_empty_bug",
            "_adjust_bin_edges",
            "test_has_duplicates_overflow",
            "test_pi_shift_ndarray",
            "_check_offsetfunc_works",
            "test_sortlevel_deterministic",
            "test_observed",
            "_write_varnames",
            "_add_numeric_methods_unary",
            "test_td64arr_sub_timedeltalike",
            "test_getitem_setitem_slice_integers",
            "test_sparse",
            "merge_asof",
            "test_range_slice_seconds",
            "test_write_multiindex",
            "test_pi_add_sub_td64_array_tick",
            "srcpath",
            "test_format_datetime_with_time",
            "test_resample_unequal_times",
            "_annual_finder",
            "test_get_label_or_level_values_series_axis0",
            "test_interp_limit_before_ends",
            "test_categorical_dtype_missing",
            "test_replace_callable",
            "any",
            "test_resample_ohlc_result",
            "skipif_32bit",
            "format_name",
            "test_join_multi_dtypes",
            "test_start_stop_table",
            "test_series_grouper",
            "test_pickle_v0_14_1",
            "_format_with_header",
            "test_nested_raises_on_local_self_reference",
            "normalize",
            "_execute_sql",
            "time_groupby_extra_cat_sort",
            "test_crosstab_single",
            "test_read_excel_squeeze",
            "test_df_add_2d_array_collike_broadcasts",
            "is_datetime64_any_dtype",
            "test_mi_sparse",
            "test_if_scatterplot_colorbars_are_next_to_parent_axes",
            "_sparse_series_op",
            "test_with_max_level",
            "_series_and_2d_ndarray",
            "test_set_option",
            "test_with_offset",
            "_get_row_repeat",
            "_has_plotted_object",
            "test_xs_missing_values_in_index",
            "test_basic_period_index_boolean_expression",
            "test_equals_categorical",
            "test_ignore_downcast_invalid_data",
            "test_regex_replace_dict_mixed",
            "test_rdivmod_invalid",
            "test_map_categorical",
            "test_concat_inner_sort",
            "test_is_hashable",
            "test_pie_nan",
            "is_numeric_dtype",
            "test_concat_dict",
            "test_simple_normalize",
            "test_compressed_urls",
            "test_properties_business",
            "test_any_all_level_axis_none_raises",
            "_gen_fill_zeros",
            "add_prefix",
            "test_count_level",
            "test_duplicated_on_empty_frame",
            "test_parse_public_s3n_bucket",
            "_format_attrs",
            "test_window_with_args",
            "test_constructor_compound_dtypes",
            "test_boolean_set_uncons",
            "test_frame_comparison",
            "test_unit_mixed",
            "test_groupby_transform_with_int",
            "test_notna",
            "_validate_for_numeric_binop",
            "test_detect_chained_assignment_warnings_filter_and_dupe_cols",
            "assert_sp_array_equal",
            "test_repr_unsortable",
            "test_set_axis_name_raises",
            "_parse_numpy",
            "to_parquet",
            "_maybe_get_mask",
            "test_dti_set_index_reindex",
            "test_stack_preserve_categorical_dtype",
            "test_set_axis_prior_to_deprecation_signature",
            "test_unknown_engine",
            "from_coo",
            "test_setitem_with_string_index",
            "create_mgr",
            "test_indexing_over_hashtable_size_cutoff",
            "test_merge_equal_cat_dtypes",
            "test_from_file",
            "test_fillna_col_reordering",
            "fetch",
            "test_td64arr_div_numeric_scalar",
            "_get_single_key",
            "test_setitem_multiindex",
            "test_abc_types",
            "test_is_scalar_pandas_scalars",
            "test_resample_nunique",
            "ensure_python_int",
            "read_sql",
            "na_value_for_dtype",
            "test_no_nonsense_name",
            "test_unicode_string_with_unicode",
            "test_int_bins_with_inf",
            "test_properties_monthly",
            "_maybe_rename_join",
            "make_block_array",
            "_decorate_axes",
            "test_insert_with_columns_dups",
            "time_pivot_table_margins",
            "test_no_new_locals",
            "setup_method",
            "test_select_iterator_many_empty_frames",
            "test_quarterly_dont_normalize",
            "_replace_booleans",
            "test_really_large_scalar",
            "test_concat_axis_parameter",
            "test_cast_1d_array_like_from_scalar_categorical",
            "test_simple_arith_ops",
            "test_value_labels_old_format",
            "_remove_empty_lines",
            "test_cmov_window_special",
            "test_maybe_indices_to_slice_right_edge",
            "test_repr_html_long_and_wide",
            "test_rename_mapper_multi",
            "test_construct_over_dst",
            "test_frame_setitem_copy_raises",
            "_check_visible",
            "_check_legend_labels",
            "test_constructor_with_tz",
            "test_sort_index_intervals",
            "test_frame_append_datetime64_col_other_units",
            "test_groupby_includes_fill_value",
            "test_make_time_series",
            "test_thead_without_tr",
            "test_contains_method",
            "test_lookup",
            "test_constructor_period_incompatible_frequency",
            "__rfloordiv__",
            "test_reset_index_with_intervals",
            "test_get_label_or_level_values_df_simple",
            "test_to_timestamp_tz_arg_dateutil_from_string",
            "test_fails_or",
            "is_string_like_dtype",
            "test_springforward_plural",
            "test_intersection_cases",
            "test_secondary_y_regular_ts_xlim",
            "_translate",
            "test_df_float_none_comparison",
            "test_at_time_axis",
            "test_objarr_add_invalid",
            "test_td64arr_sub_offset_index",
            "test_order_matters",
            "test_td_add_sub_ten_seconds",
            "test_align_series_combinations",
            "test_encode_list_conversion",
            "test_to_html_columns_arg",
            "test_sort_index_na_position_with_categories_raises",
            "test_dti_tz_localize_naive",
            "_isfinite",
            "_interpolate",
            "test_delete",
            "test_dti_tz_localize_ambiguous_infer",
            "test_to_csv_decimal",
            "test_iloc_setitem_series",
            "test_apply_modify_traceback",
            "test_all_nans",
            "set_clipboard",
            "test_ensure_index_mixed_closed_intervals",
            "cherry_pick",
            "test_from_records_empty",
            "test_dont_modify_rcParams",
            "test_exception_importable",
            "_plot",
            "_make_date_converter",
            "_plot_colorbar",
            "test_multi_iter",
            "test_max_level_with_records_path",
            "append",
            "test_subplots_warnings",
            "test_to_flat_index",
            "test_union_base",
            "rename_categories",
            "test_ts_plot_format_coord",
            "test_get_label_or_level_values_series_axis1_error",
            "test_float_series_rdiv_td64arr",
            "test_dont_clobber_name_column",
            "compute",
            "test_default_right_closed_label",
            "test_df_boolean_comparison_error",
            "test_parsers_dayfirst_yearfirst",
            "test_from_M8_structured",
            "group_info",
            "_write_to_group",
            "test_concat_different_columns_buggy",
            "test_on_float_by_int",
            "test_bday_overflow_error",
            "test_select_iterator_non_complete_8014",
            "write_tr",
            "test_concat_invalid",
            "test_join_index_mixed_overlap",
            "test_agg_relabel",
            "test_to_period_annualish",
            "test_multiple_agg_funcs",
            "get_empty_dtype_and_na",
            "test_dropIncompleteRows",
            "_merger",
            "groupings",
            "test_subclass_attr_err_propagation",
            "test_comparison_op_scalar",
            "test_resample_5minute",
            "test_with_mixed_tuples",
            "test_bad_kwarg",
            "test_shift_fill_value",
            "test_info_repr_max_cols",
            "test_constructor_generator",
            "test_ndarray_compat",
            "_rewrite_assign",
            "maybe_infer_to_datetimelike",
            "validate_groupby_func",
            "test_append_with_diff_col_name_types_raises_value_error",
            "test_format_sparse_config",
            "test_frame_select_complex2",
            "test_astype_asfreq",
            "_value_with_fmt",
            "test_unstack_period_frame",
            "test_streaming_s3_objects",
            "test_get_accessor_args",
            "test_MillisecondTimestampArithmetic",
            "test_from_categorical_dtype_categories",
            "test_to_csv_from_csv4",
            "test_namespace",
            "get_finder",
            "test_unique_datetimelike",
            "test_str_cat_all_na",
            "test_loc_index_fill_value",
            "test_integer_col_names",
            "time_cython_sum",
            "objSeries",
            "test_agg_misc",
            "test_is_datetime_or_timedelta_dtype",
            "test_dropEmptyRows",
            "test_hexbin_basic",
            "test_apply_differently_indexed",
            "_prep_binary",
            "test_groupby_resample_on_api_with_getitem",
            "test_datetimeindex_diff",
            "_compare_or_regex_search",
            "with_csv_dialect",
            "test_unbalanced",
            "_format_strings",
            "test_get_loc_raises_bad_label",
            "test_join_overlap",
            "test_timegrouper_get_group",
            "test_dt_accessor_datetime_name_accessors",
            "test_concat_with_group_keys",
            "test_from_arrays_tuples",
            "test_count_level_corner",
            "test_multi_thread_string_io_read_csv",
            "test_subclass_sparse_slice",
            "test_2",
            "test_xs_level_series_ymd",
            "get_root",
            "test_string_index_series_name_converted",
            "test_minimal_size_col",
            "hexbin",
            "_has_same_tz",
            "test_assigning_ops",
            "test_standard_colors",
            "show_row_idx_names",
            "test_offset_whole_year",
            "test_categorical_repr_timedelta",
            "time_multi_size",
            "test_scalar_non_numeric",
            "test_index_duplicate_periods",
            "assignment_not_inplace",
            "test_date_accessor",
            "test_td64arr_mul_tdscalar_invalid",
            "test_asfreq_bug",
            "test_version",
            "test_basic_names_raise",
            "test_operators_na_handling",
            "_make_plot",
            "test_series_grid_settings",
            "tests_merge_categorical_unordered_equal",
            "test_constructor_nan_dataframe",
            "test_ix_loc_consistency",
            "test_rename_errors_raises",
            "test_global_scope",
            "test_parse_failure_rewinds",
            "get_dummies",
            "test_array",
            "test_array_tz",
            "__doc__",
            "test_constructor_datetimes_with_nulls",
            "test_pipe_args",
            "test_getitem_list_periods",
            "test_onecolumn_of_integer",
            "write_legacy_msgpack",
            "test_query_default",
            "test_codes_dtypes",
            "test_map_counter",
            "test_date",
            "test_read_write_dta5",
            "test_repr_with_mi_nat",
            "test_filter_and_transform_with_non_unique_timestamp_index",
            "test_value_counts_datetime_outofbounds",
            "test_invalid_timestamp",
            "test_td64_mean",
            "test_parr_add_sub_dt64_array_raises",
            "test_rolling_kurt",
            "test_array_equivalent_str",
            "test_to_string_decimal",
            "test_constructor_mixed_tz",
            "test_loc_multi_tuple",
            "test_ragged_skew",
            "test_from_records_iterator",
            "test_assert_almost_equal_class_mismatch",
            "test_pi_ops_offset",
            "test_range_kwargs_deprecated",
            "test_string_repr_encoding",
            "test_Nanosecond",
            "test_indices_concatenation_order",
            "gen_series_formatting",
            "test_constant",
            "test_nat_parse",
            "test_ix_dup",
            "time_nsmallest_one_column",
            "boxplot_frame",
            "test_pi_sub_pi_with_nat",
            "test_nan_numeric",
            "test_write_dta6",
            "test_numexpr_builtin_raises",
            "test_astype_nan_raises",
            "test_to_datetime_infer_datetime_format_series_start_with_nans",
            "get_indexer_dict",
            "test_difference_empty_arg",
            "test_repr_html_ipython_config",
            "_calcsize",
            "test_split_to_multiindex_expand",
            "test_invalid_total_length_max_length_multiple",
            "test_rank_resets_each_group",
            "test_categorical_equality_strings",
            "test_parse_timezone",
            "visit_Call",
            "test_reindex_like",
            "test_iterrows_iso8601",
            "use_bottleneck_cb",
            "test_grouped_hist_multiple_axes",
            "test_nonnumeric_suffix",
            "test_to_csv_from_csv5",
            "validate_resampler_func",
            "test_set_axis_name_mi",
            "json_normalize",
            "test_pi_sub_isub_int",
            "_coerce_to_type",
            "test_identity_slice_returns_new_object",
            "test_api",
            "test_constructor_coverage",
            "add_ops",
            "test_other_columns",
            "_format_multirow",
            "_validate_fill_value",
            "squeeze",
            "test_groupby_multiindex_series_keys_len_equal_group_axis",
            "test_groupby_cum_skipna",
            "test_setitem",
            "_chunk_to_dataframe",
            "test_multifunc_sum_bug",
            "test_view_with_args",
            "test_td_div_numeric_scalar",
            "test_binary_ufunc_with_series",
            "test_csv_custom_parser",
            "test_fillna",
            "test_offset_deprecated",
            "time_extract",
            "test_is_string_array",
            "test_sample",
            "test_reindex_columns",
            "test_colspan_rowspan_both_not_1",
            "test_where_with_bool_data_and_other",
            "_style_to_xlwt",
            "test_empty_series_frame",
            "test_on_index_object",
            "nrows",
            "test_read_invalid_types_raises",
            "test_equality_generic",
            "test_examples3",
            "execute",
            "test_get_loc_msg",
            "time_groupby_nth_all",
            "test_roundtrip_indexlabels",
            "lines_json_df",
            "test_categorical_nans",
            "test_asof_datetime_partial",
            "test_series_getitem",
            "test_first_last_nth_dtypes",
            "_dt_array_cmp",
            "test_set_categories_many",
            "init_xclip_clipboard",
            "test_to_string_unicode_columns",
            "round",
            "all_packers_data",
            "test_resample_loffset",
            "test_pipe_tuple_error",
            "test_frame_operators",
            "test_none",
            "test_maybe_convert_objects_uint64",
            "test_astype_extension_dtypes_duplicate_col",
            "_skip_if_no_pchip",
            "test_arith_flex_zero_len_raises",
            "test_astype_mixed_type",
            "test_invalid_local_variable_reference",
            "test_delitem",
            "test_stack_multiple_out_of_bounds",
            "_sparsify",
            "test_merge_index_as_on_arg",
            "test_replace_period",
            "test_get_indexer_non_unique_with_int_and_float",
            "test_string_nas",
            "test_read_fspath_all",
            "validate_fillna_kwargs",
            "test_xlrd_version_fallback",
            "test_concat_different_columns_sort_warns",
            "test_agg_apply",
            "test_usecols_with_parse_dates_and_names",
            "test_empty_sum",
            "test_fillna_fill_value",
            "_unpickle_sparse_frame_compat",
            "test_wikipedia_states_table",
            "test_pivot_with_multiindex",
            "test_Easter",
            "_maybe_convert_timedelta",
            "_maybe_convert_usecols",
            "identical",
            "test_date_range_nat",
            "test_getitem_fancy_1d",
            "test_ngroup_empty",
            "test_latex_repr",
            "test_join_non_unique_period_index",
            "time_multiple_date",
            "_python_apply_general",
            "test_sort_values_categorical",
            "test_from_dict_columns_parameter",
            "test_inplace_mutation_resets_values",
            "test_first_subset",
            "test_getitem_partial_int",
            "test_invalid_suffixtype",
            "_get_monthly_rule",
            "_unpack_cycler",
            "test_to_datetime_on_datetime64_series",
            "test_idxmin",
            "test_fallback_success",
            "test_write_fspath_all",
            "test_from_frame_error",
            "time_write_store",
            "_validate_join_method",
            "test_imethods_with_dups",
            "test_extractall_same_as_extract_subject_index",
            "test_setitem_mask_broadcast",
            "test_set_ordered",
            "read_sql_table",
            "test_scalar_assignment",
            "test_interp_inplace",
            "timedelta_range",
            "test_ambiguous_width",
            "test_convert_objects",
            "time_on_int32",
            "test_constructor",
            "test_resample_how_callables",
            "makeUIntIndex",
            "_box_as_indexlike",
            "test_constructor_with_int_tz",
            "_start",
            "test_sort_index_duplicates",
            "test_to_period_quarterly",
            "size",
            "_putmask_smart",
            "test_pandas_dtypes",
            "test_registering_no_warning",
            "rolling",
            "test_dispatch_transform",
            "test_properties_daily",
            "test_multiple_aggregators_with_dict_api",
            "test_secondary_axis_font_size",
            "test_groupby_level_mapper",
            "test_iter_single_element",
            "assert_block_equal",
            "_agg_index",
            "test_is_number",
            "test_constructor_invalid_Z0_isostring",
            "test_aggregate_float64_no_int64",
            "test_series_add_aware_naive_raises",
            "file_filter",
            "_create_unary_method",
            "test_infer_objects_series",
            "test_replace_across_dst",
            "test_bigint_warning",
            "test_align_int",
            "_query_iterator",
            "test_reindex_preserves_type_if_target_is_empty_list_or_array",
            "testFixnum",
            "test_subclass",
            "zfill",
            "has_truncated_repr",
            "test_constructor_categorical_series",
            "test_resample_timestamp_to_period",
            "test_take2",
            "test_not_reflect_all_tables",
            "ravel",
            "test_append_different_columns_types",
            "test_period_cons_annual",
            "test_wrong_num_labels",
            "standardize_mapping",
            "test_constructor_range_dtype",
            "test_all",
            "update_dtype",
            "_get_formatted_index",
            "test_check_dtype",
            "test_agg_structs_series",
            "mask_zero_div_zero",
            "test_slice_month",
            "_load_test2_data",
            "test_dti_tz_localize_ambiguous_flags",
            "test_scalar_call_versus_list_call",
            "_get_level_values",
            "test_rename_categories",
            "test_multi_index_parse_dates",
            "test_join_indexes_and_columns_on",
            "test_replace_replacer_equals_replacement",
            "test_date_range_int64_overflow_stride_endpoint_different_signs",
            "test_to_csv_string_with_crlf",
            "test_stack_dropna",
            "test_filter_using_len",
            "test_rsplit_to_dataframe_expand",
            "_get_codes_for_values",
            "test_get_loc_scalar",
            "time_rsplit",
            "mgr",
            "test_series_tz_localize_ambiguous_bool",
            "test_transform_datetime_to_numeric",
            "test_getitem_setitem_tuple_plus_columns",
            "test_repr_max_columns_max_rows",
            "test_fillna_different_dtype",
            "time_lstrip",
            "test_eq_with_numpy_object",
            "test_float_array_different_kind",
            "test_messed_up_data",
            "test_get_loc_raises_object_tolerance",
            "test_scalar_with_mixed",
            "time_small_get_loc_warm",
            "test_create_table_index",
            "test_fillna_object",
            "_get_index_freq",
            "_get_complex_date_index",
            "test_read_excel_multiindex_empty_level",
            "test_reset_index_level",
            "test_pi_add_iadd_timedeltalike_hourly",
            "test_loc_slice_fill_value",
            "test_corrwith_index_intersection",
            "str_repeat",
            "test_set_index_names",
            "test_is_monotonic_increasing",
            "test_ops_datetimelike_align",
            "test_construction",
            "test_reindex_axis_style_raises",
            "test_sub_n_gt_1_ticks",
            "test_pow",
            "test_frame_to_dict_tz",
            "test_series_ret_bins",
            "test_tolist",
            "test_parse_date_column_with_empty_string",
            "test_is_scalar_numpy_zerodim_arrays",
            "test_conv_monthly",
            "test_drop_exception_raised",
            "test_groupby_with_single_column",
            "test_numpy_round",
            "test_slicing_doc_examples",
            "to_records",
            "test_nat_arithmetic_scalar",
            "_set_result_index_ordered",
            "test_by_int",
            "test_align_series_frame",
            "test_mixed_depth_insert",
            "test_info_repr",
            "test_repr_small",
            "versions_from_file",
            "_get_join_keys",
            "mix_abc",
            "test_to_datetime_today_now_unicode_bytes",
            "test_cr_delimited",
            "test_multi_line_expression_local_variable",
            "_reference_dates",
            "test_needs_i8_conversion",
            "test_transform_bug",
            "test_values_numeric_cols",
            "test_ewmvol",
            "_recast_datetimelike_result",
            "test_subtype_integer_errors",
            "mask",
            "test_nansem",
            "_compose",
            "test_to_datetime_utc",
            "test_to_csv",
            "test_argsort_stable",
            "test_mi_sparse_column_names",
            "test_datetime_tz_qcut",
            "test_from_csv",
            "test_apply_multikey_corner",
            "test_resample_timedelta_idempotency",
            "test_contains_with_nat",
            "time_read_csv",
            "test_merge_overlap",
            "time_encode_decode",
            "test_iloc_slice",
            "test_sharex_and_ax",
            "test_period_ops_offset",
            "test_parse_booleans",
            "validate_all",
            "test_boolean_index_empty_corner",
            "test_merge_suffix",
            "test_ewmcov_pairwise",
            "test_slice_locs_dup",
            "linkcode_resolve",
            "_remove_labels_from_axis",
            "test_numeric_only_flag",
            "test_scalar_raises",
            "test_multi_line_expression_callable_local_variable",
            "test_excel_table",
            "test_apply_attach_name",
            "test_frame_values_with_tz",
            "test_dti_tz_localize_nonexistent",
            "test_list_numpy_float_complex",
            "save",
            "test_indexing_ambiguity_bug_1678",
            "test_true_and_false_value_options",
            "test_operators_bitwise",
            "test_numpy_string_dtype",
            "test_agg_category_nansum",
            "test_tz_localize_errors_invalid_arg",
            "test_join_index_more",
            "test_basic_sort",
            "test_quantile_empty",
            "_add_series_or_dataframe_operations",
            "_akima_interpolate",
            "test_td_rfloordiv_null_scalar",
            "test_dti_eq_null_scalar",
            "_check_frame_ops",
            "test_interp_alt_scipy",
            "test_unicode_repr_level_names",
            "_join_multi",
            "test_merge_on_indexes",
            "is_null_slice",
            "take_2d_multi",
            "simple_multiindex_dataframe",
            "test_date_range_gen_error",
            "test_parse_ragged_csv",
            "_add_delta",
            "test_to_csv_no_index",
            "test_valid_allow_exact_matches",
            "_create_methods",
            "_get_data_as_items",
            "merge",
            "test_mode_timedelta",
            "test_copy",
            "m_offset",
            "test_resample_interpolate",
            "test_concat_multiindex_with_none_in_index_names",
            "_write_row_header",
            "_add_offset",
            "test_more_than_one_expression_raises",
            "maybe_cast_to_integer_array",
            "test_stack_unstack",
            "test_unicode_name_in_footer",
            "test_convert_pandas_type_to_json_field_categorical",
            "test_corrwith_spearman",
            "peakmem_int",
            "test_selection_by_datetimelike",
            "test_ctor_str_intraday",
            "test_getitem_seconds",
            "_maybe_restore_index_levels",
            "test_calendar_observance_dates",
            "compress_file",
            "test_mixed_datetime64",
            "ensure_clean_dir",
            "test_td64arr_sub_pi",
            "test_resample_segfault",
            "test_sheet_name",
            "test_datetime_tz_cut",
            "test_to_string_with_formatters_unicode",
            "plt",
            "test_kurt",
            "test_strings",
            "test_unordered_different_order_equal",
            "_try_cast_result",
            "_handle_hidden_tables",
            "test_multiple_tbody",
            "test_from_inferred_categories_dtype",
            "test_idxmin_idxmax_returns_int_types",
            "test_to_datetime_iso8601",
            "test_apply_without_aggregation",
            "_concat_categorical",
            "test_map",
            "test_as_json_table_type_bool_dtypes",
            "test_reindex_non_unique",
            "raise_assert_detail",
            "test_partition_with_name",
            "write_th",
            "test_config_prefix",
            "_is_type_compatible",
            "test_regular_min",
            "test_from_records_non_tuple",
            "fill_frame",
            "test_isin_dupe_self",
            "time_rpartition",
            "pytest_runtest_setup",
            "test_override_set_noconvert_columns",
            "test_join_right",
            "test_subclass_sparse_addition",
            "test_query_empty_string",
            "format_object_summary",
            "get_key",
            "to_dense",
            "test_constructor_not_sequence",
            "test_neg",
            "test_unit_m_y_deprecated",
            "test_merge_join_key_dtype_cast",
            "isiterable",
            "test_frame_groupby",
            "test_union",
            "test_rolling_median_resample",
            "set_atom_datetime64",
            "test_read_s3_with_hash_in_key",
            "test_skiprows_lineterminator",
            "time_multiply",
            "last_valid_index",
            "test_maybe_convert_i8_errors",
            "test_delevel_infer_dtype",
            "test_closed_uneven",
            "_join_index",
            "scatter_matrix",
            "test_resample_ohlc_dataframe",
            "_setup_dtype",
            "_workbook_class",
            "test_rolling_min_max_numeric_types",
            "_union",
            "test_iloc_getitem_frame",
            "test_get_schema_keys",
            "test_resample_groupby_with_label",
            "test_errors_param_filters_errors",
            "test_boxplot_legacy2",
            "time_format_YYYYMMDD",
            "dropna",
            "test_size",
            "test_mi_sparse_index_names",
            "_setitem_array",
            "test_fillna_preserves_tz",
            "test_reset_index_period",
            "test_header_multi_index_common_format_malformed3",
            "_get_slice_axis",
            "test_line_lim",
            "test_default_na_values",
            "test_iteritems",
            "write_td",
            "test_print_unicode_columns",
            "test_exponents_with_eng_prefix",
            "test_expanding_corr_cov",
            "search",
            "test_logical_ops_with_index",
            "test_single_backtick_variable_expr",
            "_get_ax_freq",
            "_read_strls",
            "test_td64arr_mul_numeric_scalar",
            "test_categorical_concat_gh7864",
            "is_non_overlapping_monotonic",
            "test_set_names_with_nlevel_1",
            "generate",
            "test_readjson_chunks_from_file",
            "test_datetime_likes",
            "test_where_different_freq_raises",
            "sql_schema",
            "test_to_html_truncation_index_false_max_cols",
            "test_basic_left_index",
            "test_error_iso_week_year",
            "_is_metadata_of",
            "test_works_on_valid_markup",
            "test_concat_astype_dup_col",
            "test_slice_locs_partial",
            "test_constructor_list_str_na",
            "test_precise_conversion",
            "_create_blocks",
            "test_astype_object2",
            "contains",
            "test_getitem_partial",
            "test_boolean_comparison",
            "test_date_range_timestamp_equiv_preserve_frequency",
            "asfreq",
            "test_join_on_tz_aware_datetimeindex",
            "time_setitem_period_column",
            "_any_pandas_objects",
            "form_blocks",
            "test_add_series_with_extension_array",
            "test_merge_on_periods",
            "test_non_string_na_values",
            "set_names",
            "at_time",
            "test_apply_index",
            "test_regex_replace_regex_list_to_numeric",
            "test_basic_getitem_with_labels",
            "init_klipper_clipboard",
            "_maybe_right_yaxis",
            "test_quantile",
            "test_align_mixed_int",
            "test_assert_almost_equal_edge_case_ndarrays",
            "_check_is_chained_assignment_possible",
            "test_truncate_nonsortedindex",
            "test_frame_append_datetime64_column",
            "test_line_label_none",
            "test_start_stop_fixed",
            "test_iat_setter_incompatible_assignment",
            "test_partial_set_empty_frame",
            "test_ufunc_at",
            "test_factorize_na_sentinel",
            "test_read_jsonl_unicode_chars",
            "valid",
            "current_pickle_data",
            "__sizeof__",
            "test_group_shift_with_fill_value",
            "test_pivot_table_dropna",
            "_assert_safe_casting",
            "test_logical_operators",
            "test_groupby_with_empty",
            "df_full",
            "test_to_csv_with_single_column",
            "test_partial_slice_minutely",
            "test_float_same_index",
            "test_cmp_dt64_arraylike_tznaive",
            "_get_counts_nanvar",
            "test_lookup_array",
            "test_getitem_dups",
            "test_assert_almost_equal_value_mismatch1",
            "_maybe_downcast_constants",
            "sort_index",
            "is_list_like_indexer",
            "test_getitem_sparse_column",
            "test_floordiv_div",
            "set_atom_string",
            "stack_sparse_frame",
            "test_apply_trivial_fail",
            "test_normalize_tz",
            "time_read_csv_python_engine",
            "test_setitem_change_dtype",
            "time_nsmallest_two_columns",
            "from_array",
            "test_first_raises",
            "set_atom_datetime64tz",
            "test_set_axis_name",
            "test_compare_zerodim_array",
            "test_object_series_ok",
            "time_first",
            "test_groupby_series_with_name",
            "test_fill_method_and_how_upsample",
            "test_any_datetime",
            "test_sub_period",
            "test_rolling_cov_offset",
            "test_basic_index",
            "_upsample",
            "test_filter_and_transform_with_non_unique_int_index",
            "test_tab_complete_ipython6_warning",
            "test_dti_custom_getitem",
            "test_latin_encoding",
            "test_transform_and_agg_error",
            "test_transpose_tzaware_1col_single_tz",
            "test_read_duplicate_index_explicit",
            "test_resample_across_dst",
            "test_itemsize",
            "test_numpy_array_float",
            "_replace_single",
            "convert_pandas_type_to_json_field",
            "test_per_axis_per_level_setitem",
            "test_col_level",
            "test_str_attribute",
            "test_date_col_as_index_col",
            "test_frame_join_tzaware",
            "test_categorical_shift_fill_value",
            "test_header_multi_index_common_format3",
            "_set_values",
            "test_memory_usage",
            "test_unit_with_numeric",
            "test_index_name",
            "datetime_series",
            "_set_names",
            "time_from_missing",
            "test_closed_min_max_datetime",
            "test_legend_name",
            "test_weekly_upsample",
            "test_basics_with_nan",
            "test_frame_loc_callable",
            "_convert_to_style",
            "_get_annual_rule",
            "time_transform_multi_key3",
            "test_frame_describe_tupleindex",
            "read_table",
            "recode_from_groupby",
            "test_period_with_agg",
            "test_num_string_disambiguation",
            "test_dti_tz_constructors",
            "test_plot_bar",
            "_disallow_scalar_only_bool_ops",
            "test_to_string_format_na",
            "test_nan",
            "test_dti_snap",
            "test_infer_from_tdi",
            "test_float_arithemtic",
            "test_dt64arr_add_sub_tick_DateOffset_smoke",
            "test_frame_mi_access_returns_frame",
            "test_initial_warning",
            "test_tricky_container",
            "test_different_nans_as_float64",
            "time_divide",
            "test_assign_index_sequences",
            "test_concat_mixed_objs",
            "test_set_dataframe_column_ns_dtype",
            "time_iso8601_format",
            "test_iloc_setitem_list_of_lists",
            "test_cut_read_only",
            "test_categorical_warnings_and_errors",
            "write_data",
            "_infer_columns",
            "time_groupby_extra_cat_nosort",
            "_engine",
            "test_complex_fixed",
            "test_api_mi_raises",
            "_asof_by_function",
            "test_pivot_table_with_nans",
            "test_nanosecond_resample_error",
            "test_bar_align_single_column",
            "nancov",
            "test_dti_shift_int",
            "_center_window",
            "test_single_common_level",
            "test_cummax_datetime64",
            "test_positional_take",
            "test_complex_series_error",
            "test_partial_slice_daily",
            "test_binary_ufunc_drops_series_name",
            "test_constructor_with_null",
            "test_timestamp_compare_with_early_datetime",
            "test_unary_in_array",
            "test_from_arrays_index_series_timedelta",
            "test_slice_float",
            "write_legacy_pickles",
            "validate",
            "test_take_na_empty",
            "write",
            "test_frame_align_aware",
            "test_mi_data_columns",
            "test_empty_str_methods_to_frame",
            "test_combined_up_downsampling_of_irregular",
            "test_join_utc_convert",
            "visit",
            "test_repr_mixed_big",
            "test_generate_cday",
            "test_get_loc_nan",
            "block",
            "test_int_types",
            "_parsed_string_to_bounds",
            "test_local_variable_with_in",
            "test_delitem_corner",
            "test_union_with_DatetimeIndex",
            "to_stata",
            "test_getitem_category_type",
            "test_clip_with_na_args",
            "test_concat_series_name_npscalar_tuple",
            "is_old_version",
            "test_to_datetime_YYYYMMDD",
            "test_groupby_multi_timezone",
            "test_mangle_dupe_cols_false",
            "test_subplots_ts_share_axes",
            "test_pct_change_shift_over_nas",
            "test_numeric_column_names",
            "df_duplicates",
            "test_normalize_tz_local",
            "makeDateIndex",
            "_interpolate_scipy_wrapper",
            "str_replace",
            "test_date_parser_resolution_if_not_ns",
            "_maybe_utc_convert",
            "test_join_hierarchical_mixed",
            "test_numpy_err_state_is_default",
            "test_categorical_dtype_chunksize_explicit_categories",
            "check",
            "test_inf_parsing",
            "_str_extract_noexpand",
            "test_inconsistent_return_type",
            "test_iloc_row",
            "test_minmax_tz",
            "test_indexing_with_datetimeindex_tz",
            "time_groupby_sum_booleans",
            "test_arith_series_with_array",
            "_sparse_array_op",
            "test_numpy_ufuncs_basic",
            "test_update",
            "test_join_left_sequence_non_unique_index",
            "test_max_len_string_array",
            "_missing_double",
            "test_set_levels_with_iterable",
            "get_datevalue",
            "test_interp_combo",
            "__eq__",
            "to_excel",
            "test_apply_frame_yield_constant",
            "check_nancorr_nancov_1d",
            "test_sub_datetime_compat",
            "test_dti_tz_localize_utc_conversion",
            "_assert_can_do_setop",
            "get_dtype_counts",
            "test_cummethods_bool",
            "test_get_get_value",
            "test_mixed_array_float_int",
            "_make_index",
            "time_transform_mean",
            "test_matplotlib_backend_error",
            "test_groupby_keys_same_size_as_index",
            "test_order",
            "test_categorical_nan_handling",
            "test_constructor_float32",
            "test_skiprows_ndarray",
            "set_engine_and_path",
            "test_datetimelike_frame",
            "test_timedelta_assignment",
            "test_reindex_empty_index",
            "_unpickle_matrix_compat",
            "test_rank_naoption_raises",
            "pandasSQL_builder",
            "test_constructor_error",
            "show_versions",
            "dataframe",
            "test_concat_aligned_sort",
            "_get_cython_function",
            "time_ceil",
            "_wrap_results",
            "test_tdi_iadd_int",
            "test_construction_base_constructor",
            "test_cat_accessor_api",
            "test_truncate_out_of_bounds",
            "_process_columnname_subheader",
            "test_pivot_table_margins_name_with_aggfunc_list",
            "test_rolling_min_resample",
            "_get_partial_string_timestamp_match_key",
            "test_constructor_from_categorical_with_unknown_dtype",
            "is_function_or_method",
            "from_items",
            "test_to_latex_float_format_no_fixed_width",
            "test_excel_passes_na",
            "test_readjson_chunks",
            "empty_returns",
            "test_astype_categories_deprecation_raises",
            "test_gb_apply_list_of_unequal_len_arrays",
            "replace",
            "test_to_csv_escapechar",
            "test_dataframe_categorical_with_nan",
            "_validate_names",
            "_getitem_axis",
            "reorder_arrays",
            "test_drop_level_nonunique_datetime",
            "test_categorial_assigning_ops",
            "test_bad_class",
            "check_result_type",
            "test_xs_duplicates",
            "union_categoricals",
            "test_categorical_index_repr_timedelta_ordered",
            "_evaluate_numexpr",
            "test_merge_different_column_key_names",
            "test_y_listlike",
            "get_expects",
            "to_manager",
            "test_union_freq_both_none",
            "map",
            "test_from_dict",
            "test_pindex_slice_index",
            "test_combine_first_mixed_bug",
            "test_with_duplicates_no_on",
            "test_to_timestamp_tz_arg",
            "df_ref",
            "read_sas",
            "test_groupby_preserves_sort",
            "time_datetime_field_day",
            "test_interp_scipy_basic",
            "test_df_series_secondary_legend",
            "test_frame_loc_callable_mixture",
            "stack",
            "test_raises_on_non_datetimelike_index",
            "_validate_dt64_dtype",
            "_encode_complex",
            "test_index_names_multiple_nones",
            "safe_sort",
            "_is_label_or_level_reference",
            "test_built_in_round",
            "test_constructor_arrays_and_scalars",
            "_maybe_coerce_indexer",
            "test_set_column_names_in_parameter",
            "test_get_indexer_same_categories_different_order",
            "test_reduce",
            "_parse_no_numpy",
            "test_regex_replace_list_mixed_inplace",
            "test_bar_bad_align_raises",
            "clip_upper",
            "test_as_array_datetime",
            "test__has_infs",
            "test_constructor_no_coercion",
            "test_replace_pure_bool_with_string_no_op",
            "_comp_method_FRAME",
            "test_interpolate_time_raises_for_non_timeseries",
            "test_emptylike_constructor",
            "test_stata_doc_examples",
            "test_constructor_list_of_namedtuples",
            "test_extract_expand_True",
            "test_convert_numeric_uint64_nan_values",
            "test_indexing_with_datetime_tz",
            "test_get_nan_multiple",
            "take_nd",
            "test_apply_to_empty_series",
            "_noarg_wrapper",
            "test_select_dtypes_exclude_include_using_list_like",
            "raw_frame",
            "test_to_period_microsecond",
            "test_reindex_categorical",
            "test_to_csv_sparse_dataframe",
            "test_timedelta64_ops_nat",
            "test_corr_cov_independent_index_column",
            "nontemporal_method",
            "run",
            "test_to_datetime_now",
            "test_loc_multiindex_labels",
            "test_unstack_fill_frame",
            "test_at_with_tz",
            "test_writer_117",
            "_get_suffix_prefix",
            "check_floor_division",
            "test_NaT_cast",
            "test_frame_getitem_setitem_multislice",
            "test_replace_dict_tuple_list_ordering_remains_the_same",
            "test_month_range_union_tz_pytz",
            "test_is_timedelta64_ns_dtype",
            "test_append_empty_dataframe",
            "test_read_write_dta13",
            "test_pivot_table_values_key_error",
            "check_fun_data",
            "_get_closing_time",
            "_ensure_localized",
            "test_partial_slice_doesnt_require_monotonicity",
            "test_reset_index_right_dtype",
            "test_all_invalid_plot_data",
            "test_from_index",
            "safe_import",
            "test_format_explicit",
            "test_set_dtype_nans",
            "fill_zeros",
            "make_nancomp",
            "test_equals_categoridcal_unordered",
            "test_to_html_with_id",
            "test_merge_on_int_array",
            "test_concat_NaT_dataframes_all_NaT_axis_1",
            "_convert_to_style_kwargs",
            "test_var_std",
            "test_difference_name_preservation",
            "test_expanding_cov_pairwise",
            "test_missing_required_dependency",
            "test_excel_cell_error_na",
            "indices",
            "test_very_wide_info_repr",
            "test_union_categoricals_nan",
            "test_repr_chop_threshold",
            "test_loc_getitem_frame",
            "test_categorical_categories",
            "test_hist",
            "test_to_csv_gcs",
            "_zero_out_fperr",
            "test_conv_daily",
            "test_unstack_non_unique_index_names",
            "test_get_indexer_categorical_time",
            "test_pi_sub_intarray",
            "test_subclass_unstack",
            "test_allow_exact_matches_and_tolerance_nearest",
            "test_asfreq_combined",
            "test_order_compat",
            "test_series_partial_set_with_name",
            "test_min_max",
            "test_to_sql",
            "test_cat_accessor_no_new_attributes",
            "indent",
            "test_to_string_buffer_all_unicode",
            "test_sum_inf",
            "test_dataframe_dummies_with_na",
            "test_constructor_year_and_quarter",
            "init_no_clipboard",
            "test_thousands_macau_stats",
            "_period_array_cmp",
            "test_to_dict_numeric_names",
            "test_dti_shift_tzaware",
            "test_name_error_exprs",
            "test_get_indexer_nearest_error",
            "test_operators_datetimelike_with_timezones",
            "test_nested_exception",
            "test_constructor_dict_of_iterators",
            "test_cython_transform_series",
            "_hash_categories",
            "jsonl_file",
            "max_level_test_input_data",
            "test_dropna_corner",
            "test_where_datetime_conversion",
            "test_setitem_different_unordered_raises",
            "test_na_levels",
            "test_boundary_float",
            "test_precision_finer_than_offset",
            "test_index_equal_values_mismatch",
            "time_split",
            "test_to_html_round_column_headers",
            "_is_na_fill_value",
            "append_to_multiple",
            "test_dti_tz_localize_errors_deprecation",
            "test_construction_list_tuples_nan",
            "test_temporary_table",
            "test_basic_drop_first",
            "test_set_index_custom_label_hashable_iterable",
            "test_getitem_setitem_datetime_tz_dateutil",
            "test_axis_limits",
            "to_frame",
            "test_reindex_lvl_preserves_type_if_target_is_empty_list_or_array",
            "test_multiindex_slicers_datetimelike",
            "test_setitem_with_unaligned_tz_aware_datetime_column",
            "test_usecols_str",
            "_reindex_index",
            "test_pi_ops_nat",
            "test_dataframe_categorical_ordered_observed_sort",
            "test_setitem_series_datetime64",
            "test_join_inner",
            "test_sort_index_inplace",
            "_get_merge_keys",
            "test_equals_op_multiindex_identify",
            "test_resample_consistency",
            "test_loc_getitem_dups",
            "test_to_csv_from_csv_w_some_infs",
            "test_getitem_day",
            "test_max_nan_bug",
            "get_sys_info",
            "test_create_categorical",
            "maybe_dispatch_ufunc_to_dunder_op",
            "__getattr__",
            "test_rolling_consistency",
            "test_stringify_path_pathlib",
            "test_take_bad_bounds_raises",
            "test_get_level_values_int_with_na",
            "test_constructor_tuples_datetimes",
            "test_dt64arr_iadd_timedeltalike_scalar",
            "test_crosstab_margins",
            "test_mod_timedelta64_nat",
            "test_combineFunc",
            "test_read_chunksize_with_index",
            "test_to_timestamp_pi_nat",
            "test_preserve_on_ordered_ops",
            "test_readonly_axis_blosc",
            "test_odict",
            "test_date_range_normalize",
            "test_merge_left_notempty_right_empty",
            "test_setitem_always_copy",
            "test_repr_html_float",
            "data_missing_for_sorting",
            "_create_method",
            "get_attrs",
            "test_concat_series",
            "test_non_space_filler",
            "_range_from_fields",
            "test_append_series",
            "test_dti_shift_freqs",
            "test_read_with_parse_dates_invalid_type",
            "test_area_colors",
            "_raw_hex_id",
            "float_frame_int_kind",
            "test_comment_default",
            "test_constructor_dict_order_by_values",
            "test_update_datetime_tz",
            "test_values_duplicates",
            "test_get_indexer_invalid",
            "test_aggregate_str_func",
            "from_arrays",
            "test_ngroup_mi",
            "test_map_fallthrough",
            "test_where_bug_mixed",
            "test_complex_table",
            "is_iterator",
            "test_sort_index_different_sortorder",
            "test_asfreq_near_zero_weekly",
            "test_merge_datatype_error_raises",
            "test_check_label_or_level_ambiguity_series_axis1_error",
            "test_unstack_preserve_types",
            "has_table",
            "test_union_sort_other_empty_sort",
            "test_series_set_tz_timestamp",
            "test_shift_months",
            "set_labels",
            "test_clip_mixed_numeric",
            "test_apply_no_name_column_conflict",
            "_get_numeric_engines",
            "test_empty_groups_corner",
            "_get_multiindex_indexer",
            "test_highlight_max",
            "test_constructor_scalar",
            "test_labels_out_of_bound",
            "test_dropna_tz_aware_datetime",
            "test_df_bool_mul_int",
            "test_pie_df",
            "test_frame_tz_localize",
            "test_non_callable_aggregates",
            "test_with_na_groups",
            "test_pivot_multi_values",
            "test_Minute",
            "_maybe_convert_to_int_keys",
            "get_loc_level",
            "test_take_filling_all_nan",
            "_maybe_convert_i8",
            "test_basic_types",
            "test_ndarray",
            "test_hashtable_large_sizehint",
            "is_valid_dtype_n_method",
            "test_set_index_preserve_categorical_dtype",
            "_convert_and_box_cache",
            "lag_plot",
            "test_annually_infer",
            "test_set_categories",
            "test_sort_index_level",
            "test_series_comparison_scalars",
            "test_iloc_array_not_mutating_negative_indices",
            "test_groupby_with_timezone_selection",
            "test_skip_bad_lines",
            "simple_period_range_series",
            "test_constructor_mrecarray",
            "test_order_with_freq",
            "test_dataframe_metadata",
            "test_invalid_delegation",
            "interpolate_2d",
            "_check_ne_builtin_clash",
            "_take_without_fill",
            "test_scatter_matrix_axis",
            "skip_if_np_lt",
            "test_loc_getitem_duplicates_multiindex_empty_indexer",
            "test_parsers_iso8601_leading_space",
            "test_allow_exact_matches_and_tolerance_forward",
            "test_where_unobserved_categories",
            "test_dti_timestamp_fields",
            "test_skip_sum_object_raises",
            "_cython_transform",
            "__iter__",
            "test_reopen_handle",
            "test_describe_datetime_columns",
            "test_frame_setitem_timestamp",
            "test_warn_bad_lines",
            "test_logical_compat",
            "test_categorical_index",
            "test_difference_sort",
            "test_loc_index",
            "run_frame",
            "test_date_parse_failure",
            "test_dti_sub_int",
            "test_hash_vs_equality",
            "test_hist_kwargs",
            "_make_stat_function_ddof",
            "test_datetime64_tz_fillna",
            "test_partition_index",
            "test_set_value_by_index",
            "time_read_store_table",
            "assert_sp_series_equal",
            "test_regex_replace_series_of_regexes",
            "month_roll",
            "test_iloc_getitem_multiple_items",
            "test_tseries_indices_frame",
            "test_value_counts_categorical_not_ordered",
            "select_as_multiple",
            "test_setitem_ambig",
            "test_replace_compiled_regex",
            "test_type_promotion",
            "test_skiprows_by_index_inference",
            "test_nonoverlapping_monotonic",
            "test_to_latex_longtable",
            "test_meta_parameter_not_modified",
            "test_maybe_indices_to_slice_left_edge",
            "test_infer_index_col",
            "test_update_dtype",
            "test_mul_td64arr",
            "test_td64arr_div_numeric_array",
            "test_loc_listlike",
            "test_to_latex_multiindex_names",
            "test_downsample_across_dst_weekly",
            "test_ts_area_lim",
            "test_basic_categorical",
            "test_fwf_comment",
            "test_merge_inner_join_empty",
            "test_setitem_dtype_upcast",
            "to_sql",
            "test_custom_comment_char",
            "test_apply_numeric_coercion_when_datetime",
            "test_from_spmatrix",
            "delegate_names",
            "test_set_none_nan",
            "time_match",
            "test_period_index_length",
            "test_to_datetime_format_YYYYMMDD_overflow",
            "test_gap_upsample",
            "test_bool_operators_with_nas",
            "_aggregate_series_fast",
            "test_moment_functions_zero_length_pairwise",
            "_binop",
            "test_iteration_preserves_nanoseconds",
            "test_partial_setting",
            "test_round_trip_current",
            "test_try_aggregate_non_existing_column",
            "test_compress_group_combinations",
            "test_to_json_period_index",
            "time_endswith",
            "truncate",
            "test_first_last_max_min_on_time_data",
            "test_intelligently_handle_join_key",
            "test_nunique_with_object",
            "test_invalid_origins",
            "test_scikit_learn",
            "test_convert_numeric_uint64_nan",
            "test_query_with_nested_special_character",
            "test_resample_basic",
            "test_isin_level_kwarg",
            "test_generate",
            "test_append_concat_tz_dateutil",
            "test_ewma_nan_handling",
            "buffer_put_lines",
            "test_handle_overlap_arbitrary_key",
            "test_quarterly_infer",
            "_is_boolean",
            "test_reindex_multi_categorical_time",
            "test_setitem_with_unaligned_sparse_value",
            "test_subclass_align_combinations",
            "_is_level_reference",
            "test_slice_duplicate_monotonic",
            "test_intersect",
            "take",
            "test_df_use_case",
            "test_dti_cmp_tdi_tzawareness",
            "test_crosstab_with_empties",
            "test_make_block_boundary",
            "test_where_subset_compare_with_applymap",
            "testFixRaw",
            "test_complex_mixed_table",
            "_format_labels",
            "test_fillna_categorical_raise",
            "time_string_get_loc",
            "test_pivot_table_nocols",
            "_nanpercentile_1d",
            "test_get_indexer",
            "test_blocks_compat_GH9037",
            "test_to_datetime_tz_psycopg2",
            "test_bad_arg_length_max_value_single",
            "test_dtype_on_categorical_dates",
            "test_to_html_filename",
            "test_ix_multi_take_nonint_index",
            "test_hist_df_coord",
            "parameter_mismatches",
            "test_roundtrip",
            "float_frame_fill2",
            "test_difference_type",
            "to_hierarchical",
            "test_agg_lambda_with_timezone",
            "test_cat_accessor_updates_on_inplace",
            "assert_onOffset",
            "test_query_with_unnamed_multiindex",
            "test_alias_to_unit_raises",
            "test_margin_dropna",
            "test_td64arr_div_tdlike_scalar",
            "test_int_array",
            "test_reindex_method",
            "test_write_variable_label_errors",
            "test_concat_empty_series_dtypes",
            "test_set_levels_codes_names_bad_input",
            "test_construction_from_string_errors",
            "test_categorical_nan_only_columns",
            "result",
            "test_astype_from_categorical",
            "f",
            "test_set_attribute",
            "test_resample_incompat_freq",
            "test_constructor_series",
            "test_describe",
            "_make_sorted_values_labels",
            "_take_new_index",
            "test_loc_setitem_frame",
            "test_format_integer_names",
            "test_to_coo_bad_partition_small_union",
            "test_multiindex_unique",
            "_gotitem",
            "test_size_groupby_all_null",
            "test_fwf_for_uint8",
            "interval_range",
            "test_td_from_repr_roundtrip",
            "test_to_dict_invalid_orient",
            "test_list_mixed",
            "test_read_json_table_orient_raises",
            "indexer_at_time",
            "test_misc_coverage",
            "_get_colors",
            "test_summary_deprecated",
            "test_Hour",
            "test_loc_iterable",
            "test_transpose_tzaware_2col_single_tz",
            "test_assign_dependent_old_python",
            "test_na_values",
            "test_handle_join_key_pass_array",
            "test_apply_broadcast",
            "test_crosstab_with_numpy_size",
            "test_utc_box_timestamp_and_localize",
            "test_constructor_with_dtype",
            "test_lookup_mixed",
            "unpack",
            "test_where_object",
            "isAnchored",
            "test_with_local_timezone_dateutil",
            "test_metadata_propagation_indiv",
            "test_verify_integrity_deprecated",
            "test_tz_setter_raises",
            "assert_stat_op_api",
            "test_ellipsis",
            "test_bool_array",
            "test_merge_nosort",
            "test_day_not_in_month_ignore",
            "test_datetime64formatter_hoursecond",
            "test_series_constructor_with_dtype",
            "_allow_na_ops",
            "test_quarterly_negative_ordinals",
            "test_assert_almost_equal_dict_like_object",
            "test_parr_cmp_pi_mismatched_freq_raises",
            "test_fillna_inplace",
            "index_subclass_makers_generator",
            "test_transform_select_columns",
            "_check_percentile",
            "test_div_zero",
            "test_concat_bug_2972",
            "test_value_counts_preserves_tz",
            "test_resample_bms_2752",
            "test_repr_corner",
            "test_iloc_getitem_list_int",
            "_process_parse_dates_argument",
            "test_construct_with_different_start_end_string_format",
            "visit_Compare",
            "test_conflicting_excel_engines",
            "missing_metadata",
            "highlight_max",
            "_check_comments",
            "test_assert_almost_equal_value_mismatch3",
            "test_append_sorts",
            "test_constructor_period",
            "_na_for_min_count",
            "test_combine_first_dt_tz_values",
            "time_frame_nth_any",
            "test_tolerance_tz",
            "getTimeSeriesData",
            "test_corr_sanity",
            "test_frame",
            "in_ipython_frontend",
            "test_numpy_squeeze",
            "test_skip_initial_space",
            "test_resample_nonexistent_time_bin_edge",
            "test_getitem_setitem_periodindex",
            "test_info_memory",
            "test_getitem_setitem_ix_bool_keyerror",
            "test_maybe_promote_any_with_timedelta64",
            "axisinfo",
            "_convert_datetime_to_stata_type",
            "format_object_attrs",
            "test_rank_modify_inplace",
            "test_index_equal_level_values_mismatch",
            "test_merge_na_keys",
            "test_extension_array_cross_section_converts",
            "_from_name",
            "test_where_array_like",
            "test_corr_non_numeric",
            "test_constructor_manager_resize",
            "test_frame_datetime64_handling_groupby",
            "test_merge_join_categorical_multiindex",
            "test_scalar_ops_from_sequence_raises",
            "test_to_csv_multi_index",
            "test_index_false_to_json_table",
            "test_getitem_index",
            "test_get_bool_data",
            "test_from_tzaware_object_array",
            "test_timestamp_repr_pre1900",
            "test_index_false_error_to_json",
            "test_usecols_with_whitespace",
            "test_to_period_tz_warning",
            "test_dataframe_dummies_preserve_categorical_dtype",
            "test_loc_getitem_lowerdim_corner",
            "test_backfill",
            "api_doc",
            "testUnsignedInt",
            "_process_page_meta",
            "time_partition",
            "set_testing_mode",
            "__reduce__",
            "test_bar_log_no_subplots",
            "test_shift_categorical",
            "test_sparse_int",
            "test_interp_datetime64",
            "test_unstack_unused_levels",
            "test_barely_out_of_bounds",
            "test_bar_align_mid_vmax",
            "test_multiple_date_col_named_index_compat",
            "_add_legend_handle",
            "test_frame_on2",
            "test_frame_negate",
            "test_left_join_multi_index",
            "test_groupby_wrong_multi_labels",
            "check_bool_indexer",
            "test_tdi_add_int",
            "test_header_multi_index_common_format1",
            "test_groupby_extension_apply",
            "test_group_var_generic_2d_some_nan",
            "test_3d_fill_nonna",
            "combine_first",
            "unstack",
            "validate_col",
            "asi8",
            "test_query_compare_column_type",
            "test_write_append_mode_raises",
            "test_dti_add_intarray_no_freq",
            "test_float_max",
            "test_pivot_margins_name_unicode",
            "test_2000",
            "test_custom_na_values",
            "_get_standard_colors",
            "test_empty_with_multi_index_pass_dtype",
            "test_frame_getitem_not_sorted2",
            "test_allow_exact_matches_and_tolerance",
            "test_apply_bad_labels",
            "_union_indexes",
            "difference",
            "test_set_value",
            "test_large_multiindex_error",
            "test_non_unique_idvars",
            "test_query_doesnt_pickup_local",
            "_to_sql_empty",
            "_str_extract_frame",
            "test_td64arr_add_datetime64_nat",
            "test_integer_array_constructor",
            "test_to_records_dt64",
            "_format_data",
            "test_to_excel_multiindex_dates",
            "iris",
            "test_concatlike_dtypes_coercion",
            "test_partial_set_empty_frame_empty_consistencies",
            "test_to_json_float_index",
            "test_apply_scaler_on_date_time_index_aware_series",
            "test_set_index_period",
            "test_closed_left_corner",
            "test_error_with_zero_monthends",
            "nanall",
            "test_nanstd",
            "_reduce",
            "test_date_range_timezone_str_argument",
            "create_description",
            "test_setitem_same_but_unordered",
            "test_millisecond_repr",
            "test_loc_getitem_across_dst",
            "_validate_frequency",
            "test_constructor_invariant",
            "test_intersection_zero_length",
            "drop_table",
            "test_forward_by",
            "test_consistency_with_tz_aware_scalar",
            "test_arith_series_with_scalar",
            "test_fy5253qtr_onoffset_nearest",
            "_list_to_arrays",
            "test_diff_mixed_dtype",
            "test_partial_set_empty_frame_empty_copy_assignment",
            "test_basic",
            "test_series_bin_grouper",
            "test_info_memory_usage",
            "time_quantile",
            "time_floor",
            "test_compression_warns_when_decompress_caches_zlib",
            "test_dti_tz_convert_utc_to_local_no_modify",
            "test_rolling_max_resample",
            "test_query_None",
            "test_compare_zerodim",
            "test_parr_cmp_pi",
            "test_bar_align_mid_all_neg",
            "test_set_index_datetime",
            "test_cythonized_aggers",
            "test_get_level_number_integer",
            "test_constructor_mismatched_codes_levels",
            "test_numeric_op_scalar",
            "_check_roundtrip_table",
            "df_cross_compat",
            "register_extension_dtype",
            "pivot_table",
            "test_get_indexer_backfill",
            "validate_tz_from_dtype",
            "test_detect_console_encoding_fallback_to_default",
            "build_string",
            "test_no_color_bar",
            "test_shift2",
            "test_select_dtypes_datetime_with_tz",
            "test_td_sub_nat",
            "test_fillna_frame",
            "test_compression",
            "test_bad_deprecate_kwarg",
            "test_isin_nan_not_pypy",
            "test_unstack_to_series",
            "test_scalar_conversion",
            "test_cython_group_transform_algos",
            "test_set_name_methods",
            "test_date_format_raises",
            "test_interp_nan_idx",
            "test_sequence_like_with_categorical",
            "test_mpl2_color_cycle_str",
            "process_axes",
            "to_timestamp",
            "test_dti_add_int",
            "test_float_truncation",
            "test_ts_plot_with_tz",
            "test_filter_and_transform_with_non_unique_float_index",
            "test_concatlike_common_period_mixed_dt_to_object",
            "test_to_sql_append",
            "read_sparse_intindex",
            "test_concat_keys_with_none",
            "test_array_multiindex_raises",
            "test_boolean_context_compat",
            "test_setitem_multiple_partial",
            "test_concat_different_fill_value",
            "test_get_schema_create_table",
            "__floordiv__",
            "test_keyword_arg",
            "_get_period_range_edges",
            "test_td64arr_mod_tdscalar",
            "test_concat_copy",
            "test_rsplit",
            "test_string_index_repr_with_unicode_option",
            "test_datetime_indexing",
            "test_date_query_with_attribute_access",
            "test_truncate_copy",
            "test_concat_NaT_dataframes_all_NaT_axis_0",
            "test_frame_tz_convert",
            "test_pad_nan",
            "test_repr_bool_fails",
            "test_select_dtypes_exclude_using_scalars",
            "test_simple_cmp_ops",
            "test_axis_alias",
            "test_datetimeindex_sub_timestamp_overflow",
            "test_frame_dict_constructor_datetime64_1680",
            "test_to_datetime_parse_timezone_malformed",
            "test_constructor_orient",
            "test_pi_comp_period",
            "test_grouper_index_types",
            "test_empty_timeseries_reductions_return_nat",
            "test_values_multiindex_datetimeindex",
            "test_bar_align_mid_nans",
            "_is_numeric",
            "test_fails_ampersand",
            "test_index_convert_to_datetime_array",
            "test_excel_raise_error_on_multiindex_columns_and_no_index",
            "test_getitem_bool_index_all",
            "test_constructor_overflow_int64",
            "test_multiindex_get_loc",
            "_getitem_lowerdim",
            "pack",
            "test_apply_args",
            "has_invalid_return_type",
            "numeric_as_float",
            "assert_datetime_array_equal",
            "test_components",
            "_repr_fits_horizontal_",
            "test_resample_dtype_coerceion",
            "test_apply_standard_nonunique",
            "test_get_dummies_duplicate_columns",
            "test_dti_with_timedelta64_data_deprecation",
            "test_nonzero",
            "test_infer_datetimelike_array_nan_nat_like",
            "test_subplots_multiple_axes",
            "test_pairs",
            "_sanitize_and_check",
            "test_iloc_getitem_slice",
            "test_styler_to_excel",
            "is_datetime_arraylike",
            "test_df_mod_zero_int",
            "test_extract_single_group_returns_frame",
            "test_operators_empty_int_corner",
            "test_select_dtypes_include_using_list_like",
            "test_bad_generic_functions",
            "visit_BoolOp",
            "test_unique_id",
            "test_partial_set_invalid",
            "assert_label_values",
            "test_css_relative_font_size",
            "test_ffill",
            "test_comparison_with_unknown_scalars",
            "test_date_and_index",
            "test_iter_box",
            "ceil",
            "test_parse_dates_column_list",
            "_try_import",
            "test_float64_unit_conversion",
            "nansem",
            "test_dt64arr_add_timedeltalike_scalar",
            "_get_indices",
            "test_custom_value_name",
            "test_grouper_creation_bug",
            "test_rolling_std",
            "test_concat_bug_1719",
            "_assert_where_conversion",
            "test_comment_empty_line",
            "read_html",
            "test_eq",
            "test_asfreq_fill_value",
            "test_encode_string_conversion",
            "test_pi_add_iadd_int",
            "test_stack_mixed_levels",
            "test_infer_dtype_datetime",
            "test_interp_bad_method",
            "test_dti_tz_convert_dst",
            "test_plot_scatter",
            "test_properties_minutely",
            "time_join_dataframe_index_multi",
            "test_ordered_api",
            "test_to_timedelta_box_deprecated",
            "test_andrews_curves",
            "queryables",
            "test_from_codes_with_dtype_raises",
            "test_findall",
            "test_cdaterange",
            "test_unary_functions",
            "test_drop_duplicates_categorical_non_bool",
            "test_join_segfault",
            "tests_indexing_with_sparse",
            "_clip_with_one_bound",
            "test_partial_slice_hourly",
            "_write_header",
            "test_nested_flattens",
            "test_merge_series",
            "test_equals_op_index_vs_mi_same_length",
            "getMixedTypeDict",
            "test_corr_invalid_method",
            "test_repr_is_valid_construction_code",
            "_read_bytes",
            "test_reconstruction_index",
            "_check_inplace_setting",
            "_sub_period_array",
            "test_dti_add_sub_nonzero_mth_offset",
            "test_iteration_preserves_tz",
            "_set_subtyp",
            "test_lower_upper",
            "test_identical_stubnames",
            "test_where_bug",
            "test_astype_bool",
            "_get_ax_layer",
            "test_unit",
            "versions_from_parentdir",
            "test_isnull_for_inf_deprecated",
            "test_count_non_nulls",
            "frame_with_period_index",
            "df_cat",
            "test_map_dictlike",
            "test_describe_empty_categorical_column",
            "time_frame_date_formatting",
            "_bins_to_cuts",
            "test_loc_slicing",
            "test_Microsecond",
            "test_resample_string_kwargs",
            "test_range_closed_with_tz_aware_start_end",
            "test_grouped_box_layout",
            "test_to_int_index",
            "test_groupby_apply_none_first",
            "test_setitem_empty",
            "match",
            "test_dialect_conflict_except_delimiter",
            "check_result",
            "test_pass_dtype",
            "_wrap_transformed_output",
            "test_frame_timeseries_to_records",
            "test_cumsum_corner",
            "ohlc",
            "test_intersect_equal_sort",
            "test_as_json_table_type_categorical_dtypes",
            "_sphinx_build",
            "test_boolean_selection",
            "test_group_var_constant",
            "test_first_last_tz",
            "_maybe_localize_point",
            "test_comment_arg",
            "assert_copy",
            "is_platform_little_endian",
            "dups",
            "time_add_timedeltas",
            "test_repr_unicode",
            "test_rolling_max_gh6297",
            "test_get_values_deprecated",
            "test_mixed_arithmetic",
            "test_usecols_with_names",
            "test_count_object",
            "test_dti_sub_tdi",
            "_setop",
            "test_gz_lineend",
            "test_microsecond_repr",
            "time_different_str_functions",
            "test_to_pydatetime_nonzero_nano",
            "test_numpy_array_equal_unicode",
            "_where",
            "test_tdi_mul_int_array_zerodim",
            "test_resample_to_period_monthly_buglet",
            "test_include_na",
            "test_value_counts_period",
            "test_describe_bool_frame",
            "test_dti_tz_localize_pass_dates_to_utc",
            "test_bar_barwidth_position_int",
            "left_multi",
            "latex",
            "test_rename_signature",
            "test_usage_via_getsizeof",
            "test_get_indexer_with_interval",
            "test_td_mul_nat",
            "test_multi_index_unnamed",
            "wrap_arithmetic_op",
            "test_dti_tdi_numeric_ops",
            "test_bins_from_interval_index",
            "_add_deprecation_prefixes",
            "test_categorical_series_repr_datetime_ordered",
            "test_convert_objects_leave_decimal_alone",
            "test_an_exception_in_objecthook2",
            "ne_lt_2_6_9",
            "time_join_dataframe_index_single_key_small",
            "test_date_range_negative_freq",
            "test_bin8",
            "test_select_with_many_inputs",
            "_construct_dataframe",
            "test_copy_and_deepcopy",
            "test_groupby_multiindex_tuple",
            "build_components",
            "test_simple",
            "test_union_coverage",
            "test_from_items_deprecation",
            "test_reset_index_drop_errors",
            "test_isna_extension_array",
            "test_to_datetime_parse_tzname_or_tzoffset",
            "test_td64arr_sub_period",
            "test_from_datetime64_freq_changes",
            "test_group_var_generic_2d_all_finite",
            "test_apply_describe_bug",
            "test_astype_mixed_float",
            "test_cached_range_bug",
            "test_update_ctx_flatten_multi_traliing_semi",
            "build_table_schema",
            "test_repr_no_warning",
            "test_parsers_iso8601_invalid_offset_invalid",
            "test_tdi_mul_float_series",
            "_get_default_locs",
            "test_irreg_hf",
            "_make_comparison_op",
            "test_dataframe_constructor",
            "to_perioddelta",
            "time_normalize",
            "test_dti_construction_univalent",
            "test_create_index_existing_name",
            "test_rolling_functions_window_non_shrinkage_binary",
            "test_mgr_locs",
            "cut",
            "test_replace_swapping_bug",
            "test_data_frame_size_after_to_json",
            "time_join",
            "test_slice_float64",
            "set_value",
            "test_parr_cmp_period_scalar2",
            "test_apply_mixed_dtype_corner",
            "test_to_csv_headers",
            "test_multiindex_negative_level",
            "test_clip_against_list_like",
            "idx_cols_multi",
            "test_scalar_na_logical_ops_corners",
            "test_to_datetime_utc_true",
            "test_na_trailing_columns",
            "time_query_datetime_column",
            "_is_sub",
            "test_maybe_convert_timedelta",
            "_load_obj",
            "need_slice",
            "test_invalid_compression",
            "test_astype_period",
            "safe_cast",
            "_has_bool_dtype",
            "test_constructor_bool",
            "test_multi_nan_indexing",
            "test_loc_setitem_with_existing_dst",
            "test_mode",
            "test_column_format",
            "test_merge_non_unique_index_many_to_many",
            "test_categorical_repr_period",
            "_check_op",
            "test_header_and_index_no_types",
            "test_rename_nocopy",
            "_to_sql_method_callable",
            "test_setitem_with_tz",
            "test_format_percentiles",
            "test_select_dtypes_duplicate_columns",
            "test_strftime",
            "test_int64_overflow_issues",
            "test_single_char_leading_whitespace",
            "single_level_multiindex",
            "test_integer_array_plot",
            "_adjust_to_origin",
            "test_tsplot",
            "time_and",
            "test_overlaps_invalid_type",
            "test_fillna_raises",
            "test_reset_index",
            "forbid_nonstring_types",
            "test_tab_complete_warning",
            "test_iloc_setitem_int_multiindex_series",
            "test_dt64arr_add_sub_parr",
            "test_write_cells_merge_styled",
            "test_quantile_nat",
            "test_read_columns",
            "test_errorbar_scatter",
            "_has_complex_date_col",
            "check_compound_invert_op",
            "test_autocorrelation_plot",
            "test_basics_nanos",
            "_make_logical_function",
            "_maybe_check_integrity",
            "test_option_context_scope",
            "returns",
            "test_filter_bytestring",
            "_transform_index",
            "test_line_area_stacked",
            "_validate_header_arg",
            "test_subclass_empty_repr",
            "test_set_index_cast_datetimeindex",
            "test_shift_dst",
            "test_period_dt64_round_trip",
            "is_numeric",
            "_pop_header_name",
            "downcast",
            "_transaction_test",
            "test_no_right",
            "test_insert_index_float64",
            "test_groupby_extension_no_sort",
            "test_time_field_bug",
            "test_period_astype_to_timestamp",
            "test_td64arr_sub_offset_array",
            "test_constructor_datetime64arr",
            "test_bool_array_logical",
            "test_append_empty_preserve_name",
            "test_format_percentiles_integer_idx",
            "test_timestamp_to_datetime",
            "test_append_to_multiple_dropna_false",
            "test_constructor_from_index_series_timedelta",
            "test_short_format_converters",
            "test_to_html_basic_alignment",
            "test_xs_view",
            "select_as_coordinates",
            "test_interval_index",
            "asof_locs",
            "test_info_duplicate_columns",
            "test_bools",
            "test_uint64_factorize",
            "test_period_compat",
            "test_rename",
            "test_compression_utf16_encoding",
            "multiindex_year_month_day_dataframe_random_data",
            "test_detect_chained_assignment",
            "test_where_callable",
            "get_reindexed_values",
            "test_path_localpath_hdfstore",
            "factorize",
            "test_rdiv_zero_compat",
            "transform",
            "test_categorical_index_repr_period",
            "_test_small_strings_no_warn",
            "test_constructor_dict_cast",
            "test_omit_nuisance",
            "test_replace_categorical",
            "_get_period_bins",
            "test_colaliases",
            "_set_encoding",
            "test_monthly_upsample",
            "_convert_cell",
            "test_sparse_series",
            "test_constructor_object_dtype",
            "test_to_native_types",
            "andrews_curves",
            "test_join_nonunique",
            "test_map_bug_1677",
            "test_categorical_repr_unicode",
            "test_dtype_all_columns",
            "test_groupby_multiindex_not_lexsorted",
            "test_isna_datetime",
            "test_stat_op_calc",
            "strftime",
            "test_tz_aware_scalar_comparison",
            "test_infer_from_tdi_mismatch",
            "test_align_multiindex",
            "test_usecols_diff_positional_str_columns_order",
            "test_custom_var_and_value_name",
            "test_datetimetz_dtype",
            "test_n",
            "test_evenly_divisible_with_no_extra_bins",
            "to_latex",
            "test_million_record_attribute_error",
            "time_rfind",
            "test_map_with_non_function_missing_values",
            "generate_range",
            "test_small_strings_no_warn_blosc",
            "test_pi_sub_intlike",
            "test_hide_columns_single_level",
            "test_td64arr_mul_tdlike_scalar_raises",
            "test_read_zipped_json",
            "_fast_union",
            "_add_logical_methods",
            "test_rolling_var",
            "test_comprehensive",
            "test_timestamp_to_datetime_dateutil",
            "test_dataframe_dummies_prefix_dict",
            "test_td64arr_add_sub_numeric_arr_invalid",
            "test_dti_add_intarray_tick",
            "time_float_int_str_lines",
            "test_td_rsub_nat",
            "read_array",
            "test_really_large_in_arr_consistent",
            "test_grouper_multilevel_freq",
            "test_converters_euro_decimal_format",
            "test_repr_max_rows",
            "test_sparse_reindex",
            "test_dt64arr_add_sub_float",
            "test_drop",
            "test_transform_numeric_ret",
            "test_grouped_box_multiple_axes",
            "test_decimal_rows",
            "update_info",
            "test_rank_first_pct",
            "test_errors",
            "boxplot",
            "test_try_coerce_arg",
            "test_constructor_maskedrecarray_dtype",
            "four_level_index_dataframe",
            "color_to_excel",
            "test_floating_tuples",
            "test_dti_time",
            "test_constructor_dtypes_datetime",
            "test_merge_indexes_and_columns_lefton_righton",
            "_disabled",
            "test_logical_typeerror_with_non_valid",
            "format_signature",
            "test_to_excel_unicode_filename",
            "test_map_with_string_constructor",
            "test_values",
            "test_array_basic",
            "test_to_datetime_unparseable_ignore",
            "is_datetimelike_v_numeric",
            "test_transform_length",
            "test_zero_length_input_index",
            "see_also",
            "test_truediv",
            "test_fillna_fill_other",
            "test_from_values_or_dtype_raises",
            "test_constructor_wrong_precision_raises",
            "test_to_html_multiindex_max_cols",
            "test_frame_datetime64_pre1900_repr",
            "test_margins_dtype",
            "test_iloc_non_integer_raises",
            "overlaps",
            "lstrip",
            "test_to_dict_timestamp",
            "test_to_csv_stdout_file",
            "test_time_musec",
            "test_setitem_frame_upcast",
            "_pad_bytes_new",
            "tips_file",
            "test_to_datetime_unit",
            "test_pass_function",
            "_get_frame_op_default_axis",
            "test_nan_str_index",
            "time_read_json_lines_concat",
            "_validate_format",
            "test_rolling_functions_window_non_shrinkage",
            "test_outer",
            "legend_title",
            "time_transform_multi_key2",
            "test_categorical_repr",
            "_get_grouper",
            "test_concatlike_same_dtypes",
            "time_series_nth_any",
            "test_regex_replace_scalar_inplace",
            "test_apply_frame_to_series",
            "test_single_backtick_variable_query",
            "pct_change",
            "test_to_csv_line_terminators",
            "test_constructor_sequence_like",
            "_replot_ax",
            "get_is_dtype_funcs",
            "test_seriesgroupby_observed_apply_dict",
            "test_business_end_year_alias",
            "test_get_nan",
            "_repr_latex_",
            "test_select_iterator_complete_8014",
            "_maybe_add_join_keys",
            "test_setitem_mulit_index",
            "test_dropna",
            "time_multi_int_count",
            "test_comparison_invalid",
            "test_sort_ascending_list",
            "test_dt64arr_sub_timedeltalike_scalar",
            "test_sparse_series_pad_backfill_limit",
            "test_tz_localize_errors_deprecation",
            "test_shift_across_dst",
            "test_take_mixed_type",
            "all_mixed",
            "main",
            "test_path_local_path",
            "test_cython_agg_return_dict",
            "_repr_data_resource_",
            "test_mixed_dtypes_remain_object_array",
            "_wrap_generic_output",
            "test_groupby_list_infer_array_like",
            "test_frame_empty_mixedtype",
            "test_multi_key_multiple_functions",
            "test_constructor_dict_nan_tuple_key",
            "test_to_coo_text_names_integer_row_levels_sort",
            "tests_skip_nuisance",
            "test_series_describe_multikey",
            "count",
            "test_squeeze",
            "_add_numeric_methods_binary",
            "test_is_scalar_builtin_scalars",
            "test_quote_char_basic",
            "test_tz_localize_convert_copy_inplace_mutate",
            "test_bar_center",
            "test_take_fill_value",
            "test_week_of_month_frequency",
            "test_between_time_raises",
            "test_array_like",
            "_create_data",
            "_prefix",
            "test_decode_null_character",
            "test_groupby_level_index_names",
            "test_concat_odered_dict",
            "test_no_index",
            "test_set_columns",
            "test_numeric_arr_mul_tdscalar",
            "setup_driver",
            "test_bar_nan",
            "test_sqlite_type_mapping",
            "test_numpy_minmax_datetime64",
            "test_scalar_float",
            "test_nanvar_ddof",
            "test_td64arr_rmul_numeric_array",
            "test_foobar",
            "generate_blob",
            "run_transaction",
            "test_gb_key_len_equal_axis_len",
            "test_array_timedelta_floordiv",
            "test_holidays",
            "test_to_timestamp_pi_mult",
            "test_idxminmax_with_inf",
            "test_setitem_boolean_column",
            "test_construction_interval",
            "test_apply",
            "nansum",
            "_get_concat_axis",
            "test_fails_pipe",
            "test_regression_whitelist_methods",
            "test_parse_trim_buffers",
            "_process_columnattributes_subheader",
            "test_union_dataframe_index",
            "test_logical_ops_empty_frame",
            "test_insert_nat",
            "test_fill_value_when_combine_const",
            "test_take_warns",
            "test_loc_getitem_label",
            "test_raise_on_passed_int_dtype_with_nas",
            "test_no_new_globals",
            "is_numeric_v_string_like",
            "test_length_zero",
            "test_str_to_bytes_raises",
            "test_usecols_with_parse_dates3",
            "test_insert_index_timedelta64",
            "_grouped_plot_by_column",
            "test_duplicated_with_misspelled_column_name",
            "test_integer_array_constructor_copy",
            "test_freq_setter_errors",
            "test_pct_change_periods_freq",
            "test_replace_input_formats_scalar",
            "_get_string_slice",
            "test_constructor_index_mismatch",
            "nlargest",
            "float_string_frame",
            "test_groupby_multiple_key",
            "data",
            "create_axes",
            "test_date_unit",
            "test_non_convertable_values",
            "test_concatlike_common_coerce_to_pandas_object",
            "nested_to_record",
            "time_frame_sort_values",
            "get_values",
            "_write",
            "test_retain_index_attributes2",
            "test_from_records_empty_with_nonempty_fields_gh3682",
            "test_convert_dti_to_series",
            "test_compare_unordered_different_order",
            "apply_broadcast",
            "test_to_datetime_utc_true_with_series_tzaware_string",
            "get_dtype_kinds",
            "test_slice_locs_na_raises",
            "test_with_large_max_level",
            "test_arrmap",
            "freq",
            "deep_nested",
            "time_to_datetime_format_DD_MM_YYYY",
            "test_as_blocks",
            "test_read_chunks_117",
            "test_from_json_to_json_table_dtypes",
            "_filter_special_cases",
            "test_factorized_sort_ordered",
            "check_arbitrary",
            "test_constructor_ordered_dict_conflicting_orders",
            "_reconstruct_object",
            "test_sort_index_level_mixed",
            "test_offset_timedelta64_arg",
            "_construct_axes_from_arguments",
            "test_is_datetime64tz_dtype",
            "test_boxplot_legacy3",
            "test_merge_type",
            "_addsub_int_array",
            "test_constructor_incompat_freq",
            "test_timestamp_and_label",
            "test_out_of_bounds_string",
            "test_iterable_object_and_category",
            "test_argument_types",
            "_format_native_types",
            "test_resample_timedelta_values",
            "test_series_compression_defaults_to_infer",
            "_add_datetime_arraylike",
            "get_commit_info",
            "test_empty_with_index_pass_dtype",
            "test_index_label_overlaps_location",
            "test_to_xarray_index_types",
            "_multi_take",
            "test_parr_add_iadd_parr_raises",
            "test_regex_replace_dict_nested",
            "test_merge_right_vs_left",
            "test_dti_slicing",
            "test_misc",
            "test_readonly_axis_zlib",
            "assert_sp_frame_equal",
            "_apply_to_column_groupbys",
            "constructor",
            "test_dt_accessor_invalid",
            "_postprocess_for_cut",
            "test_replace_convert",
            "_hashed_values",
            "test_loc_general",
            "test_bins_from_interval_index_doc_example",
            "test_reindex_name_remains",
            "__contains__",
            "test_constructor_timestamp",
            "test_group_var_generic_1d_flat_labels",
            "time_getitem_label_slice",
            "test_get_indexer_same_categories_same_order",
            "test_clipboard_copy_tabs_default",
            "_ftype",
            "test_describe_option",
            "formatting_values",
            "_side_expander",
            "test_reindex_objects",
            "test_dt64arr_add_timestamp_raises",
            "test_stack_names_and_numbers",
            "test_combine_first_timezone",
            "test_ragged_median",
            "test_mean_mixed_datetime_numeric",
            "test_to_coo_duplicate_index_entries",
            "test_getitem_slice_not_sorted",
            "test_usecols_index_col_conflict2",
            "test_deferred_with_groupby",
            "test_nat",
            "hash_array",
            "test_time_change_xlim",
            "is_nested_list_like",
            "test_setitem_frame_invalid_length",
            "test_period_array_readonly_object",
            "test_to_html_multi_indexes_index_false",
            "test_x_string_values_ticks",
            "test_set_index_raise_on_type",
            "time_different_python_functions_multicol",
            "time_apply_ref_by_name",
            "index_names",
            "test_unicode_column_name",
            "test_resample_rounding",
            "test_fillna_invalid_value",
            "test_contains_nat",
            "test_index_types",
            "dispatch_to_series",
            "time_read_store_mixed",
            "test_comparisons",
            "test_transform_fast",
            "orientation",
            "_factorize_array",
            "test_iloc_getitem_bool_diff_len",
            "test_from_records_nones",
            "test_overlapping_columns_error_message",
            "test_dict_numpy_float",
            "read_index_node",
            "test_boolean_compare_transpose_tzindex_with_dst",
            "test_tokenize_CR_with_quoting",
            "test_fontsize_set_correctly",
            "test_pivot_with_list_like_values_nans",
            "test_corr_int_and_boolean",
            "test_grouper_column_and_index",
            "test_td_sub_pytimedelta",
            "test_td_sub_td64_nat",
            "test_pickle_compat_0_14_1",
            "test_is_dict_like_duck_type",
            "time_translate",
            "add_special_arithmetic_methods",
            "test_ngroup_series_matches_frame",
            "test_variable_width_unicode",
            "test_cmov_window_corner",
            "rands_array",
            "test_tshift",
            "test_non_iso_strings_with_tz_offset",
            "test_resample_how",
            "test_boxplot_return_type_legacy",
            "test_is_level_reference_series_simple_axis0",
            "test_open_args",
            "test_unicode_index",
            "test_dti_with_offset_series",
            "test_unordered_different_categories_raises",
            "_take_with_fill",
            "_get_agg_axis",
            "_chk_truncate",
            "test_mul_int_series",
            "timezone_frame",
            "test_filter_out_all_groups",
            "to_series",
            "test_loc_and_at_with_categorical_index",
            "test_binary_ops_align",
            "test_skew",
            "test_dataframe_dummies_prefix_list",
            "test_crosstab_non_aligned",
            "_parse_dtype_strict",
            "nancorr",
            "test_get_level_values_all_na",
            "_get_single_indexer",
            "test_setitem_loc_scalar_single",
            "_find_valid_index",
            "sanitize_index",
            "test_deprecated_from_api_types",
            "test_get_indexer_nearest",
            "test_dti_custom_business_repr",
            "test_deprecate_no_docstring",
            "float_frame_fill2_dense",
            "test_index_false_from_json_to_json",
            "test_frame_double_encoded_labels",
            "test_pi_add_timedeltalike_mismatched_freq_hourly",
            "test_constructor_series_copy",
            "test_slice_integer",
            "test_reconstruct_sort",
            "test_merge_take_missing_values_from_index_of_other_dtype",
            "test_getitem_multiple",
            "test_nested_period_index_subscript_expression",
            "test_rank_na_option",
            "test_to_csv_withcommas",
            "test_comp_nat",
            "time_col_select_lambda_sum",
            "_make_stat_function",
            "test_basic_subset_columns",
            "test_range_slice_day",
            "test_str_cat_categorical",
            "test_boxplot_empty_column",
            "write_to_compressed",
            "time_strip",
            "test_query_by_text_obj",
            "test_operators_corner",
            "_make_wrapper",
            "test_astype_int",
            "read_gbq",
            "test_caption",
            "test_dtype_with_converters",
            "test_all_apply",
            "_setitem_with_indexer",
            "allow_in_pandas",
            "test_describe_percentiles_integer_idx",
            "test_cut_return_intervals",
            "test_read_csv_local",
            "test_stack_mixed_level",
            "test_file_handle",
            "_replace_pandas_items",
            "test_detect_console_encoding_from_stdout_stdin",
            "test_string_io",
            "test_periods",
            "test_set_properties_subset",
            "df_mixed_floats",
            "test_loc_getitem_nested_indexer",
            "test_replace_datetime",
            "test_range_edges",
            "test_to_html_truncate_multi_index",
            "test_rename_errors",
            "test_concat_categorical_multi_coercion",
            "test_slicing_datetimes",
            "test_timestamp_compare",
            "test_sort_index",
            "get_offset",
            "test_skipfooter",
            "get_new_values",
            "test_tz_dtype_matches",
            "test_join_level_corner_case",
            "file_path_to_url",
            "_extract_multi_indexer_columns",
            "_process_columnsize_subheader",
            "test_set_dtype_same",
            "test_no_copy_blocks",
            "test_two_backtick_variables_expr",
            "test_df_legend_labels",
            "test_to_string_unicode_three",
            "test_categorical_unexpected_categories",
            "test_extract_index_one_two_groups",
            "s3_resource",
            "test_index_convert_to_datetime_array_explicit_pytz",
            "test_reader_special_dtypes",
            "test_nansum",
            "test_calendar",
            "test_just_na",
            "test_period_cons_combined",
            "test_skipinitialspace",
            "test_diff_float_n",
            "test_margins_no_values_two_rows",
            "test_zfill",
            "_do_date_conversions",
            "test_categorical_delegations",
            "test_unsupported_dtype",
            "time_sparse_series_to_coo",
            "test_constructor_corner",
            "test_set_axis_inplace_axes",
            "test_datetime_with_timezone_roundtrip",
            "recode_for_groupby",
            "test_s3_fails",
            "_get_cacher",
            "_unconvert_string_array",
            "_add_numeric_operations",
            "_get_lbllist",
            "_replace_locals",
            "test_format_missing",
            "test_set_column_scalar_with_ix",
            "_get_empty_meta",
            "_get_new_axes",
            "_is_py3_complex_incompat",
            "test_astype_with_exclude_string",
            "test_not_hashable",
            "test_constructor_from_frame_series_freq",
            "test_aggregate_with_nat",
            "test_td_add_sub_one_day_ten_seconds",
            "test_query_python",
            "test_as_json_table_type_categorical_data",
            "test_axis_dates",
            "test_unordered_ts",
            "test_syntax_error_exprs",
            "test_plot_fails_when_ax_differs_from_figure",
            "test_invalid_kind",
            "test_rank2",
            "test_full_file_with_spaces",
            "fillna",
            "test_periods_number_check",
            "test_td_div_nan",
            "test_as_index",
            "time_read_csv_cached",
            "test_first_nan_kept",
            "test_homogenize",
            "_get_index_names",
            "test_same_ordering",
            "test_none_delimiter",
            "test_consistency_name",
            "test_numeric_conversions",
            "test_operators_combine",
            "nanskew",
            "test_unicode_problem_decoding_as_ascii",
            "test_expanding_consistency",
            "test_align_float",
            "test_ismethods",
            "testRollback2",
            "_skip_if_no_akima",
            "test_constructor_from_dense_series",
            "test_logical_ops_int_frame",
            "test_intersection_equal_sort_true",
            "test_interp_nonmono_raise",
            "test_concat_tuple_keys",
            "intersection",
            "test_to_block_index",
            "test_pivot",
            "test_td64arr_rfloordiv_tdlike_scalar",
            "test_neg_freq",
            "test_categorical_equal_object_override",
            "test_filter_multi_column_df",
            "test_pivot_table_with_iterator_values",
            "test_drop_and_dropna_caching",
            "init_windows_clipboard",
            "test_where_timedelta_coerce",
            "test_invalid_date_conversion",
            "test_dtype_per_column",
            "test_css_side_shorthands",
            "time_add",
            "test_register",
            "mixed_float2",
            "test_nested_object_record_path",
            "test_metadata_immutable",
            "test_td64arr_sub_timestamp_raises",
            "test_take_positive_no_warning",
            "nanstd",
            "test_attr_expression",
            "test_startswith",
            "test_closed",
            "test_invalid_url",
            "test_tz_convert_and_localize",
            "test_construction_with_mixed",
            "test_shift_gh8083",
            "test_validate_all_ignore_deprecated",
            "test_compat_replace",
            "test_basic_regular",
            "_items_overlap_with_suffix",
            "time_contains",
            "memory_usage",
            "test_map_compat",
            "is_monotonic_decreasing",
            "test_encode",
            "test_validate_sum_initial",
            "test_nanmean",
            "_add_comparison_methods",
            "test_corrwith_matches_corrcoef",
            "test_groupby_grouper_f_sanity_checked",
            "test_setitem_ndarray_3d",
            "test_constructor_field_arrays",
            "test_loc_getitem_duplicates_multiindex_non_scalar_type_object",
            "test_versioning",
            "_concat_rangeindex_same_dtype",
            "test_take_raises",
            "is_mixed",
            "test_agg_relabel_with_level",
            "test_empty_tables",
            "_add_datetimelike_methods",
            "test_int_internal",
            "test_get_numeric_data_preserve_dtype",
            "test_basic_upsample",
            "fast_xs",
            "test_intersection_empty",
            "test_undefined_func",
            "write_cells",
            "_make_flex_doc",
            "test_at_to_fail",
            "testRollforward1",
            "test_index_col_is_true",
            "test_non_ascii_key",
            "test_reductions",
            "test_parsing_different_timezone_offsets",
            "test_regex_replace_str_to_numeric",
            "_tag",
            "test_dti_constructor_years_only",
            "test_cross_engine_pa_fp",
            "table",
            "test_unstack_swaplevel_sortlevel",
            "test_dict_complex",
            "_convert_for_op",
            "test_from_product_iterator",
            "method_source",
            "test_join_str_datetime",
            "test_timezone_comparaison_bug",
            "test_separating_character",
            "test_set_name_attribute",
            "test_execute_sql",
            "test_partial_set_empty_frame_set_series",
            "get_value_maybe_box",
            "test_from_records_set_index_name",
            "test_same_name_but_underscores",
            "test_get_pad_indexer",
            "test_set_change_dtype_slice",
            "test_tseries_select_index_column",
            "_check_for_invalid_keys",
            "test_replace_input_formats_listlike",
            "test_td_add_timedeltalike_object_dtype_array",
            "test_insert_column_bug_4032",
            "test_where_tz_values",
            "test_query_string_scalar_variable",
            "test_df_flex_cmp_constant_return_types",
            "test_append_dtypes",
            "test_shift_duplicate_columns",
            "test_invalid_table_attrs",
            "test_max",
            "test_no_dummy_key_names",
            "_preparse",
            "filter",
            "set_version",
            "test_pos_numeric",
            "test_comparison_operators_with_nas",
            "test_astype_nansafe",
            "test_to_records_with_unicode_index",
            "test_td_add_offset",
            "test_getitem_with_listlike",
            "test_sparse_frame",
            "test_combine_from_sequence_raises",
            "test_pivot_multi_functions",
            "test_to_excel_timedelta",
            "test_pivot_index_none",
            "test_constructor_frame_copy",
            "test_constructor_categorical_with_coercion",
            "test_filter_mixed_df",
            "new_func_wrong_docstring",
            "test_timedelta_cut_roundtrip",
            "test_empty_prod",
            "get_new_columns",
            "test_astype_categoricaldtype",
            "_to_sql_fail",
            "test_to_csv_list_entries",
            "test_max_min_non_numeric",
            "test_to_string_multindex_header",
            "time_nlargest_one_column",
            "test_from_records_columns_not_modified",
            "test_isin_with_i8",
            "test_backend_is_not_module",
            "validate_min_itemsize",
            "test_filter_has_access_to_grouped_cols",
            "assert_interval_array_equal",
            "test_top_level_method",
            "remove_na",
            "test_divmod_invalid",
            "test_pi_add_timedeltalike_tick_gt1",
            "decode",
            "test_append_to_another",
            "_check_ticks_props",
            "test_nuiscance_columns",
            "test_getitem_multilevel_index_tuple_not_sorted",
            "test_series_indexing_multiple",
            "test_datetime",
            "test_map_dict_subclass_with_missing",
            "test_preserve_categorical_dtype",
            "test_cmp_series_period_series_mixed_freq",
            "test_repr_roundtrip",
            "test_out_of_range_double",
            "test_setitem_with_sparse_value",
            "test_data_after_quote",
            "test_ordered_none_default_deprecated",
            "test_stat_unexpected_keyword",
            "test_groupby_with_timegrouper",
            "test_pi_add_sub_timedeltalike_freq_mismatch_annual",
            "teardown_class",
            "test_check_compatible_with",
            "test_ewm_consistency",
            "_convert_datetimelike_to_object",
            "test_numeric_arr_rdiv_tdscalar",
            "test_to_csv_bug",
            "test_dti_astype_asobject_tzinfos",
            "test_write_ignoring_index",
            "test_from_categorical_dtype_both",
            "test_to_excel_multiindex_cols",
            "test_hour",
            "test_select_dtypes_bad_datetime64",
            "test_fast_apply",
            "github_url",
            "test_difference_sort_special",
            "_get_quarterly_rule",
            "_try_convert_types",
            "test_stale_cached_series_bug_473",
            "test_empty_na_values_no_default_with_index",
            "test_reindex",
            "test_bad_stream_exception",
            "test_construction_with_tz_and_tz_aware_dti",
            "test_crosstab_unsorted_order",
            "test_tuple_index",
            "test_no_warning",
            "_get_ordinal_range",
            "test_dti_iadd_tdi",
            "test_dti_intersection",
            "test_get_loc2",
            "test_concat",
            "rstjinja",
            "test_asobject_deprecated",
            "_recode_for_categories",
            "test_axis_classmethods",
            "test_disallow_set_ops",
            "from_intervals",
            "test_display_dict",
            "test_qcut_specify_quantiles",
            "test_na_value_dict",
            "_get_private_key_path",
            "_set_value",
            "test_fillna_limit_pad",
            "deregister",
            "test_constructor_more",
            "_prepare_pandas",
            "test_intersect_nosort",
            "makeCustomDataframe",
            "test_flex_method_equivalence",
            "test_exit_status_for_validate_all_json",
            "get_mgr_concatenation_plan",
            "test_empty_frame_roundtrip",
            "test_pi_cmp_period",
            "test_getitem_list_of_columns",
            "test_mpl_nopandas",
            "test_auto_conversion",
            "test_pos_raises",
            "test_errorbar_plot",
            "create_for_block",
            "test_encode_hook",
            "test_maybe_promote_any_with_string",
            "test_append_with_timezones_pytz",
            "test_td_mul_nan",
            "_reset_cache",
            "test_td_sub_timedeltalike_object_dtype_array",
            "test_xs_level",
            "get_authors",
            "test_fancy_setitem",
            "test_from_codes",
            "test_concat_categorical_tz",
            "_isnan",
            "test_date_parsing",
            "external_values",
            "test_frame_set_name_single",
            "test_pad_width",
            "test_value_counts_datetime",
            "test_pickle_round_trip",
            "test_rename_axis_supported",
            "test_getitem_setitem_ix_duplicates",
            "test_get_period_range_edges",
            "test_less_precise",
            "select_coords",
            "test_assert_numpy_array_equal_value_mismatch3",
            "test_dti_tz_conversion_freq",
            "time2num",
            "test_to_datetime_dt64s_out_of_bounds",
            "test_repr_html",
            "test_categorical_with_stata_missing_values",
            "test_dt64tz_series_sub_dtitz",
            "test_concat_axis1",
            "test_conv_read_write",
            "test_period_constructor_offsets",
            "test_incorrect_type_array",
            "test_dt64_data_invalid",
            "test_medium_complex_frame_alignment",
            "test_total_seconds_precision",
            "test_contiguous_boolean_preserve_freq",
            "_process_page_metadata",
            "test_agg_cast_results_dtypes",
            "reorder_levels",
            "test_set_index_timezone",
            "test_min_max_series",
            "test_update_dtype_string",
            "test_nanosecond_field",
            "_obj_with_exclusions",
            "test_assign_bad",
            "test_setting_fill_value_fillna_still_works",
            "test_series_map_box_timedelta",
            "three_group",
            "test_td64arr_add_str_invalid",
            "test_interp_timedelta64",
            "test_query_undefined_local",
            "__pos__",
            "test_series_tz_localize_empty",
            "stack_multiple",
            "test_series_getitem_returns_scalar",
            "test_sparse_with_compression",
            "test_empty_str_methods",
            "test_rdiv_zero",
            "test_constructor_dict_order",
            "round_trip_localpath",
            "test_apply_without_copy",
            "test_python_engine",
            "test_secondary_frame",
            "test_series_frame_commutativity",
            "set_axis",
            "test_astimezone",
            "test_droplevel",
            "_ensure_decoded",
            "test_union_sort_other_incomparable_true",
            "test_dti_with_timezone_repr",
            "is_platform_windows",
            "read_json",
            "test_groupby_series_indexed_differently",
            "test_assign",
            "test_widths",
            "test_header_multi_index_common_format2",
            "_load_iris_view",
            "_replace_coerce",
            "test_method_delegation",
            "test_fifth_week_of_month",
            "test_rename_multiindex",
            "_multiindex",
            "test_datetimeindex_highprecision",
            "test_malformed_chunks",
            "test_mode_datetime",
            "test_text_color_threshold",
            "test_comparison_object_array",
            "bdate_range",
            "test_repr_name_iterable_indexable",
            "test_format_timedelta_ticks_wide",
            "test_converters_corner_with_nans",
            "sum",
            "testArray",
            "_adorn_subplots",
            "test_invalid_origins_tzinfo",
            "maybe_infer_tz",
            "_make_legend",
            "test_dti_tz_localize_nonexistent_shift_invalid",
            "test_dates_invalid_column",
            "test_scalar_integer",
            "test_dt64arr_isub_timedeltalike_scalar",
            "test_cython_api2",
            "test_ix_general",
            "test_with_s3_url",
            "test_nonunique_contains",
            "test_get_year_end",
            "test_logical_with_nas",
            "test_from_codes_with_categorical_categories",
            "test_concat_single_with_key",
            "time_frame_getitem_single_column_label",
            "test_getitems_slice_multi",
            "test_take_invalid_kwargs",
            "test_rollback",
            "test_assert_numpy_array_equal_value_mismatch1",
            "test_backend_is_correct",
            "test_cached_data",
            "test_no_mlk_before_1986",
            "test_append_concat_tz",
            "_reindex_indexer",
            "test_fillna_limit_backfill",
            "test_block_internal",
            "test_background_gradient",
            "test_ragged_sum",
            "test_freq_str",
            "test_join_on_pass_vector",
            "test_line_colors",
            "test_label",
            "str_wrap",
            "test_iloc_getitem_labelled_frame",
            "test_indexing_sliced"
          ]
        },
        "file": {
          "file_name": "common.py",
          "file_nloc": 243,
          "file_complexity": 105,
          "file_token_count": 1425,
          "file_before": "\"\"\"\nMisc tools for implementing data structures\n\nNote: pandas.core.common is *not* part of the public API.\n\"\"\"\n\nimport collections\nfrom collections import OrderedDict, abc\nfrom datetime import datetime, timedelta\nfrom functools import partial\nimport inspect\nfrom typing import Any, Iterable, Union\n\nimport numpy as np\n\nfrom pandas._libs import lib, tslibs\nfrom pandas.compat import PY36\n\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.common import (\n    is_array_like, is_bool_dtype, is_extension_array_dtype, is_integer)\nfrom pandas.core.dtypes.generic import ABCIndex, ABCIndexClass, ABCSeries\nfrom pandas.core.dtypes.inference import _iterable_not_string\nfrom pandas.core.dtypes.missing import isna, isnull, notnull  # noqa\n\n\nclass SettingWithCopyError(ValueError):\n    pass\n\n\nclass SettingWithCopyWarning(Warning):\n    pass\n\n\ndef flatten(l):\n    \"\"\"\n    Flatten an arbitrarily nested sequence.\n\n    Parameters\n    ----------\n    l : sequence\n        The non string sequence to flatten\n\n    Notes\n    -----\n    This doesn't consider strings sequences.\n\n    Returns\n    -------\n    flattened : generator\n    \"\"\"\n    for el in l:\n        if _iterable_not_string(el):\n            for s in flatten(el):\n                yield s\n        else:\n            yield el\n\n\ndef consensus_name_attr(objs):\n    name = objs[0].name\n    for obj in objs[1:]:\n        try:\n            if obj.name != name:\n                name = None\n        except ValueError:\n            name = None\n    return name\n\n\ndef maybe_box(indexer, values, obj, key):\n\n    # if we have multiples coming back, box em\n    if isinstance(values, np.ndarray):\n        return obj[indexer.get_loc(key)]\n\n    # return the value\n    return values\n\n\ndef maybe_box_datetimelike(value):\n    # turn a datetime like into a Timestamp/timedelta as needed\n\n    if isinstance(value, (np.datetime64, datetime)):\n        value = tslibs.Timestamp(value)\n    elif isinstance(value, (np.timedelta64, timedelta)):\n        value = tslibs.Timedelta(value)\n\n    return value\n\n\nvalues_from_object = lib.values_from_object\n\n\ndef is_bool_indexer(key: Any) -> bool:\n    \"\"\"\n    Check whether `key` is a valid boolean indexer.\n\n    Parameters\n    ----------\n    key : Any\n        Only list-likes may be considered boolean indexers.\n        All other types are not considered a boolean indexer.\n        For array-like input, boolean ndarrays or ExtensionArrays\n        with ``_is_boolean`` set are considered boolean indexers.\n\n    Returns\n    -------\n    bool\n\n    Raises\n    ------\n    ValueError\n        When the array is an object-dtype ndarray or ExtensionArray\n        and contains missing values.\n    \"\"\"\n    na_msg = 'cannot index with vector containing NA / NaN values'\n    if (isinstance(key, (ABCSeries, np.ndarray, ABCIndex)) or\n            (is_array_like(key) and is_extension_array_dtype(key.dtype))):\n        if key.dtype == np.object_:\n            key = np.asarray(values_from_object(key))\n\n            if not lib.is_bool_array(key):\n                if isna(key).any():\n                    raise ValueError(na_msg)\n                return False\n            return True\n        elif is_bool_dtype(key.dtype):\n            # an ndarray with bool-dtype by definition has no missing values.\n            # So we only need to check for NAs in ExtensionArrays\n            if is_extension_array_dtype(key.dtype):\n                if np.any(key.isna()):\n                    raise ValueError(na_msg)\n            return True\n    elif isinstance(key, list):\n        try:\n            arr = np.asarray(key)\n            return arr.dtype == np.bool_ and len(arr) == len(key)\n        except TypeError:  # pragma: no cover\n            return False\n\n    return False\n\n\ndef cast_scalar_indexer(val):\n    \"\"\"\n    To avoid numpy DeprecationWarnings, cast float to integer where valid.\n\n    Parameters\n    ----------\n    val : scalar\n\n    Returns\n    -------\n    outval : scalar\n    \"\"\"\n    # assumes lib.is_scalar(val)\n    if lib.is_float(val) and val == int(val):\n        return int(val)\n    return val\n\n\ndef _not_none(*args):\n    \"\"\"\n    Returns a generator consisting of the arguments that are not None.\n    \"\"\"\n    return (arg for arg in args if arg is not None)\n\n\ndef _any_none(*args):\n    \"\"\"\n    Returns a boolean indicating if any argument is None.\n    \"\"\"\n    for arg in args:\n        if arg is None:\n            return True\n    return False\n\n\ndef _all_none(*args):\n    \"\"\"\n    Returns a boolean indicating if all arguments are None.\n    \"\"\"\n    for arg in args:\n        if arg is not None:\n            return False\n    return True\n\n\ndef _any_not_none(*args):\n    \"\"\"\n    Returns a boolean indicating if any argument is not None.\n    \"\"\"\n    for arg in args:\n        if arg is not None:\n            return True\n    return False\n\n\ndef _all_not_none(*args):\n    \"\"\"\n    Returns a boolean indicating if all arguments are not None.\n    \"\"\"\n    for arg in args:\n        if arg is None:\n            return False\n    return True\n\n\ndef count_not_none(*args):\n    \"\"\"\n    Returns the count of arguments that are not None.\n    \"\"\"\n    return sum(x is not None for x in args)\n\n\ndef try_sort(iterable):\n    listed = list(iterable)\n    try:\n        return sorted(listed)\n    except Exception:\n        return listed\n\n\ndef dict_keys_to_ordered_list(mapping):\n    # when pandas drops support for Python < 3.6, this function\n    # can be replaced by a simple list(mapping.keys())\n    if PY36 or isinstance(mapping, OrderedDict):\n        keys = list(mapping.keys())\n    else:\n        keys = try_sort(mapping)\n    return keys\n\n\ndef asarray_tuplesafe(values, dtype=None):\n\n    if not (isinstance(values, (list, tuple)) or hasattr(values, '__array__')):\n        values = list(values)\n    elif isinstance(values, ABCIndexClass):\n        return values.values\n\n    if isinstance(values, list) and dtype in [np.object_, object]:\n        return construct_1d_object_array_from_listlike(values)\n\n    result = np.asarray(values, dtype=dtype)\n\n    if issubclass(result.dtype.type, str):\n        result = np.asarray(values, dtype=object)\n\n    if result.ndim == 2:\n        # Avoid building an array of arrays:\n        # TODO: verify whether any path hits this except #18819 (invalid)\n        values = [tuple(x) for x in values]\n        result = construct_1d_object_array_from_listlike(values)\n\n    return result\n\n\ndef index_labels_to_array(labels, dtype=None):\n    \"\"\"\n    Transform label or iterable of labels to array, for use in Index.\n\n    Parameters\n    ----------\n    dtype : dtype\n        If specified, use as dtype of the resulting array, otherwise infer.\n\n    Returns\n    -------\n    array\n    \"\"\"\n    if isinstance(labels, (str, tuple)):\n        labels = [labels]\n\n    if not isinstance(labels, (list, np.ndarray)):\n        try:\n            labels = list(labels)\n        except TypeError:  # non-iterable\n            labels = [labels]\n\n    labels = asarray_tuplesafe(labels, dtype=dtype)\n\n    return labels\n\n\ndef maybe_make_list(obj):\n    if obj is not None and not isinstance(obj, (tuple, list)):\n        return [obj]\n    return obj\n\n\ndef maybe_iterable_to_list(obj: Union[Iterable, Any]) -> Union[list, Any]:\n    \"\"\"\n    If obj is Iterable but not list-like, consume into list.\n    \"\"\"\n    if isinstance(obj, abc.Iterable) and not isinstance(obj, abc.Sized):\n        return list(obj)\n    return obj\n\n\ndef is_null_slice(obj):\n    \"\"\"\n    We have a null slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start is None and\n            obj.stop is None and obj.step is None)\n\n\ndef is_true_slices(l):\n    \"\"\"\n    Find non-trivial slices in \"l\": return a list of booleans with same length.\n    \"\"\"\n    return [isinstance(k, slice) and not is_null_slice(k) for k in l]\n\n\n# TODO: used only once in indexing; belongs elsewhere?\ndef is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)\n\n\ndef get_callable_name(obj):\n    # typical case has name\n    if hasattr(obj, '__name__'):\n        return getattr(obj, '__name__')\n    # some objects don't; could recurse\n    if isinstance(obj, partial):\n        return get_callable_name(obj.func)\n    # fall back to class name\n    if hasattr(obj, '__call__'):\n        return obj.__class__.__name__\n    # everything failed (probably because the argument\n    # wasn't actually callable); we return None\n    # instead of the empty string in this case to allow\n    # distinguishing between no name and a name of ''\n    return None\n\n\ndef apply_if_callable(maybe_callable, obj, **kwargs):\n    \"\"\"\n    Evaluate possibly callable input using obj and kwargs if it is callable,\n    otherwise return as it is.\n\n    Parameters\n    ----------\n    maybe_callable : possibly a callable\n    obj : NDFrame\n    **kwargs\n    \"\"\"\n\n    if callable(maybe_callable):\n        return maybe_callable(obj, **kwargs)\n\n    return maybe_callable\n\n\ndef dict_compat(d):\n    \"\"\"\n    Helper function to convert datetimelike-keyed dicts\n    to Timestamp-keyed dict.\n\n    Parameters\n    ----------\n    d: dict like object\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n    return {maybe_box_datetimelike(key): value for key, value in d.items()}\n\n\ndef standardize_mapping(into):\n    \"\"\"\n    Helper function to standardize a supplied mapping.\n\n    .. versionadded:: 0.21.0\n\n    Parameters\n    ----------\n    into : instance or subclass of collections.abc.Mapping\n        Must be a class, an initialized collections.defaultdict,\n        or an instance of a collections.abc.Mapping subclass.\n\n    Returns\n    -------\n    mapping : a collections.abc.Mapping subclass or other constructor\n        a callable object that can accept an iterator to create\n        the desired Mapping.\n\n    See Also\n    --------\n    DataFrame.to_dict\n    Series.to_dict\n    \"\"\"\n    if not inspect.isclass(into):\n        if isinstance(into, collections.defaultdict):\n            return partial(\n                collections.defaultdict, into.default_factory)\n        into = type(into)\n    if not issubclass(into, abc.Mapping):\n        raise TypeError('unsupported type: {into}'.format(into=into))\n    elif into == collections.defaultdict:\n        raise TypeError(\n            'to_dict() only accepts initialized defaultdicts')\n    return into\n\n\ndef random_state(state=None):\n    \"\"\"\n    Helper function for processing random_state arguments.\n\n    Parameters\n    ----------\n    state : int, np.random.RandomState, None.\n        If receives an int, passes to np.random.RandomState() as seed.\n        If receives an np.random.RandomState object, just returns object.\n        If receives `None`, returns np.random.\n        If receives anything else, raises an informative ValueError.\n        Default None.\n\n    Returns\n    -------\n    np.random.RandomState\n    \"\"\"\n\n    if is_integer(state):\n        return np.random.RandomState(state)\n    elif isinstance(state, np.random.RandomState):\n        return state\n    elif state is None:\n        return np.random\n    else:\n        raise ValueError(\"random_state must be an integer, a numpy \"\n                         \"RandomState, or None\")\n\n\ndef _pipe(obj, func, *args, **kwargs):\n    \"\"\"\n    Apply a function ``func`` to object ``obj`` either by passing obj as the\n    first argument to the function or, in the case that the func is a tuple,\n    interpret the first element of the tuple as a function and pass the obj to\n    that function as a keyword argument whose key is the value of the second\n    element of the tuple.\n\n    Parameters\n    ----------\n    func : callable or tuple of (callable, string)\n        Function to apply to this object or, alternatively, a\n        ``(callable, data_keyword)`` tuple where ``data_keyword`` is a\n        string indicating the keyword of `callable`` that expects the\n        object.\n    args : iterable, optional\n        positional arguments passed into ``func``.\n    kwargs : dict, optional\n        a dictionary of keyword arguments passed into ``func``.\n\n    Returns\n    -------\n    object : the return type of ``func``.\n    \"\"\"\n    if isinstance(func, tuple):\n        func, target = func\n        if target in kwargs:\n            msg = '%s is both the pipe target and a keyword argument' % target\n            raise ValueError(msg)\n        kwargs[target] = obj\n        return func(*args, **kwargs)\n    else:\n        return func(obj, *args, **kwargs)\n\n\ndef _get_rename_function(mapper):\n    \"\"\"\n    Returns a function that will map names/labels, dependent if mapper\n    is a dict, Series or just a function.\n    \"\"\"\n    if isinstance(mapper, (abc.Mapping, ABCSeries)):\n\n        def f(x):\n            if x in mapper:\n                return mapper[x]\n            else:\n                return x\n    else:\n        f = mapper\n\n    return f\n",
          "file_after": "\"\"\"\nMisc tools for implementing data structures\n\nNote: pandas.core.common is *not* part of the public API.\n\"\"\"\n\nimport collections\nfrom collections import OrderedDict, abc\nfrom datetime import datetime, timedelta\nfrom functools import partial\nimport inspect\nfrom typing import Any, Iterable, Union\n\nimport numpy as np\n\nfrom pandas._libs import lib, tslibs\nfrom pandas.compat import PY36\n\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.common import (\n    is_array_like,\n    is_bool_dtype,\n    is_extension_array_dtype,\n    is_integer,\n)\nfrom pandas.core.dtypes.generic import ABCIndex, ABCIndexClass, ABCSeries\nfrom pandas.core.dtypes.inference import _iterable_not_string\nfrom pandas.core.dtypes.missing import isna, isnull, notnull  # noqa\n\n\nclass SettingWithCopyError(ValueError):\n    pass\n\n\nclass SettingWithCopyWarning(Warning):\n    pass\n\n\ndef flatten(l):\n    \"\"\"\n    Flatten an arbitrarily nested sequence.\n\n    Parameters\n    ----------\n    l : sequence\n        The non string sequence to flatten\n\n    Notes\n    -----\n    This doesn't consider strings sequences.\n\n    Returns\n    -------\n    flattened : generator\n    \"\"\"\n    for el in l:\n        if _iterable_not_string(el):\n            for s in flatten(el):\n                yield s\n        else:\n            yield el\n\n\ndef consensus_name_attr(objs):\n    name = objs[0].name\n    for obj in objs[1:]:\n        try:\n            if obj.name != name:\n                name = None\n        except ValueError:\n            name = None\n    return name\n\n\ndef maybe_box(indexer, values, obj, key):\n\n    # if we have multiples coming back, box em\n    if isinstance(values, np.ndarray):\n        return obj[indexer.get_loc(key)]\n\n    # return the value\n    return values\n\n\ndef maybe_box_datetimelike(value):\n    # turn a datetime like into a Timestamp/timedelta as needed\n\n    if isinstance(value, (np.datetime64, datetime)):\n        value = tslibs.Timestamp(value)\n    elif isinstance(value, (np.timedelta64, timedelta)):\n        value = tslibs.Timedelta(value)\n\n    return value\n\n\nvalues_from_object = lib.values_from_object\n\n\ndef is_bool_indexer(key: Any) -> bool:\n    \"\"\"\n    Check whether `key` is a valid boolean indexer.\n\n    Parameters\n    ----------\n    key : Any\n        Only list-likes may be considered boolean indexers.\n        All other types are not considered a boolean indexer.\n        For array-like input, boolean ndarrays or ExtensionArrays\n        with ``_is_boolean`` set are considered boolean indexers.\n\n    Returns\n    -------\n    bool\n\n    Raises\n    ------\n    ValueError\n        When the array is an object-dtype ndarray or ExtensionArray\n        and contains missing values.\n    \"\"\"\n    na_msg = \"cannot index with vector containing NA / NaN values\"\n    if isinstance(key, (ABCSeries, np.ndarray, ABCIndex)) or (\n        is_array_like(key) and is_extension_array_dtype(key.dtype)\n    ):\n        if key.dtype == np.object_:\n            key = np.asarray(values_from_object(key))\n\n            if not lib.is_bool_array(key):\n                if isna(key).any():\n                    raise ValueError(na_msg)\n                return False\n            return True\n        elif is_bool_dtype(key.dtype):\n            # an ndarray with bool-dtype by definition has no missing values.\n            # So we only need to check for NAs in ExtensionArrays\n            if is_extension_array_dtype(key.dtype):\n                if np.any(key.isna()):\n                    raise ValueError(na_msg)\n            return True\n    elif isinstance(key, list):\n        try:\n            arr = np.asarray(key)\n            return arr.dtype == np.bool_ and len(arr) == len(key)\n        except TypeError:  # pragma: no cover\n            return False\n\n    return False\n\n\ndef cast_scalar_indexer(val):\n    \"\"\"\n    To avoid numpy DeprecationWarnings, cast float to integer where valid.\n\n    Parameters\n    ----------\n    val : scalar\n\n    Returns\n    -------\n    outval : scalar\n    \"\"\"\n    # assumes lib.is_scalar(val)\n    if lib.is_float(val) and val == int(val):\n        return int(val)\n    return val\n\n\ndef _not_none(*args):\n    \"\"\"\n    Returns a generator consisting of the arguments that are not None.\n    \"\"\"\n    return (arg for arg in args if arg is not None)\n\n\ndef _any_none(*args):\n    \"\"\"\n    Returns a boolean indicating if any argument is None.\n    \"\"\"\n    for arg in args:\n        if arg is None:\n            return True\n    return False\n\n\ndef _all_none(*args):\n    \"\"\"\n    Returns a boolean indicating if all arguments are None.\n    \"\"\"\n    for arg in args:\n        if arg is not None:\n            return False\n    return True\n\n\ndef _any_not_none(*args):\n    \"\"\"\n    Returns a boolean indicating if any argument is not None.\n    \"\"\"\n    for arg in args:\n        if arg is not None:\n            return True\n    return False\n\n\ndef _all_not_none(*args):\n    \"\"\"\n    Returns a boolean indicating if all arguments are not None.\n    \"\"\"\n    for arg in args:\n        if arg is None:\n            return False\n    return True\n\n\ndef count_not_none(*args):\n    \"\"\"\n    Returns the count of arguments that are not None.\n    \"\"\"\n    return sum(x is not None for x in args)\n\n\ndef try_sort(iterable):\n    listed = list(iterable)\n    try:\n        return sorted(listed)\n    except Exception:\n        return listed\n\n\ndef dict_keys_to_ordered_list(mapping):\n    # when pandas drops support for Python < 3.6, this function\n    # can be replaced by a simple list(mapping.keys())\n    if PY36 or isinstance(mapping, OrderedDict):\n        keys = list(mapping.keys())\n    else:\n        keys = try_sort(mapping)\n    return keys\n\n\ndef asarray_tuplesafe(values, dtype=None):\n\n    if not (isinstance(values, (list, tuple)) or hasattr(values, \"__array__\")):\n        values = list(values)\n    elif isinstance(values, ABCIndexClass):\n        return values.values\n\n    if isinstance(values, list) and dtype in [np.object_, object]:\n        return construct_1d_object_array_from_listlike(values)\n\n    result = np.asarray(values, dtype=dtype)\n\n    if issubclass(result.dtype.type, str):\n        result = np.asarray(values, dtype=object)\n\n    if result.ndim == 2:\n        # Avoid building an array of arrays:\n        # TODO: verify whether any path hits this except #18819 (invalid)\n        values = [tuple(x) for x in values]\n        result = construct_1d_object_array_from_listlike(values)\n\n    return result\n\n\ndef index_labels_to_array(labels, dtype=None):\n    \"\"\"\n    Transform label or iterable of labels to array, for use in Index.\n\n    Parameters\n    ----------\n    dtype : dtype\n        If specified, use as dtype of the resulting array, otherwise infer.\n\n    Returns\n    -------\n    array\n    \"\"\"\n    if isinstance(labels, (str, tuple)):\n        labels = [labels]\n\n    if not isinstance(labels, (list, np.ndarray)):\n        try:\n            labels = list(labels)\n        except TypeError:  # non-iterable\n            labels = [labels]\n\n    labels = asarray_tuplesafe(labels, dtype=dtype)\n\n    return labels\n\n\ndef maybe_make_list(obj):\n    if obj is not None and not isinstance(obj, (tuple, list)):\n        return [obj]\n    return obj\n\n\ndef maybe_iterable_to_list(obj: Union[Iterable, Any]) -> Union[list, Any]:\n    \"\"\"\n    If obj is Iterable but not list-like, consume into list.\n    \"\"\"\n    if isinstance(obj, abc.Iterable) and not isinstance(obj, abc.Sized):\n        return list(obj)\n    return obj\n\n\ndef is_null_slice(obj):\n    \"\"\"\n    We have a null slice.\n    \"\"\"\n    return (\n        isinstance(obj, slice)\n        and obj.start is None\n        and obj.stop is None\n        and obj.step is None\n    )\n\n\ndef is_true_slices(l):\n    \"\"\"\n    Find non-trivial slices in \"l\": return a list of booleans with same length.\n    \"\"\"\n    return [isinstance(k, slice) and not is_null_slice(k) for k in l]\n\n\n# TODO: used only once in indexing; belongs elsewhere?\ndef is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (\n        isinstance(obj, slice) and obj.start == 0 and obj.stop == l and obj.step is None\n    )\n\n\ndef get_callable_name(obj):\n    # typical case has name\n    if hasattr(obj, \"__name__\"):\n        return getattr(obj, \"__name__\")\n    # some objects don't; could recurse\n    if isinstance(obj, partial):\n        return get_callable_name(obj.func)\n    # fall back to class name\n    if hasattr(obj, \"__call__\"):\n        return obj.__class__.__name__\n    # everything failed (probably because the argument\n    # wasn't actually callable); we return None\n    # instead of the empty string in this case to allow\n    # distinguishing between no name and a name of ''\n    return None\n\n\ndef apply_if_callable(maybe_callable, obj, **kwargs):\n    \"\"\"\n    Evaluate possibly callable input using obj and kwargs if it is callable,\n    otherwise return as it is.\n\n    Parameters\n    ----------\n    maybe_callable : possibly a callable\n    obj : NDFrame\n    **kwargs\n    \"\"\"\n\n    if callable(maybe_callable):\n        return maybe_callable(obj, **kwargs)\n\n    return maybe_callable\n\n\ndef dict_compat(d):\n    \"\"\"\n    Helper function to convert datetimelike-keyed dicts\n    to Timestamp-keyed dict.\n\n    Parameters\n    ----------\n    d: dict like object\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n    return {maybe_box_datetimelike(key): value for key, value in d.items()}\n\n\ndef standardize_mapping(into):\n    \"\"\"\n    Helper function to standardize a supplied mapping.\n\n    .. versionadded:: 0.21.0\n\n    Parameters\n    ----------\n    into : instance or subclass of collections.abc.Mapping\n        Must be a class, an initialized collections.defaultdict,\n        or an instance of a collections.abc.Mapping subclass.\n\n    Returns\n    -------\n    mapping : a collections.abc.Mapping subclass or other constructor\n        a callable object that can accept an iterator to create\n        the desired Mapping.\n\n    See Also\n    --------\n    DataFrame.to_dict\n    Series.to_dict\n    \"\"\"\n    if not inspect.isclass(into):\n        if isinstance(into, collections.defaultdict):\n            return partial(collections.defaultdict, into.default_factory)\n        into = type(into)\n    if not issubclass(into, abc.Mapping):\n        raise TypeError(\"unsupported type: {into}\".format(into=into))\n    elif into == collections.defaultdict:\n        raise TypeError(\"to_dict() only accepts initialized defaultdicts\")\n    return into\n\n\ndef random_state(state=None):\n    \"\"\"\n    Helper function for processing random_state arguments.\n\n    Parameters\n    ----------\n    state : int, np.random.RandomState, None.\n        If receives an int, passes to np.random.RandomState() as seed.\n        If receives an np.random.RandomState object, just returns object.\n        If receives `None`, returns np.random.\n        If receives anything else, raises an informative ValueError.\n        Default None.\n\n    Returns\n    -------\n    np.random.RandomState\n    \"\"\"\n\n    if is_integer(state):\n        return np.random.RandomState(state)\n    elif isinstance(state, np.random.RandomState):\n        return state\n    elif state is None:\n        return np.random\n    else:\n        raise ValueError(\n            \"random_state must be an integer, a numpy \" \"RandomState, or None\"\n        )\n\n\ndef _pipe(obj, func, *args, **kwargs):\n    \"\"\"\n    Apply a function ``func`` to object ``obj`` either by passing obj as the\n    first argument to the function or, in the case that the func is a tuple,\n    interpret the first element of the tuple as a function and pass the obj to\n    that function as a keyword argument whose key is the value of the second\n    element of the tuple.\n\n    Parameters\n    ----------\n    func : callable or tuple of (callable, string)\n        Function to apply to this object or, alternatively, a\n        ``(callable, data_keyword)`` tuple where ``data_keyword`` is a\n        string indicating the keyword of `callable`` that expects the\n        object.\n    args : iterable, optional\n        positional arguments passed into ``func``.\n    kwargs : dict, optional\n        a dictionary of keyword arguments passed into ``func``.\n\n    Returns\n    -------\n    object : the return type of ``func``.\n    \"\"\"\n    if isinstance(func, tuple):\n        func, target = func\n        if target in kwargs:\n            msg = \"%s is both the pipe target and a keyword argument\" % target\n            raise ValueError(msg)\n        kwargs[target] = obj\n        return func(*args, **kwargs)\n    else:\n        return func(obj, *args, **kwargs)\n\n\ndef _get_rename_function(mapper):\n    \"\"\"\n    Returns a function that will map names/labels, dependent if mapper\n    is a dict, Series or just a function.\n    \"\"\"\n    if isinstance(mapper, (abc.Mapping, ABCSeries)):\n\n        def f(x):\n            if x in mapper:\n                return mapper[x]\n            else:\n                return x\n\n    else:\n        f = mapper\n\n    return f\n",
          "file_patch": "@@ -18,7 +18,11 @@ from pandas.compat import PY36\n \n from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\n from pandas.core.dtypes.common import (\n-    is_array_like, is_bool_dtype, is_extension_array_dtype, is_integer)\n+    is_array_like,\n+    is_bool_dtype,\n+    is_extension_array_dtype,\n+    is_integer,\n+)\n from pandas.core.dtypes.generic import ABCIndex, ABCIndexClass, ABCSeries\n from pandas.core.dtypes.inference import _iterable_not_string\n from pandas.core.dtypes.missing import isna, isnull, notnull  # noqa\n@@ -114,9 +118,10 @@ def is_bool_indexer(key: Any) -> bool:\n         When the array is an object-dtype ndarray or ExtensionArray\n         and contains missing values.\n     \"\"\"\n-    na_msg = 'cannot index with vector containing NA / NaN values'\n-    if (isinstance(key, (ABCSeries, np.ndarray, ABCIndex)) or\n-            (is_array_like(key) and is_extension_array_dtype(key.dtype))):\n+    na_msg = \"cannot index with vector containing NA / NaN values\"\n+    if isinstance(key, (ABCSeries, np.ndarray, ABCIndex)) or (\n+        is_array_like(key) and is_extension_array_dtype(key.dtype)\n+    ):\n         if key.dtype == np.object_:\n             key = np.asarray(values_from_object(key))\n \n@@ -234,7 +239,7 @@ def dict_keys_to_ordered_list(mapping):\n \n def asarray_tuplesafe(values, dtype=None):\n \n-    if not (isinstance(values, (list, tuple)) or hasattr(values, '__array__')):\n+    if not (isinstance(values, (list, tuple)) or hasattr(values, \"__array__\")):\n         values = list(values)\n     elif isinstance(values, ABCIndexClass):\n         return values.values\n@@ -302,8 +307,12 @@ def is_null_slice(obj):\n     \"\"\"\n     We have a null slice.\n     \"\"\"\n-    return (isinstance(obj, slice) and obj.start is None and\n-            obj.stop is None and obj.step is None)\n+    return (\n+        isinstance(obj, slice)\n+        and obj.start is None\n+        and obj.stop is None\n+        and obj.step is None\n+    )\n \n \n def is_true_slices(l):\n@@ -318,19 +327,20 @@ def is_full_slice(obj, l):\n     \"\"\"\n     We have a full length slice.\n     \"\"\"\n-    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n-            obj.step is None)\n+    return (\n+        isinstance(obj, slice) and obj.start == 0 and obj.stop == l and obj.step is None\n+    )\n \n \n def get_callable_name(obj):\n     # typical case has name\n-    if hasattr(obj, '__name__'):\n-        return getattr(obj, '__name__')\n+    if hasattr(obj, \"__name__\"):\n+        return getattr(obj, \"__name__\")\n     # some objects don't; could recurse\n     if isinstance(obj, partial):\n         return get_callable_name(obj.func)\n     # fall back to class name\n-    if hasattr(obj, '__call__'):\n+    if hasattr(obj, \"__call__\"):\n         return obj.__class__.__name__\n     # everything failed (probably because the argument\n     # wasn't actually callable); we return None\n@@ -399,14 +409,12 @@ def standardize_mapping(into):\n     \"\"\"\n     if not inspect.isclass(into):\n         if isinstance(into, collections.defaultdict):\n-            return partial(\n-                collections.defaultdict, into.default_factory)\n+            return partial(collections.defaultdict, into.default_factory)\n         into = type(into)\n     if not issubclass(into, abc.Mapping):\n-        raise TypeError('unsupported type: {into}'.format(into=into))\n+        raise TypeError(\"unsupported type: {into}\".format(into=into))\n     elif into == collections.defaultdict:\n-        raise TypeError(\n-            'to_dict() only accepts initialized defaultdicts')\n+        raise TypeError(\"to_dict() only accepts initialized defaultdicts\")\n     return into\n \n \n@@ -435,8 +443,9 @@ def random_state(state=None):\n     elif state is None:\n         return np.random\n     else:\n-        raise ValueError(\"random_state must be an integer, a numpy \"\n-                         \"RandomState, or None\")\n+        raise ValueError(\n+            \"random_state must be an integer, a numpy \" \"RandomState, or None\"\n+        )\n \n \n def _pipe(obj, func, *args, **kwargs):\n@@ -466,7 +475,7 @@ def _pipe(obj, func, *args, **kwargs):\n     if isinstance(func, tuple):\n         func, target = func\n         if target in kwargs:\n-            msg = '%s is both the pipe target and a keyword argument' % target\n+            msg = \"%s is both the pipe target and a keyword argument\" % target\n             raise ValueError(msg)\n         kwargs[target] = obj\n         return func(*args, **kwargs)\n@@ -486,6 +495,7 @@ def _get_rename_function(mapper):\n                 return mapper[x]\n             else:\n                 return x\n+\n     else:\n         f = mapper\n \n",
          "files_name_in_blame_commit": [
            "test_index_col.py",
            "generate_legacy_storage_files.py",
            "offsets.py",
            "test_timedeltas.py",
            "scipy_sparse.py",
            "test_na_values.py",
            "_optional.py",
            "test_xlrd.py",
            "groupby.py",
            "datetimes.py",
            "parquet.py",
            "test_qcut.py",
            "style.py",
            "test_accessor.py",
            "join_merge.py",
            "test_sorted.py",
            "test_multilevel.py",
            "test_integrity.py",
            "timestamp.py",
            "test_holiday.py",
            "test_assert_extension_array_equal.py",
            "series_methods.py",
            "test_indexing_slow.py",
            "test_readlines.py",
            "find_commits_touching_func.py",
            "test_index_as_string.py",
            "test_config.py",
            "pandas_vb_common.py",
            "test_operators.py",
            "test_reshape.py",
            "resample.py",
            "test_assert_series_equal.py",
            "period.py",
            "test_read_fwf.py",
            "test_lib.py",
            "pickle_compat.py",
            "test_melt.py",
            "frame.py",
            "util.py",
            "test_json_table_schema.py",
            "_util.py",
            "test_ujson.py",
            "test_compat.py",
            "test_parse_dates.py",
            "test_validate.py",
            "test_eval.py",
            "test_reductions.py",
            "numeric.py",
            "test_multi_thread.py",
            "test_assert_numpy_array_equal.py",
            "test_subclass.py",
            "concat.py",
            "test_pandas.py",
            "test_offsets_properties.py",
            "test_format.py",
            "test_printing.py",
            "ops.py",
            "console.py",
            "test_api.py",
            "test_filters.py",
            "test_pytables.py",
            "test_xs.py",
            "test_datetime_index.py",
            "test_assert_categorical_equal.py",
            "inference.py",
            "test_contains.py",
            "test_parsing.py",
            "test_scalar_compat.py",
            "test_pickle.py",
            "versioneer.py",
            "test_sas7bdat.py",
            "test_rank.py",
            "test_asof.py",
            "test_missing.py",
            "test_normalize_date.py",
            "latex.py",
            "test_period_asfreq.py",
            "test_parse_iso8601.py",
            "test_xlsxwriter.py",
            "attrs_caching.py",
            "category.py",
            "test_observance.py",
            "_validators.py",
            "test_libsparse.py",
            "test_validate_args.py",
            "interval.py",
            "test_converter.py",
            "__init__.py",
            "test_join.py",
            "dtype.py",
            "tile.py",
            "test_merge_asof.py",
            "tools.py",
            "test_deprecate_kwarg.py",
            "test_spss.py",
            "test_indexing.py",
            "test_range.py",
            "table_schema.py",
            "test_normalize.py",
            "pickle.py",
            "test_extension.py",
            "_typing.py",
            "test_axis_select_reindex.py",
            "_xlrd.py",
            "test_to_from_scipy.py",
            "test_construct_from_scalar.py",
            "frozen.py",
            "test_sort_values_level_as_str.py",
            "test_sparse.py",
            "test_io.py",
            "test_libfrequencies.py",
            "test_numpy.py",
            "methods.py",
            "test_mangle_dupes.py",
            "merge.py",
            "test_to_latex.py",
            "test_localization.py",
            "test_header.py",
            "test_timedelta.py",
            "test_groupby.py",
            "test_html.py",
            "test_datetimes.py",
            "test_equivalence.py",
            "csvs.py",
            "setitem.py",
            "test_arithmetic.py",
            "test_expressions.py",
            "test_window.py",
            "sparse.py",
            "test_grouping.py",
            "test_dialect.py",
            "test_errors.py",
            "sasreader.py",
            "conftest.py",
            "bool.py",
            "holiday.py",
            "test_getitem.py",
            "test_register_accessor.py",
            "test_whitelist.py",
            "download_wheels.py",
            "test_assert_produces_warning.py",
            "test_validate_docstrings.py",
            "test_scalar.py",
            "expr.py",
            "test_quantile.py",
            "converter.py",
            "test_unpack_raw.py",
            "html.py",
            "series.py",
            "test_to_html.py",
            "test_validate_args_and_kwargs.py",
            "function.py",
            "test_seq.py",
            "test_comparisons.py",
            "stat_ops.py",
            "test_infer_datetimelike.py",
            "exceptions.py",
            "test_case.py",
            "test_pack.py",
            "test_period_index.py",
            "sas_xport.py",
            "test_upcast.py",
            "test_buffer.py",
            "test_construct_ndarray.py",
            "config.py",
            "test_aggregate.py",
            "test_sorting.py",
            "excel.py",
            "format.py",
            "test_astype.py",
            "_ranges.py",
            "generate_pip_deps_from_conda.py",
            "test_quoting.py",
            "test_converters.py",
            "test_backend.py",
            "setup.py",
            "test_mutate_columns.py",
            "test_timestamp.py",
            "test_downcast.py",
            "test_loc.py",
            "getitem.py",
            "test_partial_slicing.py",
            "test_yqm_offsets.py",
            "test_array_to_datetime.py",
            "test_interval_new.py",
            "test_css.py",
            "test_interval.py",
            "test_dtype.py",
            "test_bin_groupby.py",
            "algorithms.py",
            "test_limits.py",
            "indexing.py",
            "test_gbq.py",
            "_print_versions.py",
            "test_names.py",
            "test_skiprows.py",
            "accessor.py",
            "hashing.py",
            "test_timezones.py",
            "test_transform.py",
            "test_gcs.py",
            "test_fiscal.py",
            "eval.py",
            "test_obj.py",
            "test_datetime_values.py",
            "test_writers.py",
            "test_pivot.py",
            "test_block_internals.py",
            "test_except.py",
            "display.py",
            "gcs.py",
            "announce.py",
            "test_timegrouper.py",
            "test_construct_object_arr.py",
            "frame_methods.py",
            "test_time_grouper.py",
            "array_.py",
            "compat.py",
            "test_xport.py",
            "test_to_excel.py",
            "test_merge_ordered.py",
            "test_assert_almost_equal.py",
            "test_alter_index.py",
            "test_period_range.py",
            "test_get_set.py",
            "test_date_converters.py",
            "index.py",
            "test_setitem.py",
            "integer.py",
            "numpy_.py",
            "test_callable.py",
            "gil.py",
            "test_s3.py",
            "test_value_counts.py",
            "reduce.py",
            "test_take.py",
            "timeseries.py",
            "_version.py",
            "test_other.py",
            "test_cut.py",
            "test_series.py",
            "test_numpy_compat.py",
            "managers.py",
            "api.py",
            "test_unsupported.py",
            "pytables.py",
            "timedelta.py",
            "core.py",
            "test_merge_index_as_string.py",
            "test_misc.py",
            "binary_ops.py",
            "test_hist_method.py",
            "test_stata.py",
            "test_internals.py",
            "test_optional_dependency.py",
            "test_convert_to.py",
            "packers.py",
            "test_move.py",
            "test_base.py",
            "test_replace.py",
            "test_boxplot_method.py",
            "windows.py",
            "test_promote.py",
            "test_floats.py",
            "test_python_parser_only.py",
            "feather_format.py",
            "test_decimal.py",
            "test_style.py",
            "spss.py",
            "test_integer.py",
            "test_interval_tree.py",
            "test_frame.py",
            "test_setops.py",
            "_odfreader.py",
            "_decorators.py",
            "test_validate_kwargs.py",
            "contributors.py",
            "test_comment.py",
            "test_reindex.py",
            "_doctools.py",
            "test_conversion.py",
            "test_sql.py",
            "_test_decorators.py",
            "date_converters.py",
            "ctors.py",
            "test_ix.py",
            "json.py",
            "test_rendering.py",
            "test_safe_import.py",
            "test_constructors.py",
            "test_downstream.py",
            "test_inference.py",
            "test_iloc.py",
            "multiindex_object.py",
            "align.py",
            "test_construction.py",
            "test_resample_api.py",
            "test_function.py",
            "_base.py",
            "test_textreader.py",
            "engines.py",
            "test_assert_interval_array_equal.py",
            "test_readers.py",
            "test_slice.py",
            "test_subtype.py",
            "test_openpyxl.py",
            "test_unary_ops.py",
            "index_object.py",
            "base.py",
            "test_calendar.py",
            "_core.py",
            "dates.py",
            "test_partial_indexing.py",
            "pandas_logo.py",
            "test_nanops.py",
            "offset.py",
            "test_date_range.py",
            "test_nth.py",
            "test_assert_frame_equal.py",
            "test_json.py",
            "strings.py",
            "csv.py",
            "conf.py",
            "datetimelike.py",
            "timedeltas.py",
            "expressions.py",
            "test_offsets.py",
            "stata.py",
            "test_coercion.py",
            "gbq.py",
            "test_combine_concat.py",
            "scope.py",
            "test_concat.py",
            "rolling.py",
            "construction.py",
            "test_numeric.py",
            "check.py",
            "grouper.py",
            "melt.py",
            "test_chaining_and_caching.py",
            "test_copy.py",
            "test_util.py",
            "test_categorical.py",
            "test_bool.py",
            "test_alter_axes.py",
            "test_period.py",
            "test_network.py",
            "test_ufunc.py",
            "clipboards.py",
            "_misc.py",
            "s3.py",
            "test_drop.py",
            "test_to_csv.py",
            "test_label_or_level_utils.py",
            "multi.py",
            "msgpack.py",
            "replace.py",
            "test_timedelta_range.py",
            "test_generic.py",
            "test_xlwt.py",
            "test_multiindex.py",
            "test_datetime.py",
            "generic.py",
            "sas_constants.py",
            "cast.py",
            "test_usecols.py",
            "_depr_module.py",
            "parsers.py",
            "printing.py",
            "test_duplicates.py",
            "_xlsxwriter.py",
            "test_nat.py",
            "constructors.py",
            "css.py",
            "test_asfreq.py",
            "test_tools.py",
            "nanops.py",
            "chainmap.py",
            "test_ops.py",
            "test_arithmetics.py",
            "localization.py",
            "test_ticks.py",
            "blocks.py",
            "merge-pr.py",
            "test_c_parser_only.py",
            "test_datetime64.py",
            "test_resampler_grouper.py",
            "test_repr.py",
            "reshape.py",
            "test_object.py",
            "test_repr_info.py",
            "test_hashing.py",
            "test_eng_formatting.py",
            "test_clipboard.py",
            "test_common.py",
            "hist.py",
            "test_warnings.py",
            "test_category.py",
            "sas.py",
            "plotting.py",
            "test_nonunique_indexes.py",
            "frequencies.py",
            "test_compression.py",
            "test_assert_index_equal.py",
            "test_sequnpack.py",
            "test_frozen.py",
            "test_console.py",
            "test_indexing_engines.py",
            "test_algos.py",
            "test_parquet.py",
            "test_to_offset.py",
            "test_interval_range.py",
            "sas7bdat.py",
            "range.py",
            "test_boolean.py",
            "test_read_size.py",
            "test_federal.py",
            "test_cython.py",
            "boxplot.py",
            "pivot.py",
            "make.py",
            "print_skipped.py",
            "normalize.py",
            "test_merge.py",
            "test_apply.py",
            "_tester.py",
            "testing.py",
            "test_monotonic.py",
            "test_multi.py",
            "test_deprecate.py",
            "sorting.py",
            "test_set_ops.py",
            "test_freq_code.py",
            "apply.py",
            "accessors.py",
            "test_timedelta64.py",
            "validate_docstrings.py",
            "test_stat_reductions.py",
            "test_datetimelike.py",
            "test_packers.py",
            "test_dtypes.py",
            "test_analytics.py",
            "test_counting.py",
            "test_find_common_type.py",
            "test_query_eval.py",
            "test_types.py",
            "frame_ctor.py",
            "test_unpack.py",
            "hdf.py",
            "misc.py",
            "common.py",
            "test_timeseries.py",
            "test_partial.py",
            "config_init.py",
            "interface.py",
            "io.py",
            "categoricals.py",
            "reindex.py",
            "sql.py",
            "test_infer_dtype.py",
            "window.py",
            "array.py",
            "test_sas.py",
            "_openpyxl.py",
            "test_external_block.py",
            "indexing_engines.py",
            "categorical.py",
            "_xlwt.py",
            "test_ccalendar.py",
            "missing.py",
            "test_liboffsets.py",
            "test_feather.py",
            "test_newspec.py",
            "test_strings.py",
            "test_array.py",
            "test_odf.py",
            "test_formats.py",
            "test_constructor.py",
            "reshaping.py",
            "dtypes.py",
            "test_union_categoricals.py"
          ]
        }
      },
      "88318e3066b5394a007d2ffaab33d866c2f066a7": {
        "commit": {
          "commit_id": "88318e3066b5394a007d2ffaab33d866c2f066a7",
          "commit_message": "DOC: Fix validation type error RT04 (#25107) (#25129)",
          "commit_author": "Kara de la Marck",
          "commit_date": "2019-02-04 07:56:02",
          "commit_parent": "d3c9d6e67491caf9046b0f8efd2d8d153b52b8e3"
        },
        "function": {
          "function_name": "is_string_dtype",
          "function_code_before": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
          "function_code_after": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
          "function_before_start_line": 605,
          "function_before_end_line": 636,
          "function_after_start_line": 611,
          "function_after_end_line": 643,
          "function_before_token_count": 15,
          "function_after_token_count": 15,
          "functions_name_modified_file": [
            "is_numeric_v_string_like",
            "is_datetime64_ns_dtype",
            "is_period",
            "is_any_int_dtype",
            "ensure_float",
            "is_numeric_dtype",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "_is_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_categorical",
            "is_dtype_union_equal",
            "is_datetime64_any_dtype",
            "_is_dtype_type",
            "is_float_dtype",
            "is_bool_dtype",
            "is_datetimelike_v_object",
            "is_sparse",
            "is_datetimetz",
            "is_interval_dtype",
            "infer_dtype_from_object",
            "ensure_categorical",
            "_validate_date_like_dtype",
            "is_datetimelike",
            "is_scipy_sparse",
            "classes_and_not_datetimelike",
            "ensure_int64_or_float64",
            "is_integer_dtype",
            "_is_unorderable_exception",
            "is_datetime64tz_dtype",
            "is_extension_type",
            "classes",
            "is_extension_array_dtype",
            "is_object_dtype",
            "is_string_dtype",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_all_files": [
            "map",
            "format",
            "freq",
            "real",
            "_extract_axes",
            "_maybe_update_cacher",
            "is_floating",
            "_get_value",
            "_set_with_engine",
            "pivot_table",
            "swapaxes",
            "_repr_html_",
            "_is_dtype",
            "get_loc",
            "_get_axis",
            "_is_homogeneous_type",
            "_constructor_sliced",
            "select",
            "slice_shift",
            "identical",
            "stack",
            "_construct_axes_from_arguments",
            "eval",
            "tshift",
            "_delegate_property_set",
            "_can_hold_identifiers_and_holds_name",
            "set_caption",
            "to_csv",
            "unique",
            "_is_label_or_level_reference",
            "_format_native_types",
            "to_timestamp",
            "describe",
            "shape",
            "clip_upper",
            "checked_add_with_arr",
            "_string_data_error",
            "_validate_join_method",
            "components",
            "is_extension_array_dtype",
            "hide_columns",
            "is_object_dtype",
            "_single_replace",
            "equal_levels",
            "drop_duplicates",
            "_convert",
            "_simple_new",
            "diff",
            "background_gradient",
            "_drop_axis",
            "infer_objects",
            "_highlight_handler",
            "_update_inplace",
            "take_nd",
            "is_",
            "from_product",
            "_delegate_method",
            "size",
            "pandas_dtype",
            "_hashed_values",
            "is_datetime64_dtype",
            "to_html",
            "argsort",
            "__contains__",
            "_new_Index",
            "_trim_front",
            "get_indexer",
            "is_datetime_or_timedelta_dtype",
            "nunique",
            "_bar",
            "_is_numeric_mixed_type",
            "drop",
            "between",
            "_join_level",
            "_make_arithmetic_op",
            "use",
            "_join_monotonic",
            "from_csv",
            "__xor__",
            "_get_axis_resolvers",
            "__getstate__",
            "__finalize__",
            "_get_level_number",
            "bool",
            "is_extension_type",
            "_invalid_indexer",
            "reset_index",
            "inferred_type",
            "__nonzero__",
            "_agg_by_level",
            "_reindex_columns",
            "ravel",
            "hide_index",
            "_repr_fits_horizontal_",
            "is_period",
            "_add_series_only_operations",
            "highlight_min",
            "_doc_parms",
            "_get_dtype",
            "get_locs",
            "value_counts",
            "combine",
            "_stat_axis",
            "_combine",
            "is_datetime_arraylike",
            "_get_level_values",
            "_get_reconciled_name_object",
            "needs_i8_conversion",
            "_maybe_cast_slice_bound",
            "__array__",
            "is_float_dtype",
            "set_levels",
            "_factorize_array",
            "_try_get_item",
            "iterrows",
            "levshape",
            "is_datetimelike",
            "duplicated",
            "_get_hashtable_algo",
            "get_ftype_counts",
            "abs",
            "__deepcopy__",
            "_validate_for_numeric_unaryop",
            "pivot",
            "_getitem_bool_array",
            "to_sparse",
            "to_panel",
            "_left_indexer",
            "_apply_2d",
            "_set_as_cached",
            "_is_strictly_monotonic_decreasing",
            "__neg__",
            "_join_non_unique",
            "render",
            "_expand_axes",
            "_protect_consolidate",
            "_nbytes",
            "reindex_axis",
            "_get_plane_axes",
            "put",
            "_maybe_wrap_formatter",
            "_ensure_data",
            "repeat",
            "set_uuid",
            "to_records",
            "slice_locs",
            "_constructor",
            "to_json",
            "ensure_categorical",
            "ndim",
            "droplevel",
            "_get_nearest_indexer",
            "delete",
            "_is_unorderable_exception",
            "_maybe_promote",
            "update",
            "_get_agg_axis",
            "add_suffix",
            "to_series",
            "_clip_with_one_bound",
            "to_frame",
            "info",
            "symmetric_difference",
            "view",
            "_set_levels",
            "clip_lower",
            "_reindex_index",
            "itertuples",
            "_validate_sort_keyword",
            "sort_values",
            "_get_numeric_data",
            "mask",
            "_constructor_expanddim",
            "_align_series",
            "_find_valid_index",
            "is_timedelta64_ns_dtype",
            "_check_inplace_setting",
            "_get_names",
            "is_boolean",
            "to_pytimedelta",
            "_set_subtyp",
            "array",
            "_hashed_indexing_key",
            "_get_unique_index",
            "_compare_constructor",
            "to_feather",
            "__getattr__",
            "_add_numeric_methods_disabled",
            "blocks",
            "set_index",
            "_setup_axes",
            "_consolidate",
            "conform",
            "tail",
            "default_index",
            "rank",
            "_make_stat_function",
            "__getitem__",
            "__sub__",
            "keys",
            "_get_na_rep",
            "from_custom_template",
            "to_string",
            "get_indexer_non_unique",
            "_verify_integrity",
            "_init_data",
            "clear",
            "match",
            "empty",
            "to_msgpack",
            "_values",
            "_validate_indexer",
            "set_table_attributes",
            "_add_series_or_dataframe_operations",
            "_join_multi",
            "take_2d_multi",
            "compress",
            "_drop_labels_or_levels",
            "_get_fill_indexer",
            "_get_codes_for_sorting",
            "remove_unused_levels",
            "_getitem_frame",
            "_get_axis_number",
            "nonzero",
            "merge",
            "_init_mgr",
            "from_arrays",
            "_add_numeric_methods_unary",
            "classes_and_not_datetimelike",
            "ftypes",
            "is_all_dates",
            "_highlight_null",
            "_box_col_values",
            "_where",
            "_wrap_setop_result",
            "_reset_cacher",
            "slice_indexer",
            "_evaluate_with_datetime_like",
            "set_labels",
            "_get_loc_only_exact_matches",
            "notnull",
            "_get_cacher",
            "_add_numeric_operations",
            "_partial_tup_index",
            "aggregate",
            "idxmin",
            "tz_localize",
            "is_lexsorted",
            "_info_axis",
            "is_categorical_dtype",
            "_clear_item_cache",
            "__setattr__",
            "_format_with_header",
            "__hash__",
            "_take_nd_object",
            "_validate_dtype",
            "_convert_index_indexer",
            "__radd__",
            "_init_matrix",
            "is_categorical",
            "is_datetime64_any_dtype",
            "get_loc_level",
            "_get_take_nd_function",
            "idxmax",
            "_maybe_cache_changed",
            "dtype_str",
            "__add__",
            "is_valid_dtype_n_method",
            "is_interval",
            "_get_plane_axes_index",
            "fillna",
            "isnull",
            "_concat",
            "is_type_compatible",
            "sortlevel",
            "clip",
            "is_copy",
            "_slice",
            "__iadd__",
            "dot",
            "__getslice__",
            "__setitem__",
            "_make_comparison_op",
            "_get_level_indexer",
            "_to_dict_of_blocks",
            "from_tuples",
            "is_numeric_dtype",
            "get_slice_bound",
            "_unpickle_series_compat",
            "_is_cached",
            "add_prefix",
            "bar",
            "is_timedelta64_dtype",
            "_format_attrs",
            "set_value",
            "_add_numeric_methods",
            "_set_name",
            "_formatting_values",
            "to_dense",
            "__iter__",
            "_is_view",
            "_needs_reindex_multi",
            "intersection",
            "_convert_list_indexer",
            "_repr_fits_vertical_",
            "_is_dtype_type",
            "_is_label_reference",
            "_coerce_scalar_to_index",
            "last_valid_index",
            "to_pickle",
            "get",
            "is_sparse",
            "_evaluate_with_timedelta_like",
            "infer_dtype_from_object",
            "_validate_for_numeric_binop",
            "__array_prepare__",
            "_get_with",
            "summary",
            "_convert_listlike_indexer",
            "is_scipy_sparse",
            "__rmatmul__",
            "_get_item_cache",
            "xs",
            "to_parquet",
            "values",
            "_get_join_index",
            "_make_stat_function_ddof",
            "sample",
            "_can_hold_na",
            "dropna",
            "_get_fill_indexer_searchsorted",
            "_init_arrays",
            "_sort_levels_monotonic",
            "_setitem_array",
            "__or__",
            "_copy",
            "swaplevel",
            "memory_usage",
            "to_clipboard",
            "is_monotonic_decreasing",
            "_reconstruct_data",
            "_add_logical_methods_disabled",
            "_drop_from_level",
            "_set_item",
            "is_offsetlike",
            "_add_comparison_methods",
            "__round__",
            "is_lexsorted_for_tuple",
            "_convert_slice_indexer",
            "_has_complex_internals",
            "nbytes",
            "_extract_axes_for_slice",
            "_combine_panel",
            "dtype",
            "is_mixed",
            "__new__",
            "searchsorted",
            "is_datetimetz",
            "first",
            "_make_logical_function",
            "codes",
            "_clip_with_scalar",
            "melt",
            "to_sql",
            "__init__",
            "_get_grouper_for_level",
            "_delegate_property_get",
            "contains",
            "as_matrix",
            "last",
            "ensure_index",
            "_binop",
            "tz_convert",
            "asfreq",
            "is_numeric",
            "is_any_int_dtype",
            "truncate",
            "_iget_item_cache",
            "at_time",
            "set_names",
            "get_indexer_for",
            "_convert_for_op",
            "reindex_like",
            "_validate_index_level",
            "is_string_like_dtype",
            "_check_is_chained_assignment_possible",
            "_ensure_like_indices",
            "_translate",
            "_is_level_reference",
            "major_xs",
            "asof_locs",
            "imag",
            "take",
            "_is_strictly_monotonic_increasing",
            "_get_axis_name",
            "filter",
            "axes",
            "_ensure_valid_index",
            "union",
            "valid",
            "_get_data_algo",
            "__invert__",
            "__len__",
            "dtypes",
            "factorize",
            "convert_objects",
            "transform",
            "align",
            "_background_gradient",
            "_box_item_values",
            "_take",
            "astype",
            "ensure_float",
            "append",
            "interpolate",
            "to_hdf",
            "corrwith",
            "_view_wrapper",
            "_summary",
            "_get_level_lengths",
            "_getitem_multilevel",
            "_inferred_type_levels",
            "_get_label_or_level_values",
            "_ensure_arraylike",
            "is_signed_integer_dtype",
            "apply",
            "isna",
            "compute",
            "to_numpy",
            "to_hierarchical",
            "sort_index",
            "_is_visible",
            "where",
            "remove_na",
            "to_gbq",
            "__unicode__",
            "is_bool_dtype",
            "_setitem_frame",
            "is_interval_dtype",
            "_set_is_copy",
            "_update_ctx",
            "assign",
            "_convert_wrapper",
            "to_period",
            "_maybe_cast_indexer",
            "_coerce_method",
            "from_array",
            "to_latex",
            "_can_reindex",
            "_mpl_repr",
            "ensure_int64_or_float64",
            "_construct_axes_dict_for_slice",
            "_dir_additions",
            "_add_logical_methods",
            "_applymap",
            "_gotitem",
            "corr",
            "_series",
            "_reindex_axes",
            "lexsort_depth",
            "from_records",
            "lookup",
            "to_pydatetime",
            "_compute",
            "_combine_frame",
            "equals",
            "_unpickle_frame_compat",
            "__and__",
            "is_unique",
            "highlight_null",
            "rename",
            "_set_axis",
            "_convert_scalar_indexer",
            "_to_safe_for_reshape",
            "levels",
            "_set_with",
            "_set_values",
            "is_dtype_union_equal",
            "_shallow_copy_with_infer",
            "_set_names",
            "get_value",
            "_is_mixed_type",
            "_ensure_has_len",
            "_construct_axes_dict",
            "_validate_date_like_dtype",
            "_filter_indexer_tolerance",
            "is_object",
            "_homogenize_dict",
            "is_datetime64tz_dtype",
            "__copy__",
            "_scalar_data_error",
            "_concat_same_dtype",
            "_align_frame",
            "is_datetimelike_v_numeric",
            "_check_percentile",
            "to_flat_index",
            "bfill",
            "_cleanup",
            "quantile",
            "_apply_1d",
            "highlight_max",
            "is_dtype_equal",
            "is_complex_dtype",
            "to_native_types",
            "_reindex_with_indexers",
            "_format_space",
            "_reindex_non_unique",
            "_wrap_joined_index",
            "_from_nested_dict",
            "_set_value",
            "_sanitize_column",
            "minor_xs",
            "to_dict",
            "notna",
            "_engine",
            "pop",
            "_indexed_same",
            "nsmallest",
            "pipe",
            "_init_dict",
            "_check_setitem_copy",
            "is_integer_dtype",
            "_consolidate_inplace",
            "ftype",
            "isin",
            "_count_level",
            "_aggregate",
            "_get_values_tuple",
            "_is_memory_usage_qualified",
            "_maybe_update_attributes",
            "__setstate__",
            "classes",
            "_outer_indexer",
            "has_duplicates",
            "__rsub__",
            "as_blocks",
            "pct_change",
            "_codes_to_ints",
            "set_codes",
            "_create_indexer",
            "_reindex_multi",
            "_isnan",
            "is_period_arraylike",
            "_repr_latex_",
            "_apply",
            "_take_2d_multi_object",
            "shift",
            "is_period_dtype",
            "rename_axis",
            "_formatter_func",
            "_convert_can_do_setop",
            "_add_numeric_methods_add_sub_disabled",
            "hasnans",
            "_searchsorted_monotonic",
            "get_level_values",
            "nlevels",
            "_check_label_or_level_ambiguity",
            "__delitem__",
            "_repr_data_resource_",
            "asobject",
            "_get_index_resolvers",
            "autocorr",
            "iteritems",
            "is_datetimelike_v_object",
            "_set_labels",
            "__reduce__",
            "to_stata",
            "_try_convert_to_int_index",
            "reorder_levels",
            "_construct_return_type",
            "_set_codes",
            "count",
            "from_frame",
            "_unpickle_panel_compat",
            "_add_numeric_methods_binary",
            "holds_integer",
            "_info_repr",
            "panel_index",
            "_obj_with_exclusions",
            "_sparsify",
            "_assert_take_fillable",
            "_shallow_copy",
            "_nan_idxs",
            "_ixs",
            "is_datetime64_ns_dtype",
            "_get_block_manager_axis",
            "groupby",
            "labels",
            "name",
            "asof",
            "__pos__",
            "cov",
            "is_monotonic",
            "_assert_can_do_op",
            "_inner_indexer",
            "combine_first",
            "unstack",
            "_convert_tolerance",
            "_put_str",
            "insert",
            "_selected_obj",
            "_have_mixed_levels",
            "style",
            "ffill",
            "is_unsigned_integer_dtype",
            "__abs__",
            "export",
            "mode",
            "_get_values",
            "_combine_match_index",
            "set_axis",
            "_reset_identity",
            "is_integer",
            "_make_cum_function",
            "_prep_ndarray",
            "_mpl",
            "squeeze",
            "to_excel",
            "_get_attributes_dict",
            "difference",
            "first_valid_index",
            "_get_bool_data",
            "putmask",
            "_assert_can_do_setop",
            "get_dtype_counts",
            "__matmul__",
            "to_xarray",
            "copy",
            "applymap",
            "set_precision",
            "_extract_axis",
            "is_string_dtype",
            "is_numeric_v_string_like",
            "select_dtypes",
            "_format_data",
            "_is_datelike_mixed_type",
            "_unpickle_matrix_compat",
            "_construct_axes_dict_from",
            "_make_min_count_stat_function",
            "_from_axes",
            "resample",
            "set_table_styles",
            "is_int64_dtype",
            "reindex",
            "_reduce",
            "_coerce_to_ndarray",
            "is_monotonic_increasing",
            "_join_compat",
            "ensure_index_from_sequences",
            "_get_string_slice",
            "get_duplicates",
            "_setitem_slice",
            "nlargest",
            "query",
            "round",
            "from_dict",
            "from_items",
            "__array_wrap__",
            "_reindex_indexer",
            "_combine_const",
            "_wrap_result",
            "transpose",
            "replace",
            "_combine_match_columns",
            "get_values",
            "between_time",
            "_left_indexer_unique",
            "_validate_names",
            "set_properties",
            "_value_counts_arraylike",
            "_highlight_extrema",
            "join",
            "_set_axis_name",
            "head",
            "_convert_arr_indexer",
            "sort",
            "_from_arrays"
          ],
          "functions_name_co_evolved_modified_file": [
            "is_numeric_v_string_like",
            "is_datetime64_ns_dtype",
            "is_any_int_dtype",
            "is_period",
            "is_numeric_dtype",
            "is_period_arraylike",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_categorical",
            "is_dtype_union_equal",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "is_datetimelike_v_object",
            "is_interval_dtype",
            "is_datetimetz",
            "is_datetimelike",
            "_is_unorderable_exception",
            "is_scipy_sparse",
            "is_integer_dtype",
            "is_datetime64tz_dtype",
            "is_extension_type",
            "is_object_dtype",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_co_evolved_all_files": [
            "is_numeric_v_string_like",
            "is_datetime64_ns_dtype",
            "is_any_int_dtype",
            "is_period",
            "asof",
            "is_numeric_dtype",
            "is_period_arraylike",
            "is_int64_dtype",
            "shift",
            "is_period_dtype",
            "render",
            "is_string_like_dtype",
            "to_pydatetime",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "quantile",
            "get_level_values",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "to_pytimedelta",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "minor_xs",
            "is_categorical",
            "is_dtype_union_equal",
            "is_datetime64_any_dtype",
            "major_xs",
            "is_float_dtype",
            "is_bool_dtype",
            "is_datetimelike_v_object",
            "is_interval_dtype",
            "is_datetimetz",
            "unique",
            "is_datetimelike",
            "_is_unorderable_exception",
            "is_scipy_sparse",
            "is_integer_dtype",
            "is_datetime64tz_dtype",
            "is_extension_type",
            "from_custom_template",
            "is_object_dtype",
            "is_datetimelike_v_numeric"
          ]
        },
        "file": {
          "file_name": "common.py",
          "file_nloc": 352,
          "file_complexity": 165,
          "file_token_count": 2421,
          "file_before": "\"\"\" common type operations \"\"\"\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.compat import PY3, PY36, string_types\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype, DatetimeTZDtype, ExtensionDtype, IntervalDtype,\n    PandasExtensionDtype, PeriodDtype, registry)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical, ABCDateOffset, ABCDatetimeIndex, ABCIndexClass,\n    ABCPeriodArray, ABCPeriodIndex, ABCSeries)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like, is_bool, is_complex, is_decimal, is_dict_like, is_file_like,\n    is_float, is_hashable, is_integer, is_interval, is_iterator, is_list_like,\n    is_named_tuple, is_nested_list_like, is_number, is_re, is_re_compilable,\n    is_scalar, is_sequence, is_string_like)\n\n_POSSIBLY_CAST_DTYPES = {np.dtype(t).name\n                         for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                   'int32', 'uint32', 'int64', 'uint64']}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int64_or_float64(arr, copy=False):\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: boolean\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n    \"\"\"\n    try:\n        return arr.astype('int64', copy=copy, casting='safe')\n    except TypeError:\n        return arr.astype('float64', copy=copy)\n\n\ndef classes(*klasses):\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses):\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (issubclass(tipo, klasses) and\n                         not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_object_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    DataFrame.to_sparse : Convert DataFrame to a SparseDataFrame.\n    Series.to_sparse : Convert Series to SparseSeries.\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.SparseSeries([0, 0, 1, 0]))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n\n    >>> df = pd.SparseDataFrame([389., 24., 80.5, np.nan],\n                                columns=['max_speed'],\n                                index=['falcon', 'parrot', 'lion', 'monkey'])\n    >>> is_sparse(df)\n    False\n    >>> is_sparse(df.max_speed)\n    True\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, 'dtype', arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a\n              scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    >>> is_scipy_sparse(pd.SparseSeries([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr):\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime array-like with\n              a timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_datetimetz' is deprecated and will be removed in a \"\n                  \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n                  FutureWarning, stacklevel=2)\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj):\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean : Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif (is_list_like(arr_or_obj) and len(arr_or_obj) and\n          is_object_dtype(arr_or_obj)):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr):\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_period' is deprecated and will be removed in a future \"\n                  \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n                  \"instead.\", FutureWarning, stacklevel=2)\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical\n              array-like or PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime\n              array-like or DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (is_object_dtype(arr.dtype)\n                and lib.infer_dtype(arr, skipna=False) == 'datetime')\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime-like array-like.\n\n    Acceptable datetime-like objects are (but not limited to) datetime\n    indices, periodic indices, and timedelta indices.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime-like array-like.\n\n    Examples\n    --------\n    >>> is_datetimelike([1, 2, 3])\n    False\n    >>> is_datetimelike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>> is_datetimelike(pd.PeriodIndex([], freq=\"A\"))\n    True\n    >>> is_datetimelike(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetimelike(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimelike(s)\n    True\n    \"\"\"\n\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean : Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_dtype_union_equal(source, target):\n    \"\"\"\n    Check whether two arrays have compatible dtypes to do a union.\n    numpy types are checked with ``is_dtype_equal``. Extension types are\n    checked separately.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean : Whether or not the two dtypes are equal.\n\n    >>> is_dtype_equal(\"int\", int)\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c']))\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c'], ordered=True))\n    False\n    \"\"\"\n    source = _get_dtype(source)\n    target = _get_dtype(target)\n    if is_categorical_dtype(source) and is_categorical_dtype(target):\n        # ordered False for both\n        return source.ordered is target.ordered\n    return is_dtype_equal(source, target)\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    \"\"\"Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a signed integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an\n              unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the\n              timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a\n              timedelta64, or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean : Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a string-like\n              object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(1, 1)\n    False\n    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n    False\n    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n    False\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to a numeric object.\n\n    By \"numeric,\" we mean an object that is either of an int or float dtype.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to a numeric object.\n\n    Examples\n    --------\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_numeric(1, 1)\n    False\n    >>> is_datetimelike_v_numeric(dt, dt)\n    False\n    >>> is_datetimelike_v_numeric(1, dt)\n    True\n    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n    False\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        \"\"\"\n        Check if an object has a numeric dtype (i.e. integer or float).\n        \"\"\"\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to an object instance.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to an object instance.\n\n    Examples\n    --------\n    >>> obj = object()\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_object(obj, obj)\n    False\n    >>> is_datetimelike_v_object(dt, dt)\n    False\n    >>> is_datetimelike_v_object(obj, dt)\n    True\n    >>> is_datetimelike_v_object(dt, obj)  # symmetric check\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), obj)\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), dt)\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([obj]))\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), np.array([obj]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([1]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object_dtype(b)) or\n            (is_datetimelike(b) and is_object_dtype(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(\n        arr_or_dtype, lambda dtype: dtype.kind in ('S', 'U'))\n\n\ndef is_float_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return (arr_or_dtype.is_object and\n                arr_or_dtype.inferred_type == 'boolean')\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a pandas\n              extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> is_extension_type(pd.SparseSeries([1, 2, 3]))\n    True\n    >>>\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype):\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n    return (isinstance(dtype, ExtensionDtype) or\n            registry.find(dtype) is not None)\n\n\ndef is_complex_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a compex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition):\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition):\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisifed for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, (PandasExtensionDtype, ExtensionDtype)):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n    elif arr_or_dtype is None:\n        return condition(type(None))\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, string_types):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('{error}'.format(error=e))\n    if typ != 'generic' and typ != 'ns':\n        msg = '{name!r} is too specific of a frequency, try passing {type!r}'\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except Exception:\n        # we don't want to force a repr of the non-string\n        if not isinstance(dtype, string_types):\n            raise TypeError(\"data type not understood\")\n        raise TypeError(\"data type '{}' not understood\".format(\n            dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, 'object', 'O']:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == 'O':\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_after": "\"\"\" common type operations \"\"\"\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.compat import PY3, PY36, string_types\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype, DatetimeTZDtype, ExtensionDtype, IntervalDtype,\n    PandasExtensionDtype, PeriodDtype, registry)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical, ABCDateOffset, ABCDatetimeIndex, ABCIndexClass,\n    ABCPeriodArray, ABCPeriodIndex, ABCSeries)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like, is_bool, is_complex, is_decimal, is_dict_like, is_file_like,\n    is_float, is_hashable, is_integer, is_interval, is_iterator, is_list_like,\n    is_named_tuple, is_nested_list_like, is_number, is_re, is_re_compilable,\n    is_scalar, is_sequence, is_string_like)\n\n_POSSIBLY_CAST_DTYPES = {np.dtype(t).name\n                         for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                   'int32', 'uint32', 'int64', 'uint64']}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int64_or_float64(arr, copy=False):\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: boolean\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n    \"\"\"\n    try:\n        return arr.astype('int64', copy=copy, casting='safe')\n    except TypeError:\n        return arr.astype('float64', copy=copy)\n\n\ndef classes(*klasses):\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses):\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (issubclass(tipo, klasses) and\n                         not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_object_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    DataFrame.to_sparse : Convert DataFrame to a SparseDataFrame.\n    Series.to_sparse : Convert Series to SparseSeries.\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.SparseSeries([0, 0, 1, 0]))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n\n    >>> df = pd.SparseDataFrame([389., 24., 80.5, np.nan],\n                                columns=['max_speed'],\n                                index=['falcon', 'parrot', 'lion', 'monkey'])\n    >>> is_sparse(df)\n    False\n    >>> is_sparse(df.max_speed)\n    True\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, 'dtype', arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    >>> is_scipy_sparse(pd.SparseSeries([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr):\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like with a\n        timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_datetimetz' is deprecated and will be removed in a \"\n                  \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n                  FutureWarning, stacklevel=2)\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj):\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean\n        Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif (is_list_like(arr_or_obj) and len(arr_or_obj) and\n          is_object_dtype(arr_or_obj)):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr):\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_period' is deprecated and will be removed in a future \"\n                  \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n                  \"instead.\", FutureWarning, stacklevel=2)\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a periodical array-like or\n        PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime array-like or\n        DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (is_object_dtype(arr.dtype)\n                and lib.infer_dtype(arr, skipna=False) == 'datetime')\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime-like array-like.\n\n    Acceptable datetime-like objects are (but not limited to) datetime\n    indices, periodic indices, and timedelta indices.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is a datetime-like array-like.\n\n    Examples\n    --------\n    >>> is_datetimelike([1, 2, 3])\n    False\n    >>> is_datetimelike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>> is_datetimelike(pd.PeriodIndex([], freq=\"A\"))\n    True\n    >>> is_datetimelike(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetimelike(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimelike(s)\n    True\n    \"\"\"\n\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_dtype_union_equal(source, target):\n    \"\"\"\n    Check whether two arrays have compatible dtypes to do a union.\n    numpy types are checked with ``is_dtype_equal``. Extension types are\n    checked separately.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean\n        Whether or not the two dtypes are equal.\n\n    >>> is_dtype_equal(\"int\", int)\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c']))\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c'], ordered=True))\n    False\n    \"\"\"\n    source = _get_dtype(source)\n    target = _get_dtype(target)\n    if is_categorical_dtype(source) and is_categorical_dtype(target):\n        # ordered False for both\n        return source.ordered is target.ordered\n    return is_dtype_equal(source, target)\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    \"\"\"Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a signed integer dtype\n        and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a timedelta64,\n        or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a string-like object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(1, 1)\n    False\n    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n    False\n    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n    False\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to a numeric object.\n\n    By \"numeric,\" we mean an object that is either of an int or float dtype.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a datetime-like to a numeric object.\n\n    Examples\n    --------\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_numeric(1, 1)\n    False\n    >>> is_datetimelike_v_numeric(dt, dt)\n    False\n    >>> is_datetimelike_v_numeric(1, dt)\n    True\n    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n    False\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        \"\"\"\n        Check if an object has a numeric dtype (i.e. integer or float).\n        \"\"\"\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to an object instance.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a datetime-like to an object instance.\n\n    Examples\n    --------\n    >>> obj = object()\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_object(obj, obj)\n    False\n    >>> is_datetimelike_v_object(dt, dt)\n    False\n    >>> is_datetimelike_v_object(obj, dt)\n    True\n    >>> is_datetimelike_v_object(dt, obj)  # symmetric check\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), obj)\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), dt)\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([obj]))\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), np.array([obj]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([1]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object_dtype(b)) or\n            (is_datetimelike(b) and is_object_dtype(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(\n        arr_or_dtype, lambda dtype: dtype.kind in ('S', 'U'))\n\n\ndef is_float_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return (arr_or_dtype.is_object and\n                arr_or_dtype.inferred_type == 'boolean')\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like is of a pandas extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> is_extension_type(pd.SparseSeries([1, 2, 3]))\n    True\n    >>>\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype):\n    \"\"\"\n    Check if an object is a pandas extension array type.\n\n    See the :ref:`Use Guide <extending.extension-types>` for more.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n        For array-like input, the ``.dtype`` attribute will\n        be extracted.\n\n    Returns\n    -------\n    bool\n        Whether the `arr_or_dtype` is an extension array type.\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n    * Period\n    * DatetimeArray\n    * TimedeltaArray\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_extension_array_dtype\n    >>> arr = pd.Categorical(['a', 'b'])\n    >>> is_extension_array_dtype(arr)\n    True\n    >>> is_extension_array_dtype(arr.dtype)\n    True\n\n    >>> arr = np.array(['a', 'b'])\n    >>> is_extension_array_dtype(arr.dtype)\n    False\n    \"\"\"\n    dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n    return (isinstance(dtype, ExtensionDtype) or\n            registry.find(dtype) is not None)\n\n\ndef is_complex_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a compex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition):\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition):\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisifed for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, (PandasExtensionDtype, ExtensionDtype)):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n    elif arr_or_dtype is None:\n        return condition(type(None))\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, string_types):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('{error}'.format(error=e))\n    if typ != 'generic' and typ != 'ns':\n        msg = '{name!r} is too specific of a frequency, try passing {type!r}'\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except Exception:\n        # we don't want to force a repr of the non-string\n        if not isinstance(dtype, string_types):\n            raise TypeError(\"data type not understood\")\n        raise TypeError(\"data type '{}' not understood\".format(\n            dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, 'object', 'O']:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == 'O':\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_patch": "@@ -139,7 +139,8 @@ def is_object_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like or dtype is of the object dtype.\n+    boolean\n+        Whether or not the array-like or dtype is of the object dtype.\n \n     Examples\n     --------\n@@ -230,8 +231,8 @@ def is_scipy_sparse(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is a\n-              scipy.sparse.spmatrix instance.\n+    boolean\n+        Whether or not the array-like is a scipy.sparse.spmatrix instance.\n \n     Notes\n     -----\n@@ -270,7 +271,8 @@ def is_categorical(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is of a Categorical instance.\n+    boolean\n+        Whether or not the array-like is of a Categorical instance.\n \n     Examples\n     --------\n@@ -305,8 +307,9 @@ def is_datetimetz(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is a datetime array-like with\n-              a timezone component in its dtype.\n+    boolean\n+        Whether or not the array-like is a datetime array-like with a\n+        timezone component in its dtype.\n \n     Examples\n     --------\n@@ -347,7 +350,8 @@ def is_offsetlike(arr_or_obj):\n \n     Returns\n     -------\n-    boolean : Whether the object is a DateOffset or listlike of DatetOffsets\n+    boolean\n+        Whether the object is a DateOffset or listlike of DatetOffsets\n \n     Examples\n     --------\n@@ -381,7 +385,8 @@ def is_period(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is a periodical index.\n+    boolean\n+        Whether or not the array-like is a periodical index.\n \n     Examples\n     --------\n@@ -411,8 +416,8 @@ def is_datetime64_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like or dtype is of\n-              the datetime64 dtype.\n+    boolean\n+        Whether or not the array-like or dtype is of the datetime64 dtype.\n \n     Examples\n     --------\n@@ -442,8 +447,8 @@ def is_datetime64tz_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like or dtype is of\n-              a DatetimeTZDtype dtype.\n+    boolean\n+        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n \n     Examples\n     --------\n@@ -480,8 +485,8 @@ def is_timedelta64_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like or dtype is\n-              of the timedelta64 dtype.\n+    boolean\n+        Whether or not the array-like or dtype is of the timedelta64 dtype.\n \n     Examples\n     --------\n@@ -511,7 +516,8 @@ def is_period_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like or dtype is of the Period dtype.\n+    boolean\n+        Whether or not the array-like or dtype is of the Period dtype.\n \n     Examples\n     --------\n@@ -544,8 +550,8 @@ def is_interval_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like or dtype is\n-              of the Interval dtype.\n+    boolean\n+        Whether or not the array-like or dtype is of the Interval dtype.\n \n     Examples\n     --------\n@@ -580,8 +586,8 @@ def is_categorical_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like or dtype is\n-              of the Categorical dtype.\n+    boolean\n+        Whether or not the array-like or dtype is of the Categorical dtype.\n \n     Examples\n     --------\n@@ -613,7 +619,8 @@ def is_string_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of the string dtype.\n+    boolean\n+        Whether or not the array or dtype is of the string dtype.\n \n     Examples\n     --------\n@@ -647,8 +654,9 @@ def is_period_arraylike(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is a periodical\n-              array-like or PeriodIndex instance.\n+    boolean\n+        Whether or not the array-like is a periodical array-like or\n+        PeriodIndex instance.\n \n     Examples\n     --------\n@@ -678,8 +686,9 @@ def is_datetime_arraylike(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is a datetime\n-              array-like or DatetimeIndex.\n+    boolean\n+        Whether or not the array-like is a datetime array-like or\n+        DatetimeIndex.\n \n     Examples\n     --------\n@@ -713,7 +722,8 @@ def is_datetimelike(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is a datetime-like array-like.\n+    boolean\n+        Whether or not the array-like is a datetime-like array-like.\n \n     Examples\n     --------\n@@ -754,7 +764,8 @@ def is_dtype_equal(source, target):\n \n     Returns\n     ----------\n-    boolean : Whether or not the two dtypes are equal.\n+    boolean\n+        Whether or not the two dtypes are equal.\n \n     Examples\n     --------\n@@ -794,7 +805,8 @@ def is_dtype_union_equal(source, target):\n \n     Returns\n     ----------\n-    boolean : Whether or not the two dtypes are equal.\n+    boolean\n+        Whether or not the two dtypes are equal.\n \n     >>> is_dtype_equal(\"int\", int)\n     True\n@@ -835,7 +847,8 @@ def is_any_int_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of an integer dtype.\n+    boolean\n+        Whether or not the array or dtype is of an integer dtype.\n \n     Examples\n     --------\n@@ -883,8 +896,9 @@ def is_integer_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of an integer dtype\n-              and not an instance of timedelta64.\n+    boolean\n+        Whether or not the array or dtype is of an integer dtype and\n+        not an instance of timedelta64.\n \n     Examples\n     --------\n@@ -938,8 +952,9 @@ def is_signed_integer_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of a signed integer dtype\n-              and not an instance of timedelta64.\n+    boolean\n+        Whether or not the array or dtype is of a signed integer dtype\n+        and not an instance of timedelta64.\n \n     Examples\n     --------\n@@ -993,8 +1008,8 @@ def is_unsigned_integer_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of an\n-              unsigned integer dtype.\n+    boolean\n+        Whether or not the array or dtype is of an unsigned integer dtype.\n \n     Examples\n     --------\n@@ -1036,7 +1051,8 @@ def is_int64_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of the int64 dtype.\n+    boolean\n+        Whether or not the array or dtype is of the int64 dtype.\n \n     Notes\n     -----\n@@ -1086,7 +1102,8 @@ def is_datetime64_any_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of the datetime64 dtype.\n+    boolean\n+        Whether or not the array or dtype is of the datetime64 dtype.\n \n     Examples\n     --------\n@@ -1126,7 +1143,8 @@ def is_datetime64_ns_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of the datetime64[ns] dtype.\n+    boolean\n+        Whether or not the array or dtype is of the datetime64[ns] dtype.\n \n     Examples\n     --------\n@@ -1178,8 +1196,8 @@ def is_timedelta64_ns_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of the\n-              timedelta64[ns] dtype.\n+    boolean\n+        Whether or not the array or dtype is of the timedelta64[ns] dtype.\n \n     Examples\n     --------\n@@ -1207,8 +1225,9 @@ def is_datetime_or_timedelta_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of a\n-              timedelta64, or datetime64 dtype.\n+    boolean\n+        Whether or not the array or dtype is of a timedelta64,\n+        or datetime64 dtype.\n \n     Examples\n     --------\n@@ -1248,7 +1267,8 @@ def _is_unorderable_exception(e):\n \n     Returns\n     -------\n-    boolean : Whether or not the exception raised is an unorderable exception.\n+    boolean\n+        Whether or not the exception raised is an unorderable exception.\n     \"\"\"\n \n     if PY36:\n@@ -1275,8 +1295,8 @@ def is_numeric_v_string_like(a, b):\n \n     Returns\n     -------\n-    boolean : Whether we return a comparing a string-like\n-              object to a numeric array.\n+    boolean\n+        Whether we return a comparing a string-like object to a numeric array.\n \n     Examples\n     --------\n@@ -1332,8 +1352,8 @@ def is_datetimelike_v_numeric(a, b):\n \n     Returns\n     -------\n-    boolean : Whether we return a comparing a datetime-like\n-              to a numeric object.\n+    boolean\n+        Whether we return a comparing a datetime-like to a numeric object.\n \n     Examples\n     --------\n@@ -1388,8 +1408,8 @@ def is_datetimelike_v_object(a, b):\n \n     Returns\n     -------\n-    boolean : Whether we return a comparing a datetime-like\n-              to an object instance.\n+    boolean\n+        Whether we return a comparing a datetime-like to an object instance.\n \n     Examples\n     --------\n@@ -1442,7 +1462,8 @@ def needs_i8_conversion(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype should be converted to int64.\n+    boolean\n+        Whether or not the array or dtype should be converted to int64.\n \n     Examples\n     --------\n@@ -1480,7 +1501,8 @@ def is_numeric_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of a numeric dtype.\n+    boolean\n+        Whether or not the array or dtype is of a numeric dtype.\n \n     Examples\n     --------\n@@ -1524,7 +1546,8 @@ def is_string_like_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of the string dtype.\n+    boolean\n+        Whether or not the array or dtype is of the string dtype.\n \n     Examples\n     --------\n@@ -1555,7 +1578,8 @@ def is_float_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of a float dtype.\n+    boolean\n+        Whether or not the array or dtype is of a float dtype.\n \n     Examples\n     --------\n@@ -1586,7 +1610,8 @@ def is_bool_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of a boolean dtype.\n+    boolean\n+        Whether or not the array or dtype is of a boolean dtype.\n \n     Notes\n     -----\n@@ -1655,8 +1680,8 @@ def is_extension_type(arr):\n \n     Returns\n     -------\n-    boolean : Whether or not the array-like is of a pandas\n-              extension class instance.\n+    boolean\n+        Whether or not the array-like is of a pandas extension class instance.\n \n     Examples\n     --------\n@@ -1760,7 +1785,8 @@ def is_complex_dtype(arr_or_dtype):\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype is of a compex dtype.\n+    boolean\n+        Whether or not the array or dtype is of a compex dtype.\n \n     Examples\n     --------\n",
          "files_name_in_blame_commit": [
            "common.py",
            "series.py",
            "base.py",
            "panel.py",
            "algorithms.py",
            "generic.py",
            "accessors.py",
            "style.py",
            "multi.py",
            "frame.py"
          ]
        }
      },
      "19f715c51d16995fc6cd0c102fdba2f213a83a0f": {
        "commit": {
          "commit_id": "19f715c51d16995fc6cd0c102fdba2f213a83a0f",
          "commit_message": "CLN: use idiomatic pandas_dtypes in pandas/dtypes/common.py (#24541)",
          "commit_author": "Jeff Reback",
          "commit_date": "2019-01-04 08:55:43",
          "commit_parent": "a42c9be11c2fe0d7dfacc5939f6186ef1d81e077"
        },
        "function": {
          "function_name": "is_string_dtype",
          "function_code_before": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    except TypeError:\n        return False",
          "function_code_after": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    return _is_dtype(arr_or_dtype, condition)",
          "function_before_start_line": 609,
          "function_before_end_line": 645,
          "function_after_start_line": 605,
          "function_after_end_line": 636,
          "function_before_token_count": 44,
          "function_after_token_count": 15,
          "functions_name_modified_file": [
            "is_numeric_v_string_like",
            "is_datetime64_ns_dtype",
            "is_period",
            "is_any_int_dtype",
            "ensure_float",
            "is_numeric_dtype",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_offsetlike",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "_is_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_categorical",
            "is_dtype_union_equal",
            "is_datetime64_any_dtype",
            "_is_dtype_type",
            "is_float_dtype",
            "is_bool_dtype",
            "is_datetimelike_v_object",
            "is_sparse",
            "is_datetimetz",
            "is_interval_dtype",
            "infer_dtype_from_object",
            "ensure_categorical",
            "_validate_date_like_dtype",
            "is_datetimelike",
            "is_scipy_sparse",
            "classes_and_not_datetimelike",
            "ensure_int64_or_float64",
            "is_integer_dtype",
            "_is_unorderable_exception",
            "is_datetime64tz_dtype",
            "is_extension_type",
            "classes",
            "is_extension_array_dtype",
            "is_object_dtype",
            "is_string_dtype",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_all_files": [
            "test_dtype_equal_strict",
            "get_dtype_kinds",
            "concatenate_join_units",
            "_get_value",
            "pivot_table",
            "_repr_html_",
            "_is_dtype",
            "get_loc",
            "_is_homogeneous_type",
            "stack",
            "eval",
            "test_is_datetime64tz_dtype",
            "tick_classes",
            "test_is_not_int64_dtype",
            "axis",
            "tz_naive_fixture",
            "float_dtype",
            "_format_native_types",
            "nulls_fixture",
            "to_timestamp",
            "is_nested_object",
            "shape",
            "test_is_categorical",
            "is_extension_array_dtype",
            "is_object_dtype",
            "test_is_datetimetz",
            "drop_duplicates",
            "test_is_complex_dtype",
            "construct_array_type",
            "diff",
            "pandas_dtype",
            "is_datetime64_dtype",
            "time_pandas_dtype",
            "find_common_type",
            "to_html",
            "__contains__",
            "is_datetime_or_timedelta_dtype",
            "nunique",
            "drop",
            "from_csv",
            "all_arithmetic_operators",
            "test_is_period_arraylike",
            "_is_numeric",
            "maybe_promote",
            "test_is_timedelta64_ns_dtype",
            "is_extension_type",
            "reset_index",
            "inferred_type",
            "arrays_to_mgr",
            "test_is_int64_dtype",
            "test_is_datetimelike_v_numeric",
            "_reindex_columns",
            "_repr_fits_horizontal_",
            "any_skipna_inferred_dtype",
            "is_period",
            "_concat_index_asobject",
            "extract_index",
            "_get_dtype",
            "uint_dtype",
            "combine_concat_plans",
            "value_counts",
            "combine",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "sanitize_array",
            "utc_fixture",
            "_maybe_cast_slice_bound",
            "__array__",
            "is_float_dtype",
            "iterrows",
            "is_datetimelike",
            "duplicated",
            "join_type",
            "pivot",
            "_getitem_bool_array",
            "to_sparse",
            "to_panel",
            "is_uniform_join_units",
            "time_pandas_dtype_invalid",
            "coerce_indexer_dtype",
            "infer_dtype_from",
            "coerce_to_array",
            "spmatrix",
            "test__is_dtype_type",
            "_get_frame_result_type",
            "test_is_scipy_sparse",
            "reindex_axis",
            "all_numeric_reductions",
            "test_is_string_like_dtype",
            "to_records",
            "_constructor",
            "ensure_categorical",
            "_is_unorderable_exception",
            "update",
            "_get_agg_axis",
            "other_closed",
            "string_dtype",
            "info",
            "test_needs_i8_conversion",
            "_convert_object_array",
            "maybe_castable",
            "_reindex_index",
            "itertuples",
            "sort_values",
            "_constructor_expanddim",
            "cast_scalar_to_array",
            "is_timedelta64_ns_dtype",
            "sanitize_index",
            "test_period_dtype",
            "compression",
            "to_feather",
            "set_index",
            "pytest_addoption",
            "test_is_interval_dtype",
            "_concat_sparse",
            "infer_dtype_from_array",
            "__getitem__",
            "setup",
            "maybe_convert_platform",
            "to_string",
            "cython_table_items",
            "test_is_timedelta64_dtype",
            "is_na",
            "test_numpy_string_dtype",
            "to_numpy_dtypes",
            "_ndarray_values",
            "is_uniform_reindex",
            "_getitem_frame",
            "mock",
            "merge",
            "test_is_extension_type",
            "_create_comparison_method",
            "all_compare_operators",
            "classes_and_not_datetimelike",
            "is_all_dates",
            "maybe_cast_to_integer_array",
            "complex_dtype",
            "_box_col_values",
            "unique_nulls_fixture",
            "closed",
            "_list_of_dict_to_arrays",
            "test_get_dtype_error_catch",
            "notnull",
            "test_categorical_dtype",
            "init_dict",
            "teardown",
            "aggregate",
            "idxmin",
            "test__get_dtype_fails",
            "construct_from_string",
            "is_categorical_dtype",
            "test_is_integer_dtype",
            "_convert_index_indexer",
            "_concat_datetimetz",
            "_create_arithmetic_method",
            "is_categorical",
            "is_datetime64_any_dtype",
            "idxmax",
            "test_is_not_signed_integer_dtype",
            "__repr__",
            "fillna",
            "isnull",
            "_concat_categorical",
            "dot",
            "__setitem__",
            "test_is_period_deprecated",
            "is_numeric_dtype",
            "pytest_runtest_setup",
            "_from_sequence",
            "is_timedelta64_dtype",
            "set_value",
            "__iter__",
            "test_pandas_dtype_valid",
            "_repr_fits_vertical_",
            "_is_dtype_type",
            "test_is_datetime64_any_dtype",
            "_try_cast",
            "maybe_upcast_putmask",
            "is_sparse",
            "any_int_dtype",
            "infer_dtype_from_object",
            "safe_cast",
            "is_scipy_sparse",
            "__rmatmul__",
            "to_parquet",
            "_from_sequence_of_strings",
            "dropna",
            "needs_filling",
            "astype_nansafe",
            "maybe_upcast",
            "add_imports",
            "_setitem_array",
            "kind",
            "swaplevel",
            "memory_usage",
            "test_is_not_unsigned_integer_dtype",
            "_set_item",
            "test_is_string_dtype",
            "is_offsetlike",
            "_convert_slice_indexer",
            "nbytes",
            "test_is_bool_dtype",
            "test_is_float_dtype",
            "_concat_rangeindex_same_dtype",
            "nselect_method",
            "dtype",
            "__new__",
            "compression_only",
            "is_datetimetz",
            "integer_array",
            "melt",
            "__init__",
            "to_arrays",
            "get_names_from_index",
            "axis_series",
            "is_any_int_dtype",
            "_convert_for_op",
            "is_string_like_dtype",
            "writable",
            "configure_tests",
            "_na_value",
            "any_numpy_dtype",
            "take",
            "construct_1d_ndarray_preserving_na",
            "datapath",
            "axes",
            "_ensure_valid_index",
            "numpy_dtype",
            "get_reindexed_values",
            "__len__",
            "transform",
            "align",
            "_box_item_values",
            "astype",
            "_assert_safe_casting",
            "maybe_infer_dtype_type",
            "ensure_float",
            "masked_rec_array_to_mgr",
            "append",
            "test_is_period_dtype",
            "corrwith",
            "to_ea_dtypes",
            "_getitem_multilevel",
            "test_is_sparse",
            "invalidate_string_dtypes",
            "is_signed_integer_dtype",
            "apply",
            "isna",
            "to_numpy",
            "strict_data_files",
            "sort_index",
            "to_gbq",
            "__unicode__",
            "is_bool_dtype",
            "_setitem_frame",
            "is_interval_dtype",
            "assign",
            "to_period",
            "test_numpy_dtype",
            "test_datetimetz_dtype",
            "get_empty_dtype_and_na",
            "_get_series_result_type",
            "ensure_int64_or_float64",
            "maybe_infer_to_datetimelike",
            "_gotitem",
            "corr",
            "_series",
            "_reindex_axes",
            "soft_convert_objects",
            "tz_aware_fixture",
            "from_records",
            "lookup",
            "_convert_datetimelike_to_object",
            "test_is_offsetlike",
            "remove",
            "_combine_frame",
            "equals",
            "_unpickle_frame_compat",
            "datetime_tz_utc",
            "is_unique",
            "rename",
            "test_is_datetimelike",
            "_convert_scalar_indexer",
            "test_is_numeric_v_string_like",
            "is_dtype_union_equal",
            "_concat_same_type",
            "test_is_datetime_or_timedelta_dtype",
            "get_value",
            "_validate_date_like_dtype",
            "is_unsigned_integer",
            "_from_factorized",
            "is_datetime64tz_dtype",
            "construct_1d_arraylike_from_scalar",
            "_concat_same_dtype",
            "is_datetimelike_v_numeric",
            "test_is_datetimelike_v_object",
            "_homogenize",
            "quantile",
            "is_dtype_equal",
            "is_complex_dtype",
            "_wrap_joined_index",
            "_from_nested_dict",
            "_set_value",
            "_sanitize_column",
            "to_dict",
            "test_is_unsigned_integer_dtype",
            "get_mgr_concatenation_plan",
            "notna",
            "nsmallest",
            "test_dtype_equal",
            "maybe_convert_objects",
            "is_integer_dtype",
            "_count_level",
            "isin",
            "_aggregate",
            "_get_axes",
            "classes",
            "infer_dtype_from_scalar",
            "maybe_cast_item",
            "trim_join_unit",
            "any_real_dtype",
            "get_is_dtype_funcs",
            "_reindex_multi",
            "itemsize",
            "is_period_arraylike",
            "shift",
            "is_period_dtype",
            "prep_ndarray",
            "test__get_dtype",
            "init_ndarray",
            "iteritems",
            "is_datetimelike_v_object",
            "_maybe_mask_result",
            "to_stata",
            "sint_dtype",
            "reorder_levels",
            "count",
            "_info_repr",
            "_concat_compat",
            "test_is_categorical_dtype",
            "_concat_index_same_dtype",
            "test_is_datetime64_ns_dtype",
            "_shallow_copy",
            "_ixs",
            "is_datetime64_ns_dtype",
            "cov",
            "combine_first",
            "unstack",
            "_convert_tolerance",
            "_put_str",
            "insert",
            "test_is_signed_integer_dtype",
            "asi8",
            "style",
            "maybe_downcast_to_dtype",
            "is_unsigned_integer_dtype",
            "mode",
            "test_is_object",
            "_combine_match_index",
            "ip",
            "_values_for_argsort",
            "_formatter",
            "_list_of_series_to_arrays",
            "test_is_numeric_dtype",
            "maybe_cast_to_datetime",
            "__matmul__",
            "copy",
            "applymap",
            "_get_cython_table_params",
            "is_string_dtype",
            "is_numeric_v_string_like",
            "_concatenate_2d",
            "select_dtypes",
            "iris",
            "_unpickle_matrix_compat",
            "is_signed_integer",
            "is_int64_dtype",
            "_concat_datetime",
            "reindex",
            "_reduce",
            "_coerce_to_ndarray",
            "_join_compat",
            "_setitem_slice",
            "nlargest",
            "construct_1d_object_array_from_listlike",
            "query",
            "observed",
            "round",
            "test_is_datetime_arraylike",
            "from_dict",
            "from_items",
            "_combine_const",
            "_list_to_arrays",
            "test_is_datetime64_dtype",
            "transpose",
            "replace",
            "_combine_match_columns",
            "reorder_arrays",
            "test_invalid_dtype_error",
            "coerce_to_dtypes",
            "union_categoricals",
            "join",
            "test_is_not_integer_dtype",
            "all_boolean_reductions",
            "_convert_arr_indexer",
            "_from_arrays"
          ],
          "functions_name_co_evolved_modified_file": [
            "is_any_int_dtype",
            "is_numeric_dtype",
            "_get_dtype",
            "is_int64_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_timedelta64_ns_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_datetime64_dtype",
            "_is_dtype",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_or_timedelta_dtype",
            "_is_dtype_type",
            "is_float_dtype",
            "is_bool_dtype",
            "_get_dtype_type",
            "infer_dtype_from_object",
            "classes_and_not_datetimelike",
            "is_integer_dtype",
            "classes",
            "_get_dtype_from_object",
            "is_object_dtype"
          ],
          "functions_name_co_evolved_all_files": [
            "select_dtypes",
            "astype",
            "get_dtype_kinds",
            "is_any_int_dtype",
            "is_numeric_dtype",
            "time_pandas_dtype_invalid",
            "_get_dtype",
            "to_ea_dtypes",
            "is_int64_dtype",
            "test_is_not_unsigned_integer_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "test__get_dtype_type",
            "coerce_to_array",
            "is_timedelta64_ns_dtype",
            "test_is_signed_integer_dtype",
            "pandas_dtype",
            "invalidate_string_dtypes",
            "is_signed_integer_dtype",
            "is_datetime64_dtype",
            "test_is_integer_dtype",
            "to_numpy_dtypes",
            "_is_dtype",
            "time_pandas_dtype",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "test__is_dtype_type",
            "is_datetime_or_timedelta_dtype",
            "sanitize_array",
            "_is_dtype_type",
            "test_is_unsigned_integer_dtype",
            "test_is_not_int64_dtype",
            "test_is_datetime_or_timedelta_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "_get_dtype_type",
            "test_is_not_signed_integer_dtype",
            "infer_dtype_from_object",
            "get_empty_dtype_and_na",
            "classes_and_not_datetimelike",
            "is_integer_dtype",
            "_concat_compat",
            "test_is_not_integer_dtype",
            "classes",
            "test_is_int64_dtype",
            "_get_dtype_from_object",
            "is_object_dtype"
          ]
        },
        "file": {
          "file_name": "common.py",
          "file_nloc": 352,
          "file_complexity": 165,
          "file_token_count": 2421,
          "file_before": "\"\"\" common type operations \"\"\"\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.interval import Interval\nfrom pandas._libs.tslibs import Period, Timestamp, conversion\nfrom pandas.compat import PY3, PY36, binary_type, string_types, text_type\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype, CategoricalDtypeType, DatetimeTZDtype, ExtensionDtype,\n    IntervalDtype, PandasExtensionDtype, PeriodDtype, registry)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical, ABCCategoricalIndex, ABCDateOffset, ABCDatetimeIndex,\n    ABCIndexClass, ABCPeriodArray, ABCPeriodIndex, ABCSeries, ABCSparseArray,\n    ABCSparseSeries)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like, is_bool, is_complex, is_decimal, is_dict_like, is_file_like,\n    is_float, is_hashable, is_integer, is_interval, is_iterator, is_list_like,\n    is_named_tuple, is_nested_list_like, is_number, is_re, is_re_compilable,\n    is_scalar, is_sequence, is_string_like)\n\n_POSSIBLY_CAST_DTYPES = {np.dtype(t).name\n                         for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                   'int32', 'uint32', 'int64', 'uint64']}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int64_or_float64(arr, copy=False):\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: boolean\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n    \"\"\"\n    try:\n        return arr.astype('int64', copy=copy, casting='safe')\n    except TypeError:\n        return arr.astype('float64', copy=copy)\n\n\ndef is_object_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.object_)\n\n\ndef is_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    DataFrame.to_sparse : Convert DataFrame to a SparseDataFrame.\n    Series.to_sparse : Convert Series to SparseSeries.\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.SparseSeries([0, 0, 1, 0]))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n\n    >>> df = pd.SparseDataFrame([389., 24., 80.5, np.nan],\n                                columns=['max_speed'],\n                                index=['falcon', 'parrot', 'lion', 'monkey'])\n    >>> is_sparse(df)\n    False\n    >>> is_sparse(df.max_speed)\n    True\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, 'dtype', arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a\n              scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    >>> is_scipy_sparse(pd.SparseSeries([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr):\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime array-like with\n              a timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_datetimetz' is deprecated and will be removed in a \"\n                  \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n                  FutureWarning, stacklevel=2)\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj):\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean : Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif (is_list_like(arr_or_obj) and len(arr_or_obj) and\n          is_object_dtype(arr_or_obj)):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr):\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_period' is deprecated and will be removed in a future \"\n                  \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n                  \"instead.\", FutureWarning, stacklevel=2)\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except (TypeError, UnicodeEncodeError):\n        return False\n    return issubclass(tipo, np.datetime64)\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except (TypeError, ValueError, SyntaxError):\n        return False\n    return issubclass(tipo, np.timedelta64)\n\n\ndef is_period_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    except TypeError:\n        return False\n\n\ndef is_period_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical\n              array-like or PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime\n              array-like or DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (is_object_dtype(arr.dtype)\n                and lib.infer_dtype(arr, skipna=False) == 'datetime')\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime-like array-like.\n\n    Acceptable datetime-like objects are (but not limited to) datetime\n    indices, periodic indices, and timedelta indices.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime-like array-like.\n\n    Examples\n    --------\n    >>> is_datetimelike([1, 2, 3])\n    False\n    >>> is_datetimelike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>> is_datetimelike(pd.PeriodIndex([], freq=\"A\"))\n    True\n    >>> is_datetimelike(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetimelike(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimelike(s)\n    True\n    \"\"\"\n\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean : Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_dtype_union_equal(source, target):\n    \"\"\"\n    Check whether two arrays have compatible dtypes to do a union.\n    numpy types are checked with ``is_dtype_equal``. Extension types are\n    checked separately.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean : Whether or not the two dtypes are equal.\n\n    >>> is_dtype_equal(\"int\", int)\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c']))\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c'], ordered=True))\n    False\n    \"\"\"\n    source = _get_dtype(source)\n    target = _get_dtype(target)\n    if is_categorical_dtype(source) and is_categorical_dtype(target):\n        # ordered False for both\n        return source.ordered is target.ordered\n    return is_dtype_equal(source, target)\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    \"\"\"Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.integer)\n\n\ndef is_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a signed integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.signedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an\n              unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.unsignedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.int64)\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the\n              timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n        return tipo == _TD_DTYPE\n    except TypeError:\n        return False\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a\n              timedelta64, or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, (np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean : Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a string-like\n              object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(1, 1)\n    False\n    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n    False\n    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n    False\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to a numeric object.\n\n    By \"numeric,\" we mean an object that is either of an int or float dtype.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to a numeric object.\n\n    Examples\n    --------\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_numeric(1, 1)\n    False\n    >>> is_datetimelike_v_numeric(dt, dt)\n    False\n    >>> is_datetimelike_v_numeric(1, dt)\n    True\n    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n    False\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        \"\"\"\n        Check if an object has a numeric dtype (i.e. integer or float).\n        \"\"\"\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to an object instance.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to an object instance.\n\n    Examples\n    --------\n    >>> obj = object()\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_object(obj, obj)\n    False\n    >>> is_datetimelike_v_object(dt, dt)\n    False\n    >>> is_datetimelike_v_object(obj, dt)\n    True\n    >>> is_datetimelike_v_object(dt, obj)  # symmetric check\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), obj)\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), dt)\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([obj]))\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), np.array([obj]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([1]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object_dtype(b)) or\n            (is_datetimelike(b) and is_object_dtype(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, (np.number, np.bool_)) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('S', 'U')\n    except TypeError:\n        return False\n\n\ndef is_float_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.floating)\n\n\ndef is_bool_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except ValueError:\n        # this isn't even a dtype\n        return False\n\n    if isinstance(arr_or_dtype, (ABCCategorical, ABCCategoricalIndex)):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return (arr_or_dtype.is_object and\n                arr_or_dtype.inferred_type == 'boolean')\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(tipo, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a pandas\n              extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> is_extension_type(pd.SparseSeries([1, 2, 3]))\n    True\n    >>>\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype):\n    \"\"\"Check if an object is a pandas extension array type.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n\n    Returns\n    -------\n    bool\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n    \"\"\"\n    dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n    return (isinstance(dtype, ExtensionDtype) or\n            registry.find(dtype) is not None)\n\n\ndef is_complex_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a compex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.complexfloating)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    # TODO(extension)\n    # replace with pandas_dtype\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n    elif isinstance(arr_or_dtype, ExtensionDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, IntervalDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtype.construct_from_string(arr_or_dtype)\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtype.construct_from_string(arr_or_dtype)\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtype.construct_from_string(arr_or_dtype)\n        elif is_interval_dtype(arr_or_dtype):\n            return IntervalDtype.construct_from_string(arr_or_dtype)\n    elif isinstance(arr_or_dtype, (ABCCategorical, ABCCategoricalIndex,\n                                   ABCSparseArray, ABCSparseSeries)):\n        return arr_or_dtype.dtype\n\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n    return np.dtype(arr_or_dtype)\n\n\ndef _get_dtype_type(arr_or_dtype):\n    \"\"\"\n    Get the type (NOT dtype) instance associated with\n    an array or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose type we want to extract.\n\n    Returns\n    -------\n    obj_type : The extract type instance from the\n               passed in array or dtype object.\n    \"\"\"\n\n    # TODO(extension)\n    # replace with pandas_dtype\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype.type\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype).type\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return CategoricalDtypeType\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return Timestamp\n    elif isinstance(arr_or_dtype, IntervalDtype):\n        return Interval\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return Period\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtypeType\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return Timestamp\n        elif is_period_dtype(arr_or_dtype):\n            return Period\n        elif is_interval_dtype(arr_or_dtype):\n            return Interval\n        return _get_dtype_type(np.dtype(arr_or_dtype))\n    else:\n        from pandas.core.arrays.sparse import SparseDtype\n        if isinstance(arr_or_dtype, (ABCSparseSeries,\n                                     ABCSparseArray,\n                                     SparseDtype)):\n            dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n            return dtype.type\n    try:\n        return arr_or_dtype.dtype.type\n    except AttributeError:\n        return type(None)\n\n\ndef _get_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif is_categorical(dtype):\n        return CategoricalDtype().type\n    elif is_datetime64tz_dtype(dtype):\n        return DatetimeTZDtype(dtype).type\n    elif isinstance(dtype, np.dtype):  # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n    elif isinstance(dtype, string_types):\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n\n        try:\n            return _get_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return _get_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('{error}'.format(error=e))\n    if typ != 'generic' and typ != 'ns':\n        msg = '{name!r} is too specific of a frequency, try passing {type!r}'\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\n_string_dtypes = frozenset(map(_get_dtype_from_object, (binary_type,\n                                                        text_type)))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, np.dtype):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # un-registered extension types\n    elif isinstance(dtype, (PandasExtensionDtype, ExtensionDtype)):\n        return dtype\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except Exception:\n        # we don't want to force a repr of the non-string\n        if not isinstance(dtype, string_types):\n            raise TypeError(\"data type not understood\")\n        raise TypeError(\"data type '{}' not understood\".format(\n            dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, 'object', 'O']:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == 'O':\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_after": "\"\"\" common type operations \"\"\"\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import algos, lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.compat import PY3, PY36, string_types\n\nfrom pandas.core.dtypes.dtypes import (\n    CategoricalDtype, DatetimeTZDtype, ExtensionDtype, IntervalDtype,\n    PandasExtensionDtype, PeriodDtype, registry)\nfrom pandas.core.dtypes.generic import (\n    ABCCategorical, ABCDateOffset, ABCDatetimeIndex, ABCIndexClass,\n    ABCPeriodArray, ABCPeriodIndex, ABCSeries)\nfrom pandas.core.dtypes.inference import (  # noqa:F401\n    is_array_like, is_bool, is_complex, is_decimal, is_dict_like, is_file_like,\n    is_float, is_hashable, is_integer, is_interval, is_iterator, is_list_like,\n    is_named_tuple, is_nested_list_like, is_number, is_re, is_re_compilable,\n    is_scalar, is_sequence, is_string_like)\n\n_POSSIBLY_CAST_DTYPES = {np.dtype(t).name\n                         for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                   'int32', 'uint32', 'int64', 'uint64']}\n\n_NS_DTYPE = conversion.NS_DTYPE\n_TD_DTYPE = conversion.TD_DTYPE\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\nensure_float64 = algos.ensure_float64\nensure_float32 = algos.ensure_float32\n\n_ensure_datetime64ns = conversion.ensure_datetime64ns\n_ensure_timedelta64ns = conversion.ensure_timedelta64ns\n\n\ndef ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\nensure_uint64 = algos.ensure_uint64\nensure_int64 = algos.ensure_int64\nensure_int32 = algos.ensure_int32\nensure_int16 = algos.ensure_int16\nensure_int8 = algos.ensure_int8\nensure_platform_int = algos.ensure_platform_int\nensure_object = algos.ensure_object\n\n\ndef ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef ensure_int64_or_float64(arr, copy=False):\n    \"\"\"\n    Ensure that an dtype array of some integer dtype\n    has an int64 dtype if possible\n    If it's not possible, potentially because of overflow,\n    convert the array to float64 instead.\n\n    Parameters\n    ----------\n    arr : array-like\n          The array whose data type we want to enforce.\n    copy: boolean\n          Whether to copy the original array or reuse\n          it in place, if possible.\n\n    Returns\n    -------\n    out_arr : The input array cast as int64 if\n              possible without overflow.\n              Otherwise the input array cast to float64.\n    \"\"\"\n    try:\n        return arr.astype('int64', copy=copy, casting='safe')\n    except TypeError:\n        return arr.astype('float64', copy=copy)\n\n\ndef classes(*klasses):\n    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n    return lambda tipo: issubclass(tipo, klasses)\n\n\ndef classes_and_not_datetimelike(*klasses):\n    \"\"\"\n    evaluate if the tipo is a subclass of the klasses\n    and not a datetimelike\n    \"\"\"\n    return lambda tipo: (issubclass(tipo, klasses) and\n                         not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_object_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n\n\ndef is_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a 1-D pandas sparse array.\n\n    Check that the one-dimensional array-like is a pandas sparse array.\n    Returns True if it is a pandas sparse array, not another type of\n    sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        Array-like to check.\n\n    Returns\n    -------\n    bool\n        Whether or not the array-like is a pandas sparse array.\n\n    See Also\n    --------\n    DataFrame.to_sparse : Convert DataFrame to a SparseDataFrame.\n    Series.to_sparse : Convert Series to SparseSeries.\n    Series.to_dense : Return dense representation of a Series.\n\n    Examples\n    --------\n    Returns `True` if the parameter is a 1-D pandas sparse array.\n\n    >>> is_sparse(pd.SparseArray([0, 0, 1, 0]))\n    True\n    >>> is_sparse(pd.SparseSeries([0, 0, 1, 0]))\n    True\n\n    Returns `False` if the parameter is not sparse.\n\n    >>> is_sparse(np.array([0, 0, 1, 0]))\n    False\n    >>> is_sparse(pd.Series([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter is not a pandas sparse array.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([0, 1, 0, 0]))\n    False\n\n    Returns `False` if the parameter has more than one dimension.\n\n    >>> df = pd.SparseDataFrame([389., 24., 80.5, np.nan],\n                                columns=['max_speed'],\n                                index=['falcon', 'parrot', 'lion', 'monkey'])\n    >>> is_sparse(df)\n    False\n    >>> is_sparse(df.max_speed)\n    True\n    \"\"\"\n    from pandas.core.arrays.sparse import SparseDtype\n\n    dtype = getattr(arr, 'dtype', arr)\n    return isinstance(dtype, SparseDtype)\n\n\ndef is_scipy_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a\n              scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    >>> is_scipy_sparse(pd.SparseSeries([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr):\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals, Series Categoricals, and CategoricalIndex will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    >>> is_categorical(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime array-like with\n              a timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_datetimetz' is deprecated and will be removed in a \"\n                  \"future version.  Use 'is_datetime64tz_dtype' instead.\",\n                  FutureWarning, stacklevel=2)\n    return is_datetime64tz_dtype(arr)\n\n\ndef is_offsetlike(arr_or_obj):\n    \"\"\"\n    Check if obj or all elements of list-like is DateOffset\n\n    Parameters\n    ----------\n    arr_or_obj : object\n\n    Returns\n    -------\n    boolean : Whether the object is a DateOffset or listlike of DatetOffsets\n\n    Examples\n    --------\n    >>> is_offsetlike(pd.DateOffset(days=1))\n    True\n    >>> is_offsetlike('offset')\n    False\n    >>> is_offsetlike([pd.offsets.Minute(4), pd.offsets.MonthEnd()])\n    True\n    >>> is_offsetlike(np.array([pd.DateOffset(months=3), pd.Timestamp.now()]))\n    False\n    \"\"\"\n    if isinstance(arr_or_obj, ABCDateOffset):\n        return True\n    elif (is_list_like(arr_or_obj) and len(arr_or_obj) and\n          is_object_dtype(arr_or_obj)):\n        return all(isinstance(x, ABCDateOffset) for x in arr_or_obj)\n    return False\n\n\ndef is_period(arr):\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    .. deprecated:: 0.24.0\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    warnings.warn(\"'is_period' is deprecated and will be removed in a future \"\n                  \"version.  Use 'is_period_dtype' or is_period_arraylike' \"\n                  \"instead.\", FutureWarning, stacklevel=2)\n\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype('0 days')\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n\n\ndef is_period_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n    def condition(dtype):\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    return _is_dtype(arr_or_dtype, condition)\n\n\ndef is_period_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical\n              array-like or PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, (ABCPeriodIndex, ABCPeriodArray)):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return is_period_dtype(arr.dtype)\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime\n              array-like or DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return (is_object_dtype(arr.dtype)\n                and lib.infer_dtype(arr, skipna=False) == 'datetime')\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime-like array-like.\n\n    Acceptable datetime-like objects are (but not limited to) datetime\n    indices, periodic indices, and timedelta indices.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime-like array-like.\n\n    Examples\n    --------\n    >>> is_datetimelike([1, 2, 3])\n    False\n    >>> is_datetimelike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>> is_datetimelike(pd.PeriodIndex([], freq=\"A\"))\n    True\n    >>> is_datetimelike(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetimelike(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimelike(s)\n    True\n    \"\"\"\n\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean : Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_dtype_union_equal(source, target):\n    \"\"\"\n    Check whether two arrays have compatible dtypes to do a union.\n    numpy types are checked with ``is_dtype_equal``. Extension types are\n    checked separately.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean : Whether or not the two dtypes are equal.\n\n    >>> is_dtype_equal(\"int\", int)\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c']))\n    True\n\n    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],\n    ...                CategoricalDtype(['b', 'c'], ordered=True))\n    False\n    \"\"\"\n    source = _get_dtype(source)\n    target = _get_dtype(target)\n    if is_categorical_dtype(source) and is_categorical_dtype(target):\n        # ordered False for both\n        return source.ordered is target.ordered\n    return is_dtype_equal(source, target)\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    \"\"\"Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    This function is internal and should not be exposed in the public API.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes(np.integer, np.timedelta64))\n\n\ndef is_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype('int8')\n    True\n    >>> is_integer_dtype('Int8')\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.integer))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n       as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a signed integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype('int8')\n    True\n    >>> is_signed_integer_dtype('Int8')\n    True\n    >>> is_signed_dtype(pd.Int8Dtype)\n    True\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    .. versionchanged:: 0.24.0\n\n       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n       considered as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an\n              unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype('uint8')\n    True\n    >>> is_unsigned_integer_dtype('UInt8')\n    True\n    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype('int8')\n    False\n    >>> is_int64_dtype('Int8')\n    False\n    >>> is_int64_dtype(pd.Int64Dtype)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the\n              timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a\n              timedelta64, or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes(np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean : Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a string-like\n              object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(1, 1)\n    False\n    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n    False\n    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n    False\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to a numeric object.\n\n    By \"numeric,\" we mean an object that is either of an int or float dtype.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to a numeric object.\n\n    Examples\n    --------\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_numeric(1, 1)\n    False\n    >>> is_datetimelike_v_numeric(dt, dt)\n    False\n    >>> is_datetimelike_v_numeric(1, dt)\n    True\n    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n    False\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        \"\"\"\n        Check if an object has a numeric dtype (i.e. integer or float).\n        \"\"\"\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to an object instance.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to an object instance.\n\n    Examples\n    --------\n    >>> obj = object()\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_object(obj, obj)\n    False\n    >>> is_datetimelike_v_object(dt, dt)\n    False\n    >>> is_datetimelike_v_object(obj, dt)\n    True\n    >>> is_datetimelike_v_object(dt, obj)  # symmetric check\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), obj)\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), dt)\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([obj]))\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), np.array([obj]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([1]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object_dtype(b)) or\n            (is_datetimelike(b) and is_object_dtype(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    return _is_dtype_type(\n        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    return _is_dtype(\n        arr_or_dtype, lambda dtype: dtype.kind in ('S', 'U'))\n\n\ndef is_float_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    This function is internal and should not be exposed in the public API.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n\n\ndef is_bool_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except TypeError:\n        return False\n\n    if isinstance(arr_or_dtype, CategoricalDtype):\n        arr_or_dtype = arr_or_dtype.categories\n        # now we use the special definition for Index\n\n    if isinstance(arr_or_dtype, ABCIndexClass):\n\n        # TODO(jreback)\n        # we don't have a boolean Index class\n        # so its object, we need to infer to\n        # guess this\n        return (arr_or_dtype.is_object and\n                arr_or_dtype.inferred_type == 'boolean')\n    elif is_extension_array_dtype(arr_or_dtype):\n        dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n        return dtype._is_boolean\n\n    return issubclass(dtype.type, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a pandas\n              extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> is_extension_type(pd.SparseSeries([1, 2, 3]))\n    True\n    >>>\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetime64tz_dtype(arr):\n        return True\n    return False\n\n\ndef is_extension_array_dtype(arr_or_dtype):\n    \"\"\"Check if an object is a pandas extension array type.\n\n    Parameters\n    ----------\n    arr_or_dtype : object\n\n    Returns\n    -------\n    bool\n\n    Notes\n    -----\n    This checks whether an object implements the pandas extension\n    array interface. In pandas, this includes:\n\n    * Categorical\n    * Sparse\n    * Interval\n\n    Third-party libraries may implement arrays or types satisfying\n    this interface as well.\n    \"\"\"\n    dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n    return (isinstance(dtype, ExtensionDtype) or\n            registry.find(dtype) is not None)\n\n\ndef is_complex_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a compex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n\n\ndef _is_dtype(arr_or_dtype, condition):\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtype]]\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError, UnicodeEncodeError):\n        return False\n    return condition(dtype)\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n\n    # fastpath\n    elif isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n\n    # if we have an array-like\n    elif hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    return pandas_dtype(arr_or_dtype)\n\n\ndef _is_dtype_type(arr_or_dtype, condition):\n    \"\"\"\n    Return a boolean if the condition is satisfied for the arr_or_dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n\n    Returns\n    -------\n    bool : if the condition is satisifed for the arr_or_dtype\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return condition(type(None))\n\n    # fastpath\n    if isinstance(arr_or_dtype, np.dtype):\n        return condition(arr_or_dtype.type)\n    elif isinstance(arr_or_dtype, type):\n        if issubclass(arr_or_dtype, (PandasExtensionDtype, ExtensionDtype)):\n            arr_or_dtype = arr_or_dtype.type\n        return condition(np.dtype(arr_or_dtype).type)\n    elif arr_or_dtype is None:\n        return condition(type(None))\n\n    # if we have an array-like\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n\n    # we are not possibly a dtype\n    elif is_list_like(arr_or_dtype):\n        return condition(type(None))\n\n    try:\n        tipo = pandas_dtype(arr_or_dtype).type\n    except (TypeError, ValueError, UnicodeEncodeError):\n        if is_scalar(arr_or_dtype):\n            return condition(type(None))\n\n        return False\n\n    return condition(tipo)\n\n\ndef infer_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n        # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n\n    try:\n        dtype = pandas_dtype(dtype)\n    except TypeError:\n        pass\n\n    if is_extension_array_dtype(dtype):\n        return dtype.type\n    elif isinstance(dtype, string_types):\n\n        # TODO(jreback)\n        # should deprecate these\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n        try:\n            return infer_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return infer_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('{error}'.format(error=e))\n    if typ != 'generic' and typ != 'ns':\n        msg = '{name!r} is too specific of a frequency, try passing {type!r}'\n        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n    \"\"\"\n    # short-circuit\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n        return dtype\n\n    # registered extension types\n    result = registry.find(dtype)\n    if result is not None:\n        return result\n\n    # try a numpy dtype\n    # raise a consistent TypeError if failed\n    try:\n        npdtype = np.dtype(dtype)\n    except Exception:\n        # we don't want to force a repr of the non-string\n        if not isinstance(dtype, string_types):\n            raise TypeError(\"data type not understood\")\n        raise TypeError(\"data type '{}' not understood\".format(\n            dtype))\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if is_hashable(dtype) and dtype in [object, np.object_, 'object', 'O']:\n        # check hashability to avoid errors/DeprecationWarning when we get\n        # here and `dtype` is an array\n        return npdtype\n    elif npdtype.kind == 'O':\n        raise TypeError(\"dtype '{}' not understood\".format(dtype))\n\n    return npdtype\n",
          "file_patch": "@@ -4,17 +4,15 @@ import warnings\n import numpy as np\n \n from pandas._libs import algos, lib\n-from pandas._libs.interval import Interval\n-from pandas._libs.tslibs import Period, Timestamp, conversion\n-from pandas.compat import PY3, PY36, binary_type, string_types, text_type\n+from pandas._libs.tslibs import conversion\n+from pandas.compat import PY3, PY36, string_types\n \n from pandas.core.dtypes.dtypes import (\n-    CategoricalDtype, CategoricalDtypeType, DatetimeTZDtype, ExtensionDtype,\n-    IntervalDtype, PandasExtensionDtype, PeriodDtype, registry)\n+    CategoricalDtype, DatetimeTZDtype, ExtensionDtype, IntervalDtype,\n+    PandasExtensionDtype, PeriodDtype, registry)\n from pandas.core.dtypes.generic import (\n-    ABCCategorical, ABCCategoricalIndex, ABCDateOffset, ABCDatetimeIndex,\n-    ABCIndexClass, ABCPeriodArray, ABCPeriodIndex, ABCSeries, ABCSparseArray,\n-    ABCSparseSeries)\n+    ABCCategorical, ABCDateOffset, ABCDatetimeIndex, ABCIndexClass,\n+    ABCPeriodArray, ABCPeriodIndex, ABCSeries)\n from pandas.core.dtypes.inference import (  # noqa:F401\n     is_array_like, is_bool, is_complex, is_decimal, is_dict_like, is_file_like,\n     is_float, is_hashable, is_integer, is_interval, is_iterator, is_list_like,\n@@ -116,6 +114,20 @@ def ensure_int64_or_float64(arr, copy=False):\n         return arr.astype('float64', copy=copy)\n \n \n+def classes(*klasses):\n+    \"\"\" evaluate if the tipo is a subclass of the klasses \"\"\"\n+    return lambda tipo: issubclass(tipo, klasses)\n+\n+\n+def classes_and_not_datetimelike(*klasses):\n+    \"\"\"\n+    evaluate if the tipo is a subclass of the klasses\n+    and not a datetimelike\n+    \"\"\"\n+    return lambda tipo: (issubclass(tipo, klasses) and\n+                         not issubclass(tipo, (np.datetime64, np.timedelta64)))\n+\n+\n def is_object_dtype(arr_or_dtype):\n     \"\"\"\n     Check whether an array-like or dtype is of the object dtype.\n@@ -142,11 +154,7 @@ def is_object_dtype(arr_or_dtype):\n     >>> is_object_dtype([1, 2, 3])\n     False\n     \"\"\"\n-\n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return issubclass(tipo, np.object_)\n+    return _is_dtype_type(arr_or_dtype, classes(np.object_))\n \n \n def is_sparse(arr):\n@@ -420,13 +428,7 @@ def is_datetime64_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    try:\n-        tipo = _get_dtype_type(arr_or_dtype)\n-    except (TypeError, UnicodeEncodeError):\n-        return False\n-    return issubclass(tipo, np.datetime64)\n+    return _is_dtype_type(arr_or_dtype, classes(np.datetime64))\n \n \n def is_datetime64tz_dtype(arr_or_dtype):\n@@ -495,13 +497,7 @@ def is_timedelta64_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    try:\n-        tipo = _get_dtype_type(arr_or_dtype)\n-    except (TypeError, ValueError, SyntaxError):\n-        return False\n-    return issubclass(tipo, np.timedelta64)\n+    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))\n \n \n def is_period_dtype(arr_or_dtype):\n@@ -635,14 +631,9 @@ def is_string_dtype(arr_or_dtype):\n     \"\"\"\n \n     # TODO: gh-15585: consider making the checks stricter.\n-\n-    if arr_or_dtype is None:\n-        return False\n-    try:\n-        dtype = _get_dtype(arr_or_dtype)\n+    def condition(dtype):\n         return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n-    except TypeError:\n-        return False\n+    return _is_dtype(arr_or_dtype, condition)\n \n \n def is_period_arraylike(arr):\n@@ -832,6 +823,11 @@ def is_any_int_dtype(arr_or_dtype):\n \n     This function is internal and should not be exposed in the public API.\n \n+    .. versionchanged:: 0.24.0\n+\n+       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n+       as integer by this function.\n+\n     Parameters\n     ----------\n     arr_or_dtype : array-like\n@@ -865,10 +861,8 @@ def is_any_int_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return issubclass(tipo, np.integer)\n+    return _is_dtype_type(\n+        arr_or_dtype, classes(np.integer, np.timedelta64))\n \n \n def is_integer_dtype(arr_or_dtype):\n@@ -877,6 +871,11 @@ def is_integer_dtype(arr_or_dtype):\n \n     Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n \n+    .. versionchanged:: 0.24.0\n+\n+       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n+       as integer by this function.\n+\n     Parameters\n     ----------\n     arr_or_dtype : array-like\n@@ -897,6 +896,12 @@ def is_integer_dtype(arr_or_dtype):\n     False\n     >>> is_integer_dtype(np.uint64)\n     True\n+    >>> is_integer_dtype('int8')\n+    True\n+    >>> is_integer_dtype('Int8')\n+    True\n+    >>> is_integer_dtype(pd.Int8Dtype)\n+    True\n     >>> is_integer_dtype(np.datetime64)\n     False\n     >>> is_integer_dtype(np.timedelta64)\n@@ -911,11 +916,8 @@ def is_integer_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return (issubclass(tipo, np.integer) and\n-            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n+    return _is_dtype_type(\n+        arr_or_dtype, classes_and_not_datetimelike(np.integer))\n \n \n def is_signed_integer_dtype(arr_or_dtype):\n@@ -924,6 +926,11 @@ def is_signed_integer_dtype(arr_or_dtype):\n \n     Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n \n+    .. versionchanged:: 0.24.0\n+\n+       The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n+       as integer by this function.\n+\n     Parameters\n     ----------\n     arr_or_dtype : array-like\n@@ -944,6 +951,12 @@ def is_signed_integer_dtype(arr_or_dtype):\n     False\n     >>> is_signed_integer_dtype(np.uint64)  # unsigned\n     False\n+    >>> is_signed_integer_dtype('int8')\n+    True\n+    >>> is_signed_integer_dtype('Int8')\n+    True\n+    >>> is_signed_dtype(pd.Int8Dtype)\n+    True\n     >>> is_signed_integer_dtype(np.datetime64)\n     False\n     >>> is_signed_integer_dtype(np.timedelta64)\n@@ -960,17 +973,19 @@ def is_signed_integer_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return (issubclass(tipo, np.signedinteger) and\n-            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n+    return _is_dtype_type(\n+        arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))\n \n \n def is_unsigned_integer_dtype(arr_or_dtype):\n     \"\"\"\n     Check whether the provided array or dtype is of an unsigned integer dtype.\n \n+    .. versionchanged:: 0.24.0\n+\n+       The nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also\n+       considered as integer by this function.\n+\n     Parameters\n     ----------\n     arr_or_dtype : array-like\n@@ -991,6 +1006,12 @@ def is_unsigned_integer_dtype(arr_or_dtype):\n     False\n     >>> is_unsigned_integer_dtype(np.uint64)\n     True\n+    >>> is_unsigned_integer_dtype('uint8')\n+    True\n+    >>> is_unsigned_integer_dtype('UInt8')\n+    True\n+    >>> is_unsigned_integer_dtype(pd.UInt8Dtype)\n+    True\n     >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n     False\n     >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n@@ -1000,12 +1021,8 @@ def is_unsigned_integer_dtype(arr_or_dtype):\n     >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n     True\n     \"\"\"\n-\n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return (issubclass(tipo, np.unsignedinteger) and\n-            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n+    return _is_dtype_type(\n+        arr_or_dtype, classes_and_not_datetimelike(np.unsignedinteger))\n \n \n def is_int64_dtype(arr_or_dtype):\n@@ -1035,6 +1052,12 @@ def is_int64_dtype(arr_or_dtype):\n     False\n     >>> is_int64_dtype(np.int64)\n     True\n+    >>> is_int64_dtype('int8')\n+    False\n+    >>> is_int64_dtype('Int8')\n+    False\n+    >>> is_int64_dtype(pd.Int64Dtype)\n+    True\n     >>> is_int64_dtype(float)\n     False\n     >>> is_int64_dtype(np.uint64)  # unsigned\n@@ -1049,10 +1072,7 @@ def is_int64_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return issubclass(tipo, np.int64)\n+    return _is_dtype_type(arr_or_dtype, classes(np.int64))\n \n \n def is_datetime64_any_dtype(arr_or_dtype):\n@@ -1172,14 +1192,7 @@ def is_timedelta64_ns_dtype(arr_or_dtype):\n     >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n     False\n     \"\"\"\n-\n-    if arr_or_dtype is None:\n-        return False\n-    try:\n-        tipo = _get_dtype(arr_or_dtype)\n-        return tipo == _TD_DTYPE\n-    except TypeError:\n-        return False\n+    return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)\n \n \n def is_datetime_or_timedelta_dtype(arr_or_dtype):\n@@ -1217,10 +1230,8 @@ def is_datetime_or_timedelta_dtype(arr_or_dtype):\n     True\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return issubclass(tipo, (np.datetime64, np.timedelta64))\n+    return _is_dtype_type(\n+        arr_or_dtype, classes(np.datetime64, np.timedelta64))\n \n \n def _is_unorderable_exception(e):\n@@ -1495,11 +1506,8 @@ def is_numeric_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return (issubclass(tipo, (np.number, np.bool_)) and\n-            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n+    return _is_dtype_type(\n+        arr_or_dtype, classes_and_not_datetimelike(np.number, np.bool_))\n \n \n def is_string_like_dtype(arr_or_dtype):\n@@ -1530,13 +1538,8 @@ def is_string_like_dtype(arr_or_dtype):\n     False\n     \"\"\"\n \n-    if arr_or_dtype is None:\n-        return False\n-    try:\n-        dtype = _get_dtype(arr_or_dtype)\n-        return dtype.kind in ('S', 'U')\n-    except TypeError:\n-        return False\n+    return _is_dtype(\n+        arr_or_dtype, lambda dtype: dtype.kind in ('S', 'U'))\n \n \n def is_float_dtype(arr_or_dtype):\n@@ -1569,11 +1572,7 @@ def is_float_dtype(arr_or_dtype):\n     >>> is_float_dtype(pd.Index([1, 2.]))\n     True\n     \"\"\"\n-\n-    if arr_or_dtype is None:\n-        return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return issubclass(tipo, np.floating)\n+    return _is_dtype_type(arr_or_dtype, classes(np.floating))\n \n \n def is_bool_dtype(arr_or_dtype):\n@@ -1618,14 +1617,10 @@ def is_bool_dtype(arr_or_dtype):\n     if arr_or_dtype is None:\n         return False\n     try:\n-        tipo = _get_dtype_type(arr_or_dtype)\n-    except ValueError:\n-        # this isn't even a dtype\n+        dtype = _get_dtype(arr_or_dtype)\n+    except TypeError:\n         return False\n \n-    if isinstance(arr_or_dtype, (ABCCategorical, ABCCategoricalIndex)):\n-        arr_or_dtype = arr_or_dtype.dtype\n-\n     if isinstance(arr_or_dtype, CategoricalDtype):\n         arr_or_dtype = arr_or_dtype.categories\n         # now we use the special definition for Index\n@@ -1642,7 +1637,7 @@ def is_bool_dtype(arr_or_dtype):\n         dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n         return dtype._is_boolean\n \n-    return issubclass(tipo, np.bool_)\n+    return issubclass(dtype.type, np.bool_)\n \n \n def is_extension_type(arr):\n@@ -1761,10 +1756,32 @@ def is_complex_dtype(arr_or_dtype):\n     True\n     \"\"\"\n \n+    return _is_dtype_type(arr_or_dtype, classes(np.complexfloating))\n+\n+\n+def _is_dtype(arr_or_dtype, condition):\n+    \"\"\"\n+    Return a boolean if the condition is satisfied for the arr_or_dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType\n+        The array-like or dtype object whose dtype we want to extract.\n+    condition : callable[Union[np.dtype, ExtensionDtype]]\n+\n+    Returns\n+    -------\n+    bool\n+\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n-    tipo = _get_dtype_type(arr_or_dtype)\n-    return issubclass(tipo, np.complexfloating)\n+    try:\n+        dtype = _get_dtype(arr_or_dtype)\n+    except (TypeError, ValueError, UnicodeEncodeError):\n+        return False\n+    return condition(dtype)\n \n \n def _get_dtype(arr_or_dtype):\n@@ -1787,95 +1804,70 @@ def _get_dtype(arr_or_dtype):\n     TypeError : The passed in object is None.\n     \"\"\"\n \n-    # TODO(extension)\n-    # replace with pandas_dtype\n-\n     if arr_or_dtype is None:\n         raise TypeError(\"Cannot deduce dtype from null object\")\n-    if isinstance(arr_or_dtype, np.dtype):\n+\n+    # fastpath\n+    elif isinstance(arr_or_dtype, np.dtype):\n         return arr_or_dtype\n     elif isinstance(arr_or_dtype, type):\n         return np.dtype(arr_or_dtype)\n-    elif isinstance(arr_or_dtype, ExtensionDtype):\n-        return arr_or_dtype\n-    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n-        return arr_or_dtype\n-    elif isinstance(arr_or_dtype, PeriodDtype):\n-        return arr_or_dtype\n-    elif isinstance(arr_or_dtype, IntervalDtype):\n-        return arr_or_dtype\n-    elif isinstance(arr_or_dtype, string_types):\n-        if is_categorical_dtype(arr_or_dtype):\n-            return CategoricalDtype.construct_from_string(arr_or_dtype)\n-        elif is_datetime64tz_dtype(arr_or_dtype):\n-            return DatetimeTZDtype.construct_from_string(arr_or_dtype)\n-        elif is_period_dtype(arr_or_dtype):\n-            return PeriodDtype.construct_from_string(arr_or_dtype)\n-        elif is_interval_dtype(arr_or_dtype):\n-            return IntervalDtype.construct_from_string(arr_or_dtype)\n-    elif isinstance(arr_or_dtype, (ABCCategorical, ABCCategoricalIndex,\n-                                   ABCSparseArray, ABCSparseSeries)):\n-        return arr_or_dtype.dtype\n \n-    if hasattr(arr_or_dtype, 'dtype'):\n+    # if we have an array-like\n+    elif hasattr(arr_or_dtype, 'dtype'):\n         arr_or_dtype = arr_or_dtype.dtype\n-    return np.dtype(arr_or_dtype)\n \n+    return pandas_dtype(arr_or_dtype)\n \n-def _get_dtype_type(arr_or_dtype):\n+\n+def _is_dtype_type(arr_or_dtype, condition):\n     \"\"\"\n-    Get the type (NOT dtype) instance associated with\n-    an array or dtype object.\n+    Return a boolean if the condition is satisfied for the arr_or_dtype.\n \n     Parameters\n     ----------\n     arr_or_dtype : array-like\n-        The array-like or dtype object whose type we want to extract.\n+        The array-like or dtype object whose dtype we want to extract.\n+    condition : callable[Union[np.dtype, ExtensionDtypeType]]\n \n     Returns\n     -------\n-    obj_type : The extract type instance from the\n-               passed in array or dtype object.\n+    bool : if the condition is satisifed for the arr_or_dtype\n     \"\"\"\n \n-    # TODO(extension)\n-    # replace with pandas_dtype\n+    if arr_or_dtype is None:\n+        return condition(type(None))\n+\n+    # fastpath\n     if isinstance(arr_or_dtype, np.dtype):\n-        return arr_or_dtype.type\n+        return condition(arr_or_dtype.type)\n     elif isinstance(arr_or_dtype, type):\n-        return np.dtype(arr_or_dtype).type\n-    elif isinstance(arr_or_dtype, CategoricalDtype):\n-        return CategoricalDtypeType\n-    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n-        return Timestamp\n-    elif isinstance(arr_or_dtype, IntervalDtype):\n-        return Interval\n-    elif isinstance(arr_or_dtype, PeriodDtype):\n-        return Period\n-    elif isinstance(arr_or_dtype, string_types):\n-        if is_categorical_dtype(arr_or_dtype):\n-            return CategoricalDtypeType\n-        elif is_datetime64tz_dtype(arr_or_dtype):\n-            return Timestamp\n-        elif is_period_dtype(arr_or_dtype):\n-            return Period\n-        elif is_interval_dtype(arr_or_dtype):\n-            return Interval\n-        return _get_dtype_type(np.dtype(arr_or_dtype))\n-    else:\n-        from pandas.core.arrays.sparse import SparseDtype\n-        if isinstance(arr_or_dtype, (ABCSparseSeries,\n-                                     ABCSparseArray,\n-                                     SparseDtype)):\n-            dtype = getattr(arr_or_dtype, 'dtype', arr_or_dtype)\n-            return dtype.type\n+        if issubclass(arr_or_dtype, (PandasExtensionDtype, ExtensionDtype)):\n+            arr_or_dtype = arr_or_dtype.type\n+        return condition(np.dtype(arr_or_dtype).type)\n+    elif arr_or_dtype is None:\n+        return condition(type(None))\n+\n+    # if we have an array-like\n+    if hasattr(arr_or_dtype, 'dtype'):\n+        arr_or_dtype = arr_or_dtype.dtype\n+\n+    # we are not possibly a dtype\n+    elif is_list_like(arr_or_dtype):\n+        return condition(type(None))\n+\n     try:\n-        return arr_or_dtype.dtype.type\n-    except AttributeError:\n-        return type(None)\n+        tipo = pandas_dtype(arr_or_dtype).type\n+    except (TypeError, ValueError, UnicodeEncodeError):\n+        if is_scalar(arr_or_dtype):\n+            return condition(type(None))\n+\n+        return False\n+\n+    return condition(tipo)\n \n \n-def _get_dtype_from_object(dtype):\n+def infer_dtype_from_object(dtype):\n     \"\"\"\n     Get a numpy dtype.type-style object for a dtype object.\n \n@@ -1898,18 +1890,26 @@ def _get_dtype_from_object(dtype):\n     if isinstance(dtype, type) and issubclass(dtype, np.generic):\n         # Type object from a dtype\n         return dtype\n-    elif is_categorical(dtype):\n-        return CategoricalDtype().type\n-    elif is_datetime64tz_dtype(dtype):\n-        return DatetimeTZDtype(dtype).type\n-    elif isinstance(dtype, np.dtype):  # dtype object\n+    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n+        # dtype object\n         try:\n             _validate_date_like_dtype(dtype)\n         except TypeError:\n             # Should still pass if we don't have a date-like\n             pass\n         return dtype.type\n+\n+    try:\n+        dtype = pandas_dtype(dtype)\n+    except TypeError:\n+        pass\n+\n+    if is_extension_array_dtype(dtype):\n+        return dtype.type\n     elif isinstance(dtype, string_types):\n+\n+        # TODO(jreback)\n+        # should deprecate these\n         if dtype in ['datetimetz', 'datetime64tz']:\n             return DatetimeTZDtype.type\n         elif dtype in ['period']:\n@@ -1917,9 +1917,8 @@ def _get_dtype_from_object(dtype):\n \n         if dtype == 'datetime' or dtype == 'timedelta':\n             dtype += '64'\n-\n         try:\n-            return _get_dtype_from_object(getattr(np, dtype))\n+            return infer_dtype_from_object(getattr(np, dtype))\n         except (AttributeError, TypeError):\n             # Handles cases like _get_dtype(int) i.e.,\n             # Python objects that are valid dtypes\n@@ -1929,7 +1928,7 @@ def _get_dtype_from_object(dtype):\n             # further handle internal types\n             pass\n \n-    return _get_dtype_from_object(np.dtype(dtype))\n+    return infer_dtype_from_object(np.dtype(dtype))\n \n \n def _validate_date_like_dtype(dtype):\n@@ -1957,10 +1956,6 @@ def _validate_date_like_dtype(dtype):\n         raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))\n \n \n-_string_dtypes = frozenset(map(_get_dtype_from_object, (binary_type,\n-                                                        text_type)))\n-\n-\n def pandas_dtype(dtype):\n     \"\"\"\n     Converts input into a pandas only dtype object or a numpy dtype object.\n@@ -1980,7 +1975,7 @@ def pandas_dtype(dtype):\n     # short-circuit\n     if isinstance(dtype, np.ndarray):\n         return dtype.dtype\n-    elif isinstance(dtype, np.dtype):\n+    elif isinstance(dtype, (np.dtype, PandasExtensionDtype, ExtensionDtype)):\n         return dtype\n \n     # registered extension types\n@@ -1988,10 +1983,6 @@ def pandas_dtype(dtype):\n     if result is not None:\n         return result\n \n-    # un-registered extension types\n-    elif isinstance(dtype, (PandasExtensionDtype, ExtensionDtype)):\n-        return dtype\n-\n     # try a numpy dtype\n     # raise a consistent TypeError if failed\n     try:\n",
          "files_name_in_blame_commit": [
            "common.py",
            "construction.py",
            "test_common.py",
            "concat.py",
            "dtypes.py",
            "pandas_vb_common.py",
            "numeric.py",
            "integer.py",
            "cast.py",
            "conftest.py",
            "frame.py"
          ]
        }
      },
      "1a0c878f733c5fc2b37e6f6ab655e943685036f9": {
        "commit": {
          "commit_id": "1a0c878f733c5fc2b37e6f6ab655e943685036f9",
          "commit_message": "DOC, TST: Document and Test Functions in dtypes/common.py (#16237)\n\n* DOC: Document pandas.core.dtypes.common\r\n\r\nCloses gh-15895.\r\n\r\n* TST: Add tests for pandas.core.dtypes.common\r\n\r\nThe testing of this module was especially lacking\r\nwith the exception of is_dtype_equal and pandas_dtype.",
          "commit_author": "gfyoung",
          "commit_date": "2017-05-04 17:37:14",
          "commit_parent": "a54efdd3f8ff4c9d9248c71e87679af29c856806"
        },
        "function": {
          "function_name": "is_string_dtype",
          "function_code_before": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(np.array([1, 2]))\n    False\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    except TypeError:\n        return False",
          "function_code_after": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    except TypeError:\n        return False",
          "function_before_start_line": 165,
          "function_before_end_line": 201,
          "function_after_start_line": 503,
          "function_after_end_line": 539,
          "function_before_token_count": 44,
          "function_after_token_count": 44,
          "functions_name_modified_file": [
            "is_numeric_v_string_like",
            "is_datetime64_ns_dtype",
            "is_period",
            "is_any_int_dtype",
            "is_numeric_dtype",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_int_or_datetime_dtype",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "_get_dtype_type",
            "is_datetimelike_v_object",
            "is_sparse",
            "is_datetimetz",
            "is_interval_dtype",
            "_ensure_float",
            "_validate_date_like_dtype",
            "is_datetimelike",
            "is_scipy_sparse",
            "_is_unorderable_exception",
            "is_integer_dtype",
            "_ensure_categorical",
            "is_datetime64tz_dtype",
            "is_floating_dtype",
            "is_extension_type",
            "_coerce_to_dtype",
            "_get_dtype_from_object",
            "is_object_dtype",
            "is_string_dtype",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_all_files": [
            "test_dtype_equal_strict",
            "test_is_datetimelike_v_object",
            "is_timedelta64_ns_dtype",
            "test_is_string_dtype",
            "test_period_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_int_or_datetime_dtype",
            "test_is_bool_dtype",
            "test_is_datetime64tz_dtype",
            "test_is_float_dtype",
            "test_is_interval_dtype",
            "test_is_unsigned_integer_dtype",
            "is_datetimetz",
            "_ensure_float",
            "test_dtype_equal",
            "is_integer_dtype",
            "_coerce_to_dtype",
            "test_is_categorical",
            "test_is_period",
            "test_is_timedelta64_dtype",
            "is_object_dtype",
            "test_numpy_string_dtype",
            "test_is_datetimetz",
            "test_is_complex_dtype",
            "test_is_int_or_datetime_dtype",
            "is_any_int_dtype",
            "get_is_dtype_funcs",
            "is_period_arraylike",
            "is_period_dtype",
            "is_string_like_dtype",
            "pandas_dtype",
            "is_datetime64_dtype",
            "is_datetime_or_timedelta_dtype",
            "is_datetimelike_v_object",
            "test_is_extension_type",
            "test_is_period_arraylike",
            "test_is_timedelta64_ns_dtype",
            "is_extension_type",
            "test_is_categorical_dtype",
            "test_is_int64_dtype",
            "test_is_datetimelike_v_numeric",
            "test_is_datetime64_ns_dtype",
            "is_datetime64_ns_dtype",
            "test_get_dtype_error_catch",
            "is_period",
            "test_categorical_dtype",
            "_get_dtype",
            "test_is_period_dtype",
            "is_categorical_dtype",
            "test_is_sparse",
            "test_is_signed_integer_dtype",
            "is_signed_integer_dtype",
            "test_is_integer_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "test_is_object",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "is_interval_dtype",
            "test_numpy_dtype",
            "is_datetimelike",
            "test_datetimetz_dtype",
            "test_is_numeric_dtype",
            "_ensure_categorical",
            "is_string_dtype",
            "is_numeric_v_string_like",
            "is_numeric_dtype",
            "is_int64_dtype",
            "is_timedelta64_dtype",
            "test_is_scipy_sparse",
            "test_is_datetimelike",
            "test_is_numeric_v_string_like",
            "test_is_datetime_arraylike",
            "test_is_datetime64_any_dtype",
            "test_is_string_like_dtype",
            "test_is_datetime_or_timedelta_dtype",
            "_get_dtype_type",
            "is_sparse",
            "test_is_datetime64_dtype",
            "_validate_date_like_dtype",
            "is_scipy_sparse",
            "_is_unorderable_exception",
            "test_invalid_dtype_error",
            "is_datetime64tz_dtype",
            "is_floating_dtype",
            "_get_dtype_from_object",
            "test_needs_i8_conversion",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_co_evolved_modified_file": [
            "is_numeric_v_string_like",
            "is_datetime64_ns_dtype",
            "is_any_int_dtype",
            "is_period",
            "is_numeric_dtype",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_int_or_datetime_dtype",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "_get_dtype_type",
            "is_datetimelike_v_object",
            "is_sparse",
            "is_datetimetz",
            "is_interval_dtype",
            "_ensure_float",
            "is_datetimelike",
            "is_scipy_sparse",
            "is_integer_dtype",
            "is_datetime64tz_dtype",
            "is_extension_type",
            "is_floating_dtype",
            "is_object_dtype",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_co_evolved_all_files": [
            "test_dtype_equal_strict",
            "test_is_datetimelike_v_object",
            "is_timedelta64_ns_dtype",
            "test_is_string_dtype",
            "test_period_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_int_or_datetime_dtype",
            "test_is_bool_dtype",
            "test_is_datetime64tz_dtype",
            "test_is_float_dtype",
            "test_is_interval_dtype",
            "test_is_unsigned_integer_dtype",
            "is_datetimetz",
            "_ensure_float",
            "test_dtype_equal",
            "is_integer_dtype",
            "test_is_categorical",
            "test_is_period",
            "test_is_timedelta64_dtype",
            "is_object_dtype",
            "test_numpy_string_dtype",
            "test_is_datetimetz",
            "test_is_complex_dtype",
            "test_is_int_or_datetime_dtype",
            "is_any_int_dtype",
            "get_is_dtype_funcs",
            "is_period_arraylike",
            "is_period_dtype",
            "is_string_like_dtype",
            "pandas_dtype",
            "is_datetime64_dtype",
            "is_datetime_or_timedelta_dtype",
            "is_datetimelike_v_object",
            "test_is_extension_type",
            "test_is_period_arraylike",
            "test_is_timedelta64_ns_dtype",
            "is_extension_type",
            "test_is_int64_dtype",
            "test_is_datetimelike_v_numeric",
            "test_is_categorical_dtype",
            "test_is_datetime64_ns_dtype",
            "is_datetime64_ns_dtype",
            "is_period",
            "test_categorical_dtype",
            "_get_dtype",
            "test_is_period_dtype",
            "is_categorical_dtype",
            "test_is_signed_integer_dtype",
            "test_is_sparse",
            "is_signed_integer_dtype",
            "test_is_integer_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "test_is_object",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "is_interval_dtype",
            "test_numpy_dtype",
            "is_datetimelike",
            "test_datetimetz_dtype",
            "test_is_numeric_dtype",
            "is_numeric_v_string_like",
            "is_numeric_dtype",
            "is_int64_dtype",
            "is_timedelta64_dtype",
            "test_is_scipy_sparse",
            "test_is_datetimelike",
            "test_is_numeric_v_string_like",
            "test_is_datetime64_any_dtype",
            "test_is_datetime_arraylike",
            "test_is_string_like_dtype",
            "test_is_datetime_or_timedelta_dtype",
            "_get_dtype_type",
            "is_sparse",
            "test_is_datetime64_dtype",
            "is_scipy_sparse",
            "test_invalid_dtype_error",
            "is_datetime64tz_dtype",
            "is_floating_dtype",
            "test_needs_i8_conversion",
            "is_datetimelike_v_numeric"
          ]
        },
        "file": {
          "file_name": "common.py",
          "file_nloc": 415,
          "file_complexity": 199,
          "file_token_count": 2553,
          "file_before": "\"\"\" common type operations \"\"\"\n\nimport numpy as np\nfrom pandas.compat import (string_types, text_type, binary_type,\n                           PY3, PY36)\nfrom pandas._libs import algos, lib\nfrom .dtypes import (CategoricalDtype, CategoricalDtypeType,\n                     DatetimeTZDtype, DatetimeTZDtypeType,\n                     PeriodDtype, PeriodDtypeType,\n                     IntervalDtype, IntervalDtypeType,\n                     ExtensionDtype)\nfrom .generic import (ABCCategorical, ABCPeriodIndex,\n                      ABCDatetimeIndex, ABCSeries,\n                      ABCSparseArray, ABCSparseSeries)\nfrom .inference import is_string_like\nfrom .inference import *  # noqa\n\n\n_POSSIBLY_CAST_DTYPES = set([np.dtype(t).name\n                             for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                       'int32', 'uint32', 'int64', 'uint64']])\n\n_NS_DTYPE = np.dtype('M8[ns]')\n_TD_DTYPE = np.dtype('m8[ns]')\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\n_ensure_float64 = algos.ensure_float64\n_ensure_float32 = algos.ensure_float32\n\n\ndef _ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : ndarray, Series\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\n_ensure_uint64 = algos.ensure_uint64\n_ensure_int64 = algos.ensure_int64\n_ensure_int32 = algos.ensure_int32\n_ensure_int16 = algos.ensure_int16\n_ensure_int8 = algos.ensure_int8\n_ensure_platform_int = algos.ensure_platform_int\n_ensure_object = algos.ensure_object\n\n\ndef _ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef is_object_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.object_)\n\n\ndef is_sparse(array):\n    \"\"\" return if we are a sparse array \"\"\"\n    return isinstance(array, (ABCSparseArray, ABCSparseSeries))\n\n\ndef is_scipy_sparse(array):\n    \"\"\" return if we are a scipy.sparse.spmatrix \"\"\"\n    global _is_scipy_sparse\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n    return _is_scipy_sparse(array)\n\n\ndef is_categorical(array):\n    \"\"\" return if we are a categorical possibility \"\"\"\n    return isinstance(array, ABCCategorical) or is_categorical_dtype(array)\n\n\ndef is_datetimetz(array):\n    \"\"\" return if we are a datetime with tz array \"\"\"\n    return ((isinstance(array, ABCDatetimeIndex) and\n             getattr(array, 'tz', None) is not None) or\n            is_datetime64tz_dtype(array))\n\n\ndef is_period(array):\n    \"\"\" return if we are a period array \"\"\"\n    return isinstance(array, ABCPeriodIndex) or is_period_arraylike(array)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except TypeError:\n        return False\n    return issubclass(tipo, np.datetime64)\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.timedelta64)\n\n\ndef is_period_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(np.array([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    except TypeError:\n        return False\n\n\ndef is_period_arraylike(arr):\n    \"\"\" return if we are period arraylike / PeriodIndex \"\"\"\n    if isinstance(arr, ABCPeriodIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'period'\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\" return if we are datetime arraylike / DatetimeIndex \"\"\"\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'datetime'\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex) or\n            is_datetimetz(arr))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\" return a boolean if the dtypes are equal \"\"\"\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.integer)\n\n\ndef is_integer_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.signedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.unsignedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.int64)\n\n\ndef is_int_or_datetime_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) or\n            issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype\n              is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]')\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]')  # Wrong frequency\n    False\n    >>>\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n        return tipo == _TD_DTYPE\n    except TypeError:\n        return False\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, (np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean : Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    numpy doesn't like to compare numeric arrays vs scalar string-likes\n\n    return a boolean result if this is the case for a,b or b,a\n\n    \"\"\"\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    # return if we have an i8 convertible and numeric comparison\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    # return if we have an i8 convertible and object comparsion\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def f(x):\n        return is_object_dtype(x)\n\n    def is_object(x):\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object(b)) or\n            (is_datetimelike(b) and is_object(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, (np.number, np.bool_)) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>>\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(np.array([1, 2]))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('S', 'U')\n    except TypeError:\n        return False\n\n\ndef is_float_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.floating)\n\n\ndef is_floating_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return isinstance(tipo, np.floating)\n\n\ndef is_bool_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except ValueError:\n        # this isn't even a dtype\n        return False\n    return issubclass(tipo, np.bool_)\n\n\ndef is_extension_type(value):\n    \"\"\"\n    if we are a klass that is preserved by the internals\n    these are internal klasses that we represent (and don't use a np.array)\n    \"\"\"\n    if is_categorical(value):\n        return True\n    elif is_sparse(value):\n        return True\n    elif is_datetimetz(value):\n        return True\n    return False\n\n\ndef is_complex_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.complexfloating)\n\n\ndef _coerce_to_dtype(dtype):\n    \"\"\"\n    Coerce a string or np.dtype to a pandas or numpy\n    dtype if possible.\n\n    If we cannot convert to a pandas dtype initially,\n    we convert to a numpy dtype.\n\n    Parameters\n    ----------\n    dtype : The dtype that we want to coerce.\n\n    Returns\n    -------\n    pd_or_np_dtype : The coerced dtype.\n    \"\"\"\n\n    if is_categorical_dtype(dtype):\n        dtype = CategoricalDtype()\n    elif is_datetime64tz_dtype(dtype):\n        dtype = DatetimeTZDtype(dtype)\n    elif is_period_dtype(dtype):\n        dtype = PeriodDtype(dtype)\n    elif is_interval_dtype(dtype):\n        dtype = IntervalDtype(dtype)\n    else:\n        dtype = np.dtype(dtype)\n    return dtype\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, Series, dtype, type\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, IntervalDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtype.construct_from_string(arr_or_dtype)\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtype.construct_from_string(arr_or_dtype)\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtype.construct_from_string(arr_or_dtype)\n        elif is_interval_dtype(arr_or_dtype):\n            return IntervalDtype.construct_from_string(arr_or_dtype)\n\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n    return np.dtype(arr_or_dtype)\n\n\ndef _get_dtype_type(arr_or_dtype):\n    \"\"\"\n    Get the type (NOT dtype) instance associated with\n    an array or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, Series, dtype, type\n        The array-like or dtype object whose type we want to extract.\n\n    Returns\n    -------\n    obj_type : The extract type instance from the\n               passed in array or dtype object.\n    \"\"\"\n\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype.type\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype).type\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return CategoricalDtypeType\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return DatetimeTZDtypeType\n    elif isinstance(arr_or_dtype, IntervalDtype):\n        return IntervalDtypeType\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return PeriodDtypeType\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtypeType\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtypeType\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtypeType\n        elif is_interval_dtype(arr_or_dtype):\n            return IntervalDtypeType\n        return _get_dtype_type(np.dtype(arr_or_dtype))\n    try:\n        return arr_or_dtype.dtype.type\n    except AttributeError:\n        return type(None)\n\n\ndef _get_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif is_categorical(dtype):\n        return CategoricalDtype().type\n    elif is_datetimetz(dtype):\n        return DatetimeTZDtype(dtype).type\n    elif isinstance(dtype, np.dtype):  # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n    elif isinstance(dtype, string_types):\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n\n        try:\n            return _get_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return _get_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('%s' % e)\n    if typ != 'generic' and typ != 'ns':\n        raise ValueError('%r is too specific of a frequency, try passing %r' %\n                         (dtype.name, dtype.type.__name__))\n\n\n_string_dtypes = frozenset(map(_get_dtype_from_object, (binary_type,\n                                                        text_type)))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n    \"\"\"\n    if isinstance(dtype, DatetimeTZDtype):\n        return dtype\n    elif isinstance(dtype, PeriodDtype):\n        return dtype\n    elif isinstance(dtype, CategoricalDtype):\n        return dtype\n    elif isinstance(dtype, IntervalDtype):\n        return dtype\n    elif isinstance(dtype, string_types):\n        try:\n            return DatetimeTZDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n\n        if dtype.startswith('period[') or dtype.startswith('Period['):\n            # do not parse string like U as period[U]\n            try:\n                return PeriodDtype.construct_from_string(dtype)\n            except TypeError:\n                pass\n\n        elif dtype.startswith('interval[') or dtype.startswith('Interval['):\n            try:\n                return IntervalDtype.construct_from_string(dtype)\n            except TypeError:\n                pass\n\n        try:\n            return CategoricalDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n    elif isinstance(dtype, ExtensionDtype):\n        return dtype\n\n    try:\n        npdtype = np.dtype(dtype)\n    except (TypeError, ValueError):\n        raise\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if dtype in [object, np.object_, 'object', 'O']:\n        return npdtype\n    elif npdtype.kind == 'O':\n        raise TypeError('dtype {0} not understood'.format(dtype))\n\n    return npdtype\n",
          "file_after": "\"\"\" common type operations \"\"\"\n\nimport numpy as np\nfrom pandas.compat import (string_types, text_type, binary_type,\n                           PY3, PY36)\nfrom pandas._libs import algos, lib\nfrom .dtypes import (CategoricalDtype, CategoricalDtypeType,\n                     DatetimeTZDtype, DatetimeTZDtypeType,\n                     PeriodDtype, PeriodDtypeType,\n                     IntervalDtype, IntervalDtypeType,\n                     ExtensionDtype)\nfrom .generic import (ABCCategorical, ABCPeriodIndex,\n                      ABCDatetimeIndex, ABCSeries,\n                      ABCSparseArray, ABCSparseSeries)\nfrom .inference import is_string_like\nfrom .inference import *  # noqa\n\n\n_POSSIBLY_CAST_DTYPES = set([np.dtype(t).name\n                             for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                       'int32', 'uint32', 'int64', 'uint64']])\n\n_NS_DTYPE = np.dtype('M8[ns]')\n_TD_DTYPE = np.dtype('m8[ns]')\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\n_ensure_float64 = algos.ensure_float64\n_ensure_float32 = algos.ensure_float32\n\n\ndef _ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\n_ensure_uint64 = algos.ensure_uint64\n_ensure_int64 = algos.ensure_int64\n_ensure_int32 = algos.ensure_int32\n_ensure_int16 = algos.ensure_int16\n_ensure_int8 = algos.ensure_int8\n_ensure_platform_int = algos.ensure_platform_int\n_ensure_object = algos.ensure_object\n\n\ndef _ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef is_object_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the object dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the object dtype.\n\n    Examples\n    --------\n    >>> is_object_dtype(object)\n    True\n    >>> is_object_dtype(int)\n    False\n    >>> is_object_dtype(np.array([], dtype=object))\n    True\n    >>> is_object_dtype(np.array([], dtype=int))\n    False\n    >>> is_object_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.object_)\n\n\ndef is_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a pandas sparse array.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a pandas sparse array.\n\n    Examples\n    --------\n    >>> is_sparse(np.array([1, 2, 3]))\n    False\n    >>> is_sparse(pd.SparseArray([1, 2, 3]))\n    True\n    >>> is_sparse(pd.SparseSeries([1, 2, 3]))\n    True\n\n    This function checks only for pandas sparse array instances, so\n    sparse arrays from other libraries will return False.\n\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_sparse(bsr_matrix([1, 2, 3]))\n    False\n    \"\"\"\n\n    return isinstance(arr, (ABCSparseArray, ABCSparseSeries))\n\n\ndef is_scipy_sparse(arr):\n    \"\"\"\n    Check whether an array-like is a scipy.sparse.spmatrix instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a\n              scipy.sparse.spmatrix instance.\n\n    Notes\n    -----\n    If scipy is not installed, this function will always return False.\n\n    Examples\n    --------\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n    True\n    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n    False\n    >>> is_scipy_sparse(pd.SparseSeries([1, 2, 3]))\n    False\n    \"\"\"\n\n    global _is_scipy_sparse\n\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n\n    return _is_scipy_sparse(arr)\n\n\ndef is_categorical(arr):\n    \"\"\"\n    Check whether an array-like is a Categorical instance.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a Categorical instance.\n\n    Examples\n    --------\n    >>> is_categorical([1, 2, 3])\n    False\n\n    Categoricals and Series Categoricals will return True.\n\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>> is_categorical(cat)\n    True\n    >>> is_categorical(pd.Series(cat))\n    True\n    \"\"\"\n\n    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n\n\ndef is_datetimetz(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like with a timezone\n    component in its dtype.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime array-like with\n              a timezone component in its dtype.\n\n    Examples\n    --------\n    >>> is_datetimetz([1, 2, 3])\n    False\n\n    Although the following examples are both DatetimeIndex objects,\n    the first one returns False because it has no timezone component\n    unlike the second one, which returns True.\n\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    The object need not be a DatetimeIndex object. It just needs to have\n    a dtype which has a timezone component.\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimetz(s)\n    True\n    \"\"\"\n\n    # TODO: do we need this function?\n    # It seems like a repeat of is_datetime64tz_dtype.\n\n    return ((isinstance(arr, ABCDatetimeIndex) and\n             getattr(arr, 'tz', None) is not None) or\n            is_datetime64tz_dtype(arr))\n\n\ndef is_period(arr):\n    \"\"\"\n    Check whether an array-like is a periodical index.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical index.\n\n    Examples\n    --------\n    >>> is_period([1, 2, 3])\n    False\n    >>> is_period(pd.Index([1, 2, 3]))\n    False\n    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    # TODO: do we need this function?\n    # It seems like a repeat of is_period_arraylike.\n    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_dtype(object)\n    False\n    >>> is_datetime64_dtype(np.datetime64)\n    True\n    >>> is_datetime64_dtype(np.array([], dtype=int))\n    False\n    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_dtype([1, 2, 3])\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except TypeError:\n        return False\n    return issubclass(tipo, np.datetime64)\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of\n              a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the timedelta64 dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.timedelta64)\n\n\ndef is_period_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n    True\n    \"\"\"\n\n    # TODO: Consider making Period an instance of PeriodDtype\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_interval_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Interval dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Interval dtype.\n\n    Examples\n    --------\n    >>> is_interval_dtype(object)\n    False\n    >>> is_interval_dtype(IntervalDtype())\n    True\n    >>> is_interval_dtype([1, 2, 3])\n    False\n    >>>\n    >>> interval = pd.Interval(1, 2, closed=\"right\")\n    >>> is_interval_dtype(interval)\n    False\n    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n    True\n    \"\"\"\n\n    # TODO: Consider making Interval an instance of IntervalDtype\n    if arr_or_dtype is None:\n        return False\n    return IntervalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like or dtype is\n              of the Categorical dtype.\n\n    Examples\n    --------\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    except TypeError:\n        return False\n\n\ndef is_period_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a periodical array-like or PeriodIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a periodical\n              array-like or PeriodIndex instance.\n\n    Examples\n    --------\n    >>> is_period_arraylike([1, 2, 3])\n    False\n    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCPeriodIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'period'\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime array-like or DatetimeIndex.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime\n              array-like or DatetimeIndex.\n\n    Examples\n    --------\n    >>> is_datetime_arraylike([1, 2, 3])\n    False\n    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    \"\"\"\n\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'datetime'\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    \"\"\"\n    Check whether an array-like is a datetime-like array-like.\n\n    Acceptable datetime-like objects are (but not limited to) datetime\n    indices, periodic indices, and timedelta indices.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is a datetime-like array-like.\n\n    Examples\n    --------\n    >>> is_datetimelike([1, 2, 3])\n    False\n    >>> is_datetimelike(pd.Index([1, 2, 3]))\n    False\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3]))\n    True\n    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>> is_datetimelike(pd.PeriodIndex([], freq=\"A\"))\n    True\n    >>> is_datetimelike(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetimelike(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetimelike(s)\n    True\n    \"\"\"\n\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex) or\n            is_datetimetz(arr))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\"\n    Check if two dtypes are equal.\n\n    Parameters\n    ----------\n    source : The first dtype to compare\n    target : The second dtype to compare\n\n    Returns\n    ----------\n    boolean : Whether or not the two dtypes are equal.\n\n    Examples\n    --------\n    >>> is_dtype_equal(int, float)\n    False\n    >>> is_dtype_equal(\"int\", int)\n    True\n    >>> is_dtype_equal(object, \"category\")\n    False\n    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n    True\n    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n    False\n    \"\"\"\n\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    \"\"\"\n    DEPRECATED: This function will be removed in a future version.\n\n    Check whether the provided array or dtype is of an integer dtype.\n\n    In this function, timedelta64 instances are also considered \"any-integer\"\n    type objects and will return True.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype.\n\n    Examples\n    --------\n    >>> is_any_int_dtype(str)\n    False\n    >>> is_any_int_dtype(int)\n    True\n    >>> is_any_int_dtype(float)\n    False\n    >>> is_any_int_dtype(np.uint64)\n    True\n    >>> is_any_int_dtype(np.datetime64)\n    False\n    >>> is_any_int_dtype(np.timedelta64)\n    True\n    >>> is_any_int_dtype(np.array(['a', 'b']))\n    False\n    >>> is_any_int_dtype(pd.Series([1, 2]))\n    True\n    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.integer)\n\n\ndef is_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a signed integer dtype.\n\n    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a signed integer dtype\n              and not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> is_signed_integer_dtype(str)\n    False\n    >>> is_signed_integer_dtype(int)\n    True\n    >>> is_signed_integer_dtype(float)\n    False\n    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n    False\n    >>> is_signed_integer_dtype(np.datetime64)\n    False\n    >>> is_signed_integer_dtype(np.timedelta64)\n    False\n    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.signedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an unsigned integer dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an\n              unsigned integer dtype.\n\n    Examples\n    --------\n    >>> is_unsigned_integer_dtype(str)\n    False\n    >>> is_unsigned_integer_dtype(int)  # signed\n    False\n    >>> is_unsigned_integer_dtype(float)\n    False\n    >>> is_unsigned_integer_dtype(np.uint64)\n    True\n    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n    False\n    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n    False\n    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.unsignedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the int64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the int64 dtype.\n\n    Notes\n    -----\n    Depending on system architecture, the return value of `is_int64_dtype(\n    int)` will be True if the OS uses 64-bit integers and False if the OS\n    uses 32-bit integers.\n\n    Examples\n    --------\n    >>> is_int64_dtype(str)\n    False\n    >>> is_int64_dtype(np.int32)\n    False\n    >>> is_int64_dtype(np.int64)\n    True\n    >>> is_int64_dtype(float)\n    False\n    >>> is_int64_dtype(np.uint64)  # unsigned\n    False\n    >>> is_int64_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n    True\n    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n    False\n    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.int64)\n\n\ndef is_int_or_datetime_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of an\n    integer, timedelta64, or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of an\n              integer, timedelta64, or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_int_or_datetime_dtype(str)\n    False\n    >>> is_int_or_datetime_dtype(int)\n    True\n    >>> is_int_or_datetime_dtype(float)\n    False\n    >>> is_int_or_datetime_dtype(np.uint64)\n    True\n    >>> is_int_or_datetime_dtype(np.datetime64)\n    True\n    >>> is_int_or_datetime_dtype(np.timedelta64)\n    True\n    >>> is_int_or_datetime_dtype(np.array(['a', 'b']))\n    False\n    >>> is_int_or_datetime_dtype(pd.Series([1, 2]))\n    True\n    >>> is_int_or_datetime_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_int_or_datetime_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_int_or_datetime_dtype(pd.Index([1, 2.]))  # float\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) or\n            issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_any_dtype(str)\n    False\n    >>> is_datetime64_any_dtype(int)\n    False\n    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n    True\n    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_any_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n    True\n    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n                                dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the datetime64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_datetime64_ns_dtype(str)\n    False\n    >>> is_datetime64_ns_dtype(int)\n    False\n    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n    False\n    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n    True\n    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n    False\n    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n    False\n    >>> is_datetime64_ns_dtype(np.array([],\n                               dtype=\"datetime64[ps]\"))  # wrong unit\n    False\n    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n                               dtype=np.datetime64))  # has 'ns' unit\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the\n              timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n    False\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n        return tipo == _TD_DTYPE\n    except TypeError:\n        return False\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of\n    a timedelta64 or datetime64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a\n              timedelta64, or datetime64 dtype.\n\n    Examples\n    --------\n    >>> is_datetime_or_timedelta_dtype(str)\n    False\n    >>> is_datetime_or_timedelta_dtype(int)\n    False\n    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n    False\n    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n    False\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n    True\n    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, (np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean : Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a string-like\n              object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(1, 1)\n    False\n    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n    False\n    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n    False\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to a numeric object.\n\n    By \"numeric,\" we mean an object that is either of an int or float dtype.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to a numeric object.\n\n    Examples\n    --------\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_numeric(1, 1)\n    False\n    >>> is_datetimelike_v_numeric(dt, dt)\n    False\n    >>> is_datetimelike_v_numeric(1, dt)\n    True\n    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n    True\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n    True\n    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n    False\n    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        \"\"\"\n        Check if an object has a numeric dtype (i.e. integer or float).\n        \"\"\"\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    \"\"\"\n    Check if we are comparing a datetime-like object to an object instance.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean : Whether we return a comparing a datetime-like\n              to an object instance.\n\n    Examples\n    --------\n    >>> obj = object()\n    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n    >>>\n    >>> is_datetimelike_v_object(obj, obj)\n    False\n    >>> is_datetimelike_v_object(dt, dt)\n    False\n    >>> is_datetimelike_v_object(obj, dt)\n    True\n    >>> is_datetimelike_v_object(dt, obj)  # symmetric check\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), obj)\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), dt)\n    True\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([obj]))\n    True\n    >>> is_datetimelike_v_object(np.array([obj]), np.array([obj]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([1]))\n    False\n    >>> is_datetimelike_v_object(np.array([dt]), np.array([dt]))\n    False\n    \"\"\"\n\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object_dtype(b)) or\n            (is_datetimelike(b) and is_object_dtype(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    \"\"\"\n    Check whether the array or dtype should be converted to int64.\n\n    An array-like or dtype \"needs\" such a conversion if the array-like\n    or dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    True\n    >>> needs_i8_conversion(np.array(['a', 'b']))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a numeric dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a numeric dtype.\n\n    Examples\n    --------\n    >>> is_numeric_dtype(str)\n    False\n    >>> is_numeric_dtype(int)\n    True\n    >>> is_numeric_dtype(float)\n    True\n    >>> is_numeric_dtype(np.uint64)\n    True\n    >>> is_numeric_dtype(np.datetime64)\n    False\n    >>> is_numeric_dtype(np.timedelta64)\n    False\n    >>> is_numeric_dtype(np.array(['a', 'b']))\n    False\n    >>> is_numeric_dtype(pd.Series([1, 2]))\n    True\n    >>> is_numeric_dtype(pd.Index([1, 2.]))\n    True\n    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, (np.number, np.bool_)) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(pd.Series([1, 2]))\n    False\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('S', 'U')\n    except TypeError:\n        return False\n\n\ndef is_float_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array(['a', 'b']))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.floating)\n\n\ndef is_floating_dtype(arr_or_dtype):\n    \"\"\"\n    DEPRECATED: This function will be removed in a future version.\n\n    Check whether the provided array or dtype is an instance of\n    numpy's float dtype.\n\n    Unlike, `is_float_dtype`, this check is a lot stricter, as it requires\n    `isinstance` of `np.floating` and not `issubclass`.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return isinstance(tipo, np.floating)\n\n\ndef is_bool_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a boolean dtype.\n\n    Examples\n    --------\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool)\n    True\n    >>> is_bool_dtype(np.array(['a', 'b']))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except ValueError:\n        # this isn't even a dtype\n        return False\n    return issubclass(tipo, np.bool_)\n\n\ndef is_extension_type(arr):\n    \"\"\"\n    Check whether an array-like is of a pandas extension class instance.\n\n    Extension classes include categoricals, pandas sparse objects (i.e.\n    classes represented within the pandas library and not ones external\n    to it like scipy sparse matrices), and datetime-like arrays.\n\n    Parameters\n    ----------\n    arr : array-like\n        The array-like to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array-like is of a pandas\n              extension class instance.\n\n    Examples\n    --------\n    >>> is_extension_type([1, 2, 3])\n    False\n    >>> is_extension_type(np.array([1, 2, 3]))\n    False\n    >>>\n    >>> cat = pd.Categorical([1, 2, 3])\n    >>>\n    >>> is_extension_type(cat)\n    True\n    >>> is_extension_type(pd.Series(cat))\n    True\n    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n    True\n    >>> is_extension_type(pd.SparseSeries([1, 2, 3]))\n    True\n    >>>\n    >>> from scipy.sparse import bsr_matrix\n    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n    False\n    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n    >>>\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_extension_type(s)\n    True\n    \"\"\"\n\n    if is_categorical(arr):\n        return True\n    elif is_sparse(arr):\n        return True\n    elif is_datetimetz(arr):\n        return True\n    return False\n\n\ndef is_complex_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a complex dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of a compex dtype.\n\n    Examples\n    --------\n    >>> is_complex_dtype(str)\n    False\n    >>> is_complex_dtype(int)\n    False\n    >>> is_complex_dtype(np.complex)\n    True\n    >>> is_complex_dtype(np.array(['a', 'b']))\n    False\n    >>> is_complex_dtype(pd.Series([1, 2]))\n    False\n    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n    True\n    \"\"\"\n\n    if arr_or_dtype is None:\n        return False\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.complexfloating)\n\n\ndef _coerce_to_dtype(dtype):\n    \"\"\"\n    Coerce a string or np.dtype to a pandas or numpy\n    dtype if possible.\n\n    If we cannot convert to a pandas dtype initially,\n    we convert to a numpy dtype.\n\n    Parameters\n    ----------\n    dtype : The dtype that we want to coerce.\n\n    Returns\n    -------\n    pd_or_np_dtype : The coerced dtype.\n    \"\"\"\n\n    if is_categorical_dtype(dtype):\n        dtype = CategoricalDtype()\n    elif is_datetime64tz_dtype(dtype):\n        dtype = DatetimeTZDtype(dtype)\n    elif is_period_dtype(dtype):\n        dtype = PeriodDtype(dtype)\n    elif is_interval_dtype(dtype):\n        dtype = IntervalDtype(dtype)\n    else:\n        dtype = np.dtype(dtype)\n    return dtype\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, IntervalDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtype.construct_from_string(arr_or_dtype)\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtype.construct_from_string(arr_or_dtype)\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtype.construct_from_string(arr_or_dtype)\n        elif is_interval_dtype(arr_or_dtype):\n            return IntervalDtype.construct_from_string(arr_or_dtype)\n\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n    return np.dtype(arr_or_dtype)\n\n\ndef _get_dtype_type(arr_or_dtype):\n    \"\"\"\n    Get the type (NOT dtype) instance associated with\n    an array or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like\n        The array-like or dtype object whose type we want to extract.\n\n    Returns\n    -------\n    obj_type : The extract type instance from the\n               passed in array or dtype object.\n    \"\"\"\n\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype.type\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype).type\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return CategoricalDtypeType\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return DatetimeTZDtypeType\n    elif isinstance(arr_or_dtype, IntervalDtype):\n        return IntervalDtypeType\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return PeriodDtypeType\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtypeType\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtypeType\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtypeType\n        elif is_interval_dtype(arr_or_dtype):\n            return IntervalDtypeType\n        return _get_dtype_type(np.dtype(arr_or_dtype))\n    try:\n        return arr_or_dtype.dtype.type\n    except AttributeError:\n        return type(None)\n\n\ndef _get_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif is_categorical(dtype):\n        return CategoricalDtype().type\n    elif is_datetimetz(dtype):\n        return DatetimeTZDtype(dtype).type\n    elif isinstance(dtype, np.dtype):  # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n    elif isinstance(dtype, string_types):\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n\n        try:\n            return _get_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return _get_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('%s' % e)\n    if typ != 'generic' and typ != 'ns':\n        raise ValueError('%r is too specific of a frequency, try passing %r' %\n                         (dtype.name, dtype.type.__name__))\n\n\n_string_dtypes = frozenset(map(_get_dtype_from_object, (binary_type,\n                                                        text_type)))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n    \"\"\"\n\n    if isinstance(dtype, DatetimeTZDtype):\n        return dtype\n    elif isinstance(dtype, PeriodDtype):\n        return dtype\n    elif isinstance(dtype, CategoricalDtype):\n        return dtype\n    elif isinstance(dtype, IntervalDtype):\n        return dtype\n    elif isinstance(dtype, string_types):\n        try:\n            return DatetimeTZDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n\n        if dtype.startswith('period[') or dtype.startswith('Period['):\n            # do not parse string like U as period[U]\n            try:\n                return PeriodDtype.construct_from_string(dtype)\n            except TypeError:\n                pass\n\n        elif dtype.startswith('interval[') or dtype.startswith('Interval['):\n            try:\n                return IntervalDtype.construct_from_string(dtype)\n            except TypeError:\n                pass\n\n        try:\n            return CategoricalDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n    elif isinstance(dtype, ExtensionDtype):\n        return dtype\n\n    try:\n        npdtype = np.dtype(dtype)\n    except (TypeError, ValueError):\n        raise\n\n    # Any invalid dtype (such as pd.Timestamp) should raise an error.\n    # np.dtype(invalid_type).kind = 0 for such objects. However, this will\n    # also catch some valid dtypes such as object, np.object_ and 'object'\n    # which we safeguard against by catching them earlier and returning\n    # np.dtype(valid_dtype) before this condition is evaluated.\n    if dtype in [object, np.object_, 'object', 'O']:\n        return npdtype\n    elif npdtype.kind == 'O':\n        raise TypeError('dtype {0} not understood'.format(dtype))\n\n    return npdtype\n",
          "file_patch": "@@ -37,7 +37,7 @@ def _ensure_float(arr):\n \n     Parameters\n     ----------\n-    arr : ndarray, Series\n+    arr : array-like\n         The array whose data type we want to enforce as float.\n \n     Returns\n@@ -82,46 +82,243 @@ def _ensure_categorical(arr):\n \n \n def is_object_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether an array-like or dtype is of the object dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array-like or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like or dtype is of the object dtype.\n+\n+    Examples\n+    --------\n+    >>> is_object_dtype(object)\n+    True\n+    >>> is_object_dtype(int)\n+    False\n+    >>> is_object_dtype(np.array([], dtype=object))\n+    True\n+    >>> is_object_dtype(np.array([], dtype=int))\n+    False\n+    >>> is_object_dtype([1, 2, 3])\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n     return issubclass(tipo, np.object_)\n \n \n-def is_sparse(array):\n-    \"\"\" return if we are a sparse array \"\"\"\n-    return isinstance(array, (ABCSparseArray, ABCSparseSeries))\n+def is_sparse(arr):\n+    \"\"\"\n+    Check whether an array-like is a pandas sparse array.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is a pandas sparse array.\n+\n+    Examples\n+    --------\n+    >>> is_sparse(np.array([1, 2, 3]))\n+    False\n+    >>> is_sparse(pd.SparseArray([1, 2, 3]))\n+    True\n+    >>> is_sparse(pd.SparseSeries([1, 2, 3]))\n+    True\n+\n+    This function checks only for pandas sparse array instances, so\n+    sparse arrays from other libraries will return False.\n+\n+    >>> from scipy.sparse import bsr_matrix\n+    >>> is_sparse(bsr_matrix([1, 2, 3]))\n+    False\n+    \"\"\"\n+\n+    return isinstance(arr, (ABCSparseArray, ABCSparseSeries))\n+\n+\n+def is_scipy_sparse(arr):\n+    \"\"\"\n+    Check whether an array-like is a scipy.sparse.spmatrix instance.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is a\n+              scipy.sparse.spmatrix instance.\n+\n+    Notes\n+    -----\n+    If scipy is not installed, this function will always return False.\n \n+    Examples\n+    --------\n+    >>> from scipy.sparse import bsr_matrix\n+    >>> is_scipy_sparse(bsr_matrix([1, 2, 3]))\n+    True\n+    >>> is_scipy_sparse(pd.SparseArray([1, 2, 3]))\n+    False\n+    >>> is_scipy_sparse(pd.SparseSeries([1, 2, 3]))\n+    False\n+    \"\"\"\n \n-def is_scipy_sparse(array):\n-    \"\"\" return if we are a scipy.sparse.spmatrix \"\"\"\n     global _is_scipy_sparse\n+\n     if _is_scipy_sparse is None:\n         try:\n             from scipy.sparse import issparse as _is_scipy_sparse\n         except ImportError:\n             _is_scipy_sparse = lambda _: False\n-    return _is_scipy_sparse(array)\n \n+    return _is_scipy_sparse(arr)\n \n-def is_categorical(array):\n-    \"\"\" return if we are a categorical possibility \"\"\"\n-    return isinstance(array, ABCCategorical) or is_categorical_dtype(array)\n \n+def is_categorical(arr):\n+    \"\"\"\n+    Check whether an array-like is a Categorical instance.\n \n-def is_datetimetz(array):\n-    \"\"\" return if we are a datetime with tz array \"\"\"\n-    return ((isinstance(array, ABCDatetimeIndex) and\n-             getattr(array, 'tz', None) is not None) or\n-            is_datetime64tz_dtype(array))\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is of a Categorical instance.\n+\n+    Examples\n+    --------\n+    >>> is_categorical([1, 2, 3])\n+    False\n+\n+    Categoricals and Series Categoricals will return True.\n+\n+    >>> cat = pd.Categorical([1, 2, 3])\n+    >>> is_categorical(cat)\n+    True\n+    >>> is_categorical(pd.Series(cat))\n+    True\n+    \"\"\"\n+\n+    return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)\n+\n+\n+def is_datetimetz(arr):\n+    \"\"\"\n+    Check whether an array-like is a datetime array-like with a timezone\n+    component in its dtype.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n \n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is a datetime array-like with\n+              a timezone component in its dtype.\n+\n+    Examples\n+    --------\n+    >>> is_datetimetz([1, 2, 3])\n+    False\n+\n+    Although the following examples are both DatetimeIndex objects,\n+    the first one returns False because it has no timezone component\n+    unlike the second one, which returns True.\n+\n+    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3]))\n+    False\n+    >>> is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n+    True\n+\n+    The object need not be a DatetimeIndex object. It just needs to have\n+    a dtype which has a timezone component.\n+\n+    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n+    >>> s = pd.Series([], dtype=dtype)\n+    >>> is_datetimetz(s)\n+    True\n+    \"\"\"\n+\n+    # TODO: do we need this function?\n+    # It seems like a repeat of is_datetime64tz_dtype.\n+\n+    return ((isinstance(arr, ABCDatetimeIndex) and\n+             getattr(arr, 'tz', None) is not None) or\n+            is_datetime64tz_dtype(arr))\n+\n+\n+def is_period(arr):\n+    \"\"\"\n+    Check whether an array-like is a periodical index.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is a periodical index.\n+\n+    Examples\n+    --------\n+    >>> is_period([1, 2, 3])\n+    False\n+    >>> is_period(pd.Index([1, 2, 3]))\n+    False\n+    >>> is_period(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n+    True\n+    \"\"\"\n \n-def is_period(array):\n-    \"\"\" return if we are a period array \"\"\"\n-    return isinstance(array, ABCPeriodIndex) or is_period_arraylike(array)\n+    # TODO: do we need this function?\n+    # It seems like a repeat of is_period_arraylike.\n+    return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)\n \n \n def is_datetime64_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether an array-like or dtype is of the datetime64 dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array-like or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like or dtype is of\n+              the datetime64 dtype.\n+\n+    Examples\n+    --------\n+    >>> is_datetime64_dtype(object)\n+    False\n+    >>> is_datetime64_dtype(np.datetime64)\n+    True\n+    >>> is_datetime64_dtype(np.array([], dtype=int))\n+    False\n+    >>> is_datetime64_dtype(np.array([], dtype=np.datetime64))\n+    True\n+    >>> is_datetime64_dtype([1, 2, 3])\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     try:\n@@ -132,12 +329,69 @@ def is_datetime64_dtype(arr_or_dtype):\n \n \n def is_datetime64tz_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array-like or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like or dtype is of\n+              a DatetimeTZDtype dtype.\n+\n+    Examples\n+    --------\n+    >>> is_datetime64tz_dtype(object)\n+    False\n+    >>> is_datetime64tz_dtype([1, 2, 3])\n+    False\n+    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n+    False\n+    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n+    True\n+\n+    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n+    >>> s = pd.Series([], dtype=dtype)\n+    >>> is_datetime64tz_dtype(dtype)\n+    True\n+    >>> is_datetime64tz_dtype(s)\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     return DatetimeTZDtype.is_dtype(arr_or_dtype)\n \n \n def is_timedelta64_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether an array-like or dtype is of the timedelta64 dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array-like or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like or dtype is\n+              of the timedelta64 dtype.\n+\n+    Examples\n+    --------\n+    >>> is_timedelta64_dtype(object)\n+    False\n+    >>> is_timedelta64_dtype(np.timedelta64)\n+    True\n+    >>> is_timedelta64_dtype([1, 2, 3])\n+    False\n+    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -145,18 +399,102 @@ def is_timedelta64_dtype(arr_or_dtype):\n \n \n def is_period_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether an array-like or dtype is of the Period dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array-like or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like or dtype is of the Period dtype.\n+\n+    Examples\n+    --------\n+    >>> is_period_dtype(object)\n+    False\n+    >>> is_period_dtype(PeriodDtype(freq=\"D\"))\n+    True\n+    >>> is_period_dtype([1, 2, 3])\n+    False\n+    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n+    False\n+    >>> is_period_dtype(pd.PeriodIndex([], freq=\"A\"))\n+    True\n+    \"\"\"\n+\n+    # TODO: Consider making Period an instance of PeriodDtype\n     if arr_or_dtype is None:\n         return False\n     return PeriodDtype.is_dtype(arr_or_dtype)\n \n \n def is_interval_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether an array-like or dtype is of the Interval dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array-like or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like or dtype is\n+              of the Interval dtype.\n+\n+    Examples\n+    --------\n+    >>> is_interval_dtype(object)\n+    False\n+    >>> is_interval_dtype(IntervalDtype())\n+    True\n+    >>> is_interval_dtype([1, 2, 3])\n+    False\n+    >>>\n+    >>> interval = pd.Interval(1, 2, closed=\"right\")\n+    >>> is_interval_dtype(interval)\n+    False\n+    >>> is_interval_dtype(pd.IntervalIndex([interval]))\n+    True\n+    \"\"\"\n+\n+    # TODO: Consider making Interval an instance of IntervalDtype\n     if arr_or_dtype is None:\n         return False\n     return IntervalDtype.is_dtype(arr_or_dtype)\n \n \n def is_categorical_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether an array-like or dtype is of the Categorical dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array-like or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like or dtype is\n+              of the Categorical dtype.\n+\n+    Examples\n+    --------\n+    >>> is_categorical_dtype(object)\n+    False\n+    >>> is_categorical_dtype(CategoricalDtype())\n+    True\n+    >>> is_categorical_dtype([1, 2, 3])\n+    False\n+    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n+    True\n+    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     return CategoricalDtype.is_dtype(arr_or_dtype)\n@@ -168,7 +506,7 @@ def is_string_dtype(arr_or_dtype):\n \n     Parameters\n     ----------\n-    arr_or_dtype : ndarray, dtype, type\n+    arr_or_dtype : array-like\n         The array or dtype to check.\n \n     Returns\n@@ -186,7 +524,7 @@ def is_string_dtype(arr_or_dtype):\n     >>>\n     >>> is_string_dtype(np.array(['a', 'b']))\n     True\n-    >>> is_string_dtype(np.array([1, 2]))\n+    >>> is_string_dtype(pd.Series([1, 2]))\n     False\n     \"\"\"\n \n@@ -202,7 +540,29 @@ def is_string_dtype(arr_or_dtype):\n \n \n def is_period_arraylike(arr):\n-    \"\"\" return if we are period arraylike / PeriodIndex \"\"\"\n+    \"\"\"\n+    Check whether an array-like is a periodical array-like or PeriodIndex.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is a periodical\n+              array-like or PeriodIndex instance.\n+\n+    Examples\n+    --------\n+    >>> is_period_arraylike([1, 2, 3])\n+    False\n+    >>> is_period_arraylike(pd.Index([1, 2, 3]))\n+    False\n+    >>> is_period_arraylike(pd.PeriodIndex([\"2017-01-01\"], freq=\"D\"))\n+    True\n+    \"\"\"\n+\n     if isinstance(arr, ABCPeriodIndex):\n         return True\n     elif isinstance(arr, (np.ndarray, ABCSeries)):\n@@ -211,7 +571,29 @@ def is_period_arraylike(arr):\n \n \n def is_datetime_arraylike(arr):\n-    \"\"\" return if we are datetime arraylike / DatetimeIndex \"\"\"\n+    \"\"\"\n+    Check whether an array-like is a datetime array-like or DatetimeIndex.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is a datetime\n+              array-like or DatetimeIndex.\n+\n+    Examples\n+    --------\n+    >>> is_datetime_arraylike([1, 2, 3])\n+    False\n+    >>> is_datetime_arraylike(pd.Index([1, 2, 3]))\n+    False\n+    >>> is_datetime_arraylike(pd.DatetimeIndex([1, 2, 3]))\n+    True\n+    \"\"\"\n+\n     if isinstance(arr, ABCDatetimeIndex):\n         return True\n     elif isinstance(arr, (np.ndarray, ABCSeries)):\n@@ -220,6 +602,44 @@ def is_datetime_arraylike(arr):\n \n \n def is_datetimelike(arr):\n+    \"\"\"\n+    Check whether an array-like is a datetime-like array-like.\n+\n+    Acceptable datetime-like objects are (but not limited to) datetime\n+    indices, periodic indices, and timedelta indices.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is a datetime-like array-like.\n+\n+    Examples\n+    --------\n+    >>> is_datetimelike([1, 2, 3])\n+    False\n+    >>> is_datetimelike(pd.Index([1, 2, 3]))\n+    False\n+    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3]))\n+    True\n+    >>> is_datetimelike(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n+    True\n+    >>> is_datetimelike(pd.PeriodIndex([], freq=\"A\"))\n+    True\n+    >>> is_datetimelike(np.array([], dtype=np.datetime64))\n+    True\n+    >>> is_datetimelike(pd.Series([], dtype=\"timedelta64[ns]\"))\n+    True\n+    >>>\n+    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n+    >>> s = pd.Series([], dtype=dtype)\n+    >>> is_datetimelike(s)\n+    True\n+    \"\"\"\n+\n     return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n             is_timedelta64_dtype(arr) or\n             isinstance(arr, ABCPeriodIndex) or\n@@ -227,7 +647,32 @@ def is_datetimelike(arr):\n \n \n def is_dtype_equal(source, target):\n-    \"\"\" return a boolean if the dtypes are equal \"\"\"\n+    \"\"\"\n+    Check if two dtypes are equal.\n+\n+    Parameters\n+    ----------\n+    source : The first dtype to compare\n+    target : The second dtype to compare\n+\n+    Returns\n+    ----------\n+    boolean : Whether or not the two dtypes are equal.\n+\n+    Examples\n+    --------\n+    >>> is_dtype_equal(int, float)\n+    False\n+    >>> is_dtype_equal(\"int\", int)\n+    True\n+    >>> is_dtype_equal(object, \"category\")\n+    False\n+    >>> is_dtype_equal(CategoricalDtype(), \"category\")\n+    True\n+    >>> is_dtype_equal(DatetimeTZDtype(), \"datetime64\")\n+    False\n+    \"\"\"\n+\n     try:\n         source = _get_dtype(source)\n         target = _get_dtype(target)\n@@ -240,6 +685,47 @@ def is_dtype_equal(source, target):\n \n \n def is_any_int_dtype(arr_or_dtype):\n+    \"\"\"\n+    DEPRECATED: This function will be removed in a future version.\n+\n+    Check whether the provided array or dtype is of an integer dtype.\n+\n+    In this function, timedelta64 instances are also considered \"any-integer\"\n+    type objects and will return True.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of an integer dtype.\n+\n+    Examples\n+    --------\n+    >>> is_any_int_dtype(str)\n+    False\n+    >>> is_any_int_dtype(int)\n+    True\n+    >>> is_any_int_dtype(float)\n+    False\n+    >>> is_any_int_dtype(np.uint64)\n+    True\n+    >>> is_any_int_dtype(np.datetime64)\n+    False\n+    >>> is_any_int_dtype(np.timedelta64)\n+    True\n+    >>> is_any_int_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_any_int_dtype(pd.Series([1, 2]))\n+    True\n+    >>> is_any_int_dtype(np.array([], dtype=np.timedelta64))\n+    True\n+    >>> is_any_int_dtype(pd.Index([1, 2.]))  # float\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -247,6 +733,45 @@ def is_any_int_dtype(arr_or_dtype):\n \n \n def is_integer_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of an integer dtype.\n+\n+    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of an integer dtype\n+              and not an instance of timedelta64.\n+\n+    Examples\n+    --------\n+    >>> is_integer_dtype(str)\n+    False\n+    >>> is_integer_dtype(int)\n+    True\n+    >>> is_integer_dtype(float)\n+    False\n+    >>> is_integer_dtype(np.uint64)\n+    True\n+    >>> is_integer_dtype(np.datetime64)\n+    False\n+    >>> is_integer_dtype(np.timedelta64)\n+    False\n+    >>> is_integer_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_integer_dtype(pd.Series([1, 2]))\n+    True\n+    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n+    False\n+    >>> is_integer_dtype(pd.Index([1, 2.]))  # float\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -255,6 +780,47 @@ def is_integer_dtype(arr_or_dtype):\n \n \n def is_signed_integer_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of a signed integer dtype.\n+\n+    Unlike in `in_any_int_dtype`, timedelta64 instances will return False.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of a signed integer dtype\n+              and not an instance of timedelta64.\n+\n+    Examples\n+    --------\n+    >>> is_signed_integer_dtype(str)\n+    False\n+    >>> is_signed_integer_dtype(int)\n+    True\n+    >>> is_signed_integer_dtype(float)\n+    False\n+    >>> is_signed_integer_dtype(np.uint64)  # unsigned\n+    False\n+    >>> is_signed_integer_dtype(np.datetime64)\n+    False\n+    >>> is_signed_integer_dtype(np.timedelta64)\n+    False\n+    >>> is_signed_integer_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_signed_integer_dtype(pd.Series([1, 2]))\n+    True\n+    >>> is_signed_integer_dtype(np.array([], dtype=np.timedelta64))\n+    False\n+    >>> is_signed_integer_dtype(pd.Index([1, 2.]))  # float\n+    False\n+    >>> is_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -263,6 +829,39 @@ def is_signed_integer_dtype(arr_or_dtype):\n \n \n def is_unsigned_integer_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of an unsigned integer dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of an\n+              unsigned integer dtype.\n+\n+    Examples\n+    --------\n+    >>> is_unsigned_integer_dtype(str)\n+    False\n+    >>> is_unsigned_integer_dtype(int)  # signed\n+    False\n+    >>> is_unsigned_integer_dtype(float)\n+    False\n+    >>> is_unsigned_integer_dtype(np.uint64)\n+    True\n+    >>> is_unsigned_integer_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_unsigned_integer_dtype(pd.Series([1, 2]))  # signed\n+    False\n+    >>> is_unsigned_integer_dtype(pd.Index([1, 2.]))  # float\n+    False\n+    >>> is_unsigned_integer_dtype(np.array([1, 2], dtype=np.uint32))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -271,6 +870,46 @@ def is_unsigned_integer_dtype(arr_or_dtype):\n \n \n def is_int64_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of the int64 dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of the int64 dtype.\n+\n+    Notes\n+    -----\n+    Depending on system architecture, the return value of `is_int64_dtype(\n+    int)` will be True if the OS uses 64-bit integers and False if the OS\n+    uses 32-bit integers.\n+\n+    Examples\n+    --------\n+    >>> is_int64_dtype(str)\n+    False\n+    >>> is_int64_dtype(np.int32)\n+    False\n+    >>> is_int64_dtype(np.int64)\n+    True\n+    >>> is_int64_dtype(float)\n+    False\n+    >>> is_int64_dtype(np.uint64)  # unsigned\n+    False\n+    >>> is_int64_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_int64_dtype(np.array([1, 2], dtype=np.int64))\n+    True\n+    >>> is_int64_dtype(pd.Index([1, 2.]))  # float\n+    False\n+    >>> is_int64_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -278,6 +917,46 @@ def is_int64_dtype(arr_or_dtype):\n \n \n def is_int_or_datetime_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of an\n+    integer, timedelta64, or datetime64 dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of an\n+              integer, timedelta64, or datetime64 dtype.\n+\n+    Examples\n+    --------\n+    >>> is_int_or_datetime_dtype(str)\n+    False\n+    >>> is_int_or_datetime_dtype(int)\n+    True\n+    >>> is_int_or_datetime_dtype(float)\n+    False\n+    >>> is_int_or_datetime_dtype(np.uint64)\n+    True\n+    >>> is_int_or_datetime_dtype(np.datetime64)\n+    True\n+    >>> is_int_or_datetime_dtype(np.timedelta64)\n+    True\n+    >>> is_int_or_datetime_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_int_or_datetime_dtype(pd.Series([1, 2]))\n+    True\n+    >>> is_int_or_datetime_dtype(np.array([], dtype=np.timedelta64))\n+    True\n+    >>> is_int_or_datetime_dtype(np.array([], dtype=np.datetime64))\n+    True\n+    >>> is_int_or_datetime_dtype(pd.Index([1, 2.]))  # float\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -285,7 +964,40 @@ def is_int_or_datetime_dtype(arr_or_dtype):\n             issubclass(tipo, (np.datetime64, np.timedelta64)))\n \n \n-def is_datetime64_any_dtype(arr_or_dtype):\n+def is_datetime64_any_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of the datetime64 dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of the datetime64 dtype.\n+\n+    Examples\n+    --------\n+    >>> is_datetime64_any_dtype(str)\n+    False\n+    >>> is_datetime64_any_dtype(int)\n+    False\n+    >>> is_datetime64_any_dtype(np.datetime64)  # can be tz-naive\n+    True\n+    >>> is_datetime64_any_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n+    True\n+    >>> is_datetime64_any_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_datetime64_any_dtype(np.array([1, 2]))\n+    False\n+    >>> is_datetime64_any_dtype(np.array([], dtype=np.datetime64))\n+    True\n+    >>> is_datetime64_any_dtype(pd.DatetimeIndex([1, 2, 3],\n+                                dtype=np.datetime64))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     return (is_datetime64_dtype(arr_or_dtype) or\n@@ -293,6 +1005,42 @@ def is_datetime64_any_dtype(arr_or_dtype):\n \n \n def is_datetime64_ns_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of the datetime64[ns] dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of the datetime64[ns] dtype.\n+\n+    Examples\n+    --------\n+    >>> is_datetime64_ns_dtype(str)\n+    False\n+    >>> is_datetime64_ns_dtype(int)\n+    False\n+    >>> is_datetime64_ns_dtype(np.datetime64)  # no unit\n+    False\n+    >>> is_datetime64_ns_dtype(DatetimeTZDtype(\"ns\", \"US/Eastern\"))\n+    True\n+    >>> is_datetime64_ns_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_datetime64_ns_dtype(np.array([1, 2]))\n+    False\n+    >>> is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))  # no unit\n+    False\n+    >>> is_datetime64_ns_dtype(np.array([],\n+                               dtype=\"datetime64[ps]\"))  # wrong unit\n+    False\n+    >>> is_datetime64_ns_dtype(pd.DatetimeIndex([1, 2, 3],\n+                               dtype=np.datetime64))  # has 'ns' unit\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     try:\n@@ -314,21 +1062,20 @@ def is_timedelta64_ns_dtype(arr_or_dtype):\n \n     Parameters\n     ----------\n-    arr_or_dtype : ndarray, dtype, type\n+    arr_or_dtype : array-like\n         The array or dtype to check.\n \n     Returns\n     -------\n-    boolean : Whether or not the array or dtype\n-              is of the timedelta64[ns] dtype.\n+    boolean : Whether or not the array or dtype is of the\n+              timedelta64[ns] dtype.\n \n     Examples\n     --------\n-    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]')\n+    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]'))\n     True\n-    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]')  # Wrong frequency\n+    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]'))  # Wrong frequency\n     False\n-    >>>\n     >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n     True\n     >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n@@ -345,6 +1092,40 @@ def is_timedelta64_ns_dtype(arr_or_dtype):\n \n \n def is_datetime_or_timedelta_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of\n+    a timedelta64 or datetime64 dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of a\n+              timedelta64, or datetime64 dtype.\n+\n+    Examples\n+    --------\n+    >>> is_datetime_or_timedelta_dtype(str)\n+    False\n+    >>> is_datetime_or_timedelta_dtype(int)\n+    False\n+    >>> is_datetime_or_timedelta_dtype(np.datetime64)\n+    True\n+    >>> is_datetime_or_timedelta_dtype(np.timedelta64)\n+    True\n+    >>> is_datetime_or_timedelta_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_datetime_or_timedelta_dtype(pd.Series([1, 2]))\n+    False\n+    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.timedelta64))\n+    True\n+    >>> is_datetime_or_timedelta_dtype(np.array([], dtype=np.datetime64))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -378,11 +1159,45 @@ def _is_unorderable_exception(e):\n \n def is_numeric_v_string_like(a, b):\n     \"\"\"\n-    numpy doesn't like to compare numeric arrays vs scalar string-likes\n+    Check if we are comparing a string-like object to a numeric ndarray.\n+\n+    NumPy doesn't like to compare such objects, especially numeric arrays\n+    and scalar string-likes.\n+\n+    Parameters\n+    ----------\n+    a : array-like, scalar\n+        The first object to check.\n+    b : array-like, scalar\n+        The second object to check.\n \n-    return a boolean result if this is the case for a,b or b,a\n+    Returns\n+    -------\n+    boolean : Whether we return a comparing a string-like\n+              object to a numeric array.\n \n+    Examples\n+    --------\n+    >>> is_numeric_v_string_like(1, 1)\n+    False\n+    >>> is_numeric_v_string_like(\"foo\", \"foo\")\n+    False\n+    >>> is_numeric_v_string_like(1, \"foo\")  # non-array numeric\n+    False\n+    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n+    True\n+    >>> is_numeric_v_string_like(\"foo\", np.array([1]))  # symmetric check\n+    True\n+    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n+    True\n+    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n+    True\n+    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n+    False\n+    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n+    False\n     \"\"\"\n+\n     is_a_array = isinstance(a, np.ndarray)\n     is_b_array = isinstance(b, np.ndarray)\n \n@@ -401,13 +1216,56 @@ def is_numeric_v_string_like(a, b):\n \n \n def is_datetimelike_v_numeric(a, b):\n-    # return if we have an i8 convertible and numeric comparison\n+    \"\"\"\n+    Check if we are comparing a datetime-like object to a numeric object.\n+\n+    By \"numeric,\" we mean an object that is either of an int or float dtype.\n+\n+    Parameters\n+    ----------\n+    a : array-like, scalar\n+        The first object to check.\n+    b : array-like, scalar\n+        The second object to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether we return a comparing a datetime-like\n+              to a numeric object.\n+\n+    Examples\n+    --------\n+    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n+    >>>\n+    >>> is_datetimelike_v_numeric(1, 1)\n+    False\n+    >>> is_datetimelike_v_numeric(dt, dt)\n+    False\n+    >>> is_datetimelike_v_numeric(1, dt)\n+    True\n+    >>> is_datetimelike_v_numeric(dt, 1)  # symmetric check\n+    True\n+    >>> is_datetimelike_v_numeric(np.array([dt]), 1)\n+    True\n+    >>> is_datetimelike_v_numeric(np.array([1]), dt)\n+    True\n+    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([1]))\n+    True\n+    >>> is_datetimelike_v_numeric(np.array([1]), np.array([2]))\n+    False\n+    >>> is_datetimelike_v_numeric(np.array([dt]), np.array([dt]))\n+    False\n+    \"\"\"\n+\n     if not hasattr(a, 'dtype'):\n         a = np.asarray(a)\n     if not hasattr(b, 'dtype'):\n         b = np.asarray(b)\n \n     def is_numeric(x):\n+        \"\"\"\n+        Check if an object has a numeric dtype (i.e. integer or float).\n+        \"\"\"\n         return is_integer_dtype(x) or is_float_dtype(x)\n \n     is_datetimelike = needs_i8_conversion\n@@ -416,24 +1274,92 @@ def is_datetimelike_v_numeric(a, b):\n \n \n def is_datetimelike_v_object(a, b):\n-    # return if we have an i8 convertible and object comparsion\n+    \"\"\"\n+    Check if we are comparing a datetime-like object to an object instance.\n+\n+    Parameters\n+    ----------\n+    a : array-like, scalar\n+        The first object to check.\n+    b : array-like, scalar\n+        The second object to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether we return a comparing a datetime-like\n+              to an object instance.\n+\n+    Examples\n+    --------\n+    >>> obj = object()\n+    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))\n+    >>>\n+    >>> is_datetimelike_v_object(obj, obj)\n+    False\n+    >>> is_datetimelike_v_object(dt, dt)\n+    False\n+    >>> is_datetimelike_v_object(obj, dt)\n+    True\n+    >>> is_datetimelike_v_object(dt, obj)  # symmetric check\n+    True\n+    >>> is_datetimelike_v_object(np.array([dt]), obj)\n+    True\n+    >>> is_datetimelike_v_object(np.array([obj]), dt)\n+    True\n+    >>> is_datetimelike_v_object(np.array([dt]), np.array([obj]))\n+    True\n+    >>> is_datetimelike_v_object(np.array([obj]), np.array([obj]))\n+    False\n+    >>> is_datetimelike_v_object(np.array([dt]), np.array([1]))\n+    False\n+    >>> is_datetimelike_v_object(np.array([dt]), np.array([dt]))\n+    False\n+    \"\"\"\n+\n     if not hasattr(a, 'dtype'):\n         a = np.asarray(a)\n     if not hasattr(b, 'dtype'):\n         b = np.asarray(b)\n \n-    def f(x):\n-        return is_object_dtype(x)\n-\n-    def is_object(x):\n-        return is_integer_dtype(x) or is_float_dtype(x)\n-\n     is_datetimelike = needs_i8_conversion\n-    return ((is_datetimelike(a) and is_object(b)) or\n-            (is_datetimelike(b) and is_object(a)))\n+    return ((is_datetimelike(a) and is_object_dtype(b)) or\n+            (is_datetimelike(b) and is_object_dtype(a)))\n \n \n def needs_i8_conversion(arr_or_dtype):\n+    \"\"\"\n+    Check whether the array or dtype should be converted to int64.\n+\n+    An array-like or dtype \"needs\" such a conversion if the array-like\n+    or dtype is of a datetime-like dtype\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype should be converted to int64.\n+\n+    Examples\n+    --------\n+    >>> needs_i8_conversion(str)\n+    False\n+    >>> needs_i8_conversion(np.int64)\n+    False\n+    >>> needs_i8_conversion(np.datetime64)\n+    True\n+    >>> needs_i8_conversion(np.array(['a', 'b']))\n+    False\n+    >>> needs_i8_conversion(pd.Series([1, 2]))\n+    False\n+    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n+    True\n+    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n@@ -442,6 +1368,42 @@ def needs_i8_conversion(arr_or_dtype):\n \n \n def is_numeric_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of a numeric dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of a numeric dtype.\n+\n+    Examples\n+    --------\n+    >>> is_numeric_dtype(str)\n+    False\n+    >>> is_numeric_dtype(int)\n+    True\n+    >>> is_numeric_dtype(float)\n+    True\n+    >>> is_numeric_dtype(np.uint64)\n+    True\n+    >>> is_numeric_dtype(np.datetime64)\n+    False\n+    >>> is_numeric_dtype(np.timedelta64)\n+    False\n+    >>> is_numeric_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_numeric_dtype(pd.Series([1, 2]))\n+    True\n+    >>> is_numeric_dtype(pd.Index([1, 2.]))\n+    True\n+    >>> is_numeric_dtype(np.array([], dtype=np.timedelta64))\n+    False\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -458,7 +1420,7 @@ def is_string_like_dtype(arr_or_dtype):\n \n     Parameters\n     ----------\n-    arr_or_dtype : ndarray, dtype, type\n+    arr_or_dtype : array-like\n         The array or dtype to check.\n \n     Returns\n@@ -471,10 +1433,9 @@ def is_string_like_dtype(arr_or_dtype):\n     True\n     >>> is_string_like_dtype(object)\n     False\n-    >>>\n     >>> is_string_like_dtype(np.array(['a', 'b']))\n     True\n-    >>> is_string_like_dtype(np.array([1, 2]))\n+    >>> is_string_like_dtype(pd.Series([1, 2]))\n     False\n     \"\"\"\n \n@@ -488,6 +1449,34 @@ def is_string_like_dtype(arr_or_dtype):\n \n \n def is_float_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of a float dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of a float dtype.\n+\n+    Examples\n+    --------\n+    >>> is_float_dtype(str)\n+    False\n+    >>> is_float_dtype(int)\n+    False\n+    >>> is_float_dtype(float)\n+    True\n+    >>> is_float_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_float_dtype(pd.Series([1, 2]))\n+    False\n+    >>> is_float_dtype(pd.Index([1, 2.]))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -495,6 +1484,16 @@ def is_float_dtype(arr_or_dtype):\n \n \n def is_floating_dtype(arr_or_dtype):\n+    \"\"\"\n+    DEPRECATED: This function will be removed in a future version.\n+\n+    Check whether the provided array or dtype is an instance of\n+    numpy's float dtype.\n+\n+    Unlike, `is_float_dtype`, this check is a lot stricter, as it requires\n+    `isinstance` of `np.floating` and not `issubclass`.\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -502,6 +1501,36 @@ def is_floating_dtype(arr_or_dtype):\n \n \n def is_bool_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of a boolean dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of a boolean dtype.\n+\n+    Examples\n+    --------\n+    >>> is_bool_dtype(str)\n+    False\n+    >>> is_bool_dtype(int)\n+    False\n+    >>> is_bool_dtype(bool)\n+    True\n+    >>> is_bool_dtype(np.bool)\n+    True\n+    >>> is_bool_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_bool_dtype(pd.Series([1, 2]))\n+    False\n+    >>> is_bool_dtype(np.array([True, False]))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     try:\n@@ -512,21 +1541,94 @@ def is_bool_dtype(arr_or_dtype):\n     return issubclass(tipo, np.bool_)\n \n \n-def is_extension_type(value):\n+def is_extension_type(arr):\n     \"\"\"\n-    if we are a klass that is preserved by the internals\n-    these are internal klasses that we represent (and don't use a np.array)\n+    Check whether an array-like is of a pandas extension class instance.\n+\n+    Extension classes include categoricals, pandas sparse objects (i.e.\n+    classes represented within the pandas library and not ones external\n+    to it like scipy sparse matrices), and datetime-like arrays.\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array-like to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array-like is of a pandas\n+              extension class instance.\n+\n+    Examples\n+    --------\n+    >>> is_extension_type([1, 2, 3])\n+    False\n+    >>> is_extension_type(np.array([1, 2, 3]))\n+    False\n+    >>>\n+    >>> cat = pd.Categorical([1, 2, 3])\n+    >>>\n+    >>> is_extension_type(cat)\n+    True\n+    >>> is_extension_type(pd.Series(cat))\n+    True\n+    >>> is_extension_type(pd.SparseArray([1, 2, 3]))\n+    True\n+    >>> is_extension_type(pd.SparseSeries([1, 2, 3]))\n+    True\n+    >>>\n+    >>> from scipy.sparse import bsr_matrix\n+    >>> is_extension_type(bsr_matrix([1, 2, 3]))\n+    False\n+    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3]))\n+    False\n+    >>> is_extension_type(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n+    True\n+    >>>\n+    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n+    >>> s = pd.Series([], dtype=dtype)\n+    >>> is_extension_type(s)\n+    True\n     \"\"\"\n-    if is_categorical(value):\n+\n+    if is_categorical(arr):\n         return True\n-    elif is_sparse(value):\n+    elif is_sparse(arr):\n         return True\n-    elif is_datetimetz(value):\n+    elif is_datetimetz(arr):\n         return True\n     return False\n \n \n def is_complex_dtype(arr_or_dtype):\n+    \"\"\"\n+    Check whether the provided array or dtype is of a complex dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : array-like\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of a compex dtype.\n+\n+    Examples\n+    --------\n+    >>> is_complex_dtype(str)\n+    False\n+    >>> is_complex_dtype(int)\n+    False\n+    >>> is_complex_dtype(np.complex)\n+    True\n+    >>> is_complex_dtype(np.array(['a', 'b']))\n+    False\n+    >>> is_complex_dtype(pd.Series([1, 2]))\n+    False\n+    >>> is_complex_dtype(np.array([1 + 1j, 5]))\n+    True\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n         return False\n     tipo = _get_dtype_type(arr_or_dtype)\n@@ -570,7 +1672,7 @@ def _get_dtype(arr_or_dtype):\n \n     Parameters\n     ----------\n-    arr_or_dtype : ndarray, Series, dtype, type\n+    arr_or_dtype : array-like\n         The array-like or dtype object whose dtype we want to extract.\n \n     Returns\n@@ -619,7 +1721,7 @@ def _get_dtype_type(arr_or_dtype):\n \n     Parameters\n     ----------\n-    arr_or_dtype : ndarray, Series, dtype, type\n+    arr_or_dtype : array-like\n         The array-like or dtype object whose type we want to extract.\n \n     Returns\n@@ -754,6 +1856,7 @@ def pandas_dtype(dtype):\n     -------\n     np.dtype or a pandas dtype\n     \"\"\"\n+\n     if isinstance(dtype, DatetimeTZDtype):\n         return dtype\n     elif isinstance(dtype, PeriodDtype):\n",
          "files_name_in_blame_commit": [
            "common.py",
            "test_common.py"
          ]
        }
      },
      "bc2fa160b9d281889b344e7bc15352998e7b0955": {
        "commit": {
          "commit_id": "bc2fa160b9d281889b344e7bc15352998e7b0955",
          "commit_message": "BUG/DOC: Add documentation in types/common.py (#15941)\n\n* DOC: document internal methods in types/common.py\r\n\r\nPartially addresses gh-15895.\r\n\r\n* BUG: Catch TypeError when calling _get_dtype\r\n\r\nThe following functions were not catching\r\nthe TypeError raised by _get_dtype:\r\n\r\n1) is_string_dtype\r\n2) is_string_like_dtype\r\n3) is_timedelta64_ns_dtype\r\n\r\nThus, when \"None\" was passed in, an\r\nException was raised instead of returning\r\nFalse, as other functions did.\r\n\r\n* TST: use ids to have nice parameterized function names",
          "commit_author": "gfyoung",
          "commit_date": "2017-04-07 18:42:29",
          "commit_parent": "6d90a436674a1e285d4577553b5cb75906a1bd27"
        },
        "function": {
          "function_name": "is_string_dtype",
          "function_code_before": "def is_string_dtype(arr_or_dtype):\n    dtype = _get_dtype(arr_or_dtype)\n    return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))",
          "function_code_after": "def is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(np.array([1, 2]))\n    False\n    \"\"\"\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and (not is_period_dtype(dtype))\n    except TypeError:\n        return False",
          "function_before_start_line": 118,
          "function_before_end_line": 120,
          "function_after_start_line": 146,
          "function_after_end_line": 180,
          "function_before_token_count": 29,
          "function_after_token_count": 37,
          "functions_name_modified_file": [
            "is_numeric_v_string_like",
            "is_datetime64_ns_dtype",
            "is_period",
            "is_any_int_dtype",
            "is_numeric_dtype",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_int_or_datetime_dtype",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "_get_dtype_type",
            "is_datetimelike_v_object",
            "is_sparse",
            "is_datetimetz",
            "_ensure_float",
            "_validate_date_like_dtype",
            "is_datetimelike",
            "is_scipy_sparse",
            "_is_unorderable_exception",
            "is_integer_dtype",
            "_ensure_categorical",
            "is_datetime64tz_dtype",
            "is_floating_dtype",
            "is_extension_type",
            "_coerce_to_dtype",
            "_get_dtype_from_object",
            "is_object_dtype",
            "is_string_dtype",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_all_files": [
            "test_numpy_string_dtype",
            "test_dtype_equal_strict",
            "is_numeric_v_string_like",
            "test_get_dtype_error_catch",
            "is_datetime64_ns_dtype",
            "test_categorical_dtype",
            "is_period",
            "get_is_dtype_funcs",
            "is_any_int_dtype",
            "is_numeric_dtype",
            "is_period_arraylike",
            "_get_dtype",
            "is_int64_dtype",
            "is_period_dtype",
            "is_string_like_dtype",
            "is_timedelta64_dtype",
            "is_categorical_dtype",
            "is_timedelta64_ns_dtype",
            "pandas_dtype",
            "is_signed_integer_dtype",
            "test_period_dtype",
            "is_datetime64_dtype",
            "is_dtype_equal",
            "is_complex_dtype",
            "is_unsigned_integer_dtype",
            "is_datetime_arraylike",
            "needs_i8_conversion",
            "is_datetime_or_timedelta_dtype",
            "is_int_or_datetime_dtype",
            "is_categorical",
            "is_datetime64_any_dtype",
            "is_float_dtype",
            "is_bool_dtype",
            "_get_dtype_type",
            "is_datetimelike_v_object",
            "is_sparse",
            "is_datetimetz",
            "_ensure_float",
            "_validate_date_like_dtype",
            "test_numpy_dtype",
            "test_datetimetz_dtype",
            "is_datetimelike",
            "is_scipy_sparse",
            "test_dtype_equal",
            "is_integer_dtype",
            "_is_unorderable_exception",
            "_ensure_categorical",
            "is_datetime64tz_dtype",
            "is_floating_dtype",
            "is_extension_type",
            "_coerce_to_dtype",
            "_get_dtype_from_object",
            "is_object_dtype",
            "is_string_dtype",
            "is_datetimelike_v_numeric"
          ],
          "functions_name_co_evolved_modified_file": [
            "_is_unorderable_exception",
            "is_string_like_dtype",
            "is_timedelta64_ns_dtype",
            "_ensure_categorical",
            "_coerce_to_dtype",
            "_get_dtype_type",
            "_get_dtype",
            "_ensure_float",
            "_validate_date_like_dtype",
            "_get_dtype_from_object"
          ],
          "functions_name_co_evolved_all_files": [
            "_is_unorderable_exception",
            "test_dtype_equal_strict",
            "is_string_like_dtype",
            "test_get_dtype_error_catch",
            "is_timedelta64_ns_dtype",
            "_ensure_categorical",
            "get_is_dtype_funcs",
            "_coerce_to_dtype",
            "_get_dtype_type",
            "_get_dtype",
            "_ensure_float",
            "_validate_date_like_dtype",
            "_get_dtype_from_object"
          ]
        },
        "file": {
          "file_name": "common.py",
          "file_nloc": 341,
          "file_complexity": 164,
          "file_token_count": 2224,
          "file_before": "\"\"\" common type operations \"\"\"\n\nimport numpy as np\nfrom pandas.compat import (string_types, text_type, binary_type,\n                           PY3, PY36)\nfrom pandas._libs import algos, lib\nfrom .dtypes import (CategoricalDtype, CategoricalDtypeType,\n                     DatetimeTZDtype, DatetimeTZDtypeType,\n                     PeriodDtype, PeriodDtypeType,\n                     ExtensionDtype)\nfrom .generic import (ABCCategorical, ABCPeriodIndex,\n                      ABCDatetimeIndex, ABCSeries,\n                      ABCSparseArray, ABCSparseSeries)\nfrom .inference import is_string_like\nfrom .inference import *  # noqa\n\n\n_POSSIBLY_CAST_DTYPES = set([np.dtype(t).name\n                             for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                       'int32', 'uint32', 'int64', 'uint64']])\n\n_NS_DTYPE = np.dtype('M8[ns]')\n_TD_DTYPE = np.dtype('m8[ns]')\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\n_ensure_float64 = algos.ensure_float64\n_ensure_float32 = algos.ensure_float32\n\n\ndef _ensure_float(arr):\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\n_ensure_uint64 = algos.ensure_uint64\n_ensure_int64 = algos.ensure_int64\n_ensure_int32 = algos.ensure_int32\n_ensure_int16 = algos.ensure_int16\n_ensure_int8 = algos.ensure_int8\n_ensure_platform_int = algos.ensure_platform_int\n_ensure_object = algos.ensure_object\n\n\ndef _ensure_categorical(arr):\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef is_object_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.object_)\n\n\ndef is_sparse(array):\n    \"\"\" return if we are a sparse array \"\"\"\n    return isinstance(array, (ABCSparseArray, ABCSparseSeries))\n\n\ndef is_scipy_sparse(array):\n    \"\"\" return if we are a scipy.sparse.spmatrix \"\"\"\n    global _is_scipy_sparse\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n    return _is_scipy_sparse(array)\n\n\ndef is_categorical(array):\n    \"\"\" return if we are a categorical possibility \"\"\"\n    return isinstance(array, ABCCategorical) or is_categorical_dtype(array)\n\n\ndef is_datetimetz(array):\n    \"\"\" return if we are a datetime with tz array \"\"\"\n    return ((isinstance(array, ABCDatetimeIndex) and\n             getattr(array, 'tz', None) is not None) or\n            is_datetime64tz_dtype(array))\n\n\ndef is_period(array):\n    \"\"\" return if we are a period array \"\"\"\n    return isinstance(array, ABCPeriodIndex) or is_period_arraylike(array)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except TypeError:\n        return False\n    return issubclass(tipo, np.datetime64)\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.timedelta64)\n\n\ndef is_period_dtype(arr_or_dtype):\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    dtype = _get_dtype(arr_or_dtype)\n    return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n\n\ndef is_period_arraylike(arr):\n    \"\"\" return if we are period arraylike / PeriodIndex \"\"\"\n    if isinstance(arr, ABCPeriodIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'period'\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\" return if we are datetime arraylike / DatetimeIndex \"\"\"\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'datetime'\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex) or\n            is_datetimetz(arr))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\" return a boolean if the dtypes are equal \"\"\"\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.integer)\n\n\ndef is_integer_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.signedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.unsignedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.int64)\n\n\ndef is_int_or_datetime_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) or\n            issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    tipo = _get_dtype(arr_or_dtype)\n    return tipo == _TD_DTYPE\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, (np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    return a boolean if we an unorderable exception error message\n\n    These are different error message for PY>=3<=3.5 and PY>=3.6\n    \"\"\"\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    numpy doesn't like to compare numeric arrays vs scalar string-likes\n\n    return a boolean result if this is the case for a,b or b,a\n\n    \"\"\"\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    # return if we have an i8 convertible and numeric comparison\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    # return if we have an i8 convertible and object comparsion\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def f(x):\n        return is_object_dtype(x)\n\n    def is_object(x):\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object(b)) or\n            (is_datetimelike(b) and is_object(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, (np.number, np.bool_)) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    # exclude object as its a mixed dtype\n    dtype = _get_dtype(arr_or_dtype)\n    return dtype.kind in ('S', 'U')\n\n\ndef is_float_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.floating)\n\n\ndef is_floating_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return isinstance(tipo, np.floating)\n\n\ndef is_bool_dtype(arr_or_dtype):\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except ValueError:\n        # this isn't even a dtype\n        return False\n    return issubclass(tipo, np.bool_)\n\n\ndef is_extension_type(value):\n    \"\"\"\n    if we are a klass that is preserved by the internals\n    these are internal klasses that we represent (and don't use a np.array)\n    \"\"\"\n    if is_categorical(value):\n        return True\n    elif is_sparse(value):\n        return True\n    elif is_datetimetz(value):\n        return True\n    return False\n\n\ndef is_complex_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.complexfloating)\n\n\ndef _coerce_to_dtype(dtype):\n    \"\"\" coerce a string / np.dtype to a dtype \"\"\"\n    if is_categorical_dtype(dtype):\n        dtype = CategoricalDtype()\n    elif is_datetime64tz_dtype(dtype):\n        dtype = DatetimeTZDtype(dtype)\n    elif is_period_dtype(dtype):\n        dtype = PeriodDtype(dtype)\n    else:\n        dtype = np.dtype(dtype)\n    return dtype\n\n\ndef _get_dtype(arr_or_dtype):\n    if arr_or_dtype is None:\n        raise TypeError\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtype.construct_from_string(arr_or_dtype)\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtype.construct_from_string(arr_or_dtype)\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtype.construct_from_string(arr_or_dtype)\n\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n    return np.dtype(arr_or_dtype)\n\n\ndef _get_dtype_type(arr_or_dtype):\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype.type\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype).type\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return CategoricalDtypeType\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return DatetimeTZDtypeType\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return PeriodDtypeType\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtypeType\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtypeType\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtypeType\n        return _get_dtype_type(np.dtype(arr_or_dtype))\n    try:\n        return arr_or_dtype.dtype.type\n    except AttributeError:\n        return type(None)\n\n\ndef _get_dtype_from_object(dtype):\n    \"\"\"Get a numpy dtype.type-style object. This handles the datetime64[ns]\n    and datetime64[ns, TZ] compat\n\n    Notes\n    -----\n    If nothing can be found, returns ``object``.\n    \"\"\"\n\n    # type object from a dtype\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        return dtype\n    elif is_categorical(dtype):\n        return CategoricalDtype().type\n    elif is_datetimetz(dtype):\n        return DatetimeTZDtype(dtype).type\n    elif isinstance(dtype, np.dtype):  # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # should still pass if we don't have a datelike\n            pass\n        return dtype.type\n    elif isinstance(dtype, string_types):\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n\n        try:\n            return _get_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # handles cases like _get_dtype(int)\n            # i.e., python objects that are valid dtypes (unlike user-defined\n            # types, in general)\n            # TypeError handles the float16 typecode of 'e'\n            # further handle internal types\n            pass\n\n    return _get_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('%s' % e)\n    if typ != 'generic' and typ != 'ns':\n        raise ValueError('%r is too specific of a frequency, try passing %r' %\n                         (dtype.name, dtype.type.__name__))\n\n\n_string_dtypes = frozenset(map(_get_dtype_from_object, (binary_type,\n                                                        text_type)))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n    \"\"\"\n    if isinstance(dtype, DatetimeTZDtype):\n        return dtype\n    elif isinstance(dtype, PeriodDtype):\n        return dtype\n    elif isinstance(dtype, CategoricalDtype):\n        return dtype\n    elif isinstance(dtype, string_types):\n        try:\n            return DatetimeTZDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n\n        if dtype.startswith('period[') or dtype.startswith('Period['):\n            # do not parse string like U as period[U]\n            try:\n                return PeriodDtype.construct_from_string(dtype)\n            except TypeError:\n                pass\n\n        try:\n            return CategoricalDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n    elif isinstance(dtype, ExtensionDtype):\n        return dtype\n\n    return np.dtype(dtype)\n",
          "file_after": "\"\"\" common type operations \"\"\"\n\nimport numpy as np\nfrom pandas.compat import (string_types, text_type, binary_type,\n                           PY3, PY36)\nfrom pandas._libs import algos, lib\nfrom .dtypes import (CategoricalDtype, CategoricalDtypeType,\n                     DatetimeTZDtype, DatetimeTZDtypeType,\n                     PeriodDtype, PeriodDtypeType,\n                     ExtensionDtype)\nfrom .generic import (ABCCategorical, ABCPeriodIndex,\n                      ABCDatetimeIndex, ABCSeries,\n                      ABCSparseArray, ABCSparseSeries)\nfrom .inference import is_string_like\nfrom .inference import *  # noqa\n\n\n_POSSIBLY_CAST_DTYPES = set([np.dtype(t).name\n                             for t in ['O', 'int8', 'uint8', 'int16', 'uint16',\n                                       'int32', 'uint32', 'int64', 'uint64']])\n\n_NS_DTYPE = np.dtype('M8[ns]')\n_TD_DTYPE = np.dtype('m8[ns]')\n_INT64_DTYPE = np.dtype(np.int64)\n\n# oh the troubles to reduce import time\n_is_scipy_sparse = None\n\n_ensure_float64 = algos.ensure_float64\n_ensure_float32 = algos.ensure_float32\n\n\ndef _ensure_float(arr):\n    \"\"\"\n    Ensure that an array object has a float dtype if possible.\n\n    Parameters\n    ----------\n    arr : ndarray, Series\n        The array whose data type we want to enforce as float.\n\n    Returns\n    -------\n    float_arr : The original array cast to the float dtype if\n                possible. Otherwise, the original array is returned.\n    \"\"\"\n\n    if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n        arr = arr.astype(float)\n    return arr\n\n\n_ensure_uint64 = algos.ensure_uint64\n_ensure_int64 = algos.ensure_int64\n_ensure_int32 = algos.ensure_int32\n_ensure_int16 = algos.ensure_int16\n_ensure_int8 = algos.ensure_int8\n_ensure_platform_int = algos.ensure_platform_int\n_ensure_object = algos.ensure_object\n\n\ndef _ensure_categorical(arr):\n    \"\"\"\n    Ensure that an array-like object is a Categorical (if not already).\n\n    Parameters\n    ----------\n    arr : array-like\n        The array that we want to convert into a Categorical.\n\n    Returns\n    -------\n    cat_arr : The original array cast as a Categorical. If it already\n              is a Categorical, we return as is.\n    \"\"\"\n\n    if not is_categorical(arr):\n        from pandas import Categorical\n        arr = Categorical(arr)\n    return arr\n\n\ndef is_object_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.object_)\n\n\ndef is_sparse(array):\n    \"\"\" return if we are a sparse array \"\"\"\n    return isinstance(array, (ABCSparseArray, ABCSparseSeries))\n\n\ndef is_scipy_sparse(array):\n    \"\"\" return if we are a scipy.sparse.spmatrix \"\"\"\n    global _is_scipy_sparse\n    if _is_scipy_sparse is None:\n        try:\n            from scipy.sparse import issparse as _is_scipy_sparse\n        except ImportError:\n            _is_scipy_sparse = lambda _: False\n    return _is_scipy_sparse(array)\n\n\ndef is_categorical(array):\n    \"\"\" return if we are a categorical possibility \"\"\"\n    return isinstance(array, ABCCategorical) or is_categorical_dtype(array)\n\n\ndef is_datetimetz(array):\n    \"\"\" return if we are a datetime with tz array \"\"\"\n    return ((isinstance(array, ABCDatetimeIndex) and\n             getattr(array, 'tz', None) is not None) or\n            is_datetime64tz_dtype(array))\n\n\ndef is_period(array):\n    \"\"\" return if we are a period array \"\"\"\n    return isinstance(array, ABCPeriodIndex) or is_period_arraylike(array)\n\n\ndef is_datetime64_dtype(arr_or_dtype):\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except TypeError:\n        return False\n    return issubclass(tipo, np.datetime64)\n\n\ndef is_datetime64tz_dtype(arr_or_dtype):\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)\n\n\ndef is_timedelta64_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.timedelta64)\n\n\ndef is_period_dtype(arr_or_dtype):\n    return PeriodDtype.is_dtype(arr_or_dtype)\n\n\ndef is_categorical_dtype(arr_or_dtype):\n    return CategoricalDtype.is_dtype(arr_or_dtype)\n\n\ndef is_string_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>>\n    >>> is_string_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_dtype(np.array([1, 2]))\n    False\n    \"\"\"\n\n    # TODO: gh-15585: consider making the checks stricter.\n\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n    except TypeError:\n        return False\n\n\ndef is_period_arraylike(arr):\n    \"\"\" return if we are period arraylike / PeriodIndex \"\"\"\n    if isinstance(arr, ABCPeriodIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'period'\n    return getattr(arr, 'inferred_type', None) == 'period'\n\n\ndef is_datetime_arraylike(arr):\n    \"\"\" return if we are datetime arraylike / DatetimeIndex \"\"\"\n    if isinstance(arr, ABCDatetimeIndex):\n        return True\n    elif isinstance(arr, (np.ndarray, ABCSeries)):\n        return arr.dtype == object and lib.infer_dtype(arr) == 'datetime'\n    return getattr(arr, 'inferred_type', None) == 'datetime'\n\n\ndef is_datetimelike(arr):\n    return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or\n            is_timedelta64_dtype(arr) or\n            isinstance(arr, ABCPeriodIndex) or\n            is_datetimetz(arr))\n\n\ndef is_dtype_equal(source, target):\n    \"\"\" return a boolean if the dtypes are equal \"\"\"\n    try:\n        source = _get_dtype(source)\n        target = _get_dtype(target)\n        return source == target\n    except (TypeError, AttributeError):\n\n        # invalid comparison\n        # object == category will hit this\n        return False\n\n\ndef is_any_int_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.integer)\n\n\ndef is_integer_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_signed_integer_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.signedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_unsigned_integer_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.unsignedinteger) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_int64_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.int64)\n\n\ndef is_int_or_datetime_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, np.integer) or\n            issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_datetime64_any_dtype(arr_or_dtype):\n    return (is_datetime64_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype))\n\n\ndef is_datetime64_ns_dtype(arr_or_dtype):\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n    except TypeError:\n        if is_datetime64tz_dtype(arr_or_dtype):\n            tipo = _get_dtype(arr_or_dtype.dtype)\n        else:\n            return False\n    return tipo == _NS_DTYPE or getattr(tipo, 'base', None) == _NS_DTYPE\n\n\ndef is_timedelta64_ns_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\n    This is a very specific dtype, so generic ones like `np.timedelta64`\n    will return False if passed into this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype\n              is of the timedelta64[ns] dtype.\n\n    Examples\n    --------\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]')\n    True\n    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]')  # Wrong frequency\n    False\n    >>>\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n    True\n    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n    False\n    \"\"\"\n\n    try:\n        tipo = _get_dtype(arr_or_dtype)\n        return tipo == _TD_DTYPE\n    except TypeError:\n        return False\n\n\ndef is_datetime_or_timedelta_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, (np.datetime64, np.timedelta64))\n\n\ndef _is_unorderable_exception(e):\n    \"\"\"\n    Check if the exception raised is an unorderable exception.\n\n    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n    we need to condition based on Python version.\n\n    Parameters\n    ----------\n    e : Exception or sub-class\n        The exception object to check.\n\n    Returns\n    -------\n    boolean : Whether or not the exception raised is an unorderable exception.\n    \"\"\"\n\n    if PY36:\n        return \"'>' not supported between instances of\" in str(e)\n\n    elif PY3:\n        return 'unorderable' in str(e)\n    return False\n\n\ndef is_numeric_v_string_like(a, b):\n    \"\"\"\n    numpy doesn't like to compare numeric arrays vs scalar string-likes\n\n    return a boolean result if this is the case for a,b or b,a\n\n    \"\"\"\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n\n    is_a_numeric_array = is_a_array and is_numeric_dtype(a)\n    is_b_numeric_array = is_b_array and is_numeric_dtype(b)\n    is_a_string_array = is_a_array and is_string_like_dtype(a)\n    is_b_string_array = is_b_array and is_string_like_dtype(b)\n\n    is_a_scalar_string_like = not is_a_array and is_string_like(a)\n    is_b_scalar_string_like = not is_b_array and is_string_like(b)\n\n    return ((is_a_numeric_array and is_b_scalar_string_like) or\n            (is_b_numeric_array and is_a_scalar_string_like) or\n            (is_a_numeric_array and is_b_string_array) or\n            (is_b_numeric_array and is_a_string_array))\n\n\ndef is_datetimelike_v_numeric(a, b):\n    # return if we have an i8 convertible and numeric comparison\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def is_numeric(x):\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_numeric(b)) or\n            (is_datetimelike(b) and is_numeric(a)))\n\n\ndef is_datetimelike_v_object(a, b):\n    # return if we have an i8 convertible and object comparsion\n    if not hasattr(a, 'dtype'):\n        a = np.asarray(a)\n    if not hasattr(b, 'dtype'):\n        b = np.asarray(b)\n\n    def f(x):\n        return is_object_dtype(x)\n\n    def is_object(x):\n        return is_integer_dtype(x) or is_float_dtype(x)\n\n    is_datetimelike = needs_i8_conversion\n    return ((is_datetimelike(a) and is_object(b)) or\n            (is_datetimelike(b) and is_object(a)))\n\n\ndef needs_i8_conversion(arr_or_dtype):\n    return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\n            is_datetime64tz_dtype(arr_or_dtype) or\n            is_period_dtype(arr_or_dtype))\n\n\ndef is_numeric_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return (issubclass(tipo, (np.number, np.bool_)) and\n            not issubclass(tipo, (np.datetime64, np.timedelta64)))\n\n\ndef is_string_like_dtype(arr_or_dtype):\n    \"\"\"\n    Check whether the provided array or dtype is of a string-like dtype.\n\n    Unlike `is_string_dtype`, the object dtype is excluded because it\n    is a mixed dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, dtype, type\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean : Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> is_string_like_dtype(str)\n    True\n    >>> is_string_like_dtype(object)\n    False\n    >>>\n    >>> is_string_like_dtype(np.array(['a', 'b']))\n    True\n    >>> is_string_like_dtype(np.array([1, 2]))\n    False\n    \"\"\"\n\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n        return dtype.kind in ('S', 'U')\n    except TypeError:\n        return False\n\n\ndef is_float_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.floating)\n\n\ndef is_floating_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return isinstance(tipo, np.floating)\n\n\ndef is_bool_dtype(arr_or_dtype):\n    try:\n        tipo = _get_dtype_type(arr_or_dtype)\n    except ValueError:\n        # this isn't even a dtype\n        return False\n    return issubclass(tipo, np.bool_)\n\n\ndef is_extension_type(value):\n    \"\"\"\n    if we are a klass that is preserved by the internals\n    these are internal klasses that we represent (and don't use a np.array)\n    \"\"\"\n    if is_categorical(value):\n        return True\n    elif is_sparse(value):\n        return True\n    elif is_datetimetz(value):\n        return True\n    return False\n\n\ndef is_complex_dtype(arr_or_dtype):\n    tipo = _get_dtype_type(arr_or_dtype)\n    return issubclass(tipo, np.complexfloating)\n\n\ndef _coerce_to_dtype(dtype):\n    \"\"\"\n    Coerce a string or np.dtype to a pandas or numpy\n    dtype if possible.\n\n    If we cannot convert to a pandas dtype initially,\n    we convert to a numpy dtype.\n\n    Parameters\n    ----------\n    dtype : The dtype that we want to coerce.\n\n    Returns\n    -------\n    pd_or_np_dtype : The coerced dtype.\n    \"\"\"\n\n    if is_categorical_dtype(dtype):\n        dtype = CategoricalDtype()\n    elif is_datetime64tz_dtype(dtype):\n        dtype = DatetimeTZDtype(dtype)\n    elif is_period_dtype(dtype):\n        dtype = PeriodDtype(dtype)\n    else:\n        dtype = np.dtype(dtype)\n    return dtype\n\n\ndef _get_dtype(arr_or_dtype):\n    \"\"\"\n    Get the dtype instance associated with an array\n    or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, Series, dtype, type\n        The array-like or dtype object whose dtype we want to extract.\n\n    Returns\n    -------\n    obj_dtype : The extract dtype instance from the\n                passed in array or dtype object.\n\n    Raises\n    ------\n    TypeError : The passed in object is None.\n    \"\"\"\n\n    if arr_or_dtype is None:\n        raise TypeError(\"Cannot deduce dtype from null object\")\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype)\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return arr_or_dtype\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtype.construct_from_string(arr_or_dtype)\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtype.construct_from_string(arr_or_dtype)\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtype.construct_from_string(arr_or_dtype)\n\n    if hasattr(arr_or_dtype, 'dtype'):\n        arr_or_dtype = arr_or_dtype.dtype\n    return np.dtype(arr_or_dtype)\n\n\ndef _get_dtype_type(arr_or_dtype):\n    \"\"\"\n    Get the type (NOT dtype) instance associated with\n    an array or dtype object.\n\n    Parameters\n    ----------\n    arr_or_dtype : ndarray, Series, dtype, type\n        The array-like or dtype object whose type we want to extract.\n\n    Returns\n    -------\n    obj_type : The extract type instance from the\n               passed in array or dtype object.\n    \"\"\"\n\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype.type\n    elif isinstance(arr_or_dtype, type):\n        return np.dtype(arr_or_dtype).type\n    elif isinstance(arr_or_dtype, CategoricalDtype):\n        return CategoricalDtypeType\n    elif isinstance(arr_or_dtype, DatetimeTZDtype):\n        return DatetimeTZDtypeType\n    elif isinstance(arr_or_dtype, PeriodDtype):\n        return PeriodDtypeType\n    elif isinstance(arr_or_dtype, string_types):\n        if is_categorical_dtype(arr_or_dtype):\n            return CategoricalDtypeType\n        elif is_datetime64tz_dtype(arr_or_dtype):\n            return DatetimeTZDtypeType\n        elif is_period_dtype(arr_or_dtype):\n            return PeriodDtypeType\n        return _get_dtype_type(np.dtype(arr_or_dtype))\n    try:\n        return arr_or_dtype.dtype.type\n    except AttributeError:\n        return type(None)\n\n\ndef _get_dtype_from_object(dtype):\n    \"\"\"\n    Get a numpy dtype.type-style object for a dtype object.\n\n    This methods also includes handling of the datetime64[ns] and\n    datetime64[ns, TZ] objects.\n\n    If no dtype can be found, we return ``object``.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype object whose numpy dtype.type-style\n        object we want to extract.\n\n    Returns\n    -------\n    dtype_object : The extracted numpy dtype.type-style object.\n    \"\"\"\n\n    if isinstance(dtype, type) and issubclass(dtype, np.generic):\n        # Type object from a dtype\n        return dtype\n    elif is_categorical(dtype):\n        return CategoricalDtype().type\n    elif is_datetimetz(dtype):\n        return DatetimeTZDtype(dtype).type\n    elif isinstance(dtype, np.dtype):  # dtype object\n        try:\n            _validate_date_like_dtype(dtype)\n        except TypeError:\n            # Should still pass if we don't have a date-like\n            pass\n        return dtype.type\n    elif isinstance(dtype, string_types):\n        if dtype in ['datetimetz', 'datetime64tz']:\n            return DatetimeTZDtype.type\n        elif dtype in ['period']:\n            raise NotImplementedError\n\n        if dtype == 'datetime' or dtype == 'timedelta':\n            dtype += '64'\n\n        try:\n            return _get_dtype_from_object(getattr(np, dtype))\n        except (AttributeError, TypeError):\n            # Handles cases like _get_dtype(int) i.e.,\n            # Python objects that are valid dtypes\n            # (unlike user-defined types, in general)\n            #\n            # TypeError handles the float16 type code of 'e'\n            # further handle internal types\n            pass\n\n    return _get_dtype_from_object(np.dtype(dtype))\n\n\ndef _validate_date_like_dtype(dtype):\n    \"\"\"\n    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\n    Parameters\n    ----------\n    dtype : dtype, type\n        The dtype to check.\n\n    Raises\n    ------\n    TypeError : The dtype could not be casted to a date-like dtype.\n    ValueError : The dtype is an illegal date-like dtype (e.g. the\n                 the frequency provided is too specific)\n    \"\"\"\n\n    try:\n        typ = np.datetime_data(dtype)[0]\n    except ValueError as e:\n        raise TypeError('%s' % e)\n    if typ != 'generic' and typ != 'ns':\n        raise ValueError('%r is too specific of a frequency, try passing %r' %\n                         (dtype.name, dtype.type.__name__))\n\n\n_string_dtypes = frozenset(map(_get_dtype_from_object, (binary_type,\n                                                        text_type)))\n\n\ndef pandas_dtype(dtype):\n    \"\"\"\n    Converts input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n    \"\"\"\n    if isinstance(dtype, DatetimeTZDtype):\n        return dtype\n    elif isinstance(dtype, PeriodDtype):\n        return dtype\n    elif isinstance(dtype, CategoricalDtype):\n        return dtype\n    elif isinstance(dtype, string_types):\n        try:\n            return DatetimeTZDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n\n        if dtype.startswith('period[') or dtype.startswith('Period['):\n            # do not parse string like U as period[U]\n            try:\n                return PeriodDtype.construct_from_string(dtype)\n            except TypeError:\n                pass\n\n        try:\n            return CategoricalDtype.construct_from_string(dtype)\n        except TypeError:\n            pass\n    elif isinstance(dtype, ExtensionDtype):\n        return dtype\n\n    return np.dtype(dtype)\n",
          "file_patch": "@@ -31,6 +31,20 @@ _ensure_float32 = algos.ensure_float32\n \n \n def _ensure_float(arr):\n+    \"\"\"\n+    Ensure that an array object has a float dtype if possible.\n+\n+    Parameters\n+    ----------\n+    arr : ndarray, Series\n+        The array whose data type we want to enforce as float.\n+\n+    Returns\n+    -------\n+    float_arr : The original array cast to the float dtype if\n+                possible. Otherwise, the original array is returned.\n+    \"\"\"\n+\n     if issubclass(arr.dtype.type, (np.integer, np.bool_)):\n         arr = arr.astype(float)\n     return arr\n@@ -46,6 +60,20 @@ _ensure_object = algos.ensure_object\n \n \n def _ensure_categorical(arr):\n+    \"\"\"\n+    Ensure that an array-like object is a Categorical (if not already).\n+\n+    Parameters\n+    ----------\n+    arr : array-like\n+        The array that we want to convert into a Categorical.\n+\n+    Returns\n+    -------\n+    cat_arr : The original array cast as a Categorical. If it already\n+              is a Categorical, we return as is.\n+    \"\"\"\n+\n     if not is_categorical(arr):\n         from pandas import Categorical\n         arr = Categorical(arr)\n@@ -116,8 +144,40 @@ def is_categorical_dtype(arr_or_dtype):\n \n \n def is_string_dtype(arr_or_dtype):\n-    dtype = _get_dtype(arr_or_dtype)\n-    return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n+    \"\"\"\n+    Check whether the provided array or dtype is of the string dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : ndarray, dtype, type\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of the string dtype.\n+\n+    Examples\n+    --------\n+    >>> is_string_dtype(str)\n+    True\n+    >>> is_string_dtype(object)\n+    True\n+    >>> is_string_dtype(int)\n+    False\n+    >>>\n+    >>> is_string_dtype(np.array(['a', 'b']))\n+    True\n+    >>> is_string_dtype(np.array([1, 2]))\n+    False\n+    \"\"\"\n+\n+    # TODO: gh-15585: consider making the checks stricter.\n+\n+    try:\n+        dtype = _get_dtype(arr_or_dtype)\n+        return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\n+    except TypeError:\n+        return False\n \n \n def is_period_arraylike(arr):\n@@ -209,8 +269,40 @@ def is_datetime64_ns_dtype(arr_or_dtype):\n \n \n def is_timedelta64_ns_dtype(arr_or_dtype):\n-    tipo = _get_dtype(arr_or_dtype)\n-    return tipo == _TD_DTYPE\n+    \"\"\"\n+    Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n+\n+    This is a very specific dtype, so generic ones like `np.timedelta64`\n+    will return False if passed into this function.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : ndarray, dtype, type\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype\n+              is of the timedelta64[ns] dtype.\n+\n+    Examples\n+    --------\n+    >>> is_timedelta64_ns_dtype(np.dtype('m8[ns]')\n+    True\n+    >>> is_timedelta64_ns_dtype(np.dtype('m8[ps]')  # Wrong frequency\n+    False\n+    >>>\n+    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype='m8[ns]'))\n+    True\n+    >>> is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))\n+    False\n+    \"\"\"\n+\n+    try:\n+        tipo = _get_dtype(arr_or_dtype)\n+        return tipo == _TD_DTYPE\n+    except TypeError:\n+        return False\n \n \n def is_datetime_or_timedelta_dtype(arr_or_dtype):\n@@ -220,10 +312,21 @@ def is_datetime_or_timedelta_dtype(arr_or_dtype):\n \n def _is_unorderable_exception(e):\n     \"\"\"\n-    return a boolean if we an unorderable exception error message\n+    Check if the exception raised is an unorderable exception.\n \n-    These are different error message for PY>=3<=3.5 and PY>=3.6\n+    The error message differs for 3 <= PY <= 3.5 and PY >= 3.6, so\n+    we need to condition based on Python version.\n+\n+    Parameters\n+    ----------\n+    e : Exception or sub-class\n+        The exception object to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the exception raised is an unorderable exception.\n     \"\"\"\n+\n     if PY36:\n         return \"'>' not supported between instances of\" in str(e)\n \n@@ -302,9 +405,39 @@ def is_numeric_dtype(arr_or_dtype):\n \n \n def is_string_like_dtype(arr_or_dtype):\n-    # exclude object as its a mixed dtype\n-    dtype = _get_dtype(arr_or_dtype)\n-    return dtype.kind in ('S', 'U')\n+    \"\"\"\n+    Check whether the provided array or dtype is of a string-like dtype.\n+\n+    Unlike `is_string_dtype`, the object dtype is excluded because it\n+    is a mixed dtype.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : ndarray, dtype, type\n+        The array or dtype to check.\n+\n+    Returns\n+    -------\n+    boolean : Whether or not the array or dtype is of the string dtype.\n+\n+    Examples\n+    --------\n+    >>> is_string_like_dtype(str)\n+    True\n+    >>> is_string_like_dtype(object)\n+    False\n+    >>>\n+    >>> is_string_like_dtype(np.array(['a', 'b']))\n+    True\n+    >>> is_string_like_dtype(np.array([1, 2]))\n+    False\n+    \"\"\"\n+\n+    try:\n+        dtype = _get_dtype(arr_or_dtype)\n+        return dtype.kind in ('S', 'U')\n+    except TypeError:\n+        return False\n \n \n def is_float_dtype(arr_or_dtype):\n@@ -346,7 +479,22 @@ def is_complex_dtype(arr_or_dtype):\n \n \n def _coerce_to_dtype(dtype):\n-    \"\"\" coerce a string / np.dtype to a dtype \"\"\"\n+    \"\"\"\n+    Coerce a string or np.dtype to a pandas or numpy\n+    dtype if possible.\n+\n+    If we cannot convert to a pandas dtype initially,\n+    we convert to a numpy dtype.\n+\n+    Parameters\n+    ----------\n+    dtype : The dtype that we want to coerce.\n+\n+    Returns\n+    -------\n+    pd_or_np_dtype : The coerced dtype.\n+    \"\"\"\n+\n     if is_categorical_dtype(dtype):\n         dtype = CategoricalDtype()\n     elif is_datetime64tz_dtype(dtype):\n@@ -359,8 +507,27 @@ def _coerce_to_dtype(dtype):\n \n \n def _get_dtype(arr_or_dtype):\n+    \"\"\"\n+    Get the dtype instance associated with an array\n+    or dtype object.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : ndarray, Series, dtype, type\n+        The array-like or dtype object whose dtype we want to extract.\n+\n+    Returns\n+    -------\n+    obj_dtype : The extract dtype instance from the\n+                passed in array or dtype object.\n+\n+    Raises\n+    ------\n+    TypeError : The passed in object is None.\n+    \"\"\"\n+\n     if arr_or_dtype is None:\n-        raise TypeError\n+        raise TypeError(\"Cannot deduce dtype from null object\")\n     if isinstance(arr_or_dtype, np.dtype):\n         return arr_or_dtype\n     elif isinstance(arr_or_dtype, type):\n@@ -385,6 +552,21 @@ def _get_dtype(arr_or_dtype):\n \n \n def _get_dtype_type(arr_or_dtype):\n+    \"\"\"\n+    Get the type (NOT dtype) instance associated with\n+    an array or dtype object.\n+\n+    Parameters\n+    ----------\n+    arr_or_dtype : ndarray, Series, dtype, type\n+        The array-like or dtype object whose type we want to extract.\n+\n+    Returns\n+    -------\n+    obj_type : The extract type instance from the\n+               passed in array or dtype object.\n+    \"\"\"\n+\n     if isinstance(arr_or_dtype, np.dtype):\n         return arr_or_dtype.type\n     elif isinstance(arr_or_dtype, type):\n@@ -410,16 +592,27 @@ def _get_dtype_type(arr_or_dtype):\n \n \n def _get_dtype_from_object(dtype):\n-    \"\"\"Get a numpy dtype.type-style object. This handles the datetime64[ns]\n-    and datetime64[ns, TZ] compat\n+    \"\"\"\n+    Get a numpy dtype.type-style object for a dtype object.\n \n-    Notes\n-    -----\n-    If nothing can be found, returns ``object``.\n+    This methods also includes handling of the datetime64[ns] and\n+    datetime64[ns, TZ] objects.\n+\n+    If no dtype can be found, we return ``object``.\n+\n+    Parameters\n+    ----------\n+    dtype : dtype, type\n+        The dtype object whose numpy dtype.type-style\n+        object we want to extract.\n+\n+    Returns\n+    -------\n+    dtype_object : The extracted numpy dtype.type-style object.\n     \"\"\"\n \n-    # type object from a dtype\n     if isinstance(dtype, type) and issubclass(dtype, np.generic):\n+        # Type object from a dtype\n         return dtype\n     elif is_categorical(dtype):\n         return CategoricalDtype().type\n@@ -429,7 +622,7 @@ def _get_dtype_from_object(dtype):\n         try:\n             _validate_date_like_dtype(dtype)\n         except TypeError:\n-            # should still pass if we don't have a datelike\n+            # Should still pass if we don't have a date-like\n             pass\n         return dtype.type\n     elif isinstance(dtype, string_types):\n@@ -444,10 +637,11 @@ def _get_dtype_from_object(dtype):\n         try:\n             return _get_dtype_from_object(getattr(np, dtype))\n         except (AttributeError, TypeError):\n-            # handles cases like _get_dtype(int)\n-            # i.e., python objects that are valid dtypes (unlike user-defined\n-            # types, in general)\n-            # TypeError handles the float16 typecode of 'e'\n+            # Handles cases like _get_dtype(int) i.e.,\n+            # Python objects that are valid dtypes\n+            # (unlike user-defined types, in general)\n+            #\n+            # TypeError handles the float16 type code of 'e'\n             # further handle internal types\n             pass\n \n@@ -455,6 +649,21 @@ def _get_dtype_from_object(dtype):\n \n \n def _validate_date_like_dtype(dtype):\n+    \"\"\"\n+    Check whether the dtype is a date-like dtype. Raises an error if invalid.\n+\n+    Parameters\n+    ----------\n+    dtype : dtype, type\n+        The dtype to check.\n+\n+    Raises\n+    ------\n+    TypeError : The dtype could not be casted to a date-like dtype.\n+    ValueError : The dtype is an illegal date-like dtype (e.g. the\n+                 the frequency provided is too specific)\n+    \"\"\"\n+\n     try:\n         typ = np.datetime_data(dtype)[0]\n     except ValueError as e:\n",
          "files_name_in_blame_commit": [
            "common.py",
            "test_common.py"
          ]
        }
      }
    }
  }
}
{
  "id": "64",
  "blame_commit": {
    "commit": {
      "commit_id": "0e413176143711bb417439634acd8d6031264612",
      "commit_message": "Fix inversion of 3d axis.\n\n... which was broken because 3d axises stored and accessed their viewlim\ninfo sometimes in xy_viewLim/zz_viewLim and sometimes in v_interval (and\nlikewise for datalim), leading to out-of-sync info...\n\nNot deprecating d_interval/v_interval for now both because this needs to\ngo to 3.1.1 to fix the breakage and because I think storing the info in\naxis attributes actually makes *more* sense than in viewLim/dataLim --\nbut fully switching to d_interval/v_interval needs bigger surgery.",
      "commit_author": "Antony Lee",
      "commit_date": "2019-06-20 10:38:28",
      "commit_parent": "63d96d2861c6b4c42da83067689dbe7b6d33582b"
    },
    "function": {
      "function_name": "_make_getset_interval",
      "function_code_before": "",
      "function_code_after": "def _make_getset_interval(method_name, lim_name, attr_name):\n    \"\"\"\n    Helper to generate ``get_{data,view}_interval`` and\n    ``set_{data,view}_interval`` implementations.\n    \"\"\"\n\n    def getter(self):\n        return getattr(getattr(self.axes, lim_name), attr_name)\n\n    def setter(self, vmin, vmax, ignore=False):\n        if ignore:\n            setattr(getattr(self.axes, lim_name), attr_name, (vmin, vmax))\n        else:\n            (oldmin, oldmax) = getter(self)\n            if oldmin < oldmax:\n                setter(self, min(vmin, vmax, oldmin), max(vmin, vmax, oldmax), ignore=True)\n            else:\n                setter(self, max(vmin, vmax, oldmax), min(vmin, vmax, oldmin), ignore=True)\n        self.stale = True\n    getter.__name__ = f'get_{method_name}_interval'\n    setter.__name__ = f'set_{method_name}_interval'\n    return (getter, setter)",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 1893,
      "function_after_end_line": 1920,
      "function_before_token_count": 0,
      "function_after_token_count": 30,
      "functions_name_modified_file": [
        "get_minorticklines",
        "get_data_interval",
        "_get_text1_transform",
        "get_smart_bounds",
        "get_transform",
        "set_major_locator",
        "get_minorticklabels",
        "set_remove_overlapping_locs",
        "set_offset_position",
        "cla",
        "set_pad",
        "update_position",
        "get_ticks_direction",
        "get_loc",
        "get_minpos",
        "set_units",
        "_get_text2_transform",
        "get_remove_overlapping_locs",
        "pan",
        "get_ticks_position",
        "_get_tick1line",
        "get_text_heights",
        "set_smart_bounds",
        "formatter",
        "get_label_position",
        "get_pad",
        "__init__",
        "get_majorticklabels",
        "set_minor_locator",
        "_get_gridline",
        "set_pickradius",
        "get_ticklines",
        "get_ticklabels",
        "_get_label",
        "contains",
        "get_text_widths",
        "iter_ticks",
        "_copy_tick_props",
        "axis_date",
        "get_pad_pixels",
        "get_tick_space",
        "apply_tickdir",
        "_set_scale",
        "locator",
        "set_tick_params",
        "__str__",
        "_update_axisinfo",
        "set_label1",
        "get_minor_formatter",
        "_make_getset_interval",
        "get_offset_text",
        "_set_artist_props",
        "label",
        "_get_tick2line",
        "grid",
        "limit_range_for_scale",
        "update_units",
        "get_tightbbox",
        "set_ticklabels",
        "get_units",
        "get_major_ticks",
        "_apply_params",
        "__get__",
        "_update_ticks",
        "convert_units",
        "set_data_interval",
        "get_ticklocs",
        "_update_label_position",
        "draw",
        "get_minor_locator",
        "set_label_position",
        "zoom",
        "_get_tick_bboxes",
        "get_major_formatter",
        "get_major_locator",
        "set_minor_formatter",
        "_get_text2",
        "set_ticks",
        "set_view_interval",
        "get_scale",
        "_update_offset_text_position",
        "_get_offset_text",
        "set_label2",
        "tick_top",
        "get_tickdir",
        "_get_tick",
        "get_children",
        "_translate_tick_kw",
        "set_label_coords",
        "get_inverted",
        "get_ticklabel_extents",
        "get_label",
        "set_inverted",
        "set_major_formatter",
        "have_units",
        "set_label_text",
        "get_majorticklines",
        "get_majorticklocs",
        "tick_bottom",
        "set_clip_path",
        "get_label_text",
        "get_gridlines",
        "_get_text1",
        "set_default_intervals",
        "_get_tick_boxes_siblings",
        "get_view_interval",
        "get_tick_padding",
        "get_pickradius",
        "get_minor_ticks",
        "get_minorticklocs",
        "_get_ticks_position",
        "tick_right",
        "_set_labelrotation",
        "reset_ticks",
        "set_ticks_position",
        "tick_left"
      ],
      "functions_name_all_files": [
        "get_minorticklines",
        "d_interval",
        "get_data_interval",
        "_get_text1_transform",
        "get_smart_bounds",
        "test_poly3dcollection_alpha",
        "get_transform",
        "set_major_locator",
        "test_bar3d",
        "get_minorticklabels",
        "test_axes3d_ortho",
        "set_remove_overlapping_locs",
        "set_offset_position",
        "cla",
        "set_pad",
        "update_position",
        "get_ticks_direction",
        "test_wireframe3dzerorstride",
        "get_loc",
        "test_proj3d_deprecated",
        "get_minpos",
        "set_pane_pos",
        "test_proj_axes_cube",
        "set_units",
        "_get_text2_transform",
        "test_mixedsubplots",
        "test_surface3d_shaded",
        "test_surface3d",
        "test_edge_style",
        "get_remove_overlapping_locs",
        "pan",
        "get_ticks_position",
        "get_flip_min_max",
        "_get_tick1line",
        "get_text_heights",
        "set_smart_bounds",
        "formatter",
        "get_label_position",
        "get_pad",
        "__init__",
        "get_majorticklabels",
        "set_minor_locator",
        "_get_gridline",
        "set_pickradius",
        "get_ticklines",
        "test_alpha",
        "get_ticklabels",
        "_get_label",
        "contains",
        "test_wireframe3dzerostrideraises",
        "get_text_widths",
        "_test_proj_make_M",
        "iter_ticks",
        "test_invalid_axes_limits",
        "test_art3d_deprecated",
        "set_rotate_label",
        "test_contourf3d_fill",
        "get_rotate_label",
        "test_calling_conventions",
        "_copy_tick_props",
        "test_scatter3d_color",
        "test_scatter3d",
        "test_named_colors",
        "axis_date",
        "get_pad_pixels",
        "test_autoscale",
        "get_tick_space",
        "test_quiver3d_pivot_middle",
        "apply_tickdir",
        "test_xyz",
        "_set_scale",
        "_get_coord_info",
        "test_axes3d_labelpad",
        "test_line3d_set_get_data_3d",
        "locator",
        "test_plot_3d_from_2d",
        "set_tick_params",
        "__str__",
        "_update_axisinfo",
        "set_label1",
        "get_minor_formatter",
        "_make_getset_interval",
        "test_world",
        "test_poly3dcollection_closed",
        "test_wireframe3dzerocstride",
        "get_offset_text",
        "_set_artist_props",
        "label",
        "_get_tick2line",
        "grid",
        "test_contour3d",
        "limit_range_for_scale",
        "update_units",
        "get_tightbbox",
        "test_quiver3d",
        "tick_update_position",
        "set_ticklabels",
        "get_units",
        "test_aspect_equal_error",
        "get_major_ticks",
        "_apply_params",
        "test_ax3d_tickcolour",
        "__get__",
        "_update_ticks",
        "convert_units",
        "set_data_interval",
        "get_ticklocs",
        "_update_label_position",
        "test_contourf3d",
        "test_poly_collection_2d_to_3d_empty",
        "draw",
        "get_minor_locator",
        "set_label_position",
        "zoom",
        "test_proj_transform",
        "test_simple",
        "_get_tick_bboxes",
        "get_major_formatter",
        "get_major_locator",
        "set_minor_formatter",
        "_get_text2",
        "_test_proj_draw_axes",
        "test_plotsurface_1d_raises",
        "set_ticks",
        "set_view_interval",
        "get_scale",
        "test_text3d",
        "_update_offset_text_position",
        "_get_offset_text",
        "set_label2",
        "tick_top",
        "get_tickdir",
        "_get_tick",
        "test_quiver3d_empty",
        "get_children",
        "_translate_tick_kw",
        "move_from_center",
        "test_tricontour",
        "set_label_coords",
        "get_inverted",
        "get_ticklabel_extents",
        "test_inverted_cla",
        "get_label",
        "init3d",
        "test_lines_dists",
        "set_inverted",
        "v_interval",
        "test_axes3d_cla",
        "set_major_formatter",
        "have_units",
        "test_quiver3d_pivot_tail",
        "set_label_text",
        "get_majorticklines",
        "get_majorticklocs",
        "tick_bottom",
        "test_rgb_data",
        "set_clip_path",
        "get_label_text",
        "test_mixedsamplesraises",
        "test_rot",
        "get_gridlines",
        "draw_pane",
        "test_quiver3d_masked",
        "test_proj_axes_cube_ortho",
        "_get_text1",
        "set_pane_color",
        "set_default_intervals",
        "_get_tick_boxes_siblings",
        "get_view_interval",
        "test_inverted",
        "get_tick_padding",
        "get_pickradius",
        "test_tight_layout_text",
        "test_trisurf3d",
        "get_minor_ticks",
        "test_lines3d",
        "test_wireframe3d",
        "get_minorticklocs",
        "_get_ticks_position",
        "test_bar3d_shaded",
        "tick_right",
        "test_bar3d_notshaded",
        "_set_labelrotation",
        "reset_ticks",
        "test_trisurf3d_shaded",
        "set_ticks_position",
        "tick_left",
        "get_tick_positions"
      ],
      "functions_name_co_evolved_modified_file": [
        "set_data_interval",
        "get_data_interval",
        "set_view_interval",
        "get_view_interval"
      ],
      "functions_name_co_evolved_all_files": [
        "d_interval",
        "__init__",
        "test_inverted",
        "get_data_interval",
        "v_interval",
        "set_view_interval",
        "set_data_interval",
        "get_view_interval"
      ]
    },
    "file": {
      "file_name": "axis.py",
      "file_nloc": 1663,
      "file_complexity": 455,
      "file_token_count": 11415,
      "file_before": "\"\"\"\nClasses for the ticks and x and y axis.\n\"\"\"\n\nimport datetime\nimport logging\n\nimport numpy as np\n\nfrom matplotlib import rcParams\nimport matplotlib.artist as martist\nimport matplotlib.cbook as cbook\nimport matplotlib.font_manager as font_manager\nimport matplotlib.lines as mlines\nimport matplotlib.scale as mscale\nimport matplotlib.text as mtext\nimport matplotlib.ticker as mticker\nimport matplotlib.transforms as mtransforms\nimport matplotlib.units as munits\n\n_log = logging.getLogger(__name__)\n\nGRIDLINE_INTERPOLATION_STEPS = 180\n\n# This list is being used for compatibility with Axes.grid, which\n# allows all Line2D kwargs.\n_line_AI = martist.ArtistInspector(mlines.Line2D)\n_line_param_names = _line_AI.get_setters()\n_line_param_aliases = [list(d)[0] for d in _line_AI.aliasd.values()]\n_gridline_param_names = ['grid_' + name\n                         for name in _line_param_names + _line_param_aliases]\n\n\nclass Tick(martist.Artist):\n    \"\"\"\n    Abstract base class for the axis ticks, grid lines and labels.\n\n    Ticks mark a position on an Axis. They contain two lines as markers and\n    two labels; one each for the bottom and top positions (in case of an\n    `.XAxis`) or for the left and right positions (in case of a `.YAxis`).\n\n    Attributes\n    ----------\n    tick1line : `.Line2D`\n        The left/bottom tick marker.\n    tick2line : `.Line2D`\n        The right/top tick marker.\n    gridline : `.Line2D`\n        The grid line associated with the label position.\n    label1 : `.Text`\n        The left/bottom tick label.\n    label2 : `.Text`\n        The right/top tick label.\n\n    \"\"\"\n    def __init__(self, axes, loc, label,\n                 size=None,  # points\n                 width=None,\n                 color=None,\n                 tickdir=None,\n                 pad=None,\n                 labelsize=None,\n                 labelcolor=None,\n                 zorder=None,\n                 gridOn=None,  # defaults to axes.grid depending on\n                               # axes.grid.which\n                 tick1On=True,\n                 tick2On=True,\n                 label1On=True,\n                 label2On=False,\n                 major=True,\n                 labelrotation=0,\n                 grid_color=None,\n                 grid_linestyle=None,\n                 grid_linewidth=None,\n                 grid_alpha=None,\n                 **kw  # Other Line2D kwargs applied to gridlines.\n                 ):\n        \"\"\"\n        bbox is the Bound2D bounding box in display coords of the Axes\n        loc is the tick location in data coords\n        size is the tick size in points\n        \"\"\"\n        martist.Artist.__init__(self)\n\n        if gridOn is None:\n            if major and (rcParams['axes.grid.which'] in ('both', 'major')):\n                gridOn = rcParams['axes.grid']\n            elif (not major) and (rcParams['axes.grid.which']\n                                  in ('both', 'minor')):\n                gridOn = rcParams['axes.grid']\n            else:\n                gridOn = False\n\n        self.set_figure(axes.figure)\n        self.axes = axes\n\n        name = self.__name__.lower()\n        self._name = name\n\n        self._loc = loc\n\n        if size is None:\n            if major:\n                size = rcParams['%s.major.size' % name]\n            else:\n                size = rcParams['%s.minor.size' % name]\n        self._size = size\n\n        if width is None:\n            if major:\n                width = rcParams['%s.major.width' % name]\n            else:\n                width = rcParams['%s.minor.width' % name]\n        self._width = width\n\n        if color is None:\n            color = rcParams['%s.color' % name]\n        self._color = color\n\n        if pad is None:\n            if major:\n                pad = rcParams['%s.major.pad' % name]\n            else:\n                pad = rcParams['%s.minor.pad' % name]\n        self._base_pad = pad\n\n        if labelcolor is None:\n            labelcolor = rcParams['%s.color' % name]\n        self._labelcolor = labelcolor\n\n        if labelsize is None:\n            labelsize = rcParams['%s.labelsize' % name]\n        self._labelsize = labelsize\n\n        self._set_labelrotation(labelrotation)\n\n        if zorder is None:\n            if major:\n                zorder = mlines.Line2D.zorder + 0.01\n            else:\n                zorder = mlines.Line2D.zorder\n        self._zorder = zorder\n\n        self._grid_color = (rcParams['grid.color']\n                            if grid_color is None else grid_color)\n        self._grid_linestyle = (rcParams['grid.linestyle']\n                                if grid_linestyle is None else grid_linestyle)\n        self._grid_linewidth = (rcParams['grid.linewidth']\n                                if grid_linewidth is None else grid_linewidth)\n        self._grid_alpha = (rcParams['grid.alpha']\n                            if grid_alpha is None else grid_alpha)\n\n        self._grid_kw = {k[5:]: v for k, v in kw.items()}\n\n        self.apply_tickdir(tickdir)\n\n        self.tick1line = self._get_tick1line()\n        self.tick2line = self._get_tick2line()\n        self.gridline = self._get_gridline()\n        self.label1 = self._get_text1()\n        self.label2 = self._get_text2()\n\n        self.gridline.set_visible(gridOn)\n        self.tick1line.set_visible(tick1On)\n        self.tick2line.set_visible(tick2On)\n        self.label1.set_visible(label1On)\n        self.label2.set_visible(label2On)\n\n        self.update_position(loc)\n\n    for _old_name, _new_name in [\n            (\"gridOn\", \"gridline\"),\n            (\"tick1On\", \"tick1line\"),\n            (\"tick2On\", \"tick2line\"),\n            (\"label1On\", \"label1\"),\n            (\"label2On\", \"label2\")]:\n        locals()[_old_name] = property(\n            cbook.deprecated(\n                \"3.1\",\n                name=_old_name,\n                alternative=\"Tick.{}.get_visible\".format(_new_name))(\n                    lambda self, _new_name=_new_name:\n                        getattr(self, _new_name).get_visible()),\n            cbook.deprecated(\n                \"3.1\",\n                name=_old_name,\n                alternative=\"Tick.{}.set_visible\".format(_new_name))(\n                    lambda self, value, _new_name=_new_name:\n                        getattr(self, _new_name).set_visible(value)))\n    del _old_name, _new_name\n\n    @property\n    @cbook.deprecated(\"3.1\", alternative=\"Tick.label1\", pending=True)\n    def label(self):\n        return self.label1\n\n    def _set_labelrotation(self, labelrotation):\n        if isinstance(labelrotation, str):\n            mode = labelrotation\n            angle = 0\n        elif isinstance(labelrotation, (tuple, list)):\n            mode, angle = labelrotation\n        else:\n            mode = 'default'\n            angle = labelrotation\n        cbook._check_in_list(['auto', 'default'], labelrotation=mode)\n        self._labelrotation = (mode, angle)\n\n    def apply_tickdir(self, tickdir):\n        \"\"\"Calculate self._pad and self._tickmarkers.\"\"\"\n\n    def get_tickdir(self):\n        return self._tickdir\n\n    def get_tick_padding(self):\n        \"\"\"Get the length of the tick outside of the axes.\"\"\"\n        padding = {\n            'in': 0.0,\n            'inout': 0.5,\n            'out': 1.0\n        }\n        return self._size * padding[self._tickdir]\n\n    def get_children(self):\n        children = [self.tick1line, self.tick2line,\n                    self.gridline, self.label1, self.label2]\n        return children\n\n    def set_clip_path(self, clippath, transform=None):\n        # docstring inherited\n        martist.Artist.set_clip_path(self, clippath, transform)\n        self.gridline.set_clip_path(clippath, transform)\n        self.stale = True\n\n    def get_pad_pixels(self):\n        return self.figure.dpi * self._base_pad / 72\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occurred in the Tick marks.\n\n        This function always returns false.  It is more useful to test if the\n        axis as a whole contains the mouse rather than the set of tick marks.\n        \"\"\"\n        if self._contains is not None:\n            return self._contains(self, mouseevent)\n        return False, {}\n\n    def set_pad(self, val):\n        \"\"\"\n        Set the tick label pad in points\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        self._apply_params(pad=val)\n        self.stale = True\n\n    def get_pad(self):\n        'Get the value of the tick label pad in points'\n        return self._base_pad\n\n    def _get_text1(self):\n        'Get the default Text 1 instance'\n        pass\n\n    def _get_text2(self):\n        'Get the default Text 2 instance'\n        pass\n\n    def _get_tick1line(self):\n        'Get the default line2D instance for tick1'\n        pass\n\n    def _get_tick2line(self):\n        'Get the default line2D instance for tick2'\n        pass\n\n    def _get_gridline(self):\n        'Get the default grid Line2d instance for this tick'\n        pass\n\n    def get_loc(self):\n        'Return the tick location (data coords) as a scalar'\n        return self._loc\n\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        if not self.get_visible():\n            self.stale = False\n            return\n        renderer.open_group(self.__name__)\n        for artist in [self.gridline, self.tick1line, self.tick2line,\n                       self.label1, self.label2]:\n            artist.draw(renderer)\n        renderer.close_group(self.__name__)\n        self.stale = False\n\n    def set_label1(self, s):\n        \"\"\"\n        Set the label1 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label1.set_text(s)\n        self.stale = True\n\n    set_label = set_label1\n\n    def set_label2(self, s):\n        \"\"\"\n        Set the label2 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label2.set_text(s)\n        self.stale = True\n\n    def _set_artist_props(self, a):\n        a.set_figure(self.figure)\n\n    def get_view_interval(self):\n        \"\"\"\n        Return the view limits ``(min, max)`` of the axis the tick belongs to.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _apply_params(self, **kw):\n        for name, target in [(\"gridOn\", self.gridline),\n                               (\"tick1On\", self.tick1line),\n                               (\"tick2On\", self.tick2line),\n                               (\"label1On\", self.label1),\n                               (\"label2On\", self.label2)]:\n            if name in kw:\n                target.set_visible(kw.pop(name))\n        if any(k in kw for k in ['size', 'width', 'pad', 'tickdir']):\n            self._size = kw.pop('size', self._size)\n            # Width could be handled outside this block, but it is\n            # convenient to leave it here.\n            self._width = kw.pop('width', self._width)\n            self._base_pad = kw.pop('pad', self._base_pad)\n            # apply_tickdir uses _size and _base_pad to make _pad,\n            # and also makes _tickmarkers.\n            self.apply_tickdir(kw.pop('tickdir', self._tickdir))\n            self.tick1line.set_marker(self._tickmarkers[0])\n            self.tick2line.set_marker(self._tickmarkers[1])\n            for line in (self.tick1line, self.tick2line):\n                line.set_markersize(self._size)\n                line.set_markeredgewidth(self._width)\n            # _get_text1_transform uses _pad from apply_tickdir.\n            trans = self._get_text1_transform()[0]\n            self.label1.set_transform(trans)\n            trans = self._get_text2_transform()[0]\n            self.label2.set_transform(trans)\n        tick_kw = {k: v for k, v in kw.items() if k in ['color', 'zorder']}\n        self.tick1line.set(**tick_kw)\n        self.tick2line.set(**tick_kw)\n        for k, v in tick_kw.items():\n            setattr(self, '_' + k, v)\n\n        if 'labelrotation' in kw:\n            self._set_labelrotation(kw.pop('labelrotation'))\n            self.label1.set(rotation=self._labelrotation[1])\n            self.label2.set(rotation=self._labelrotation[1])\n\n        label_kw = {k[5:]: v for k, v in kw.items()\n                    if k in ['labelsize', 'labelcolor']}\n        self.label1.set(**label_kw)\n        self.label2.set(**label_kw)\n        for k, v in label_kw.items():\n            # for labelsize the text objects covert str ('small')\n            # -> points. grab the integer from the `Text` object\n            # instead of saving the string representation\n            v = getattr(self.label1, 'get_' + k)()\n            setattr(self, '_label' + k, v)\n\n        grid_kw = {k[5:]: v for k, v in kw.items()\n                   if k in _gridline_param_names}\n        self.gridline.set(**grid_kw)\n        for k, v in grid_kw.items():\n            setattr(self, '_grid_' + k, v)\n\n    def update_position(self, loc):\n        'Set the location of tick in data coords with scalar *loc*'\n        raise NotImplementedError('Derived must override')\n\n    def _get_text1_transform(self):\n        raise NotImplementedError('Derived must override')\n\n    def _get_text2_transform(self):\n        raise NotImplementedError('Derived must override')\n\n\nclass XTick(Tick):\n    \"\"\"\n    Contains all the Artists needed to make an x tick - the tick line,\n    the label text and the grid line\n    \"\"\"\n    __name__ = 'xtick'\n\n    def _get_text1_transform(self):\n        return self.axes.get_xaxis_text1_transform(self._pad)\n\n    def _get_text2_transform(self):\n        return self.axes.get_xaxis_text2_transform(self._pad)\n\n    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = rcParams['%s.direction' % self._name]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKUP, mlines.TICKDOWN)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('|', '|')\n        else:\n            self._tickmarkers = (mlines.TICKDOWN, mlines.TICKUP)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True\n\n    def _get_text1(self):\n        'Get the default Text instance'\n        # the y loc is 3 points below the min of y axis\n        # get the affine as an a,b,c,d,tx,ty list\n        # x in data coords, y in axes coords\n        trans, vert, horiz = self._get_text1_transform()\n        t = mtext.Text(\n            x=0, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_text2(self):\n        'Get the default Text 2 instance'\n        # x in data coords, y in axes coords\n        trans, vert, horiz = self._get_text2_transform()\n        t = mtext.Text(\n            x=0, y=1,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_tick1line(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0,), ydata=(0,), color=self._color,\n                          linestyle='None', marker=self._tickmarkers[0],\n                          markersize=self._size,\n                          markeredgewidth=self._width, zorder=self._zorder)\n        l.set_transform(self.axes.get_xaxis_transform(which='tick1'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_tick2line(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0,), ydata=(1,),\n                          color=self._color,\n                          linestyle='None',\n                          marker=self._tickmarkers[1],\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n\n        l.set_transform(self.axes.get_xaxis_transform(which='tick2'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_gridline(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0.0, 0.0), ydata=(0, 1.0),\n                          color=self._grid_color,\n                          linestyle=self._grid_linestyle,\n                          linewidth=self._grid_linewidth,\n                          alpha=self._grid_alpha,\n                          markersize=0,\n                          **self._grid_kw)\n        l.set_transform(self.axes.get_xaxis_transform(which='grid'))\n        l.get_path()._interpolation_steps = GRIDLINE_INTERPOLATION_STEPS\n        self._set_artist_props(l)\n\n        return l\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_xdata((loc,))\n        self.tick2line.set_xdata((loc,))\n        self.gridline.set_xdata((loc,))\n        self.label1.set_x(loc)\n        self.label2.set_x(loc)\n        self._loc = loc\n        self.stale = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervalx\n\n\nclass YTick(Tick):\n    \"\"\"\n    Contains all the Artists needed to make a Y tick - the tick line,\n    the label text and the grid line\n    \"\"\"\n    __name__ = 'ytick'\n\n    def _get_text1_transform(self):\n        return self.axes.get_yaxis_text1_transform(self._pad)\n\n    def _get_text2_transform(self):\n        return self.axes.get_yaxis_text2_transform(self._pad)\n\n    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = rcParams['%s.direction' % self._name]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKRIGHT, mlines.TICKLEFT)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('_', '_')\n        else:\n            self._tickmarkers = (mlines.TICKLEFT, mlines.TICKRIGHT)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True\n\n    # how far from the y axis line the right of the ticklabel are\n    def _get_text1(self):\n        'Get the default Text instance'\n        # x in axes coords, y in data coords\n        trans, vert, horiz = self._get_text1_transform()\n        t = mtext.Text(\n            x=0, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_text2(self):\n        'Get the default Text instance'\n        # x in axes coords, y in data coords\n        trans, vert, horiz = self._get_text2_transform()\n        t = mtext.Text(\n            x=1, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_tick1line(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n\n        l = mlines.Line2D((0,), (0,),\n                          color=self._color,\n                          marker=self._tickmarkers[0],\n                          linestyle='None',\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n        l.set_transform(self.axes.get_yaxis_transform(which='tick1'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_tick2line(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n        l = mlines.Line2D((1,), (0,),\n                          color=self._color,\n                          marker=self._tickmarkers[1],\n                          linestyle='None',\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n        l.set_transform(self.axes.get_yaxis_transform(which='tick2'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_gridline(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n        l = mlines.Line2D(xdata=(0, 1), ydata=(0, 0),\n                          color=self._grid_color,\n                          linestyle=self._grid_linestyle,\n                          linewidth=self._grid_linewidth,\n                          alpha=self._grid_alpha,\n                          markersize=0,\n                          **self._grid_kw)\n        l.set_transform(self.axes.get_yaxis_transform(which='grid'))\n        l.get_path()._interpolation_steps = GRIDLINE_INTERPOLATION_STEPS\n        self._set_artist_props(l)\n        return l\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_ydata((loc,))\n        self.tick2line.set_ydata((loc,))\n        self.gridline.set_ydata((loc,))\n        self.label1.set_y(loc)\n        self.label2.set_y(loc)\n        self._loc = loc\n        self.stale = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervaly\n\n\nclass Ticker:\n    \"\"\"\n    A container for the objects defining tick position and format.\n\n    Attributes\n    ----------\n    locator : `matplotlib.ticker.Locator` subclass\n        Determines the positions of the ticks.\n    formatter : `matplotlib.ticker.Formatter` subclass\n        Determines the format of the tick labels.\n    \"\"\"\n\n    def __init__(self):\n        self._locator = None\n        self._formatter = None\n\n    @property\n    def locator(self):\n        return self._locator\n\n    @locator.setter\n    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            cbook.warn_deprecated(\n                \"3.2\", message=\"Support for locators that do not subclass \"\n                \"matplotlib.ticker.Locator is deprecated since %(since)s and \"\n                \"support for them will be removed %(removal)s.\")\n        self._locator = locator\n\n    @property\n    def formatter(self):\n        return self._formatter\n\n    @formatter.setter\n    def formatter(self, formatter):\n        if not isinstance(formatter, mticker.Formatter):\n            cbook.warn_deprecated(\n                \"3.2\", message=\"Support for formatters that do not subclass \"\n                \"matplotlib.ticker.Formatter is deprecated since %(since)s \"\n                \"and support for them will be removed %(removal)s.\")\n        self._formatter = formatter\n\n\nclass _LazyTickList:\n    \"\"\"\n    A descriptor for lazy instantiation of tick lists.\n\n    See comment above definition of the ``majorTicks`` and ``minorTicks``\n    attributes.\n    \"\"\"\n\n    def __init__(self, major):\n        self._major = major\n\n    def __get__(self, instance, cls):\n        if instance is None:\n            return self\n        else:\n            # instance._get_tick() can itself try to access the majorTicks\n            # attribute (e.g. in certain projection classes which override\n            # e.g. get_xaxis_text1_transform).  In order to avoid infinite\n            # recursion, first set the majorTicks on the instance to an empty\n            # list, then create the tick and append it.\n            if self._major:\n                instance.majorTicks = []\n                tick = instance._get_tick(major=True)\n                instance.majorTicks.append(tick)\n                return instance.majorTicks\n            else:\n                instance.minorTicks = []\n                tick = instance._get_tick(major=False)\n                instance.minorTicks.append(tick)\n                return instance.minorTicks\n\n\nclass Axis(martist.Artist):\n    \"\"\"\n    Base class for `.XAxis` and `.YAxis`.\n\n    Attributes\n    ----------\n    isDefault_label : bool\n\n    axes : `matplotlib.axes.Axes`\n        The `~.axes.Axes` to which the Axis belongs.\n    major : `matplotlib.axis.Ticker`\n        Determines the major tick positions and their label format.\n    minor : `matplotlib.axis.Ticker`\n        Determines the minor tick positions and their label format.\n    callbacks : `matplotlib.cbook.CallbackRegistry`\n\n    label : `.Text`\n        The axis label.\n    labelpad : float\n        The distance between the axis label and the tick labels.\n        Defaults to :rc:`axes.labelpad` = 4.\n    offsetText : `.Text`\n        A `.Text` object containing the data offset of the ticks (if any).\n    pickradius : float\n        The acceptance radius for containment tests. See also `.Axis.contains`.\n    majorTicks : list of `.Tick`\n        The major ticks.\n    minorTicks : list of `.Tick`\n        The minor ticks.\n    \"\"\"\n    OFFSETTEXTPAD = 3\n\n    def __str__(self):\n        return self.__class__.__name__ \\\n            + \"(%f,%f)\" % tuple(self.axes.transAxes.transform_point((0, 0)))\n\n    def __init__(self, axes, pickradius=15):\n        \"\"\"\n        Parameters\n        ----------\n        axes : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to which the created Axis belongs.\n        pickradius : float\n            The acceptance radius for containment tests. See also\n            `.Axis.contains`.\n        \"\"\"\n        martist.Artist.__init__(self)\n        self._remove_overlapping_locs = True\n\n        self.set_figure(axes.figure)\n\n        self.isDefault_label = True\n\n        self.axes = axes\n        self.major = Ticker()\n        self.minor = Ticker()\n        self.callbacks = cbook.CallbackRegistry()\n\n        self._autolabelpos = True\n        self._smart_bounds = False\n\n        self.label = self._get_label()\n        self.labelpad = rcParams['axes.labelpad']\n        self.offsetText = self._get_offset_text()\n\n        self.pickradius = pickradius\n\n        # Initialize here for testing; later add API\n        self._major_tick_kw = dict()\n        self._minor_tick_kw = dict()\n\n        self.cla()\n        self._set_scale('linear')\n\n    # During initialization, Axis objects often create ticks that are later\n    # unused; this turns out to be a very slow step.  Instead, use a custom\n    # descriptor to make the tick lists lazy and instantiate them as needed.\n    majorTicks = _LazyTickList(major=True)\n    minorTicks = _LazyTickList(major=False)\n\n    def get_remove_overlapping_locs(self):\n        return self._remove_overlapping_locs\n\n    def set_remove_overlapping_locs(self, val):\n        self._remove_overlapping_locs = bool(val)\n\n    remove_overlapping_locs = property(\n        get_remove_overlapping_locs, set_remove_overlapping_locs,\n        doc=('If minor ticker locations that overlap with major '\n             'ticker locations should be trimmed.'))\n\n    def set_label_coords(self, x, y, transform=None):\n        \"\"\"\n        Set the coordinates of the label.\n\n        By default, the x coordinate of the y label is determined by the tick\n        label bounding boxes, but this can lead to poor alignment of multiple\n        ylabels if there are multiple axes.  Ditto for the y coordinate of\n        the x label.\n\n        You can also specify the coordinate system of the label with\n        the transform.  If None, the default coordinate system will be\n        the axes coordinate system (0,0) is (left,bottom), (0.5, 0.5)\n        is middle, etc\n        \"\"\"\n        self._autolabelpos = False\n        if transform is None:\n            transform = self.axes.transAxes\n\n        self.label.set_transform(transform)\n        self.label.set_position((x, y))\n        self.stale = True\n\n    def get_transform(self):\n        return self._scale.get_transform()\n\n    def get_scale(self):\n        return self._scale.name\n\n    def _set_scale(self, value, **kwargs):\n        self._scale = mscale.scale_factory(value, self, **kwargs)\n        self._scale.set_default_locators_and_formatters(self)\n\n        self.isDefault_majloc = True\n        self.isDefault_minloc = True\n        self.isDefault_majfmt = True\n        self.isDefault_minfmt = True\n\n    def limit_range_for_scale(self, vmin, vmax):\n        return self._scale.limit_range_for_scale(vmin, vmax, self.get_minpos())\n\n    def get_children(self):\n        return [self.label, self.offsetText,\n                *self.get_major_ticks(), *self.get_minor_ticks()]\n\n    def cla(self):\n        \"\"\"Clear this axis.\"\"\"\n\n        self.label.set_text('')  # self.set_label_text would change isDefault_\n\n        self._set_scale('linear')\n\n        # Clear the callback registry for this axis, or it may \"leak\"\n        self.callbacks = cbook.CallbackRegistry()\n\n        # whether the grids are on\n        self._gridOnMajor = (rcParams['axes.grid'] and\n                             rcParams['axes.grid.which'] in ('both', 'major'))\n        self._gridOnMinor = (rcParams['axes.grid'] and\n                             rcParams['axes.grid.which'] in ('both', 'minor'))\n\n        self.reset_ticks()\n\n        self.converter = None\n        self.units = None\n        self.set_units(None)\n        self.stale = True\n\n    def reset_ticks(self):\n        \"\"\"\n        Re-initialize the major and minor Tick lists.\n\n        Each list starts with a single fresh Tick.\n        \"\"\"\n        # Restore the lazy tick lists.\n        try:\n            del self.majorTicks\n        except AttributeError:\n            pass\n        try:\n            del self.minorTicks\n        except AttributeError:\n            pass\n        try:\n            self.set_clip_path(self.axes.patch)\n        except AttributeError:\n            pass\n\n    def set_tick_params(self, which='major', reset=False, **kw):\n        \"\"\"\n        Set appearance parameters for ticks, ticklabels, and gridlines.\n\n        For documentation of keyword arguments, see\n        :meth:`matplotlib.axes.Axes.tick_params`.\n        \"\"\"\n        dicts = []\n        if which == 'major' or which == 'both':\n            dicts.append(self._major_tick_kw)\n        if which == 'minor' or which == 'both':\n            dicts.append(self._minor_tick_kw)\n        kwtrans = self._translate_tick_kw(kw)\n\n        # this stashes the parameter changes so any new ticks will\n        # automatically get them\n        for d in dicts:\n            if reset:\n                d.clear()\n            d.update(kwtrans)\n\n        if reset:\n            self.reset_ticks()\n        else:\n            # apply the new kwargs to the existing ticks\n            if which == 'major' or which == 'both':\n                for tick in self.majorTicks:\n                    tick._apply_params(**kwtrans)\n            if which == 'minor' or which == 'both':\n                for tick in self.minorTicks:\n                    tick._apply_params(**kwtrans)\n            # special-case label color to also apply to the offset\n            # text\n            if 'labelcolor' in kwtrans:\n                self.offsetText.set_color(kwtrans['labelcolor'])\n\n        self.stale = True\n\n    @staticmethod\n    def _translate_tick_kw(kw):\n        # The following lists may be moved to a more accessible location.\n        kwkeys = ['size', 'width', 'color', 'tickdir', 'pad',\n                  'labelsize', 'labelcolor', 'zorder', 'gridOn',\n                  'tick1On', 'tick2On', 'label1On', 'label2On',\n                  'length', 'direction', 'left', 'bottom', 'right', 'top',\n                  'labelleft', 'labelbottom', 'labelright', 'labeltop',\n                  'labelrotation'] + _gridline_param_names\n        kwtrans = {}\n        if 'length' in kw:\n            kwtrans['size'] = kw.pop('length')\n        if 'direction' in kw:\n            kwtrans['tickdir'] = kw.pop('direction')\n        if 'rotation' in kw:\n            kwtrans['labelrotation'] = kw.pop('rotation')\n        if 'left' in kw:\n            kwtrans['tick1On'] = kw.pop('left')\n        if 'bottom' in kw:\n            kwtrans['tick1On'] = kw.pop('bottom')\n        if 'right' in kw:\n            kwtrans['tick2On'] = kw.pop('right')\n        if 'top' in kw:\n            kwtrans['tick2On'] = kw.pop('top')\n        if 'labelleft' in kw:\n            kwtrans['label1On'] = kw.pop('labelleft')\n        if 'labelbottom' in kw:\n            kwtrans['label1On'] = kw.pop('labelbottom')\n        if 'labelright' in kw:\n            kwtrans['label2On'] = kw.pop('labelright')\n        if 'labeltop' in kw:\n            kwtrans['label2On'] = kw.pop('labeltop')\n        if 'colors' in kw:\n            c = kw.pop('colors')\n            kwtrans['color'] = c\n            kwtrans['labelcolor'] = c\n        # Maybe move the checking up to the caller of this method.\n        for key in kw:\n            if key not in kwkeys:\n                raise ValueError(\n                    \"keyword %s is not recognized; valid keywords are %s\"\n                    % (key, kwkeys))\n            kwtrans.update(kw)\n        return kwtrans\n\n    def set_clip_path(self, clippath, transform=None):\n        martist.Artist.set_clip_path(self, clippath, transform)\n        for child in self.majorTicks + self.minorTicks:\n            child.set_clip_path(clippath, transform)\n        self.stale = True\n\n    def get_view_interval(self):\n        \"\"\"Return the view limits ``(min, max)`` of this axis.\"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def set_view_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis view limits.  This method is for internal use; Matplotlib\n        users should typically use e.g. `~Axes.set_xlim` and `~Axes.set_ylim`.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting view limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the view limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def get_data_interval(self):\n        \"\"\"Return the Interval instance for this axis data limits.\"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def set_data_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis data limits.  This method is for internal use.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting data limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the data limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def get_inverted(self):\n        \"\"\"\n        Return whether the axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        low, high = self.get_view_interval()\n        return high < low\n\n    def set_inverted(self, inverted):\n        \"\"\"\n        Set whether the axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        a, b = self.get_view_interval()\n        if inverted:\n            self.set_view_interval(max(a, b), min(a, b), ignore=True)\n        else:\n            self.set_view_interval(min(a, b), max(a, b), ignore=True)\n\n    def set_default_intervals(self):\n        \"\"\"\n        Set the default limits for the axis data and view interval if they\n        have not been not mutated yet.\n        \"\"\"\n        # this is mainly in support of custom object plotting.  For\n        # example, if someone passes in a datetime object, we do not\n        # know automagically how to set the default min/max of the\n        # data and view limits.  The unit conversion AxisInfo\n        # interface provides a hook for custom types to register\n        # default limits through the AxisInfo.default_limits\n        # attribute, and the derived code below will check for that\n        # and use it if is available (else just use 0..1)\n\n    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.figure)\n\n    @cbook.deprecated(\"3.1\")\n    def iter_ticks(self):\n        \"\"\"\n        Yield ``(Tick, location, label)`` tuples for major and minor ticks.\n        \"\"\"\n        major_locs = self.get_majorticklocs()\n        major_labels = self.major.formatter.format_ticks(major_locs)\n        major_ticks = self.get_major_ticks(len(major_locs))\n        yield from zip(major_ticks, major_locs, major_labels)\n        minor_locs = self.get_minorticklocs()\n        minor_labels = self.minor.formatter.format_ticks(minor_locs)\n        minor_ticks = self.get_minor_ticks(len(minor_locs))\n        yield from zip(minor_ticks, minor_locs, minor_labels)\n\n    def get_ticklabel_extents(self, renderer):\n        \"\"\"\n        Get the extents of the tick labels on either side\n        of the axes.\n        \"\"\"\n\n        ticks_to_draw = self._update_ticks()\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(ticks_to_draw,\n                                                                renderer)\n\n        if len(ticklabelBoxes):\n            bbox = mtransforms.Bbox.union(ticklabelBoxes)\n        else:\n            bbox = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        if len(ticklabelBoxes2):\n            bbox2 = mtransforms.Bbox.union(ticklabelBoxes2)\n        else:\n            bbox2 = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        return bbox, bbox2\n\n    def set_smart_bounds(self, value):\n        \"\"\"Set the axis to have smart bounds.\"\"\"\n        self._smart_bounds = value\n        self.stale = True\n\n    def get_smart_bounds(self):\n        \"\"\"Return whether the axis has smart bounds.\"\"\"\n        return self._smart_bounds\n\n    def _update_ticks(self):\n        \"\"\"\n        Update ticks (position and labels) using the current data interval of\n        the axes.  Return the list of ticks that will be drawn.\n        \"\"\"\n        major_locs = self.get_majorticklocs()\n        major_labels = self.major.formatter.format_ticks(major_locs)\n        major_ticks = self.get_major_ticks(len(major_locs))\n        self.major.formatter.set_locs(major_locs)\n        for tick, loc, label in zip(major_ticks, major_locs, major_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        minor_locs = self.get_minorticklocs()\n        minor_labels = self.minor.formatter.format_ticks(minor_locs)\n        minor_ticks = self.get_minor_ticks(len(minor_locs))\n        self.minor.formatter.set_locs(minor_locs)\n        for tick, loc, label in zip(minor_ticks, minor_locs, minor_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        ticks = [*major_ticks, *minor_ticks]\n\n        view_low, view_high = self.get_view_interval()\n        if view_low > view_high:\n            view_low, view_high = view_high, view_low\n\n        if self._smart_bounds and ticks:\n            # handle inverted limits\n            data_low, data_high = sorted(self.get_data_interval())\n            locs = np.sort([tick.get_loc() for tick in ticks])\n            if data_low <= view_low:\n                # data extends beyond view, take view as limit\n                ilow = view_low\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs <= data_low]\n                if len(good_locs):\n                    # last tick prior or equal to first data point\n                    ilow = good_locs[-1]\n                else:\n                    # No ticks (why not?), take first tick\n                    ilow = locs[0]\n            if data_high >= view_high:\n                # data extends beyond view, take view as limit\n                ihigh = view_high\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs >= data_high]\n                if len(good_locs):\n                    # first tick after or equal to last data point\n                    ihigh = good_locs[0]\n                else:\n                    # No ticks (why not?), take last tick\n                    ihigh = locs[-1]\n            ticks = [tick for tick in ticks if ilow <= tick.get_loc() <= ihigh]\n\n        interval_t = self.get_transform().transform([view_low, view_high])\n\n        ticks_to_draw = []\n        for tick in ticks:\n            try:\n                loc_t = self.get_transform().transform(tick.get_loc())\n            except AssertionError:\n                # transforms.transform doesn't allow masked values but\n                # some scales might make them, so we need this try/except.\n                pass\n            else:\n                if mtransforms._interval_contains_close(interval_t, loc_t):\n                    ticks_to_draw.append(tick)\n\n        return ticks_to_draw\n\n    def _get_tick_bboxes(self, ticks, renderer):\n        \"\"\"Return lists of bboxes for ticks' label1's and label2's.\"\"\"\n        return ([tick.label1.get_window_extent(renderer)\n                 for tick in ticks if tick.label1.get_visible()],\n                [tick.label2.get_window_extent(renderer)\n                 for tick in ticks if tick.label2.get_visible()])\n\n    def get_tightbbox(self, renderer):\n        \"\"\"\n        Return a bounding box that encloses the axis. It only accounts\n        tick labels, axis label, and offsetText.\n        \"\"\"\n        if not self.get_visible():\n            return\n\n        ticks_to_draw = self._update_ticks()\n\n        self._update_label_position(renderer)\n\n        # go back to just this axis's tick labels\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(\n                    ticks_to_draw, renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n\n        bboxes = [\n            *(a.get_window_extent(renderer)\n              for a in [self.label, self.offsetText]\n              if a.get_visible()),\n            *ticklabelBoxes,\n            *ticklabelBoxes2,\n        ]\n        bboxes = [b for b in bboxes\n                  if 0 < b.width < np.inf and 0 < b.height < np.inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None\n\n    def get_tick_padding(self):\n        values = []\n        if len(self.majorTicks):\n            values.append(self.majorTicks[0].get_tick_padding())\n        if len(self.minorTicks):\n            values.append(self.minorTicks[0].get_tick_padding())\n        return max(values, default=0)\n\n    @martist.allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        'Draw the axis lines, grid lines, tick lines and labels'\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__)\n\n        ticks_to_draw = self._update_ticks()\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(ticks_to_draw,\n                                                                renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # scale up the axis label box to also find the neighbors, not\n        # just the tick labels that actually overlap note we need a\n        # *copy* of the axis label box because we don't wan't to scale\n        # the actual bbox\n\n        self._update_label_position(renderer)\n\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.draw(renderer)\n\n        renderer.close_group(__name__)\n        self.stale = False\n\n    def _get_label(self):\n        raise NotImplementedError('Derived must override')\n\n    def _get_offset_text(self):\n        raise NotImplementedError('Derived must override')\n\n    def get_gridlines(self):\n        'Return the grid lines as a list of Line2D instance'\n        ticks = self.get_major_ticks()\n        return cbook.silent_list('Line2D gridline',\n                                 [tick.gridline for tick in ticks])\n\n    def get_label(self):\n        'Return the axis label as a Text instance'\n        return self.label\n\n    def get_offset_text(self):\n        'Return the axis offsetText as a Text instance'\n        return self.offsetText\n\n    def get_pickradius(self):\n        'Return the depth of the axis used by the picker'\n        return self.pickradius\n\n    def get_majorticklabels(self):\n        'Return a list of Text instances for the major ticklabels.'\n        ticks = self.get_major_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text major ticklabel', labels1 + labels2)\n\n    def get_minorticklabels(self):\n        'Return a list of Text instances for the minor ticklabels.'\n        ticks = self.get_minor_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text minor ticklabel', labels1 + labels2)\n\n    def get_ticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides `minor`.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n        \"\"\"\n\n        if which is not None:\n            if which == 'minor':\n                return self.get_minorticklabels()\n            elif which == 'major':\n                return self.get_majorticklabels()\n            elif which == 'both':\n                return self.get_majorticklabels() + self.get_minorticklabels()\n            else:\n                cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        if minor:\n            return self.get_minorticklabels()\n        return self.get_majorticklabels()\n\n    def get_majorticklines(self):\n        'Return the major tick lines as a list of Line2D instances'\n        lines = []\n        ticks = self.get_major_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)\n\n    def get_minorticklines(self):\n        'Return the minor tick lines as a list of Line2D instances'\n        lines = []\n        ticks = self.get_minor_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)\n\n    def get_ticklines(self, minor=False):\n        'Return the tick lines as a list of Line2D instances'\n        if minor:\n            return self.get_minorticklines()\n        return self.get_majorticklines()\n\n    def get_majorticklocs(self):\n        \"\"\"Get the array of major tick locations in data coordinates.\"\"\"\n        return self.major.locator()\n\n    def get_minorticklocs(self):\n        \"\"\"Get the array of minor tick locations in data coordinates.\"\"\"\n        # Remove minor ticks duplicating major ticks.\n        major_locs = self.major.locator()\n        minor_locs = self.minor.locator()\n        transform = self._scale.get_transform()\n        tr_minor_locs = transform.transform(minor_locs)\n        tr_major_locs = transform.transform(major_locs)\n        lo, hi = sorted(transform.transform(self.get_view_interval()))\n        # Use the transformed view limits as scale.  1e-5 is the default rtol\n        # for np.isclose.\n        tol = (hi - lo) * 1e-5\n        if self.remove_overlapping_locs:\n            minor_locs = [\n                loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)\n                if ~np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]\n        return minor_locs\n\n    def get_ticklocs(self, minor=False):\n        \"\"\"Get the array of tick locations in data coordinates.\"\"\"\n        return self.get_minorticklocs() if minor else self.get_majorticklocs()\n\n    def get_ticks_direction(self, minor=False):\n        \"\"\"\n        Get the tick directions as a numpy array\n\n        Parameters\n        ----------\n        minor : boolean\n            True to return the minor tick directions,\n            False to return the major tick directions,\n            Default is False\n\n        Returns\n        -------\n        numpy array of tick directions\n        \"\"\"\n        if minor:\n            return np.array(\n                [tick._tickdir for tick in self.get_minor_ticks()])\n        else:\n            return np.array(\n                [tick._tickdir for tick in self.get_major_ticks()])\n\n    def _get_tick(self, major):\n        \"\"\"Return the default tick instance.\"\"\"\n        raise NotImplementedError('derived must override')\n\n    def _copy_tick_props(self, src, dest):\n        \"\"\"Copy the properties from *src* tick to *dest* tick.\"\"\"\n        if src is None or dest is None:\n            return\n        dest.label1.update_from(src.label1)\n        dest.label2.update_from(src.label2)\n        dest.tick1line.update_from(src.tick1line)\n        dest.tick2line.update_from(src.tick2line)\n        dest.gridline.update_from(src.gridline)\n\n    def get_label_text(self):\n        'Get the text of the label'\n        return self.label.get_text()\n\n    def get_major_locator(self):\n        'Get the locator of the major ticker'\n        return self.major.locator\n\n    def get_minor_locator(self):\n        'Get the locator of the minor ticker'\n        return self.minor.locator\n\n    def get_major_formatter(self):\n        'Get the formatter of the major ticker'\n        return self.major.formatter\n\n    def get_minor_formatter(self):\n        'Get the formatter of the minor ticker'\n        return self.minor.formatter\n\n    def get_major_ticks(self, numticks=None):\n        'Get the tick instances; grow as necessary.'\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMajor)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n\n    def get_minor_ticks(self, numticks=None):\n        'Get the minor tick instances; grow as necessary.'\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMinor)\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n\n    def grid(self, b=None, which='major', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        b : bool or None\n            Whether to show the grid lines. If any *kwargs* are supplied,\n            it is assumed you want the grid on and *b* will be set to True.\n\n            If *b* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}\n            The grid lines to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n\n        \"\"\"\n        if len(kwargs):\n            if not b and b is not None:  # something false-like but not None\n                cbook._warn_external('First parameter to grid() is false, '\n                                     'but line properties are supplied. The '\n                                     'grid will be enabled.')\n            b = True\n        which = which.lower()\n        cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        gridkw = {'grid_' + item[0]: item[1] for item in kwargs.items()}\n\n        if which in ['minor', 'both']:\n            if b is None:\n                self._gridOnMinor = not self._gridOnMinor\n            else:\n                self._gridOnMinor = b\n            self.set_tick_params(which='minor', gridOn=self._gridOnMinor,\n                                 **gridkw)\n        if which in ['major', 'both']:\n            if b is None:\n                self._gridOnMajor = not self._gridOnMajor\n            else:\n                self._gridOnMajor = b\n            self.set_tick_params(which='major', gridOn=self._gridOnMajor,\n                                 **gridkw)\n        self.stale = True\n\n    def update_units(self, data):\n        \"\"\"\n        Introspect *data* for units converter and update the\n        axis.converter instance if necessary. Return *True*\n        if *data* is registered for unit conversion.\n        \"\"\"\n        converter = munits.registry.get_converter(data)\n        if converter is None:\n            return False\n\n        neednew = self.converter != converter\n        self.converter = converter\n        default = self.converter.default_units(data, self)\n        if default is not None and self.units is None:\n            self.set_units(default)\n\n        if neednew:\n            self._update_axisinfo()\n        self.stale = True\n        return True\n\n    def _update_axisinfo(self):\n        \"\"\"\n        Check the axis converter for the stored units to see if the\n        axis info needs to be updated.\n        \"\"\"\n        if self.converter is None:\n            return\n\n        info = self.converter.axisinfo(self.units, self)\n\n        if info is None:\n            return\n        if info.majloc is not None and \\\n           self.major.locator != info.majloc and self.isDefault_majloc:\n            self.set_major_locator(info.majloc)\n            self.isDefault_majloc = True\n        if info.minloc is not None and \\\n           self.minor.locator != info.minloc and self.isDefault_minloc:\n            self.set_minor_locator(info.minloc)\n            self.isDefault_minloc = True\n        if info.majfmt is not None and \\\n           self.major.formatter != info.majfmt and self.isDefault_majfmt:\n            self.set_major_formatter(info.majfmt)\n            self.isDefault_majfmt = True\n        if info.minfmt is not None and \\\n           self.minor.formatter != info.minfmt and self.isDefault_minfmt:\n            self.set_minor_formatter(info.minfmt)\n            self.isDefault_minfmt = True\n        if info.label is not None and self.isDefault_label:\n            self.set_label_text(info.label)\n            self.isDefault_label = True\n\n        self.set_default_intervals()\n\n    def have_units(self):\n        return self.converter is not None or self.units is not None\n\n    def convert_units(self, x):\n        # If x is natively supported by Matplotlib, doesn't need converting\n        if munits._is_natively_supported(x):\n            return x\n\n        if self.converter is None:\n            self.converter = munits.registry.get_converter(x)\n\n        if self.converter is None:\n            return x\n        try:\n            ret = self.converter.convert(x, self.units, self)\n        except Exception as e:\n            raise munits.ConversionError('Failed to convert value(s) to axis '\n                                         f'units: {x!r}') from e\n        return ret\n\n    def set_units(self, u):\n        \"\"\"\n        Set the units for axis.\n\n        Parameters\n        ----------\n        u : units tag\n        \"\"\"\n        pchanged = False\n        if u is None:\n            self.units = None\n            pchanged = True\n        else:\n            if u != self.units:\n                self.units = u\n                pchanged = True\n        if pchanged:\n            self._update_axisinfo()\n            self.callbacks.process('units')\n            self.callbacks.process('units finalize')\n        self.stale = True\n\n    def get_units(self):\n        \"\"\"Return the units for axis.\"\"\"\n        return self.units\n\n    def set_label_text(self, label, fontdict=None, **kwargs):\n        \"\"\"\n        Set the text value of the axis label.\n\n        Parameters\n        ----------\n        label : str\n            Text string.\n        fontdict : dict\n            Text properties.\n        **kwargs\n            Merged into fontdict.\n        \"\"\"\n        self.isDefault_label = False\n        self.label.set_text(label)\n        if fontdict is not None:\n            self.label.update(fontdict)\n        self.label.update(kwargs)\n        self.stale = True\n        return self.label\n\n    def set_major_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the major ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        self.isDefault_majfmt = False\n        self.major.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True\n\n    def set_minor_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the minor ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        self.isDefault_minfmt = False\n        self.minor.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True\n\n    def set_major_locator(self, locator):\n        \"\"\"\n        Set the locator of the major ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        cbook._check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_majloc = False\n        self.major.locator = locator\n        if self.major.formatter:\n            self.major.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_minor_locator(self, locator):\n        \"\"\"\n        Set the locator of the minor ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        cbook._check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_minloc = False\n        self.minor.locator = locator\n        if self.minor.formatter:\n            self.minor.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_pickradius(self, pickradius):\n        \"\"\"\n        Set the depth of the axis used by the picker.\n\n        Parameters\n        ----------\n        pickradius :  float\n        \"\"\"\n        self.pickradius = pickradius\n\n    def set_ticklabels(self, ticklabels, *args, minor=False, **kwargs):\n        r\"\"\"\n        Set the text values of the tick labels.\n\n        Parameters\n        ----------\n        ticklabels : sequence of str or of `Text`\\s\n            List of texts for tick labels; must include values for non-visible\n            labels.\n        minor : bool\n            If True, set minor ticks instead of major ticks.\n        **kwargs\n            Text properties.\n\n        Returns\n        -------\n        labels : list of `Text`\\s\n            For each tick, includes ``tick.label1`` if it is visible, then\n            ``tick.label2`` if it is visible, in that order.\n        \"\"\"\n        if args:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Additional positional arguments to \"\n                \"set_ticklabels are ignored, and deprecated since Matplotlib \"\n                \"3.1; passing them will raise a TypeError in Matplotlib 3.3.\")\n        get_labels = []\n        for t in ticklabels:\n            # try calling get_text() to check whether it is Text object\n            # if it is Text, get label content\n            try:\n                get_labels.append(t.get_text())\n            # otherwise add the label to the list directly\n            except AttributeError:\n                get_labels.append(t)\n        # replace the ticklabels list with the processed one\n        ticklabels = get_labels\n\n        if minor:\n            self.set_minor_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_minor_ticks()\n        else:\n            self.set_major_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_major_ticks()\n        ret = []\n        for tick_label, tick in zip(ticklabels, ticks):\n            # deal with label1\n            tick.label1.set_text(tick_label)\n            tick.label1.update(kwargs)\n            # deal with label2\n            tick.label2.set_text(tick_label)\n            tick.label2.update(kwargs)\n            # only return visible tick labels\n            if tick.label1.get_visible():\n                ret.append(tick.label1)\n            if tick.label2.get_visible():\n                ret.append(tick.label2)\n\n        self.stale = True\n        return ret\n\n    def set_ticks(self, ticks, minor=False):\n        \"\"\"\n        Set the locations of the tick marks from sequence ticks\n\n        Parameters\n        ----------\n        ticks : sequence of floats\n        minor : bool\n        \"\"\"\n        # XXX if the user changes units, the information will be lost here\n        ticks = self.convert_units(ticks)\n        if len(ticks) > 1:\n            xleft, xright = self.get_view_interval()\n            if xright > xleft:\n                self.set_view_interval(min(ticks), max(ticks))\n            else:\n                self.set_view_interval(max(ticks), min(ticks))\n        if minor:\n            self.set_minor_locator(mticker.FixedLocator(ticks))\n            return self.get_minor_ticks(len(ticks))\n        else:\n            self.set_major_locator(mticker.FixedLocator(ticks))\n            return self.get_major_ticks(len(ticks))\n\n    def _get_tick_boxes_siblings(self, xdir, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the label position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def pan(self, numsteps):\n        'Pan *numsteps* (can be positive or negative)'\n        self.major.locator.pan(numsteps)\n\n    def zoom(self, direction):\n        \"Zoom in/out on axis; if *direction* is >0 zoom in, else zoom out\"\n        self.major.locator.zoom(direction)\n\n    def axis_date(self, tz=None):\n        \"\"\"\n        Sets up x-axis ticks and labels that treat the x data as dates.\n\n        Parameters\n        ----------\n        tz : tzinfo or str or None\n            The timezone used to create date labels.\n        \"\"\"\n        # By providing a sample datetime instance with the desired timezone,\n        # the registered converter can be selected, and the \"units\" attribute,\n        # which is the timezone, can be set.\n        if isinstance(tz, str):\n            import dateutil.tz\n            tz = dateutil.tz.gettz(tz)\n        self.update_units(datetime.datetime(2009, 1, 1, 0, 0, 0, 0, tz))\n\n    def get_tick_space(self):\n        \"\"\"\n        Return the estimated number of ticks that can fit on the axis.\n        \"\"\"\n        # Must be overridden in the subclass\n        raise NotImplementedError()\n\n    def _get_ticks_position(self):\n        \"\"\"\n        Helper for `XAxis.get_ticks_position` and `YAxis.get_ticks_position`.\n\n        Check the visibility of tick1line, label1, tick2line, and label2 on\n        the first major and the first minor ticks, and return\n\n        - 1 if only tick1line and label1 are visible (which corresponds to\n          \"bottom\" for the x-axis and \"left\" for the y-axis);\n        - 2 if only tick2line and label2 are visible (which corresponds to\n          \"top\" for the x-axis and \"right\" for the y-axis);\n        - \"default\" if only tick1line, tick2line and label1 are visible;\n        - \"unknown\" otherwise.\n        \"\"\"\n        major = self.majorTicks[0]\n        minor = self.minorTicks[0]\n        if all(tick.tick1line.get_visible()\n               and not tick.tick2line.get_visible()\n               and tick.label1.get_visible()\n               and not tick.label2.get_visible()\n               for tick in [major, minor]):\n            return 1\n        elif all(tick.tick2line.get_visible()\n                 and not tick.tick1line.get_visible()\n                 and tick.label2.get_visible()\n                 and not tick.label1.get_visible()\n                 for tick in [major, minor]):\n            return 2\n        elif all(tick.tick1line.get_visible()\n                 and tick.tick2line.get_visible()\n                 and tick.label1.get_visible()\n                 and not tick.label2.get_visible()\n                 for tick in [major, minor]):\n            return \"default\"\n        else:\n            return \"unknown\"\n\n    def get_label_position(self):\n        \"\"\"\n        Return the label position (top or bottom)\n        \"\"\"\n        return self.label_position\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_minpos(self):\n        raise NotImplementedError()\n\n\nclass XAxis(Axis):\n    __name__ = 'xaxis'\n    axis_name = 'x'\n\n    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occurred in the x axis.\n        \"\"\"\n        if self._contains is not None:\n            return self._contains(self, mouseevent)\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform_point((x, y))\n        except ValueError:\n            return False, {}\n        l, b = self.axes.transAxes.transform_point((0, 0))\n        r, t = self.axes.transAxes.transform_point((1, 1))\n        inaxis = 0 <= xaxes <= 1 and (\n            b - self.pickradius < y < b or\n            t < y < t + self.pickradius)\n        return inaxis, {}\n\n    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return XTick(self.axes, 0, '', major=major, **tick_kw)\n\n    def _get_label(self):\n        # x in axes coords, y in display coords (to be updated at draw\n        # time by _update_label_positions)\n        label = mtext.Text(x=0.5, y=0,\n                           fontproperties=font_manager.FontProperties(\n                               size=rcParams['axes.labelsize'],\n                               weight=rcParams['axes.labelweight']),\n                           color=rcParams['axes.labelcolor'],\n                           verticalalignment='top',\n                           horizontalalignment='center')\n\n        label.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform()))\n\n        self._set_artist_props(label)\n        self.label_position = 'bottom'\n        return label\n\n    def _get_offset_text(self):\n        # x in axes coords, y in display coords (to be updated at draw time)\n        offsetText = mtext.Text(x=1, y=0,\n                                fontproperties=font_manager.FontProperties(\n                                    size=rcParams['xtick.labelsize']),\n                                color=rcParams['xtick.color'],\n                                verticalalignment='top',\n                                horizontalalignment='right')\n        offsetText.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform())\n        )\n        self._set_artist_props(offsetText)\n        self.offset_text_position = 'bottom'\n        return offsetText\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        if position == 'top':\n            self.label.set_verticalalignment('baseline')\n        elif position == 'bottom':\n            self.label.set_verticalalignment('top')\n        else:\n            raise ValueError(\"Position accepts only 'top' or 'bottom'\")\n        self.label_position = position\n        self.stale = True\n\n    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of x-label groups for this figure\n        grp = self.figure._align_xlabel_grp\n        # if we want to align labels from other axes:\n        for nn, axx in enumerate(grp.get_siblings(self.axes)):\n            ticks_to_draw = axx.xaxis._update_ticks()\n            tlb, tlb2 = axx.xaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'bottom':\n            try:\n                spine = self.axes.spines['bottom']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            bottom = bbox.y0\n\n            self.label.set_position(\n                (x, bottom - self.labelpad * self.figure.dpi / 72)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['top']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            top = bbox.y1\n\n            self.label.set_position(\n                (x, top + self.labelpad * self.figure.dpi / 72)\n            )\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not len(bboxes):\n            bottom = self.axes.bbox.ymin\n        else:\n            bbox = mtransforms.Bbox.union(bboxes)\n            bottom = bbox.y0\n        self.offsetText.set_position(\n            (x, bottom - self.OFFSETTEXTPAD * self.figure.dpi / 72)\n        )\n\n    def get_text_heights(self, renderer):\n        \"\"\"\n        Returns the amount of space one should reserve for text\n        above and below the axes.  Returns a tuple (above, below)\n        \"\"\"\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        padPixels = self.majorTicks[0].get_pad_pixels()\n\n        above = 0.0\n        if bbox2.height:\n            above += bbox2.height + padPixels\n        below = 0.0\n        if bbox.height:\n            below += bbox.height + padPixels\n\n        if self.get_label_position() == 'top':\n            above += self.label.get_window_extent(renderer).height + padPixels\n        else:\n            below += self.label.get_window_extent(renderer).height + padPixels\n        return above, below\n\n    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (top, bottom, both, default or none)\n        both sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at bottom.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'top', 'bottom', 'both', 'default', 'none'}\n        \"\"\"\n        if position == 'top':\n            self.set_tick_params(which='both', top=True, labeltop=True,\n                                 bottom=False, labelbottom=False)\n        elif position == 'bottom':\n            self.set_tick_params(which='both', top=False, labeltop=False,\n                                 bottom=True, labelbottom=True)\n        elif position == 'both':\n            self.set_tick_params(which='both', top=True,\n                                 bottom=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', top=False,\n                                 bottom=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', top=True, labeltop=False,\n                                 bottom=True, labelbottom=True)\n        else:\n            raise ValueError(\"invalid position: %s\" % position)\n        self.stale = True\n\n    def tick_top(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the top of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('top')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labeltop=label)\n\n    def tick_bottom(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the bottom of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('bottom')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labelbottom=label)\n\n    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"bottom\", 2: \"top\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervalx\n\n    def set_view_interval(self, vmin, vmax, ignore=False):\n        # docstring inherited\n        if ignore:\n            self.axes.viewLim.intervalx = vmin, vmax\n        else:\n            Vmin, Vmax = self.get_view_interval()\n            if Vmin < Vmax:\n                self.axes.viewLim.intervalx = (min(vmin, vmax, Vmin),\n                                               max(vmin, vmax, Vmax))\n            else:\n                self.axes.viewLim.intervalx = (max(vmin, vmax, Vmin),\n                                               min(vmin, vmax, Vmax))\n\n    def get_minpos(self):\n        return self.axes.dataLim.minposx\n\n    def get_data_interval(self):\n        # docstring inherited\n        return self.axes.dataLim.intervalx\n\n    def set_data_interval(self, vmin, vmax, ignore=False):\n        # docstring inherited\n        if ignore:\n            self.axes.dataLim.intervalx = vmin, vmax\n        else:\n            Vmin, Vmax = self.get_data_interval()\n            self.axes.dataLim.intervalx = min(vmin, Vmin), max(vmax, Vmax)\n        self.stale = True\n\n    def set_default_intervals(self):\n        # docstring inherited\n        xmin, xmax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedx()\n        viewMutated = self.axes.viewLim.mutatedx()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    xmin = self.converter.convert(valmin, self.units, self)\n                    xmax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervalx = xmin, xmax\n            if not viewMutated:\n                self.axes.viewLim.intervalx = xmin, xmax\n        self.stale = True\n\n    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [1, 0]])\n        length = ((ends[1][0] - ends[0][0]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # There is a heuristic here that the aspect ratio of tick text\n        # is no more than 3:1\n        size = tick.label1.get_size() * 3\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1\n\n\nclass YAxis(Axis):\n    __name__ = 'yaxis'\n    axis_name = 'y'\n\n    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occurred in the y axis.\n\n        Returns *True* | *False*\n        \"\"\"\n        if self._contains is not None:\n            return self._contains(self, mouseevent)\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform_point((x, y))\n        except ValueError:\n            return False, {}\n        l, b = self.axes.transAxes.transform_point((0, 0))\n        r, t = self.axes.transAxes.transform_point((1, 1))\n        inaxis = 0 <= yaxes <= 1 and (\n            l - self.pickradius < x < l or\n            r < x < r + self.pickradius)\n        return inaxis, {}\n\n    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return YTick(self.axes, 0, '', major=major, **tick_kw)\n\n    def _get_label(self):\n        # x in display coords (updated by _update_label_position)\n        # y in axes coords\n        label = mtext.Text(x=0, y=0.5,\n                           # todo: get the label position\n                           fontproperties=font_manager.FontProperties(\n                               size=rcParams['axes.labelsize'],\n                               weight=rcParams['axes.labelweight']),\n                           color=rcParams['axes.labelcolor'],\n                           verticalalignment='bottom',\n                           horizontalalignment='center',\n                           rotation='vertical',\n                           rotation_mode='anchor')\n        label.set_transform(mtransforms.blended_transform_factory(\n            mtransforms.IdentityTransform(), self.axes.transAxes))\n\n        self._set_artist_props(label)\n        self.label_position = 'left'\n        return label\n\n    def _get_offset_text(self):\n        # x in display coords, y in axes coords (to be updated at draw time)\n        offsetText = mtext.Text(x=0, y=0.5,\n                                fontproperties=font_manager.FontProperties(\n                                    size=rcParams['ytick.labelsize']\n                                ),\n                                color=rcParams['ytick.color'],\n                                verticalalignment='baseline',\n                                horizontalalignment='left')\n        offsetText.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform())\n        )\n        self._set_artist_props(offsetText)\n        self.offset_text_position = 'left'\n        return offsetText\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (left or right)\n\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        self.label.set_rotation_mode('anchor')\n        self.label.set_horizontalalignment('center')\n        if position == 'left':\n            self.label.set_verticalalignment('bottom')\n        elif position == 'right':\n            self.label.set_verticalalignment('top')\n        else:\n            raise ValueError(\"Position accepts only 'left' or 'right'\")\n        self.label_position = position\n        self.stale = True\n\n    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of y-label groups for this figure\n        grp = self.figure._align_ylabel_grp\n        # if we want to align labels from other axes:\n        for axx in grp.get_siblings(self.axes):\n            ticks_to_draw = axx.yaxis._update_ticks()\n            tlb, tlb2 = axx.yaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'left':\n            try:\n                spine = self.axes.spines['left']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            left = bbox.x0\n            self.label.set_position(\n                (left - self.labelpad * self.figure.dpi / 72, y)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['right']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            right = bbox.x1\n\n            self.label.set_position(\n                (right + self.labelpad * self.figure.dpi / 72, y)\n            )\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        top = self.axes.bbox.ymax\n        self.offsetText.set_position(\n            (x, top + self.OFFSETTEXTPAD * self.figure.dpi / 72)\n        )\n\n    def set_offset_position(self, position):\n        \"\"\"\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if position == 'left':\n            x = 0\n        elif position == 'right':\n            x = 1\n        else:\n            raise ValueError(\"Position accepts only [ 'left' | 'right' ]\")\n\n        self.offsetText.set_ha(position)\n        self.offsetText.set_position((x, y))\n        self.stale = True\n\n    def get_text_widths(self, renderer):\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        padPixels = self.majorTicks[0].get_pad_pixels()\n\n        left = 0.0\n        if bbox.width:\n            left += bbox.width + padPixels\n        right = 0.0\n        if bbox2.width:\n            right += bbox2.width + padPixels\n\n        if self.get_label_position() == 'left':\n            left += self.label.get_window_extent(renderer).width + padPixels\n        else:\n            right += self.label.get_window_extent(renderer).width + padPixels\n        return left, right\n\n    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (left, right, both, default or none)\n        'both' sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at left.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'left', 'right', 'both', 'default', 'none'}\n        \"\"\"\n        if position == 'right':\n            self.set_tick_params(which='both', right=True, labelright=True,\n                                 left=False, labelleft=False)\n            self.set_offset_position(position)\n        elif position == 'left':\n            self.set_tick_params(which='both', right=False, labelright=False,\n                                 left=True, labelleft=True)\n            self.set_offset_position(position)\n        elif position == 'both':\n            self.set_tick_params(which='both', right=True,\n                                 left=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', right=False,\n                                 left=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', right=True, labelright=False,\n                                 left=True, labelleft=True)\n        else:\n            raise ValueError(\"invalid position: %s\" % position)\n        self.stale = True\n\n    def tick_right(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the right of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('right')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelright=label)\n\n    def tick_left(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the left of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('left')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelleft=label)\n\n    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"left\", \"right\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"left\", 2: \"right\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervaly\n\n    def set_view_interval(self, vmin, vmax, ignore=False):\n        # docstring inherited\n        if ignore:\n            self.axes.viewLim.intervaly = vmin, vmax\n        else:\n            Vmin, Vmax = self.get_view_interval()\n            if Vmin < Vmax:\n                self.axes.viewLim.intervaly = (min(vmin, vmax, Vmin),\n                                               max(vmin, vmax, Vmax))\n            else:\n                self.axes.viewLim.intervaly = (max(vmin, vmax, Vmin),\n                                               min(vmin, vmax, Vmax))\n        self.stale = True\n\n    def get_minpos(self):\n        return self.axes.dataLim.minposy\n\n    def get_data_interval(self):\n        # docstring inherited\n        return self.axes.dataLim.intervaly\n\n    def set_data_interval(self, vmin, vmax, ignore=False):\n        # docstring inherited\n        if ignore:\n            self.axes.dataLim.intervaly = vmin, vmax\n        else:\n            Vmin, Vmax = self.get_data_interval()\n            self.axes.dataLim.intervaly = min(vmin, Vmin), max(vmax, Vmax)\n        self.stale = True\n\n    def set_default_intervals(self):\n        # docstring inherited\n        ymin, ymax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedy()\n        viewMutated = self.axes.viewLim.mutatedy()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    ymin = self.converter.convert(valmin, self.units, self)\n                    ymax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervaly = ymin, ymax\n            if not viewMutated:\n                self.axes.viewLim.intervaly = ymin, ymax\n        self.stale = True\n\n    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [0, 1]])\n        length = ((ends[1][1] - ends[0][1]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # Having a spacing of at least 2 just looks good.\n        size = tick.label1.get_size() * 2.0\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1\n",
      "file_after": "\"\"\"\nClasses for the ticks and x and y axis.\n\"\"\"\n\nimport datetime\nimport logging\n\nimport numpy as np\n\nfrom matplotlib import rcParams\nimport matplotlib.artist as martist\nimport matplotlib.cbook as cbook\nimport matplotlib.font_manager as font_manager\nimport matplotlib.lines as mlines\nimport matplotlib.scale as mscale\nimport matplotlib.text as mtext\nimport matplotlib.ticker as mticker\nimport matplotlib.transforms as mtransforms\nimport matplotlib.units as munits\n\n_log = logging.getLogger(__name__)\n\nGRIDLINE_INTERPOLATION_STEPS = 180\n\n# This list is being used for compatibility with Axes.grid, which\n# allows all Line2D kwargs.\n_line_AI = martist.ArtistInspector(mlines.Line2D)\n_line_param_names = _line_AI.get_setters()\n_line_param_aliases = [list(d)[0] for d in _line_AI.aliasd.values()]\n_gridline_param_names = ['grid_' + name\n                         for name in _line_param_names + _line_param_aliases]\n\n\nclass Tick(martist.Artist):\n    \"\"\"\n    Abstract base class for the axis ticks, grid lines and labels.\n\n    Ticks mark a position on an Axis. They contain two lines as markers and\n    two labels; one each for the bottom and top positions (in case of an\n    `.XAxis`) or for the left and right positions (in case of a `.YAxis`).\n\n    Attributes\n    ----------\n    tick1line : `.Line2D`\n        The left/bottom tick marker.\n    tick2line : `.Line2D`\n        The right/top tick marker.\n    gridline : `.Line2D`\n        The grid line associated with the label position.\n    label1 : `.Text`\n        The left/bottom tick label.\n    label2 : `.Text`\n        The right/top tick label.\n\n    \"\"\"\n    def __init__(self, axes, loc, label,\n                 size=None,  # points\n                 width=None,\n                 color=None,\n                 tickdir=None,\n                 pad=None,\n                 labelsize=None,\n                 labelcolor=None,\n                 zorder=None,\n                 gridOn=None,  # defaults to axes.grid depending on\n                               # axes.grid.which\n                 tick1On=True,\n                 tick2On=True,\n                 label1On=True,\n                 label2On=False,\n                 major=True,\n                 labelrotation=0,\n                 grid_color=None,\n                 grid_linestyle=None,\n                 grid_linewidth=None,\n                 grid_alpha=None,\n                 **kw  # Other Line2D kwargs applied to gridlines.\n                 ):\n        \"\"\"\n        bbox is the Bound2D bounding box in display coords of the Axes\n        loc is the tick location in data coords\n        size is the tick size in points\n        \"\"\"\n        martist.Artist.__init__(self)\n\n        if gridOn is None:\n            if major and (rcParams['axes.grid.which'] in ('both', 'major')):\n                gridOn = rcParams['axes.grid']\n            elif (not major) and (rcParams['axes.grid.which']\n                                  in ('both', 'minor')):\n                gridOn = rcParams['axes.grid']\n            else:\n                gridOn = False\n\n        self.set_figure(axes.figure)\n        self.axes = axes\n\n        name = self.__name__.lower()\n        self._name = name\n\n        self._loc = loc\n\n        if size is None:\n            if major:\n                size = rcParams['%s.major.size' % name]\n            else:\n                size = rcParams['%s.minor.size' % name]\n        self._size = size\n\n        if width is None:\n            if major:\n                width = rcParams['%s.major.width' % name]\n            else:\n                width = rcParams['%s.minor.width' % name]\n        self._width = width\n\n        if color is None:\n            color = rcParams['%s.color' % name]\n        self._color = color\n\n        if pad is None:\n            if major:\n                pad = rcParams['%s.major.pad' % name]\n            else:\n                pad = rcParams['%s.minor.pad' % name]\n        self._base_pad = pad\n\n        if labelcolor is None:\n            labelcolor = rcParams['%s.color' % name]\n        self._labelcolor = labelcolor\n\n        if labelsize is None:\n            labelsize = rcParams['%s.labelsize' % name]\n        self._labelsize = labelsize\n\n        self._set_labelrotation(labelrotation)\n\n        if zorder is None:\n            if major:\n                zorder = mlines.Line2D.zorder + 0.01\n            else:\n                zorder = mlines.Line2D.zorder\n        self._zorder = zorder\n\n        self._grid_color = (rcParams['grid.color']\n                            if grid_color is None else grid_color)\n        self._grid_linestyle = (rcParams['grid.linestyle']\n                                if grid_linestyle is None else grid_linestyle)\n        self._grid_linewidth = (rcParams['grid.linewidth']\n                                if grid_linewidth is None else grid_linewidth)\n        self._grid_alpha = (rcParams['grid.alpha']\n                            if grid_alpha is None else grid_alpha)\n\n        self._grid_kw = {k[5:]: v for k, v in kw.items()}\n\n        self.apply_tickdir(tickdir)\n\n        self.tick1line = self._get_tick1line()\n        self.tick2line = self._get_tick2line()\n        self.gridline = self._get_gridline()\n        self.label1 = self._get_text1()\n        self.label2 = self._get_text2()\n\n        self.gridline.set_visible(gridOn)\n        self.tick1line.set_visible(tick1On)\n        self.tick2line.set_visible(tick2On)\n        self.label1.set_visible(label1On)\n        self.label2.set_visible(label2On)\n\n        self.update_position(loc)\n\n    for _old_name, _new_name in [\n            (\"gridOn\", \"gridline\"),\n            (\"tick1On\", \"tick1line\"),\n            (\"tick2On\", \"tick2line\"),\n            (\"label1On\", \"label1\"),\n            (\"label2On\", \"label2\")]:\n        locals()[_old_name] = property(\n            cbook.deprecated(\n                \"3.1\",\n                name=_old_name,\n                alternative=\"Tick.{}.get_visible\".format(_new_name))(\n                    lambda self, _new_name=_new_name:\n                        getattr(self, _new_name).get_visible()),\n            cbook.deprecated(\n                \"3.1\",\n                name=_old_name,\n                alternative=\"Tick.{}.set_visible\".format(_new_name))(\n                    lambda self, value, _new_name=_new_name:\n                        getattr(self, _new_name).set_visible(value)))\n    del _old_name, _new_name\n\n    @property\n    @cbook.deprecated(\"3.1\", alternative=\"Tick.label1\", pending=True)\n    def label(self):\n        return self.label1\n\n    def _set_labelrotation(self, labelrotation):\n        if isinstance(labelrotation, str):\n            mode = labelrotation\n            angle = 0\n        elif isinstance(labelrotation, (tuple, list)):\n            mode, angle = labelrotation\n        else:\n            mode = 'default'\n            angle = labelrotation\n        cbook._check_in_list(['auto', 'default'], labelrotation=mode)\n        self._labelrotation = (mode, angle)\n\n    def apply_tickdir(self, tickdir):\n        \"\"\"Calculate self._pad and self._tickmarkers.\"\"\"\n\n    def get_tickdir(self):\n        return self._tickdir\n\n    def get_tick_padding(self):\n        \"\"\"Get the length of the tick outside of the axes.\"\"\"\n        padding = {\n            'in': 0.0,\n            'inout': 0.5,\n            'out': 1.0\n        }\n        return self._size * padding[self._tickdir]\n\n    def get_children(self):\n        children = [self.tick1line, self.tick2line,\n                    self.gridline, self.label1, self.label2]\n        return children\n\n    def set_clip_path(self, clippath, transform=None):\n        # docstring inherited\n        martist.Artist.set_clip_path(self, clippath, transform)\n        self.gridline.set_clip_path(clippath, transform)\n        self.stale = True\n\n    def get_pad_pixels(self):\n        return self.figure.dpi * self._base_pad / 72\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occurred in the Tick marks.\n\n        This function always returns false.  It is more useful to test if the\n        axis as a whole contains the mouse rather than the set of tick marks.\n        \"\"\"\n        if self._contains is not None:\n            return self._contains(self, mouseevent)\n        return False, {}\n\n    def set_pad(self, val):\n        \"\"\"\n        Set the tick label pad in points\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        self._apply_params(pad=val)\n        self.stale = True\n\n    def get_pad(self):\n        'Get the value of the tick label pad in points'\n        return self._base_pad\n\n    def _get_text1(self):\n        'Get the default Text 1 instance'\n        pass\n\n    def _get_text2(self):\n        'Get the default Text 2 instance'\n        pass\n\n    def _get_tick1line(self):\n        'Get the default line2D instance for tick1'\n        pass\n\n    def _get_tick2line(self):\n        'Get the default line2D instance for tick2'\n        pass\n\n    def _get_gridline(self):\n        'Get the default grid Line2d instance for this tick'\n        pass\n\n    def get_loc(self):\n        'Return the tick location (data coords) as a scalar'\n        return self._loc\n\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        if not self.get_visible():\n            self.stale = False\n            return\n        renderer.open_group(self.__name__)\n        for artist in [self.gridline, self.tick1line, self.tick2line,\n                       self.label1, self.label2]:\n            artist.draw(renderer)\n        renderer.close_group(self.__name__)\n        self.stale = False\n\n    def set_label1(self, s):\n        \"\"\"\n        Set the label1 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label1.set_text(s)\n        self.stale = True\n\n    set_label = set_label1\n\n    def set_label2(self, s):\n        \"\"\"\n        Set the label2 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label2.set_text(s)\n        self.stale = True\n\n    def _set_artist_props(self, a):\n        a.set_figure(self.figure)\n\n    def get_view_interval(self):\n        \"\"\"\n        Return the view limits ``(min, max)`` of the axis the tick belongs to.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _apply_params(self, **kw):\n        for name, target in [(\"gridOn\", self.gridline),\n                               (\"tick1On\", self.tick1line),\n                               (\"tick2On\", self.tick2line),\n                               (\"label1On\", self.label1),\n                               (\"label2On\", self.label2)]:\n            if name in kw:\n                target.set_visible(kw.pop(name))\n        if any(k in kw for k in ['size', 'width', 'pad', 'tickdir']):\n            self._size = kw.pop('size', self._size)\n            # Width could be handled outside this block, but it is\n            # convenient to leave it here.\n            self._width = kw.pop('width', self._width)\n            self._base_pad = kw.pop('pad', self._base_pad)\n            # apply_tickdir uses _size and _base_pad to make _pad,\n            # and also makes _tickmarkers.\n            self.apply_tickdir(kw.pop('tickdir', self._tickdir))\n            self.tick1line.set_marker(self._tickmarkers[0])\n            self.tick2line.set_marker(self._tickmarkers[1])\n            for line in (self.tick1line, self.tick2line):\n                line.set_markersize(self._size)\n                line.set_markeredgewidth(self._width)\n            # _get_text1_transform uses _pad from apply_tickdir.\n            trans = self._get_text1_transform()[0]\n            self.label1.set_transform(trans)\n            trans = self._get_text2_transform()[0]\n            self.label2.set_transform(trans)\n        tick_kw = {k: v for k, v in kw.items() if k in ['color', 'zorder']}\n        self.tick1line.set(**tick_kw)\n        self.tick2line.set(**tick_kw)\n        for k, v in tick_kw.items():\n            setattr(self, '_' + k, v)\n\n        if 'labelrotation' in kw:\n            self._set_labelrotation(kw.pop('labelrotation'))\n            self.label1.set(rotation=self._labelrotation[1])\n            self.label2.set(rotation=self._labelrotation[1])\n\n        label_kw = {k[5:]: v for k, v in kw.items()\n                    if k in ['labelsize', 'labelcolor']}\n        self.label1.set(**label_kw)\n        self.label2.set(**label_kw)\n        for k, v in label_kw.items():\n            # for labelsize the text objects covert str ('small')\n            # -> points. grab the integer from the `Text` object\n            # instead of saving the string representation\n            v = getattr(self.label1, 'get_' + k)()\n            setattr(self, '_label' + k, v)\n\n        grid_kw = {k[5:]: v for k, v in kw.items()\n                   if k in _gridline_param_names}\n        self.gridline.set(**grid_kw)\n        for k, v in grid_kw.items():\n            setattr(self, '_grid_' + k, v)\n\n    def update_position(self, loc):\n        'Set the location of tick in data coords with scalar *loc*'\n        raise NotImplementedError('Derived must override')\n\n    def _get_text1_transform(self):\n        raise NotImplementedError('Derived must override')\n\n    def _get_text2_transform(self):\n        raise NotImplementedError('Derived must override')\n\n\nclass XTick(Tick):\n    \"\"\"\n    Contains all the Artists needed to make an x tick - the tick line,\n    the label text and the grid line\n    \"\"\"\n    __name__ = 'xtick'\n\n    def _get_text1_transform(self):\n        return self.axes.get_xaxis_text1_transform(self._pad)\n\n    def _get_text2_transform(self):\n        return self.axes.get_xaxis_text2_transform(self._pad)\n\n    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = rcParams['%s.direction' % self._name]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKUP, mlines.TICKDOWN)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('|', '|')\n        else:\n            self._tickmarkers = (mlines.TICKDOWN, mlines.TICKUP)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True\n\n    def _get_text1(self):\n        'Get the default Text instance'\n        # the y loc is 3 points below the min of y axis\n        # get the affine as an a,b,c,d,tx,ty list\n        # x in data coords, y in axes coords\n        trans, vert, horiz = self._get_text1_transform()\n        t = mtext.Text(\n            x=0, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_text2(self):\n        'Get the default Text 2 instance'\n        # x in data coords, y in axes coords\n        trans, vert, horiz = self._get_text2_transform()\n        t = mtext.Text(\n            x=0, y=1,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_tick1line(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0,), ydata=(0,), color=self._color,\n                          linestyle='None', marker=self._tickmarkers[0],\n                          markersize=self._size,\n                          markeredgewidth=self._width, zorder=self._zorder)\n        l.set_transform(self.axes.get_xaxis_transform(which='tick1'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_tick2line(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0,), ydata=(1,),\n                          color=self._color,\n                          linestyle='None',\n                          marker=self._tickmarkers[1],\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n\n        l.set_transform(self.axes.get_xaxis_transform(which='tick2'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_gridline(self):\n        'Get the default line2D instance'\n        # x in data coords, y in axes coords\n        l = mlines.Line2D(xdata=(0.0, 0.0), ydata=(0, 1.0),\n                          color=self._grid_color,\n                          linestyle=self._grid_linestyle,\n                          linewidth=self._grid_linewidth,\n                          alpha=self._grid_alpha,\n                          markersize=0,\n                          **self._grid_kw)\n        l.set_transform(self.axes.get_xaxis_transform(which='grid'))\n        l.get_path()._interpolation_steps = GRIDLINE_INTERPOLATION_STEPS\n        self._set_artist_props(l)\n\n        return l\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_xdata((loc,))\n        self.tick2line.set_xdata((loc,))\n        self.gridline.set_xdata((loc,))\n        self.label1.set_x(loc)\n        self.label2.set_x(loc)\n        self._loc = loc\n        self.stale = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervalx\n\n\nclass YTick(Tick):\n    \"\"\"\n    Contains all the Artists needed to make a Y tick - the tick line,\n    the label text and the grid line\n    \"\"\"\n    __name__ = 'ytick'\n\n    def _get_text1_transform(self):\n        return self.axes.get_yaxis_text1_transform(self._pad)\n\n    def _get_text2_transform(self):\n        return self.axes.get_yaxis_text2_transform(self._pad)\n\n    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = rcParams['%s.direction' % self._name]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKRIGHT, mlines.TICKLEFT)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('_', '_')\n        else:\n            self._tickmarkers = (mlines.TICKLEFT, mlines.TICKRIGHT)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True\n\n    # how far from the y axis line the right of the ticklabel are\n    def _get_text1(self):\n        'Get the default Text instance'\n        # x in axes coords, y in data coords\n        trans, vert, horiz = self._get_text1_transform()\n        t = mtext.Text(\n            x=0, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_text2(self):\n        'Get the default Text instance'\n        # x in axes coords, y in data coords\n        trans, vert, horiz = self._get_text2_transform()\n        t = mtext.Text(\n            x=1, y=0,\n            fontproperties=font_manager.FontProperties(size=self._labelsize),\n            color=self._labelcolor,\n            verticalalignment=vert,\n            horizontalalignment=horiz,\n            )\n        t.set_transform(trans)\n        self._set_artist_props(t)\n        return t\n\n    def _get_tick1line(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n\n        l = mlines.Line2D((0,), (0,),\n                          color=self._color,\n                          marker=self._tickmarkers[0],\n                          linestyle='None',\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n        l.set_transform(self.axes.get_yaxis_transform(which='tick1'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_tick2line(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n        l = mlines.Line2D((1,), (0,),\n                          color=self._color,\n                          marker=self._tickmarkers[1],\n                          linestyle='None',\n                          markersize=self._size,\n                          markeredgewidth=self._width,\n                          zorder=self._zorder)\n        l.set_transform(self.axes.get_yaxis_transform(which='tick2'))\n        self._set_artist_props(l)\n        return l\n\n    def _get_gridline(self):\n        'Get the default line2D instance'\n        # x in axes coords, y in data coords\n        l = mlines.Line2D(xdata=(0, 1), ydata=(0, 0),\n                          color=self._grid_color,\n                          linestyle=self._grid_linestyle,\n                          linewidth=self._grid_linewidth,\n                          alpha=self._grid_alpha,\n                          markersize=0,\n                          **self._grid_kw)\n        l.set_transform(self.axes.get_yaxis_transform(which='grid'))\n        l.get_path()._interpolation_steps = GRIDLINE_INTERPOLATION_STEPS\n        self._set_artist_props(l)\n        return l\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_ydata((loc,))\n        self.tick2line.set_ydata((loc,))\n        self.gridline.set_ydata((loc,))\n        self.label1.set_y(loc)\n        self.label2.set_y(loc)\n        self._loc = loc\n        self.stale = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervaly\n\n\nclass Ticker:\n    \"\"\"\n    A container for the objects defining tick position and format.\n\n    Attributes\n    ----------\n    locator : `matplotlib.ticker.Locator` subclass\n        Determines the positions of the ticks.\n    formatter : `matplotlib.ticker.Formatter` subclass\n        Determines the format of the tick labels.\n    \"\"\"\n\n    def __init__(self):\n        self._locator = None\n        self._formatter = None\n\n    @property\n    def locator(self):\n        return self._locator\n\n    @locator.setter\n    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            cbook.warn_deprecated(\n                \"3.2\", message=\"Support for locators that do not subclass \"\n                \"matplotlib.ticker.Locator is deprecated since %(since)s and \"\n                \"support for them will be removed %(removal)s.\")\n        self._locator = locator\n\n    @property\n    def formatter(self):\n        return self._formatter\n\n    @formatter.setter\n    def formatter(self, formatter):\n        if not isinstance(formatter, mticker.Formatter):\n            cbook.warn_deprecated(\n                \"3.2\", message=\"Support for formatters that do not subclass \"\n                \"matplotlib.ticker.Formatter is deprecated since %(since)s \"\n                \"and support for them will be removed %(removal)s.\")\n        self._formatter = formatter\n\n\nclass _LazyTickList:\n    \"\"\"\n    A descriptor for lazy instantiation of tick lists.\n\n    See comment above definition of the ``majorTicks`` and ``minorTicks``\n    attributes.\n    \"\"\"\n\n    def __init__(self, major):\n        self._major = major\n\n    def __get__(self, instance, cls):\n        if instance is None:\n            return self\n        else:\n            # instance._get_tick() can itself try to access the majorTicks\n            # attribute (e.g. in certain projection classes which override\n            # e.g. get_xaxis_text1_transform).  In order to avoid infinite\n            # recursion, first set the majorTicks on the instance to an empty\n            # list, then create the tick and append it.\n            if self._major:\n                instance.majorTicks = []\n                tick = instance._get_tick(major=True)\n                instance.majorTicks.append(tick)\n                return instance.majorTicks\n            else:\n                instance.minorTicks = []\n                tick = instance._get_tick(major=False)\n                instance.minorTicks.append(tick)\n                return instance.minorTicks\n\n\nclass Axis(martist.Artist):\n    \"\"\"\n    Base class for `.XAxis` and `.YAxis`.\n\n    Attributes\n    ----------\n    isDefault_label : bool\n\n    axes : `matplotlib.axes.Axes`\n        The `~.axes.Axes` to which the Axis belongs.\n    major : `matplotlib.axis.Ticker`\n        Determines the major tick positions and their label format.\n    minor : `matplotlib.axis.Ticker`\n        Determines the minor tick positions and their label format.\n    callbacks : `matplotlib.cbook.CallbackRegistry`\n\n    label : `.Text`\n        The axis label.\n    labelpad : float\n        The distance between the axis label and the tick labels.\n        Defaults to :rc:`axes.labelpad` = 4.\n    offsetText : `.Text`\n        A `.Text` object containing the data offset of the ticks (if any).\n    pickradius : float\n        The acceptance radius for containment tests. See also `.Axis.contains`.\n    majorTicks : list of `.Tick`\n        The major ticks.\n    minorTicks : list of `.Tick`\n        The minor ticks.\n    \"\"\"\n    OFFSETTEXTPAD = 3\n\n    def __str__(self):\n        return self.__class__.__name__ \\\n            + \"(%f,%f)\" % tuple(self.axes.transAxes.transform_point((0, 0)))\n\n    def __init__(self, axes, pickradius=15):\n        \"\"\"\n        Parameters\n        ----------\n        axes : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to which the created Axis belongs.\n        pickradius : float\n            The acceptance radius for containment tests. See also\n            `.Axis.contains`.\n        \"\"\"\n        martist.Artist.__init__(self)\n        self._remove_overlapping_locs = True\n\n        self.set_figure(axes.figure)\n\n        self.isDefault_label = True\n\n        self.axes = axes\n        self.major = Ticker()\n        self.minor = Ticker()\n        self.callbacks = cbook.CallbackRegistry()\n\n        self._autolabelpos = True\n        self._smart_bounds = False\n\n        self.label = self._get_label()\n        self.labelpad = rcParams['axes.labelpad']\n        self.offsetText = self._get_offset_text()\n\n        self.pickradius = pickradius\n\n        # Initialize here for testing; later add API\n        self._major_tick_kw = dict()\n        self._minor_tick_kw = dict()\n\n        self.cla()\n        self._set_scale('linear')\n\n    # During initialization, Axis objects often create ticks that are later\n    # unused; this turns out to be a very slow step.  Instead, use a custom\n    # descriptor to make the tick lists lazy and instantiate them as needed.\n    majorTicks = _LazyTickList(major=True)\n    minorTicks = _LazyTickList(major=False)\n\n    def get_remove_overlapping_locs(self):\n        return self._remove_overlapping_locs\n\n    def set_remove_overlapping_locs(self, val):\n        self._remove_overlapping_locs = bool(val)\n\n    remove_overlapping_locs = property(\n        get_remove_overlapping_locs, set_remove_overlapping_locs,\n        doc=('If minor ticker locations that overlap with major '\n             'ticker locations should be trimmed.'))\n\n    def set_label_coords(self, x, y, transform=None):\n        \"\"\"\n        Set the coordinates of the label.\n\n        By default, the x coordinate of the y label is determined by the tick\n        label bounding boxes, but this can lead to poor alignment of multiple\n        ylabels if there are multiple axes.  Ditto for the y coordinate of\n        the x label.\n\n        You can also specify the coordinate system of the label with\n        the transform.  If None, the default coordinate system will be\n        the axes coordinate system (0,0) is (left,bottom), (0.5, 0.5)\n        is middle, etc\n        \"\"\"\n        self._autolabelpos = False\n        if transform is None:\n            transform = self.axes.transAxes\n\n        self.label.set_transform(transform)\n        self.label.set_position((x, y))\n        self.stale = True\n\n    def get_transform(self):\n        return self._scale.get_transform()\n\n    def get_scale(self):\n        return self._scale.name\n\n    def _set_scale(self, value, **kwargs):\n        self._scale = mscale.scale_factory(value, self, **kwargs)\n        self._scale.set_default_locators_and_formatters(self)\n\n        self.isDefault_majloc = True\n        self.isDefault_minloc = True\n        self.isDefault_majfmt = True\n        self.isDefault_minfmt = True\n\n    def limit_range_for_scale(self, vmin, vmax):\n        return self._scale.limit_range_for_scale(vmin, vmax, self.get_minpos())\n\n    def get_children(self):\n        return [self.label, self.offsetText,\n                *self.get_major_ticks(), *self.get_minor_ticks()]\n\n    def cla(self):\n        \"\"\"Clear this axis.\"\"\"\n\n        self.label.set_text('')  # self.set_label_text would change isDefault_\n\n        self._set_scale('linear')\n\n        # Clear the callback registry for this axis, or it may \"leak\"\n        self.callbacks = cbook.CallbackRegistry()\n\n        # whether the grids are on\n        self._gridOnMajor = (rcParams['axes.grid'] and\n                             rcParams['axes.grid.which'] in ('both', 'major'))\n        self._gridOnMinor = (rcParams['axes.grid'] and\n                             rcParams['axes.grid.which'] in ('both', 'minor'))\n\n        self.reset_ticks()\n\n        self.converter = None\n        self.units = None\n        self.set_units(None)\n        self.stale = True\n\n    def reset_ticks(self):\n        \"\"\"\n        Re-initialize the major and minor Tick lists.\n\n        Each list starts with a single fresh Tick.\n        \"\"\"\n        # Restore the lazy tick lists.\n        try:\n            del self.majorTicks\n        except AttributeError:\n            pass\n        try:\n            del self.minorTicks\n        except AttributeError:\n            pass\n        try:\n            self.set_clip_path(self.axes.patch)\n        except AttributeError:\n            pass\n\n    def set_tick_params(self, which='major', reset=False, **kw):\n        \"\"\"\n        Set appearance parameters for ticks, ticklabels, and gridlines.\n\n        For documentation of keyword arguments, see\n        :meth:`matplotlib.axes.Axes.tick_params`.\n        \"\"\"\n        dicts = []\n        if which == 'major' or which == 'both':\n            dicts.append(self._major_tick_kw)\n        if which == 'minor' or which == 'both':\n            dicts.append(self._minor_tick_kw)\n        kwtrans = self._translate_tick_kw(kw)\n\n        # this stashes the parameter changes so any new ticks will\n        # automatically get them\n        for d in dicts:\n            if reset:\n                d.clear()\n            d.update(kwtrans)\n\n        if reset:\n            self.reset_ticks()\n        else:\n            # apply the new kwargs to the existing ticks\n            if which == 'major' or which == 'both':\n                for tick in self.majorTicks:\n                    tick._apply_params(**kwtrans)\n            if which == 'minor' or which == 'both':\n                for tick in self.minorTicks:\n                    tick._apply_params(**kwtrans)\n            # special-case label color to also apply to the offset\n            # text\n            if 'labelcolor' in kwtrans:\n                self.offsetText.set_color(kwtrans['labelcolor'])\n\n        self.stale = True\n\n    @staticmethod\n    def _translate_tick_kw(kw):\n        # The following lists may be moved to a more accessible location.\n        kwkeys = ['size', 'width', 'color', 'tickdir', 'pad',\n                  'labelsize', 'labelcolor', 'zorder', 'gridOn',\n                  'tick1On', 'tick2On', 'label1On', 'label2On',\n                  'length', 'direction', 'left', 'bottom', 'right', 'top',\n                  'labelleft', 'labelbottom', 'labelright', 'labeltop',\n                  'labelrotation'] + _gridline_param_names\n        kwtrans = {}\n        if 'length' in kw:\n            kwtrans['size'] = kw.pop('length')\n        if 'direction' in kw:\n            kwtrans['tickdir'] = kw.pop('direction')\n        if 'rotation' in kw:\n            kwtrans['labelrotation'] = kw.pop('rotation')\n        if 'left' in kw:\n            kwtrans['tick1On'] = kw.pop('left')\n        if 'bottom' in kw:\n            kwtrans['tick1On'] = kw.pop('bottom')\n        if 'right' in kw:\n            kwtrans['tick2On'] = kw.pop('right')\n        if 'top' in kw:\n            kwtrans['tick2On'] = kw.pop('top')\n        if 'labelleft' in kw:\n            kwtrans['label1On'] = kw.pop('labelleft')\n        if 'labelbottom' in kw:\n            kwtrans['label1On'] = kw.pop('labelbottom')\n        if 'labelright' in kw:\n            kwtrans['label2On'] = kw.pop('labelright')\n        if 'labeltop' in kw:\n            kwtrans['label2On'] = kw.pop('labeltop')\n        if 'colors' in kw:\n            c = kw.pop('colors')\n            kwtrans['color'] = c\n            kwtrans['labelcolor'] = c\n        # Maybe move the checking up to the caller of this method.\n        for key in kw:\n            if key not in kwkeys:\n                raise ValueError(\n                    \"keyword %s is not recognized; valid keywords are %s\"\n                    % (key, kwkeys))\n            kwtrans.update(kw)\n        return kwtrans\n\n    def set_clip_path(self, clippath, transform=None):\n        martist.Artist.set_clip_path(self, clippath, transform)\n        for child in self.majorTicks + self.minorTicks:\n            child.set_clip_path(clippath, transform)\n        self.stale = True\n\n    def get_view_interval(self):\n        \"\"\"Return the view limits ``(min, max)`` of this axis.\"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def set_view_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis view limits.  This method is for internal use; Matplotlib\n        users should typically use e.g. `~Axes.set_xlim` and `~Axes.set_ylim`.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting view limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the view limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def get_data_interval(self):\n        \"\"\"Return the Interval instance for this axis data limits.\"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def set_data_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis data limits.  This method is for internal use.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting data limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the data limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def get_inverted(self):\n        \"\"\"\n        Return whether the axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        low, high = self.get_view_interval()\n        return high < low\n\n    def set_inverted(self, inverted):\n        \"\"\"\n        Set whether the axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        a, b = self.get_view_interval()\n        if inverted:\n            self.set_view_interval(max(a, b), min(a, b), ignore=True)\n        else:\n            self.set_view_interval(min(a, b), max(a, b), ignore=True)\n\n    def set_default_intervals(self):\n        \"\"\"\n        Set the default limits for the axis data and view interval if they\n        have not been not mutated yet.\n        \"\"\"\n        # this is mainly in support of custom object plotting.  For\n        # example, if someone passes in a datetime object, we do not\n        # know automagically how to set the default min/max of the\n        # data and view limits.  The unit conversion AxisInfo\n        # interface provides a hook for custom types to register\n        # default limits through the AxisInfo.default_limits\n        # attribute, and the derived code below will check for that\n        # and use it if is available (else just use 0..1)\n\n    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.figure)\n\n    @cbook.deprecated(\"3.1\")\n    def iter_ticks(self):\n        \"\"\"\n        Yield ``(Tick, location, label)`` tuples for major and minor ticks.\n        \"\"\"\n        major_locs = self.get_majorticklocs()\n        major_labels = self.major.formatter.format_ticks(major_locs)\n        major_ticks = self.get_major_ticks(len(major_locs))\n        yield from zip(major_ticks, major_locs, major_labels)\n        minor_locs = self.get_minorticklocs()\n        minor_labels = self.minor.formatter.format_ticks(minor_locs)\n        minor_ticks = self.get_minor_ticks(len(minor_locs))\n        yield from zip(minor_ticks, minor_locs, minor_labels)\n\n    def get_ticklabel_extents(self, renderer):\n        \"\"\"\n        Get the extents of the tick labels on either side\n        of the axes.\n        \"\"\"\n\n        ticks_to_draw = self._update_ticks()\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(ticks_to_draw,\n                                                                renderer)\n\n        if len(ticklabelBoxes):\n            bbox = mtransforms.Bbox.union(ticklabelBoxes)\n        else:\n            bbox = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        if len(ticklabelBoxes2):\n            bbox2 = mtransforms.Bbox.union(ticklabelBoxes2)\n        else:\n            bbox2 = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        return bbox, bbox2\n\n    def set_smart_bounds(self, value):\n        \"\"\"Set the axis to have smart bounds.\"\"\"\n        self._smart_bounds = value\n        self.stale = True\n\n    def get_smart_bounds(self):\n        \"\"\"Return whether the axis has smart bounds.\"\"\"\n        return self._smart_bounds\n\n    def _update_ticks(self):\n        \"\"\"\n        Update ticks (position and labels) using the current data interval of\n        the axes.  Return the list of ticks that will be drawn.\n        \"\"\"\n        major_locs = self.get_majorticklocs()\n        major_labels = self.major.formatter.format_ticks(major_locs)\n        major_ticks = self.get_major_ticks(len(major_locs))\n        self.major.formatter.set_locs(major_locs)\n        for tick, loc, label in zip(major_ticks, major_locs, major_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        minor_locs = self.get_minorticklocs()\n        minor_labels = self.minor.formatter.format_ticks(minor_locs)\n        minor_ticks = self.get_minor_ticks(len(minor_locs))\n        self.minor.formatter.set_locs(minor_locs)\n        for tick, loc, label in zip(minor_ticks, minor_locs, minor_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        ticks = [*major_ticks, *minor_ticks]\n\n        view_low, view_high = self.get_view_interval()\n        if view_low > view_high:\n            view_low, view_high = view_high, view_low\n\n        if self._smart_bounds and ticks:\n            # handle inverted limits\n            data_low, data_high = sorted(self.get_data_interval())\n            locs = np.sort([tick.get_loc() for tick in ticks])\n            if data_low <= view_low:\n                # data extends beyond view, take view as limit\n                ilow = view_low\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs <= data_low]\n                if len(good_locs):\n                    # last tick prior or equal to first data point\n                    ilow = good_locs[-1]\n                else:\n                    # No ticks (why not?), take first tick\n                    ilow = locs[0]\n            if data_high >= view_high:\n                # data extends beyond view, take view as limit\n                ihigh = view_high\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs >= data_high]\n                if len(good_locs):\n                    # first tick after or equal to last data point\n                    ihigh = good_locs[0]\n                else:\n                    # No ticks (why not?), take last tick\n                    ihigh = locs[-1]\n            ticks = [tick for tick in ticks if ilow <= tick.get_loc() <= ihigh]\n\n        interval_t = self.get_transform().transform([view_low, view_high])\n\n        ticks_to_draw = []\n        for tick in ticks:\n            try:\n                loc_t = self.get_transform().transform(tick.get_loc())\n            except AssertionError:\n                # transforms.transform doesn't allow masked values but\n                # some scales might make them, so we need this try/except.\n                pass\n            else:\n                if mtransforms._interval_contains_close(interval_t, loc_t):\n                    ticks_to_draw.append(tick)\n\n        return ticks_to_draw\n\n    def _get_tick_bboxes(self, ticks, renderer):\n        \"\"\"Return lists of bboxes for ticks' label1's and label2's.\"\"\"\n        return ([tick.label1.get_window_extent(renderer)\n                 for tick in ticks if tick.label1.get_visible()],\n                [tick.label2.get_window_extent(renderer)\n                 for tick in ticks if tick.label2.get_visible()])\n\n    def get_tightbbox(self, renderer):\n        \"\"\"\n        Return a bounding box that encloses the axis. It only accounts\n        tick labels, axis label, and offsetText.\n        \"\"\"\n        if not self.get_visible():\n            return\n\n        ticks_to_draw = self._update_ticks()\n\n        self._update_label_position(renderer)\n\n        # go back to just this axis's tick labels\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(\n                    ticks_to_draw, renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n\n        bboxes = [\n            *(a.get_window_extent(renderer)\n              for a in [self.label, self.offsetText]\n              if a.get_visible()),\n            *ticklabelBoxes,\n            *ticklabelBoxes2,\n        ]\n        bboxes = [b for b in bboxes\n                  if 0 < b.width < np.inf and 0 < b.height < np.inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None\n\n    def get_tick_padding(self):\n        values = []\n        if len(self.majorTicks):\n            values.append(self.majorTicks[0].get_tick_padding())\n        if len(self.minorTicks):\n            values.append(self.minorTicks[0].get_tick_padding())\n        return max(values, default=0)\n\n    @martist.allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        'Draw the axis lines, grid lines, tick lines and labels'\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__)\n\n        ticks_to_draw = self._update_ticks()\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(ticks_to_draw,\n                                                                renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # scale up the axis label box to also find the neighbors, not\n        # just the tick labels that actually overlap note we need a\n        # *copy* of the axis label box because we don't wan't to scale\n        # the actual bbox\n\n        self._update_label_position(renderer)\n\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.draw(renderer)\n\n        renderer.close_group(__name__)\n        self.stale = False\n\n    def _get_label(self):\n        raise NotImplementedError('Derived must override')\n\n    def _get_offset_text(self):\n        raise NotImplementedError('Derived must override')\n\n    def get_gridlines(self):\n        'Return the grid lines as a list of Line2D instance'\n        ticks = self.get_major_ticks()\n        return cbook.silent_list('Line2D gridline',\n                                 [tick.gridline for tick in ticks])\n\n    def get_label(self):\n        'Return the axis label as a Text instance'\n        return self.label\n\n    def get_offset_text(self):\n        'Return the axis offsetText as a Text instance'\n        return self.offsetText\n\n    def get_pickradius(self):\n        'Return the depth of the axis used by the picker'\n        return self.pickradius\n\n    def get_majorticklabels(self):\n        'Return a list of Text instances for the major ticklabels.'\n        ticks = self.get_major_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text major ticklabel', labels1 + labels2)\n\n    def get_minorticklabels(self):\n        'Return a list of Text instances for the minor ticklabels.'\n        ticks = self.get_minor_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text minor ticklabel', labels1 + labels2)\n\n    def get_ticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides `minor`.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n        \"\"\"\n\n        if which is not None:\n            if which == 'minor':\n                return self.get_minorticklabels()\n            elif which == 'major':\n                return self.get_majorticklabels()\n            elif which == 'both':\n                return self.get_majorticklabels() + self.get_minorticklabels()\n            else:\n                cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        if minor:\n            return self.get_minorticklabels()\n        return self.get_majorticklabels()\n\n    def get_majorticklines(self):\n        'Return the major tick lines as a list of Line2D instances'\n        lines = []\n        ticks = self.get_major_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)\n\n    def get_minorticklines(self):\n        'Return the minor tick lines as a list of Line2D instances'\n        lines = []\n        ticks = self.get_minor_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)\n\n    def get_ticklines(self, minor=False):\n        'Return the tick lines as a list of Line2D instances'\n        if minor:\n            return self.get_minorticklines()\n        return self.get_majorticklines()\n\n    def get_majorticklocs(self):\n        \"\"\"Get the array of major tick locations in data coordinates.\"\"\"\n        return self.major.locator()\n\n    def get_minorticklocs(self):\n        \"\"\"Get the array of minor tick locations in data coordinates.\"\"\"\n        # Remove minor ticks duplicating major ticks.\n        major_locs = self.major.locator()\n        minor_locs = self.minor.locator()\n        transform = self._scale.get_transform()\n        tr_minor_locs = transform.transform(minor_locs)\n        tr_major_locs = transform.transform(major_locs)\n        lo, hi = sorted(transform.transform(self.get_view_interval()))\n        # Use the transformed view limits as scale.  1e-5 is the default rtol\n        # for np.isclose.\n        tol = (hi - lo) * 1e-5\n        if self.remove_overlapping_locs:\n            minor_locs = [\n                loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)\n                if ~np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]\n        return minor_locs\n\n    def get_ticklocs(self, minor=False):\n        \"\"\"Get the array of tick locations in data coordinates.\"\"\"\n        return self.get_minorticklocs() if minor else self.get_majorticklocs()\n\n    def get_ticks_direction(self, minor=False):\n        \"\"\"\n        Get the tick directions as a numpy array\n\n        Parameters\n        ----------\n        minor : boolean\n            True to return the minor tick directions,\n            False to return the major tick directions,\n            Default is False\n\n        Returns\n        -------\n        numpy array of tick directions\n        \"\"\"\n        if minor:\n            return np.array(\n                [tick._tickdir for tick in self.get_minor_ticks()])\n        else:\n            return np.array(\n                [tick._tickdir for tick in self.get_major_ticks()])\n\n    def _get_tick(self, major):\n        \"\"\"Return the default tick instance.\"\"\"\n        raise NotImplementedError('derived must override')\n\n    def _copy_tick_props(self, src, dest):\n        \"\"\"Copy the properties from *src* tick to *dest* tick.\"\"\"\n        if src is None or dest is None:\n            return\n        dest.label1.update_from(src.label1)\n        dest.label2.update_from(src.label2)\n        dest.tick1line.update_from(src.tick1line)\n        dest.tick2line.update_from(src.tick2line)\n        dest.gridline.update_from(src.gridline)\n\n    def get_label_text(self):\n        'Get the text of the label'\n        return self.label.get_text()\n\n    def get_major_locator(self):\n        'Get the locator of the major ticker'\n        return self.major.locator\n\n    def get_minor_locator(self):\n        'Get the locator of the minor ticker'\n        return self.minor.locator\n\n    def get_major_formatter(self):\n        'Get the formatter of the major ticker'\n        return self.major.formatter\n\n    def get_minor_formatter(self):\n        'Get the formatter of the minor ticker'\n        return self.minor.formatter\n\n    def get_major_ticks(self, numticks=None):\n        'Get the tick instances; grow as necessary.'\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMajor)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n\n    def get_minor_ticks(self, numticks=None):\n        'Get the minor tick instances; grow as necessary.'\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMinor)\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n\n    def grid(self, b=None, which='major', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        b : bool or None\n            Whether to show the grid lines. If any *kwargs* are supplied,\n            it is assumed you want the grid on and *b* will be set to True.\n\n            If *b* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}\n            The grid lines to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n\n        \"\"\"\n        if len(kwargs):\n            if not b and b is not None:  # something false-like but not None\n                cbook._warn_external('First parameter to grid() is false, '\n                                     'but line properties are supplied. The '\n                                     'grid will be enabled.')\n            b = True\n        which = which.lower()\n        cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        gridkw = {'grid_' + item[0]: item[1] for item in kwargs.items()}\n\n        if which in ['minor', 'both']:\n            if b is None:\n                self._gridOnMinor = not self._gridOnMinor\n            else:\n                self._gridOnMinor = b\n            self.set_tick_params(which='minor', gridOn=self._gridOnMinor,\n                                 **gridkw)\n        if which in ['major', 'both']:\n            if b is None:\n                self._gridOnMajor = not self._gridOnMajor\n            else:\n                self._gridOnMajor = b\n            self.set_tick_params(which='major', gridOn=self._gridOnMajor,\n                                 **gridkw)\n        self.stale = True\n\n    def update_units(self, data):\n        \"\"\"\n        Introspect *data* for units converter and update the\n        axis.converter instance if necessary. Return *True*\n        if *data* is registered for unit conversion.\n        \"\"\"\n        converter = munits.registry.get_converter(data)\n        if converter is None:\n            return False\n\n        neednew = self.converter != converter\n        self.converter = converter\n        default = self.converter.default_units(data, self)\n        if default is not None and self.units is None:\n            self.set_units(default)\n\n        if neednew:\n            self._update_axisinfo()\n        self.stale = True\n        return True\n\n    def _update_axisinfo(self):\n        \"\"\"\n        Check the axis converter for the stored units to see if the\n        axis info needs to be updated.\n        \"\"\"\n        if self.converter is None:\n            return\n\n        info = self.converter.axisinfo(self.units, self)\n\n        if info is None:\n            return\n        if info.majloc is not None and \\\n           self.major.locator != info.majloc and self.isDefault_majloc:\n            self.set_major_locator(info.majloc)\n            self.isDefault_majloc = True\n        if info.minloc is not None and \\\n           self.minor.locator != info.minloc and self.isDefault_minloc:\n            self.set_minor_locator(info.minloc)\n            self.isDefault_minloc = True\n        if info.majfmt is not None and \\\n           self.major.formatter != info.majfmt and self.isDefault_majfmt:\n            self.set_major_formatter(info.majfmt)\n            self.isDefault_majfmt = True\n        if info.minfmt is not None and \\\n           self.minor.formatter != info.minfmt and self.isDefault_minfmt:\n            self.set_minor_formatter(info.minfmt)\n            self.isDefault_minfmt = True\n        if info.label is not None and self.isDefault_label:\n            self.set_label_text(info.label)\n            self.isDefault_label = True\n\n        self.set_default_intervals()\n\n    def have_units(self):\n        return self.converter is not None or self.units is not None\n\n    def convert_units(self, x):\n        # If x is natively supported by Matplotlib, doesn't need converting\n        if munits._is_natively_supported(x):\n            return x\n\n        if self.converter is None:\n            self.converter = munits.registry.get_converter(x)\n\n        if self.converter is None:\n            return x\n        try:\n            ret = self.converter.convert(x, self.units, self)\n        except Exception as e:\n            raise munits.ConversionError('Failed to convert value(s) to axis '\n                                         f'units: {x!r}') from e\n        return ret\n\n    def set_units(self, u):\n        \"\"\"\n        Set the units for axis.\n\n        Parameters\n        ----------\n        u : units tag\n        \"\"\"\n        pchanged = False\n        if u is None:\n            self.units = None\n            pchanged = True\n        else:\n            if u != self.units:\n                self.units = u\n                pchanged = True\n        if pchanged:\n            self._update_axisinfo()\n            self.callbacks.process('units')\n            self.callbacks.process('units finalize')\n        self.stale = True\n\n    def get_units(self):\n        \"\"\"Return the units for axis.\"\"\"\n        return self.units\n\n    def set_label_text(self, label, fontdict=None, **kwargs):\n        \"\"\"\n        Set the text value of the axis label.\n\n        Parameters\n        ----------\n        label : str\n            Text string.\n        fontdict : dict\n            Text properties.\n        **kwargs\n            Merged into fontdict.\n        \"\"\"\n        self.isDefault_label = False\n        self.label.set_text(label)\n        if fontdict is not None:\n            self.label.update(fontdict)\n        self.label.update(kwargs)\n        self.stale = True\n        return self.label\n\n    def set_major_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the major ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        self.isDefault_majfmt = False\n        self.major.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True\n\n    def set_minor_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the minor ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        self.isDefault_minfmt = False\n        self.minor.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True\n\n    def set_major_locator(self, locator):\n        \"\"\"\n        Set the locator of the major ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        cbook._check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_majloc = False\n        self.major.locator = locator\n        if self.major.formatter:\n            self.major.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_minor_locator(self, locator):\n        \"\"\"\n        Set the locator of the minor ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        cbook._check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_minloc = False\n        self.minor.locator = locator\n        if self.minor.formatter:\n            self.minor.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_pickradius(self, pickradius):\n        \"\"\"\n        Set the depth of the axis used by the picker.\n\n        Parameters\n        ----------\n        pickradius :  float\n        \"\"\"\n        self.pickradius = pickradius\n\n    def set_ticklabels(self, ticklabels, *args, minor=False, **kwargs):\n        r\"\"\"\n        Set the text values of the tick labels.\n\n        Parameters\n        ----------\n        ticklabels : sequence of str or of `Text`\\s\n            List of texts for tick labels; must include values for non-visible\n            labels.\n        minor : bool\n            If True, set minor ticks instead of major ticks.\n        **kwargs\n            Text properties.\n\n        Returns\n        -------\n        labels : list of `Text`\\s\n            For each tick, includes ``tick.label1`` if it is visible, then\n            ``tick.label2`` if it is visible, in that order.\n        \"\"\"\n        if args:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Additional positional arguments to \"\n                \"set_ticklabels are ignored, and deprecated since Matplotlib \"\n                \"3.1; passing them will raise a TypeError in Matplotlib 3.3.\")\n        get_labels = []\n        for t in ticklabels:\n            # try calling get_text() to check whether it is Text object\n            # if it is Text, get label content\n            try:\n                get_labels.append(t.get_text())\n            # otherwise add the label to the list directly\n            except AttributeError:\n                get_labels.append(t)\n        # replace the ticklabels list with the processed one\n        ticklabels = get_labels\n\n        if minor:\n            self.set_minor_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_minor_ticks()\n        else:\n            self.set_major_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_major_ticks()\n        ret = []\n        for tick_label, tick in zip(ticklabels, ticks):\n            # deal with label1\n            tick.label1.set_text(tick_label)\n            tick.label1.update(kwargs)\n            # deal with label2\n            tick.label2.set_text(tick_label)\n            tick.label2.update(kwargs)\n            # only return visible tick labels\n            if tick.label1.get_visible():\n                ret.append(tick.label1)\n            if tick.label2.get_visible():\n                ret.append(tick.label2)\n\n        self.stale = True\n        return ret\n\n    def set_ticks(self, ticks, minor=False):\n        \"\"\"\n        Set the locations of the tick marks from sequence ticks\n\n        Parameters\n        ----------\n        ticks : sequence of floats\n        minor : bool\n        \"\"\"\n        # XXX if the user changes units, the information will be lost here\n        ticks = self.convert_units(ticks)\n        if len(ticks) > 1:\n            xleft, xright = self.get_view_interval()\n            if xright > xleft:\n                self.set_view_interval(min(ticks), max(ticks))\n            else:\n                self.set_view_interval(max(ticks), min(ticks))\n        if minor:\n            self.set_minor_locator(mticker.FixedLocator(ticks))\n            return self.get_minor_ticks(len(ticks))\n        else:\n            self.set_major_locator(mticker.FixedLocator(ticks))\n            return self.get_major_ticks(len(ticks))\n\n    def _get_tick_boxes_siblings(self, xdir, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the label position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def pan(self, numsteps):\n        'Pan *numsteps* (can be positive or negative)'\n        self.major.locator.pan(numsteps)\n\n    def zoom(self, direction):\n        \"Zoom in/out on axis; if *direction* is >0 zoom in, else zoom out\"\n        self.major.locator.zoom(direction)\n\n    def axis_date(self, tz=None):\n        \"\"\"\n        Sets up x-axis ticks and labels that treat the x data as dates.\n\n        Parameters\n        ----------\n        tz : tzinfo or str or None\n            The timezone used to create date labels.\n        \"\"\"\n        # By providing a sample datetime instance with the desired timezone,\n        # the registered converter can be selected, and the \"units\" attribute,\n        # which is the timezone, can be set.\n        if isinstance(tz, str):\n            import dateutil.tz\n            tz = dateutil.tz.gettz(tz)\n        self.update_units(datetime.datetime(2009, 1, 1, 0, 0, 0, 0, tz))\n\n    def get_tick_space(self):\n        \"\"\"\n        Return the estimated number of ticks that can fit on the axis.\n        \"\"\"\n        # Must be overridden in the subclass\n        raise NotImplementedError()\n\n    def _get_ticks_position(self):\n        \"\"\"\n        Helper for `XAxis.get_ticks_position` and `YAxis.get_ticks_position`.\n\n        Check the visibility of tick1line, label1, tick2line, and label2 on\n        the first major and the first minor ticks, and return\n\n        - 1 if only tick1line and label1 are visible (which corresponds to\n          \"bottom\" for the x-axis and \"left\" for the y-axis);\n        - 2 if only tick2line and label2 are visible (which corresponds to\n          \"top\" for the x-axis and \"right\" for the y-axis);\n        - \"default\" if only tick1line, tick2line and label1 are visible;\n        - \"unknown\" otherwise.\n        \"\"\"\n        major = self.majorTicks[0]\n        minor = self.minorTicks[0]\n        if all(tick.tick1line.get_visible()\n               and not tick.tick2line.get_visible()\n               and tick.label1.get_visible()\n               and not tick.label2.get_visible()\n               for tick in [major, minor]):\n            return 1\n        elif all(tick.tick2line.get_visible()\n                 and not tick.tick1line.get_visible()\n                 and tick.label2.get_visible()\n                 and not tick.label1.get_visible()\n                 for tick in [major, minor]):\n            return 2\n        elif all(tick.tick1line.get_visible()\n                 and tick.tick2line.get_visible()\n                 and tick.label1.get_visible()\n                 and not tick.label2.get_visible()\n                 for tick in [major, minor]):\n            return \"default\"\n        else:\n            return \"unknown\"\n\n    def get_label_position(self):\n        \"\"\"\n        Return the label position (top or bottom)\n        \"\"\"\n        return self.label_position\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_minpos(self):\n        raise NotImplementedError()\n\n\ndef _make_getset_interval(method_name, lim_name, attr_name):\n    \"\"\"\n    Helper to generate ``get_{data,view}_interval`` and\n    ``set_{data,view}_interval`` implementations.\n    \"\"\"\n\n    def getter(self):\n        # docstring inherited.\n        return getattr(getattr(self.axes, lim_name), attr_name)\n\n    def setter(self, vmin, vmax, ignore=False):\n        # docstring inherited.\n        if ignore:\n            setattr(getattr(self.axes, lim_name), attr_name, (vmin, vmax))\n        else:\n            oldmin, oldmax = getter(self)\n            if oldmin < oldmax:\n                setter(self, min(vmin, vmax, oldmin), max(vmin, vmax, oldmax),\n                       ignore=True)\n            else:\n                setter(self, max(vmin, vmax, oldmax), min(vmin, vmax, oldmin),\n                       ignore=True)\n        self.stale = True\n\n    getter.__name__ = f\"get_{method_name}_interval\"\n    setter.__name__ = f\"set_{method_name}_interval\"\n\n    return getter, setter\n\n\nclass XAxis(Axis):\n    __name__ = 'xaxis'\n    axis_name = 'x'\n\n    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occurred in the x axis.\n        \"\"\"\n        if self._contains is not None:\n            return self._contains(self, mouseevent)\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform_point((x, y))\n        except ValueError:\n            return False, {}\n        l, b = self.axes.transAxes.transform_point((0, 0))\n        r, t = self.axes.transAxes.transform_point((1, 1))\n        inaxis = 0 <= xaxes <= 1 and (\n            b - self.pickradius < y < b or\n            t < y < t + self.pickradius)\n        return inaxis, {}\n\n    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return XTick(self.axes, 0, '', major=major, **tick_kw)\n\n    def _get_label(self):\n        # x in axes coords, y in display coords (to be updated at draw\n        # time by _update_label_positions)\n        label = mtext.Text(x=0.5, y=0,\n                           fontproperties=font_manager.FontProperties(\n                               size=rcParams['axes.labelsize'],\n                               weight=rcParams['axes.labelweight']),\n                           color=rcParams['axes.labelcolor'],\n                           verticalalignment='top',\n                           horizontalalignment='center')\n\n        label.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform()))\n\n        self._set_artist_props(label)\n        self.label_position = 'bottom'\n        return label\n\n    def _get_offset_text(self):\n        # x in axes coords, y in display coords (to be updated at draw time)\n        offsetText = mtext.Text(x=1, y=0,\n                                fontproperties=font_manager.FontProperties(\n                                    size=rcParams['xtick.labelsize']),\n                                color=rcParams['xtick.color'],\n                                verticalalignment='top',\n                                horizontalalignment='right')\n        offsetText.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform())\n        )\n        self._set_artist_props(offsetText)\n        self.offset_text_position = 'bottom'\n        return offsetText\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        if position == 'top':\n            self.label.set_verticalalignment('baseline')\n        elif position == 'bottom':\n            self.label.set_verticalalignment('top')\n        else:\n            raise ValueError(\"Position accepts only 'top' or 'bottom'\")\n        self.label_position = position\n        self.stale = True\n\n    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of x-label groups for this figure\n        grp = self.figure._align_xlabel_grp\n        # if we want to align labels from other axes:\n        for nn, axx in enumerate(grp.get_siblings(self.axes)):\n            ticks_to_draw = axx.xaxis._update_ticks()\n            tlb, tlb2 = axx.xaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'bottom':\n            try:\n                spine = self.axes.spines['bottom']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            bottom = bbox.y0\n\n            self.label.set_position(\n                (x, bottom - self.labelpad * self.figure.dpi / 72)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['top']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            top = bbox.y1\n\n            self.label.set_position(\n                (x, top + self.labelpad * self.figure.dpi / 72)\n            )\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not len(bboxes):\n            bottom = self.axes.bbox.ymin\n        else:\n            bbox = mtransforms.Bbox.union(bboxes)\n            bottom = bbox.y0\n        self.offsetText.set_position(\n            (x, bottom - self.OFFSETTEXTPAD * self.figure.dpi / 72)\n        )\n\n    def get_text_heights(self, renderer):\n        \"\"\"\n        Returns the amount of space one should reserve for text\n        above and below the axes.  Returns a tuple (above, below)\n        \"\"\"\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        padPixels = self.majorTicks[0].get_pad_pixels()\n\n        above = 0.0\n        if bbox2.height:\n            above += bbox2.height + padPixels\n        below = 0.0\n        if bbox.height:\n            below += bbox.height + padPixels\n\n        if self.get_label_position() == 'top':\n            above += self.label.get_window_extent(renderer).height + padPixels\n        else:\n            below += self.label.get_window_extent(renderer).height + padPixels\n        return above, below\n\n    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (top, bottom, both, default or none)\n        both sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at bottom.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'top', 'bottom', 'both', 'default', 'none'}\n        \"\"\"\n        if position == 'top':\n            self.set_tick_params(which='both', top=True, labeltop=True,\n                                 bottom=False, labelbottom=False)\n        elif position == 'bottom':\n            self.set_tick_params(which='both', top=False, labeltop=False,\n                                 bottom=True, labelbottom=True)\n        elif position == 'both':\n            self.set_tick_params(which='both', top=True,\n                                 bottom=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', top=False,\n                                 bottom=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', top=True, labeltop=False,\n                                 bottom=True, labelbottom=True)\n        else:\n            raise ValueError(\"invalid position: %s\" % position)\n        self.stale = True\n\n    def tick_top(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the top of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('top')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labeltop=label)\n\n    def tick_bottom(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the bottom of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('bottom')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labelbottom=label)\n\n    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"bottom\", 2: \"top\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]\n\n    get_view_interval, set_view_interval = _make_getset_interval(\n        \"view\", \"viewLim\", \"intervalx\")\n    get_data_interval, set_data_interval = _make_getset_interval(\n        \"data\", \"dataLim\", \"intervalx\")\n\n    def get_minpos(self):\n        return self.axes.dataLim.minposx\n\n    def set_default_intervals(self):\n        # docstring inherited\n        xmin, xmax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedx()\n        viewMutated = self.axes.viewLim.mutatedx()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    xmin = self.converter.convert(valmin, self.units, self)\n                    xmax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervalx = xmin, xmax\n            if not viewMutated:\n                self.axes.viewLim.intervalx = xmin, xmax\n        self.stale = True\n\n    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [1, 0]])\n        length = ((ends[1][0] - ends[0][0]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # There is a heuristic here that the aspect ratio of tick text\n        # is no more than 3:1\n        size = tick.label1.get_size() * 3\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1\n\n\nclass YAxis(Axis):\n    __name__ = 'yaxis'\n    axis_name = 'y'\n\n    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occurred in the y axis.\n\n        Returns *True* | *False*\n        \"\"\"\n        if self._contains is not None:\n            return self._contains(self, mouseevent)\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform_point((x, y))\n        except ValueError:\n            return False, {}\n        l, b = self.axes.transAxes.transform_point((0, 0))\n        r, t = self.axes.transAxes.transform_point((1, 1))\n        inaxis = 0 <= yaxes <= 1 and (\n            l - self.pickradius < x < l or\n            r < x < r + self.pickradius)\n        return inaxis, {}\n\n    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return YTick(self.axes, 0, '', major=major, **tick_kw)\n\n    def _get_label(self):\n        # x in display coords (updated by _update_label_position)\n        # y in axes coords\n        label = mtext.Text(x=0, y=0.5,\n                           # todo: get the label position\n                           fontproperties=font_manager.FontProperties(\n                               size=rcParams['axes.labelsize'],\n                               weight=rcParams['axes.labelweight']),\n                           color=rcParams['axes.labelcolor'],\n                           verticalalignment='bottom',\n                           horizontalalignment='center',\n                           rotation='vertical',\n                           rotation_mode='anchor')\n        label.set_transform(mtransforms.blended_transform_factory(\n            mtransforms.IdentityTransform(), self.axes.transAxes))\n\n        self._set_artist_props(label)\n        self.label_position = 'left'\n        return label\n\n    def _get_offset_text(self):\n        # x in display coords, y in axes coords (to be updated at draw time)\n        offsetText = mtext.Text(x=0, y=0.5,\n                                fontproperties=font_manager.FontProperties(\n                                    size=rcParams['ytick.labelsize']\n                                ),\n                                color=rcParams['ytick.color'],\n                                verticalalignment='baseline',\n                                horizontalalignment='left')\n        offsetText.set_transform(mtransforms.blended_transform_factory(\n            self.axes.transAxes, mtransforms.IdentityTransform())\n        )\n        self._set_artist_props(offsetText)\n        self.offset_text_position = 'left'\n        return offsetText\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (left or right)\n\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        self.label.set_rotation_mode('anchor')\n        self.label.set_horizontalalignment('center')\n        if position == 'left':\n            self.label.set_verticalalignment('bottom')\n        elif position == 'right':\n            self.label.set_verticalalignment('top')\n        else:\n            raise ValueError(\"Position accepts only 'left' or 'right'\")\n        self.label_position = position\n        self.stale = True\n\n    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of y-label groups for this figure\n        grp = self.figure._align_ylabel_grp\n        # if we want to align labels from other axes:\n        for axx in grp.get_siblings(self.axes):\n            ticks_to_draw = axx.yaxis._update_ticks()\n            tlb, tlb2 = axx.yaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'left':\n            try:\n                spine = self.axes.spines['left']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            left = bbox.x0\n            self.label.set_position(\n                (left - self.labelpad * self.figure.dpi / 72, y)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['right']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            right = bbox.x1\n\n            self.label.set_position(\n                (right + self.labelpad * self.figure.dpi / 72, y)\n            )\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        top = self.axes.bbox.ymax\n        self.offsetText.set_position(\n            (x, top + self.OFFSETTEXTPAD * self.figure.dpi / 72)\n        )\n\n    def set_offset_position(self, position):\n        \"\"\"\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if position == 'left':\n            x = 0\n        elif position == 'right':\n            x = 1\n        else:\n            raise ValueError(\"Position accepts only [ 'left' | 'right' ]\")\n\n        self.offsetText.set_ha(position)\n        self.offsetText.set_position((x, y))\n        self.stale = True\n\n    def get_text_widths(self, renderer):\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        padPixels = self.majorTicks[0].get_pad_pixels()\n\n        left = 0.0\n        if bbox.width:\n            left += bbox.width + padPixels\n        right = 0.0\n        if bbox2.width:\n            right += bbox2.width + padPixels\n\n        if self.get_label_position() == 'left':\n            left += self.label.get_window_extent(renderer).width + padPixels\n        else:\n            right += self.label.get_window_extent(renderer).width + padPixels\n        return left, right\n\n    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (left, right, both, default or none)\n        'both' sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at left.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'left', 'right', 'both', 'default', 'none'}\n        \"\"\"\n        if position == 'right':\n            self.set_tick_params(which='both', right=True, labelright=True,\n                                 left=False, labelleft=False)\n            self.set_offset_position(position)\n        elif position == 'left':\n            self.set_tick_params(which='both', right=False, labelright=False,\n                                 left=True, labelleft=True)\n            self.set_offset_position(position)\n        elif position == 'both':\n            self.set_tick_params(which='both', right=True,\n                                 left=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', right=False,\n                                 left=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', right=True, labelright=False,\n                                 left=True, labelleft=True)\n        else:\n            raise ValueError(\"invalid position: %s\" % position)\n        self.stale = True\n\n    def tick_right(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the right of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('right')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelright=label)\n\n    def tick_left(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the left of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('left')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelleft=label)\n\n    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"left\", \"right\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"left\", 2: \"right\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]\n\n    get_view_interval, set_view_interval = _make_getset_interval(\n        \"view\", \"viewLim\", \"intervaly\")\n    get_data_interval, set_data_interval = _make_getset_interval(\n        \"data\", \"dataLim\", \"intervaly\")\n\n    def get_minpos(self):\n        return self.axes.dataLim.minposy\n\n    def set_default_intervals(self):\n        # docstring inherited\n        ymin, ymax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedy()\n        viewMutated = self.axes.viewLim.mutatedy()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    ymin = self.converter.convert(valmin, self.units, self)\n                    ymax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervaly = ymin, ymax\n            if not viewMutated:\n                self.axes.viewLim.intervaly = ymin, ymax\n        self.stale = True\n\n    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [0, 1]])\n        length = ((ends[1][1] - ends[0][1]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # Having a spacing of at least 2 just looks good.\n        size = tick.label1.get_size() * 2.0\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1\n",
      "file_patch": "@@ -1890,6 +1890,36 @@ class Axis(martist.Artist):\n         raise NotImplementedError()\n \n \n+def _make_getset_interval(method_name, lim_name, attr_name):\n+    \"\"\"\n+    Helper to generate ``get_{data,view}_interval`` and\n+    ``set_{data,view}_interval`` implementations.\n+    \"\"\"\n+\n+    def getter(self):\n+        # docstring inherited.\n+        return getattr(getattr(self.axes, lim_name), attr_name)\n+\n+    def setter(self, vmin, vmax, ignore=False):\n+        # docstring inherited.\n+        if ignore:\n+            setattr(getattr(self.axes, lim_name), attr_name, (vmin, vmax))\n+        else:\n+            oldmin, oldmax = getter(self)\n+            if oldmin < oldmax:\n+                setter(self, min(vmin, vmax, oldmin), max(vmin, vmax, oldmax),\n+                       ignore=True)\n+            else:\n+                setter(self, max(vmin, vmax, oldmax), min(vmin, vmax, oldmin),\n+                       ignore=True)\n+        self.stale = True\n+\n+    getter.__name__ = f\"get_{method_name}_interval\"\n+    setter.__name__ = f\"set_{method_name}_interval\"\n+\n+    return getter, setter\n+\n+\n class XAxis(Axis):\n     __name__ = 'xaxis'\n     axis_name = 'x'\n@@ -2133,39 +2163,14 @@ class XAxis(Axis):\n                 \"default\": \"default\", \"unknown\": \"unknown\"}[\n                     self._get_ticks_position()]\n \n-    def get_view_interval(self):\n-        # docstring inherited\n-        return self.axes.viewLim.intervalx\n-\n-    def set_view_interval(self, vmin, vmax, ignore=False):\n-        # docstring inherited\n-        if ignore:\n-            self.axes.viewLim.intervalx = vmin, vmax\n-        else:\n-            Vmin, Vmax = self.get_view_interval()\n-            if Vmin < Vmax:\n-                self.axes.viewLim.intervalx = (min(vmin, vmax, Vmin),\n-                                               max(vmin, vmax, Vmax))\n-            else:\n-                self.axes.viewLim.intervalx = (max(vmin, vmax, Vmin),\n-                                               min(vmin, vmax, Vmax))\n+    get_view_interval, set_view_interval = _make_getset_interval(\n+        \"view\", \"viewLim\", \"intervalx\")\n+    get_data_interval, set_data_interval = _make_getset_interval(\n+        \"data\", \"dataLim\", \"intervalx\")\n \n     def get_minpos(self):\n         return self.axes.dataLim.minposx\n \n-    def get_data_interval(self):\n-        # docstring inherited\n-        return self.axes.dataLim.intervalx\n-\n-    def set_data_interval(self, vmin, vmax, ignore=False):\n-        # docstring inherited\n-        if ignore:\n-            self.axes.dataLim.intervalx = vmin, vmax\n-        else:\n-            Vmin, Vmax = self.get_data_interval()\n-            self.axes.dataLim.intervalx = min(vmin, Vmin), max(vmax, Vmax)\n-        self.stale = True\n-\n     def set_default_intervals(self):\n         # docstring inherited\n         xmin, xmax = 0., 1.\n@@ -2460,40 +2465,14 @@ class YAxis(Axis):\n                 \"default\": \"default\", \"unknown\": \"unknown\"}[\n                     self._get_ticks_position()]\n \n-    def get_view_interval(self):\n-        # docstring inherited\n-        return self.axes.viewLim.intervaly\n-\n-    def set_view_interval(self, vmin, vmax, ignore=False):\n-        # docstring inherited\n-        if ignore:\n-            self.axes.viewLim.intervaly = vmin, vmax\n-        else:\n-            Vmin, Vmax = self.get_view_interval()\n-            if Vmin < Vmax:\n-                self.axes.viewLim.intervaly = (min(vmin, vmax, Vmin),\n-                                               max(vmin, vmax, Vmax))\n-            else:\n-                self.axes.viewLim.intervaly = (max(vmin, vmax, Vmin),\n-                                               min(vmin, vmax, Vmax))\n-        self.stale = True\n+    get_view_interval, set_view_interval = _make_getset_interval(\n+        \"view\", \"viewLim\", \"intervaly\")\n+    get_data_interval, set_data_interval = _make_getset_interval(\n+        \"data\", \"dataLim\", \"intervaly\")\n \n     def get_minpos(self):\n         return self.axes.dataLim.minposy\n \n-    def get_data_interval(self):\n-        # docstring inherited\n-        return self.axes.dataLim.intervaly\n-\n-    def set_data_interval(self, vmin, vmax, ignore=False):\n-        # docstring inherited\n-        if ignore:\n-            self.axes.dataLim.intervaly = vmin, vmax\n-        else:\n-            Vmin, Vmax = self.get_data_interval()\n-            self.axes.dataLim.intervaly = min(vmin, Vmin), max(vmax, Vmax)\n-        self.stale = True\n-\n     def set_default_intervals(self):\n         # docstring inherited\n         ymin, ymax = 0., 1.\n",
      "files_name_in_blame_commit": [
        "axis3d.py",
        "axis.py",
        "test_mplot3d.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 383
  },
  "recursive_blame_commits": {}
}
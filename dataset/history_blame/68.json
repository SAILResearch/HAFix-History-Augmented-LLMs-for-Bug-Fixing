{
  "id": "68",
  "blame_commit": {
    "commit": {
      "commit_id": "08b8ad1ff3bd003ef8309faaa0cc108ffa40317d",
      "commit_message": "Fix bar_format breaking console display\n\nSigned-off-by: Stephen L. <lrq3000@gmail.com>",
      "commit_author": "Stephen L",
      "commit_date": "2016-05-15 01:13:56",
      "commit_parent": "2c3c4d440e3535c01400483be87ae5157ff67d52"
    },
    "function": {
      "function_name": "format_meter",
      "function_code_before": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    format_sizeof = tqdm.format_sizeof\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate if inv_rate is None else inv_rate, 'rate_noinv': rate, 'rate_noinv_fmt': ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if rate else '?') + 'it/s', 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
      "function_code_after": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    format_sizeof = tqdm.format_sizeof\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        if bar_format:\n            bar_args = {'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate if inv_rate is None else inv_rate, 'rate_noinv': rate, 'rate_noinv_fmt': ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if rate else '?') + 'it/s', 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            if '{bar}' in bar_format:\n                (l_bar_user, r_bar_user) = bar_format.split('{bar}')\n                (l_bar, r_bar) = (l_bar.format(**bar_args), r_bar.format(**bar_args))\n            else:\n                return bar_format.format(**bar_args)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
      "function_before_start_line": 104,
      "function_before_end_line": 256,
      "function_after_start_line": 104,
      "function_after_end_line": 265,
      "function_before_token_count": 538,
      "function_after_token_count": 567,
      "functions_name_modified_file": [
        "trange",
        "clear",
        "_decr_instances",
        "status_printer",
        "set_description",
        "refresh",
        "format_sizeof",
        "write",
        "_get_free_pos",
        "__enter__",
        "__hash__",
        "__iter__",
        "__le__",
        "__ge__",
        "close",
        "__new__",
        "__lt__",
        "__gt__",
        "moveto",
        "__eq__",
        "__repr__",
        "__init__",
        "update",
        "__del__",
        "__len__",
        "__ne__",
        "unpause",
        "format_interval",
        "format_meter",
        "__exit__"
      ],
      "functions_name_all_files": [
        "trange",
        "clear",
        "_decr_instances",
        "status_printer",
        "set_description",
        "refresh",
        "format_sizeof",
        "write",
        "_get_free_pos",
        "__enter__",
        "__hash__",
        "__iter__",
        "__le__",
        "__ge__",
        "close",
        "__new__",
        "__lt__",
        "__gt__",
        "moveto",
        "__eq__",
        "__repr__",
        "__init__",
        "update",
        "__del__",
        "__len__",
        "__ne__",
        "unpause",
        "format_interval",
        "format_meter",
        "__exit__"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": []
    },
    "file": {
      "file_name": "_tqdm.py",
      "file_nloc": 455,
      "file_complexity": 157,
      "file_token_count": 3050,
      "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                                    if unit_scale else\n                                                    '{0:5.2f}'.format(rate))\n                                                    if rate else '?') + 'it/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        # Clear all bars\n        inst_cleared = []\n        for inst in cls._instances:\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == file or \\\n              (file in [sys.stdout, sys.stderr] and\n               inst.fp in [sys.stdout, sys.stderr]):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        file.write(s)\n        file.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations.\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:  # pragma: no cover\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= miniters:\n                    delta_it = n - last_print_n\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
      "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            if bar_format:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                                    if unit_scale else\n                                                    '{0:5.2f}'.format(rate))\n                                                    if rate else '?') + 'it/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else '',\n                            # 'bar': full_bar  # replaced by procedure below\n                            }\n\n                # Interpolate supplied bar format with the dict\n                if '{bar}' in bar_format:\n                    # Format left/right sides of the bar, and format the bar\n                    # later in the remaining space (avoid breaking display)\n                    l_bar_user, r_bar_user = bar_format.split('{bar}')\n                    l_bar, r_bar = l_bar.format(**bar_args), r_bar.format(**bar_args)\n                else:\n                    # Else no progress bar, we can just format and return\n                    return bar_format.format(**bar_args)\n\n            # Formatting progress bar\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            # Piece together the bar parts\n            return l_bar + full_bar + r_bar\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        # Clear all bars\n        inst_cleared = []\n        for inst in cls._instances:\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == file or \\\n              (file in [sys.stdout, sys.stderr] and\n               inst.fp in [sys.stdout, sys.stderr]):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        file.write(s)\n        file.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations.\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:  # pragma: no cover\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= miniters:\n                    delta_it = n - last_print_n\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
      "file_patch": "@@ -194,6 +194,40 @@ class tqdm(object):\n             if ncols == 0:\n                 return l_bar[:-1] + r_bar[1:]\n \n+            if bar_format:\n+                # Custom bar formatting\n+                # Populate a dict with all available progress indicators\n+                bar_args = {'n': n,\n+                            'n_fmt': n_fmt,\n+                            'total': total,\n+                            'total_fmt': total_fmt,\n+                            'percentage': percentage,\n+                            'rate': rate if inv_rate is None else inv_rate,\n+                            'rate_noinv': rate,\n+                            'rate_noinv_fmt': ((format_sizeof(rate)\n+                                                    if unit_scale else\n+                                                    '{0:5.2f}'.format(rate))\n+                                                    if rate else '?') + 'it/s',\n+                            'rate_fmt': rate_fmt,\n+                            'elapsed': elapsed_str,\n+                            'remaining': remaining_str,\n+                            'l_bar': l_bar,\n+                            'r_bar': r_bar,\n+                            'desc': prefix if prefix else '',\n+                            # 'bar': full_bar  # replaced by procedure below\n+                            }\n+\n+                # Interpolate supplied bar format with the dict\n+                if '{bar}' in bar_format:\n+                    # Format left/right sides of the bar, and format the bar\n+                    # later in the remaining space (avoid breaking display)\n+                    l_bar_user, r_bar_user = bar_format.split('{bar}')\n+                    l_bar, r_bar = l_bar.format(**bar_args), r_bar.format(**bar_args)\n+                else:\n+                    # Else no progress bar, we can just format and return\n+                    return bar_format.format(**bar_args)\n+\n+            # Formatting progress bar\n             # space available for bar's display\n             N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                 else 10\n@@ -222,33 +256,8 @@ class tqdm(object):\n                 full_bar = bar + \\\n                     ' ' * max(N_BARS - bar_length, 0)\n \n-            if bar_format is None:\n-                # Default bar format = fast display\n-                return l_bar + full_bar + r_bar\n-            else:\n-                # Custom bar formatting\n-                # Populate a dict with all available progress indicators\n-                bar_args = {'bar': full_bar,\n-                            'n': n,\n-                            'n_fmt': n_fmt,\n-                            'total': total,\n-                            'total_fmt': total_fmt,\n-                            'percentage': percentage,\n-                            'rate': rate if inv_rate is None else inv_rate,\n-                            'rate_noinv': rate,\n-                            'rate_noinv_fmt': ((format_sizeof(rate)\n-                                                    if unit_scale else\n-                                                    '{0:5.2f}'.format(rate))\n-                                                    if rate else '?') + 'it/s',\n-                            'rate_fmt': rate_fmt,\n-                            'elapsed': elapsed_str,\n-                            'remaining': remaining_str,\n-                            'l_bar': l_bar,\n-                            'r_bar': r_bar,\n-                            'desc': prefix if prefix else ''\n-                            }\n-                # Interpolate supplied bar format with the dict\n-                return bar_format.format(**bar_args)\n+            # Piece together the bar parts\n+            return l_bar + full_bar + r_bar\n \n         # no total: no progressbar, ETA, just progress stats\n         else:\n",
      "files_name_in_blame_commit": [
        "_tqdm.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 150
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "104": {
        "commit_id": "adc89a268e1570f195f5aece4132252ab24ba124",
        "line_code": "    def format_meter(n, total, elapsed, ncols=None, prefix='',",
        "commit_date": "2016-01-12 18:19:04",
        "valid": 1
      },
      "105": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "                     ascii=False, unit='it', unit_scale=False, rate=None,",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "106": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "                     bar_format=None):",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "107": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        \"\"\"",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "108": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "        Return a string-based progress bar given some parameters",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "109": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 0
      },
      "110": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        Parameters",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "111": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        ----------",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "112": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        n  : int",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "113": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "            Number of finished iterations.",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "114": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        total  : int",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "115": {
        "commit_id": "4d9ec57cd988330eda8585d3f8512a7a05ce57fc",
        "line_code": "            The expected total number of iterations. If meaningless (), only",
        "commit_date": "2015-11-28 20:27:43",
        "valid": 1
      },
      "116": {
        "commit_id": "4d9ec57cd988330eda8585d3f8512a7a05ce57fc",
        "line_code": "            basic progress statistics are displayed (no ETA).",
        "commit_date": "2015-11-28 20:27:43",
        "valid": 1
      },
      "117": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        elapsed  : float",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "118": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "            Number of seconds passed since start.",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "119": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        ncols  : int, optional",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "120": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            The width of the entire output message. If specified,",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "121": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            dynamically resizes the progress meter to stay within this bound",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "122": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            [default: None]. The fallback meter width is 10 for the progress",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "123": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            bar + no limit for the iterations counter and statistics. If 0,",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "124": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            will not print any meter (only stats).",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "125": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        prefix  : str, optional",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "126": {
        "commit_id": "66672fe244165e43ce0f0971e0c8cad9093042bc",
        "line_code": "            Prefix message (included in total width) [default: ''].",
        "commit_date": "2015-09-13 18:47:52",
        "valid": 1
      },
      "127": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        ascii  : bool, optional",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "128": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "            If not set, use unicode (smooth blocks) to fill the meter",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "129": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            [default: False]. The fallback is to use ASCII characters",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "130": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            (1-9 #).",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "131": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "        unit  : str, optional",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "132": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "            The iteration unit [default: 'it'].",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "133": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "        unit_scale  : bool, optional",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "134": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            If set, the number of iterations will printed with an",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "135": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "136": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            [default: False].",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "137": {
        "commit_id": "370780a74a3ec0d9341c196e201f73f4a8dd8f11",
        "line_code": "        rate  : float, optional",
        "commit_date": "2015-11-09 12:17:20",
        "valid": 1
      },
      "138": {
        "commit_id": "4d9ec57cd988330eda8585d3f8512a7a05ce57fc",
        "line_code": "            Manual override for iteration rate.",
        "commit_date": "2015-11-28 20:27:43",
        "valid": 1
      },
      "139": {
        "commit_id": "4d9ec57cd988330eda8585d3f8512a7a05ce57fc",
        "line_code": "            If [default: None], uses n/elapsed.",
        "commit_date": "2015-11-28 20:27:43",
        "valid": 1
      },
      "140": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "        bar_format  : str, optional",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "141": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "            Specify a custom bar string formatting. May impact performance.",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "142": {
        "commit_id": "5af1135108fa7178f1c88801569b81613c87d497",
        "line_code": "            [default: '{l_bar}{bar}{r_bar}'], where l_bar is",
        "commit_date": "2015-12-27 17:08:17",
        "valid": 1
      },
      "143": {
        "commit_id": "5af1135108fa7178f1c88801569b81613c87d497",
        "line_code": "            '{desc}{percentage:3.0f}%|' and r_bar is",
        "commit_date": "2015-12-27 17:08:17",
        "valid": 1
      },
      "144": {
        "commit_id": "d401184da4c5f08c5aa97eedcf12e58f06de3c3d",
        "line_code": "            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'",
        "commit_date": "2016-04-07 22:10:09",
        "valid": 1
      },
      "145": {
        "commit_id": "5af1135108fa7178f1c88801569b81613c87d497",
        "line_code": "            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,",
        "commit_date": "2015-12-27 17:08:17",
        "valid": 1
      },
      "146": {
        "commit_id": "5af1135108fa7178f1c88801569b81613c87d497",
        "line_code": "            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.",
        "commit_date": "2015-12-27 17:08:17",
        "valid": 1
      },
      "147": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 0
      },
      "148": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        Returns",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "149": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        -------",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "150": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        out  : Formatted meter and stats, ready to display.",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "151": {
        "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
        "line_code": "        \"\"\"",
        "commit_date": "2015-06-18 22:46:06",
        "valid": 1
      },
      "152": {
        "commit_id": "05dc6d5011affe35c35997e2290aef90053ef023",
        "line_code": "",
        "commit_date": "2015-07-12 06:44:04",
        "valid": 0
      },
      "153": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "        # sanity check: total",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "154": {
        "commit_id": "05dc6d5011affe35c35997e2290aef90053ef023",
        "line_code": "        if total and n > total:",
        "commit_date": "2015-07-12 06:44:04",
        "valid": 1
      },
      "155": {
        "commit_id": "6ba85d464c588d7166f2aea897e5265ade93b9eb",
        "line_code": "            total = None",
        "commit_date": "2013-10-26 22:54:46",
        "valid": 1
      },
      "156": {
        "commit_id": "6ba85d464c588d7166f2aea897e5265ade93b9eb",
        "line_code": "",
        "commit_date": "2013-10-26 22:54:46",
        "valid": 0
      },
      "157": {
        "commit_id": "879f7ef463ab4ac922761244dada1c41c090ca0d",
        "line_code": "        format_interval = tqdm.format_interval",
        "commit_date": "2016-01-12 18:48:47",
        "valid": 1
      },
      "158": {
        "commit_id": "6ba85d464c588d7166f2aea897e5265ade93b9eb",
        "line_code": "        elapsed_str = format_interval(elapsed)",
        "commit_date": "2013-10-26 22:54:46",
        "valid": 1
      },
      "159": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 0
      },
      "160": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "        # if unspecified, attempt to use rate = average speed",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "161": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "        # (we allow manual override since predicting time is an arcane art)",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "162": {
        "commit_id": "370780a74a3ec0d9341c196e201f73f4a8dd8f11",
        "line_code": "        if rate is None and elapsed:",
        "commit_date": "2015-11-09 12:17:20",
        "valid": 1
      },
      "163": {
        "commit_id": "370780a74a3ec0d9341c196e201f73f4a8dd8f11",
        "line_code": "            rate = n / elapsed",
        "commit_date": "2015-11-09 12:17:20",
        "valid": 1
      },
      "164": {
        "commit_id": "dc8eeedeb132e01943f4d13664b5b6e7831fc13a",
        "line_code": "        inv_rate = 1 / rate if (rate and (rate < 1)) else None",
        "commit_date": "2015-12-27 16:32:02",
        "valid": 1
      },
      "165": {
        "commit_id": "879f7ef463ab4ac922761244dada1c41c090ca0d",
        "line_code": "        format_sizeof = tqdm.format_sizeof",
        "commit_date": "2016-01-12 18:48:47",
        "valid": 1
      },
      "166": {
        "commit_id": "b47abc54999cb2e259681555ef08b9a5c8141b81",
        "line_code": "        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)",
        "commit_date": "2016-01-10 21:37:47",
        "valid": 1
      },
      "167": {
        "commit_id": "b47abc54999cb2e259681555ef08b9a5c8141b81",
        "line_code": "                    if unit_scale else",
        "commit_date": "2016-01-10 21:37:47",
        "valid": 1
      },
      "168": {
        "commit_id": "b47abc54999cb2e259681555ef08b9a5c8141b81",
        "line_code": "                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))",
        "commit_date": "2016-01-10 21:37:47",
        "valid": 1
      },
      "169": {
        "commit_id": "a34a7699f2aa645be1a13c121270df2ca7023f33",
        "line_code": "                    if rate else '?') \\",
        "commit_date": "2016-01-10 21:30:39",
        "valid": 1
      },
      "170": {
        "commit_id": "dc8eeedeb132e01943f4d13664b5b6e7831fc13a",
        "line_code": "            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')",
        "commit_date": "2015-12-27 16:32:02",
        "valid": 1
      },
      "171": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 0
      },
      "172": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "        if unit_scale:",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "173": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "            n_fmt = format_sizeof(n)",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "174": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "            total_fmt = format_sizeof(total) if total else None",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "175": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "        else:",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "176": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "            n_fmt = str(n)",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "177": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "            total_fmt = str(total)",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "178": {
        "commit_id": "6ba85d464c588d7166f2aea897e5265ade93b9eb",
        "line_code": "",
        "commit_date": "2013-10-26 22:54:46",
        "valid": 0
      },
      "179": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "        # total is known: we can predict some stats",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "180": {
        "commit_id": "6ba85d464c588d7166f2aea897e5265ade93b9eb",
        "line_code": "        if total:",
        "commit_date": "2013-10-26 22:54:46",
        "valid": 1
      },
      "181": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "            # fractional and percentage progress",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "182": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "            frac = n / total",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "183": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "            percentage = frac * 100",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "184": {
        "commit_id": "6ba85d464c588d7166f2aea897e5265ade93b9eb",
        "line_code": "",
        "commit_date": "2013-10-26 22:54:46",
        "valid": 0
      },
      "185": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            remaining_str = format_interval((total - n) / rate) \\",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "186": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "                if rate else '?'",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "187": {
        "commit_id": "e9ccb10310f7bb1eca9d53b4ca199a1f18987101",
        "line_code": "",
        "commit_date": "2015-06-15 10:35:06",
        "valid": 0
      },
      "188": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "            # format the stats displayed to the left and right sides of the bar",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "189": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "            l_bar = (prefix if prefix else '') + \\",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "190": {
        "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
        "line_code": "                '{0:3.0f}%|'.format(percentage)",
        "commit_date": "2016-01-11 09:02:07",
        "valid": 1
      },
      "191": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "192": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      },
      "193": {
        "commit_id": "e9ccb10310f7bb1eca9d53b4ca199a1f18987101",
        "line_code": "",
        "commit_date": "2015-06-15 10:35:06",
        "valid": 0
      },
      "194": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "            if ncols == 0:",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "195": {
        "commit_id": "367723c584d7bbbce0b24f079f9b0404dfb1758e",
        "line_code": "                return l_bar[:-1] + r_bar[1:]",
        "commit_date": "2015-09-18 20:39:13",
        "valid": 1
      },
      "196": {
        "commit_id": "367723c584d7bbbce0b24f079f9b0404dfb1758e",
        "line_code": "",
        "commit_date": "2015-09-18 20:39:13",
        "valid": 0
      },
      "197": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "            # space available for bar's display",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "198": {
        "commit_id": "b625ff4bbdbf1b5e56d4e7504c40819d381ec457",
        "line_code": "            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\",
        "commit_date": "2015-07-13 15:19:06",
        "valid": 1
      },
      "199": {
        "commit_id": "b625ff4bbdbf1b5e56d4e7504c40819d381ec457",
        "line_code": "                else 10",
        "commit_date": "2015-07-13 15:19:06",
        "valid": 1
      },
      "200": {
        "commit_id": "ef61853720c34e5e9fb9ae513ea8338ffbcd16a2",
        "line_code": "",
        "commit_date": "2015-06-18 22:19:40",
        "valid": 0
      },
      "201": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "            # format bar depending on availability of unicode/ascii chars",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "202": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "            if ascii:",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "203": {
        "commit_id": "fffe2e70bc7a96795e44d1e784e7e2940d0f2c10",
        "line_code": "                bar_length, frac_bar_length = divmod(",
        "commit_date": "2015-07-13 15:44:26",
        "valid": 1
      },
      "204": {
        "commit_id": "fffe2e70bc7a96795e44d1e784e7e2940d0f2c10",
        "line_code": "                    int(frac * N_BARS * 10), 10)",
        "commit_date": "2015-07-13 15:44:26",
        "valid": 1
      },
      "205": {
        "commit_id": "ef61853720c34e5e9fb9ae513ea8338ffbcd16a2",
        "line_code": "",
        "commit_date": "2015-06-18 22:19:40",
        "valid": 0
      },
      "206": {
        "commit_id": "ef61853720c34e5e9fb9ae513ea8338ffbcd16a2",
        "line_code": "                bar = '#' * bar_length",
        "commit_date": "2015-06-18 22:19:40",
        "valid": 1
      },
      "207": {
        "commit_id": "b625ff4bbdbf1b5e56d4e7504c40819d381ec457",
        "line_code": "                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\",
        "commit_date": "2015-07-13 15:19:06",
        "valid": 1
      },
      "208": {
        "commit_id": "b625ff4bbdbf1b5e56d4e7504c40819d381ec457",
        "line_code": "                    else ' '",
        "commit_date": "2015-07-13 15:19:06",
        "valid": 1
      },
      "209": {
        "commit_id": "ef61853720c34e5e9fb9ae513ea8338ffbcd16a2",
        "line_code": "",
        "commit_date": "2015-06-18 22:19:40",
        "valid": 0
      },
      "210": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "            else:",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "211": {
        "commit_id": "ac4646c723a22aaa14a005613d892822cf81eebb",
        "line_code": "                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)",
        "commit_date": "2015-06-18 15:59:37",
        "valid": 1
      },
      "212": {
        "commit_id": "2ed6664b6cbd55386e4954d978798d40b6e09911",
        "line_code": "",
        "commit_date": "2015-06-15 10:32:56",
        "valid": 0
      },
      "213": {
        "commit_id": "c58a7c3f216c0a681f6abc0ce95b0eb97c77b08f",
        "line_code": "                bar = _unich(0x2588) * bar_length",
        "commit_date": "2015-06-25 16:56:34",
        "valid": 1
      },
      "214": {
        "commit_id": "c58a7c3f216c0a681f6abc0ce95b0eb97c77b08f",
        "line_code": "                frac_bar = _unich(0x2590 - frac_bar_length) \\",
        "commit_date": "2015-06-25 16:56:34",
        "valid": 1
      },
      "215": {
        "commit_id": "ef61853720c34e5e9fb9ae513ea8338ffbcd16a2",
        "line_code": "                    if frac_bar_length else ' '",
        "commit_date": "2015-06-18 22:19:40",
        "valid": 1
      },
      "216": {
        "commit_id": "e9ccb10310f7bb1eca9d53b4ca199a1f18987101",
        "line_code": "",
        "commit_date": "2015-06-15 10:35:06",
        "valid": 0
      },
      "217": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "            # whitespace padding",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "218": {
        "commit_id": "e9ccb10310f7bb1eca9d53b4ca199a1f18987101",
        "line_code": "            if bar_length < N_BARS:",
        "commit_date": "2015-06-15 10:35:06",
        "valid": 1
      },
      "219": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "                full_bar = bar + frac_bar + \\",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "220": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "                    ' ' * max(N_BARS - bar_length - 1, 0)",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "221": {
        "commit_id": "ac4646c723a22aaa14a005613d892822cf81eebb",
        "line_code": "            else:",
        "commit_date": "2015-06-18 15:59:37",
        "valid": 1
      },
      "222": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "                full_bar = bar + \\",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 1
      },
      "223": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "                    ' ' * max(N_BARS - bar_length, 0)",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "224": {
        "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
        "line_code": "",
        "commit_date": "2015-07-12 06:20:23",
        "valid": 0
      },
      "225": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "            if bar_format is None:",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "226": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                # Default bar format = fast display",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "227": {
        "commit_id": "1f671ecf43eedc06b10f9e222085714b3bead29f",
        "line_code": "                return l_bar + full_bar + r_bar",
        "commit_date": "2015-07-13 14:53:08",
        "valid": 1
      },
      "228": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "            else:",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "229": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                # Custom bar formatting",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "230": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                # Populate a dict with all available progress indicators",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "231": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                bar_args = {'bar': full_bar,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "232": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'n': n,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "233": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'n_fmt': n_fmt,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "234": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'total': total,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "235": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'total_fmt': total_fmt,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "236": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'percentage': percentage,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "237": {
        "commit_id": "560e8977199cc4e968ba738d0b663a65895104e5",
        "line_code": "                            'rate': rate if inv_rate is None else inv_rate,",
        "commit_date": "2016-05-09 01:37:08",
        "valid": 1
      },
      "238": {
        "commit_id": "560e8977199cc4e968ba738d0b663a65895104e5",
        "line_code": "                            'rate_noinv': rate,",
        "commit_date": "2016-05-09 01:37:08",
        "valid": 1
      },
      "239": {
        "commit_id": "560e8977199cc4e968ba738d0b663a65895104e5",
        "line_code": "                            'rate_noinv_fmt': ((format_sizeof(rate)",
        "commit_date": "2016-05-09 01:37:08",
        "valid": 1
      },
      "240": {
        "commit_id": "560e8977199cc4e968ba738d0b663a65895104e5",
        "line_code": "                                                    if unit_scale else",
        "commit_date": "2016-05-09 01:37:08",
        "valid": 1
      },
      "241": {
        "commit_id": "560e8977199cc4e968ba738d0b663a65895104e5",
        "line_code": "                                                    '{0:5.2f}'.format(rate))",
        "commit_date": "2016-05-09 01:37:08",
        "valid": 1
      },
      "242": {
        "commit_id": "560e8977199cc4e968ba738d0b663a65895104e5",
        "line_code": "                                                    if rate else '?') + 'it/s',",
        "commit_date": "2016-05-09 01:37:08",
        "valid": 1
      },
      "243": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'rate_fmt': rate_fmt,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "244": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'elapsed': elapsed_str,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "245": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'remaining': remaining_str,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "246": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'l_bar': l_bar,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "247": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            'r_bar': r_bar,",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "248": {
        "commit_id": "5af1135108fa7178f1c88801569b81613c87d497",
        "line_code": "                            'desc': prefix if prefix else ''",
        "commit_date": "2015-12-27 17:08:17",
        "valid": 1
      },
      "249": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                            }",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "250": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                # Interpolate supplied bar format with the dict",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "251": {
        "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
        "line_code": "                return bar_format.format(**bar_args)",
        "commit_date": "2015-12-27 17:08:07",
        "valid": 1
      },
      "252": {
        "commit_id": "6ba85d464c588d7166f2aea897e5265ade93b9eb",
        "line_code": "",
        "commit_date": "2013-10-26 22:54:46",
        "valid": 0
      },
      "253": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "        # no total: no progressbar, ETA, just progress stats",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "254": {
        "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
        "line_code": "        else:",
        "commit_date": "2015-11-10 16:50:51",
        "valid": 1
      },
      "255": {
        "commit_id": "743af04f3948c2943ee3a00007cbad06c783f801",
        "line_code": "            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(",
        "commit_date": "2015-09-14 12:44:31",
        "valid": 1
      },
      "256": {
        "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
        "line_code": "                n_fmt, unit, elapsed_str, rate_fmt)",
        "commit_date": "2015-07-16 01:58:07",
        "valid": 1
      }
    },
    "commits": {
      "560e8977199cc4e968ba738d0b663a65895104e5": {
        "commit": {
          "commit_id": "560e8977199cc4e968ba738d0b663a65895104e5",
          "commit_message": "Add no rate inversion option in bar_format\n\nSigned-off-by: Stephen L. <lrq3000@gmail.com>",
          "commit_author": "Stephen L",
          "commit_date": "2016-05-09 01:37:08",
          "commit_parent": "36c5013e6d66bebf9c2343006b6fe200851b6107"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    format_sizeof = tqdm.format_sizeof\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    format_sizeof = tqdm.format_sizeof\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate if inv_rate is None else inv_rate, 'rate_noinv': rate, 'rate_noinv_fmt': ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if rate else '?') + 'it/s', 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 104,
          "function_before_end_line": 251,
          "function_after_start_line": 104,
          "function_after_end_line": 256,
          "function_before_token_count": 502,
          "function_after_token_count": 538,
          "functions_name_modified_file": [
            "trange",
            "clear",
            "_decr_instances",
            "status_printer",
            "set_description",
            "refresh",
            "format_sizeof",
            "write",
            "_get_free_pos",
            "__enter__",
            "__hash__",
            "__iter__",
            "__le__",
            "__ge__",
            "close",
            "__new__",
            "__lt__",
            "__gt__",
            "moveto",
            "__eq__",
            "__repr__",
            "__init__",
            "update",
            "__del__",
            "__len__",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "clear",
            "_decr_instances",
            "status_printer",
            "set_description",
            "refresh",
            "format_sizeof",
            "write",
            "_get_free_pos",
            "__enter__",
            "__hash__",
            "__iter__",
            "__le__",
            "__ge__",
            "close",
            "__new__",
            "__lt__",
            "__gt__",
            "moveto",
            "__eq__",
            "__repr__",
            "__init__",
            "update",
            "__del__",
            "__len__",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 453,
          "file_complexity": 156,
          "file_token_count": 3021,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        # Clear all bars\n        inst_cleared = []\n        for inst in cls._instances:\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == file or \\\n              (file in [sys.stdout, sys.stderr] and\n               inst.fp in [sys.stdout, sys.stderr]):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        file.write(s)\n        file.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations.\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:  # pragma: no cover\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= miniters:\n                    delta_it = n - last_print_n\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                                    if unit_scale else\n                                                    '{0:5.2f}'.format(rate))\n                                                    if rate else '?') + 'it/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Return the instance\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    @classmethod\n    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        # Clear all bars\n        inst_cleared = []\n        for inst in cls._instances:\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == file or \\\n              (file in [sys.stdout, sys.stderr] and\n               inst.fp in [sys.stdout, sys.stderr]):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        file.write(s)\n        file.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh()\n        # TODO: make list of all instances incl. absolutely positioned ones?\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations.\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:  # pragma: no cover\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= miniters:\n                    delta_it = n - last_print_n\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)\n\n    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -234,7 +234,12 @@ class tqdm(object):\n                             'total': total,\n                             'total_fmt': total_fmt,\n                             'percentage': percentage,\n-                            'rate': rate,\n+                            'rate': rate if inv_rate is None else inv_rate,\n+                            'rate_noinv': rate,\n+                            'rate_noinv_fmt': ((format_sizeof(rate)\n+                                                    if unit_scale else\n+                                                    '{0:5.2f}'.format(rate))\n+                                                    if rate else '?') + 'it/s',\n                             'rate_fmt': rate_fmt,\n                             'elapsed': elapsed_str,\n                             'remaining': remaining_str,\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "d401184da4c5f08c5aa97eedcf12e58f06de3c3d": {
        "commit": {
          "commit_id": "d401184da4c5f08c5aa97eedcf12e58f06de3c3d",
          "commit_message": "Make, flake8 tidy",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2016-04-07 22:10:09",
          "commit_parent": "fe9731752b835c539b4d02f432baae16e37352e1"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    format_sizeof = tqdm.format_sizeof\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    format_sizeof = tqdm.format_sizeof\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 104,
          "function_before_end_line": 251,
          "function_after_start_line": 104,
          "function_after_end_line": 251,
          "function_before_token_count": 502,
          "function_after_token_count": 502,
          "functions_name_modified_file": [
            "trange",
            "_decr_instances",
            "status_printer",
            "set_description",
            "format_sizeof",
            "_get_free_pos",
            "__enter__",
            "__hash__",
            "__iter__",
            "__le__",
            "__ge__",
            "close",
            "__new__",
            "__lt__",
            "__gt__",
            "moveto",
            "__eq__",
            "__repr__",
            "__init__",
            "update",
            "__del__",
            "__len__",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "_decr_instances",
            "status_printer",
            "set_description",
            "format_sizeof",
            "execute_makefile_commands",
            "_get_free_pos",
            "__enter__",
            "__hash__",
            "__iter__",
            "__le__",
            "__ge__",
            "close",
            "__new__",
            "__lt__",
            "__gt__",
            "moveto",
            "__eq__",
            "parse_makefile_aliases",
            "__repr__",
            "__init__",
            "update",
            "__del__",
            "__len__",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "__repr__"
          ],
          "functions_name_co_evolved_all_files": [
            "parse_makefile_aliases",
            "__repr__",
            "__init__"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 422,
          "file_complexity": 140,
          "file_token_count": 2750,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        instance = object.__new__(cls)\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If [default: None], len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If [default: None] or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If [default: None], will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if [default: None].\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:  # pragma: no cover\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total, time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode, WeakSet\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __new__(cls, *args, **kwargs):\n        instance = object.__new__(cls)\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If [default: None],\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If [default: None] or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If [default: None], will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if [default: None].\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:  # pragma: no cover\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)\n\n    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos\n        # except AttributeError:\n        #     return self.start_t < other.start_t\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos\n        # except AttributeError:\n        #     return self.start_t == other.start_t\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -141,7 +141,7 @@ class tqdm(object):\n             Specify a custom bar string formatting. May impact performance.\n             [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n             '{desc}{percentage:3.0f}%|' and r_bar is\n-            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n+            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n             Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n             rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n \n@@ -297,11 +297,11 @@ class tqdm(object):\n         desc  : str, optional\n             Prefix for the progressbar [default: None].\n         total  : int, optional\n-            The number of expected iterations. If [default: None], len(iterable)\n-            is used if possible. As a last resort, only basic progress\n-            statistics are displayed (no ETA, no progressbar). If `gui` is\n-            True and this parameter needs subsequent updating, specify an\n-            initial arbitrary large positive integer, e.g. int(9e9).\n+            The number of expected iterations. If [default: None],\n+            len(iterable) is used if possible. As a last resort, only basic\n+            progress statistics are displayed (no ETA, no progressbar).\n+            If `gui` is True and this parameter needs subsequent updating,\n+            specify an initial arbitrary large positive integer, e.g. int(9e9).\n         leave  : bool, optional\n             If [default: True], removes all traces of the progressbar\n             upon termination of iteration.\n@@ -347,7 +347,7 @@ class tqdm(object):\n             Specify a custom bar string formatting. May impact performance.\n             If [default: None], will use '{l_bar}{bar}{r_bar}', where l_bar is\n             '{desc}{percentage:3.0f}%|' and r_bar is\n-            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n+            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n             Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n             rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n         initial  : int, optional\n@@ -478,7 +478,8 @@ class tqdm(object):\n         self.close()\n \n     def __repr__(self):\n-        return self.format_meter(self.n, self.total, time() - self.last_print_t,\n+        return self.format_meter(self.n, self.total,\n+                                 time() - self.last_print_t,\n                                  self.ncols, self.desc, self.ascii, self.unit,\n                                  self.unit_scale, 1 / self.avg_time\n                                  if self.avg_time else None, self.bar_format)\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "setup.py"
          ]
        }
      },
      "879f7ef463ab4ac922761244dada1c41c090ca0d": {
        "commit": {
          "commit_id": "879f7ef463ab4ac922761244dada1c41c090ca0d",
          "commit_message": "one big happy class",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2016-01-12 18:48:47",
          "commit_parent": "adc89a268e1570f195f5aece4132252ab24ba124"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    format_sizeof = tqdm.format_sizeof\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 100,
          "function_before_end_line": 245,
          "function_after_start_line": 101,
          "function_after_end_line": 248,
          "function_before_token_count": 492,
          "function_after_token_count": 502,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "status_printer",
            "__len__",
            "__enter__",
            "__iter__",
            "unpause",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_ascii",
            "test_iterate_over_csv_rows",
            "status_printer",
            "test_no_gui",
            "set_description",
            "test_bar_format",
            "closing",
            "format_sizeof",
            "test_set_description",
            "test_si_format",
            "test_close",
            "get_bar",
            "test_min_interval",
            "__enter__",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "progressbar_rate",
            "update",
            "test_smoothing",
            "test_file_output",
            "test_max_interval",
            "test_big_min_interval",
            "__len__",
            "test_nested",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__",
            "test_format_interval",
            "test_unpause"
          ],
          "functions_name_co_evolved_modified_file": [
            "format_sizeof",
            "format_interval"
          ],
          "functions_name_co_evolved_all_files": [
            "format_sizeof",
            "format_interval",
            "test_format_interval"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 325,
          "file_complexity": 103,
          "file_token_count": 2130,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if elapsed else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(self.format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange']\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if elapsed else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(self.format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -19,55 +19,7 @@ from time import time\n \n __author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                               \"casperdcl\", \"lrq3000\"]}\n-__all__ = ['tqdm', 'trange', 'format_interval']\n-\n-\n-def format_sizeof(num, suffix=''):\n-    \"\"\"\n-    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n-\n-    Parameters\n-    ----------\n-    num  : float\n-        Number ( >= 1) to format.\n-    suffix  : str, optional\n-        Post-postfix [default: ''].\n-\n-    Returns\n-    -------\n-    out  : str\n-        Number with Order of Magnitude SI unit postfix.\n-    \"\"\"\n-    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n-        if abs(num) < 999.95:\n-            if abs(num) < 99.95:\n-                if abs(num) < 9.995:\n-                    return '{0:1.2f}'.format(num) + unit + suffix\n-                return '{0:2.1f}'.format(num) + unit + suffix\n-            return '{0:3.0f}'.format(num) + unit + suffix\n-        num /= 1000.0\n-    return '{0:3.1f}Y'.format(num) + suffix\n-\n-\n-def format_interval(t):\n-    \"\"\"\n-    Formats a number of seconds as a clock time, [H:]MM:SS\n-\n-    Parameters\n-    ----------\n-    t  : int\n-        Number of seconds.\n-    Returns\n-    -------\n-    out  : str\n-        [H:]MM:SS\n-    \"\"\"\n-    mins, s = divmod(int(t), 60)\n-    h, m = divmod(mins, 60)\n-    if h:\n-        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n-    else:\n-        return '{0:02d}:{1:02d}'.format(m, s)\n+__all__ = ['tqdm', 'trange']\n \n \n class tqdm(object):\n@@ -76,6 +28,55 @@ class tqdm(object):\n     like the original iterable, but prints a dynamically updating\n     progressbar every time a value is requested.\n     \"\"\"\n+    @staticmethod\n+    def format_sizeof(num, suffix=''):\n+        \"\"\"\n+        Formats a number (greater than unity) with SI Order of Magnitude\n+        prefixes.\n+\n+        Parameters\n+        ----------\n+        num  : float\n+            Number ( >= 1) to format.\n+        suffix  : str, optional\n+            Post-postfix [default: ''].\n+\n+        Returns\n+        -------\n+        out  : str\n+            Number with Order of Magnitude SI unit postfix.\n+        \"\"\"\n+        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n+            if abs(num) < 999.95:\n+                if abs(num) < 99.95:\n+                    if abs(num) < 9.995:\n+                        return '{0:1.2f}'.format(num) + unit + suffix\n+                    return '{0:2.1f}'.format(num) + unit + suffix\n+                return '{0:3.0f}'.format(num) + unit + suffix\n+            num /= 1000.0\n+        return '{0:3.1f}Y'.format(num) + suffix\n+\n+    @staticmethod\n+    def format_interval(t):\n+        \"\"\"\n+        Formats a number of seconds as a clock time, [H:]MM:SS\n+\n+        Parameters\n+        ----------\n+        t  : int\n+            Number of seconds.\n+        Returns\n+        -------\n+        out  : str\n+            [H:]MM:SS\n+        \"\"\"\n+        mins, s = divmod(int(t), 60)\n+        h, m = divmod(mins, 60)\n+        if h:\n+            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n+        else:\n+            return '{0:02d}:{1:02d}'.format(m, s)\n+\n     @staticmethod\n     def status_printer(file):\n         \"\"\"\n@@ -150,6 +151,7 @@ class tqdm(object):\n         if total and n > total:\n             total = None\n \n+        format_interval = tqdm.format_interval\n         elapsed_str = format_interval(elapsed)\n \n         # if unspecified, attempt to use rate = average speed\n@@ -157,6 +159,7 @@ class tqdm(object):\n         if rate is None and elapsed:\n             rate = n / elapsed\n         inv_rate = 1 / rate if (rate and (rate < 1)) else None\n+        format_sizeof = tqdm.format_sizeof\n         rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                     if unit_scale else\n                     '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "adc89a268e1570f195f5aece4132252ab24ba124": {
        "commit": {
          "commit_id": "adc89a268e1570f195f5aece4132252ab24ba124",
          "commit_message": "minor optimisation",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2016-01-12 18:19:04",
          "commit_parent": "c0bd5f421bfa01b759f71ea2247858b0f0a84094"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "@classmethod\ndef format_meter(cls, n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 100,
          "function_before_end_line": 245,
          "function_after_start_line": 100,
          "function_after_end_line": 245,
          "function_before_token_count": 494,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "status_printer",
            "__len__",
            "__enter__",
            "__iter__",
            "unpause",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "__init__",
            "close",
            "update",
            "trange",
            "status_printer",
            "__len__",
            "__enter__",
            "__iter__",
            "unpause",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "status_printer"
          ],
          "functions_name_co_evolved_all_files": [
            "status_printer"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 321,
          "file_complexity": 103,
          "file_token_count": 2118,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @classmethod\n    def status_printer(cls, file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @classmethod\n    def format_meter(cls, n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if elapsed else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(self.format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if elapsed else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(self.format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -76,8 +76,8 @@ class tqdm(object):\n     like the original iterable, but prints a dynamically updating\n     progressbar every time a value is requested.\n     \"\"\"\n-    @classmethod\n-    def status_printer(cls, file):\n+    @staticmethod\n+    def status_printer(file):\n         \"\"\"\n         Manage the printing and in-place updating of a line of characters.\n         Note that if the string is longer than a line, then in-place\n@@ -96,8 +96,8 @@ class tqdm(object):\n             last_printed_len[0] = len_s\n         return print_status\n \n-    @classmethod\n-    def format_meter(cls, n, total, elapsed, ncols=None, prefix='',\n+    @staticmethod\n+    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                      ascii=False, unit='it', unit_scale=False, rate=None,\n                      bar_format=None):\n         \"\"\"\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "4d1f437eaf6250686df42e44f6e032202e3aed0d": {
        "commit": {
          "commit_id": "4d1f437eaf6250686df42e44f6e032202e3aed0d",
          "commit_message": "make format_meter part of the class. TODO: update docs",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2016-01-11 09:02:07",
          "commit_parent": "231a9948aa8e6a2f68260514988590b08a00be18"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "@classmethod\ndef format_meter(cls, n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 73,
          "function_before_end_line": 212,
          "function_after_start_line": 100,
          "function_after_end_line": 245,
          "function_before_token_count": 490,
          "function_after_token_count": 494,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__enter__",
            "__iter__",
            "unpause",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_ascii",
            "test_iterate_over_csv_rows",
            "test_no_gui",
            "set_description",
            "test_bar_format",
            "closing",
            "format_sizeof",
            "test_set_description",
            "test_si_format",
            "test_close",
            "get_bar",
            "test_min_interval",
            "__enter__",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "test_leave_option",
            "test_format_meter",
            "tgrange",
            "test_unit",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "progressbar_rate",
            "update",
            "test_smoothing",
            "StatusPrinter",
            "test_file_output",
            "test_max_interval",
            "test_big_min_interval",
            "__len__",
            "test_nested",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__",
            "test_format_interval",
            "test_unpause"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "__iter__",
            "update",
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "__init__",
            "update",
            "test_si_format",
            "__iter__",
            "test_format_meter"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 320,
          "file_complexity": 103,
          "file_token_count": 2116,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if elapsed else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix if prefix else ''\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None, self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    @classmethod\n    def format_meter(cls, n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if elapsed else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            if bar_format is None:\n                # Default bar format = fast display\n                return l_bar + full_bar + r_bar\n            else:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'bar': full_bar,\n                            'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate,\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else ''\n                            }\n                # Interpolate supplied bar format with the dict\n                return bar_format.format(**bar_args)\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(self.format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing:  # and delta_it\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing:  # and delta_it\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -19,7 +19,7 @@ from time import time\n \n __author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                               \"casperdcl\", \"lrq3000\"]}\n-__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n+__all__ = ['tqdm', 'trange', 'format_interval']\n \n \n def format_sizeof(num, suffix=''):\n@@ -70,148 +70,6 @@ def format_interval(t):\n         return '{0:02d}:{1:02d}'.format(m, s)\n \n \n-def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n-                 unit='it', unit_scale=False, rate=None, bar_format=None):\n-    \"\"\"\n-    Return a string-based progress bar given some parameters\n-\n-    Parameters\n-    ----------\n-    n  : int\n-        Number of finished iterations.\n-    total  : int\n-        The expected total number of iterations. If meaningless (), only\n-        basic progress statistics are displayed (no ETA).\n-    elapsed  : float\n-        Number of seconds passed since start.\n-    ncols  : int, optional\n-        The width of the entire output message. If specified, dynamically\n-        resizes the progress meter to stay within this bound\n-        [default: None]. The fallback meter width is 10 for the progress bar\n-        + no limit for the iterations counter and statistics. If 0, will not\n-        print any meter (only stats).\n-    prefix  : str, optional\n-        Prefix message (included in total width) [default: ''].\n-    ascii  : bool, optional\n-        If not set, use unicode (smooth blocks) to fill the meter\n-        [default: False]. The fallback is to use ASCII characters (1-9 #).\n-    unit  : str, optional\n-        The iteration unit [default: 'it'].\n-    unit_scale  : bool, optional\n-        If set, the number of iterations will printed with an appropriate\n-        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n-    rate  : float, optional\n-        Manual override for iteration rate.\n-        If [default: None], uses n/elapsed.\n-    bar_format  : str, optional\n-        Specify a custom bar string formatting. May impact performance.\n-        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n-        '{desc}{percentage:3.0f}%|' and r_bar is\n-        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n-        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n-        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n-\n-    Returns\n-    -------\n-    out  : Formatted meter and stats, ready to display.\n-    \"\"\"\n-\n-    # sanity check: total\n-    if total and n > total:\n-        total = None\n-\n-    elapsed_str = format_interval(elapsed)\n-\n-    # if unspecified, attempt to use rate = average speed\n-    # (we allow manual override since predicting time is an arcane art)\n-    if rate is None and elapsed:\n-        rate = n / elapsed\n-    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n-    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n-                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n-                if elapsed else '?') \\\n-        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n-\n-    if unit_scale:\n-        n_fmt = format_sizeof(n)\n-        total_fmt = format_sizeof(total) if total else None\n-    else:\n-        n_fmt = str(n)\n-        total_fmt = str(total)\n-\n-    # total is known: we can predict some stats\n-    if total:\n-        # fractional and percentage progress\n-        frac = n / total\n-        percentage = frac * 100\n-\n-        remaining_str = format_interval((total - n) / rate) if rate else '?'\n-\n-        # format the stats displayed to the left and right sides of the bar\n-        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n-        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n-                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n-\n-        if ncols == 0:\n-            return l_bar[:-1] + r_bar[1:]\n-\n-        # space available for bar's display\n-        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n-            else 10\n-\n-        # format bar depending on availability of unicode/ascii chars\n-        if ascii:\n-            bar_length, frac_bar_length = divmod(\n-                int(frac * N_BARS * 10), 10)\n-\n-            bar = '#' * bar_length\n-            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n-                else ' '\n-\n-        else:\n-            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n-\n-            bar = _unich(0x2588) * bar_length\n-            frac_bar = _unich(0x2590 - frac_bar_length) \\\n-                if frac_bar_length else ' '\n-\n-        # whitespace padding\n-        if bar_length < N_BARS:\n-            full_bar = bar + frac_bar + \\\n-                ' ' * max(N_BARS - bar_length - 1, 0)\n-        else:\n-            full_bar = bar + \\\n-                ' ' * max(N_BARS - bar_length, 0)\n-\n-        if bar_format is None:\n-            # Default bar format = fast display\n-            return l_bar + full_bar + r_bar\n-        else:\n-            # Custom bar formatting\n-            # Populate a dict with all available progress indicators\n-            bar_args = {'bar': full_bar,\n-                        'n': n,\n-                        'n_fmt': n_fmt,\n-                        'total': total,\n-                        'total_fmt': total_fmt,\n-                        'percentage': percentage,\n-                        'rate': rate,\n-                        'rate_fmt': rate_fmt,\n-                        'elapsed': elapsed_str,\n-                        'remaining': remaining_str,\n-                        'l_bar': l_bar,\n-                        'r_bar': r_bar,\n-                        'desc': prefix if prefix else ''\n-                        }\n-            # Interpolate supplied bar format with the dict\n-            return bar_format.format(**bar_args)\n-\n-    # no total: no progressbar, ETA, just progress stats\n-    else:\n-        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n-            n_fmt, unit, elapsed_str, rate_fmt)\n-\n-\n def StatusPrinter(file):\n     \"\"\"\n     Manage the printing and in-place updating of a line of characters.\n@@ -238,6 +96,154 @@ class tqdm(object):\n     like the original iterable, but prints a dynamically updating\n     progressbar every time a value is requested.\n     \"\"\"\n+    @classmethod\n+    def format_meter(cls, n, total, elapsed, ncols=None, prefix='',\n+                     ascii=False, unit='it', unit_scale=False, rate=None,\n+                     bar_format=None):\n+        \"\"\"\n+        Return a string-based progress bar given some parameters\n+\n+        Parameters\n+        ----------\n+        n  : int\n+            Number of finished iterations.\n+        total  : int\n+            The expected total number of iterations. If meaningless (), only\n+            basic progress statistics are displayed (no ETA).\n+        elapsed  : float\n+            Number of seconds passed since start.\n+        ncols  : int, optional\n+            The width of the entire output message. If specified,\n+            dynamically resizes the progress meter to stay within this bound\n+            [default: None]. The fallback meter width is 10 for the progress\n+            bar + no limit for the iterations counter and statistics. If 0,\n+            will not print any meter (only stats).\n+        prefix  : str, optional\n+            Prefix message (included in total width) [default: ''].\n+        ascii  : bool, optional\n+            If not set, use unicode (smooth blocks) to fill the meter\n+            [default: False]. The fallback is to use ASCII characters\n+            (1-9 #).\n+        unit  : str, optional\n+            The iteration unit [default: 'it'].\n+        unit_scale  : bool, optional\n+            If set, the number of iterations will printed with an\n+            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n+            [default: False].\n+        rate  : float, optional\n+            Manual override for iteration rate.\n+            If [default: None], uses n/elapsed.\n+        bar_format  : str, optional\n+            Specify a custom bar string formatting. May impact performance.\n+            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n+            '{desc}{percentage:3.0f}%|' and r_bar is\n+            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n+            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n+            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n+\n+        Returns\n+        -------\n+        out  : Formatted meter and stats, ready to display.\n+        \"\"\"\n+\n+        # sanity check: total\n+        if total and n > total:\n+            total = None\n+\n+        elapsed_str = format_interval(elapsed)\n+\n+        # if unspecified, attempt to use rate = average speed\n+        # (we allow manual override since predicting time is an arcane art)\n+        if rate is None and elapsed:\n+            rate = n / elapsed\n+        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n+        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n+                    if unit_scale else\n+                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n+                    if elapsed else '?') \\\n+            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n+\n+        if unit_scale:\n+            n_fmt = format_sizeof(n)\n+            total_fmt = format_sizeof(total) if total else None\n+        else:\n+            n_fmt = str(n)\n+            total_fmt = str(total)\n+\n+        # total is known: we can predict some stats\n+        if total:\n+            # fractional and percentage progress\n+            frac = n / total\n+            percentage = frac * 100\n+\n+            remaining_str = format_interval((total - n) / rate) \\\n+                if rate else '?'\n+\n+            # format the stats displayed to the left and right sides of the bar\n+            l_bar = (prefix if prefix else '') + \\\n+                '{0:3.0f}%|'.format(percentage)\n+            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n+                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n+\n+            if ncols == 0:\n+                return l_bar[:-1] + r_bar[1:]\n+\n+            # space available for bar's display\n+            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n+                else 10\n+\n+            # format bar depending on availability of unicode/ascii chars\n+            if ascii:\n+                bar_length, frac_bar_length = divmod(\n+                    int(frac * N_BARS * 10), 10)\n+\n+                bar = '#' * bar_length\n+                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n+                    else ' '\n+\n+            else:\n+                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n+\n+                bar = _unich(0x2588) * bar_length\n+                frac_bar = _unich(0x2590 - frac_bar_length) \\\n+                    if frac_bar_length else ' '\n+\n+            # whitespace padding\n+            if bar_length < N_BARS:\n+                full_bar = bar + frac_bar + \\\n+                    ' ' * max(N_BARS - bar_length - 1, 0)\n+            else:\n+                full_bar = bar + \\\n+                    ' ' * max(N_BARS - bar_length, 0)\n+\n+            if bar_format is None:\n+                # Default bar format = fast display\n+                return l_bar + full_bar + r_bar\n+            else:\n+                # Custom bar formatting\n+                # Populate a dict with all available progress indicators\n+                bar_args = {'bar': full_bar,\n+                            'n': n,\n+                            'n_fmt': n_fmt,\n+                            'total': total,\n+                            'total_fmt': total_fmt,\n+                            'percentage': percentage,\n+                            'rate': rate,\n+                            'rate_fmt': rate_fmt,\n+                            'elapsed': elapsed_str,\n+                            'remaining': remaining_str,\n+                            'l_bar': l_bar,\n+                            'r_bar': r_bar,\n+                            'desc': prefix if prefix else ''\n+                            }\n+                # Interpolate supplied bar format with the dict\n+                return bar_format.format(**bar_args)\n+\n+        # no total: no progressbar, ETA, just progress stats\n+        else:\n+            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n+                n_fmt, unit, elapsed_str, rate_fmt)\n+\n     def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                  file=sys.stderr, ncols=None, mininterval=0.1,\n                  maxinterval=10.0, miniters=None, ascii=None,\n@@ -392,7 +398,7 @@ class tqdm(object):\n             if not disable:\n                 if self.nested:\n                     self.fp.write('\\n')\n-                self.sp(format_meter(self.n, total, 0,\n+                self.sp(self.format_meter(self.n, total, 0,\n                         (dynamic_ncols(file) if dynamic_ncols else ncols),\n                         self.desc, ascii, unit, unit_scale, None, bar_format))\n \n@@ -437,6 +443,7 @@ class tqdm(object):\n             smoothing = self.smoothing\n             avg_time = self.avg_time\n             bar_format = self.bar_format\n+            format_meter = self.format_meter\n \n             try:\n                 sp = self.sp\n@@ -540,12 +547,13 @@ class tqdm(object):\n                     raise DeprecationWarning('Please use tqdm_gui(...)'\n                                              ' instead of tqdm(..., gui=True)')\n \n-                self.sp(format_meter(\n+                self.sp(self.format_meter(\n                     self.n, self.total, elapsed,\n                     (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                      else self.ncols),\n                     self.desc, self.ascii, self.unit, self.unit_scale,\n-                    1 / self.avg_time if self.avg_time else None, self.bar_format))\n+                    1 / self.avg_time if self.avg_time else None,\n+                    self.bar_format))\n \n                 # If no `miniters` was specified, adjust automatically to the\n                 # maximum iteration rate seen so far.\n@@ -579,7 +587,7 @@ class tqdm(object):\n             if self.last_print_n < self.n:\n                 cur_t = time()\n                 # stats for overall rate (no weighted average)\n-                self.sp(format_meter(\n+                self.sp(self.format_meter(\n                     self.n, self.total, cur_t - self.start_t,\n                     (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                      else self.ncols),\n",
          "files_name_in_blame_commit": [
            "__init__.py",
            "_tqdm.py",
            "tests_tqdm.py",
            "_tqdm_gui.py"
          ]
        }
      },
      "b47abc54999cb2e259681555ef08b9a5c8141b81": {
        "commit": {
          "commit_id": "b47abc54999cb2e259681555ef08b9a5c8141b81",
          "commit_message": "fix unit tests, safer unit tests with setup/teardown, full coverage, fix flake8",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2016-01-10 21:37:47",
          "commit_parent": "f2246bb60cf3cc547ebe7874f95dca84ed543d29"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 73,
          "function_before_end_line": 212,
          "function_after_start_line": 73,
          "function_after_end_line": 213,
          "function_before_token_count": 490,
          "function_after_token_count": 490,
          "functions_name_modified_file": [
            "trange",
            "_decr_instances",
            "_incr_instances",
            "set_description",
            "format_sizeof",
            "__enter__",
            "__hash__",
            "__iter__",
            "__le__",
            "__ge__",
            "close",
            "__lt__",
            "__gt__",
            "moveto",
            "__eq__",
            "__repr__",
            "__init__",
            "update",
            "__del__",
            "StatusPrinter",
            "__len__",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_ascii",
            "test_iterate_over_csv_rows",
            "_decr_instances",
            "pretest",
            "test_repr",
            "test_no_gui",
            "_incr_instances",
            "set_description",
            "test_bar_format",
            "closing",
            "format_sizeof",
            "test_set_description",
            "test_si_format",
            "test_close",
            "get_bar",
            "tic",
            "test_iter_overhead",
            "__enter__",
            "__hash__",
            "__iter__",
            "posttest",
            "toc",
            "test_min_interval",
            "__le__",
            "test_trange",
            "test_update",
            "test_min_iters",
            "__ge__",
            "test_cmp",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "__lt__",
            "test_leave_option",
            "test_format_meter",
            "__gt__",
            "moveto",
            "__eq__",
            "test_position",
            "__repr__",
            "test_unit",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "progressbar_rate",
            "update",
            "__del__",
            "test_smoothing",
            "StatusPrinter",
            "test_file_output",
            "test_max_interval",
            "test_big_min_interval",
            "__len__",
            "test_nested",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "__ne__",
            "unpause",
            "test_manual_overhead",
            "format_interval",
            "format_meter",
            "__exit__",
            "test_format_interval",
            "test_unpause"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_disable",
            "test_close",
            "test_smoothing",
            "pretest",
            "test_dynamic_min_iters",
            "test_no_gui",
            "test_max_interval",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "test_bar_format",
            "test_manual_overhead",
            "test_update",
            "posttest",
            "test_position",
            "test_cmp",
            "test_smoothed_dynamic_min_iters"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 395,
          "file_complexity": 136,
          "file_token_count": 2642,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if rate else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix if prefix else ''\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write(_unicode('\\r' + s + (' ' * max(last_printed_len[0] - len_s,\n                                                0))))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    n_instances = 0\n    _instances = set()\n\n    @classmethod\n    def _incr_instances(cls, instance):\n        cls.n_instances += 1\n        cls._instances.add(instance)\n        return cls.n_instances\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        cls.n_instances -= 1\n        # Remove from list and reposition other bars\n        # so that newer bars won't overlap previous bars\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, position=None, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar [default: 0].\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            return\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n        self.closed = False\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            self.pos = self._incr_instances(self) - 1 \\\n                if position is None else position\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.pos:\n                    self.moveto(self.pos)\n                elif self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n                if self.pos:\n                    self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return format_meter(self.n, self.total, time() - self.last_print_t,\n                            self.ncols, self.desc, self.ascii, self.unit,\n                            self.unit_scale, self.avg_rate, self.bar_format)\n\n    def __lt__(self, other):\n        return self.pos < other.pos\n\n    def __le__(self, other):\n        return self.pos <= other.pos\n\n    def __eq__(self, other):\n        return self.pos == other.pos\n\n    def __ne__(self, other):\n        return self.pos != other.pos\n\n    def __gt__(self, other):\n        return self.pos > other.pos\n\n    def __ge__(self, other):\n        return self.pos >= other.pos\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            bar_format = self.bar_format\n            fp = self.fp\n\n            try:\n                sp = self.sp\n                pos = self.pos\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        if pos:\n                            fp.write('\\n' * pos + _term_move_up() * -pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate,\n                            bar_format))\n\n                        if pos:\n                            fp.write('\\n' * -pos + _term_move_up() * pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not (hasattr(self, \"sp\") and hasattr(self, \"pos\")):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate, self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        if self.closed:\n            return\n        self.closed = True\n\n        self._decr_instances(self)\n\n        # only for unit testing\n        if not hasattr(self, \"sp\"):\n            # raise AttributeError(\"object has no attribute 'sp'\")\n            # Fail silently since __del__() cannot throw errors properly\n            return\n\n        try:\n            self.fp.write(_unicode(''))\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n\n        if self.pos:\n            self.moveto(self.pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                stats = format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format)\n                self.sp(stats)\n            self.fp.write('\\r' + _term_move_up()\n                          if (self.nested and not self.pos) else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write(_unicode('\\r' + _term_move_up()\n                                   if (self.nested and not self.pos) else '\\r'))\n\n        if self.pos:\n            self.moveto(-self.pos)\n            if self.leave:\n                self.moveto(-1)\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                 if unit_scale else\n                 '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if rate else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix if prefix else ''\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write(_unicode('\\r' + s + (' ' * max(last_printed_len[0] - len_s,\n                                                0))))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    n_instances = 0\n    _instances = set()\n\n    @classmethod\n    def _incr_instances(cls, instance):\n        cls.n_instances += 1\n        cls._instances.add(instance)\n        return cls.n_instances\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        cls.n_instances -= 1\n        # Remove from list and reposition other bars\n        # so that newer bars won't overlap previous bars\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, position=None, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar [default: 0].\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            return\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n        self.closed = False\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            self.pos = self._incr_instances(self) - 1 \\\n                if position is None else position\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.pos:\n                    self.moveto(self.pos)\n                elif self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n                if self.pos:\n                    self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return format_meter(self.n, self.total, time() - self.last_print_t,\n                            self.ncols, self.desc, self.ascii, self.unit,\n                            self.unit_scale, self.avg_rate, self.bar_format)\n\n    def __lt__(self, other):\n        return self.pos < other.pos\n\n    def __le__(self, other):\n        return self.pos <= other.pos\n\n    def __eq__(self, other):\n        return self.pos == other.pos\n\n    def __ne__(self, other):\n        return self.pos != other.pos\n\n    def __gt__(self, other):\n        return self.pos > other.pos\n\n    def __ge__(self, other):\n        return self.pos >= other.pos\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            bar_format = self.bar_format\n            fp = self.fp\n\n            try:\n                sp = self.sp\n                pos = self.pos\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        if pos:\n                            fp.write('\\n' * pos + _term_move_up() * -pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate,\n                            bar_format))\n\n                        if pos:\n                            fp.write('\\n' * -pos + _term_move_up() * pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not (hasattr(self, \"sp\") and hasattr(self, \"pos\")):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate, self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        if self.closed:\n            return\n        self.closed = True\n\n        self._decr_instances(self)\n\n        # only for unit testing\n        if not hasattr(self, \"sp\"):\n            # raise AttributeError(\"object has no attribute 'sp'\")\n            # Fail silently since __del__() cannot throw errors properly\n            return\n\n        try:\n            self.fp.write(_unicode(''))\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n\n        if self.pos:\n            self.moveto(self.pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                stats = format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format)\n                self.sp(stats)\n            self.fp.write('\\r' + _term_move_up()\n                          if (self.nested and not self.pos) else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write(_unicode('\\r' + _term_move_up()\n                                   if (self.nested and not self.pos) else '\\r'))\n\n        if self.pos:\n            self.moveto(-self.pos)\n            if self.leave:\n                self.moveto(-1)\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -127,8 +127,9 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     if rate is None and elapsed:\n         rate = n / elapsed\n     inv_rate = 1 / rate if (rate and (rate < 1)) else None\n-    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n-                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n+    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n+                 if unit_scale else\n+                 '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                 if rate else '?') \\\n         + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n \n",
          "files_name_in_blame_commit": [
            "tests_perf.py",
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "a34a7699f2aa645be1a13c121270df2ca7023f33": {
        "commit": {
          "commit_id": "a34a7699f2aa645be1a13c121270df2ca7023f33",
          "commit_message": "fix unit tests, coverage, added some functions, master rebase, fix py3 exception handling",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2016-01-10 21:30:39",
          "commit_parent": "ee0115a6c506a803f5d44b3b37fc8e35ee175b98"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if rate else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 73,
          "function_before_end_line": 212,
          "function_after_start_line": 73,
          "function_after_end_line": 212,
          "function_before_token_count": 490,
          "function_after_token_count": 490,
          "functions_name_modified_file": [
            "trange",
            "_decr_instances",
            "_incr_instances",
            "set_description",
            "format_sizeof",
            "__enter__",
            "__iter__",
            "__le__",
            "__ge__",
            "close",
            "__lt__",
            "__gt__",
            "moveto",
            "__eq__",
            "__repr__",
            "__init__",
            "update",
            "__del__",
            "StatusPrinter",
            "__len__",
            "__ne__",
            "unpause",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_ascii",
            "test_iterate_over_csv_rows",
            "_decr_instances",
            "test_repr",
            "test_no_gui",
            "_incr_instances",
            "set_description",
            "test_bar_format",
            "closing",
            "format_sizeof",
            "test_set_description",
            "test_si_format",
            "test_close",
            "get_bar",
            "tic",
            "test_iter_overhead",
            "__enter__",
            "__iter__",
            "test_min_interval",
            "toc",
            "__le__",
            "test_trange",
            "test_update",
            "test_min_iters",
            "__ge__",
            "test_cmp",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "__lt__",
            "test_leave_option",
            "test_format_meter",
            "__gt__",
            "moveto",
            "__eq__",
            "test_position",
            "__repr__",
            "test_unit",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "progressbar_rate",
            "update",
            "__del__",
            "test_smoothing",
            "StatusPrinter",
            "test_file_output",
            "test_max_interval",
            "test_big_min_interval",
            "__len__",
            "test_nested",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "__ne__",
            "unpause",
            "test_manual_overhead",
            "format_interval",
            "format_meter",
            "__exit__",
            "test_format_interval",
            "test_unpause"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "close",
            "update",
            "__del__",
            "StatusPrinter",
            "_decr_instances",
            "__lt__",
            "_incr_instances",
            "__iter__",
            "__ne__",
            "__gt__",
            "moveto",
            "__le__",
            "__eq__",
            "__repr__",
            "__ge__"
          ],
          "functions_name_co_evolved_all_files": [
            "test_disable",
            "test_ascii",
            "_decr_instances",
            "test_repr",
            "test_no_gui",
            "_incr_instances",
            "test_bar_format",
            "test_set_description",
            "test_close",
            "get_bar",
            "__iter__",
            "__le__",
            "test_update",
            "__ge__",
            "test_cmp",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "__lt__",
            "test_format_meter",
            "__gt__",
            "moveto",
            "__eq__",
            "test_position",
            "__repr__",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "update",
            "__del__",
            "test_smoothing",
            "StatusPrinter",
            "test_big_min_interval",
            "test_max_interval",
            "test_nested",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "__ne__",
            "test_manual_overhead",
            "test_unpause"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 383,
          "file_complexity": 132,
          "file_token_count": 2577,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if elapsed else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix if prefix else ''\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, position=0, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar. Useful to manage\n            multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n        self.pos = position\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                if self.pos:\n                    self.moveto(self.pos)\n                self.sp(format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n                if self.pos:\n                    self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            bar_format = self.bar_format\n            pos = self.pos\n            fp = self.fp\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        if pos:\n                            fp.write('\\n' * pos + _term_move_up() * -pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate,\n                            bar_format))\n\n                        if pos:\n                            fp.write('\\n' * -pos + _term_move_up() * pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate, self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.pos:\n            self.moveto(self.pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n        if self.pos:\n            self.moveto(-self.pos)\n            if self.leave:\n                self.moveto(-1)\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write('\\n' * n + _term_move_up() * -n)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if rate else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix if prefix else ''\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write(_unicode('\\r' + s + (' ' * max(last_printed_len[0] - len_s,\n                                                0))))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    n_instances = 0\n\n    @classmethod\n    def _incr_instances(cls):\n        cls.n_instances += 1\n        return cls.n_instances\n\n    @classmethod\n    def _decr_instances(cls):\n        cls.n_instances -= 1\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None,\n                 disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, nested=False,\n                 bar_format=None, initial=0, position=None, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar [default: 0].\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            return\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n        self.closed = False\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        if not gui:\n            self.pos = self._incr_instances() - 1 \\\n                if position is None else position\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.pos:\n                    self.moveto(self.pos)\n                elif self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(self.n, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n                if self.pos:\n                    self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = time()\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self):\n        return format_meter(self.n, self.total, time() - self.last_print_t,\n                            self.ncols, self.desc, self.ascii, self.unit,\n                            self.unit_scale, self.avg_rate, self.bar_format)\n\n    def __lt__(self, other):\n        return self.pos < other.pos\n\n    def __le__(self, other):\n        return self.pos <= other.pos\n\n    def __eq__(self, other):\n        return self.pos == other.pos\n\n    def __ne__(self, other):\n        return self.pos != other.pos\n\n    def __gt__(self, other):\n        return self.pos > other.pos\n\n    def __ge__(self, other):\n        return self.pos >= other.pos\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            bar_format = self.bar_format\n            fp = self.fp\n\n            try:\n                sp = self.sp\n                pos = self.pos\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        if pos:\n                            fp.write('\\n' * pos + _term_move_up() * -pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate,\n                            bar_format))\n\n                        if pos:\n                            fp.write('\\n' * -pos + _term_move_up() * pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not (hasattr(self, \"sp\") and hasattr(self, \"pos\")):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate, self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        if self.closed:\n            return\n        self.closed = True\n\n        self._decr_instances()\n\n        # only for unit testing\n        if not hasattr(self, \"sp\"):\n            # raise AttributeError(\"object has no attribute 'sp'\")\n            # Fail silently since __del__() cannot throw errors properly\n            return\n\n        try:\n            self.fp.write(_unicode(''))\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n\n        if self.pos:\n            self.moveto(self.pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                stats = format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format)\n                self.sp(stats)\n            self.fp.write('\\r' + _term_move_up()\n                          if (self.nested and not self.pos) else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write(_unicode('\\r' + _term_move_up()\n                                   if (self.nested and not self.pos) else '\\r'))\n\n        if self.pos:\n            self.moveto(-self.pos)\n            if self.leave:\n                self.moveto(-1)\n\n    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -129,7 +129,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     inv_rate = 1 / rate if (rate and (rate < 1)) else None\n     rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                 else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n-                if elapsed else '?') \\\n+                if rate else '?') \\\n         + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n \n     if unit_scale:\n@@ -226,7 +226,8 @@ def StatusPrinter(file):\n \n     def print_status(s):\n         len_s = len(s)\n-        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n+        fp.write(_unicode('\\r' + s + (' ' * max(last_printed_len[0] - len_s,\n+                                                0))))\n         fp.flush()\n         last_printed_len[0] = len_s\n     return print_status\n@@ -238,12 +239,23 @@ class tqdm(object):\n     like the original iterable, but prints a dynamically updating\n     progressbar every time a value is requested.\n     \"\"\"\n+    n_instances = 0\n+\n+    @classmethod\n+    def _incr_instances(cls):\n+        cls.n_instances += 1\n+        return cls.n_instances\n+\n+    @classmethod\n+    def _decr_instances(cls):\n+        cls.n_instances -= 1\n+\n     def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                  file=sys.stderr, ncols=None, mininterval=0.1,\n                  maxinterval=10.0, miniters=None, ascii=None,\n                  disable=False, unit='it', unit_scale=False,\n                  dynamic_ncols=False, smoothing=0.3, nested=False,\n-                 bar_format=None, initial=0, position=0, gui=False):\n+                 bar_format=None, initial=0, position=None, gui=False):\n         \"\"\"\n         Parameters\n         ----------\n@@ -313,8 +325,8 @@ class tqdm(object):\n             The initial counter value. Useful when restarting a progress\n             bar [default: 0].\n         position  : int, optional\n-            Specify the line offset to print this bar. Useful to manage\n-            multiple bars at once (eg, from threads).\n+            Specify the line offset to print this bar [default: 0].\n+            Useful to manage multiple bars at once (eg, from threads).\n         gui  : bool, optional\n             WARNING: internal parameter - do not use.\n             Use tqdm_gui(...) instead. If set, will attempt to use\n@@ -324,6 +336,11 @@ class tqdm(object):\n         -------\n         out  : decorated iterator.\n         \"\"\"\n+        if disable:\n+            self.iterable = iterable\n+            self.disable = disable\n+            return\n+\n         # Preprocess the arguments\n         if total is None and iterable is not None:\n             try:\n@@ -384,20 +401,22 @@ class tqdm(object):\n         # not overwrite the outer progress bar\n         self.nested = nested\n         self.bar_format = bar_format\n-        self.pos = position\n+        self.closed = False\n \n         # Init the iterations counters\n         self.last_print_n = initial\n         self.n = initial\n \n         if not gui:\n+            self.pos = self._incr_instances() - 1 \\\n+                if position is None else position\n             # Initialize the screen printer\n             self.sp = StatusPrinter(self.fp)\n             if not disable:\n-                if self.nested:\n-                    self.fp.write('\\n')\n                 if self.pos:\n                     self.moveto(self.pos)\n+                elif self.nested:\n+                    self.fp.write('\\n')\n                 self.sp(format_meter(self.n, total, 0,\n                         (dynamic_ncols(file) if dynamic_ncols else ncols),\n                         self.desc, ascii, unit, unit_scale, None, bar_format))\n@@ -417,6 +436,32 @@ class tqdm(object):\n         self.close()\n         return False\n \n+    def __del__(self):\n+        self.close()\n+\n+    def __repr__(self):\n+        return format_meter(self.n, self.total, time() - self.last_print_t,\n+                            self.ncols, self.desc, self.ascii, self.unit,\n+                            self.unit_scale, self.avg_rate, self.bar_format)\n+\n+    def __lt__(self, other):\n+        return self.pos < other.pos\n+\n+    def __le__(self, other):\n+        return self.pos <= other.pos\n+\n+    def __eq__(self, other):\n+        return self.pos == other.pos\n+\n+    def __ne__(self, other):\n+        return self.pos != other.pos\n+\n+    def __gt__(self, other):\n+        return self.pos > other.pos\n+\n+    def __ge__(self, other):\n+        return self.pos >= other.pos\n+\n     def __iter__(self):\n         ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n \n@@ -445,11 +490,11 @@ class tqdm(object):\n             smoothing = self.smoothing\n             avg_rate = self.avg_rate\n             bar_format = self.bar_format\n-            pos = self.pos\n             fp = self.fp\n \n             try:\n                 sp = self.sp\n+                pos = self.pos\n             except AttributeError:\n                 raise DeprecationWarning('Please use tqdm_gui(...)'\n                                          ' instead of tqdm(..., gui=True)')\n@@ -553,7 +598,7 @@ class tqdm(object):\n                         else self.smoothing * delta_it / delta_t + \\\n                         (1 - self.smoothing) * self.avg_rate\n \n-                if not hasattr(self, \"sp\"):\n+                if not (hasattr(self, \"sp\") and hasattr(self, \"pos\")):\n                     raise DeprecationWarning('Please use tqdm_gui(...)'\n                                              ' instead of tqdm(..., gui=True)')\n \n@@ -599,6 +644,25 @@ class tqdm(object):\n         if self.disable:\n             return\n \n+        # Prevent multiple closures\n+        if self.closed:\n+            return\n+        self.closed = True\n+\n+        self._decr_instances()\n+\n+        # only for unit testing\n+        if not hasattr(self, \"sp\"):\n+            # raise AttributeError(\"object has no attribute 'sp'\")\n+            # Fail silently since __del__() cannot throw errors properly\n+            return\n+\n+        try:\n+            self.fp.write(_unicode(''))\n+        except ValueError as e:\n+            if 'closed' in str(e):\n+                return\n+\n         if self.pos:\n             self.moveto(self.pos)\n \n@@ -606,16 +670,19 @@ class tqdm(object):\n             if self.last_print_n < self.n:\n                 cur_t = time()\n                 # stats for overall rate (no weighted average)\n-                self.sp(format_meter(\n+                stats = format_meter(\n                     self.n, self.total, cur_t - self.start_t,\n                     (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                      else self.ncols),\n                     self.desc, self.ascii, self.unit, self.unit_scale, None,\n-                    self.bar_format))\n-            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n+                    self.bar_format)\n+                self.sp(stats)\n+            self.fp.write('\\r' + _term_move_up()\n+                          if (self.nested and not self.pos) else '\\n')\n         else:\n             self.sp('')  # clear up last bar\n-            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n+            self.fp.write(_unicode('\\r' + _term_move_up()\n+                                   if (self.nested and not self.pos) else '\\r'))\n \n         if self.pos:\n             self.moveto(-self.pos)\n@@ -637,7 +704,7 @@ class tqdm(object):\n         self.desc = desc + ': ' if desc else ''\n \n     def moveto(self, n):\n-        self.fp.write('\\n' * n + _term_move_up() * -n)\n+        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n \n \n def trange(*args, **kwargs):\n",
          "files_name_in_blame_commit": [
            "tests_perf.py",
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "5af1135108fa7178f1c88801569b81613c87d497": {
        "commit": {
          "commit_id": "5af1135108fa7178f1c88801569b81613c87d497",
          "commit_message": "docstring tidying",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-12-27 17:08:17",
          "commit_parent": "f285b731a4c18d6f6466580f0a69b32ce51486a9"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        Format: r'{var1}{var2}{etc.}'. Possible vars: bar, n, n_fmt, total,\n        total_fmt, percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix if prefix else ''}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 73,
          "function_before_end_line": 208,
          "function_after_start_line": 73,
          "function_after_end_line": 212,
          "function_before_token_count": 483,
          "function_after_token_count": 490,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__enter__",
            "__iter__",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__enter__",
            "__iter__",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 308,
          "file_complexity": 102,
          "file_token_count": 2059,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        Format: r'{var1}{var2}{etc.}'. Possible vars: bar, n, n_fmt, total,\n        total_fmt, percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if elapsed else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, nested=False, bar_format=None, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May slow down performances.\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            bar_format = self.bar_format\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate,\n                            bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate, self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if elapsed else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix if prefix else ''\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, nested=False, bar_format=None, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            bar_format = self.bar_format\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate,\n                            bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate, self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -105,8 +105,11 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n         If [default: None], uses n/elapsed.\n     bar_format  : str, optional\n         Specify a custom bar string formatting. May impact performance.\n-        Format: r'{var1}{var2}{etc.}'. Possible vars: bar, n, n_fmt, total,\n-        total_fmt, percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar\n+        [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n+        '{desc}{percentage:3.0f}%|' and r_bar is\n+        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n+        Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n+        rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n \n     Returns\n     -------\n@@ -198,6 +201,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                         'remaining': remaining_str,\n                         'l_bar': l_bar,\n                         'r_bar': r_bar,\n+                        'desc': prefix if prefix else ''\n                         }\n             # Interpolate supplied bar format with the dict\n             return bar_format.format(**bar_args)\n@@ -298,7 +302,12 @@ class tqdm(object):\n             `tqdm` [default: False]. Allows display of multiple, nested\n             progress bars.\n         bar_format  : str, optional\n-            Specify a custom bar string formatting. May slow down performances.\n+            Specify a custom bar string formatting. May impact performance.\n+            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n+            '{desc}{percentage:3.0f}%|' and r_bar is\n+            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'.\n+            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n+            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n         gui  : bool, optional\n             WARNING: internal parameter - do not use.\n             Use tqdm_gui(...) instead. If set, will attempt to use\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "f285b731a4c18d6f6466580f0a69b32ce51486a9": {
        "commit": {
          "commit_id": "f285b731a4c18d6f6466580f0a69b32ce51486a9",
          "commit_message": "Add custom bar formatting",
          "commit_author": "Stephen L",
          "commit_date": "2015-12-27 17:08:07",
          "commit_parent": "a25b4d25d9af9e887e90b81f959fbfa11a422358"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        Format: r'{var1}{var2}{etc.}'. Possible vars: bar, n, n_fmt, total,\n        total_fmt, percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        if bar_format is None:\n            return l_bar + full_bar + r_bar\n        else:\n            bar_args = {'bar': full_bar, 'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': rate, 'rate_fmt': rate_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar}\n            return bar_format.format(**bar_args)\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 73,
          "function_before_end_line": 184,
          "function_after_start_line": 73,
          "function_after_end_line": 208,
          "function_before_token_count": 412,
          "function_after_token_count": 483,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__enter__",
            "__iter__",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_ascii",
            "test_iterate_over_csv_rows",
            "_is_utf",
            "_supports_unicode",
            "test_no_gui",
            "set_description",
            "test_bar_format",
            "closing",
            "format_sizeof",
            "_environ_cols_tput",
            "test_set_description",
            "test_si_format",
            "test_close",
            "test_min_interval",
            "__enter__",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "_term_move_up",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "_environ_cols_windows",
            "test_leave_option",
            "_environ_cols_linux",
            "test_format_meter",
            "test_unit",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "progressbar_rate",
            "update",
            "test_smoothing",
            "StatusPrinter",
            "test_file_output",
            "test_max_interval",
            "test_big_min_interval",
            "__len__",
            "test_nested",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "_environ_cols_wrapper",
            "format_interval",
            "format_meter",
            "__exit__",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "__iter__",
            "update",
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "__init__",
            "update",
            "__iter__",
            "test_bar_format",
            "test_format_meter"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 307,
          "file_complexity": 101,
          "file_token_count": 2052,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if elapsed else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, nested=False, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up, _unicode\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        Format: r'{var1}{var2}{etc.}'. Possible vars: bar, n, n_fmt, total,\n        total_fmt, percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if elapsed else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        if bar_format is None:\n            # Default bar format = fast display\n            return l_bar + full_bar + r_bar\n        else:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'bar': full_bar,\n                        'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': rate,\n                        'rate_fmt': rate_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        }\n            # Interpolate supplied bar format with the dict\n            return bar_format.format(**bar_args)\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, nested=False, bar_format=None, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May slow down performances.\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Convert bar format into unicode since terminal uses unicode\n        if bar_format and not ascii:\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n        self.bar_format = bar_format\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale, None, bar_format))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            bar_format = self.bar_format\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate,\n                            bar_format))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate, self.bar_format))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n        else:\n            self.sp('')  # clear up last bar\n            self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -12,7 +12,7 @@ Usage:\n from __future__ import division, absolute_import\n # import compatibility functions and utilities\n from ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n-    _term_move_up\n+    _term_move_up, _unicode\n import sys\n from time import time\n \n@@ -71,7 +71,7 @@ def format_interval(t):\n \n \n def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n-                 unit='it', unit_scale=False, rate=None):\n+                 unit='it', unit_scale=False, rate=None, bar_format=None):\n     \"\"\"\n     Return a string-based progress bar given some parameters\n \n@@ -103,6 +103,10 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     rate  : float, optional\n         Manual override for iteration rate.\n         If [default: None], uses n/elapsed.\n+    bar_format  : str, optional\n+        Specify a custom bar string formatting. May impact performance.\n+        Format: r'{var1}{var2}{etc.}'. Possible vars: bar, n, n_fmt, total,\n+        total_fmt, percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar\n \n     Returns\n     -------\n@@ -176,7 +180,27 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n             full_bar = bar + \\\n                 ' ' * max(N_BARS - bar_length, 0)\n \n-        return l_bar + full_bar + r_bar\n+        if bar_format is None:\n+            # Default bar format = fast display\n+            return l_bar + full_bar + r_bar\n+        else:\n+            # Custom bar formatting\n+            # Populate a dict with all available progress indicators\n+            bar_args = {'bar': full_bar,\n+                        'n': n,\n+                        'n_fmt': n_fmt,\n+                        'total': total,\n+                        'total_fmt': total_fmt,\n+                        'percentage': percentage,\n+                        'rate': rate,\n+                        'rate_fmt': rate_fmt,\n+                        'elapsed': elapsed_str,\n+                        'remaining': remaining_str,\n+                        'l_bar': l_bar,\n+                        'r_bar': r_bar,\n+                        }\n+            # Interpolate supplied bar format with the dict\n+            return bar_format.format(**bar_args)\n \n     # no total: no progressbar, ETA, just progress stats\n     else:\n@@ -214,7 +238,7 @@ class tqdm(object):\n                  file=sys.stderr, ncols=None, mininterval=0.1,\n                  maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                  unit='it', unit_scale=False, dynamic_ncols=False,\n-                 smoothing=0.3, nested=False, gui=False):\n+                 smoothing=0.3, nested=False, bar_format=None, gui=False):\n         \"\"\"\n         Parameters\n         ----------\n@@ -273,6 +297,8 @@ class tqdm(object):\n             Whether this iterable is nested in another one also managed by\n             `tqdm` [default: False]. Allows display of multiple, nested\n             progress bars.\n+        bar_format  : str, optional\n+            Specify a custom bar string formatting. May slow down performances.\n         gui  : bool, optional\n             WARNING: internal parameter - do not use.\n             Use tqdm_gui(...) instead. If set, will attempt to use\n@@ -312,6 +338,10 @@ class tqdm(object):\n         if ascii is None:\n             ascii = not _supports_unicode(file)\n \n+        # Convert bar format into unicode since terminal uses unicode\n+        if bar_format and not ascii:\n+            bar_format = _unicode(bar_format)\n+\n         if smoothing is None:\n             smoothing = 0\n \n@@ -337,6 +367,7 @@ class tqdm(object):\n         # if nested, at initial sp() call we replace '\\r' by '\\n' to\n         # not overwrite the outer progress bar\n         self.nested = nested\n+        self.bar_format = bar_format\n \n         if not gui:\n             # Initialize the screen printer\n@@ -346,7 +377,7 @@ class tqdm(object):\n                     self.fp.write('\\n')\n                 self.sp(format_meter(0, total, 0,\n                         (dynamic_ncols(file) if dynamic_ncols else ncols),\n-                        self.desc, ascii, unit, unit_scale))\n+                        self.desc, ascii, unit, unit_scale, None, bar_format))\n \n         # Init the time/iterations counters\n         self.start_t = self.last_print_t = time()\n@@ -390,6 +421,7 @@ class tqdm(object):\n             dynamic_ncols = self.dynamic_ncols\n             smoothing = self.smoothing\n             avg_rate = self.avg_rate\n+            bar_format = self.bar_format\n \n             try:\n                 sp = self.sp\n@@ -420,7 +452,8 @@ class tqdm(object):\n                             n, self.total, elapsed,\n                             (dynamic_ncols(self.fp) if dynamic_ncols\n                              else ncols),\n-                            self.desc, ascii, unit, unit_scale, avg_rate))\n+                            self.desc, ascii, unit, unit_scale, avg_rate,\n+                            bar_format))\n \n                         # If no `miniters` was specified, adjust automatically\n                         # to the maximum iteration rate seen so far.\n@@ -497,7 +530,7 @@ class tqdm(object):\n                     (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                      else self.ncols),\n                     self.desc, self.ascii, self.unit, self.unit_scale,\n-                    self.avg_rate))\n+                    self.avg_rate, self.bar_format))\n \n                 # If no `miniters` was specified, adjust automatically to the\n                 # maximum iteration rate seen so far.\n@@ -535,10 +568,11 @@ class tqdm(object):\n                     self.n, self.total, cur_t - self.start_t,\n                     (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                      else self.ncols),\n-                    self.desc, self.ascii, self.unit, self.unit_scale))\n+                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n+                    self.bar_format))\n             self.fp.write('\\r' + _term_move_up() if self.nested else '\\n')\n         else:\n-            self.sp('')\n+            self.sp('')  # clear up last bar\n             self.fp.write('\\r' + _term_move_up() if self.nested else '\\r')\n \n     def set_description(self, desc=None):\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py",
            "_utils.py"
          ]
        }
      },
      "dc8eeedeb132e01943f4d13664b5b6e7831fc13a": {
        "commit": {
          "commit_id": "dc8eeedeb132e01943f4d13664b5b6e7831fc13a",
          "commit_message": "it/s versus s/it: addresses #72",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-12-27 16:32:02",
          "commit_parent": "6969610f12d5f8a47940976cb754dbce2c44a6b8"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate and rate < 1 else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale else '{0:5.2f}'.format(inv_rate if inv_rate else rate)) if elapsed else '?') + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 73,
          "function_before_end_line": 183,
          "function_after_start_line": 73,
          "function_after_end_line": 184,
          "function_before_token_count": 373,
          "function_after_token_count": 412,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__enter__",
            "__iter__",
            "set_description",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_ascii",
            "test_iterate_over_csv_rows",
            "test_no_gui",
            "set_description",
            "closing",
            "format_sizeof",
            "test_set_description",
            "test_si_format",
            "test_close",
            "test_min_interval",
            "__enter__",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "test_smoothed_dynamic_min_iters",
            "__init__",
            "progressbar_rate",
            "update",
            "test_smoothing",
            "StatusPrinter",
            "test_file_output",
            "test_max_interval",
            "test_big_min_interval",
            "__len__",
            "test_nested",
            "test_smoothed_dynamic_min_iters_with_min_interval",
            "format_interval",
            "format_meter",
            "__exit__",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_format_meter"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 291,
          "file_complexity": 98,
          "file_token_count": 1945,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, nested=False, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        gui  : bool, optional\n            WARNING: internal paramer - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        endchar = '\\r'\n        if self.nested:\n            endchar += _term_move_up()\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale))\n            if self.nested:\n                self.fp.write(endchar)\n            else:\n                self.fp.write('\\n')\n        else:\n            self.sp('')\n            self.fp.write(endchar)\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \\\n    _term_move_up\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                if elapsed else '?') \\\n        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, nested=False, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        nested  : bool, optional\n            Whether this iterable is nested in another one also managed by\n            `tqdm` [default: False]. Allows display of multiple, nested\n            progress bars.\n        gui  : bool, optional\n            WARNING: internal paramer - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.nested = nested\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                if self.nested:\n                    self.fp.write('\\n')\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        endchar = '\\r'\n        if self.nested:\n            endchar += _term_move_up()\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale))\n            if self.nested:\n                self.fp.write(endchar)\n            else:\n                self.fp.write('\\n')\n        else:\n            self.sp('')\n            self.fp.write(endchar)\n\n    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -119,10 +119,11 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     # (we allow manual override since predicting time is an arcane art)\n     if rate is None and elapsed:\n         rate = n / elapsed\n-    rate_fmt = ((format_sizeof(rate) if unit_scale else\n-                 '{0:5.2f}'.format(rate)) if elapsed else\n-                '?') \\\n-        + unit + '/s'\n+    inv_rate = 1 / rate if (rate and (rate < 1)) else None\n+    rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate) if unit_scale\n+                else '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n+                if elapsed else '?') \\\n+        + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n \n     if unit_scale:\n         n_fmt = format_sizeof(n)\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "4d9ec57cd988330eda8585d3f8512a7a05ce57fc": {
        "commit": {
          "commit_id": "4d9ec57cd988330eda8585d3f8512a7a05ce57fc",
          "commit_message": "help(tqdm) fits into 80-char terminal",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-11-28 20:27:43",
          "commit_parent": "9f37ac5b5ed7f64135fc0f0e6e090aa8b56b3925"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 72,
          "function_before_end_line": 181,
          "function_after_start_line": 72,
          "function_after_end_line": 182,
          "function_before_token_count": 373,
          "function_after_token_count": 373,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__enter__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_all_files": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__enter__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 278,
          "file_complexity": 87,
          "file_token_count": 1829,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' ' * max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progressbar to stay within this bound. If\n            [default: None], attempts to use environment width. The fallback\n            is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        gui  : bool, optional\n            WARNING: internal paramer - do not use. Use tqdm_gui(...) instead.\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale))\n            self.fp.write('\\n')\n        else:\n            self.sp('')\n            self.fp.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' ' * max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable)\n            is used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If [default: None], attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        gui  : bool, optional\n            WARNING: internal paramer - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_rate = delta_it / delta_t \\\n                                if avg_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * avg_rate\n\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_rate = delta_it / delta_t \\\n                        if self.avg_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.avg_rate\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                self.sp(format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                # stats for overall rate (no weighted average)\n                self.sp(format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale))\n            self.fp.write('\\n')\n        else:\n            self.sp('')\n            self.fp.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -79,8 +79,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     n  : int\n         Number of finished iterations.\n     total  : int\n-        The expected total number of iterations. If meaningless (), only basic\n-        progress statistics are displayed (no ETA).\n+        The expected total number of iterations. If meaningless (), only\n+        basic progress statistics are displayed (no ETA).\n     elapsed  : float\n         Number of seconds passed since start.\n     ncols  : int, optional\n@@ -100,7 +100,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n         If set, the number of iterations will printed with an appropriate\n         SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n     rate  : float, optional\n-        Manual override for iteration rate. If [default: None], uses n/elapsed.\n+        Manual override for iteration rate.\n+        If [default: None], uses n/elapsed.\n \n     Returns\n     -------\n@@ -221,8 +222,8 @@ class tqdm(object):\n         desc  : str, optional\n             Prefix for the progressbar [default: None].\n         total  : int, optional\n-            The number of expected iterations. If not given, len(iterable) is\n-            used if possible. As a last resort, only basic progress\n+            The number of expected iterations. If not given, len(iterable)\n+            is used if possible. As a last resort, only basic progress\n             statistics are displayed (no ETA, no progressbar). If `gui` is\n             True and this parameter needs subsequent updating, specify an\n             initial arbitrary large positive integer, e.g. int(9e9).\n@@ -234,10 +235,10 @@ class tqdm(object):\n             [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n             methods.\n         ncols  : int, optional\n-            The width of the entire output message. If specified, dynamically\n-            resizes the progressbar to stay within this bound. If\n-            [default: None], attempts to use environment width. The fallback\n-            is a meter width of 10 and no limit for the counter and\n+            The width of the entire output message. If specified,\n+            dynamically resizes the progressbar to stay within this bound.\n+            If [default: None], attempts to use environment width. The\n+            fallback is a meter width of 10 and no limit for the counter and\n             statistics. If 0, will not print any meter (only stats).\n         mininterval  : float, optional\n             Minimum progress update interval, in seconds [default: 0.1].\n@@ -249,7 +250,8 @@ class tqdm(object):\n             If [default: None] or false, use unicode (smooth blocks) to fill\n             the meter. The fallback is to use ASCII characters `1-9 #`.\n         disable : bool\n-            Whether to disable the entire progressbar wrapper [default: False].\n+            Whether to disable the entire progressbar wrapper\n+            [default: False].\n         unit  : str, optional\n             String that will be used to define the unit of each iteration\n             [default: 'it'].\n@@ -266,9 +268,9 @@ class tqdm(object):\n             (ignored in GUI mode). Ranges from 0 (average speed) to 1\n             (current/instantaneous speed) [default: 0.3].\n         gui  : bool, optional\n-            WARNING: internal paramer - do not use. Use tqdm_gui(...) instead.\n-            If set, will attempt to use matplotlib animations for a\n-            graphical output [default: false].\n+            WARNING: internal paramer - do not use.\n+            Use tqdm_gui(...) instead. If set, will attempt to use\n+            matplotlib animations for a graphical output [default: false].\n \n         Returns\n         -------\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "9dd7199e459411ecbb8b402e84ac2a94244e8808": {
        "commit": {
          "commit_id": "9dd7199e459411ecbb8b402e84ac2a94244e8808",
          "commit_message": "fix test, fix flake8, clean comments",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-11-10 16:50:51",
          "commit_parent": "7946b6f4c229094dcc97c37a73b794ead40d1d37"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) * (1 / rate)) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 72,
          "function_before_end_line": 188,
          "function_after_start_line": 72,
          "function_after_end_line": 181,
          "function_before_token_count": 377,
          "function_after_token_count": 373,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_iterate_over_csv_rows",
            "format_sizeof",
            "test_si_format",
            "test_close",
            "test_min_interval",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "__init__",
            "update",
            "test_smoothing",
            "StatusPrinter",
            "test_file_output",
            "test_big_min_interval",
            "__len__",
            "format_interval",
            "format_meter",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "__iter__",
            "update"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "__iter__",
            "update",
            "test_format_meter"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 399,
          "file_complexity": 103,
          "file_token_count": 2808,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # Default rate calculation: average time\n    # Else, the rate can be manually overriden because\n    # predicting time is a non-linear and non perfectly solvable problem\n    if rate is None and elapsed:\n        rate = n / elapsed\n    # Format the rate display\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    # Format n and total displays\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # Total number of iterations is known, we can predict some stats\n    if total:\n        # Compute the bar's fraction and percentage over the total\n        frac = n / total\n        percentage = frac * 100\n\n        # Compute remaining time given the rate\n        remaining_str = format_interval( (total-n) * (1/rate) ) if n else '?'\n\n        # Format the stats displays at the sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # Compute the available space for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # Format progress bar display\n        if ascii:  # only use ascii characters\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:  # unicode available: show smooth bar (with smaller blocks)\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # Fill remaining empty space if necessary\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        # Format the full bar with stats display\n        return l_bar + full_bar + r_bar\n\n    # Else we don't know the total number of iterations, no forecast\n    else:  # no progressbar nor ETA, just progress statistics\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False,\n                 smoothing=0.05):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progressbar to stay within this bound. If\n            [default: None], attempts to use environment width. The fallback\n            is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (only use average time) to 1\n            (current/instantaneous speed) [default: 0.7].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if gui:  # pragma: no cover\n            try:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n                from collections import deque\n            except ImportError:\n                gui = False\n            else:\n                self.mpl = mpl\n                self.plt = plt\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n\n        if gui:  # pragma: no cover\n            # Initialize the GUI display\n            if not disable:\n                file.write('Warning: GUI is experimental/alpha\\n')\n\n                # Remember if external environment uses toolbars\n                self.toolbar = self.mpl.rcParams['toolbar']\n                self.mpl.rcParams['toolbar'] = 'None'\n\n                self.mininterval = max(mininterval, 0.5)\n                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n                # self.fig.subplots_adjust(bottom=0.2)\n                if total:\n                    self.xdata = []\n                    self.ydata = []\n                    self.zdata = []\n                else:\n                    self.xdata = deque([])\n                    self.ydata = deque([])\n                    self.zdata = deque([])\n                self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n                self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n                ax.set_ylim(0, 0.001)\n                if total:\n                    ax.set_xlim(0, 100)\n                    ax.set_xlabel('percent')\n                    self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n                                    loc='center right')\n                    # progressbar\n                    self.hspan = plt.axhspan(0, 0.001,\n                                             xmin=0, xmax=0, color='g')\n                else:\n                    # ax.set_xlim(-60, 0)\n                    ax.set_xlim(0, 60)\n                    ax.invert_xaxis()\n                    ax.set_xlabel('seconds')\n                    ax.legend(('cur', 'est'), loc='lower left')\n                ax.grid()\n                # ax.set_xlabel('seconds')\n                ax.set_ylabel((unit if unit else 'it') + '/s')\n                if unit_scale:\n                    plt.ticklabel_format(style='sci', axis='y',\n                                         scilimits=(0, 0))\n                    ax.yaxis.get_offset_text().set_x(-0.15)\n\n                # Remember if external environment is interactive\n                self.wasion = plt.isinteractive()\n                plt.ion()\n                self.ax = ax\n        else:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            gui = self.gui\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            if gui:  # pragma: no cover\n                plt = self.plt\n                ax = self.ax\n                xdata = self.xdata\n                ydata = self.ydata\n                zdata = self.zdata\n                line1 = self.line1\n                line2 = self.line2\n            else:\n                sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        if gui:  # pragma: no cover\n                            # Inline due to multiple calls\n                            total = self.total\n                            # instantaneous rate\n                            y = delta_it / delta_t\n                            # overall rate\n                            z = n / elapsed\n                            # update line data\n                            xdata.append(n * 100.0 / total if total else cur_t)\n                            ydata.append(y)\n                            zdata.append(z)\n\n                            # Discard old values\n                            # xmin, xmax = ax.get_xlim()\n                            # if (not total) and elapsed > xmin * 1.1:\n                            if (not total) and elapsed > 66:\n                                xdata.popleft()\n                                ydata.popleft()\n                                zdata.popleft()\n\n                            ymin, ymax = ax.get_ylim()\n                            if y > ymax or z > ymax:\n                                ymax = 1.1 * y\n                                ax.set_ylim(ymin, ymax)\n                                ax.figure.canvas.draw()\n\n                            if total:\n                                line1.set_data(xdata, ydata)\n                                line2.set_data(xdata, zdata)\n                                try:\n                                    poly_lims = self.hspan.get_xy()\n                                except AttributeError:\n                                    self.hspan = plt.axhspan(0, 0.001, xmin=0,\n                                                             xmax=0, color='g')\n                                    poly_lims = self.hspan.get_xy()\n                                poly_lims[0, 1] = ymin\n                                poly_lims[1, 1] = ymax\n                                poly_lims[2] = [n / total, ymax]\n                                poly_lims[3] = [poly_lims[2, 0], ymin]\n                                if len(poly_lims) > 4:\n                                    poly_lims[4, 1] = ymin\n                                self.hspan.set_xy(poly_lims)\n                            else:\n                                t_ago = [cur_t - i for i in xdata]\n                                line1.set_data(t_ago, ydata)\n                                line2.set_data(t_ago, zdata)\n\n                            ax.set_title(format_meter(\n                                n, total, elapsed, 0,\n                                self.desc, ascii, unit, unit_scale),\n                                fontname=\"DejaVu Sans Mono\",\n                                fontsize=11)\n                            plt.pause(1e-9)\n                        else:\n                            if smoothing:  # if not smoothing: just use average time\n                                avg_rate = delta_it / delta_t if avg_rate is None \\\n                                    else smoothing * delta_it / delta_t + \\\n                                    (1 - smoothing) * avg_rate\n\n                            sp(format_meter(\n                                n, self.total, elapsed,\n                                (dynamic_ncols(self.fp) if dynamic_ncols\n                                 else ncols),\n                                self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                if self.gui:  # pragma: no cover\n                    # Inline due to multiple calls\n                    total = self.total\n                    ax = self.ax\n\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # smoothed rate\n                    z = self.n / elapsed\n                    # update line data\n                    self.xdata.append(self.n * 100.0 / total\n                                      if total else cur_t)\n                    self.ydata.append(y)\n                    self.zdata.append(z)\n\n                    # Discard old values\n                    if (not total) and elapsed > 66:\n                        self.xdata.popleft()\n                        self.ydata.popleft()\n                        self.zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ymax = 1.1 * y\n                        ax.set_ylim(ymin, ymax)\n                        ax.figure.canvas.draw()\n\n                    if total:\n                        self.line1.set_data(self.xdata, self.ydata)\n                        self.line2.set_data(self.xdata, self.zdata)\n                        try:\n                            poly_lims = self.hspan.get_xy()\n                        except AttributeError:\n                            self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n                                                          xmax=0, color='g')\n                            poly_lims = self.hspan.get_xy()\n                        poly_lims[0, 1] = ymin\n                        poly_lims[1, 1] = ymax\n                        poly_lims[2] = [self.n / total, ymax]\n                        poly_lims[3] = [poly_lims[2, 0], ymin]\n                        if len(poly_lims) > 4:\n                            poly_lims[4, 1] = ymin\n                        self.hspan.set_xy(poly_lims)\n                    else:\n                        t_ago = [cur_t - i for i in self.xdata]\n                        self.line1.set_data(t_ago, self.ydata)\n                        self.line2.set_data(t_ago, self.zdata)\n\n                    ax.set_title(format_meter(\n                        self.n, total, elapsed, 0,\n                        self.desc, self.ascii, self.unit, self.unit_scale),\n                        fontname=\"DejaVu Sans Mono\",\n                        fontsize=11)\n                    self.plt.pause(1e-9)\n                else:\n                    if self.smoothing:  # if not smoothing: just use average time\n                        self.avg_rate = delta_it / delta_t \\\n                            if self.avg_rate is None \\\n                            else self.smoothing * delta_it / delta_t + \\\n                            (1 - self.smoothing) * self.avg_rate\n\n                    self.sp(format_meter(\n                        self.n, self.total, elapsed,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale,\n                        self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.gui:  # pragma: no cover\n            # Restore toolbars\n            self.mpl.rcParams['toolbar'] = self.toolbar\n            # Return to non-interactive mode\n            if not self.wasion:\n                self.plt.ioff()\n            if not self.leave:\n                self.plt.close(self.fig)\n        else:\n            if self.leave:\n                if self.last_print_n < self.n:\n                    cur_t = time()\n                    # stats for overall rate (no weighted average)\n                    self.sp(format_meter(\n                        self.n, self.total, cur_t-self.start_t,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale))\n                self.fp.write('\\n')\n            else:\n                self.sp('')\n                self.fp.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total-n) / rate) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False,\n                 smoothing=0.7):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progressbar to stay within this bound. If\n            [default: None], attempts to use environment width. The fallback\n            is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.7].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if gui:  # pragma: no cover\n            try:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n                from collections import deque\n            except ImportError:\n                gui = False\n            else:\n                self.mpl = mpl\n                self.plt = plt\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_rate = None\n\n        if gui:  # pragma: no cover\n            # Initialize the GUI display\n            if not disable:\n                file.write('Warning: GUI is experimental/alpha\\n')\n\n                # Remember if external environment uses toolbars\n                self.toolbar = self.mpl.rcParams['toolbar']\n                self.mpl.rcParams['toolbar'] = 'None'\n\n                self.mininterval = max(mininterval, 0.5)\n                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n                # self.fig.subplots_adjust(bottom=0.2)\n                if total:\n                    self.xdata = []\n                    self.ydata = []\n                    self.zdata = []\n                else:\n                    self.xdata = deque([])\n                    self.ydata = deque([])\n                    self.zdata = deque([])\n                self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n                self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n                ax.set_ylim(0, 0.001)\n                if total:\n                    ax.set_xlim(0, 100)\n                    ax.set_xlabel('percent')\n                    self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n                                    loc='center right')\n                    # progressbar\n                    self.hspan = plt.axhspan(0, 0.001,\n                                             xmin=0, xmax=0, color='g')\n                else:\n                    # ax.set_xlim(-60, 0)\n                    ax.set_xlim(0, 60)\n                    ax.invert_xaxis()\n                    ax.set_xlabel('seconds')\n                    ax.legend(('cur', 'est'), loc='lower left')\n                ax.grid()\n                # ax.set_xlabel('seconds')\n                ax.set_ylabel((unit if unit else 'it') + '/s')\n                if unit_scale:\n                    plt.ticklabel_format(style='sci', axis='y',\n                                         scilimits=(0, 0))\n                    ax.yaxis.get_offset_text().set_x(-0.15)\n\n                # Remember if external environment is interactive\n                self.wasion = plt.isinteractive()\n                plt.ion()\n                self.ax = ax\n        else:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            gui = self.gui\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_rate = self.avg_rate\n            if gui:  # pragma: no cover\n                plt = self.plt\n                ax = self.ax\n                xdata = self.xdata\n                ydata = self.ydata\n                zdata = self.zdata\n                line1 = self.line1\n                line2 = self.line2\n            else:\n                sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        if gui:  # pragma: no cover\n                            # Inline due to multiple calls\n                            total = self.total\n                            # instantaneous rate\n                            y = delta_it / delta_t\n                            # overall rate\n                            z = n / elapsed\n                            # update line data\n                            xdata.append(n * 100.0 / total if total else cur_t)\n                            ydata.append(y)\n                            zdata.append(z)\n\n                            # Discard old values\n                            # xmin, xmax = ax.get_xlim()\n                            # if (not total) and elapsed > xmin * 1.1:\n                            if (not total) and elapsed > 66:\n                                xdata.popleft()\n                                ydata.popleft()\n                                zdata.popleft()\n\n                            ymin, ymax = ax.get_ylim()\n                            if y > ymax or z > ymax:\n                                ymax = 1.1 * y\n                                ax.set_ylim(ymin, ymax)\n                                ax.figure.canvas.draw()\n\n                            if total:\n                                line1.set_data(xdata, ydata)\n                                line2.set_data(xdata, zdata)\n                                try:\n                                    poly_lims = self.hspan.get_xy()\n                                except AttributeError:\n                                    self.hspan = plt.axhspan(0, 0.001, xmin=0,\n                                                             xmax=0, color='g')\n                                    poly_lims = self.hspan.get_xy()\n                                poly_lims[0, 1] = ymin\n                                poly_lims[1, 1] = ymax\n                                poly_lims[2] = [n / total, ymax]\n                                poly_lims[3] = [poly_lims[2, 0], ymin]\n                                if len(poly_lims) > 4:\n                                    poly_lims[4, 1] = ymin\n                                self.hspan.set_xy(poly_lims)\n                            else:\n                                t_ago = [cur_t - i for i in xdata]\n                                line1.set_data(t_ago, ydata)\n                                line2.set_data(t_ago, zdata)\n\n                            ax.set_title(format_meter(\n                                n, total, elapsed, 0,\n                                self.desc, ascii, unit, unit_scale),\n                                fontname=\"DejaVu Sans Mono\",\n                                fontsize=11)\n                            plt.pause(1e-9)\n                        else:\n                            if smoothing:  # EMA (not just overall average)\n                                avg_rate = delta_it / delta_t if avg_rate is None \\\n                                    else smoothing * delta_it / delta_t + \\\n                                    (1 - smoothing) * avg_rate\n\n                            sp(format_meter(\n                                n, self.total, elapsed,\n                                (dynamic_ncols(self.fp) if dynamic_ncols\n                                 else ncols),\n                                self.desc, ascii, unit, unit_scale, avg_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                if self.gui:  # pragma: no cover\n                    # Inline due to multiple calls\n                    total = self.total\n                    ax = self.ax\n\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # smoothed rate\n                    z = self.n / elapsed\n                    # update line data\n                    self.xdata.append(self.n * 100.0 / total\n                                      if total else cur_t)\n                    self.ydata.append(y)\n                    self.zdata.append(z)\n\n                    # Discard old values\n                    if (not total) and elapsed > 66:\n                        self.xdata.popleft()\n                        self.ydata.popleft()\n                        self.zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ymax = 1.1 * y\n                        ax.set_ylim(ymin, ymax)\n                        ax.figure.canvas.draw()\n\n                    if total:\n                        self.line1.set_data(self.xdata, self.ydata)\n                        self.line2.set_data(self.xdata, self.zdata)\n                        try:\n                            poly_lims = self.hspan.get_xy()\n                        except AttributeError:\n                            self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n                                                          xmax=0, color='g')\n                            poly_lims = self.hspan.get_xy()\n                        poly_lims[0, 1] = ymin\n                        poly_lims[1, 1] = ymax\n                        poly_lims[2] = [self.n / total, ymax]\n                        poly_lims[3] = [poly_lims[2, 0], ymin]\n                        if len(poly_lims) > 4:\n                            poly_lims[4, 1] = ymin\n                        self.hspan.set_xy(poly_lims)\n                    else:\n                        t_ago = [cur_t - i for i in self.xdata]\n                        self.line1.set_data(t_ago, self.ydata)\n                        self.line2.set_data(t_ago, self.zdata)\n\n                    ax.set_title(format_meter(\n                        self.n, total, elapsed, 0,\n                        self.desc, self.ascii, self.unit, self.unit_scale),\n                        fontname=\"DejaVu Sans Mono\",\n                        fontsize=11)\n                    self.plt.pause(1e-9)\n                else:\n                    if self.smoothing:  # EMA (not just overall average)\n                        self.avg_rate = delta_it / delta_t \\\n                            if self.avg_rate is None \\\n                            else self.smoothing * delta_it / delta_t + \\\n                            (1 - self.smoothing) * self.avg_rate\n\n                    self.sp(format_meter(\n                        self.n, self.total, elapsed,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale,\n                        self.avg_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.gui:  # pragma: no cover\n            # Restore toolbars\n            self.mpl.rcParams['toolbar'] = self.toolbar\n            # Return to non-interactive mode\n            if not self.wasion:\n                self.plt.ioff()\n            if not self.leave:\n                self.plt.close(self.fig)\n        else:\n            if self.leave:\n                if self.last_print_n < self.n:\n                    cur_t = time()\n                    # stats for overall rate (no weighted average)\n                    self.sp(format_meter(\n                        self.n, self.total, cur_t-self.start_t,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale))\n                self.fp.write('\\n')\n            else:\n                self.sp('')\n                self.fp.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -107,26 +107,21 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     out  : Formatted meter and stats, ready to display.\n     \"\"\"\n \n-    # in case the total is wrong (n is above the total), then\n-    # we switch to the mode without showing the total prediction\n-    # (since ETA would be wrong anyway)\n+    # sanity check: total\n     if total and n > total:\n         total = None\n \n     elapsed_str = format_interval(elapsed)\n \n-    # Default rate calculation: average time\n-    # Else, the rate can be manually overriden because\n-    # predicting time is a non-linear and non perfectly solvable problem\n+    # if unspecified, attempt to use rate = average speed\n+    # (we allow manual override since predicting time is an arcane art)\n     if rate is None and elapsed:\n         rate = n / elapsed\n-    # Format the rate display\n     rate_fmt = ((format_sizeof(rate) if unit_scale else\n                  '{0:5.2f}'.format(rate)) if elapsed else\n                 '?') \\\n         + unit + '/s'\n \n-    # Format n and total displays\n     if unit_scale:\n         n_fmt = format_sizeof(n)\n         total_fmt = format_sizeof(total) if total else None\n@@ -134,16 +129,15 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n         n_fmt = str(n)\n         total_fmt = str(total)\n \n-    # Total number of iterations is known, we can predict some stats\n+    # total is known: we can predict some stats\n     if total:\n-        # Compute the bar's fraction and percentage over the total\n+        # fractional and percentage progress\n         frac = n / total\n         percentage = frac * 100\n \n-        # Compute remaining time given the rate\n-        remaining_str = format_interval( (total-n) * (1/rate) ) if n else '?'\n+        remaining_str = format_interval((total-n) / rate) if rate else '?'\n \n-        # Format the stats displays at the sides of the bar\n+        # format the stats displayed to the left and right sides of the bar\n         l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n         r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                 n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n@@ -151,12 +145,12 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n         if ncols == 0:\n             return l_bar[:-1] + r_bar[1:]\n \n-        # Compute the available space for bar's display\n+        # space available for bar's display\n         N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n             else 10\n \n-        # Format progress bar display\n-        if ascii:  # only use ascii characters\n+        # format bar depending on availability of unicode/ascii chars\n+        if ascii:\n             bar_length, frac_bar_length = divmod(\n                 int(frac * N_BARS * 10), 10)\n \n@@ -164,26 +158,25 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n             frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                 else ' '\n \n-        else:  # unicode available: show smooth bar (with smaller blocks)\n+        else:\n             bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n \n             bar = _unich(0x2588)*bar_length\n             frac_bar = _unich(0x2590 - frac_bar_length) \\\n                 if frac_bar_length else ' '\n \n-        # Fill remaining empty space if necessary\n+        # whitespace padding\n         if bar_length < N_BARS:\n             full_bar = bar + frac_bar + \\\n-                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n+                ' ' * max(N_BARS - bar_length - 1, 0)\n         else:\n             full_bar = bar + \\\n-                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n+                ' ' * max(N_BARS - bar_length, 0)\n \n-        # Format the full bar with stats display\n         return l_bar + full_bar + r_bar\n \n-    # Else we don't know the total number of iterations, no forecast\n-    else:  # no progressbar nor ETA, just progress statistics\n+    # no total: no progressbar, ETA, just progress stats\n+    else:\n         return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n             n_fmt, unit, elapsed_str, rate_fmt)\n \n@@ -218,7 +211,7 @@ class tqdm(object):\n                  file=sys.stderr, ncols=None, mininterval=0.1,\n                  miniters=None, ascii=None, disable=False,\n                  unit='it', unit_scale=False, gui=False, dynamic_ncols=False,\n-                 smoothing=0.05):\n+                 smoothing=0.7):\n         \"\"\"\n         Parameters\n         ----------\n@@ -271,7 +264,7 @@ class tqdm(object):\n             for window resizes) [default: False].\n         smoothing  : float\n             Exponential moving average smoothing factor for speed estimates\n-            (ignored in GUI mode). Ranges from 0 (only use average time) to 1\n+            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n             (current/instantaneous speed) [default: 0.7].\n \n         Returns\n@@ -507,7 +500,7 @@ class tqdm(object):\n                                 fontsize=11)\n                             plt.pause(1e-9)\n                         else:\n-                            if smoothing:  # if not smoothing: just use average time\n+                            if smoothing:  # EMA (not just overall average)\n                                 avg_rate = delta_it / delta_t if avg_rate is None \\\n                                     else smoothing * delta_it / delta_t + \\\n                                     (1 - smoothing) * avg_rate\n@@ -622,7 +615,7 @@ class tqdm(object):\n                         fontsize=11)\n                     self.plt.pause(1e-9)\n                 else:\n-                    if self.smoothing:  # if not smoothing: just use average time\n+                    if self.smoothing:  # EMA (not just overall average)\n                         self.avg_rate = delta_it / delta_t \\\n                             if self.avg_rate is None \\\n                             else self.smoothing * delta_it / delta_t + \\\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "370780a74a3ec0d9341c196e201f73f4a8dd8f11": {
        "commit": {
          "commit_id": "370780a74a3ec0d9341c196e201f73f4a8dd8f11",
          "commit_message": "Exponentially weighted moving average, tests, documentation",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-11-09 12:17:20",
          "commit_parent": "f54e371a405aaf7a663ad787a8e8d08336603e3f"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 72,
          "function_before_end_line": 170,
          "function_after_start_line": 72,
          "function_after_end_line": 174,
          "function_before_token_count": 363,
          "function_after_token_count": 375,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_iterate_over_csv_rows",
            "format_sizeof",
            "test_si_format",
            "test_close",
            "test_min_interval",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "test_version",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "__init__",
            "update",
            "test_smoothing",
            "StatusPrinter",
            "test_file_output",
            "test_big_min_interval",
            "__len__",
            "format_interval",
            "format_meter",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "__iter__",
            "update",
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "__init__",
            "update",
            "test_disable",
            "test_smoothing",
            "test_iterate_over_csv_rows",
            "test_all_defaults",
            "test_dynamic_min_iters",
            "test_version",
            "test_big_min_interval",
            "test_min_interval",
            "__iter__",
            "test_format_meter",
            "test_trange",
            "test_min_iters",
            "test_unit",
            "test_format_interval"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 397,
          "file_complexity": 101,
          "file_token_count": 2802,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progressbar to stay within this bound. If\n            [default: None], attempts to use environment width. The fallback\n            is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if gui:  # pragma: no cover\n            try:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n                from collections import deque\n            except ImportError:\n                gui = False\n            else:\n                self.mpl = mpl\n                self.plt = plt\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n\n        if gui:  # pragma: no cover\n            # Initialize the GUI display\n            if not disable:\n                file.write('Warning: GUI is experimental/alpha\\n')\n\n                # Remember if external environment uses toolbars\n                self.toolbar = self.mpl.rcParams['toolbar']\n                self.mpl.rcParams['toolbar'] = 'None'\n\n                self.mininterval = max(mininterval, 0.5)\n                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n                # self.fig.subplots_adjust(bottom=0.2)\n                if total:\n                    self.xdata = []\n                    self.ydata = []\n                    self.zdata = []\n                else:\n                    self.xdata = deque([])\n                    self.ydata = deque([])\n                    self.zdata = deque([])\n                self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n                self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n                ax.set_ylim(0, 0.001)\n                if total:\n                    ax.set_xlim(0, 100)\n                    ax.set_xlabel('percent')\n                    self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n                                    loc='center right')\n                    # progressbar\n                    self.hspan = plt.axhspan(0, 0.001,\n                                             xmin=0, xmax=0, color='g')\n                else:\n                    # ax.set_xlim(-60, 0)\n                    ax.set_xlim(0, 60)\n                    ax.invert_xaxis()\n                    ax.set_xlabel('seconds')\n                    ax.legend(('cur', 'est'), loc='lower left')\n                ax.grid()\n                # ax.set_xlabel('seconds')\n                ax.set_ylabel((unit if unit else 'it') + '/s')\n                if unit_scale:\n                    plt.ticklabel_format(style='sci', axis='y',\n                                         scilimits=(0, 0))\n                    ax.yaxis.get_offset_text().set_x(-0.15)\n\n                # Remember if external environment is interactive\n                self.wasion = plt.isinteractive()\n                plt.ion()\n                self.ax = ax\n        else:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            gui = self.gui\n            dynamic_ncols = self.dynamic_ncols\n            if gui:  # pragma: no cover\n                plt = self.plt\n                ax = self.ax\n                xdata = self.xdata\n                ydata = self.ydata\n                zdata = self.zdata\n                line1 = self.line1\n                line2 = self.line2\n            else:\n                sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        if gui:  # pragma: no cover\n                            # Inline due to multiple calls\n                            total = self.total\n                            # instantaneous rate\n                            y = delta_it / delta_t\n                            # smoothed rate\n                            z = n / elapsed\n                            # update line data\n                            xdata.append(n * 100.0 / total if total else cur_t)\n                            ydata.append(y)\n                            zdata.append(z)\n\n                            # Discard old values\n                            # xmin, xmax = ax.get_xlim()\n                            # if (not total) and elapsed > xmin * 1.1:\n                            if (not total) and elapsed > 66:\n                                xdata.popleft()\n                                ydata.popleft()\n                                zdata.popleft()\n\n                            ymin, ymax = ax.get_ylim()\n                            if y > ymax or z > ymax:\n                                ymax = 1.1 * y\n                                ax.set_ylim(ymin, ymax)\n                                ax.figure.canvas.draw()\n\n                            if total:\n                                line1.set_data(xdata, ydata)\n                                line2.set_data(xdata, zdata)\n                                try:\n                                    poly_lims = self.hspan.get_xy()\n                                except AttributeError:\n                                    self.hspan = plt.axhspan(0, 0.001, xmin=0,\n                                                             xmax=0, color='g')\n                                    poly_lims = self.hspan.get_xy()\n                                poly_lims[0, 1] = ymin\n                                poly_lims[1, 1] = ymax\n                                poly_lims[2] = [n / total, ymax]\n                                poly_lims[3] = [poly_lims[2, 0], ymin]\n                                if len(poly_lims) > 4:\n                                    poly_lims[4, 1] = ymin\n                                self.hspan.set_xy(poly_lims)\n                            else:\n                                t_ago = [cur_t - i for i in xdata]\n                                line1.set_data(t_ago, ydata)\n                                line2.set_data(t_ago, zdata)\n\n                            ax.set_title(format_meter(\n                                n, total, elapsed, 0,\n                                self.desc, ascii, unit, unit_scale),\n                                fontname=\"DejaVu Sans Mono\",\n                                fontsize=11)\n                            plt.pause(1e-9)\n                        else:\n                            sp(format_meter(\n                                n, self.total, elapsed,\n                                (dynamic_ncols(self.fp) if dynamic_ncols\n                                 else ncols),\n                                self.desc, ascii, unit, unit_scale))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                if self.gui:  # pragma: no cover\n                    # Inline due to multiple calls\n                    total = self.total\n                    ax = self.ax\n\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # smoothed rate\n                    z = self.n / elapsed\n                    # update line data\n                    self.xdata.append(self.n * 100.0 / total\n                                      if total else cur_t)\n                    self.ydata.append(y)\n                    self.zdata.append(z)\n\n                    # Discard old values\n                    if (not total) and elapsed > 66:\n                        self.xdata.popleft()\n                        self.ydata.popleft()\n                        self.zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ymax = 1.1 * y\n                        ax.set_ylim(ymin, ymax)\n                        ax.figure.canvas.draw()\n\n                    if total:\n                        self.line1.set_data(self.xdata, self.ydata)\n                        self.line2.set_data(self.xdata, self.zdata)\n                        try:\n                            poly_lims = self.hspan.get_xy()\n                        except AttributeError:\n                            self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n                                                          xmax=0, color='g')\n                            poly_lims = self.hspan.get_xy()\n                        poly_lims[0, 1] = ymin\n                        poly_lims[1, 1] = ymax\n                        poly_lims[2] = [self.n / total, ymax]\n                        poly_lims[3] = [poly_lims[2, 0], ymin]\n                        if len(poly_lims) > 4:\n                            poly_lims[4, 1] = ymin\n                        self.hspan.set_xy(poly_lims)\n                    else:\n                        t_ago = [cur_t - i for i in self.xdata]\n                        self.line1.set_data(t_ago, self.ydata)\n                        self.line2.set_data(t_ago, self.zdata)\n\n                    ax.set_title(format_meter(\n                        self.n, total, elapsed, 0,\n                        self.desc, self.ascii, self.unit, self.unit_scale),\n                        fontname=\"DejaVu Sans Mono\",\n                        fontsize=11)\n                    self.plt.pause(1e-9)\n                else:\n                    self.sp(format_meter(\n                        self.n, self.total, elapsed,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.gui:  # pragma: no cover\n            # Restore toolbars\n            self.mpl.rcParams['toolbar'] = self.toolbar\n            # Return to non-interactive mode\n            if not self.wasion:\n                self.plt.ioff()\n            if not self.leave:\n                self.plt.close(self.fig)\n        else:\n            if self.leave:\n                if self.last_print_n < self.n:\n                    cur_t = time()\n                    self.sp(format_meter(\n                        self.n, self.total, cur_t-self.start_t,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale))\n                self.fp.write('\\n')\n            else:\n                self.sp('')\n                self.fp.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    if rate is None and elapsed:\n        rate = n / elapsed\n    rate_fmt = ((format_sizeof(rate) if unit_scale else\n                 '{0:5.2f}'.format(rate)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    if not getattr(fp, 'flush', False):  # pragma: no cover\n        fp.flush = lambda: None\n\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False,\n                 smoothing=0.7):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar). If `gui` is\n            True and this parameter needs subsequent updating, specify an\n            initial arbitrary large positive integer, e.g. int(9e9).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progressbar to stay within this bound. If\n            [default: None], attempts to use environment width. The fallback\n            is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (initial speed) to 1\n            (current/instantaneous speed) [default: 0.7].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if gui:  # pragma: no cover\n            try:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n                from collections import deque\n            except ImportError:\n                gui = False\n            else:\n                self.mpl = mpl\n                self.plt = plt\n\n        if smoothing is None:\n            smoothing = 1\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.ave_rate = None\n\n        if gui:  # pragma: no cover\n            # Initialize the GUI display\n            if not disable:\n                file.write('Warning: GUI is experimental/alpha\\n')\n\n                # Remember if external environment uses toolbars\n                self.toolbar = self.mpl.rcParams['toolbar']\n                self.mpl.rcParams['toolbar'] = 'None'\n\n                self.mininterval = max(mininterval, 0.5)\n                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n                # self.fig.subplots_adjust(bottom=0.2)\n                if total:\n                    self.xdata = []\n                    self.ydata = []\n                    self.zdata = []\n                else:\n                    self.xdata = deque([])\n                    self.ydata = deque([])\n                    self.zdata = deque([])\n                self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n                self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n                ax.set_ylim(0, 0.001)\n                if total:\n                    ax.set_xlim(0, 100)\n                    ax.set_xlabel('percent')\n                    self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n                                    loc='center right')\n                    # progressbar\n                    self.hspan = plt.axhspan(0, 0.001,\n                                             xmin=0, xmax=0, color='g')\n                else:\n                    # ax.set_xlim(-60, 0)\n                    ax.set_xlim(0, 60)\n                    ax.invert_xaxis()\n                    ax.set_xlabel('seconds')\n                    ax.legend(('cur', 'est'), loc='lower left')\n                ax.grid()\n                # ax.set_xlabel('seconds')\n                ax.set_ylabel((unit if unit else 'it') + '/s')\n                if unit_scale:\n                    plt.ticklabel_format(style='sci', axis='y',\n                                         scilimits=(0, 0))\n                    ax.yaxis.get_offset_text().set_x(-0.15)\n\n                # Remember if external environment is interactive\n                self.wasion = plt.isinteractive()\n                plt.ion()\n                self.ax = ax\n        else:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.fp)\n            if not disable:\n                self.sp(format_meter(0, total, 0,\n                        (dynamic_ncols(file) if dynamic_ncols else ncols),\n                        self.desc, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            gui = self.gui\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            ave_rate = self.ave_rate\n            if gui:  # pragma: no cover\n                plt = self.plt\n                ax = self.ax\n                xdata = self.xdata\n                ydata = self.ydata\n                zdata = self.zdata\n                line1 = self.line1\n                line2 = self.line2\n            else:\n                sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        if gui:  # pragma: no cover\n                            # Inline due to multiple calls\n                            total = self.total\n                            # instantaneous rate\n                            y = delta_it / delta_t\n                            # overall rate\n                            z = n / elapsed\n                            # update line data\n                            xdata.append(n * 100.0 / total if total else cur_t)\n                            ydata.append(y)\n                            zdata.append(z)\n\n                            # Discard old values\n                            # xmin, xmax = ax.get_xlim()\n                            # if (not total) and elapsed > xmin * 1.1:\n                            if (not total) and elapsed > 66:\n                                xdata.popleft()\n                                ydata.popleft()\n                                zdata.popleft()\n\n                            ymin, ymax = ax.get_ylim()\n                            if y > ymax or z > ymax:\n                                ymax = 1.1 * y\n                                ax.set_ylim(ymin, ymax)\n                                ax.figure.canvas.draw()\n\n                            if total:\n                                line1.set_data(xdata, ydata)\n                                line2.set_data(xdata, zdata)\n                                try:\n                                    poly_lims = self.hspan.get_xy()\n                                except AttributeError:\n                                    self.hspan = plt.axhspan(0, 0.001, xmin=0,\n                                                             xmax=0, color='g')\n                                    poly_lims = self.hspan.get_xy()\n                                poly_lims[0, 1] = ymin\n                                poly_lims[1, 1] = ymax\n                                poly_lims[2] = [n / total, ymax]\n                                poly_lims[3] = [poly_lims[2, 0], ymin]\n                                if len(poly_lims) > 4:\n                                    poly_lims[4, 1] = ymin\n                                self.hspan.set_xy(poly_lims)\n                            else:\n                                t_ago = [cur_t - i for i in xdata]\n                                line1.set_data(t_ago, ydata)\n                                line2.set_data(t_ago, zdata)\n\n                            ax.set_title(format_meter(\n                                n, total, elapsed, 0,\n                                self.desc, ascii, unit, unit_scale),\n                                fontname=\"DejaVu Sans Mono\",\n                                fontsize=11)\n                            plt.pause(1e-9)\n                        else:\n                            ave_rate = delta_it / delta_t if ave_rate is None \\\n                                else smoothing * delta_it / delta_t + \\\n                                (1 - smoothing) * ave_rate\n                            sp(format_meter(\n                                n, self.total, elapsed,\n                                (dynamic_ncols(self.fp) if dynamic_ncols\n                                 else ncols),\n                                self.desc, ascii, unit, unit_scale, ave_rate))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        last_print_n = n\n                        last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 1:\n            n = 1\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                if self.gui:  # pragma: no cover\n                    # Inline due to multiple calls\n                    total = self.total\n                    ax = self.ax\n\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # smoothed rate\n                    z = self.n / elapsed\n                    # update line data\n                    self.xdata.append(self.n * 100.0 / total\n                                      if total else cur_t)\n                    self.ydata.append(y)\n                    self.zdata.append(z)\n\n                    # Discard old values\n                    if (not total) and elapsed > 66:\n                        self.xdata.popleft()\n                        self.ydata.popleft()\n                        self.zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ymax = 1.1 * y\n                        ax.set_ylim(ymin, ymax)\n                        ax.figure.canvas.draw()\n\n                    if total:\n                        self.line1.set_data(self.xdata, self.ydata)\n                        self.line2.set_data(self.xdata, self.zdata)\n                        try:\n                            poly_lims = self.hspan.get_xy()\n                        except AttributeError:\n                            self.hspan = self.plt.axhspan(0, 0.001, xmin=0,\n                                                          xmax=0, color='g')\n                            poly_lims = self.hspan.get_xy()\n                        poly_lims[0, 1] = ymin\n                        poly_lims[1, 1] = ymax\n                        poly_lims[2] = [self.n / total, ymax]\n                        poly_lims[3] = [poly_lims[2, 0], ymin]\n                        if len(poly_lims) > 4:\n                            poly_lims[4, 1] = ymin\n                        self.hspan.set_xy(poly_lims)\n                    else:\n                        t_ago = [cur_t - i for i in self.xdata]\n                        self.line1.set_data(t_ago, self.ydata)\n                        self.line2.set_data(t_ago, self.zdata)\n\n                    ax.set_title(format_meter(\n                        self.n, total, elapsed, 0,\n                        self.desc, self.ascii, self.unit, self.unit_scale),\n                        fontname=\"DejaVu Sans Mono\",\n                        fontsize=11)\n                    self.plt.pause(1e-9)\n                else:\n                    self.ave_rate = delta_it / delta_t \\\n                        if self.ave_rate is None \\\n                        else self.smoothing * delta_it / delta_t + \\\n                        (1 - self.smoothing) * self.ave_rate\n                    self.sp(format_meter(\n                        self.n, self.total, elapsed,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale,\n                        self.ave_rate))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        if self.gui:  # pragma: no cover\n            # Restore toolbars\n            self.mpl.rcParams['toolbar'] = self.toolbar\n            # Return to non-interactive mode\n            if not self.wasion:\n                self.plt.ioff()\n            if not self.leave:\n                self.plt.close(self.fig)\n        else:\n            if self.leave:\n                if self.last_print_n < self.n:\n                    cur_t = time()\n                    # stats for overall rate (no weighted average)\n                    self.sp(format_meter(\n                        self.n, self.total, cur_t-self.start_t,\n                        (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                         else self.ncols),\n                        self.desc, self.ascii, self.unit, self.unit_scale))\n                self.fp.write('\\n')\n            else:\n                self.sp('')\n                self.fp.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -70,7 +70,7 @@ def format_interval(t):\n \n \n def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n-                 unit='it', unit_scale=False):\n+                 unit='it', unit_scale=False, rate=None):\n     \"\"\"\n     Return a string-based progress bar given some parameters\n \n@@ -99,6 +99,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     unit_scale  : bool, optional\n         If set, the number of iterations will printed with an appropriate\n         SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n+    rate  : float, optional\n+        Manual override for iteration rate. If [default: None], uses n/elapsed.\n \n     Returns\n     -------\n@@ -113,8 +115,10 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n \n     elapsed_str = format_interval(elapsed)\n \n-    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n-                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n+    if rate is None and elapsed:\n+        rate = n / elapsed\n+    rate_fmt = ((format_sizeof(rate) if unit_scale else\n+                 '{0:5.2f}'.format(rate)) if elapsed else\n                 '?') \\\n         + unit + '/s'\n \n@@ -199,7 +203,8 @@ class tqdm(object):\n     def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                  file=sys.stderr, ncols=None, mininterval=0.1,\n                  miniters=None, ascii=None, disable=False,\n-                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False):\n+                 unit='it', unit_scale=False, gui=False, dynamic_ncols=False,\n+                 smoothing=0.7):\n         \"\"\"\n         Parameters\n         ----------\n@@ -250,6 +255,10 @@ class tqdm(object):\n         dynamic_ncols  : bool, optional\n             If set, constantly alters `ncols` to the environment (allowing\n             for window resizes) [default: False].\n+        smoothing  : float\n+            Exponential moving average smoothing factor for speed estimates\n+            (ignored in GUI mode). Ranges from 0 (initial speed) to 1\n+            (current/instantaneous speed) [default: 0.7].\n \n         Returns\n         -------\n@@ -293,6 +302,9 @@ class tqdm(object):\n                 self.mpl = mpl\n                 self.plt = plt\n \n+        if smoothing is None:\n+            smoothing = 1\n+\n         # Store the arguments\n         self.iterable = iterable\n         self.desc = desc+': ' if desc else ''\n@@ -309,6 +321,8 @@ class tqdm(object):\n         self.unit_scale = unit_scale\n         self.gui = gui\n         self.dynamic_ncols = dynamic_ncols\n+        self.smoothing = smoothing\n+        self.ave_rate = None\n \n         if gui:  # pragma: no cover\n             # Initialize the GUI display\n@@ -400,6 +414,8 @@ class tqdm(object):\n             n = self.n\n             gui = self.gui\n             dynamic_ncols = self.dynamic_ncols\n+            smoothing = self.smoothing\n+            ave_rate = self.ave_rate\n             if gui:  # pragma: no cover\n                 plt = self.plt\n                 ax = self.ax\n@@ -428,7 +444,7 @@ class tqdm(object):\n                             total = self.total\n                             # instantaneous rate\n                             y = delta_it / delta_t\n-                            # smoothed rate\n+                            # overall rate\n                             z = n / elapsed\n                             # update line data\n                             xdata.append(n * 100.0 / total if total else cur_t)\n@@ -477,11 +493,14 @@ class tqdm(object):\n                                 fontsize=11)\n                             plt.pause(1e-9)\n                         else:\n+                            ave_rate = delta_it / delta_t if ave_rate is None \\\n+                                else smoothing * delta_it / delta_t + \\\n+                                (1 - smoothing) * ave_rate\n                             sp(format_meter(\n                                 n, self.total, elapsed,\n                                 (dynamic_ncols(self.fp) if dynamic_ncols\n                                  else ncols),\n-                                self.desc, ascii, unit, unit_scale))\n+                                self.desc, ascii, unit, unit_scale, ave_rate))\n \n                         # If no `miniters` was specified, adjust automatically\n                         # to the maximum iteration rate seen so far.\n@@ -587,11 +606,16 @@ class tqdm(object):\n                         fontsize=11)\n                     self.plt.pause(1e-9)\n                 else:\n+                    self.ave_rate = delta_it / delta_t \\\n+                        if self.ave_rate is None \\\n+                        else self.smoothing * delta_it / delta_t + \\\n+                        (1 - self.smoothing) * self.ave_rate\n                     self.sp(format_meter(\n                         self.n, self.total, elapsed,\n                         (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                          else self.ncols),\n-                        self.desc, self.ascii, self.unit, self.unit_scale))\n+                        self.desc, self.ascii, self.unit, self.unit_scale,\n+                        self.ave_rate))\n \n                 # If no `miniters` was specified, adjust automatically to the\n                 # maximum iteration rate seen so far.\n@@ -624,6 +648,7 @@ class tqdm(object):\n             if self.leave:\n                 if self.last_print_n < self.n:\n                     cur_t = time()\n+                    # stats for overall rate (no weighted average)\n                     self.sp(format_meter(\n                         self.n, self.total, cur_t-self.start_t,\n                         (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py",
            "tests_version.py"
          ]
        }
      },
      "367723c584d7bbbce0b24f079f9b0404dfb1758e": {
        "commit": {
          "commit_id": "367723c584d7bbbce0b24f079f9b0404dfb1758e",
          "commit_message": "minor ncol bugfix (no-display progressbar), hybrid progressbar-rate graph, minor documentation fixes",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-09-18 20:39:13",
          "commit_parent": "4920d1779cb8b6d8b9ad3e2111d50bf5d30c925f"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 72,
          "function_before_end_line": 168,
          "function_after_start_line": 72,
          "function_after_end_line": 170,
          "function_before_token_count": 355,
          "function_after_token_count": 363,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_iterate_over_csv_rows",
            "format_sizeof",
            "test_close",
            "test_min_interval",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "__init__",
            "update",
            "StatusPrinter",
            "test_file_output",
            "__len__",
            "format_interval",
            "format_meter",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "__iter__",
            "update"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "__iter__",
            "update",
            "test_format_meter"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 330,
          "file_complexity": 82,
          "file_token_count": 2262,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            if abs(num) < 100.0:\n                if abs(num) < 10.0:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics.\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if gui:\n            try:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n                from collections import deque\n            except ImportError:\n                gui = False\n            else:\n                self.mpl = mpl\n                self.plt = plt\n\n        # Store the arguments\n        self.iterable = iterable\n        self.prefix = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n\n        if gui:\n            # Initialize the GUI display\n            if not disable:\n                file.write('Warning: GUI is experimental/alpha\\n')\n\n                # Remember if external environment uses toolbars\n                self.toolbar = self.mpl.rcParams['toolbar']\n                self.mpl.rcParams['toolbar'] = 'None'\n\n                self.mininterval = max(mininterval, 0.5)\n                self.fig, ax = plt.subplots(figsize=(10, 3))\n                # self.fig.subplots_adjust(bottom=0.2)\n                self.xdata = deque([])\n                self.ydata = deque([])\n                self.zdata = deque([])\n                self.line1, = ax.plot(self.xdata, self.ydata)\n                self.line2, = ax.plot(self.xdata, self.zdata)\n                ax.set_ylim(0, 0.001)\n                # ax.set_xlim(-60, 0)\n                ax.set_xlim(0, 60)\n                ax.invert_xaxis()\n                ax.grid()\n                # ax.set_xlabel('seconds')\n                ax.set_ylabel((unit if unit else 'it') + '/s')\n                ax.legend(('cur', 'est'), loc='lower left')\n                if unit_scale:\n                    plt.ticklabel_format(style='sci', axis='y',\n                                         scilimits=(0, 0))\n                    ax.yaxis.get_offset_text().set_x(-0.15)\n\n                # Remember if external environment is interactive\n                self.wasion = plt.isinteractive()\n                plt.ion()\n                self.ax = ax\n        else:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.file)\n            if not disable:\n                self.sp(format_meter(\n                    0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            total = self.total\n            prefix = self.prefix\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            gui = self.gui\n            if gui:\n                plt = self.plt\n                ax = self.ax\n                xdata = self.xdata\n                ydata = self.ydata\n                zdata = self.zdata\n                line1 = self.line1\n                line2 = self.line2\n            else:\n                sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        if gui:\n                            # instantaneous rate\n                            y = delta_it / delta_t\n                            # smoothed rate\n                            z = n / elapsed\n                            # update line data\n                            xdata.append(cur_t)\n                            ydata.append(y)\n                            zdata.append(z)\n\n                            # Discard old values\n                            # xmin, xmax = ax.get_xlim()\n                            # if elapsed > xmin:\n                            if elapsed > 60:\n                                xdata.popleft()\n                                ydata.popleft()\n                                zdata.popleft()\n\n                            ymin, ymax = ax.get_ylim()\n                            if y > ymax or z > ymax:\n                                ax.set_ylim(ymin, 1.1 * y)\n                                ax.figure.canvas.draw()\n\n                            t_ago = [cur_t - i for i in xdata]\n                            line1.set_data(t_ago, ydata)\n                            line2.set_data(t_ago, zdata)\n                            ax.set_title(format_meter(\n                                n, total, elapsed, ncols,\n                                prefix, True, unit, unit_scale),\n                                fontname=\"DejaVu Sans Mono\")\n                            plt.pause(1e-9)\n                        else:\n                            sp(format_meter(\n                                n, total, elapsed, ncols,\n                                prefix, ascii, unit, unit_scale))\n\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a was that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                if self.gui:\n                    ax = self.ax  # Inline due to multiple calls\n\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # smoothed rate\n                    z = self.n / elapsed\n                    # update line data\n                    self.xdata.append(cur_t)\n                    self.ydata.append(y)\n                    self.zdata.append(z)\n\n                    # Discard old values\n                    if elapsed > 60:\n                        self.xdata.popleft()\n                        self.ydata.popleft()\n                        self.zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ax.set_ylim(ymin, 1.1 * y)\n                        ax.figure.canvas.draw()\n\n                    t_ago = [cur_t - i for i in self.xdata]\n                    self.line1.set_data(t_ago, self.ydata)\n                    self.line2.set_data(t_ago, self.zdata)\n                    ax.set_title(format_meter(\n                        self.n, self.total, elapsed, self.ncols,\n                        self.prefix, True, self.unit, self.unit_scale),\n                        fontname=\"DejaVu Sans Mono\")\n                    self.plt.pause(1e-9)\n                else:\n                    self.sp(format_meter(\n                        self.n, self.total, elapsed, self.ncols,\n                        self.prefix, self.ascii, self.unit, self.unit_scale))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.gui:\n            # Restore toolbars\n            self.mpl.rcParams['toolbar'] = self.toolbar\n            # Return to non-interactive mode\n            if not self.wasion:\n                self.plt.ioff()\n            if not self.leave:\n                self.plt.close(self.fig)\n        else:\n            if self.leave:\n                if self.last_print_n < self.n:\n                    cur_t = time()\n                    self.sp(format_meter(\n                        self.n, self.total, cur_t-self.start_t, self.ncols,\n                        self.prefix, self.ascii, self.unit, self.unit_scale))\n                self.file.write('\\n')\n            else:\n                self.sp('')\n                self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  >>> from tqdm import trange[, tqdm]\n  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))\n  ...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            if abs(num) < 100.0:\n                if abs(num) < 10.0:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress bar\n        + no limit for the iterations counter and statistics. If 0, will not\n        print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, gui=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        gui  : bool, optional\n            If set, will attempt to use matplotlib animations for a\n            graphical output [default: false].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if gui:\n            try:\n                import matplotlib as mpl\n                import matplotlib.pyplot as plt\n                from collections import deque\n            except ImportError:\n                gui = False\n            else:\n                self.mpl = mpl\n                self.plt = plt\n\n        # Store the arguments\n        self.iterable = iterable\n        self.prefix = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n\n        if gui:\n            # Initialize the GUI display\n            if not disable:\n                file.write('Warning: GUI is experimental/alpha\\n')\n\n                # Remember if external environment uses toolbars\n                self.toolbar = self.mpl.rcParams['toolbar']\n                self.mpl.rcParams['toolbar'] = 'None'\n\n                self.mininterval = max(mininterval, 0.5)\n                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n                # self.fig.subplots_adjust(bottom=0.2)\n                if total:\n                    self.xdata = []\n                    self.ydata = []\n                    self.zdata = []\n                else:\n                    self.xdata = deque([])\n                    self.ydata = deque([])\n                    self.zdata = deque([])\n                self.line1, = ax.plot(self.xdata, self.ydata)\n                self.line2, = ax.plot(self.xdata, self.zdata)\n                ax.set_ylim(0, 0.001)\n                if total:\n                    ax.set_xlim(0, 100)\n                    ax.set_xlabel('percent')\n                else:\n                    # ax.set_xlim(-60, 0)\n                    ax.set_xlim(0, 60)\n                    ax.invert_xaxis()\n                    ax.set_xlabel('seconds')\n                ax.grid()\n                # ax.set_xlabel('seconds')\n                ax.set_ylabel((unit if unit else 'it') + '/s')\n                ax.legend(('cur', 'est'), loc='lower left')\n                if unit_scale:\n                    plt.ticklabel_format(style='sci', axis='y',\n                                         scilimits=(0, 0))\n                    ax.yaxis.get_offset_text().set_x(-0.15)\n\n                # Remember if external environment is interactive\n                self.wasion = plt.isinteractive()\n                plt.ion()\n                self.ax = ax\n        else:\n            # Initialize the screen printer\n            self.sp = StatusPrinter(self.file)\n            if not disable:\n                self.sp(format_meter(\n                    0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            total = self.total\n            prefix = self.prefix\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            gui = self.gui\n            if gui:\n                plt = self.plt\n                ax = self.ax\n                xdata = self.xdata\n                ydata = self.ydata\n                zdata = self.zdata\n                line1 = self.line1\n                line2 = self.line2\n            else:\n                sp = self.sp\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        if gui:\n                            # instantaneous rate\n                            y = delta_it / delta_t\n                            # smoothed rate\n                            z = n / elapsed\n                            # update line data\n                            xdata.append(n * 100.0 / total if total else cur_t)\n                            ydata.append(y)\n                            zdata.append(z)\n\n                            # Discard old values\n                            # xmin, xmax = ax.get_xlim()\n                            # if (not total) and elapsed > xmin * 1.1:\n                            if (not total) and elapsed > 66:\n                                xdata.popleft()\n                                ydata.popleft()\n                                zdata.popleft()\n\n                            ymin, ymax = ax.get_ylim()\n                            if y > ymax or z > ymax:\n                                ax.set_ylim(ymin, 1.1 * y)\n                                ax.figure.canvas.draw()\n\n                            if total:\n                                line1.set_data(xdata, ydata)\n                                line2.set_data(xdata, zdata)\n                            else:\n                                t_ago = [cur_t - i for i in xdata]\n                                line1.set_data(t_ago, ydata)\n                                line2.set_data(t_ago, zdata)\n\n                            ax.set_title(format_meter(\n                                n, total, elapsed, 0,\n                                prefix, ascii, unit, unit_scale),\n                                fontname=\"DejaVu Sans Mono\",\n                                fontsize=11)\n                            plt.pause(1e-9)\n                        else:\n                            sp(format_meter(\n                                n, total, elapsed, ncols,\n                                prefix, ascii, unit, unit_scale))\n\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a was that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                if self.gui:\n                    # Inline due to multiple calls\n                    ax = self.ax\n                    total = self.total\n\n                    # instantaneous rate\n                    y = delta_it / delta_t\n                    # smoothed rate\n                    z = self.n / elapsed\n                    # update line data\n                    self.xdata.append(self.n * 100.0 / total\n                                      if total else cur_t)\n                    self.ydata.append(y)\n                    self.zdata.append(z)\n\n                    # Discard old values\n                    if (not total) and elapsed > 66:\n                        self.xdata.popleft()\n                        self.ydata.popleft()\n                        self.zdata.popleft()\n\n                    ymin, ymax = ax.get_ylim()\n                    if y > ymax or z > ymax:\n                        ax.set_ylim(ymin, 1.1 * y)\n                        ax.figure.canvas.draw()\n\n                    if total:\n                        self.line1.set_data(self.xdata, self.ydata)\n                        self.line2.set_data(self.xdata, self.zdata)\n                    else:\n                        t_ago = [cur_t - i for i in self.xdata]\n                        self.line1.set_data(t_ago, self.ydata)\n                        self.line2.set_data(t_ago, self.zdata)\n\n                    ax.set_title(format_meter(\n                        self.n, total, elapsed, 0,\n                        self.prefix, self.ascii, self.unit, self.unit_scale),\n                        fontname=\"DejaVu Sans Mono\",\n                        fontsize=11)\n                    self.plt.pause(1e-9)\n                else:\n                    self.sp(format_meter(\n                        self.n, self.total, elapsed, self.ncols,\n                        self.prefix, self.ascii, self.unit, self.unit_scale))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.gui:\n            # Restore toolbars\n            self.mpl.rcParams['toolbar'] = self.toolbar\n            # Return to non-interactive mode\n            if not self.wasion:\n                self.plt.ioff()\n            if not self.leave:\n                self.plt.close(self.fig)\n        else:\n            if self.leave:\n                if self.last_print_n < self.n:\n                    cur_t = time()\n                    self.sp(format_meter(\n                        self.n, self.total, cur_t-self.start_t, self.ncols,\n                        self.prefix, self.ascii, self.unit, self.unit_scale))\n                self.file.write('\\n')\n            else:\n                self.sp('')\n                self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -84,9 +84,11 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     elapsed  : float\n         Number of seconds passed since start.\n     ncols  : int, optional\n-        The width of the entire output message. If sepcified, dynamically\n-        resizes the progress meter [default: None]. The fallback meter\n-        width is 10.\n+        The width of the entire output message. If specified, dynamically\n+        resizes the progress meter to stay within this bound\n+        [default: None]. The fallback meter width is 10 for the progress bar\n+        + no limit for the iterations counter and statistics. If 0, will not\n+        print any meter (only stats).\n     prefix  : str, optional\n         Prefix message (included in total width) [default: ''].\n     ascii  : bool, optional\n@@ -134,25 +136,25 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n \n         if ncols == 0:\n-            bar = ''\n-        else:\n-            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n-                else 10\n+            return l_bar[:-1] + r_bar[1:]\n \n-            if ascii:\n-                bar_length, frac_bar_length = divmod(\n-                    int(frac * N_BARS * 10), 10)\n+        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n+            else 10\n \n-                bar = '#'*bar_length\n-                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n-                    else ' '\n+        if ascii:\n+            bar_length, frac_bar_length = divmod(\n+                int(frac * N_BARS * 10), 10)\n \n-            else:\n-                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n+            bar = '#'*bar_length\n+            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n+                else ' '\n \n-                bar = _unich(0x2588)*bar_length\n-                frac_bar = _unich(0x2590 - frac_bar_length) \\\n-                    if frac_bar_length else ' '\n+        else:\n+            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n+\n+            bar = _unich(0x2588)*bar_length\n+            frac_bar = _unich(0x2590 - frac_bar_length) \\\n+                if frac_bar_length else ' '\n \n         if bar_length < N_BARS:\n             full_bar = bar + frac_bar + \\\n@@ -219,7 +221,8 @@ class tqdm(object):\n             The width of the entire output message. If specified, dynamically\n             resizes the progress meter to stay within this bound\n             [default: None]. The fallback meter width is 10 for the progress\n-            bar + no limit for the iterations counter and statistics.\n+            bar + no limit for the iterations counter and statistics. If 0,\n+            will not print any meter (only stats).\n         mininterval  : float, optional\n             Minimum progress update interval, in seconds [default: 0.1].\n         miniters  : int, optional\n@@ -303,17 +306,27 @@ class tqdm(object):\n                 self.mpl.rcParams['toolbar'] = 'None'\n \n                 self.mininterval = max(mininterval, 0.5)\n-                self.fig, ax = plt.subplots(figsize=(10, 3))\n+                self.fig, ax = plt.subplots(figsize=(9, 2.2))\n                 # self.fig.subplots_adjust(bottom=0.2)\n-                self.xdata = deque([])\n-                self.ydata = deque([])\n-                self.zdata = deque([])\n+                if total:\n+                    self.xdata = []\n+                    self.ydata = []\n+                    self.zdata = []\n+                else:\n+                    self.xdata = deque([])\n+                    self.ydata = deque([])\n+                    self.zdata = deque([])\n                 self.line1, = ax.plot(self.xdata, self.ydata)\n                 self.line2, = ax.plot(self.xdata, self.zdata)\n                 ax.set_ylim(0, 0.001)\n-                # ax.set_xlim(-60, 0)\n-                ax.set_xlim(0, 60)\n-                ax.invert_xaxis()\n+                if total:\n+                    ax.set_xlim(0, 100)\n+                    ax.set_xlabel('percent')\n+                else:\n+                    # ax.set_xlim(-60, 0)\n+                    ax.set_xlim(0, 60)\n+                    ax.invert_xaxis()\n+                    ax.set_xlabel('seconds')\n                 ax.grid()\n                 # ax.set_xlabel('seconds')\n                 ax.set_ylabel((unit if unit else 'it') + '/s')\n@@ -397,14 +410,14 @@ class tqdm(object):\n                             # smoothed rate\n                             z = n / elapsed\n                             # update line data\n-                            xdata.append(cur_t)\n+                            xdata.append(n * 100.0 / total if total else cur_t)\n                             ydata.append(y)\n                             zdata.append(z)\n \n                             # Discard old values\n                             # xmin, xmax = ax.get_xlim()\n-                            # if elapsed > xmin:\n-                            if elapsed > 60:\n+                            # if (not total) and elapsed > xmin * 1.1:\n+                            if (not total) and elapsed > 66:\n                                 xdata.popleft()\n                                 ydata.popleft()\n                                 zdata.popleft()\n@@ -414,13 +427,19 @@ class tqdm(object):\n                                 ax.set_ylim(ymin, 1.1 * y)\n                                 ax.figure.canvas.draw()\n \n-                            t_ago = [cur_t - i for i in xdata]\n-                            line1.set_data(t_ago, ydata)\n-                            line2.set_data(t_ago, zdata)\n+                            if total:\n+                                line1.set_data(xdata, ydata)\n+                                line2.set_data(xdata, zdata)\n+                            else:\n+                                t_ago = [cur_t - i for i in xdata]\n+                                line1.set_data(t_ago, ydata)\n+                                line2.set_data(t_ago, zdata)\n+\n                             ax.set_title(format_meter(\n-                                n, total, elapsed, ncols,\n-                                prefix, True, unit, unit_scale),\n-                                fontname=\"DejaVu Sans Mono\")\n+                                n, total, elapsed, 0,\n+                                prefix, ascii, unit, unit_scale),\n+                                fontname=\"DejaVu Sans Mono\",\n+                                fontsize=11)\n                             plt.pause(1e-9)\n                         else:\n                             sp(format_meter(\n@@ -472,19 +491,22 @@ class tqdm(object):\n             if delta_t >= self.mininterval:\n                 elapsed = cur_t - self.start_t\n                 if self.gui:\n-                    ax = self.ax  # Inline due to multiple calls\n+                    # Inline due to multiple calls\n+                    ax = self.ax\n+                    total = self.total\n \n                     # instantaneous rate\n                     y = delta_it / delta_t\n                     # smoothed rate\n                     z = self.n / elapsed\n                     # update line data\n-                    self.xdata.append(cur_t)\n+                    self.xdata.append(self.n * 100.0 / total\n+                                      if total else cur_t)\n                     self.ydata.append(y)\n                     self.zdata.append(z)\n \n                     # Discard old values\n-                    if elapsed > 60:\n+                    if (not total) and elapsed > 66:\n                         self.xdata.popleft()\n                         self.ydata.popleft()\n                         self.zdata.popleft()\n@@ -494,13 +516,19 @@ class tqdm(object):\n                         ax.set_ylim(ymin, 1.1 * y)\n                         ax.figure.canvas.draw()\n \n-                    t_ago = [cur_t - i for i in self.xdata]\n-                    self.line1.set_data(t_ago, self.ydata)\n-                    self.line2.set_data(t_ago, self.zdata)\n+                    if total:\n+                        self.line1.set_data(self.xdata, self.ydata)\n+                        self.line2.set_data(self.xdata, self.zdata)\n+                    else:\n+                        t_ago = [cur_t - i for i in self.xdata]\n+                        self.line1.set_data(t_ago, self.ydata)\n+                        self.line2.set_data(t_ago, self.zdata)\n+\n                     ax.set_title(format_meter(\n-                        self.n, self.total, elapsed, self.ncols,\n-                        self.prefix, True, self.unit, self.unit_scale),\n-                        fontname=\"DejaVu Sans Mono\")\n+                        self.n, total, elapsed, 0,\n+                        self.prefix, self.ascii, self.unit, self.unit_scale),\n+                        fontname=\"DejaVu Sans Mono\",\n+                        fontsize=11)\n                     self.plt.pause(1e-9)\n                 else:\n                     self.sp(format_meter(\n",
          "files_name_in_blame_commit": [
            "simple_examples.py",
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "743af04f3948c2943ee3a00007cbad06c783f801": {
        "commit": {
          "commit_id": "743af04f3948c2943ee3a00007cbad06c783f801",
          "commit_message": "prefix/desc with unknown total bugfix, 100% line test coverage",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-09-14 12:44:31",
          "commit_parent": "108ec57e706d01f82af4277cb96ba82fa7861ef6"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 72,
          "function_before_end_line": 168,
          "function_after_start_line": 72,
          "function_after_end_line": 168,
          "function_before_token_count": 347,
          "function_after_token_count": 355,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_iterate_over_csv_rows",
            "format_sizeof",
            "test_close",
            "test_min_interval",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "__init__",
            "update",
            "StatusPrinter",
            "test_file_output",
            "__len__",
            "format_interval",
            "format_meter",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_update"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 204,
          "file_complexity": 54,
          "file_token_count": 1362,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10): #same as: for i in tqdm(xrange(10))\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            if abs(num) < 100.0:\n                if abs(num) < 10.0:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics.\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.prefix = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp(format_meter(\n                0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            total = self.total\n            prefix = self.prefix\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            sp = self.sp\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    if cur_t - last_print_t >= mininterval:\n                        sp(format_meter(\n                            n, total, cur_t-start_t, ncols,\n                            prefix, ascii, unit, unit_scale))\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        >>>    ...\n        >>>    t.update(len(current_buffer)).\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a was that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n            self.file.write('\\n')\n        else:\n            self.sp('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10): #same as: for i in tqdm(xrange(10))\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"obiwanus\", \"kmike\", \"hadim\",\n                              \"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            if abs(num) < 100.0:\n                if abs(num) < 10.0:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics.\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.prefix = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp(format_meter(\n                0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            total = self.total\n            prefix = self.prefix\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            sp = self.sp\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    if cur_t - last_print_t >= mininterval:\n                        sp(format_meter(\n                            n, total, cur_t-start_t, ncols,\n                            prefix, ascii, unit, unit_scale))\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        >>>    ...\n        >>>    t.update(len(current_buffer)).\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a was that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n            self.file.write('\\n')\n        else:\n            self.sp('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -164,7 +164,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n         return l_bar + full_bar + r_bar\n \n     else:  # no progressbar nor ETA, just progress statistics\n-        return '{0}{1} [{2}, {3}]'.format(\n+        return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n             n_fmt, unit, elapsed_str, rate_fmt)\n \n \n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "66672fe244165e43ce0f0971e0c8cad9093042bc": {
        "commit": {
          "commit_id": "66672fe244165e43ce0f0971e0c8cad9093042bc",
          "commit_message": "minor bugfixes, formatting fixes, documentation, unit tests",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-09-13 18:47:52",
          "commit_parent": "6c0b7541b3d1b3633d62be7f31333640a3bd9b28"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 72,
          "function_before_end_line": 168,
          "function_after_start_line": 72,
          "function_after_end_line": 168,
          "function_before_token_count": 347,
          "function_after_token_count": 347,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "update",
            "trange",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_iterate_over_csv_rows",
            "format_sizeof",
            "test_close",
            "test_min_interval",
            "__iter__",
            "test_update",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "__init__",
            "update",
            "StatusPrinter",
            "test_file_output",
            "__len__",
            "format_interval",
            "format_meter",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "update",
            "StatusPrinter",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "update",
            "test_close",
            "StatusPrinter",
            "test_file_output",
            "test_leave_option",
            "__len__",
            "__iter__",
            "test_update",
            "format_sizeof",
            "format_interval",
            "test_min_iters",
            "test_unit"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 213,
          "file_complexity": 55,
          "file_token_count": 1407,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix.\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            if abs(num) < 100.0:\n                if abs(num) < 10.0:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n               + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                         else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    last_printed_len = [0]\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp(format_meter(\n                0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return self.iterable.__len__()\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # if the bar is disabled, then just walk the iterable\n        # (note that we keep this condition above the loop for performance,\n        # so that we don't have to repeatedly check the condition inside\n        # the loop)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            total = self.total\n            prefix = self.prefix\n            leave = self.leave\n            file = self.file\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            sp = self.sp\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            for obj in iterable:\n                yield obj\n                # UPDATE\n                # Now that the iterable object was created and processed,\n                # we can update and print the progress meter\n                # Note: this is an optimization, we could call self.update(1)\n                # but it would be way slower (because of method call)\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    if cur_t - last_print_t >= mininterval:\n                        sp(format_meter(\n                            n, total, cur_t-start_t, ncols,\n                            prefix, ascii, unit, unit_scale))\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # CLOSE\n            # Closing the progress bar\n            if leave:\n                if last_print_n < n:\n                    cur_t = time()\n                    sp(format_meter(\n                        n, total, cur_t-start_t, ncols,\n                        prefix, ascii, unit, unit_scale))\n                file.write('\\n')\n            else:\n                sp('')\n                file.write('\\r')\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n        use update(len(current_buffer)).\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n            self.file.write('\\n')\n        else:\n            self.sp('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10): #same as: for i in tqdm(xrange(10))\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            if abs(num) < 100.0:\n                if abs(num) < 10.0:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n        + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                         else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\ndef StatusPrinter(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    last_printed_len = [0]  # closure over mutable variable (fast)\n\n    def print_status(s):\n        len_s = len(s)\n        fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n        fp.flush()\n        last_printed_len[0] = len_s\n    return print_status\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank [default: None] to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar [default: None].\n        total  : int, optional\n            The number of expected iterations. If not given, len(iterable) is\n            used if possible. As a last resort, only basic progress\n            statistics are displayed (no ETA, no progressbar).\n        leave  : bool, optional\n            If [default: False], removes all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified, dynamically\n            resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics.\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations [default: None].\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If [default: None] or false, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable : bool\n            Whether to disable the entire progressbar wrapper [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n            mininterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.prefix = desc+': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp(format_meter(\n                0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return len(self.iterable)\n\n    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            total = self.total\n            prefix = self.prefix\n            leave = self.leave\n            file = self.file\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            sp = self.sp\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    if cur_t - last_print_t >= mininterval:\n                        sp(format_meter(\n                            n, total, cur_t-start_t, ncols,\n                            prefix, ascii, unit, unit_scale))\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # Closing the progress bar\n            # Note: does not call self.close() for speed optimisation.\n            if leave:\n                if last_print_n < n:\n                    cur_t = time()\n                    sp(format_meter(\n                        n, total, cur_t-start_t, ncols,\n                        prefix, ascii, unit, unit_scale))\n                file.write('\\n')\n            else:\n                sp('')\n                file.write('\\r')\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        >>>    ...\n        >>>    t.update(len(current_buffer)).\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a was that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                self.sp(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n            self.file.write('\\n')\n        else:\n            self.sp('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -4,7 +4,7 @@ Includes a default (x)range iterator printing to stderr.\n \n Usage:\n   from tqdm import trange[, tqdm]\n-  for i in trange(10):\n+  for i in trange(10): #same as: for i in tqdm(xrange(10))\n     ...\n \"\"\"\n # future division is important to divide integers and get as\n@@ -30,7 +30,7 @@ def format_sizeof(num, suffix=''):\n     num  : float\n         Number ( >= 1) to format.\n     suffix  : str, optional\n-        Post-postfix.\n+        Post-postfix [default: ''].\n \n     Returns\n     -------\n@@ -55,7 +55,7 @@ def format_interval(t):\n     Parameters\n     ----------\n     t  : int\n-        Number of seconds\n+        Number of seconds.\n     Returns\n     -------\n     out  : str\n@@ -88,7 +88,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n         resizes the progress meter [default: None]. The fallback meter\n         width is 10.\n     prefix  : str, optional\n-        Prefix message (included in total width).\n+        Prefix message (included in total width) [default: ''].\n     ascii  : bool, optional\n         If not set, use unicode (smooth blocks) to fill the meter\n         [default: False]. The fallback is to use ASCII characters (1-9 #).\n@@ -114,7 +114,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n     rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                  '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                 '?') \\\n-               + unit + '/s'\n+        + unit + '/s'\n \n     if unit_scale:\n         n_fmt = format_sizeof(n)\n@@ -175,7 +175,8 @@ def StatusPrinter(file):\n     may not work (it will print a new line at each refresh).\n     \"\"\"\n     fp = file\n-    last_printed_len = [0]\n+    last_printed_len = [0]  # closure over mutable variable (fast)\n+\n     def print_status(s):\n         len_s = len(s)\n         fp.write('\\r' + s + ' '*max(last_printed_len[0] - len_s, 0))\n@@ -189,57 +190,59 @@ class tqdm(object):\n     Decorate an iterable object, returning an iterator which acts exactly\n     like the orignal iterable, but prints a dynamically updating\n     progressbar every time a value is requested.\n-\n-    Parameters\n-    ----------\n-    iterable  : iterable, optional\n-        Iterable to decorate with a progressbar. You can leave\n-        it to None if you want to manually manage the updates.\n-    desc  : str, optional\n-        Prefix for the progressbar.\n-    total  : int, optional\n-        The number of expected iterations. If not given, len(iterable) is\n-        used if possible. As a last resort, only basic progress statistics\n-        are displayed (no ETA, no progressbar).\n-    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n-        Specifies where to output the progress messages.\n-        Uses file.write(str) and file.flush() methods.\n-    leave  : bool, optional\n-        if unset, removes all traces of the progressbar upon termination of\n-        iteration [default: False].\n-    ncols  : int, optional\n-        The width of the entire output message. If specified, dynamically\n-        resizes the progress meter to stay within this bound [default: None].\n-        The fallback meter width is 10 for the progress bar + no limit for\n-        the iterations counter and statistics.\n-    mininterval  : float, optional\n-        Minimum progress update interval, in seconds [default: 0.1].\n-    miniters  : int, optional\n-        Minimum progress update interval, in iterations [default: None].\n-    unit  : str, optional\n-        String that will be used to define the unit of each iteration\n-        [default: 'it'].\n-    unit_scale  : bool, optional\n-        If set, the number of iterations will be reduced/scaled\n-        automatically and a metric prefix following the\n-        International System of Units standard will be added\n-        (kilo, mega, etc.). [default: False]\n-    ascii  : bool, optional\n-        If not set, use unicode (smooth blocks) to fill the meter\n-        [default: False]. The fallback is to use ASCII characters (1-9 #).\n-    disable : bool\n-        Disable the progress bar if True [default: False].\n-\n-    Returns\n-    -------\n-    out  : decorated iterator.\n     \"\"\"\n \n     def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                  file=sys.stderr, ncols=None, mininterval=0.1,\n                  miniters=None, ascii=None, disable=False,\n                  unit='it', unit_scale=False):\n-\n+        \"\"\"\n+        Parameters\n+        ----------\n+        iterable  : iterable, optional\n+            Iterable to decorate with a progressbar.\n+            Leave blank [default: None] to manually manage the updates.\n+        desc  : str, optional\n+            Prefix for the progressbar [default: None].\n+        total  : int, optional\n+            The number of expected iterations. If not given, len(iterable) is\n+            used if possible. As a last resort, only basic progress\n+            statistics are displayed (no ETA, no progressbar).\n+        leave  : bool, optional\n+            If [default: False], removes all traces of the progressbar\n+            upon termination of iteration.\n+        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n+            Specifies where to output the progress messages\n+            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n+            methods.\n+        ncols  : int, optional\n+            The width of the entire output message. If specified, dynamically\n+            resizes the progress meter to stay within this bound\n+            [default: None]. The fallback meter width is 10 for the progress\n+            bar + no limit for the iterations counter and statistics.\n+        mininterval  : float, optional\n+            Minimum progress update interval, in seconds [default: 0.1].\n+        miniters  : int, optional\n+            Minimum progress update interval, in iterations [default: None].\n+            If specified, will set `mininterval` to 0.\n+        ascii  : bool, optional\n+            If [default: None] or false, use unicode (smooth blocks) to fill\n+            the meter. The fallback is to use ASCII characters `1-9 #`.\n+        disable : bool\n+            Whether to disable the entire progressbar wrapper [default: False].\n+        unit  : str, optional\n+            String that will be used to define the unit of each iteration\n+            [default: 'it'].\n+        unit_scale  : bool, optional\n+            If set, the number of iterations will be reduced/scaled\n+            automatically and a metric prefix following the\n+            International System of Units standard will be added\n+            (kilo, mega, etc.) [default: False].\n+\n+        Returns\n+        -------\n+        out  : decorated iterator.\n+        \"\"\"\n         # Preprocess the arguments\n         if total is None and iterable is not None:\n             try:\n@@ -255,14 +258,15 @@ class tqdm(object):\n             dynamic_miniters = True\n         else:\n             dynamic_miniters = False\n+            mininterval = 0\n \n         if ascii is None:\n             ascii = not _supports_unicode(file)\n \n         # Store the arguments\n         self.iterable = iterable\n-        self.total = total\n         self.prefix = desc+': ' if desc else ''\n+        self.total = total\n         self.leave = leave\n         self.file = file\n         self.ncols = ncols\n@@ -270,9 +274,9 @@ class tqdm(object):\n         self.miniters = miniters\n         self.dynamic_miniters = dynamic_miniters\n         self.ascii = ascii\n+        self.disable = disable\n         self.unit = unit\n         self.unit_scale = unit_scale\n-        self.disable = disable\n \n         # Initialize the screen printer\n         self.sp = StatusPrinter(self.file)\n@@ -286,18 +290,16 @@ class tqdm(object):\n         self.n = 0\n \n     def __len__(self):\n-        return self.iterable.__len__()\n+        return len(self.iterable)\n \n     def __iter__(self):\n-        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n+        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n \n         # Inlining instance variables as locals (speed optimisation)\n         iterable = self.iterable\n \n-        # if the bar is disabled, then just walk the iterable\n-        # (note that we keep this condition above the loop for performance,\n-        # so that we don't have to repeatedly check the condition inside\n-        # the loop)\n+        # If the bar is disabled, then just walk the iterable\n+        # (note: keep this check outside the loop for performance)\n         if self.disable:\n             for obj in iterable:\n                 yield obj\n@@ -320,11 +322,8 @@ class tqdm(object):\n             n = self.n\n             for obj in iterable:\n                 yield obj\n-                # UPDATE\n-                # Now that the iterable object was created and processed,\n-                # we can update and print the progress meter\n-                # Note: this is an optimization, we could call self.update(1)\n-                # but it would be way slower (because of method call)\n+                # Update and print the progressbar.\n+                # Note: does not call self.update(1) for speed optimisation.\n                 n += 1\n                 delta_it = n - last_print_n\n                 # check the counter first (avoid calls to time())\n@@ -338,8 +337,8 @@ class tqdm(object):\n                             miniters = max(miniters, delta_it)\n                         last_print_n = n\n                         last_print_t = cur_t\n-            # CLOSE\n             # Closing the progress bar\n+            # Note: does not call self.close() for speed optimisation.\n             if leave:\n                 if last_print_n < n:\n                     cur_t = time()\n@@ -355,13 +354,21 @@ class tqdm(object):\n         \"\"\"\n         Manually update the progress bar, useful for streams\n         such as reading files.\n-        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n-        use update(len(current_buffer)).\n+        E.g.:\n+        >>> t = tqdm(total=filesize) # Initialise\n+        >>> for current_buffer in stream:\n+        >>>    ...\n+        >>>    t.update(len(current_buffer)).\n+        >>> t.close()\n+        The last line is highly recommended, but possibly not necessary if\n+        `t.update()` will be called in such a was that `filesize` will be\n+        exactly reached and printed.\n \n         Parameters\n         ----------\n         n  : int\n-            Increment to add to the internal counter of iterations.\n+            Increment to add to the internal counter of iterations\n+            [default: 1].\n         \"\"\"\n         if n < 1:\n             n = 1\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "ee6c3ce95c4452b4829f2e6685334386ad8fda51": {
        "commit": {
          "commit_id": "ee6c3ce95c4452b4829f2e6685334386ad8fda51",
          "commit_message": "cursory tidying, optimisation, tests",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-07-16 01:58:07",
          "commit_parent": "13c6045fe19721a59dcbc1c29b126ea75cd3c4e3"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else '{0:5.2f}'.format(n / elapsed)) if elapsed else '?') + unit + '/s'\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3}]'.format(n_fmt, unit, elapsed_str, rate_fmt)",
          "function_before_start_line": 44,
          "function_before_end_line": 151,
          "function_after_start_line": 72,
          "function_after_end_line": 168,
          "function_before_token_count": 379,
          "function_after_token_count": 347,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "trange",
            "test_disable",
            "test_iterate_over_csv_rows",
            "format_sizeof",
            "test_min_interval",
            "__iter__",
            "test_trange",
            "test_min_iters",
            "close",
            "test_all_defaults",
            "test_leave_option",
            "test_format_meter",
            "test_unit",
            "__init__",
            "print_status",
            "update",
            "test_file_output",
            "__len__",
            "format_interval",
            "format_meter",
            "test_format_interval"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "__init__",
            "print_status",
            "update",
            "__len__",
            "__iter__",
            "format_sizeof",
            "format_interval"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "__init__",
            "print_status",
            "update",
            "__len__",
            "__iter__",
            "test_format_meter",
            "format_sizeof",
            "format_interval"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 261,
          "file_complexity": 55,
          "file_token_count": 1430,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n        num /= 1000.0\n    return '{0:.1f}Y{1}'.format(num, suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='',\n                 unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str,\n                rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                         else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # spacing\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # spacing\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3} {4}/s]'.format(\n            n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, unit=None, unit_scale=False, ascii=None,\n                 disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp.print_status(format_meter(\n                0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        # if the bar is disabled, then just walk the iterable\n        # (note that we keep this condition above the loop for performance,\n        # so that we don't have to repeatedly check the condition inside\n        # the loop)\n\n        # Inline all instance variables as locals (big speed optimization)\n        iterable = self.iterable\n        total = self.total\n        prefix = self.prefix\n        leave = self.leave\n        file = self.file\n        ncols = self.ncols\n        mininterval = self.mininterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        unit = self.unit\n        unit_scale = self.unit_scale\n        ascii = self.ascii\n        disable = self.disable\n        sp = self.sp\n        start_t = self.start_t\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n\n        if disable:\n            for obj in iterable:\n                yield obj\n        else:\n            for obj in iterable:\n                yield obj\n                # UPDATE\n                # Now that the iterable object was created and processed,\n                # we can update and print the progress meter\n                # Note: this is an optimization, we could call self.update(1)\n                # but it would be way slower (because of method call)\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    if cur_t - last_print_t >= mininterval:\n                        sp.print_status(format_meter(\n                            n, total, cur_t-start_t, ncols,\n                            prefix, unit, unit_scale, ascii))\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # CLOSE\n            # Closing the progress bar\n            if leave:\n                if last_print_n < n:\n                    cur_t = time()\n                    sp.print_status(format_meter(\n                        n, total, cur_t-start_t, ncols,\n                        prefix, unit, unit_scale, ascii))\n                file.write('\\n')\n            else:\n                sp.print_status('')\n                file.write('\\r')\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n        use update(len(current_buffer)).\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nfrom time import time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix=''):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix.\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            if abs(num) < 100.0:\n                if abs(num) < 10.0:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= 1000.0\n    return '{0:3.1f}Y'.format(num) + suffix\n\n\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic\n        progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will printed with an appropriate\n        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n\n    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n                '?') \\\n               + unit + '/s'\n\n    if unit_scale:\n        n_fmt = format_sizeof(n)\n        total_fmt = format_sizeof(total) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                         else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3}]'.format(\n            n_fmt, unit, elapsed_str, rate_fmt)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r' + s + ' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp.print_status(format_meter(\n                0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __len__(self):\n        return self.iterable.__len__()\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # if the bar is disabled, then just walk the iterable\n        # (note that we keep this condition above the loop for performance,\n        # so that we don't have to repeatedly check the condition inside\n        # the loop)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            total = self.total\n            prefix = self.prefix\n            leave = self.leave\n            file = self.file\n            ncols = self.ncols\n            mininterval = self.mininterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            sp = self.sp\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            for obj in iterable:\n                yield obj\n                # UPDATE\n                # Now that the iterable object was created and processed,\n                # we can update and print the progress meter\n                # Note: this is an optimization, we could call self.update(1)\n                # but it would be way slower (because of method call)\n                n += 1\n                delta_it = n - last_print_n\n                # check the counter first (avoid calls to time())\n                if delta_it >= miniters:\n                    cur_t = time()\n                    if cur_t - last_print_t >= mininterval:\n                        sp.print_status(format_meter(\n                            n, total, cur_t-start_t, ncols,\n                            prefix, ascii, unit, unit_scale))\n                        if dynamic_miniters:\n                            miniters = max(miniters, delta_it)\n                        last_print_n = n\n                        last_print_t = cur_t\n            # CLOSE\n            # Closing the progress bar\n            if leave:\n                if last_print_n < n:\n                    cur_t = time()\n                    sp.print_status(format_meter(\n                        n, total, cur_t-start_t, ncols,\n                        prefix, ascii, unit, unit_scale))\n                file.write('\\n')\n            else:\n                sp.print_status('')\n                file.write('\\r')\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n        use update(len(current_buffer)).\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time()\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.ascii, self.unit, self.unit_scale))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -21,18 +21,46 @@ __author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n __all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n \n \n-def format_sizeof(num, suffix='bytes'):\n+def format_sizeof(num, suffix=''):\n     \"\"\"\n-    Readable size format, courtesy of Sridhar Ratnakumar\n+    Formats a number (greater than unity) with SI Order of Magnitude prefixes.\n+\n+    Parameters\n+    ----------\n+    num  : float\n+        Number ( >= 1) to format.\n+    suffix  : str, optional\n+        Post-postfix.\n+\n+    Returns\n+    -------\n+    out  : str\n+        Number with Order of Magnitude SI unit postfix.\n     \"\"\"\n     for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n         if abs(num) < 1000.0:\n-            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n+            if abs(num) < 100.0:\n+                if abs(num) < 10.0:\n+                    return '{0:1.2f}'.format(num) + unit + suffix\n+                return '{0:2.1f}'.format(num) + unit + suffix\n+            return '{0:3.0f}'.format(num) + unit + suffix\n         num /= 1000.0\n-    return '{0:.1f}Y{1}'.format(num, suffix)\n+    return '{0:3.1f}Y'.format(num) + suffix\n \n \n def format_interval(t):\n+    \"\"\"\n+    Formats a number of seconds as a clock time, [H:]MM:SS\n+\n+    Parameters\n+    ----------\n+    t  : int\n+        Number of seconds\n+    Returns\n+    -------\n+    out  : str\n+        [H:]MM:SS\n+    \"\"\"\n     mins, s = divmod(int(t), 60)\n     h, m = divmod(mins, 60)\n     if h:\n@@ -41,8 +69,8 @@ def format_interval(t):\n         return '{0:02d}:{1:02d}'.format(m, s)\n \n \n-def format_meter(n, total, elapsed, ncols=None, prefix='',\n-                 unit=None, unit_scale=False, ascii=False):\n+def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n+                 unit='it', unit_scale=False):\n     \"\"\"\n     Return a string-based progress bar given some parameters\n \n@@ -51,8 +79,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n     n  : int\n         Number of finished iterations.\n     total  : int\n-        The expected total number of iterations. If None, only basic progress\n-        statistics are displayed (no ETA).\n+        The expected total number of iterations. If meaningless (), only basic\n+        progress statistics are displayed (no ETA).\n     elapsed  : float\n         Number of seconds passed since start.\n     ncols  : int, optional\n@@ -61,17 +89,14 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n         width is 10.\n     prefix  : str, optional\n         Prefix message (included in total width).\n-    unit  : str, optional\n-        String that will be used to define the unit of each iteration.\n-        [default: \"it\"]\n-    unit_scale  : bool, optional\n-        If set, the number of iterations will be reduced/scaled\n-        automatically and a metric prefix following the\n-        International System of Units standard will be added\n-        (kilo, mega, etc.). [default: False]\n     ascii  : bool, optional\n         If not set, use unicode (smooth blocks) to fill the meter\n         [default: False]. The fallback is to use ASCII characters (1-9 #).\n+    unit  : str, optional\n+        The iteration unit [default: 'it'].\n+    unit_scale  : bool, optional\n+        If set, the number of iterations will printed with an appropriate\n+        SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n \n     Returns\n     -------\n@@ -85,24 +110,18 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n         total = None\n \n     elapsed_str = format_interval(elapsed)\n-    if elapsed:\n-        if unit_scale:\n-            rate = format_sizeof(n / elapsed, suffix='')\n-        else:\n-            rate = '{0:5.2f}'.format(n / elapsed)\n-    else:\n-        rate = '?'\n \n-    rate_unit = unit if unit else 'it'\n-    if not unit:\n-        unit = ''\n+    rate_fmt = ((format_sizeof(n / elapsed) if unit_scale else\n+                 '{0:5.2f}'.format(n / elapsed)) if elapsed else\n+                '?') \\\n+               + unit + '/s'\n \n-    n_fmt = str(n)\n-    total_fmt = str(total)\n     if unit_scale:\n-        n_fmt = format_sizeof(n, suffix='')\n-        if total:\n-            total_fmt = format_sizeof(total, suffix='')\n+        n_fmt = format_sizeof(n)\n+        total_fmt = format_sizeof(total) if total else None\n+    else:\n+        n_fmt = str(n)\n+        total_fmt = str(total)\n \n     if total:\n         frac = n / total\n@@ -110,11 +129,9 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n \n         remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n \n-        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n-                '{0:3.0f}%|'.format(percentage)\n-        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n-                n_fmt, total_fmt, unit, elapsed_str, remaining_str,\n-                rate, rate_unit)\n+        l_bar = (prefix if prefix else '') + '{0:3.0f}%|'.format(percentage)\n+        r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n+                n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n \n         if ncols == 0:\n             bar = ''\n@@ -139,16 +156,16 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n \n         if bar_length < N_BARS:\n             full_bar = bar + frac_bar + \\\n-                ' ' * max(N_BARS - bar_length - 1, 0)  # spacing\n+                ' ' * max(N_BARS - bar_length - 1, 0)  # bar end padding\n         else:\n             full_bar = bar + \\\n-                ' ' * max(N_BARS - bar_length, 0)  # spacing\n+                ' ' * max(N_BARS - bar_length, 0)  # bar end padding\n \n         return l_bar + full_bar + r_bar\n \n     else:  # no progressbar nor ETA, just progress statistics\n-        return '{0}{1} [{2}, {3} {4}/s]'.format(\n-            n_fmt, unit, elapsed_str, rate, rate_unit)\n+        return '{0}{1} [{2}, {3}]'.format(\n+            n_fmt, unit, elapsed_str, rate_fmt)\n \n \n class StatusPrinter(object):\n@@ -163,7 +180,7 @@ class StatusPrinter(object):\n \n     def print_status(self, s):\n         len_s = len(s)\n-        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n+        self.file.write('\\r' + s + ' '*max(self.last_printed_len - len_s, 0))\n         self.file.flush()\n         self.last_printed_len = len_s\n \n@@ -201,8 +218,8 @@ class tqdm(object):\n     miniters  : int, optional\n         Minimum progress update interval, in iterations [default: None].\n     unit  : str, optional\n-        String that will be used to define the unit of each iteration.\n-        [default: \"it\"]\n+        String that will be used to define the unit of each iteration\n+        [default: 'it'].\n     unit_scale  : bool, optional\n         If set, the number of iterations will be reduced/scaled\n         automatically and a metric prefix following the\n@@ -221,8 +238,8 @@ class tqdm(object):\n \n     def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                  file=sys.stderr, ncols=None, mininterval=0.1,\n-                 miniters=None, unit=None, unit_scale=False, ascii=None,\n-                 disable=False):\n+                 miniters=None, ascii=None, disable=False,\n+                 unit='it', unit_scale=False):\n \n         # Preprocess the arguments\n         if total is None and iterable is not None:\n@@ -253,53 +270,55 @@ class tqdm(object):\n         self.mininterval = mininterval\n         self.miniters = miniters\n         self.dynamic_miniters = dynamic_miniters\n+        self.ascii = ascii\n         self.unit = unit\n         self.unit_scale = unit_scale\n-        self.ascii = ascii\n         self.disable = disable\n \n         # Initialize the screen printer\n         self.sp = StatusPrinter(self.file)\n         if not disable:\n             self.sp.print_status(format_meter(\n-                0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n+                0, total, 0, ncols, self.prefix, ascii, unit, unit_scale))\n \n         # Init the time/iterations counters\n         self.start_t = self.last_print_t = time()\n         self.last_print_n = 0\n         self.n = 0\n \n+    def __len__(self):\n+        return self.iterable.__len__()\n+\n     def __iter__(self):\n         ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n+\n+        # Inlining instance variables as locals (speed optimisation)\n+        iterable = self.iterable\n+\n         # if the bar is disabled, then just walk the iterable\n         # (note that we keep this condition above the loop for performance,\n         # so that we don't have to repeatedly check the condition inside\n         # the loop)\n-\n-        # Inline all instance variables as locals (big speed optimization)\n-        iterable = self.iterable\n-        total = self.total\n-        prefix = self.prefix\n-        leave = self.leave\n-        file = self.file\n-        ncols = self.ncols\n-        mininterval = self.mininterval\n-        miniters = self.miniters\n-        dynamic_miniters = self.dynamic_miniters\n-        unit = self.unit\n-        unit_scale = self.unit_scale\n-        ascii = self.ascii\n-        disable = self.disable\n-        sp = self.sp\n-        start_t = self.start_t\n-        last_print_t = self.last_print_t\n-        last_print_n = self.last_print_n\n-        n = self.n\n-\n-        if disable:\n+        if self.disable:\n             for obj in iterable:\n                 yield obj\n         else:\n+            total = self.total\n+            prefix = self.prefix\n+            leave = self.leave\n+            file = self.file\n+            ncols = self.ncols\n+            mininterval = self.mininterval\n+            miniters = self.miniters\n+            dynamic_miniters = self.dynamic_miniters\n+            unit = self.unit\n+            unit_scale = self.unit_scale\n+            ascii = self.ascii\n+            sp = self.sp\n+            start_t = self.start_t\n+            last_print_t = self.last_print_t\n+            last_print_n = self.last_print_n\n+            n = self.n\n             for obj in iterable:\n                 yield obj\n                 # UPDATE\n@@ -315,7 +334,7 @@ class tqdm(object):\n                     if cur_t - last_print_t >= mininterval:\n                         sp.print_status(format_meter(\n                             n, total, cur_t-start_t, ncols,\n-                            prefix, unit, unit_scale, ascii))\n+                            prefix, ascii, unit, unit_scale))\n                         if dynamic_miniters:\n                             miniters = max(miniters, delta_it)\n                         last_print_n = n\n@@ -327,7 +346,7 @@ class tqdm(object):\n                     cur_t = time()\n                     sp.print_status(format_meter(\n                         n, total, cur_t-start_t, ncols,\n-                        prefix, unit, unit_scale, ascii))\n+                        prefix, ascii, unit, unit_scale))\n                 file.write('\\n')\n             else:\n                 sp.print_status('')\n@@ -359,7 +378,7 @@ class tqdm(object):\n             if cur_t - self.last_print_t >= self.mininterval:\n                 self.sp.print_status(format_meter(\n                     self.n, self.total, cur_t-self.start_t, self.ncols,\n-                    self.prefix, self.unit, self.unit_scale, self.ascii))\n+                    self.prefix, self.ascii, self.unit, self.unit_scale))\n                 if self.dynamic_miniters:\n                     self.miniters = max(self.miniters, delta_it)\n                 self.last_print_n = self.n\n@@ -375,7 +394,7 @@ class tqdm(object):\n                 cur_t = time()\n                 self.sp.print_status(format_meter(\n                     self.n, self.total, cur_t-self.start_t, self.ncols,\n-                    self.prefix, self.unit, self.unit_scale, self.ascii))\n+                    self.prefix, self.ascii, self.unit, self.unit_scale))\n             self.file.write('\\n')\n         else:\n             self.sp.print_status('')\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "fffe2e70bc7a96795e44d1e784e7e2940d0f2c10": {
        "commit": {
          "commit_id": "fffe2e70bc7a96795e44d1e784e7e2940d0f2c10",
          "commit_message": "fix flake8 again\n\nSigned-off-by: Stephen L. <lrq3000@gmail.com>",
          "commit_author": "Stephen L",
          "commit_date": "2015-07-13 15:44:26",
          "commit_parent": "b625ff4bbdbf1b5e56d4e7504c40819d381ec457"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_before_start_line": 44,
          "function_before_end_line": 150,
          "function_after_start_line": 44,
          "function_after_end_line": 151,
          "function_before_token_count": 382,
          "function_after_token_count": 379,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 226,
          "file_complexity": 49,
          "file_token_count": 1214,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n        num /= 1000.0\n    return '{0:.1f}Y{1}'.format(num, suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='',\n                          unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format( \\\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, \\\n                rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                             else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                                else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # spacing\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # spacing\n\n        return l_bar + full_bar + r_bar\n\n    else: # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3} {4}/s]'.format( \\\n            n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                      file=sys.stderr, ncols=None, mininterval=0.1, miniters=None,\n                      unit=None, unit_scale=False, ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp.print_status(format_meter(\n                0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        # if the bar is disabled, then just walk the iterable\n        # (note that we keep this condition above the loop for performance,\n        # so that we don't have to repeatedly check the condition inside\n        # the loop)\n        if self.disable:\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now that the iterable object was created and processed,\n                # we can print the progress meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n        use update(len(current_buffer)).\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n        num /= 1000.0\n    return '{0:.1f}Y{1}'.format(num, suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='',\n         unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str,\n                rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                             else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                                else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # spacing\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # spacing\n\n        return l_bar + full_bar + r_bar\n\n    else:  # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3} {4}/s]'.format(\n            n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                      file=sys.stderr, ncols=None, mininterval=0.1,\n                      miniters=None, unit=None, unit_scale=False, ascii=None,\n                      disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp.print_status(format_meter(\n                0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        # if the bar is disabled, then just walk the iterable\n        # (note that we keep this condition above the loop for performance,\n        # so that we don't have to repeatedly check the condition inside\n        # the loop)\n        if self.disable:\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now that the iterable object was created and processed,\n                # we can print the progress meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n        use update(len(current_buffer)).\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -42,7 +42,7 @@ def format_interval(t):\n \n \n def format_meter(n, total, elapsed, ncols=None, prefix='',\n-                          unit=None, unit_scale=False, ascii=False):\n+         unit=None, unit_scale=False, ascii=False):\n     \"\"\"\n     Return a string-based progress bar given some parameters\n \n@@ -112,8 +112,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n \n         l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                 '{0:3.0f}%|'.format(percentage)\n-        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format( \\\n-                n_fmt, total_fmt, unit, elapsed_str, remaining_str, \\\n+        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n+                n_fmt, total_fmt, unit, elapsed_str, remaining_str,\n                 rate, rate_unit)\n \n         if ncols == 0:\n@@ -123,7 +123,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n                              else 10\n \n             if ascii:\n-                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n+                bar_length, frac_bar_length = divmod(\n+                    int(frac * N_BARS * 10), 10)\n \n                 bar = '#'*bar_length\n                 frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n@@ -145,8 +146,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='',\n \n         return l_bar + full_bar + r_bar\n \n-    else: # no progressbar nor ETA, just progress statistics\n-        return '{0}{1} [{2}, {3} {4}/s]'.format( \\\n+    else:  # no progressbar nor ETA, just progress statistics\n+        return '{0}{1} [{2}, {3} {4}/s]'.format(\n             n_fmt, unit, elapsed_str, rate, rate_unit)\n \n \n@@ -219,8 +220,9 @@ class tqdm(object):\n     \"\"\"\n \n     def __init__(self, iterable=None, desc=None, total=None, leave=False,\n-                      file=sys.stderr, ncols=None, mininterval=0.1, miniters=None,\n-                      unit=None, unit_scale=False, ascii=None, disable=False):\n+                      file=sys.stderr, ncols=None, mininterval=0.1,\n+                      miniters=None, unit=None, unit_scale=False, ascii=None,\n+                      disable=False):\n \n         # Preprocess the arguments\n         if total is None and iterable is not None:\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "b625ff4bbdbf1b5e56d4e7504c40819d381ec457": {
        "commit": {
          "commit_id": "b625ff4bbdbf1b5e56d4e7504c40819d381ec457",
          "commit_message": "fix flake8\n\nSigned-off-by: Stephen L. <lrq3000@gmail.com>",
          "commit_author": "Stephen L",
          "commit_date": "2015-07-13 15:19:06",
          "commit_parent": "841585e5cb33962c1ca336c39aa894d88ced13ac"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_before_start_line": 40,
          "function_before_end_line": 139,
          "function_after_start_line": 44,
          "function_after_end_line": 150,
          "function_before_token_count": 378,
          "function_after_token_count": 382,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "__iter__",
            "update",
            "__init__"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "__iter__",
            "update",
            "__init__"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 224,
          "file_complexity": 49,
          "file_token_count": 1217,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n        num /= 1000.0\n    return '{0:.1f}Y{1}'.format(num, suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', \\\n     unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then we switch to the mode without showing\n    # the total prediction (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit: unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total: total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        \n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0) # spacing\n        else:\n            full_bar = bar + \\\n            ' ' * max(N_BARS - bar_length, 0) # spacing\n\n        return l_bar + full_bar + r_bar\n\n    else: # no progressbar nor ETA, just progress statistics (number of iterations spent, time spent)\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n         ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now the object was created and processed, so we can print the meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable: return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nfrom __future__ import division, absolute_import\n# import compatibility functions and utilities\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n        num /= 1000.0\n    return '{0:.1f}Y{1}'.format(num, suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='',\n                          unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then\n    # we switch to the mode without showing the total prediction\n    # (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format( \\\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, \\\n                rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                             else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                                else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)  # spacing\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)  # spacing\n\n        return l_bar + full_bar + r_bar\n\n    else: # no progressbar nor ETA, just progress statistics\n        return '{0}{1} [{2}, {3} {4}/s]'.format( \\\n            n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating\n    may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n                      file=sys.stderr, ncols=None, mininterval=0.1, miniters=None,\n                      unit=None, unit_scale=False, ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable:\n            self.sp.print_status(format_meter(\n                0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        # if the bar is disabled, then just walk the iterable\n        # (note that we keep this condition above the loop for performance,\n        # so that we don't have to repeatedly check the condition inside\n        # the loop)\n        if self.disable:\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now that the iterable object was created and processed,\n                # we can print the progress meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n        use update(len(current_buffer)).\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable:\n            return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters:\n                    self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update\n        based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(\n                    self.n, self.total, cur_t-self.start_t, self.ncols,\n                    self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -7,7 +7,10 @@ Usage:\n   for i in trange(10):\n     ...\n \"\"\"\n-from __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\n+# future division is important to divide integers and get as\n+# a result precise floating numbers (instead of truncated int)\n+from __future__ import division, absolute_import\n+# import compatibility functions and utilities\n from ._utils import _supports_unicode, _environ_cols, _range, _unich\n import sys\n import time\n@@ -17,6 +20,7 @@ __author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                               \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n __all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n \n+\n def format_sizeof(num, suffix='bytes'):\n     \"\"\"\n     Readable size format, courtesy of Sridhar Ratnakumar\n@@ -37,8 +41,8 @@ def format_interval(t):\n         return '{0:02d}:{1:02d}'.format(m, s)\n \n \n-def format_meter(n, total, elapsed, ncols=None, prefix='', \\\n-     unit=None, unit_scale=False, ascii=False):\n+def format_meter(n, total, elapsed, ncols=None, prefix='',\n+                          unit=None, unit_scale=False, ascii=False):\n     \"\"\"\n     Return a string-based progress bar given some parameters\n \n@@ -74,8 +78,9 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', \\\n     out  : Formatted meter and stats, ready to display.\n     \"\"\"\n \n-    # in case the total is wrong (n is above the total), then we switch to the mode without showing\n-    # the total prediction (since ETA would be wrong anyway)\n+    # in case the total is wrong (n is above the total), then\n+    # we switch to the mode without showing the total prediction\n+    # (since ETA would be wrong anyway)\n     if total and n > total:\n         total = None\n \n@@ -89,35 +94,40 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', \\\n         rate = '?'\n \n     rate_unit = unit if unit else 'it'\n-    if not unit: unit = ''\n+    if not unit:\n+        unit = ''\n \n     n_fmt = str(n)\n     total_fmt = str(total)\n     if unit_scale:\n         n_fmt = format_sizeof(n, suffix='')\n-        if total: total_fmt = format_sizeof(total, suffix='')\n+        if total:\n+            total_fmt = format_sizeof(total, suffix='')\n \n     if total:\n         frac = n / total\n         percentage = frac * 100\n-        \n+\n         remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n \n         l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                 '{0:3.0f}%|'.format(percentage)\n-        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n-                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n+        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format( \\\n+                n_fmt, total_fmt, unit, elapsed_str, remaining_str, \\\n+                rate, rate_unit)\n \n         if ncols == 0:\n             bar = ''\n         else:\n-            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n+            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n+                             else 10\n \n             if ascii:\n                 bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n \n                 bar = '#'*bar_length\n-                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n+                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n+                                else ' '\n \n             else:\n                 bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n@@ -128,21 +138,23 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', \\\n \n         if bar_length < N_BARS:\n             full_bar = bar + frac_bar + \\\n-                ' ' * max(N_BARS - bar_length - 1, 0) # spacing\n+                ' ' * max(N_BARS - bar_length - 1, 0)  # spacing\n         else:\n             full_bar = bar + \\\n-            ' ' * max(N_BARS - bar_length, 0) # spacing\n+                ' ' * max(N_BARS - bar_length, 0)  # spacing\n \n         return l_bar + full_bar + r_bar\n \n-    else: # no progressbar nor ETA, just progress statistics (number of iterations spent, time spent)\n-        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n+    else: # no progressbar nor ETA, just progress statistics\n+        return '{0}{1} [{2}, {3} {4}/s]'.format( \\\n+            n_fmt, unit, elapsed_str, rate, rate_unit)\n \n \n class StatusPrinter(object):\n     \"\"\"\n     Manage the printing and in-place updating of a line of characters.\n-    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n+    Note that if the string is longer than a line, then in-place updating\n+    may not work (it will print a new line at each refresh).\n     \"\"\"\n     def __init__(self, file):\n         self.file = file\n@@ -206,9 +218,9 @@ class tqdm(object):\n     out  : decorated iterator.\n     \"\"\"\n \n-    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n-         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n-         ascii=None, disable=False):\n+    def __init__(self, iterable=None, desc=None, total=None, leave=False,\n+                      file=sys.stderr, ncols=None, mininterval=0.1, miniters=None,\n+                      unit=None, unit_scale=False, ascii=None, disable=False):\n \n         # Preprocess the arguments\n         if total is None and iterable is not None:\n@@ -246,7 +258,9 @@ class tqdm(object):\n \n         # Initialize the screen printer\n         self.sp = StatusPrinter(self.file)\n-        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n+        if not disable:\n+            self.sp.print_status(format_meter(\n+                0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n \n         # Init the time/iterations counters\n         self.start_t = self.last_print_t = time.time()\n@@ -255,19 +269,27 @@ class tqdm(object):\n \n     def __iter__(self):\n         ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n-        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n+        # if the bar is disabled, then just walk the iterable\n+        # (note that we keep this condition above the loop for performance,\n+        # so that we don't have to repeatedly check the condition inside\n+        # the loop)\n+        if self.disable:\n             for obj in self.iterable:\n                 yield obj\n         else:\n             for obj in self.iterable:\n                 yield obj\n-                # Now the object was created and processed, so we can print the meter.\n+                # Now that the iterable object was created and processed,\n+                # we can print the progress meter.\n                 self.update(1)\n             self.close()\n \n     def update(self, n=1):\n         \"\"\"\n-        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n+        Manually update the progress bar, useful for streams\n+        such as reading files.\n+        Eg, initialize tqdm(total=filesize), and then in the reading loop,\n+        use update(len(current_buffer)).\n \n         Parameters\n         ----------\n@@ -278,26 +300,33 @@ class tqdm(object):\n             n = 1\n         self.n += n\n \n-        if self.disable: return\n+        if self.disable:\n+            return\n \n         delta_it = self.n - self.last_print_n\n         if delta_it >= self.miniters:\n             # We check the counter first, to reduce the overhead of time.time()\n             cur_t = time.time()\n             if cur_t - self.last_print_t >= self.mininterval:\n-                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n-                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n+                self.sp.print_status(format_meter(\n+                    self.n, self.total, cur_t-self.start_t, self.ncols,\n+                    self.prefix, self.unit, self.unit_scale, self.ascii))\n+                if self.dynamic_miniters:\n+                    self.miniters = max(self.miniters, delta_it)\n                 self.last_print_n = self.n\n                 self.last_print_t = cur_t\n \n     def close(self):\n         \"\"\"\n-        Call this method to force print the last progress bar update based on the latest n value\n+        Call this method to force print the last progress bar update\n+        based on the latest n value\n         \"\"\"\n         if self.leave:\n             if self.last_print_n < self.n:\n                 cur_t = time.time()\n-                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n+                self.sp.print_status(format_meter(\n+                    self.n, self.total, cur_t-self.start_t, self.ncols,\n+                    self.prefix, self.unit, self.unit_scale, self.ascii))\n             self.file.write('\\n')\n         else:\n             self.sp.print_status('')\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "1f671ecf43eedc06b10f9e222085714b3bead29f": {
        "commit": {
          "commit_id": "1f671ecf43eedc06b10f9e222085714b3bead29f",
          "commit_message": "fix regressions + string formatting\n\nSigned-off-by: Stephen L. <lrq3000@gmail.com>",
          "commit_author": "Stephen L",
          "commit_date": "2015-07-13 14:53:08",
          "commit_parent": "26317f3c2f67148dfa4a9eee3650e14635be2d61"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + '-' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + '-' * max(N_BARS - bar_length, 0)\n        return '%s%s%s' % (l_bar, full_bar, r_bar)\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_before_start_line": 40,
          "function_before_end_line": 139,
          "function_after_start_line": 40,
          "function_after_end_line": 139,
          "function_before_token_count": 382,
          "function_after_token_count": 378,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "format_sizeof",
            "print_status"
          ],
          "functions_name_co_evolved_all_files": [
            "format_sizeof",
            "print_status"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 209,
          "file_complexity": 49,
          "file_token_count": 1213,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return \"%3.1f%s%s\" % (num, unit, suffix)\n        num /= 1000.0\n    return \"%.1f%s%s\" % (num, 'Y', suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', \\\n     unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then we switch to the mode without showing\n    # the total prediction (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit: unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total: total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        \n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                '-' * max(N_BARS - bar_length - 1, 0) # spacing\n        else:\n            full_bar = bar + \\\n            '-' * max(N_BARS - bar_length, 0) # spacing\n\n        return \"%s%s%s\" % (l_bar,  full_bar, r_bar)\n\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len-len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n         ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now the object was created and processed, so we can print the meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable: return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n        num /= 1000.0\n    return '{0:.1f}Y{1}'.format(num, suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', \\\n     unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then we switch to the mode without showing\n    # the total prediction (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit: unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total: total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        \n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0) # spacing\n        else:\n            full_bar = bar + \\\n            ' ' * max(N_BARS - bar_length, 0) # spacing\n\n        return l_bar + full_bar + r_bar\n\n    else: # no progressbar nor ETA, just progress statistics (number of iterations spent, time spent)\n        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n         ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now the object was created and processed, so we can print the meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable: return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -23,9 +23,9 @@ def format_sizeof(num, suffix='bytes'):\n     \"\"\"\n     for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n         if abs(num) < 1000.0:\n-            return \"%3.1f%s%s\" % (num, unit, suffix)\n+            return '{0:3.1f}{1}{2}'.format(num, unit, suffix)\n         num /= 1000.0\n-    return \"%.1f%s%s\" % (num, 'Y', suffix)\n+    return '{0:.1f}Y{1}'.format(num, suffix)\n \n \n def format_interval(t):\n@@ -117,7 +117,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', \\\n                 bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n \n                 bar = '#'*bar_length\n-                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n+                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n \n             else:\n                 bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n@@ -128,15 +128,15 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', \\\n \n         if bar_length < N_BARS:\n             full_bar = bar + frac_bar + \\\n-                '-' * max(N_BARS - bar_length - 1, 0) # spacing\n+                ' ' * max(N_BARS - bar_length - 1, 0) # spacing\n         else:\n             full_bar = bar + \\\n-            '-' * max(N_BARS - bar_length, 0) # spacing\n+            ' ' * max(N_BARS - bar_length, 0) # spacing\n \n-        return \"%s%s%s\" % (l_bar,  full_bar, r_bar)\n+        return l_bar + full_bar + r_bar\n \n-    else:\n-        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n+    else: # no progressbar nor ETA, just progress statistics (number of iterations spent, time spent)\n+        return '{0}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n \n \n class StatusPrinter(object):\n@@ -150,7 +150,7 @@ class StatusPrinter(object):\n \n     def print_status(self, s):\n         len_s = len(s)\n-        self.file.write('\\r'+s+' '*max(self.last_printed_len-len_s, 0))\n+        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n         self.file.flush()\n         self.last_printed_len = len_s\n \n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "05dc6d5011affe35c35997e2290aef90053ef023": {
        "commit": {
          "commit_id": "05dc6d5011affe35c35997e2290aef90053ef023",
          "commit_message": "Flake fix\n\nSigned-off-by: Stephen L. <lrq3000@gmail.com>",
          "commit_author": "Stephen L",
          "commit_date": "2015-07-12 06:44:04",
          "commit_parent": "1305eacbeebe310641a79d63a93272c54b801c51"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled automatically\n        and a metric prefix following the International System of Units standard\n        will be added (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + '-' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + '-' * max(N_BARS - bar_length, 0)\n        return '%s%s%s' % (l_bar, full_bar, r_bar)\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + '-' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + '-' * max(N_BARS - bar_length, 0)\n        return '%s%s%s' % (l_bar, full_bar, r_bar)\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_before_start_line": 39,
          "function_before_end_line": 133,
          "function_after_start_line": 40,
          "function_after_end_line": 139,
          "function_before_token_count": 381,
          "function_after_token_count": 382,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "format_sizeof"
          ],
          "functions_name_co_evolved_all_files": [
            "format_sizeof"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 208,
          "file_complexity": 49,
          "file_token_count": 1217,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['','K','M','G','T','P','E','Z']:\n        if abs(num) < 1000.0:\n            return \"%3.1f%s%s\" % (num, unit, suffix)\n        num /= 1000.0\n    return \"%.1f%s%s\" % (num, 'Y', suffix)\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled automatically\n        and a metric prefix following the International System of Units standard\n        will be added (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total: # in case the total is wrong (n is above the total), then we switch to the mode without showing the total prediction (since ETA would be wrong anyway)\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit: unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total: total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        \n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                '-' * max(N_BARS - bar_length - 1, 0) # spacing\n        else:\n            full_bar = bar + \\\n            '-' * max(N_BARS - bar_length, 0) # spacing\n\n        return \"%s%s%s\" % (l_bar,  full_bar, r_bar)\n\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n        self.file.flush()\n        self.last_printed_len = len(s)\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled automatically\n        and a metric prefix following the International System of Units standard\n        will be added (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n         ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now the object was created and processed, so we can print the meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable: return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 1000.0:\n            return \"%3.1f%s%s\" % (num, unit, suffix)\n        num /= 1000.0\n    return \"%.1f%s%s\" % (num, 'Y', suffix)\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', \\\n     unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # in case the total is wrong (n is above the total), then we switch to the mode without showing\n    # the total prediction (since ETA would be wrong anyway)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit: unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total: total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        \n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                '-' * max(N_BARS - bar_length - 1, 0) # spacing\n        else:\n            full_bar = bar + \\\n            '-' * max(N_BARS - bar_length, 0) # spacing\n\n        return \"%s%s%s\" % (l_bar,  full_bar, r_bar)\n\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n        self.file.flush()\n        self.last_printed_len = len(s)\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : bool, optional\n        If set, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.). [default: False]\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n         ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now the object was created and processed, so we can print the meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable: return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -21,12 +21,13 @@ def format_sizeof(num, suffix='bytes'):\n     \"\"\"\n     Readable size format, courtesy of Sridhar Ratnakumar\n     \"\"\"\n-    for unit in ['','K','M','G','T','P','E','Z']:\n+    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n         if abs(num) < 1000.0:\n             return \"%3.1f%s%s\" % (num, unit, suffix)\n         num /= 1000.0\n     return \"%.1f%s%s\" % (num, 'Y', suffix)\n \n+\n def format_interval(t):\n     mins, s = divmod(int(t), 60)\n     h, m = divmod(mins, 60)\n@@ -36,7 +37,8 @@ def format_interval(t):\n         return '{0:02d}:{1:02d}'.format(m, s)\n \n \n-def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n+def format_meter(n, total, elapsed, ncols=None, prefix='', \\\n+     unit=None, unit_scale=False, ascii=False):\n     \"\"\"\n     Return a string-based progress bar given some parameters\n \n@@ -59,9 +61,10 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale\n         String that will be used to define the unit of each iteration.\n         [default: \"it\"]\n     unit_scale  : bool, optional\n-        If set, the number of iterations will be reduced/scaled automatically\n-        and a metric prefix following the International System of Units standard\n-        will be added (kilo, mega, etc.). [default: False]\n+        If set, the number of iterations will be reduced/scaled\n+        automatically and a metric prefix following the\n+        International System of Units standard will be added\n+        (kilo, mega, etc.). [default: False]\n     ascii  : bool, optional\n         If not set, use unicode (smooth blocks) to fill the meter\n         [default: False]. The fallback is to use ASCII characters (1-9 #).\n@@ -70,7 +73,10 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale\n     -------\n     out  : Formatted meter and stats, ready to display.\n     \"\"\"\n-    if total and n > total: # in case the total is wrong (n is above the total), then we switch to the mode without showing the total prediction (since ETA would be wrong anyway)\n+\n+    # in case the total is wrong (n is above the total), then we switch to the mode without showing\n+    # the total prediction (since ETA would be wrong anyway)\n+    if total and n > total:\n         total = None\n \n     elapsed_str = format_interval(elapsed)\n@@ -184,9 +190,10 @@ class tqdm(object):\n         String that will be used to define the unit of each iteration.\n         [default: \"it\"]\n     unit_scale  : bool, optional\n-        If set, the number of iterations will be reduced/scaled automatically\n-        and a metric prefix following the International System of Units standard\n-        will be added (kilo, mega, etc.). [default: False]\n+        If set, the number of iterations will be reduced/scaled\n+        automatically and a metric prefix following the\n+        International System of Units standard will be added\n+        (kilo, mega, etc.). [default: False]\n     ascii  : bool, optional\n         If not set, use unicode (smooth blocks) to fill the meter\n         [default: False]. The fallback is to use ASCII characters (1-9 #).\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "cb668bea0f29bde2980bb709f1236e97847df54b": {
        "commit": {
          "commit_id": "cb668bea0f29bde2980bb709f1236e97847df54b",
          "commit_message": "Add unit and unit_scale arguments + tqdm is now a class to allow manual update() and close()\n\nSigned-off-by: Stephen L. <lrq3000@gmail.com>",
          "commit_author": "Stephen L",
          "commit_date": "2015-07-12 06:20:23",
          "commit_parent": "39e814b2d692479b677aef46618d2881fb8cb791"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : str, optional\n        If set, the number of iterations will be reduced/scaled automatically\n        and a metric prefix following the International System of Units standard\n        will be added (kilo, mega, etc.).\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n    rate_unit = unit if unit else 'it'\n    if not unit:\n        unit = ''\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total:\n            total_fmt = format_sizeof(total, suffix='')\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n            if ascii:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n            else:\n                (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n                bar = _unich(9608) * bar_length\n                frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + '-' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + '-' * max(N_BARS - bar_length, 0)\n        return '%s%s%s' % (l_bar, full_bar, r_bar)\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)",
          "function_before_start_line": 30,
          "function_before_end_line": 95,
          "function_after_start_line": 39,
          "function_after_end_line": 133,
          "function_before_token_count": 268,
          "function_after_token_count": 381,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "update",
            "close",
            "trange",
            "__iter__",
            "format_sizeof",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "close",
            "__init__",
            "print_status",
            "update",
            "tqdm",
            "__iter__",
            "format_sizeof"
          ],
          "functions_name_co_evolved_all_files": [
            "close",
            "__init__",
            "print_status",
            "update",
            "tqdm",
            "__iter__",
            "format_sizeof"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 206,
          "file_complexity": 49,
          "file_token_count": 1216,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None,\n         ascii=None, disable=False):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    if disable:\n        for obj in iterable:\n            yield obj\n        return\n\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n\n    if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n        ncols = _environ_cols(file)\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix, ascii))\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n)\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix, ascii))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\ndef format_sizeof(num, suffix='bytes'):\n    \"\"\"\n    Readable size format, courtesy of Sridhar Ratnakumar\n    \"\"\"\n    for unit in ['','K','M','G','T','P','E','Z']:\n        if abs(num) < 1000.0:\n            return \"%3.1f%s%s\" % (num, unit, suffix)\n        num /= 1000.0\n    return \"%.1f%s%s\" % (num, 'Y', suffix)\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If None, only basic progress\n        statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width).\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : str, optional\n        If set, the number of iterations will be reduced/scaled automatically\n        and a metric prefix following the International System of Units standard\n        will be added (kilo, mega, etc.).\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total: # in case the total is wrong (n is above the total), then we switch to the mode without showing the total prediction (since ETA would be wrong anyway)\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    if elapsed:\n        if unit_scale:\n            rate = format_sizeof(n / elapsed, suffix='')\n        else:\n            rate = '{0:5.2f}'.format(n / elapsed)\n    else:\n        rate = '?'\n\n    rate_unit = unit if unit else 'it'\n    if not unit: unit = ''\n\n    n_fmt = str(n)\n    total_fmt = str(total)\n    if unit_scale:\n        n_fmt = format_sizeof(n, suffix='')\n        if total: total_fmt = format_sizeof(total, suffix='')\n\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        \n        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n\n        if ncols == 0:\n            bar = ''\n        else:\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n            if ascii:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n                bar = '#'*bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588)*bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                '-' * max(N_BARS - bar_length - 1, 0) # spacing\n        else:\n            full_bar = bar + \\\n            '-' * max(N_BARS - bar_length, 0) # spacing\n\n        return \"%s%s%s\" % (l_bar,  full_bar, r_bar)\n\n    else:\n        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n\n\nclass StatusPrinter(object):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n        self.file.flush()\n        self.last_printed_len = len(s)\n\n\nclass tqdm(object):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar. You can leave\n        it to None if you want to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed (no ETA, no progressbar).\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically\n        resizes the progress meter to stay within this bound [default: None].\n        The fallback meter width is 10 for the progress bar + no limit for\n        the iterations counter and statistics.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    unit  : str, optional\n        String that will be used to define the unit of each iteration.\n        [default: \"it\"]\n    unit_scale  : str, optional\n        If set, the number of iterations will be reduced/scaled automatically\n        and a metric prefix following the International System of Units standard\n        will be added (kilo, mega, etc.).\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n         ascii=None, disable=False):\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n            ncols = _environ_cols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        # Store the arguments\n        self.iterable = iterable\n        self.total = total\n        self.prefix = desc+': ' if desc else ''\n        self.leave = leave\n        self.file = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.ascii = ascii\n        self.disable = disable\n\n        # Initialize the screen printer\n        self.sp = StatusPrinter(self.file)\n        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n\n        # Init the time/iterations counters\n        self.start_t = self.last_print_t = time.time()\n        self.last_print_n = 0\n        self.n = 0\n\n    def __iter__(self):\n        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n            for obj in self.iterable:\n                yield obj\n        else:\n            for obj in self.iterable:\n                yield obj\n                # Now the object was created and processed, so we can print the meter.\n                self.update(1)\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations.\n        \"\"\"\n        if n < 1:\n            n = 1\n        self.n += n\n\n        if self.disable: return\n\n        delta_it = self.n - self.last_print_n\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - self.last_print_t >= self.mininterval:\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n\n    def close(self):\n        \"\"\"\n        Call this method to force print the last progress bar update based on the latest n value\n        \"\"\"\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = time.time()\n                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n            self.file.write('\\n')\n        else:\n            self.sp.print_status('')\n            self.file.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -7,7 +7,7 @@ Usage:\n   for i in trange(10):\n     ...\n \"\"\"\n-from __future__ import division, absolute_import\n+from __future__ import division, absolute_import # future division is important to divide integers and get as a result precise floating numbers (instead of truncated int)\n from ._utils import _supports_unicode, _environ_cols, _range, _unich\n import sys\n import time\n@@ -17,6 +17,15 @@ __author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                               \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n __all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n \n+def format_sizeof(num, suffix='bytes'):\n+    \"\"\"\n+    Readable size format, courtesy of Sridhar Ratnakumar\n+    \"\"\"\n+    for unit in ['','K','M','G','T','P','E','Z']:\n+        if abs(num) < 1000.0:\n+            return \"%3.1f%s%s\" % (num, unit, suffix)\n+        num /= 1000.0\n+    return \"%.1f%s%s\" % (num, 'Y', suffix)\n \n def format_interval(t):\n     mins, s = divmod(int(t), 60)\n@@ -27,25 +36,32 @@ def format_interval(t):\n         return '{0:02d}:{1:02d}'.format(m, s)\n \n \n-def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n+def format_meter(n, total, elapsed, ncols=None, prefix='', unit=None, unit_scale=False, ascii=False):\n     \"\"\"\n-    Parameter parsing and formatting for output\n+    Return a string-based progress bar given some parameters\n \n     Parameters\n     ----------\n     n  : int\n-        Number of finished iterations\n+        Number of finished iterations.\n     total  : int\n-        The number of expected iterations. If None, only basic progress\n-        statistics are displayed.\n+        The expected total number of iterations. If None, only basic progress\n+        statistics are displayed (no ETA).\n     elapsed  : float\n-        Number of seconds passed since start\n+        Number of seconds passed since start.\n     ncols  : int, optional\n         The width of the entire output message. If sepcified, dynamically\n         resizes the progress meter [default: None]. The fallback meter\n         width is 10.\n     prefix  : str, optional\n-        Prefix message (included in total width)\n+        Prefix message (included in total width).\n+    unit  : str, optional\n+        String that will be used to define the unit of each iteration.\n+        [default: \"it\"]\n+    unit_scale  : str, optional\n+        If set, the number of iterations will be reduced/scaled automatically\n+        and a metric prefix following the International System of Units standard\n+        will be added (kilo, mega, etc.).\n     ascii  : bool, optional\n         If not set, use unicode (smooth blocks) to fill the meter\n         [default: False]. The fallback is to use ASCII characters (1-9 #).\n@@ -54,77 +70,101 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n     -------\n     out  : Formatted meter and stats, ready to display.\n     \"\"\"\n-    if total and n > total:\n+    if total and n > total: # in case the total is wrong (n is above the total), then we switch to the mode without showing the total prediction (since ETA would be wrong anyway)\n         total = None\n \n     elapsed_str = format_interval(elapsed)\n-    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n-\n-    if total:\n-        frac = float(n) / total\n+    if elapsed:\n+        if unit_scale:\n+            rate = format_sizeof(n / elapsed, suffix='')\n+        else:\n+            rate = '{0:5.2f}'.format(n / elapsed)\n+    else:\n+        rate = '?'\n \n-        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n+    rate_unit = unit if unit else 'it'\n+    if not unit: unit = ''\n \n-        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n-                '{0:3.0f}%|'.format(frac * 100)\n-        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n-                n, total, elapsed_str, left_str, rate)\n+    n_fmt = str(n)\n+    total_fmt = str(total)\n+    if unit_scale:\n+        n_fmt = format_sizeof(n, suffix='')\n+        if total: total_fmt = format_sizeof(total, suffix='')\n \n-        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n+    if total:\n+        frac = n / total\n+        percentage = frac * 100\n+        \n+        remaining_str = format_interval(elapsed * (total-n) / n) if n else '?'\n+\n+        l_bar = '{1}{0:.0f}%|'.format(percentage, prefix) if prefix else \\\n+                '{0:3.0f}%|'.format(percentage)\n+        r_bar = '| {0}/{1}{2} [{3}<{4}, {5} {6}/s]'.format(\n+                n_fmt, total_fmt, unit, elapsed_str, remaining_str, rate, rate_unit)\n+\n+        if ncols == 0:\n+            bar = ''\n+        else:\n+            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n \n-        if ascii:\n-            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n+            if ascii:\n+                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n \n-            bar = '#'*bar_length\n-            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n+                bar = '#'*bar_length\n+                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else '0'\n \n-        else:\n-            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n+            else:\n+                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n \n-            bar = _unich(0x2588)*bar_length\n-            frac_bar = _unich(0x2590 - frac_bar_length) \\\n-                if frac_bar_length else ' '\n+                bar = _unich(0x2588)*bar_length\n+                frac_bar = _unich(0x2590 - frac_bar_length) \\\n+                    if frac_bar_length else ' '\n \n         if bar_length < N_BARS:\n-            return l_bar + bar + frac_bar + \\\n-                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n+            full_bar = bar + frac_bar + \\\n+                '-' * max(N_BARS - bar_length - 1, 0) # spacing\n         else:\n-            return l_bar + bar + r_bar\n+            full_bar = bar + \\\n+            '-' * max(N_BARS - bar_length, 0) # spacing\n+\n+        return \"%s%s%s\" % (l_bar,  full_bar, r_bar)\n \n     else:\n-        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n+        return '{0:d}{1} [{2}, {3} {4}/s]'.format(n_fmt, unit, elapsed_str, rate, rate_unit)\n \n \n class StatusPrinter(object):\n+    \"\"\"\n+    Manage the printing and in-place updating of a line of characters.\n+    Note that if the string is longer than a line, then in-place updating may not work (it will print a new line at each refresh).\n+    \"\"\"\n     def __init__(self, file):\n         self.file = file\n         self.last_printed_len = 0\n \n     def print_status(self, s):\n-        len_s = len(s)\n-        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n+        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n         self.file.flush()\n-        self.last_printed_len = len_s\n+        self.last_printed_len = len(s)\n \n \n-def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n-         ncols=None, mininterval=0.1, miniters=None,\n-         ascii=None, disable=False):\n+class tqdm(object):\n     \"\"\"\n     Decorate an iterable object, returning an iterator which acts exactly\n     like the orignal iterable, but prints a dynamically updating\n-    progressbar.\n+    progressbar every time a value is requested.\n \n     Parameters\n     ----------\n-    iterable  : iterable\n-        Iterable to decorate with a progressbar.\n+    iterable  : iterable, optional\n+        Iterable to decorate with a progressbar. You can leave\n+        it to None if you want to manually manage the updates.\n     desc  : str, optional\n         Prefix for the progressbar.\n     total  : int, optional\n         The number of expected iterations. If not given, len(iterable) is\n         used if possible. As a last resort, only basic progress statistics\n-        are displayed.\n+        are displayed (no ETA, no progressbar).\n     file  : `io.TextIOWrapper` or `io.StringIO`, optional\n         Specifies where to output the progress messages.\n         Uses file.write(str) and file.flush() methods.\n@@ -132,13 +172,21 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         if unset, removes all traces of the progressbar upon termination of\n         iteration [default: False].\n     ncols  : int, optional\n-        The width of the entire output message. If sepcified, dynamically\n-        resizes the progress meter [default: None]. The fallback meter\n-        width is 10.\n+        The width of the entire output message. If specified, dynamically\n+        resizes the progress meter to stay within this bound [default: None].\n+        The fallback meter width is 10 for the progress bar + no limit for\n+        the iterations counter and statistics.\n     mininterval  : float, optional\n         Minimum progress update interval, in seconds [default: 0.1].\n     miniters  : int, optional\n         Minimum progress update interval, in iterations [default: None].\n+    unit  : str, optional\n+        String that will be used to define the unit of each iteration.\n+        [default: \"it\"]\n+    unit_scale  : str, optional\n+        If set, the number of iterations will be reduced/scaled automatically\n+        and a metric prefix following the International System of Units standard\n+        will be added (kilo, mega, etc.).\n     ascii  : bool, optional\n         If not set, use unicode (smooth blocks) to fill the meter\n         [default: False]. The fallback is to use ASCII characters (1-9 #).\n@@ -150,61 +198,102 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n     out  : decorated iterator.\n     \"\"\"\n \n-    if disable:\n-        for obj in iterable:\n-            yield obj\n-        return\n-\n-    if total is None:\n-        try:\n-            total = len(iterable)\n-        except (TypeError, AttributeError):\n-            total = None\n-\n-    if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n-        ncols = _environ_cols(file)\n+    def __init__(self, iterable=None, desc=None, total=None, leave=False, file=sys.stderr,\n+         ncols=None, mininterval=0.1, miniters=None, unit=None, unit_scale=False,\n+         ascii=None, disable=False):\n \n-    if miniters is None:\n-        miniters = 0\n-        dynamic_miniters = True\n-    else:\n-        dynamic_miniters = False\n+        # Preprocess the arguments\n+        if total is None and iterable is not None:\n+            try:\n+                total = len(iterable)\n+            except (TypeError, AttributeError):\n+                total = None\n \n-    if ascii is None:\n-        ascii = not _supports_unicode(file)\n+        if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n+            ncols = _environ_cols(file)\n \n-    prefix = desc+': ' if desc else ''\n+        if miniters is None:\n+            miniters = 0\n+            dynamic_miniters = True\n+        else:\n+            dynamic_miniters = False\n \n-    sp = StatusPrinter(file)\n-    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n+        if ascii is None:\n+            ascii = not _supports_unicode(file)\n \n-    start_t = last_print_t = time.time()\n-    last_print_n = 0\n-    n = 0\n-    for obj in iterable:\n-        yield obj\n-        # Now the object was created and processed, so we can print the meter.\n-        n += 1\n-        if n - last_print_n >= miniters:\n+        # Store the arguments\n+        self.iterable = iterable\n+        self.total = total\n+        self.prefix = desc+': ' if desc else ''\n+        self.leave = leave\n+        self.file = file\n+        self.ncols = ncols\n+        self.mininterval = mininterval\n+        self.miniters = miniters\n+        self.dynamic_miniters = dynamic_miniters\n+        self.unit = unit\n+        self.unit_scale = unit_scale\n+        self.ascii = ascii\n+        self.disable = disable\n+\n+        # Initialize the screen printer\n+        self.sp = StatusPrinter(self.file)\n+        if not disable: self.sp.print_status(format_meter(0, total, 0, ncols, self.prefix, unit, unit_scale, ascii))\n+\n+        # Init the time/iterations counters\n+        self.start_t = self.last_print_t = time.time()\n+        self.last_print_n = 0\n+        self.n = 0\n+\n+    def __iter__(self):\n+        ''' For backward-compatibility to use: for x in tqdm(iterable) '''\n+        if self.disable: # if the bar is disabled, then just walk the iterable (note that we keep this condition above the loop for performance, so that we don't have to repeatedly check the condition inside the loop)\n+            for obj in self.iterable:\n+                yield obj\n+        else:\n+            for obj in self.iterable:\n+                yield obj\n+                # Now the object was created and processed, so we can print the meter.\n+                self.update(1)\n+            self.close()\n+\n+    def update(self, n=1):\n+        \"\"\"\n+        Manually update the progress bar, useful for streams such as reading files (set init(total=filesize) and then in the reading loop, use update(len(current_buffer)) )\n+\n+        Parameters\n+        ----------\n+        n  : int\n+            Increment to add to the internal counter of iterations.\n+        \"\"\"\n+        if n < 1:\n+            n = 1\n+        self.n += n\n+\n+        if self.disable: return\n+\n+        delta_it = self.n - self.last_print_n\n+        if delta_it >= self.miniters:\n             # We check the counter first, to reduce the overhead of time.time()\n             cur_t = time.time()\n-            if cur_t - last_print_t >= mininterval:\n-                sp.print_status(format_meter(\n-                    n, total, cur_t-start_t, ncols, prefix, ascii))\n-                if dynamic_miniters:\n-                    miniters = max(miniters, n - last_print_n)\n-                last_print_n = n\n-                last_print_t = cur_t\n-\n-    if leave:\n-        if last_print_n < n:\n-            cur_t = time.time()\n-            sp.print_status(format_meter(\n-                n, total, cur_t-start_t, ncols, prefix, ascii))\n-        file.write('\\n')\n-    else:\n-        sp.print_status('')\n-        file.write('\\r')\n+            if cur_t - self.last_print_t >= self.mininterval:\n+                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n+                if self.dynamic_miniters: self.miniters = max(self.miniters, delta_it)\n+                self.last_print_n = self.n\n+                self.last_print_t = cur_t\n+\n+    def close(self):\n+        \"\"\"\n+        Call this method to force print the last progress bar update based on the latest n value\n+        \"\"\"\n+        if self.leave:\n+            if self.last_print_n < self.n:\n+                cur_t = time.time()\n+                self.sp.print_status(format_meter(self.n, self.total, cur_t-self.start_t, self.ncols, self.prefix, self.unit, self.unit_scale, self.ascii))\n+            self.file.write('\\n')\n+        else:\n+            self.sp.print_status('')\n+            self.file.write('\\r')\n \n \n def trange(*args, **kwargs):\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "c58a7c3f216c0a681f6abc0ce95b0eb97c77b08f": {
        "commit": {
          "commit_id": "c58a7c3f216c0a681f6abc0ce95b0eb97c77b08f",
          "commit_message": "moved more to utils",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-06-25 16:56:34",
          "commit_parent": "21912c821ccb984f79c911f7cb89698a111662ab"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            try:\n                unich = unichr\n            except NameError:\n                unich = chr\n            bar = unich(9608) * bar_length\n            frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_before_start_line": 30,
          "function_before_end_line": 100,
          "function_after_start_line": 30,
          "function_after_end_line": 95,
          "function_before_token_count": 279,
          "function_after_token_count": 268,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "trange",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "trange",
            "_environ_cols",
            "_is_utf",
            "_supports_unicode",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "trange"
          ],
          "functions_name_co_evolved_all_files": [
            "trange",
            "_environ_cols"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 111,
          "file_complexity": 33,
          "file_token_count": 790,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nfrom ._utils import _supports_unicode, _environ_cols\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            try:    # pragma: no cover\n                unich = unichr\n            except NameError:    # pragma: no cover\n                unich = chr\n\n            bar = unich(0x2588)*bar_length\n            frac_bar = unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None,\n         ascii=None, disable=False):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    if disable:\n        for obj in iterable:\n            yield obj\n        return\n\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n\n    if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n        ncols = _environ_cols()\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix, ascii))\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n + 1)\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix, ascii))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:    # pragma: no cover\n        f = xrange\n    except NameError:    # pragma: no cover\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nfrom ._utils import _supports_unicode, _environ_cols, _range, _unich\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588)*bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None,\n         ascii=None, disable=False):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n    disable : bool\n        Disable the progress bar if True [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    if disable:\n        for obj in iterable:\n            yield obj\n        return\n\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n\n    if (ncols is None) and (file in (sys.stderr, sys.stdout)):\n        ncols = _environ_cols()\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix, ascii))\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n + 1)\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix, ascii))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)\n",
          "file_patch": "@@ -8,7 +8,7 @@ Usage:\n     ...\n \"\"\"\n from __future__ import division, absolute_import\n-from ._utils import _supports_unicode, _environ_cols\n+from ._utils import _supports_unicode, _environ_cols, _range, _unich\n import sys\n import time\n \n@@ -81,13 +81,8 @@ def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n         else:\n             bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n \n-            try:    # pragma: no cover\n-                unich = unichr\n-            except NameError:    # pragma: no cover\n-                unich = chr\n-\n-            bar = unich(0x2588)*bar_length\n-            frac_bar = unich(0x2590 - frac_bar_length) \\\n+            bar = _unich(0x2588)*bar_length\n+            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                 if frac_bar_length else ' '\n \n         if bar_length < N_BARS:\n@@ -217,9 +212,4 @@ def trange(*args, **kwargs):\n     A shortcut for tqdm(xrange(*args), **kwargs).\n     On Python3+ range is used instead of xrange.\n     \"\"\"\n-    try:    # pragma: no cover\n-        f = xrange\n-    except NameError:    # pragma: no cover\n-        f = range\n-\n-    return tqdm(f(*args), **kwargs)\n+    return tqdm(_range(*args), **kwargs)\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "_utils.py"
          ]
        }
      },
      "cdfc5e8bca71e3866937c196ca4850b0457d53e3": {
        "commit": {
          "commit_id": "cdfc5e8bca71e3866937c196ca4850b0457d53e3",
          "commit_message": "added docstring for format_meter",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-06-18 22:46:06",
          "commit_parent": "7b97027f0878cd114899f8b3390e72b7c95cc894"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            try:\n                unich = unichr\n            except NameError:\n                unich = chr\n            bar = unich(9608) * bar_length\n            frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n    \n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            try:\n                unich = unichr\n            except NameError:\n                unich = chr\n            bar = unich(9608) * bar_length\n            frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_before_start_line": 29,
          "function_before_end_line": 80,
          "function_after_start_line": 29,
          "function_after_end_line": 99,
          "function_before_token_count": 278,
          "function_after_token_count": 279,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "trange",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "trange",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 121,
          "file_complexity": 35,
          "file_token_count": 802,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    # n - number of finished iterations\n    # total - total number of iterations, or None\n    # elapsed - number of seconds passed since start\n    # ncols - the output width in chars. If specified, dynamically resizes bar.\n    #     [default bar width: 10].\n    # prefix - prepend message (included in total width)\n    # ascii - whether to use ascii (otherwise unicode) character set\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            try:\n                unich = unichr\n            except NameError:\n                unich = chr\n\n            bar = unich(0x2588)*bar_length\n            frac_bar = unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, ascii=None):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n        # not good for slow iterators\n        # elif not miniters:\n        #     miniters = int(total/100)\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if ascii is None:\n        try:\n            file.encoding\n        except AttributeError:\n            ascii = True\n        else:\n            if file.encoding:\n                ascii = not ('U8' == file.encoding or\n                             ('utf' in file.encoding) or\n                             ('UTF' in file.encoding))\n            else:\n                ascii = True\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix, ascii))\n\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n + 1)\n\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix, ascii))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    \"\"\"\n    Parameter parsing and formatting for output\n    \n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations\n    total  : int\n        The number of expected iterations. If None, only basic progress\n        statistics are displayed.\n    elapsed  : float\n        Number of seconds passed since start\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    prefix  : str, optional\n        Prefix message (included in total width)\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            try:\n                unich = unichr\n            except NameError:\n                unich = chr\n\n            bar = unich(0x2588)*bar_length\n            frac_bar = unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, ascii=None):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n        # not good for slow iterators\n        # elif not miniters:\n        #     miniters = int(total/100)\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if ascii is None:\n        try:\n            file.encoding\n        except AttributeError:\n            ascii = True\n        else:\n            if file.encoding:\n                ascii = not ('U8' == file.encoding or\n                             ('utf' in file.encoding) or\n                             ('UTF' in file.encoding))\n            else:\n                ascii = True\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix, ascii))\n\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n + 1)\n\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix, ascii))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_patch": "@@ -27,13 +27,32 @@ def format_interval(t):\n \n \n def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n-    # n - number of finished iterations\n-    # total - total number of iterations, or None\n-    # elapsed - number of seconds passed since start\n-    # ncols - the output width in chars. If specified, dynamically resizes bar.\n-    #     [default bar width: 10].\n-    # prefix - prepend message (included in total width)\n-    # ascii - whether to use ascii (otherwise unicode) character set\n+    \"\"\"\n+    Parameter parsing and formatting for output\n+    \n+    Parameters\n+    ----------\n+    n  : int\n+        Number of finished iterations\n+    total  : int\n+        The number of expected iterations. If None, only basic progress\n+        statistics are displayed.\n+    elapsed  : float\n+        Number of seconds passed since start\n+    ncols  : int, optional\n+        The width of the entire output message. If sepcified, dynamically\n+        resizes the progress meter [default: None]. The fallback meter\n+        width is 10.\n+    prefix  : str, optional\n+        Prefix message (included in total width)\n+    ascii  : bool, optional\n+        If not set, use unicode (smooth blocks) to fill the meter\n+        [default: False]. The fallback is to use ASCII characters (1-9 #).\n+\n+    Returns\n+    -------\n+    out  : Formatted meter and stats, ready to display.\n+    \"\"\"\n     if total and n > total:\n         total = None\n \n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "ef61853720c34e5e9fb9ae513ea8338ffbcd16a2": {
        "commit": {
          "commit_id": "ef61853720c34e5e9fb9ae513ea8338ffbcd16a2",
          "commit_message": "added fallback ascii support",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-06-18 22:19:40",
          "commit_parent": "d16381a91146c8d9742f3d7674b812335df7da31"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix=''):\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n        try:\n            unich = unichr\n        except NameError:\n            unich = chr\n        bar = unich(9608) * bar_length\n        frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            try:\n                unich = unichr\n            except NameError:\n                unich = chr\n            bar = unich(9608) * bar_length\n            frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_before_start_line": 29,
          "function_before_end_line": 70,
          "function_after_start_line": 29,
          "function_after_end_line": 80,
          "function_before_token_count": 234,
          "function_after_token_count": 278,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "trange",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "trange",
            "test_iterate_over_csv_rows",
            "test_file_output",
            "test_leave_option",
            "tqdm",
            "test_min_interval",
            "test_format_meter",
            "test_trange",
            "format_interval",
            "format_meter",
            "test_min_iters",
            "test_format_interval",
            "test_nothing_fails"
          ],
          "functions_name_co_evolved_modified_file": [
            "tqdm"
          ],
          "functions_name_co_evolved_all_files": [
            "tqdm",
            "test_format_meter"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 121,
          "file_complexity": 35,
          "file_token_count": 801,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix=''):\n    # n - number of finished iterations\n    # total - total number of iterations, or None\n    # elapsed - number of seconds passed since start\n    # ncols - the output width in chars. If specified, dynamically resizes bar.\n    #     [default bar width: 10].\n    # prefix - prepend message (included in total width)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n        try:\n            unich = unichr\n        except NameError:\n            unich = chr\n\n        bar = unich(0x2588)*bar_length\n        frac_bar = unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n        # not good for slow iterators\n        # elif not miniters:\n        #     miniters = int(total/100)\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix))\n\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n + 1)\n\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n    # n - number of finished iterations\n    # total - total number of iterations, or None\n    # elapsed - number of seconds passed since start\n    # ncols - the output width in chars. If specified, dynamically resizes bar.\n    #     [default bar width: 10].\n    # prefix - prepend message (included in total width)\n    # ascii - whether to use ascii (otherwise unicode) character set\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n\n        if ascii:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n\n            bar = '#'*bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            try:\n                unich = unichr\n            except NameError:\n                unich = chr\n\n            bar = unich(0x2588)*bar_length\n            frac_bar = unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None, ascii=None):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters (1-9 #).\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n        # not good for slow iterators\n        # elif not miniters:\n        #     miniters = int(total/100)\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if ascii is None:\n        try:\n            file.encoding\n        except AttributeError:\n            ascii = True\n        else:\n            if file.encoding:\n                ascii = not ('U8' == file.encoding or\n                             ('utf' in file.encoding) or\n                             ('UTF' in file.encoding))\n            else:\n                ascii = True\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix, ascii))\n\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n + 1)\n\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix, ascii))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_patch": "@@ -26,13 +26,14 @@ def format_interval(t):\n         return '{0:02d}:{1:02d}'.format(m, s)\n \n \n-def format_meter(n, total, elapsed, ncols=None, prefix=''):\n+def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False):\n     # n - number of finished iterations\n     # total - total number of iterations, or None\n     # elapsed - number of seconds passed since start\n     # ncols - the output width in chars. If specified, dynamically resizes bar.\n     #     [default bar width: 10].\n     # prefix - prepend message (included in total width)\n+    # ascii - whether to use ascii (otherwise unicode) character set\n     if total and n > total:\n         total = None\n \n@@ -50,15 +51,24 @@ def format_meter(n, total, elapsed, ncols=None, prefix=''):\n                 n, total, elapsed_str, left_str, rate)\n \n         N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n-        bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n \n-        try:\n-            unich = unichr\n-        except NameError:\n-            unich = chr\n+        if ascii:\n+            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n+\n+            bar = '#'*bar_length\n+            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n+\n+        else:\n+            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n \n-        bar = unich(0x2588)*bar_length\n-        frac_bar = unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n+            try:\n+                unich = unichr\n+            except NameError:\n+                unich = chr\n+\n+            bar = unich(0x2588)*bar_length\n+            frac_bar = unich(0x2590 - frac_bar_length) \\\n+                if frac_bar_length else ' '\n \n         if bar_length < N_BARS:\n             return l_bar + bar + frac_bar + \\\n@@ -83,7 +93,7 @@ class StatusPrinter(object):\n \n \n def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n-         ncols=None, mininterval=0.1, miniters=None):\n+         ncols=None, mininterval=0.1, miniters=None, ascii=None):\n     \"\"\"\n     Decorate an iterable object, returning an iterator which acts exactly\n     like the orignal iterable, but prints a dynamically updating\n@@ -113,6 +123,9 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         Minimum progress update interval, in seconds [default: 0.1].\n     miniters  : int, optional\n         Minimum progress update interval, in iterations [default: None].\n+    ascii  : bool, optional\n+        If not set, use unicode (smooth blocks) to fill the meter\n+        [default: False]. The fallback is to use ASCII characters (1-9 #).\n \n     Returns\n     -------\n@@ -133,10 +146,23 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n     else:\n         dynamic_miniters = False\n \n+    if ascii is None:\n+        try:\n+            file.encoding\n+        except AttributeError:\n+            ascii = True\n+        else:\n+            if file.encoding:\n+                ascii = not ('U8' == file.encoding or\n+                             ('utf' in file.encoding) or\n+                             ('UTF' in file.encoding))\n+            else:\n+                ascii = True\n+\n     prefix = desc+': ' if desc else ''\n \n     sp = StatusPrinter(file)\n-    sp.print_status(format_meter(0, total, 0, ncols, prefix))\n+    sp.print_status(format_meter(0, total, 0, ncols, prefix, ascii))\n \n     start_t = last_print_t = time.time()\n     last_print_n = 0\n@@ -150,7 +176,7 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n             cur_t = time.time()\n             if cur_t - last_print_t >= mininterval:\n                 sp.print_status(format_meter(\n-                    n, total, cur_t-start_t, ncols, prefix))\n+                    n, total, cur_t-start_t, ncols, prefix, ascii))\n \n                 if dynamic_miniters:\n                     miniters = max(miniters, n - last_print_n + 1)\n@@ -162,7 +188,7 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         if last_print_n < n:\n             cur_t = time.time()\n             sp.print_status(format_meter(\n-                n, total, cur_t-start_t, ncols, prefix))\n+                n, total, cur_t-start_t, ncols, prefix, ascii))\n         file.write('\\n')\n     else:\n         sp.print_status('')\n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      },
      "ac4646c723a22aaa14a005613d892822cf81eebb": {
        "commit": {
          "commit_id": "ac4646c723a22aaa14a005613d892822cf81eebb",
          "commit_message": "major and minor efficiency improvements, minor function signature and documentation update",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-06-18 15:59:37",
          "commit_parent": "8ac163e1e7043a615eeb38c63aa765abd2345692"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed, ncols=None, prefix=''):\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        bar_length = int(frac * N_BARS)\n        frac_bar_length = int(frac * N_BARS * 8 % 8)\n        try:\n            unich = unichr\n        except:\n            unich = chr\n        bar = unich(9608) * bar_length\n        frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix=''):\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n        try:\n            unich = unichr\n        except:\n            unich = chr\n        bar = unich(9608) * bar_length\n        frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_before_start_line": 29,
          "function_before_end_line": 70,
          "function_after_start_line": 29,
          "function_after_end_line": 70,
          "function_before_token_count": 232,
          "function_after_token_count": 233,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "trange",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "trange",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_co_evolved_modified_file": [
            "tqdm",
            "print_status"
          ],
          "functions_name_co_evolved_all_files": [
            "tqdm",
            "print_status"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 103,
          "file_complexity": 28,
          "file_token_count": 692,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix=''):\n    # n - number of finished iterations\n    # total - total number of iterations, or None\n    # elapsed - number of seconds passed since start\n    # ncols - the output width in chars. If specified, dynamically resizes bar.\n    #     [default bar width: 10].\n    # prefix - prepend message (included in total width)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        bar_length = int(frac * N_BARS)\n        frac_bar_length = int((frac * N_BARS * 8) % 8)\n\n        try:\n            unich = unichr\n        except:\n            unich = chr\n\n        bar = unich(0x2588)*bar_length\n        frac_bar = unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            bar = bar + frac_bar + ' '*max(N_BARS - bar_length - 1, 0)\n\n        return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n        self.file.flush()\n        self.last_printed_len = len(s)\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=1):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.5].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: 1].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix))\n                last_print_n = n\n                last_print_t = cur_t\n\n    if not leave:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n    else:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix))\n        file.write('\\n')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\": [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n                              \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix=''):\n    # n - number of finished iterations\n    # total - total number of iterations, or None\n    # elapsed - number of seconds passed since start\n    # ncols - the output width in chars. If specified, dynamically resizes bar.\n    #     [default bar width: 10].\n    # prefix - prepend message (included in total width)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n        try:\n            unich = unichr\n        except:\n            unich = chr\n\n        bar = unich(0x2588)*bar_length\n        frac_bar = unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            return l_bar + bar + frac_bar + \\\n                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n        else:\n            return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        len_s = len(s)\n        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n        self.file.flush()\n        self.last_printed_len = len_s\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=None):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n\n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n        Uses file.write(str) and file.flush() methods.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.1].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: None].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n        # not good for slow iterators\n        # elif not miniters:\n        #     miniters = int(total/100)\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                    n, total, cur_t-start_t, ncols, prefix))\n\n                if dynamic_miniters:\n                    miniters = max(miniters, n - last_print_n + 1)\n\n                last_print_n = n\n                last_print_t = cur_t\n\n    if leave:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(\n                n, total, cur_t-start_t, ncols, prefix))\n        file.write('\\n')\n    else:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n\n\n# def tqdmise(iterable):\n#     \"\"\"\n#     A decorator for custom iterators:\n#         @tqdmise\n#         def myiter(*args, **kwargs):\n#             ...\n#     is equivalent to\n#         def myiter(*args):\n#             ...\n#     myiter = tqdmise(myiter(*args), **kwargs)\n#     \"\"\"\n#     def with_tqdm(*args, **kwargs):\n#         return tqdm(iterable(*args), **kwargs)\n#     return with_tqdm\n",
          "file_patch": "@@ -50,8 +50,7 @@ def format_meter(n, total, elapsed, ncols=None, prefix=''):\n                 n, total, elapsed_str, left_str, rate)\n \n         N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n-        bar_length = int(frac * N_BARS)\n-        frac_bar_length = int((frac * N_BARS * 8) % 8)\n+        bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n \n         try:\n             unich = unichr\n@@ -62,9 +61,10 @@ def format_meter(n, total, elapsed, ncols=None, prefix=''):\n         frac_bar = unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n \n         if bar_length < N_BARS:\n-            bar = bar + frac_bar + ' '*max(N_BARS - bar_length - 1, 0)\n-\n-        return l_bar + bar + r_bar\n+            return l_bar + bar + frac_bar + \\\n+                ' '*max(N_BARS - bar_length - 1, 0) + r_bar\n+        else:\n+            return l_bar + bar + r_bar\n \n     else:\n         return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n@@ -76,13 +76,14 @@ class StatusPrinter(object):\n         self.last_printed_len = 0\n \n     def print_status(self, s):\n-        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n+        len_s = len(s)\n+        self.file.write('\\r'+s+' '*max(self.last_printed_len - len_s, 0))\n         self.file.flush()\n-        self.last_printed_len = len(s)\n+        self.last_printed_len = len_s\n \n \n def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n-         ncols=None, mininterval=0.1, miniters=1):\n+         ncols=None, mininterval=0.1, miniters=None):\n     \"\"\"\n     Decorate an iterable object, returning an iterator which acts exactly\n     like the orignal iterable, but prints a dynamically updating\n@@ -100,6 +101,7 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         are displayed.\n     file  : `io.TextIOWrapper` or `io.StringIO`, optional\n         Specifies where to output the progress messages.\n+        Uses file.write(str) and file.flush() methods.\n     leave  : bool, optional\n         if unset, removes all traces of the progressbar upon termination of\n         iteration [default: False].\n@@ -108,9 +110,9 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         resizes the progress meter [default: None]. The fallback meter\n         width is 10.\n     mininterval  : float, optional\n-        Minimum progress update interval, in seconds [default: 0.5].\n+        Minimum progress update interval, in seconds [default: 0.1].\n     miniters  : int, optional\n-        Minimum progress update interval, in iterations [default: 1].\n+        Minimum progress update interval, in iterations [default: None].\n \n     Returns\n     -------\n@@ -121,6 +123,15 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n             total = len(iterable)\n         except (TypeError, AttributeError):\n             total = None\n+        # not good for slow iterators\n+        # elif not miniters:\n+        #     miniters = int(total/100)\n+\n+    if miniters is None:\n+        miniters = 0\n+        dynamic_miniters = True\n+    else:\n+        dynamic_miniters = False\n \n     prefix = desc+': ' if desc else ''\n \n@@ -140,18 +151,22 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n             if cur_t - last_print_t >= mininterval:\n                 sp.print_status(format_meter(\n                     n, total, cur_t-start_t, ncols, prefix))\n+\n+                if dynamic_miniters:\n+                    miniters = max(miniters, n - last_print_n + 1)\n+\n                 last_print_n = n\n                 last_print_t = cur_t\n \n-    if not leave:\n-        sp.print_status('')\n-        sys.stdout.write('\\r')\n-    else:\n+    if leave:\n         if last_print_n < n:\n             cur_t = time.time()\n             sp.print_status(format_meter(\n                 n, total, cur_t-start_t, ncols, prefix))\n         file.write('\\n')\n+    else:\n+        sp.print_status('')\n+        sys.stdout.write('\\r')\n \n \n def trange(*args, **kwargs):\n@@ -165,3 +180,19 @@ def trange(*args, **kwargs):\n         f = range\n \n     return tqdm(f(*args), **kwargs)\n+\n+\n+# def tqdmise(iterable):\n+#     \"\"\"\n+#     A decorator for custom iterators:\n+#         @tqdmise\n+#         def myiter(*args, **kwargs):\n+#             ...\n+#     is equivalent to\n+#         def myiter(*args):\n+#             ...\n+#     myiter = tqdmise(myiter(*args), **kwargs)\n+#     \"\"\"\n+#     def with_tqdm(*args, **kwargs):\n+#         return tqdm(iterable(*args), **kwargs)\n+#     return with_tqdm\n",
          "files_name_in_blame_commit": [
            "_tqdm.py"
          ]
        }
      },
      "e9ccb10310f7bb1eca9d53b4ca199a1f18987101": {
        "commit": {
          "commit_id": "e9ccb10310f7bb1eca9d53b4ca199a1f18987101",
          "commit_message": "revert to N_BAR=10 as default, a sligtly faster (10Hz rather than 2Hz) update interval looks better without measurable reduction in iteration speed",
          "commit_author": "Casper da Costa-Luis",
          "commit_date": "2015-06-15 10:35:06",
          "commit_parent": "373d0bad85f3b955f789952e17f9b3c7446a673f"
        },
        "function": {
          "function_name": "format_meter",
          "function_code_before": "def format_meter(n, total, elapsed):\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        N_BARS = 32\n        bar_length = int(frac * N_BARS)\n        frac_bar_length = int(frac * N_BARS * 8 % 8)\n        bar = u'\u2588' * bar_length\n        if bar_length < N_BARS:\n            bar = bar + (unichr(9616 - frac_bar_length) if frac_bar_length else ' ') + ' ' * max(N_BARS - bar_length - 1, 0)\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        return u'{3:3.0f}%|{0}| {1}/{2} [{4}<{5}, {6} it/s]'.format(bar, n, total, frac * 100, elapsed_str, left_str, rate)\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_code_after": "def format_meter(n, total, elapsed, ncols=None, prefix=''):\n    if total and n > total:\n        total = None\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n    if total:\n        frac = float(n) / total\n        left_str = format_interval(elapsed * (total - n) / n) if n else '?'\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(n, total, elapsed_str, left_str, rate)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        bar_length = int(frac * N_BARS)\n        frac_bar_length = int(frac * N_BARS * 8 % 8)\n        try:\n            unich = unichr\n        except:\n            unich = chr\n        bar = unich(9608) * bar_length\n        frac_bar = unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        return l_bar + bar + r_bar\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)",
          "function_before_start_line": 29,
          "function_before_end_line": 58,
          "function_after_start_line": 29,
          "function_after_end_line": 68,
          "function_before_token_count": 170,
          "function_after_token_count": 232,
          "functions_name_modified_file": [
            "__init__",
            "print_status",
            "trange",
            "tqdm",
            "format_interval",
            "format_meter"
          ],
          "functions_name_all_files": [
            "__init__",
            "print_status",
            "trange",
            "test_iterate_over_csv_rows",
            "test_file_output",
            "test_leave_option",
            "tqdm",
            "test_min_interval",
            "test_format_meter",
            "test_trange",
            "format_interval",
            "format_meter",
            "test_format_interval",
            "test_nothing_fails"
          ],
          "functions_name_co_evolved_modified_file": [
            "tqdm"
          ],
          "functions_name_co_evolved_all_files": [
            "tqdm",
            "test_format_meter",
            "test_min_interval"
          ]
        },
        "file": {
          "file_name": "_tqdm.py",
          "file_nloc": 91,
          "file_complexity": 26,
          "file_token_count": 661,
          "file_before": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\" : [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n        \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed):\n    # n - number of finished iterations\n    # total - total number of iterations, or None\n    # elapsed - number of seconds passed since start\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        N_BARS = 32\n        bar_length = int(frac * N_BARS)\n        frac_bar_length = int((frac * N_BARS * 8) % 8)\n        \n        bar = u'\\u2588'*bar_length\n        if bar_length < N_BARS:\n            bar = bar \\\n                  +(unichr(0x2590-frac_bar_length) if frac_bar_length else ' ')\\\n                  + ' '*max(N_BARS - bar_length - 1, 0)\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        return u'{3:3.0f}%|{0}| {1}/{2} [{4}<{5}, {6} it/s]'.format(\n            bar, n, total, frac * 100, elapsed_str, left_str, rate)\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n        self.file.flush()\n        self.last_printed_len = len(s)\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         mininterval=0.5, miniters=1):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n    \n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.5].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: 1].\n    \n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(prefix + format_meter(0, total, 0))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(prefix + format_meter(n, total, cur_t-start_t))\n                last_print_n = n\n                last_print_t = cur_t\n\n    if not leave:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n    else:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(prefix + format_meter(n, total, cur_t-start_t))\n        file.write('\\n')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_after": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default (x)range iterator printing to stderr.\n\nUsage:\n  from tqdm import trange[, tqdm]\n  for i in trange(10):\n    ...\n\"\"\"\nfrom __future__ import division, absolute_import\nimport sys\nimport time\n\n\n__author__ = {\"github.com/\" : [\"noamraph\", \"JackMc\", \"arkottke\", \"obiwanus\",\n        \"fordhurley\", \"kmike\", \"hadim\", \"casperdcl\"]}\n__all__ = ['tqdm', 'trange', 'format_interval', 'format_meter']\n\n\ndef format_interval(t):\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)\n\n\ndef format_meter(n, total, elapsed, ncols=None, prefix=''):\n    # n - number of finished iterations\n    # total - total number of iterations, or None\n    # elapsed - number of seconds passed since start\n    # ncols - the output width in chars. If specified, dynamically resizes bar.\n    #     [default bar width: 10].\n    # prefix - prepend message (included in total width)\n    if total and n > total:\n        total = None\n\n    elapsed_str = format_interval(elapsed)\n    rate = '{0:5.2f}'.format(n / elapsed) if elapsed else '?'\n\n    if total:\n        frac = float(n) / total\n\n        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n\n        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n                '{0:3.0f}%|'.format(frac * 100)\n        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n                n, total, elapsed_str, left_str, rate)\n\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        bar_length = int(frac * N_BARS)\n        frac_bar_length = int((frac * N_BARS * 8) % 8)\n\n        try: unich = unichr\n        except: unich = chr\n\n        bar = unich(0x2588)*bar_length\n        frac_bar = unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n\n        if bar_length < N_BARS:\n            bar = bar + frac_bar + ' '*max(N_BARS - bar_length - 1, 0)\n\n        return l_bar + bar + r_bar\n\n    else:\n        return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n\n\nclass StatusPrinter(object):\n    def __init__(self, file):\n        self.file = file\n        self.last_printed_len = 0\n\n    def print_status(self, s):\n        self.file.write('\\r'+s+' '*max(self.last_printed_len-len(s), 0))\n        self.file.flush()\n        self.last_printed_len = len(s)\n\n\ndef tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n         ncols=None, mininterval=0.1, miniters=1):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the orignal iterable, but prints a dynamically updating\n    progressbar.\n    \n    Parameters\n    ----------\n    iterable  : iterable\n        Iterable to decorate with a progressbar.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If not given, len(iterable) is\n        used if possible. As a last resort, only basic progress statistics\n        are displayed.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages.\n    leave  : bool, optional\n        if unset, removes all traces of the progressbar upon termination of\n        iteration [default: False].\n    ncols  : int, optional\n        The width of the entire output message. If sepcified, dynamically\n        resizes the progress meter [default: None]. The fallback meter\n        width is 10.\n    mininterval  : float, optional\n        Minimum progress update interval, in seconds [default: 0.5].\n    miniters  : int, optional\n        Minimum progress update interval, in iterations [default: 1].\n    \n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if total is None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n\n    prefix = desc+': ' if desc else ''\n\n    sp = StatusPrinter(file)\n    sp.print_status(format_meter(0, total, 0, ncols, prefix))\n\n    start_t = last_print_t = time.time()\n    last_print_n = 0\n    n = 0\n    for obj in iterable:\n        yield obj\n        # Now the object was created and processed, so we can print the meter.\n        n += 1\n        if n - last_print_n >= miniters:\n            # We check the counter first, to reduce the overhead of time.time()\n            cur_t = time.time()\n            if cur_t - last_print_t >= mininterval:\n                sp.print_status(format_meter(\n                        n, total, cur_t-start_t, ncols, prefix))\n                last_print_n = n\n                last_print_t = cur_t\n\n    if not leave:\n        sp.print_status('')\n        sys.stdout.write('\\r')\n    else:\n        if last_print_n < n:\n            cur_t = time.time()\n            sp.print_status(format_meter(n, total, cur_t-start_t, ncols, prefix))\n        file.write('\\n')\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    try:\n        f = xrange\n    except NameError:\n        f = range\n\n    return tqdm(f(*args), **kwargs)\n",
          "file_patch": "@@ -26,10 +26,13 @@ def format_interval(t):\n         return '{0:02d}:{1:02d}'.format(m, s)\n \n \n-def format_meter(n, total, elapsed):\n+def format_meter(n, total, elapsed, ncols=None, prefix=''):\n     # n - number of finished iterations\n     # total - total number of iterations, or None\n     # elapsed - number of seconds passed since start\n+    # ncols - the output width in chars. If specified, dynamically resizes bar.\n+    #     [default bar width: 10].\n+    # prefix - prepend message (included in total width)\n     if total and n > total:\n         total = None\n \n@@ -39,20 +42,27 @@ def format_meter(n, total, elapsed):\n     if total:\n         frac = float(n) / total\n \n-        N_BARS = 32\n+        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n+\n+        l_bar = '{1}{0:.0f}%|'.format(frac * 100, prefix) if prefix else \\\n+                '{0:3.0f}%|'.format(frac * 100)\n+        r_bar = '| {0}/{1} [{2}<{3}, {4} it/s]'.format(\n+                n, total, elapsed_str, left_str, rate)\n+\n+        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n         bar_length = int(frac * N_BARS)\n         frac_bar_length = int((frac * N_BARS * 8) % 8)\n-        \n-        bar = u'\\u2588'*bar_length\n-        if bar_length < N_BARS:\n-            bar = bar \\\n-                  +(unichr(0x2590-frac_bar_length) if frac_bar_length else ' ')\\\n-                  + ' '*max(N_BARS - bar_length - 1, 0)\n \n-        left_str = format_interval(elapsed * (total-n) / n) if n else '?'\n+        try: unich = unichr\n+        except: unich = chr\n+\n+        bar = unich(0x2588)*bar_length\n+        frac_bar = unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n+\n+        if bar_length < N_BARS:\n+            bar = bar + frac_bar + ' '*max(N_BARS - bar_length - 1, 0)\n \n-        return u'{3:3.0f}%|{0}| {1}/{2} [{4}<{5}, {6} it/s]'.format(\n-            bar, n, total, frac * 100, elapsed_str, left_str, rate)\n+        return l_bar + bar + r_bar\n \n     else:\n         return '{0:d} [{1}, {2} it/s]'.format(n, elapsed_str, rate)\n@@ -70,7 +80,7 @@ class StatusPrinter(object):\n \n \n def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n-         mininterval=0.5, miniters=1):\n+         ncols=None, mininterval=0.1, miniters=1):\n     \"\"\"\n     Decorate an iterable object, returning an iterator which acts exactly\n     like the orignal iterable, but prints a dynamically updating\n@@ -91,6 +101,10 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n     leave  : bool, optional\n         if unset, removes all traces of the progressbar upon termination of\n         iteration [default: False].\n+    ncols  : int, optional\n+        The width of the entire output message. If sepcified, dynamically\n+        resizes the progress meter [default: None]. The fallback meter\n+        width is 10.\n     mininterval  : float, optional\n         Minimum progress update interval, in seconds [default: 0.5].\n     miniters  : int, optional\n@@ -109,7 +123,7 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n     prefix = desc+': ' if desc else ''\n \n     sp = StatusPrinter(file)\n-    sp.print_status(prefix + format_meter(0, total, 0))\n+    sp.print_status(format_meter(0, total, 0, ncols, prefix))\n \n     start_t = last_print_t = time.time()\n     last_print_n = 0\n@@ -122,7 +136,8 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n             # We check the counter first, to reduce the overhead of time.time()\n             cur_t = time.time()\n             if cur_t - last_print_t >= mininterval:\n-                sp.print_status(prefix + format_meter(n, total, cur_t-start_t))\n+                sp.print_status(format_meter(\n+                        n, total, cur_t-start_t, ncols, prefix))\n                 last_print_n = n\n                 last_print_t = cur_t\n \n@@ -132,7 +147,7 @@ def tqdm(iterable, desc=None, total=None, leave=False, file=sys.stderr,\n     else:\n         if last_print_n < n:\n             cur_t = time.time()\n-            sp.print_status(prefix + format_meter(n, total, cur_t-start_t))\n+            sp.print_status(format_meter(n, total, cur_t-start_t, ncols, prefix))\n         file.write('\\n')\n \n \n",
          "files_name_in_blame_commit": [
            "_tqdm.py",
            "tests_tqdm.py"
          ]
        }
      }
    }
  }
}
{
  "id": "12",
  "blame_commit": {
    "commit": {
      "commit_id": "86095f49b9b15a3c9642f1147d72a557a72bd3c3",
      "commit_message": "Use open context manager to read context_file in generate",
      "commit_author": "Raphael Pierzina",
      "commit_date": "2015-11-27 18:20:46",
      "commit_parent": "c97b19d1529b21439e0d25cf827091e3fe187109"
    },
    "function": {
      "function_name": "generate_context",
      "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
      "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
      "function_before_start_line": 76,
      "function_before_end_line": 116,
      "function_after_start_line": 76,
      "function_after_end_line": 116,
      "function_before_token_count": 140,
      "function_after_token_count": 142,
      "functions_name_modified_file": [
        "render_and_create_dir",
        "ensure_dir_is_templated",
        "apply_overwrites_to_context",
        "generate_file",
        "copy_without_render",
        "generate_context",
        "_run_hook_from_repo_dir",
        "generate_files"
      ],
      "functions_name_all_files": [
        "render_and_create_dir",
        "ensure_dir_is_templated",
        "apply_overwrites_to_context",
        "generate_file",
        "copy_without_render",
        "generate_context",
        "_run_hook_from_repo_dir",
        "generate_files"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": []
    },
    "file": {
      "file_name": "generate.py",
      "file_nloc": 186,
      "file_complexity": 35,
      "file_token_count": 1135,
      "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport fnmatch\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import (\n    NonTemplatedInputDirException,\n    ContextDecodingException,\n    FailedHookException,\n    OutputDirExistsException\n)\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in, rmtree\nfrom .hooks import run_hook\n\n\ndef copy_without_render(path, context):\n    \"\"\"\n    Returns True if `path` matches some pattern in the\n    `_copy_without_render` context setting.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False\n\n\ndef apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logging.debug('The resulting file name is empty: {0}'.format(outfile))\n        return\n\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir,\n                          overwrite_if_exists=False):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if overwrite_if_exists:\n        if output_dir_exists:\n            logging.debug('Output directory {} already exists,'\n                          'overwriting it'.format(dir_to_create))\n    else:\n        if output_dir_exists:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context):\n    \"\"\"\n    Run hook from repo directory, cleaning up project directory if hook fails\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            rmtree(project_dir)\n            logging.error(\"Stopping generation because %s\"\n                          \" hook script didn't exit sucessfully\" % hook_name)\n            raise\n\n\ndef generate_files(repo_dir, context=None, output_dir='.',\n                   overwrite_if_exists=False):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir,\n                                        context,\n                                        output_dir,\n                                        overwrite_if_exists)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    _run_hook_from_repo_dir(repo_dir, 'pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if copy_without_render(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                logging.debug(\n                    'Copying dir {0} to {1} without rendering'\n                    ''.format(indir, outdir)\n                )\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                render_and_create_dir(unrendered_dir, context, output_dir,\n                                      overwrite_if_exists)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if copy_without_render(infile, context):\n                    outfile_tmpl = Template(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logging.debug(\n                        'Copying file {0} to {1} without rendering'\n                        ''.format(infile, outfile)\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    _run_hook_from_repo_dir(repo_dir, 'post_gen_project', project_dir, context)\n\n    return project_dir\n",
      "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport fnmatch\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import (\n    NonTemplatedInputDirException,\n    ContextDecodingException,\n    FailedHookException,\n    OutputDirExistsException\n)\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in, rmtree\nfrom .hooks import run_hook\n\n\ndef copy_without_render(path, context):\n    \"\"\"\n    Returns True if `path` matches some pattern in the\n    `_copy_without_render` context setting.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False\n\n\ndef apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logging.debug('The resulting file name is empty: {0}'.format(outfile))\n        return\n\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir,\n                          overwrite_if_exists=False):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if overwrite_if_exists:\n        if output_dir_exists:\n            logging.debug('Output directory {} already exists,'\n                          'overwriting it'.format(dir_to_create))\n    else:\n        if output_dir_exists:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context):\n    \"\"\"\n    Run hook from repo directory, cleaning up project directory if hook fails\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            rmtree(project_dir)\n            logging.error(\"Stopping generation because %s\"\n                          \" hook script didn't exit sucessfully\" % hook_name)\n            raise\n\n\ndef generate_files(repo_dir, context=None, output_dir='.',\n                   overwrite_if_exists=False):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir,\n                                        context,\n                                        output_dir,\n                                        overwrite_if_exists)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    _run_hook_from_repo_dir(repo_dir, 'pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if copy_without_render(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                logging.debug(\n                    'Copying dir {0} to {1} without rendering'\n                    ''.format(indir, outdir)\n                )\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                render_and_create_dir(unrendered_dir, context, output_dir,\n                                      overwrite_if_exists)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if copy_without_render(infile, context):\n                    outfile_tmpl = Template(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logging.debug(\n                        'Copying file {0} to {1} without rendering'\n                        ''.format(infile, outfile)\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    _run_hook_from_repo_dir(repo_dir, 'post_gen_project', project_dir, context)\n\n    return project_dir\n",
      "file_patch": "@@ -87,9 +87,9 @@ def generate_context(context_file='cookiecutter.json', default_context=None,\n \n     context = {}\n \n-    file_handle = open(context_file)\n     try:\n-        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n+        with open(context_file) as file_handle:\n+            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n     except ValueError as e:\n         # JSON decoding error.  Let's throw a new exception that is more\n         # friendly for the developer or user.\n",
      "files_name_in_blame_commit": [
        "generate.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 111
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "76": {
        "commit_id": "8c3ce23eab374ac311a384275edda83ac6c3c4cc",
        "line_code": "def generate_context(context_file='cookiecutter.json', default_context=None,",
        "commit_date": "2014-08-28 22:31:04",
        "valid": 1
      },
      "77": {
        "commit_id": "8c3ce23eab374ac311a384275edda83ac6c3c4cc",
        "line_code": "                     extra_context=None):",
        "commit_date": "2014-08-28 22:31:04",
        "valid": 1
      },
      "78": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "    \"\"\"",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 1
      },
      "79": {
        "commit_id": "0bbce99096a790f096f9a77c52760c3189620c9c",
        "line_code": "    Generates the context for a Cookiecutter project template.",
        "commit_date": "2013-07-22 10:28:34",
        "valid": 1
      },
      "80": {
        "commit_id": "ed1f47b6c4b7e35069bc66bfe30c9e6b28cd2464",
        "line_code": "    Loads the JSON file as a Python object, with key being the JSON filename.",
        "commit_date": "2013-08-07 17:32:44",
        "valid": 1
      },
      "81": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 0
      },
      "82": {
        "commit_id": "87bf3549f260da72e7eb06c7091dbf639dbcd329",
        "line_code": "    :param context_file: JSON file containing key/value pairs for populating",
        "commit_date": "2013-09-11 23:35:43",
        "valid": 1
      },
      "83": {
        "commit_id": "87bf3549f260da72e7eb06c7091dbf639dbcd329",
        "line_code": "        the cookiecutter's variables.",
        "commit_date": "2013-09-11 23:35:43",
        "valid": 1
      },
      "84": {
        "commit_id": "aa1e7ebe0b92fbfcaebe4b31bf8dd12ded20e4d2",
        "line_code": "    :param default_context: Dictionary containing config to take into account.",
        "commit_date": "2014-10-23 14:08:25",
        "valid": 1
      },
      "85": {
        "commit_id": "8c3ce23eab374ac311a384275edda83ac6c3c4cc",
        "line_code": "    :param extra_context: Dictionary containing configuration overrides",
        "commit_date": "2014-08-28 22:31:04",
        "valid": 1
      },
      "86": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "    \"\"\"",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 1
      },
      "87": {
        "commit_id": "ed1f47b6c4b7e35069bc66bfe30c9e6b28cd2464",
        "line_code": "",
        "commit_date": "2013-08-07 17:32:44",
        "valid": 0
      },
      "88": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "    context = {}",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 1
      },
      "89": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 0
      },
      "90": {
        "commit_id": "765c4d1db199cfa469babf873788fbd2ff3db1be",
        "line_code": "    file_handle = open(context_file)",
        "commit_date": "2013-09-07 13:13:09",
        "valid": 1
      },
      "91": {
        "commit_id": "687e09c663b9d8cedf02abdb5daacafc22782155",
        "line_code": "    try:",
        "commit_date": "2015-02-20 20:15:10",
        "valid": 1
      },
      "92": {
        "commit_id": "6085037f61efc158d75c2c5975d7ec6ac58fe91d",
        "line_code": "        obj = json.load(file_handle, object_pairs_hook=OrderedDict)",
        "commit_date": "2014-07-26 20:20:58",
        "valid": 1
      },
      "93": {
        "commit_id": "687e09c663b9d8cedf02abdb5daacafc22782155",
        "line_code": "    except ValueError as e:",
        "commit_date": "2015-02-20 20:15:10",
        "valid": 1
      },
      "94": {
        "commit_id": "2303652b05a7a09b8387527bacc2822ea8d962b8",
        "line_code": "        # JSON decoding error.  Let's throw a new exception that is more",
        "commit_date": "2015-02-20 20:28:14",
        "valid": 1
      },
      "95": {
        "commit_id": "2303652b05a7a09b8387527bacc2822ea8d962b8",
        "line_code": "        # friendly for the developer or user.",
        "commit_date": "2015-02-20 20:28:14",
        "valid": 1
      },
      "96": {
        "commit_id": "687e09c663b9d8cedf02abdb5daacafc22782155",
        "line_code": "        full_fpath = os.path.abspath(context_file)",
        "commit_date": "2015-02-20 20:15:10",
        "valid": 1
      },
      "97": {
        "commit_id": "687e09c663b9d8cedf02abdb5daacafc22782155",
        "line_code": "        json_exc_message = str(e)",
        "commit_date": "2015-02-20 20:15:10",
        "valid": 1
      },
      "98": {
        "commit_id": "2303652b05a7a09b8387527bacc2822ea8d962b8",
        "line_code": "        our_exc_message = (",
        "commit_date": "2015-02-20 20:28:14",
        "valid": 1
      },
      "99": {
        "commit_id": "2303652b05a7a09b8387527bacc2822ea8d962b8",
        "line_code": "            'JSON decoding error while loading \"{0}\".  Decoding'",
        "commit_date": "2015-02-20 20:28:14",
        "valid": 1
      },
      "100": {
        "commit_id": "2303652b05a7a09b8387527bacc2822ea8d962b8",
        "line_code": "            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))",
        "commit_date": "2015-02-20 20:28:14",
        "valid": 1
      },
      "101": {
        "commit_id": "687e09c663b9d8cedf02abdb5daacafc22782155",
        "line_code": "        raise ContextDecodingException(our_exc_message)",
        "commit_date": "2015-02-20 20:15:10",
        "valid": 1
      },
      "102": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 0
      },
      "103": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "    # Add the Python object to the context dictionary",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 1
      },
      "104": {
        "commit_id": "765c4d1db199cfa469babf873788fbd2ff3db1be",
        "line_code": "    file_name = os.path.split(context_file)[1]",
        "commit_date": "2013-09-07 13:13:09",
        "valid": 1
      },
      "105": {
        "commit_id": "2dbf0c797473346ef5eeb79ce4cfc13609adec59",
        "line_code": "    file_stem = file_name.split('.')[0]",
        "commit_date": "2013-08-19 00:49:11",
        "valid": 1
      },
      "106": {
        "commit_id": "01bb77d4d812a325969a9845696ebc2b5e2e9d87",
        "line_code": "    context[file_stem] = obj",
        "commit_date": "2013-08-19 00:57:10",
        "valid": 1
      },
      "107": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 0
      },
      "108": {
        "commit_id": "c5b51a6d78d71e35f1fec9223064e691fd30c591",
        "line_code": "    # Overwrite context variable defaults with the default context from the",
        "commit_date": "2013-09-07 13:24:17",
        "valid": 1
      },
      "109": {
        "commit_id": "c5b51a6d78d71e35f1fec9223064e691fd30c591",
        "line_code": "    # user's global config, if available",
        "commit_date": "2013-09-07 13:24:17",
        "valid": 1
      },
      "110": {
        "commit_id": "e95eb56800cd167352259388578a6ba20304e0d1",
        "line_code": "    if default_context:",
        "commit_date": "2013-09-07 14:01:33",
        "valid": 1
      },
      "111": {
        "commit_id": "ab2ff6bbc116d0331dcad1de209021f9fbbc03a0",
        "line_code": "        apply_overwrites_to_context(obj, default_context)",
        "commit_date": "2015-09-29 14:33:53",
        "valid": 1
      },
      "112": {
        "commit_id": "8c3ce23eab374ac311a384275edda83ac6c3c4cc",
        "line_code": "    if extra_context:",
        "commit_date": "2014-08-28 22:31:04",
        "valid": 1
      },
      "113": {
        "commit_id": "ab2ff6bbc116d0331dcad1de209021f9fbbc03a0",
        "line_code": "        apply_overwrites_to_context(obj, extra_context)",
        "commit_date": "2015-09-29 14:33:53",
        "valid": 1
      },
      "114": {
        "commit_id": "c5b51a6d78d71e35f1fec9223064e691fd30c591",
        "line_code": "",
        "commit_date": "2013-09-07 13:24:17",
        "valid": 0
      },
      "115": {
        "commit_id": "1b6b483d2658217764f61d892ba23fe05445a464",
        "line_code": "    logging.debug('Context generated is {0}'.format(context))",
        "commit_date": "2013-08-08 11:07:54",
        "valid": 1
      },
      "116": {
        "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
        "line_code": "    return context",
        "commit_date": "2013-07-21 13:03:02",
        "valid": 1
      }
    },
    "commits": {
      "ab2ff6bbc116d0331dcad1de209021f9fbbc03a0": {
        "commit": {
          "commit_id": "ab2ff6bbc116d0331dcad1de209021f9fbbc03a0",
          "commit_message": "Implement  to properly handle choice variables",
          "commit_author": "Raphael Pierzina",
          "commit_date": "2015-09-29 14:33:53",
          "commit_parent": "d67ac80c87a5a02730724c1542124e90e557a10a"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 53,
          "function_before_end_line": 93,
          "function_after_start_line": 76,
          "function_after_end_line": 116,
          "function_before_token_count": 140,
          "function_after_token_count": 140,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "ensure_dir_is_templated",
            "apply_overwrites_to_context",
            "generate_file",
            "copy_without_render",
            "generate_context",
            "generate_files"
          ],
          "functions_name_all_files": [
            "render_and_create_dir",
            "ensure_dir_is_templated",
            "apply_overwrites_to_context",
            "generate_file",
            "copy_without_render",
            "generate_context",
            "generate_files"
          ],
          "functions_name_co_evolved_modified_file": [
            "apply_overwrites_to_context"
          ],
          "functions_name_co_evolved_all_files": [
            "apply_overwrites_to_context"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 174,
          "file_complexity": 32,
          "file_token_count": 1069,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport fnmatch\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import (\n    NonTemplatedInputDirException,\n    ContextDecodingException,\n    OutputDirExistsException\n)\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\ndef copy_without_render(path, context):\n    \"\"\"\n    Returns True if `path` matches some pattern in the\n    `_copy_without_render` context setting.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir,\n                          overwrite_if_exists=False):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if overwrite_if_exists:\n        if output_dir_exists:\n            logging.debug('Output directory {} already exists,'\n                          'overwriting it'.format(dir_to_create))\n    else:\n        if output_dir_exists:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir='.',\n                   overwrite_if_exists=False):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir,\n                                        context,\n                                        output_dir,\n                                        overwrite_if_exists)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if copy_without_render(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                logging.debug(\n                    'Copying dir {0} to {1} without rendering'\n                    ''.format(indir, outdir)\n                )\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                render_and_create_dir(unrendered_dir, context, output_dir,\n                                      overwrite_if_exists)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if copy_without_render(infile, context):\n                    outfile_tmpl = Template(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logging.debug(\n                        'Copying file {0} to {1} without rendering'\n                        ''.format(infile, outfile)\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir, context)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport fnmatch\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import (\n    NonTemplatedInputDirException,\n    ContextDecodingException,\n    OutputDirExistsException\n)\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\ndef copy_without_render(path, context):\n    \"\"\"\n    Returns True if `path` matches some pattern in the\n    `_copy_without_render` context setting.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False\n\n\ndef apply_overwrites_to_context(context, overwrite_context):\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Albeit not relevant for the template, set this variable to\n            # resemble ``dict.update()``\n            context[variable] = overwrite\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir,\n                          overwrite_if_exists=False):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if overwrite_if_exists:\n        if output_dir_exists:\n            logging.debug('Output directory {} already exists,'\n                          'overwriting it'.format(dir_to_create))\n    else:\n        if output_dir_exists:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir='.',\n                   overwrite_if_exists=False):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir,\n                                        context,\n                                        output_dir,\n                                        overwrite_if_exists)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if copy_without_render(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                logging.debug(\n                    'Copying dir {0} to {1} without rendering'\n                    ''.format(indir, outdir)\n                )\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                render_and_create_dir(unrendered_dir, context, output_dir,\n                                      overwrite_if_exists)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if copy_without_render(infile, context):\n                    outfile_tmpl = Template(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logging.debug(\n                        'Copying file {0} to {1} without rendering'\n                        ''.format(infile, outfile)\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir, context)\n",
          "file_patch": "@@ -50,6 +50,29 @@ def copy_without_render(path, context):\n     return False\n \n \n+def apply_overwrites_to_context(context, overwrite_context):\n+    for variable, overwrite in overwrite_context.items():\n+        if variable not in context:\n+            # Albeit not relevant for the template, set this variable to\n+            # resemble ``dict.update()``\n+            context[variable] = overwrite\n+            continue\n+\n+        context_value = context[variable]\n+\n+        if isinstance(context_value, list):\n+            # We are dealing with a choice variable\n+            if overwrite in context_value:\n+                # This overwrite is actually valid for the given context\n+                # Let's set it as default (by definition first item in list)\n+                # see ``cookiecutter.prompt.prompt_choice_for_config``\n+                context_value.remove(overwrite)\n+                context_value.insert(0, overwrite)\n+        else:\n+            # Simply overwrite the value for this variable\n+            context[variable] = overwrite\n+\n+\n def generate_context(context_file='cookiecutter.json', default_context=None,\n                      extra_context=None):\n     \"\"\"\n@@ -85,9 +108,9 @@ def generate_context(context_file='cookiecutter.json', default_context=None,\n     # Overwrite context variable defaults with the default context from the\n     # user's global config, if available\n     if default_context:\n-        obj.update(default_context)\n+        apply_overwrites_to_context(obj, default_context)\n     if extra_context:\n-        obj.update(extra_context)\n+        apply_overwrites_to_context(obj, extra_context)\n \n     logging.debug('Context generated is {0}'.format(context))\n     return context\n",
          "files_name_in_blame_commit": [
            "generate.py"
          ]
        }
      },
      "2303652b05a7a09b8387527bacc2822ea8d962b8": {
        "commit": {
          "commit_id": "2303652b05a7a09b8387527bacc2822ea8d962b8",
          "commit_message": "Minor fixes pointed out by tox and company",
          "commit_author": "Mark Jones",
          "commit_date": "2015-02-20 20:28:14",
          "commit_parent": "cbcf5e84ddff3264faf4896874bc1728b5154420"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 30,
          "function_before_end_line": 69,
          "function_after_start_line": 29,
          "function_after_end_line": 69,
          "function_before_token_count": 138,
          "function_after_token_count": 140,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 107,
          "file_complexity": 16,
          "file_token_count": 700,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException, ContextDecodingException\nfrom collections import OrderedDict\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more friendly for the developer\n        # or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'\\\n                          .format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir='.'):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir,\n                                              os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir, context)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException, ContextDecodingException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir='.'):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir,\n                                              os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir, context)\n",
          "file_patch": "@@ -21,7 +21,6 @@ from jinja2.exceptions import TemplateSyntaxError\n from binaryornot.check import is_binary\n \n from .exceptions import NonTemplatedInputDirException, ContextDecodingException\n-from collections import OrderedDict\n from .find import find_template\n from .utils import make_sure_path_exists, work_in\n from .hooks import run_hook\n@@ -45,12 +44,13 @@ def generate_context(context_file='cookiecutter.json', default_context=None,\n     try:\n         obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n     except ValueError as e:\n-        # JSON decoding error.  Let's throw a new exception that is more friendly for the developer\n-        # or user.\n+        # JSON decoding error.  Let's throw a new exception that is more\n+        # friendly for the developer or user.\n         full_fpath = os.path.abspath(context_file)\n         json_exc_message = str(e)\n-        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'\\\n-                          .format(full_fpath, json_exc_message)\n+        our_exc_message = (\n+            'JSON decoding error while loading \"{0}\".  Decoding'\n+            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n         raise ContextDecodingException(our_exc_message)\n \n     # Add the Python object to the context dictionary\n",
          "files_name_in_blame_commit": [
            "generate.py"
          ]
        }
      },
      "687e09c663b9d8cedf02abdb5daacafc22782155": {
        "commit": {
          "commit_id": "687e09c663b9d8cedf02abdb5daacafc22782155",
          "commit_message": "Fixed PR358",
          "commit_author": "Mark Jones",
          "commit_date": "2015-02-20 20:15:10",
          "commit_parent": "0142778ffb44e9e55f607ddfd764ac57eeabeec6"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 29,
          "function_before_end_line": 59,
          "function_after_start_line": 30,
          "function_after_end_line": 69,
          "function_before_token_count": 99,
          "function_after_token_count": 138,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "context_data",
            "generate_file",
            "test_generate_context_with_json_decoding_error",
            "generate_files",
            "test_generate_context"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_generate_context_with_json_decoding_error"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 107,
          "file_complexity": 16,
          "file_token_count": 702,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir='.'):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir,\n                                              os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir, context)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nfrom collections import OrderedDict\nimport io\nimport json\nimport logging\nimport os\nimport shutil\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException, ContextDecodingException\nfrom collections import OrderedDict\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more friendly for the developer\n        # or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'\\\n                          .format(full_fpath, json_exc_message)\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir='.'):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir, context)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir,\n                                              os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir, context)\n",
          "file_patch": "@@ -20,7 +20,8 @@ from jinja2.environment import Environment\n from jinja2.exceptions import TemplateSyntaxError\n from binaryornot.check import is_binary\n \n-from .exceptions import NonTemplatedInputDirException\n+from .exceptions import NonTemplatedInputDirException, ContextDecodingException\n+from collections import OrderedDict\n from .find import find_template\n from .utils import make_sure_path_exists, work_in\n from .hooks import run_hook\n@@ -41,7 +42,16 @@ def generate_context(context_file='cookiecutter.json', default_context=None,\n     context = {}\n \n     file_handle = open(context_file)\n-    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n+    try:\n+        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n+    except ValueError as e:\n+        # JSON decoding error.  Let's throw a new exception that is more friendly for the developer\n+        # or user.\n+        full_fpath = os.path.abspath(context_file)\n+        json_exc_message = str(e)\n+        our_exc_message = 'JSON decoding error while loading \"{0}\".  Decoding error details: \"{1}\"'\\\n+                          .format(full_fpath, json_exc_message)\n+        raise ContextDecodingException(our_exc_message)\n \n     # Add the Python object to the context dictionary\n     file_name = os.path.split(context_file)[1]\n",
          "files_name_in_blame_commit": [
            "test_generate_context.py",
            "exceptions.py",
            "generate.py"
          ]
        }
      },
      "aa1e7ebe0b92fbfcaebe4b31bf8dd12ded20e4d2": {
        "commit": {
          "commit_id": "aa1e7ebe0b92fbfcaebe4b31bf8dd12ded20e4d2",
          "commit_message": "Add tox to check the PEP8 + Fix current code PEP8.",
          "commit_author": "R\u00e9my HUBSCHER",
          "commit_date": "2014-10-23 14:08:25",
          "commit_parent": "ef166ace7b9db40032c5233d4c640b127ebfb564"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing any config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 36,
          "function_before_end_line": 66,
          "function_after_start_line": 36,
          "function_after_end_line": 66,
          "function_before_token_count": 99,
          "function_after_token_count": 99,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "parse_cookiecutter_args",
            "render_and_create_dir",
            "read_response",
            "find_template",
            "_get_parser",
            "prompt_and_delete_repo",
            "rmtree",
            "prompt_for_config",
            "find_hooks",
            "ensure_dir_is_templated",
            "_run_hook",
            "main",
            "make_sure_path_exists",
            "generate_context",
            "run_hook",
            "clone",
            "cookiecutter",
            "generate_files",
            "work_in",
            "identify_repo",
            "force_delete",
            "generate_file",
            "query_yes_no"
          ],
          "functions_name_co_evolved_modified_file": [
            "ensure_dir_is_templated",
            "render_and_create_dir",
            "generate_files"
          ],
          "functions_name_co_evolved_all_files": [
            "render_and_create_dir",
            "ensure_dir_is_templated",
            "run_hook",
            "find_template",
            "_get_parser",
            "main",
            "clone",
            "cookiecutter",
            "generate_files"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 105,
          "file_complexity": 15,
          "file_token_count": 681,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport io\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing any config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with io.open(outfile, 'w', encoding=\"utf-8\") as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport io\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with io.open(outfile, 'w', encoding=\"utf-8\") as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n            '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir,\n                                              os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_patch": "@@ -41,7 +41,7 @@ def generate_context(context_file='cookiecutter.json', default_context=None,\n \n     :param context_file: JSON file containing key/value pairs for populating\n         the cookiecutter's variables.\n-    :param default_context: Dictionary containing any config to take into account.\n+    :param default_context: Dictionary containing config to take into account.\n     :param extra_context: Dictionary containing configuration overrides\n     \"\"\"\n \n@@ -127,7 +127,8 @@ def generate_file(project_dir, infile, context, env):\n \n def render_and_create_dir(dirname, context, output_dir):\n     \"\"\"\n-    Renders the name of a directory, creates the directory, and returns its path.\n+    Renders the name of a directory, creates the directory, and\n+    returns its path.\n     \"\"\"\n \n     name_tmpl = Template(dirname)\n@@ -148,7 +149,7 @@ def ensure_dir_is_templated(dirname):\n     Ensures that dirname is a templated directory name.\n     \"\"\"\n     if '{{' in dirname and \\\n-        '}}' in dirname:\n+            '}}' in dirname:\n         return True\n     else:\n         raise NonTemplatedInputDirException\n@@ -191,7 +192,8 @@ def generate_files(repo_dir, context=None, output_dir=\".\"):\n \n         for root, dirs, files in os.walk(\".\"):\n             for d in dirs:\n-                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n+                unrendered_dir = os.path.join(project_dir,\n+                                              os.path.join(root, d))\n                 render_and_create_dir(unrendered_dir, context, output_dir)\n \n             for f in files:\n",
          "files_name_in_blame_commit": [
            "exceptions.py",
            "vcs.py",
            "utils.py",
            "prompt.py",
            "generate.py",
            "hooks.py",
            "find.py",
            "main.py"
          ]
        }
      },
      "8c3ce23eab374ac311a384275edda83ac6c3c4cc": {
        "commit": {
          "commit_id": "8c3ce23eab374ac311a384275edda83ac6c3c4cc",
          "commit_message": "Add extra_context parameter and apply override",
          "commit_author": "Michael Joseph",
          "commit_date": "2014-08-28 22:31:04",
          "commit_parent": "a944be327e0523e434be012d70c6ce9b45fe331a"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing any config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 36,
          "function_before_end_line": 62,
          "function_after_start_line": 36,
          "function_after_end_line": 66,
          "function_before_token_count": 86,
          "function_after_token_count": 99,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "parse_cookiecutter_args",
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "_get_parser",
            "main",
            "generate_file",
            "cookiecutter",
            "generate_files"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "cookiecutter"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 104,
          "file_complexity": 15,
          "file_token_count": 678,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport io\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with io.open(outfile, 'w', encoding=\"utf-8\") as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport io\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing any config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n    if extra_context:\n        obj.update(extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with io.open(outfile, 'w', encoding=\"utf-8\") as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_patch": "@@ -33,14 +33,16 @@ else:\n     from collections import OrderedDict\n \n \n-def generate_context(context_file='cookiecutter.json', default_context=None):\n+def generate_context(context_file='cookiecutter.json', default_context=None,\n+                     extra_context=None):\n     \"\"\"\n     Generates the context for a Cookiecutter project template.\n     Loads the JSON file as a Python object, with key being the JSON filename.\n \n     :param context_file: JSON file containing key/value pairs for populating\n         the cookiecutter's variables.\n-    :param config_dict: Dict containing any config to take into account.\n+    :param default_context: Dictionary containing any config to take into account.\n+    :param extra_context: Dictionary containing configuration overrides\n     \"\"\"\n \n     context = {}\n@@ -57,6 +59,8 @@ def generate_context(context_file='cookiecutter.json', default_context=None):\n     # user's global config, if available\n     if default_context:\n         obj.update(default_context)\n+    if extra_context:\n+        obj.update(extra_context)\n \n     logging.debug('Context generated is {0}'.format(context))\n     return context\n",
          "files_name_in_blame_commit": [
            "main.py",
            "generate.py"
          ]
        }
      },
      "6085037f61efc158d75c2c5975d7ec6ac58fe91d": {
        "commit": {
          "commit_id": "6085037f61efc158d75c2c5975d7ec6ac58fe91d",
          "commit_message": "Do not provide an unneeded/invalid encoding argument to json.load",
          "commit_author": "Paul Moore",
          "commit_date": "2014-07-26 20:20:58",
          "commit_parent": "b88085a9bf7745f45f78e7bd5f6d064d232e0ce2"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 35,
          "function_before_end_line": 61,
          "function_after_start_line": 35,
          "function_after_end_line": 61,
          "function_before_token_count": 90,
          "function_after_token_count": 86,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 100,
          "file_complexity": 14,
          "file_token_count": 659,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with unicode_open(outfile, 'w') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with unicode_open(outfile, 'w') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_patch": "@@ -45,7 +45,7 @@ def generate_context(context_file='cookiecutter.json', default_context=None):\n     context = {}\n \n     file_handle = open(context_file)\n-    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n+    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n \n     # Add the Python object to the context dictionary\n     file_name = os.path.split(context_file)[1]\n",
          "files_name_in_blame_commit": [
            "generate.py"
          ]
        }
      },
      "87bf3549f260da72e7eb06c7091dbf639dbcd329": {
        "commit": {
          "commit_id": "87bf3549f260da72e7eb06c7091dbf639dbcd329",
          "commit_message": "Add docstrings to document generate_file's precondition and params. Fix other docstrings in generate too.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-09-11 23:35:43",
          "commit_parent": "6e2bd2df1a9b48d01e7d4177bb01fd60804c037e"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing project config values.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 35,
          "function_before_end_line": 60,
          "function_after_start_line": 35,
          "function_after_end_line": 61,
          "function_before_token_count": 90,
          "function_after_token_count": 90,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_co_evolved_modified_file": [
            "generate_file",
            "generate_files"
          ],
          "functions_name_co_evolved_all_files": [
            "generate_file",
            "generate_files"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 100,
          "file_complexity": 14,
          "file_token_count": 663,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing project config values.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the contents of infile.\n    2. Render the filename of infile as the name of outfile.\n    3. Write the rendered infile to outfile.\n    :param infile: Input file to generate the file from.\n    \"\"\"\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with unicode_open(outfile, 'w') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the \n           rendered infile to outfile.\n\n    .. precondition::\n    \n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug(\"Writing {0}\".format(outfile))\n\n        with unicode_open(outfile, 'w') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_patch": "@@ -37,7 +37,8 @@ def generate_context(context_file='cookiecutter.json', default_context=None):\n     Generates the context for a Cookiecutter project template.\n     Loads the JSON file as a Python object, with key being the JSON filename.\n \n-    :param context_file: JSON file containing project config values.\n+    :param context_file: JSON file containing key/value pairs for populating\n+        the cookiecutter's variables.\n     :param config_dict: Dict containing any config to take into account.\n     \"\"\"\n \n@@ -62,11 +63,26 @@ def generate_context(context_file='cookiecutter.json', default_context=None):\n \n def generate_file(project_dir, infile, context, env):\n     \"\"\"\n-    1. Render the contents of infile.\n-    2. Render the filename of infile as the name of outfile.\n-    3. Write the rendered infile to outfile.\n-    :param infile: Input file to generate the file from.\n+    1. Render the filename of infile as the name of outfile.\n+    2. Deal with infile appropriately:\n+\n+        a. If infile is a binary file, copy it over without rendering.\n+        b. If infile is a text file, render its contents and write the \n+           rendered infile to outfile.\n+\n+    .. precondition::\n+    \n+        When calling `generate_file()`, the root template dir must be the\n+        current working directory. Using `utils.work_in()` is the recommended\n+        way to perform this directory change.\n+\n+    :param project_dir: Absolute path to the resulting generated project.\n+    :param infile: Input file to generate the file from. Relative to the root\n+        template dir.\n+    :param context: Dict for populating the cookiecutter's variables.\n+    :param env: Jinja2 template execution environment.\n     \"\"\"\n+\n     logging.debug(\"Generating file {0}\".format(infile))\n \n     # Render the path to the output file (not including the root project dir)\n@@ -136,8 +152,9 @@ def ensure_dir_is_templated(dirname):\n def generate_files(repo_dir, context=None, output_dir=\".\"):\n     \"\"\"\n     Renders the templates and saves them to files.\n-    :param input_dir: Project template input directory.\n-    :paramtype input_dir: directory\n+\n+    :param repo_dir: Project template input directory.\n+    :param context: Dict for populating the template's variables.\n     :param output_dir: Where to output the generated project dir into.\n     \"\"\"\n \n",
          "files_name_in_blame_commit": [
            "generate.py"
          ]
        }
      },
      "e95eb56800cd167352259388578a6ba20304e0d1": {
        "commit": {
          "commit_id": "e95eb56800cd167352259388578a6ba20304e0d1",
          "commit_message": "Pass generate_context() just the default_context, rather than the entire config_dict. Makes it more modular.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-09-07 14:01:33",
          "commit_parent": "4a7cf8cc756f8fde4ad777f406ee4027bffc5b4a"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json', config_dict=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing project config values.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if config_dict:\n        obj.update(config_dict['default_context'])\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing project config values.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    if default_context:\n        obj.update(default_context)\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 35,
          "function_before_end_line": 60,
          "function_after_start_line": 35,
          "function_after_end_line": 60,
          "function_before_token_count": 93,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "parse_cookiecutter_args",
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "main",
            "generate_file",
            "cookiecutter",
            "generate_files"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "cookiecutter"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 103,
          "file_complexity": 14,
          "file_token_count": 692,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', config_dict=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing project config values.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if config_dict:\n        obj.update(config_dict['default_context'])\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the contents of infile.\n    2. Render the filename of infile as the name of outfile.\n    3. Write the rendered infile to outfile.\n    :param infile: Input file to generate the file from.\n    \"\"\"\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the intermediary path to the output file (not including the root\n    # project dir nor the filename itself)\n    outdir_tmpl = Template(os.path.dirname(infile))\n    outdir = outdir_tmpl.render(**context)\n\n    # Write the file to the corresponding place\n    fname = os.path.basename(infile)  # input/output filename\n    outfile = os.path.join(project_dir, outdir, fname)\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Render the output filename before writing\n        name_tmpl = Template(outfile)\n        rendered_name = name_tmpl.render(**context)\n        logging.debug(\"Writing {0}\".format(rendered_name))\n\n        with unicode_open(rendered_name, 'w') as fh:\n            fh.write(rendered_file)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json', default_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing project config values.\n    :param config_dict: Dict containing any config to take into account.\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        obj.update(default_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the contents of infile.\n    2. Render the filename of infile as the name of outfile.\n    3. Write the rendered infile to outfile.\n    :param infile: Input file to generate the file from.\n    \"\"\"\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the intermediary path to the output file (not including the root\n    # project dir nor the filename itself)\n    outdir_tmpl = Template(os.path.dirname(infile))\n    outdir = outdir_tmpl.render(**context)\n\n    # Write the file to the corresponding place\n    fname = os.path.basename(infile)  # input/output filename\n    outfile = os.path.join(project_dir, outdir, fname)\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Render the output filename before writing\n        name_tmpl = Template(outfile)\n        rendered_name = name_tmpl.render(**context)\n        logging.debug(\"Writing {0}\".format(rendered_name))\n\n        with unicode_open(rendered_name, 'w') as fh:\n            fh.write(rendered_file)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_patch": "@@ -32,7 +32,7 @@ else:\n     from collections import OrderedDict\n \n \n-def generate_context(context_file='cookiecutter.json', config_dict=None):\n+def generate_context(context_file='cookiecutter.json', default_context=None):\n     \"\"\"\n     Generates the context for a Cookiecutter project template.\n     Loads the JSON file as a Python object, with key being the JSON filename.\n@@ -53,8 +53,8 @@ def generate_context(context_file='cookiecutter.json', config_dict=None):\n \n     # Overwrite context variable defaults with the default context from the\n     # user's global config, if available\n-    if config_dict:\n-        obj.update(config_dict['default_context'])\n+    if default_context:\n+        obj.update(default_context)\n \n     logging.debug('Context generated is {0}'.format(context))\n     return context\n",
          "files_name_in_blame_commit": [
            "main.py",
            "generate.py"
          ]
        }
      },
      "c5b51a6d78d71e35f1fec9223064e691fd30c591": {
        "commit": {
          "commit_id": "c5b51a6d78d71e35f1fec9223064e691fd30c591",
          "commit_message": "Prevent user's config file from overwriting context in tests.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-09-07 13:24:17",
          "commit_parent": "765c4d1db199cfa469babf873788fbd2ff3db1be"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(context_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    conf = get_user_config()\n    if conf:\n        obj.update(conf['default_context'])\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 35,
          "function_before_end_line": 55,
          "function_after_start_line": 36,
          "function_after_end_line": 62,
          "function_before_token_count": 77,
          "function_after_token_count": 94,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "tearDown",
            "render_and_create_dir",
            "test_generate_files_binaries",
            "test_get_config_does_not_exist",
            "test_generate_files_output_dir",
            "test_ignore_hooks_dirs",
            "test_run_python_hooks",
            "test_get_user_config_nonexistent",
            "test_invalid_config",
            "test_run_shell_hooks",
            "test_generate_files_absolute_path",
            "ensure_dir_is_templated",
            "test_get_config",
            "generate_context",
            "test_generate_file_verbose_template_syntax_error",
            "test_generate_context",
            "test_get_user_config_invalid",
            "test_output_folder",
            "test_run_python_hooks_cwd",
            "test_generate_files_nontemplated_exception",
            "generate_files",
            "test_generate_files",
            "setUp",
            "test_get_user_config_valid",
            "generate_file",
            "test_generate_file"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "tearDown",
            "setUp"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 105,
          "file_complexity": 14,
          "file_token_count": 701,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the contents of infile.\n    2. Render the filename of infile as the name of outfile.\n    3. Write the rendered infile to outfile.\n    :param infile: Input file to generate the file from.\n    \"\"\"\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the intermediary path to the output file (not including the root\n    # project dir nor the filename itself)\n    outdir_tmpl = Template(os.path.dirname(infile))\n    outdir = outdir_tmpl.render(**context)\n\n    # Write the file to the corresponding place\n    fname = os.path.basename(infile)  # input/output filename\n    outfile = os.path.join(project_dir, outdir, fname)\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Render the output filename before writing\n        name_tmpl = Template(outfile)\n        rendered_name = name_tmpl.render(**context)\n        logging.debug(\"Writing {0}\".format(rendered_name))\n\n        with unicode_open(rendered_name, 'w') as fh:\n            fh.write(rendered_file)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .config import get_user_config\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    conf = get_user_config()\n    if conf:\n        obj.update(conf['default_context'])\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the contents of infile.\n    2. Render the filename of infile as the name of outfile.\n    3. Write the rendered infile to outfile.\n    :param infile: Input file to generate the file from.\n    \"\"\"\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the intermediary path to the output file (not including the root\n    # project dir nor the filename itself)\n    outdir_tmpl = Template(os.path.dirname(infile))\n    outdir = outdir_tmpl.render(**context)\n\n    # Write the file to the corresponding place\n    fname = os.path.basename(infile)  # input/output filename\n    outfile = os.path.join(project_dir, outdir, fname)\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Render the output filename before writing\n        name_tmpl = Template(outfile)\n        rendered_name = name_tmpl.render(**context)\n        logging.debug(\"Writing {0}\".format(rendered_name))\n\n        with unicode_open(rendered_name, 'w') as fh:\n            fh.write(rendered_file)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_patch": "@@ -18,6 +18,7 @@ from jinja2.environment import Environment\n from jinja2.exceptions import TemplateSyntaxError\n from binaryornot.check import is_binary\n \n+from .config import get_user_config\n from .exceptions import NonTemplatedInputDirException\n from .find import find_template\n from .utils import make_sure_path_exists, unicode_open, work_in\n@@ -51,6 +52,12 @@ def generate_context(context_file='cookiecutter.json'):\n     file_stem = file_name.split('.')[0]\n     context[file_stem] = obj\n \n+    # Overwrite context variable defaults with the default context from the\n+    # user's global config, if available\n+    conf = get_user_config()\n+    if conf:\n+        obj.update(conf['default_context'])\n+\n     logging.debug('Context generated is {0}'.format(context))\n     return context\n \n",
          "files_name_in_blame_commit": [
            "test_generate.py",
            "test_config.py",
            "generate.py"
          ]
        }
      },
      "765c4d1db199cfa469babf873788fbd2ff3db1be": {
        "commit": {
          "commit_id": "765c4d1db199cfa469babf873788fbd2ff3db1be",
          "commit_message": "Refer to cookiecutter.json as context_file instead of config_file.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-09-07 13:13:09",
          "commit_parent": "d596ecf1c8b9e7550c2216403f501ede972ee312"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(context_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 35,
          "function_before_end_line": 55,
          "function_after_start_line": 35,
          "function_after_end_line": 55,
          "function_before_token_count": 77,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "render_and_create_dir",
            "generate_context",
            "ensure_dir_is_templated",
            "generate_file",
            "generate_files"
          ],
          "functions_name_all_files": [
            "parse_cookiecutter_args",
            "render_and_create_dir",
            "tearDown",
            "test_generate_files_binaries",
            "test_generate_files_output_dir",
            "test_ignore_hooks_dirs",
            "test_run_python_hooks",
            "test_run_shell_hooks",
            "test_generate_files_absolute_path",
            "ensure_dir_is_templated",
            "main",
            "generate_context",
            "test_generate_file_verbose_template_syntax_error",
            "test_generate_context",
            "test_output_folder",
            "test_run_python_hooks_cwd",
            "test_generate_files_nontemplated_exception",
            "cookiecutter",
            "generate_files",
            "test_generate_files",
            "generate_file",
            "test_generate_file"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_generate_context",
            "cookiecutter",
            "test_output_folder"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 101,
          "file_complexity": 13,
          "file_token_count": 679,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the contents of infile.\n    2. Render the filename of infile as the name of outfile.\n    3. Write the rendered infile to outfile.\n    :param infile: Input file to generate the file from.\n    \"\"\"\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the intermediary path to the output file (not including the root\n    # project dir nor the filename itself)\n    outdir_tmpl = Template(os.path.dirname(infile))\n    outdir = outdir_tmpl.render(**context)\n\n    # Write the file to the corresponding place\n    fname = os.path.basename(infile)  # input/output filename\n    outfile = os.path.join(project_dir, outdir, fname)\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Render the output filename before writing\n        name_tmpl = Template(outfile)\n        rendered_name = name_tmpl.render(**context)\n        logging.debug(\"Writing {0}\".format(rendered_name))\n\n        with unicode_open(rendered_name, 'w') as fh:\n            fh.write(rendered_file)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .find import find_template\nfrom .utils import make_sure_path_exists, unicode_open, work_in\nfrom .hooks import run_hook\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(context_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the contents of infile.\n    2. Render the filename of infile as the name of outfile.\n    3. Write the rendered infile to outfile.\n    :param infile: Input file to generate the file from.\n    \"\"\"\n    logging.debug(\"Generating file {0}\".format(infile))\n\n    # Render the intermediary path to the output file (not including the root\n    # project dir nor the filename itself)\n    outdir_tmpl = Template(os.path.dirname(infile))\n    outdir = outdir_tmpl.render(**context)\n\n    # Write the file to the corresponding place\n    fname = os.path.basename(infile)  # input/output filename\n    outfile = os.path.join(project_dir, outdir, fname)\n    logging.debug(\"outfile is {0}\".format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug(\"Copying binary {0} to {1} without rendering\"\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Render the output filename before writing\n        name_tmpl = Template(outfile)\n        rendered_name = name_tmpl.render(**context)\n        logging.debug(\"Writing {0}\".format(rendered_name))\n\n        with unicode_open(rendered_name, 'w') as fh:\n            fh.write(rendered_file)\n\n\ndef render_and_create_dir(dirname, context, output_dir):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create\n\n\ndef ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and \\\n        '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException\n\n\ndef generate_files(repo_dir, context=None, output_dir=\".\"):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir, context, output_dir)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to \".\"\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug(\"project_dir is {0}\".format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('pre_gen_project', project_dir)\n\n    with work_in(template_dir):\n        env = Environment()\n        env.loader = FileSystemLoader(\".\")\n\n        for root, dirs, files in os.walk(\".\"):\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, os.path.join(root, d))\n                render_and_create_dir(unrendered_dir, context, output_dir)\n\n            for f in files:\n                infile = os.path.join(root, f)\n                logging.debug(\"f is {0}\".format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir)\n",
          "file_patch": "@@ -32,7 +32,7 @@ else:\n     from collections import OrderedDict\n \n \n-def generate_context(config_file='cookiecutter.json'):\n+def generate_context(context_file='cookiecutter.json'):\n     \"\"\"\n     Generates the context for a Cookiecutter project template.\n     Loads the JSON file as a Python object, with key being the JSON filename.\n@@ -43,11 +43,11 @@ def generate_context(config_file='cookiecutter.json'):\n \n     context = {}\n \n-    file_handle = open(config_file)\n+    file_handle = open(context_file)\n     obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n \n     # Add the Python object to the context dictionary\n-    file_name = os.path.split(config_file)[1]\n+    file_name = os.path.split(context_file)[1]\n     file_stem = file_name.split('.')[0]\n     context[file_stem] = obj\n \n",
          "files_name_in_blame_commit": [
            "test_generate.py",
            "main.py",
            "generate.py"
          ]
        }
      },
      "01bb77d4d812a325969a9845696ebc2b5e2e9d87": {
        "commit": {
          "commit_id": "01bb77d4d812a325969a9845696ebc2b5e2e9d87",
          "commit_message": "json.loads with utf-8 encoding.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-08-19 00:57:10",
          "commit_parent": "2dbf0c797473346ef5eeb79ce4cfc13609adec59"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = unicode(obj, 'utf-8')\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 32,
          "function_before_end_line": 52,
          "function_after_start_line": 32,
          "function_after_end_line": 52,
          "function_before_token_count": 78,
          "function_after_token_count": 77,
          "functions_name_modified_file": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_all_files": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 69,
          "file_complexity": 8,
          "file_token_count": 456,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = unicode(obj, 'utf-8')\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    # Always use utf-8\n    template_dir = template_dir\n\n    logging.debug('Generating project from {0}...'.format(template_dir))\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    logging.debug(\"output_dir is {0}\".format(output_dir))\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            logging.debug(\"f is {0}\".format(f))\n            infile = os.path.join(root, f)\n            logging.debug(\"infile is {0}\".format(infile))\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n            logging.debug(\"outfile is {0}\".format(outfile))\n\n            # Just copy over binary files. Don't render.\n            logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n            if is_binary(infile):\n                logging.debug(\"Copying binary {0} to {1} without rendering\"\n                              .format(infile, outfile))\n                shutil.copyfile(infile, outfile)\n\n            else:\n\n                # Render the file\n                tmpl = env.get_template(infile)\n                rendered_file = tmpl.render(**context)\n\n                # Render the output filename before writing\n                name_tmpl = Template(outfile)\n                rendered_name = name_tmpl.render(**context)\n                logging.debug(\"Writing {0}\".format(rendered_name))\n\n                with unicode_open(rendered_name, 'w') as fh:\n                    fh.write(rendered_file)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    # Always use utf-8\n    template_dir = template_dir\n\n    logging.debug('Generating project from {0}...'.format(template_dir))\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    logging.debug(\"output_dir is {0}\".format(output_dir))\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            logging.debug(\"f is {0}\".format(f))\n            infile = os.path.join(root, f)\n            logging.debug(\"infile is {0}\".format(infile))\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n            logging.debug(\"outfile is {0}\".format(outfile))\n\n            # Just copy over binary files. Don't render.\n            logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n            if is_binary(infile):\n                logging.debug(\"Copying binary {0} to {1} without rendering\"\n                              .format(infile, outfile))\n                shutil.copyfile(infile, outfile)\n\n            else:\n\n                # Render the file\n                tmpl = env.get_template(infile)\n                rendered_file = tmpl.render(**context)\n\n                # Render the output filename before writing\n                name_tmpl = Template(outfile)\n                rendered_name = name_tmpl.render(**context)\n                logging.debug(\"Writing {0}\".format(rendered_name))\n\n                with unicode_open(rendered_name, 'w') as fh:\n                    fh.write(rendered_file)\n",
          "file_patch": "@@ -41,12 +41,12 @@ def generate_context(config_file='cookiecutter.json'):\n     context = {}\n \n     file_handle = open(config_file)\n-    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n+    obj = json.load(file_handle, encoding='utf-8', object_pairs_hook=OrderedDict)\n \n     # Add the Python object to the context dictionary\n     file_name = os.path.split(config_file)[1]\n     file_stem = file_name.split('.')[0]\n-    context[file_stem] = unicode(obj, 'utf-8')\n+    context[file_stem] = obj\n \n     logging.debug('Context generated is {0}'.format(context))\n     return context\n",
          "files_name_in_blame_commit": [
            "generate.py"
          ]
        }
      },
      "2dbf0c797473346ef5eeb79ce4cfc13609adec59": {
        "commit": {
          "commit_id": "2dbf0c797473346ef5eeb79ce4cfc13609adec59",
          "commit_message": "Test passes, but still not fully working.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-08-19 00:49:11",
          "commit_parent": "b269b022b039ba920f3a4cc6171a1e1e923ce1c8"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict, ensure_ascii=False)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0].encode('utf-8')\n    context[file_stem] = obj.encode('utf-8')\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = unicode(obj, 'utf-8')\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 32,
          "function_before_end_line": 52,
          "function_after_start_line": 32,
          "function_after_end_line": 52,
          "function_before_token_count": 87,
          "function_after_token_count": 78,
          "functions_name_modified_file": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_all_files": [
            "tearDown",
            "test_generate_files_binaries",
            "generate_context",
            "test_output_folder",
            "test_generate_files_bad",
            "generate_files",
            "test_generate_files",
            "test_generate_context"
          ],
          "functions_name_co_evolved_modified_file": [
            "generate_files"
          ],
          "functions_name_co_evolved_all_files": [
            "tearDown",
            "test_generate_files",
            "generate_files"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 69,
          "file_complexity": 8,
          "file_token_count": 457,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict, ensure_ascii=False)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0].encode('utf-8')\n    context[file_stem] = obj.encode('utf-8')\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    # Always use utf-8\n    template_dir = template_dir.encode('utf-8')\n\n    #logging.debug('Generating project from {0}...'.format(template_dir))\n    print(type(template_dir))\n    logging.debug('Generating project from ' + template_dir)\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    logging.debug(\"output_dir is {0}\".format(output_dir))\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            logging.debug(\"f is {0}\".format(f))\n            infile = os.path.join(root, f)\n            logging.debug(\"infile is {0}\".format(infile))\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n            logging.debug(\"outfile is {0}\".format(outfile))\n\n            # Just copy over binary files. Don't render.\n            logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n            if is_binary(infile):\n                logging.debug(\"Copying binary {0} to {1} without rendering\"\n                              .format(infile, outfile))\n                shutil.copyfile(infile, outfile)\n\n            else:\n\n                # Render the file\n                tmpl = env.get_template(infile)\n                rendered_file = tmpl.render(**context)\n\n                # Render the output filename before writing\n                name_tmpl = Template(outfile)\n                rendered_name = name_tmpl.render(**context)\n                logging.debug(\"Writing {0}\".format(rendered_name))\n\n                with unicode_open(rendered_name, 'w') as fh:\n                    fh.write(rendered_file)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\nfrom __future__ import unicode_literals\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\nfrom binaryornot.check import is_binary\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\nif sys.version_info[:2] < (2, 7):\n    import simplejson as json\n    from ordereddict import OrderedDict\nelse:\n    import json\n    from collections import OrderedDict\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = unicode(obj, 'utf-8')\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    # Always use utf-8\n    template_dir = template_dir\n\n    logging.debug('Generating project from {0}...'.format(template_dir))\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    logging.debug(\"output_dir is {0}\".format(output_dir))\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            logging.debug(\"f is {0}\".format(f))\n            infile = os.path.join(root, f)\n            logging.debug(\"infile is {0}\".format(infile))\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n            logging.debug(\"outfile is {0}\".format(outfile))\n\n            # Just copy over binary files. Don't render.\n            logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n            if is_binary(infile):\n                logging.debug(\"Copying binary {0} to {1} without rendering\"\n                              .format(infile, outfile))\n                shutil.copyfile(infile, outfile)\n\n            else:\n\n                # Render the file\n                tmpl = env.get_template(infile)\n                rendered_file = tmpl.render(**context)\n\n                # Render the output filename before writing\n                name_tmpl = Template(outfile)\n                rendered_name = name_tmpl.render(**context)\n                logging.debug(\"Writing {0}\".format(rendered_name))\n\n                with unicode_open(rendered_name, 'w') as fh:\n                    fh.write(rendered_file)\n",
          "file_patch": "@@ -41,12 +41,12 @@ def generate_context(config_file='cookiecutter.json'):\n     context = {}\n \n     file_handle = open(config_file)\n-    obj = json.load(file_handle, object_pairs_hook=OrderedDict, ensure_ascii=False)\n+    obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n \n     # Add the Python object to the context dictionary\n     file_name = os.path.split(config_file)[1]\n-    file_stem = file_name.split('.')[0].encode('utf-8')\n-    context[file_stem] = obj.encode('utf-8')\n+    file_stem = file_name.split('.')[0]\n+    context[file_stem] = unicode(obj, 'utf-8')\n \n     logging.debug('Context generated is {0}'.format(context))\n     return context\n@@ -60,11 +60,9 @@ def generate_files(template_dir, context=None):\n     \"\"\"\n     \n     # Always use utf-8\n-    template_dir = template_dir.encode('utf-8')\n+    template_dir = template_dir\n \n-    #logging.debug('Generating project from {0}...'.format(template_dir))\n-    print(type(template_dir))\n-    logging.debug('Generating project from ' + template_dir)\n+    logging.debug('Generating project from {0}...'.format(template_dir))\n \n     context = context or {}\n     env = Environment()\n",
          "files_name_in_blame_commit": [
            "test_generate.py",
            "generate.py"
          ]
        }
      },
      "1b6b483d2658217764f61d892ba23fe05445a464": {
        "commit": {
          "commit_id": "1b6b483d2658217764f61d892ba23fe05445a464",
          "commit_message": "Change logging.info statements to logging.debug.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-08-08 11:07:54",
          "commit_parent": "5cccc1e227b512824c7bfc2c5a5baf36a46cbf33"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    logging.info('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 22,
          "function_before_end_line": 42,
          "function_after_start_line": 22,
          "function_after_end_line": 42,
          "function_before_token_count": 69,
          "function_after_token_count": 69,
          "functions_name_modified_file": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_all_files": [
            "find_template",
            "main",
            "cookiecutter",
            "generate_context",
            "remove_repo",
            "generate_files"
          ],
          "functions_name_co_evolved_modified_file": [
            "generate_files"
          ],
          "functions_name_co_evolved_all_files": [
            "remove_repo",
            "cookiecutter",
            "generate_files",
            "find_template"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 49,
          "file_complexity": 7,
          "file_token_count": 318,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\n\nimport json\nimport logging\nimport os\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    logging.info('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    logging.info('Generating project from {0}...'.format(template_dir))\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            # Render the file\n            infile = os.path.join(root, f)\n            tmpl = env.get_template(infile)\n            rendered_file = tmpl.render(**context)\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n\n            # Render the output filename before writing\n            name_tmpl = Template(outfile)\n            rendered_name = name_tmpl.render(**context)\n            logging.info(\"Writing {0}\".format(rendered_name))\n\n            with unicode_open(rendered_name, 'w') as fh:\n                fh.write(rendered_file)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\n\nimport json\nimport logging\nimport os\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    logging.debug('Generating project from {0}...'.format(template_dir))\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            # Render the file\n            infile = os.path.join(root, f)\n            tmpl = env.get_template(infile)\n            rendered_file = tmpl.render(**context)\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n\n            # Render the output filename before writing\n            name_tmpl = Template(outfile)\n            rendered_name = name_tmpl.render(**context)\n            logging.debug(\"Writing {0}\".format(rendered_name))\n\n            with unicode_open(rendered_name, 'w') as fh:\n                fh.write(rendered_file)\n",
          "file_patch": "@@ -38,7 +38,7 @@ def generate_context(config_file='cookiecutter.json'):\n     file_stem = file_name.split('.')[0]\n     context[file_stem] = obj\n \n-    logging.info('Context generated is {0}'.format(context))\n+    logging.debug('Context generated is {0}'.format(context))\n     return context\n \n \n@@ -49,7 +49,7 @@ def generate_files(template_dir, context=None):\n     :paramtype input_dir: directory\n     \"\"\"\n     \n-    logging.info('Generating project from {0}...'.format(template_dir))\n+    logging.debug('Generating project from {0}...'.format(template_dir))\n \n     context = context or {}\n     env = Environment()\n@@ -86,7 +86,7 @@ def generate_files(template_dir, context=None):\n             # Render the output filename before writing\n             name_tmpl = Template(outfile)\n             rendered_name = name_tmpl.render(**context)\n-            logging.info(\"Writing {0}\".format(rendered_name))\n+            logging.debug(\"Writing {0}\".format(rendered_name))\n \n             with unicode_open(rendered_name, 'w') as fh:\n                 fh.write(rendered_file)\n",
          "files_name_in_blame_commit": [
            "find.py",
            "cleanup.py",
            "main.py",
            "generate.py"
          ]
        }
      },
      "ed1f47b6c4b7e35069bc66bfe30c9e6b28cd2464": {
        "commit": {
          "commit_id": "ed1f47b6c4b7e35069bc66bfe30c9e6b28cd2464",
          "commit_message": "Generate context from cookiecutter.json instead of json/",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-08-07 17:32:44",
          "commit_parent": "27e193dc40793968a65c87e7f500ad0c576cf8d6"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    :param json_dir: Directory containing .json file(s).\n    :paramtype json_dir: directory\n\n    Description:\n\n        Iterates through the contents of json_dir and finds all JSON\n        files. Loads the JSON file as a Python object with the key being the\n        JSON file name..\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n    for file_name in os.listdir(json_dir):\n        file_to_open = '{0}/{1}'.format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n        context[file_name[:-5]] = obj\n    logging.info('Context generated is {0}'.format(context))\n    return context",
          "function_code_after": "def generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n    context = {}\n    file_handle = open(config_file)\n    obj = json.load(file_handle)\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n    logging.info('Context generated is {0}'.format(context))\n    return context",
          "function_before_start_line": 22,
          "function_before_end_line": 60,
          "function_after_start_line": 22,
          "function_after_end_line": 42,
          "function_before_token_count": 70,
          "function_after_token_count": 69,
          "functions_name_modified_file": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_all_files": [
            "tearDown",
            "generate_context",
            "test_output_folder",
            "test_generate_files_bad",
            "generate_files",
            "test_generate_files",
            "test_generate_context"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_generate_context",
            "test_output_folder"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 49,
          "file_complexity": 7,
          "file_token_count": 318,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\n\nimport json\nimport logging\nimport os\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\ndef generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    :param json_dir: Directory containing .json file(s).\n    :paramtype json_dir: directory\n\n    Description:\n\n        Iterates through the contents of json_dir and finds all JSON\n        files. Loads the JSON file as a Python object with the key being the\n        JSON file name..\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n\n    for file_name in os.listdir(json_dir):\n        file_to_open = \"{0}/{1}\".format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n\n        # Add the Python object to the context dictionary\n        context[file_name[:-5]] = obj\n\n    logging.info('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    logging.info('Generating project from {0}...'.format(template_dir))\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            # Render the file\n            infile = os.path.join(root, f)\n            tmpl = env.get_template(infile)\n            rendered_file = tmpl.render(**context)\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n\n            # Render the output filename before writing\n            name_tmpl = Template(outfile)\n            rendered_name = name_tmpl.render(**context)\n            logging.info(\"Writing {0}\".format(rendered_name))\n\n            with unicode_open(rendered_name, 'w') as fh:\n                fh.write(rendered_file)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ncookiecutter.generate\n---------------------\n\nFunctions for generating a project from a project template.\n\"\"\"\n\nimport json\nimport logging\nimport os\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\ndef generate_context(config_file='cookiecutter.json'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param config_file: JSON file containing project config values.\n    :paramtype config_file: filename\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(config_file)\n    obj = json.load(file_handle)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(config_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    logging.info('Context generated is {0}'.format(context))\n    return context\n\n\ndef generate_files(template_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n    \n    logging.info('Generating project from {0}...'.format(template_dir))\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(template_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == template_dir:\n        raise NonTemplatedInputDirException\n\n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(template_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(template_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            # Render the file\n            infile = os.path.join(root, f)\n            tmpl = env.get_template(infile)\n            rendered_file = tmpl.render(**context)\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(template_dir, output_dir, 1)\n\n            # Render the output filename before writing\n            name_tmpl = Template(outfile)\n            rendered_name = name_tmpl.render(**context)\n            logging.info(\"Writing {0}\".format(rendered_name))\n\n            with unicode_open(rendered_name, 'w') as fh:\n                fh.write(rendered_file)\n",
          "file_patch": "@@ -19,42 +19,24 @@ from .exceptions import NonTemplatedInputDirException\n from .utils import make_sure_path_exists, unicode_open\n \n \n-def generate_context(json_dir='json/'):\n+def generate_context(config_file='cookiecutter.json'):\n     \"\"\"\n     Generates the context for a Cookiecutter project template.\n-    :param json_dir: Directory containing .json file(s).\n-    :paramtype json_dir: directory\n+    Loads the JSON file as a Python object, with key being the JSON filename.\n \n-    Description:\n-\n-        Iterates through the contents of json_dir and finds all JSON\n-        files. Loads the JSON file as a Python object with the key being the\n-        JSON file name..\n-\n-    Example:\n-\n-        Assume the following files exist:\n-\n-            json/names.json\n-            json/numbers.json\n-\n-        Depending on their content, might generate a context as follows:\n-\n-        contexts = {\"names\":\n-                        ['Audrey', 'Danny']\n-                    \"numbers\":\n-                        [1, 2, 3, 4]\n-                    }\n+    :param config_file: JSON file containing project config values.\n+    :paramtype config_file: filename\n     \"\"\"\n+\n     context = {}\n \n-    for file_name in os.listdir(json_dir):\n-        file_to_open = \"{0}/{1}\".format(json_dir, file_name)\n-        file_handle = open(file_to_open)\n-        obj = json.load(file_handle)\n+    file_handle = open(config_file)\n+    obj = json.load(file_handle)\n \n-        # Add the Python object to the context dictionary\n-        context[file_name[:-5]] = obj\n+    # Add the Python object to the context dictionary\n+    file_name = os.path.split(config_file)[1]\n+    file_stem = file_name.split('.')[0]\n+    context[file_stem] = obj\n \n     logging.info('Context generated is {0}'.format(context))\n     return context\n",
          "files_name_in_blame_commit": [
            "test_generate.py",
            "generate.py"
          ]
        }
      },
      "0bbce99096a790f096f9a77c52760c3189620c9c": {
        "commit": {
          "commit_id": "0bbce99096a790f096f9a77c52760c3189620c9c",
          "commit_message": "Docstring fixes.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-07-22 10:28:34",
          "commit_parent": "5a58891bfd847f416e27879cfccd79fb213ae05c"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "def generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for all complexity pages.\n\n    Description:\n\n        Iterates through the contents of the input_dir and finds all JSON\n        files.\n        Loads the JSON file as a Python object with the key being the JSON\n        filename.\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n    for file_name in os.listdir(json_dir):\n        file_to_open = '{0}/{1}'.format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n        context[file_name[:-5]] = obj\n    return context",
          "function_code_after": "def generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    :param json_dir: Directory containing .json file(s).\n    :paramtype json_dir: directory\n\n    Description:\n\n        Iterates through the contents of json_dir and finds all JSON\n        files. Loads the JSON file as a Python object with the key being the\n        JSON file name..\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n    for file_name in os.listdir(json_dir):\n        file_to_open = '{0}/{1}'.format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n        context[file_name[:-5]] = obj\n    return context",
          "function_before_start_line": 13,
          "function_before_end_line": 49,
          "function_after_start_line": 13,
          "function_after_end_line": 50,
          "function_before_token_count": 59,
          "function_after_token_count": 59,
          "functions_name_modified_file": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_all_files": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_co_evolved_modified_file": [
            "generate_files"
          ],
          "functions_name_co_evolved_all_files": [
            "generate_files"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 40,
          "file_complexity": 8,
          "file_token_count": 292,
          "file_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport json\nimport os\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\ndef generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for all complexity pages.\n\n    Description:\n\n        Iterates through the contents of the input_dir and finds all JSON\n        files.\n        Loads the JSON file as a Python object with the key being the JSON\n        filename.\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n\n    for file_name in os.listdir(json_dir):\n        file_to_open = \"{0}/{1}\".format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n\n        # Add the Python object to the context dictionary\n        context[file_name[:-5]] = obj\n\n    return context\n\n\ndef generate_files(input_dir, context=None):\n    \"\"\" Renders the templates and saves them to files. \"\"\"\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(input_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == input_dir:\n        raise NonTemplatedInputDirException\n        \n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(input_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(input_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            # Render the file\n            infile = os.path.join(root, f)\n            tmpl = env.get_template(infile)\n            rendered_file = tmpl.render(**context)\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(input_dir, output_dir, 1)\n\n            # Render the output filename before writing\n            name_tmpl = Template(outfile)\n            rendered_name = name_tmpl.render(**context)\n            print(\"Writing {0}\".format(rendered_name))\n\n            with unicode_open(rendered_name, 'w') as fh:\n                fh.write(rendered_file)\n",
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport json\nimport os\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\n\nfrom .exceptions import NonTemplatedInputDirException\nfrom .utils import make_sure_path_exists, unicode_open\n\n\ndef generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    :param json_dir: Directory containing .json file(s).\n    :paramtype json_dir: directory\n\n    Description:\n\n        Iterates through the contents of json_dir and finds all JSON\n        files. Loads the JSON file as a Python object with the key being the\n        JSON file name..\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n\n    for file_name in os.listdir(json_dir):\n        file_to_open = \"{0}/{1}\".format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n\n        # Add the Python object to the context dictionary\n        context[file_name[:-5]] = obj\n\n    return context\n\n\ndef generate_files(input_dir, context=None):\n    \"\"\"\n    Renders the templates and saves them to files.\n    :param input_dir: Project template input directory.\n    :paramtype input_dir: directory\n    \"\"\"\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(input_dir)\n    output_dir = name_tmpl.render(**context)\n    if output_dir == input_dir:\n        raise NonTemplatedInputDirException\n        \n    make_sure_path_exists(output_dir)\n\n    for root, dirs, files in os.walk(input_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(input_dir, output_dir, 1)\n\n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n\n            make_sure_path_exists(rendered_dirname)\n\n        for f in files:\n            # Render the file\n            infile = os.path.join(root, f)\n            tmpl = env.get_template(infile)\n            rendered_file = tmpl.render(**context)\n\n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(input_dir, output_dir, 1)\n\n            # Render the output filename before writing\n            name_tmpl = Template(outfile)\n            rendered_name = name_tmpl.render(**context)\n            print(\"Writing {0}\".format(rendered_name))\n\n            with unicode_open(rendered_name, 'w') as fh:\n                fh.write(rendered_file)\n",
          "file_patch": "@@ -12,14 +12,15 @@ from .utils import make_sure_path_exists, unicode_open\n \n def generate_context(json_dir='json/'):\n     \"\"\"\n-    Generates the context for all complexity pages.\n+    Generates the context for a Cookiecutter project template.\n+    :param json_dir: Directory containing .json file(s).\n+    :paramtype json_dir: directory\n \n     Description:\n \n-        Iterates through the contents of the input_dir and finds all JSON\n-        files.\n-        Loads the JSON file as a Python object with the key being the JSON\n-        filename.\n+        Iterates through the contents of json_dir and finds all JSON\n+        files. Loads the JSON file as a Python object with the key being the\n+        JSON file name..\n \n     Example:\n \n@@ -50,7 +51,11 @@ def generate_context(json_dir='json/'):\n \n \n def generate_files(input_dir, context=None):\n-    \"\"\" Renders the templates and saves them to files. \"\"\"\n+    \"\"\"\n+    Renders the templates and saves them to files.\n+    :param input_dir: Project template input directory.\n+    :paramtype input_dir: directory\n+    \"\"\"\n \n     context = context or {}\n     env = Environment()\n",
          "files_name_in_blame_commit": [
            "generate.py"
          ]
        }
      },
      "2c9be9d0e48f5358c268b45d3046438f64c18782": {
        "commit": {
          "commit_id": "2c9be9d0e48f5358c268b45d3046438f64c18782",
          "commit_message": "Factor out project generation into generate module.",
          "commit_author": "Audrey Roy",
          "commit_date": "2013-07-21 13:03:02",
          "commit_parent": "17a902a529fda1b9381845120a0afe0d86a089f8"
        },
        "function": {
          "function_name": "generate_context",
          "function_code_before": "",
          "function_code_after": "def generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for all complexity pages.\n\n    Description:\n\n        Iterates through the contents of the input_dir and finds all JSON\n        files.\n        Loads the JSON file as a Python object with the key being the JSON\n        filename.\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n    for file_name in os.listdir(json_dir):\n        file_to_open = '{0}/{1}'.format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n        context[file_name[:-5]] = obj\n    return context",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 13,
          "function_after_end_line": 49,
          "function_before_token_count": 0,
          "function_after_token_count": 59,
          "functions_name_modified_file": [
            "generate_files",
            "generate_context"
          ],
          "functions_name_all_files": [
            "tearDown",
            "test_output_folder",
            "generate_files",
            "main",
            "generate_context",
            "test_something",
            "test_generate_files",
            "test_generate_context"
          ],
          "functions_name_co_evolved_modified_file": [
            "generate_files"
          ],
          "functions_name_co_evolved_all_files": [
            "tearDown",
            "test_output_folder",
            "generate_files",
            "test_something",
            "test_generate_files",
            "test_generate_context"
          ]
        },
        "file": {
          "file_name": "generate.py",
          "file_nloc": 38,
          "file_complexity": 7,
          "file_token_count": 284,
          "file_before": null,
          "file_after": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport json\nimport os\nimport sys\n\nfrom jinja2 import FileSystemLoader, Template\nfrom jinja2.environment import Environment\n\nfrom .utils import make_sure_path_exists, unicode_open\n\n\ndef generate_context(json_dir='json/'):\n    \"\"\"\n    Generates the context for all complexity pages.\n\n    Description:\n\n        Iterates through the contents of the input_dir and finds all JSON\n        files.\n        Loads the JSON file as a Python object with the key being the JSON\n        filename.\n\n    Example:\n\n        Assume the following files exist:\n\n            json/names.json\n            json/numbers.json\n\n        Depending on their content, might generate a context as follows:\n\n        contexts = {\"names\":\n                        ['Audrey', 'Danny']\n                    \"numbers\":\n                        [1, 2, 3, 4]\n                    }\n    \"\"\"\n    context = {}\n\n    for file_name in os.listdir(json_dir):\n        file_to_open = \"{0}/{1}\".format(json_dir, file_name)\n        file_handle = open(file_to_open)\n        obj = json.load(file_handle)\n\n        # Add the Python object to the context dictionary\n        context[file_name[:-5]] = obj\n\n    return context\n\n\ndef generate_files(input_dir, output_dir, context=None):\n    \"\"\" Renders the templates and saves them to files. \"\"\"\n\n    context = context or {}\n    env = Environment()\n    env.loader = FileSystemLoader('.')\n\n    # Render dirname before writing\n    name_tmpl = Template(output_dir)\n    rendered_dirname = name_tmpl.render(**context)\n    make_sure_path_exists(rendered_dirname)\n    \n    for root, dirs, files in os.walk(input_dir):\n        for d in dirs:\n            indir = os.path.join(root, d)\n            outdir = indir.replace(input_dir, output_dir, 1)\n            \n            # Render dirname before writing\n            name_tmpl = Template(outdir)\n            rendered_dirname = name_tmpl.render(**context)\n            \n            make_sure_path_exists(rendered_dirname)\n            \n        for f in files:\n            # Render the file\n            infile = os.path.join(root, f)\n            tmpl = env.get_template(infile)\n            rendered_file = tmpl.render(**context)\n        \n            # Write it to the corresponding place in output_dir\n            outfile = infile.replace(input_dir, output_dir, 1)\n            \n            # Render the output filename before writing\n            name_tmpl = Template(outfile)\n            rendered_name = name_tmpl.render(**context)\n            print(\"Writing {0}\".format(rendered_name))\n            \n            with unicode_open(rendered_name, 'w') as fh:\n                fh.write(rendered_file)\n",
          "file_patch": "@@ -0,0 +1,90 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+import json\n+import os\n+import sys\n+\n+from jinja2 import FileSystemLoader, Template\n+from jinja2.environment import Environment\n+\n+from .utils import make_sure_path_exists, unicode_open\n+\n+\n+def generate_context(json_dir='json/'):\n+    \"\"\"\n+    Generates the context for all complexity pages.\n+\n+    Description:\n+\n+        Iterates through the contents of the input_dir and finds all JSON\n+        files.\n+        Loads the JSON file as a Python object with the key being the JSON\n+        filename.\n+\n+    Example:\n+\n+        Assume the following files exist:\n+\n+            json/names.json\n+            json/numbers.json\n+\n+        Depending on their content, might generate a context as follows:\n+\n+        contexts = {\"names\":\n+                        ['Audrey', 'Danny']\n+                    \"numbers\":\n+                        [1, 2, 3, 4]\n+                    }\n+    \"\"\"\n+    context = {}\n+\n+    for file_name in os.listdir(json_dir):\n+        file_to_open = \"{0}/{1}\".format(json_dir, file_name)\n+        file_handle = open(file_to_open)\n+        obj = json.load(file_handle)\n+\n+        # Add the Python object to the context dictionary\n+        context[file_name[:-5]] = obj\n+\n+    return context\n+\n+\n+def generate_files(input_dir, output_dir, context=None):\n+    \"\"\" Renders the templates and saves them to files. \"\"\"\n+\n+    context = context or {}\n+    env = Environment()\n+    env.loader = FileSystemLoader('.')\n+\n+    # Render dirname before writing\n+    name_tmpl = Template(output_dir)\n+    rendered_dirname = name_tmpl.render(**context)\n+    make_sure_path_exists(rendered_dirname)\n+    \n+    for root, dirs, files in os.walk(input_dir):\n+        for d in dirs:\n+            indir = os.path.join(root, d)\n+            outdir = indir.replace(input_dir, output_dir, 1)\n+            \n+            # Render dirname before writing\n+            name_tmpl = Template(outdir)\n+            rendered_dirname = name_tmpl.render(**context)\n+            \n+            make_sure_path_exists(rendered_dirname)\n+            \n+        for f in files:\n+            # Render the file\n+            infile = os.path.join(root, f)\n+            tmpl = env.get_template(infile)\n+            rendered_file = tmpl.render(**context)\n+        \n+            # Write it to the corresponding place in output_dir\n+            outfile = infile.replace(input_dir, output_dir, 1)\n+            \n+            # Render the output filename before writing\n+            name_tmpl = Template(outfile)\n+            rendered_name = name_tmpl.render(**context)\n+            print(\"Writing {0}\".format(rendered_name))\n+            \n+            with unicode_open(rendered_name, 'w') as fh:\n+                fh.write(rendered_file)\n",
          "files_name_in_blame_commit": [
            "test_cookiecutter.py",
            "test_generate.py",
            "cookiecutter.py",
            "generate.py"
          ]
        }
      }
    }
  }
}
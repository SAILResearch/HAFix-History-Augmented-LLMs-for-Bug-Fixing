{
  "id": "5",
  "blame_commit": {
    "commit": {
      "commit_id": "0bdb009aedf6307fcd066c73f19e8bf96876a183",
      "commit_message": "Add move operations into the fs target interface\n\nAlso, make so that `rename_dont_move` reports success/failure by raising\nexceptions instead of returning a bool value. As it's kind of\nunexpected and unpythonic to return True/False based on success or not.\n\nOther small changes:\n\n * Since we standardize on \"move()\" but all hdfs clients call their\n   operation \"rename()\", we could capture this difference nicely in the\n   common client.\n * Make aborted atomic writes delete (and not trash) the temporary data.\n   This plays nice when you use the webhdfs client which doesn't support\n   removing to trash.\n * Add tests for the \"move()\" and \"rename_dont_move()\" operations on the\n   target level. Hopefully this will catch any breakage and increase\n   code coverage as most file system implementations test against that\n   mixin.",
      "commit_author": "Arash Rouhani",
      "commit_date": "2016-01-05 16:13:32",
      "commit_parent": "4460b98acca6c14cd99258e99b29d139548a1061"
    },
    "function": {
      "function_name": "move",
      "function_code_before": "def move(self, new_path, raise_if_exists=False):\n    if raise_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if d and (not os.path.exists(d)):\n        self.fs.mkdir(d)\n    os.rename(self.path, new_path)",
      "function_code_after": "def move(self, old_path, new_path, raise_if_exists=False):\n    if raise_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if d and (not os.path.exists(d)):\n        self.fs.mkdir(d)\n    os.rename(old_path, new_path)",
      "function_before_start_line": 126,
      "function_before_end_line": 132,
      "function_after_start_line": 86,
      "function_after_end_line": 92,
      "function_before_token_count": 71,
      "function_after_token_count": 71,
      "functions_name_modified_file": [
        "exists",
        "remove",
        "__init__",
        "makedirs",
        "move_dir",
        "fn",
        "move",
        "__del__",
        "open",
        "listdir",
        "copy",
        "move_to_final_destination",
        "mkdir",
        "generate_tmp_path",
        "isdir"
      ],
      "functions_name_all_files": [
        "pipe_writer",
        "test_rename_no_grandparent",
        "test_open",
        "output",
        "put_multipart",
        "test_context_manager",
        "listdir",
        "test_listdir_base_list_dirs_only",
        "_wait_for_consistency",
        "list",
        "mkdir",
        "hdfs_writer",
        "walk",
        "test_luigi_tmp",
        "touchz",
        "makedirs",
        "test_format_injection",
        "test_format_newline",
        "_add_path_delimiter",
        "test_rename_trailing_slash",
        "assertRegexpMatches",
        "glob_exists",
        "test_mkdir_exists",
        "test_listdir_base_list_get_types",
        "move",
        "test_cdh3_client",
        "test_get",
        "test_listdir",
        "test_abstract_subclass",
        "test_put",
        "test_snakebite_with_hadoopcli_fallback",
        "test_listdir_base_list_files_only",
        "generate_tmp_path",
        "get_target",
        "test_chown",
        "test_text",
        "setUp",
        "__init__",
        "download",
        "_list_iter",
        "__setstate__",
        "test_listdir_base_list_get_times",
        "test_apache1_client",
        "upload",
        "test_rename_no_parent",
        "test_relativepath",
        "isdir",
        "test_file",
        "test_readback",
        "tearDown",
        "fn",
        "create_hadoopcli_client",
        "tmp_path",
        "getmerge",
        "test_listdir_base_list",
        "_touchz",
        "_add_to_buffer",
        "writable",
        "open",
        "test_read_iterator",
        "rename_dont_move",
        "test_getmerge",
        "test_move",
        "put_file",
        "test_gzip_with_module",
        "test_del",
        "fs",
        "_do_put",
        "get_client",
        "test_mkdir",
        "tezt_rename_dont_move",
        "test_snakebite",
        "test_tmppath_not_configured",
        "test_copy",
        "test_count",
        "test_listdir_base_list_get_sizes",
        "test_write_cleanup_no_close",
        "test_rename",
        "count",
        "__getstate__",
        "test_with_exception",
        "_flush_buffer",
        "move_dir",
        "test_format_chain_reverse",
        "test_multifile",
        "test_with_write_success",
        "test_with_noclose",
        "test_binary_write",
        "test_format_chain",
        "chmod",
        "test_with_close",
        "test_exists",
        "_is_writable",
        "read",
        "create_file",
        "test_unicode_obj",
        "test_writelines",
        "test_chmod",
        "test_tmp_cleanup",
        "get_as_string",
        "test_slow_exists",
        "_path_to_bucket_and_key",
        "create_target",
        "__enter__",
        "test_move_on_fs",
        "list_path",
        "assertCleanUp",
        "test_rename_dont_move_on_fs",
        "test_when_not_specified",
        "test_connection_refused",
        "test_create_ancestors",
        "_is_root",
        "_setup_listdir",
        "test_gzip",
        "test_tmp",
        "test_atomicity",
        "is_writable",
        "test_cannot_instantiate",
        "testBoolOverride",
        "test_check_output",
        "test_with_write_failure",
        "_exists",
        "copy",
        "move_to_final_destination",
        "test_list",
        "_get_s3_config",
        "test_tmppath_username",
        "test_tunnel",
        "test_tmp_move",
        "test_instantiate_subclass",
        "pipe_reader",
        "test_remove",
        "get_bite",
        "remove",
        "test_hadoopcli",
        "seekable",
        "_obj_exists",
        "get_key",
        "test_recursion_on_delete",
        "client",
        "__iter__",
        "rename",
        "test_bzip2",
        "exists",
        "close",
        "put",
        "put_string",
        "test_pickle",
        "url",
        "get",
        "hdfs_reader",
        "chown",
        "test_listdir_base_list_recusion",
        "test_gzip_works_and_cleans_up",
        "test_glob_exists",
        "__del__",
        "readable",
        "test_listdir_full_list_get_everything",
        "test_del_with_Text",
        "abort",
        "call_check",
        "test_rename_dont_move",
        "__exit__"
      ],
      "functions_name_co_evolved_modified_file": [],
      "functions_name_co_evolved_all_files": [
        "move_dir",
        "test_rename_dont_move_on_fs",
        "rename_dont_move",
        "tezt_rename_dont_move",
        "test_move_on_fs",
        "rename",
        "abort",
        "test_rename_dont_move",
        "_touchz",
        "setUp"
      ]
    },
    "file": {
      "file_name": "file.py",
      "file_nloc": 112,
      "file_complexity": 42,
      "file_token_count": 800,
      "file_before": "# -*- coding: utf-8 -*-\n#\n# Copyright 2012-2015 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n\"\"\"\n:class:`LocalTarget` provides a concrete implementation of a :py:class:`~luigi.target.Target` class that uses files on the local file system\n\"\"\"\n\nimport os\nimport random\nimport shutil\nimport tempfile\nimport io\nimport warnings\n\nfrom luigi.format import FileWrapper, get_default_format\nfrom luigi.target import FileAlreadyExists, MissingParentDirectory, NotADirectory, FileSystem, FileSystemTarget, AtomicLocalFile\n\n\nclass atomic_file(AtomicLocalFile):\n    \"\"\"Simple class that writes to a temp file and moves it on close()\n    Also cleans up the temp file if close is not invoked\n    \"\"\"\n\n    def move_to_final_destination(self):\n        os.rename(self.tmp_path, self.path)\n\n    def generate_tmp_path(self, path):\n        return path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n\n\nclass LocalFileSystem(FileSystem):\n    \"\"\"\n    Wrapper for access to file system operations.\n\n    Work in progress - add things as needed.\n    \"\"\"\n\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def mkdir(self, path, parents=True, raise_if_exists=False):\n        if self.exists(path):\n            if raise_if_exists:\n                raise FileAlreadyExists()\n            elif not self.isdir(path):\n                raise NotADirectory()\n            else:\n                return\n\n        if parents:\n            os.makedirs(path)\n        else:\n            if not os.path.exists(os.path.dirname(path)):\n                raise MissingParentDirectory()\n            os.mkdir(path)\n\n    def isdir(self, path):\n        return os.path.isdir(path)\n\n    def listdir(self, path):\n        for dir_, _, files in os.walk(path):\n            assert dir_.startswith(path)\n            for name in files:\n                yield os.path.join(dir_, name)\n\n    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)\n\n\nclass LocalTarget(FileSystemTarget):\n    fs = LocalFileSystem()\n\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if format is None:\n            format = get_default_format()\n\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(LocalTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder:\n            try:\n                os.makedirs(parentfolder)\n            except OSError:\n                pass\n\n    def open(self, mode='r'):\n        if mode[:1] == 'w':\n            self.makedirs()\n            return self.format.pipe_writer(atomic_file(self.path))\n\n        elif mode[:1] == 'r':\n            fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, mode)))\n            return self.format.pipe_reader(fileobj)\n\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        self.fs.remove(self.path)\n\n    def copy(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = LocalTarget(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n        tmp.makedirs()\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()\n\n\nclass File(LocalTarget):\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\"File has been renamed LocalTarget\", DeprecationWarning, stacklevel=2)\n        super(File, self).__init__(*args, **kwargs)\n",
      "file_after": "# -*- coding: utf-8 -*-\n#\n# Copyright 2012-2015 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n\"\"\"\n:class:`LocalTarget` provides a concrete implementation of a :py:class:`~luigi.target.Target` class that uses files on the local file system\n\"\"\"\n\nimport os\nimport random\nimport shutil\nimport tempfile\nimport io\nimport warnings\n\nfrom luigi.format import FileWrapper, get_default_format\nfrom luigi.target import FileAlreadyExists, MissingParentDirectory, NotADirectory, FileSystem, FileSystemTarget, AtomicLocalFile\n\n\nclass atomic_file(AtomicLocalFile):\n    \"\"\"Simple class that writes to a temp file and moves it on close()\n    Also cleans up the temp file if close is not invoked\n    \"\"\"\n\n    def move_to_final_destination(self):\n        os.rename(self.tmp_path, self.path)\n\n    def generate_tmp_path(self, path):\n        return path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n\n\nclass LocalFileSystem(FileSystem):\n    \"\"\"\n    Wrapper for access to file system operations.\n\n    Work in progress - add things as needed.\n    \"\"\"\n\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def mkdir(self, path, parents=True, raise_if_exists=False):\n        if self.exists(path):\n            if raise_if_exists:\n                raise FileAlreadyExists()\n            elif not self.isdir(path):\n                raise NotADirectory()\n            else:\n                return\n\n        if parents:\n            os.makedirs(path)\n        else:\n            if not os.path.exists(os.path.dirname(path)):\n                raise MissingParentDirectory()\n            os.mkdir(path)\n\n    def isdir(self, path):\n        return os.path.isdir(path)\n\n    def listdir(self, path):\n        for dir_, _, files in os.walk(path):\n            assert dir_.startswith(path)\n            for name in files:\n                yield os.path.join(dir_, name)\n\n    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)\n\n    def move(self, old_path, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(old_path, new_path)\n\n\nclass LocalTarget(FileSystemTarget):\n    fs = LocalFileSystem()\n\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if format is None:\n            format = get_default_format()\n\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(LocalTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder:\n            try:\n                os.makedirs(parentfolder)\n            except OSError:\n                pass\n\n    def open(self, mode='r'):\n        if mode[:1] == 'w':\n            self.makedirs()\n            return self.format.pipe_writer(atomic_file(self.path))\n\n        elif mode[:1] == 'r':\n            fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, mode)))\n            return self.format.pipe_reader(fileobj)\n\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, raise_if_exists=False):\n        self.fs.move(self.path, new_path, raise_if_exists=raise_if_exists)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        self.fs.remove(self.path)\n\n    def copy(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = LocalTarget(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n        tmp.makedirs()\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()\n\n\nclass File(LocalTarget):\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\"File has been renamed LocalTarget\", DeprecationWarning, stacklevel=2)\n        super(File, self).__init__(*args, **kwargs)\n",
      "file_patch": "@@ -83,6 +83,14 @@ class LocalFileSystem(FileSystem):\n         else:\n             os.remove(path)\n \n+    def move(self, old_path, new_path, raise_if_exists=False):\n+        if raise_if_exists and os.path.exists(new_path):\n+            raise RuntimeError('Destination exists: %s' % new_path)\n+        d = os.path.dirname(new_path)\n+        if d and not os.path.exists(d):\n+            self.fs.mkdir(d)\n+        os.rename(old_path, new_path)\n+\n \n class LocalTarget(FileSystemTarget):\n     fs = LocalFileSystem()\n@@ -124,12 +132,7 @@ class LocalTarget(FileSystemTarget):\n             raise Exception('mode must be r/w')\n \n     def move(self, new_path, raise_if_exists=False):\n-        if raise_if_exists and os.path.exists(new_path):\n-            raise RuntimeError('Destination exists: %s' % new_path)\n-        d = os.path.dirname(new_path)\n-        if d and not os.path.exists(d):\n-            self.fs.mkdir(d)\n-        os.rename(self.path, new_path)\n+        self.fs.move(self.path, new_path, raise_if_exists=raise_if_exists)\n \n     def move_dir(self, new_path):\n         self.move(new_path)\n",
      "files_name_in_blame_commit": [
        "gcs.py",
        "abstract_client.py",
        "snakebite_client.py",
        "target.py",
        "hdfs_test.py",
        "webhdfs_client.py",
        "hadoopcli_clients.py",
        "format.py",
        "test_ssh.py",
        "s3.py",
        "target_test.py",
        "file_test.py",
        "file.py",
        "snakebite_test.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 55
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "126": {
        "commit_id": "c886c5a016a0479cc4308982160ee35077ee2ae6",
        "line_code": "    def move(self, new_path, raise_if_exists=False):",
        "commit_date": "2015-04-15 11:49:00",
        "valid": 1
      },
      "127": {
        "commit_id": "c886c5a016a0479cc4308982160ee35077ee2ae6",
        "line_code": "        if raise_if_exists and os.path.exists(new_path):",
        "commit_date": "2015-04-15 11:49:00",
        "valid": 1
      },
      "128": {
        "commit_id": "5c77d782b1cad537b63559fa162c61999a371f23",
        "line_code": "            raise RuntimeError('Destination exists: %s' % new_path)",
        "commit_date": "2012-08-08 09:15:23",
        "valid": 1
      },
      "129": {
        "commit_id": "5c77d782b1cad537b63559fa162c61999a371f23",
        "line_code": "        d = os.path.dirname(new_path)",
        "commit_date": "2012-08-08 09:15:23",
        "valid": 1
      },
      "130": {
        "commit_id": "16070a9a6cf372d1192f69dfefa3fa18aa8c4817",
        "line_code": "        if d and not os.path.exists(d):",
        "commit_date": "2014-03-26 21:18:58",
        "valid": 1
      },
      "131": {
        "commit_id": "69ecbade3d24a9080b861a27f78b877fb7c3e3bf",
        "line_code": "            self.fs.mkdir(d)",
        "commit_date": "2013-05-16 17:37:22",
        "valid": 1
      },
      "132": {
        "commit_id": "5c77d782b1cad537b63559fa162c61999a371f23",
        "line_code": "        os.rename(self.path, new_path)",
        "commit_date": "2012-08-08 09:15:23",
        "valid": 1
      }
    },
    "commits": {
      "c886c5a016a0479cc4308982160ee35077ee2ae6": {
        "commit": {
          "commit_id": "c886c5a016a0479cc4308982160ee35077ee2ae6",
          "commit_message": "Replace fail_if_exists with raise_if_exists\n\nThe `fail_if_exists` keyword have been deprecated for a while now.",
          "commit_author": "Arash Rouhani",
          "commit_date": "2015-04-15 11:49:00",
          "commit_parent": "71e460300f8679c04f2ff1e9c968ae4605ece64f"
        },
        "function": {
          "function_name": "move",
          "function_code_before": "@luigi.util.deprecate_kwarg('fail_if_exists', 'raise_if_exists', False)\ndef move(self, new_path, fail_if_exists=False):\n    if fail_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if d and (not os.path.exists(d)):\n        self.fs.mkdir(d)\n    os.rename(self.path, new_path)",
          "function_code_after": "def move(self, new_path, raise_if_exists=False):\n    if raise_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if d and (not os.path.exists(d)):\n        self.fs.mkdir(d)\n    os.rename(self.path, new_path)",
          "function_before_start_line": 111,
          "function_before_end_line": 117,
          "function_after_start_line": 110,
          "function_after_end_line": 116,
          "function_before_token_count": 71,
          "function_after_token_count": 71,
          "functions_name_modified_file": [
            "exists",
            "remove",
            "__init__",
            "makedirs",
            "move_dir",
            "fn",
            "move",
            "__del__",
            "open",
            "copy",
            "move_to_final_destination",
            "mkdir",
            "generate_tmp_path",
            "isdir"
          ],
          "functions_name_all_files": [
            "pipe_writer",
            "fn",
            "clear",
            "chmod",
            "create_hadoopcli_client",
            "listdir",
            "tmppath",
            "pipe_reader",
            "_is_writable",
            "getmerge",
            "mkdir",
            "hdfs_writer",
            "get_all_data",
            "makedirs",
            "remove",
            "get_bite",
            "get_configured_hdfs_client",
            "open",
            "rename_dont_move",
            "rename",
            "list_path",
            "load_hadoop_cmd",
            "fs",
            "get_autoconfig_client",
            "path",
            "glob_exists",
            "exists",
            "close",
            "move",
            "put",
            "__new__",
            "get",
            "generate_tmp_path",
            "hdfs_reader",
            "chown",
            "count",
            "__init__",
            "get_data",
            "is_writable",
            "__del__",
            "move_dir",
            "copy",
            "move_to_final_destination",
            "get_configured_hadoop_version",
            "abort",
            "call_check",
            "isdir"
          ],
          "functions_name_co_evolved_modified_file": [
            "copy"
          ],
          "functions_name_co_evolved_all_files": [
            "copy",
            "rename"
          ]
        },
        "file": {
          "file_name": "file.py",
          "file_nloc": 94,
          "file_complexity": 34,
          "file_token_count": 682,
          "file_before": "# -*- coding: utf-8 -*-\n#\n# Copyright 2012-2015 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n\"\"\"\n:class:`LocalTarget` provides a concrete implementation of a :py:class:`~luigi.target.Target` class that uses files on the local file system\n\"\"\"\n\nimport os\nimport random\nimport shutil\nimport tempfile\nimport io\nimport sys\nimport warnings\n\nimport luigi.util\nfrom luigi.format import FileWrapper, get_default_format, MixedUnicodeBytes\nfrom luigi.target import FileSystem, FileSystemTarget, AtomicLocalFile\n\n\nclass atomic_file(AtomicLocalFile):\n    \"\"\"Simple class that writes to a temp file and moves it on close()\n    Also cleans up the temp file if close is not invoked\n    \"\"\"\n\n    def move_to_final_destination(self):\n        os.rename(self.tmp_path, self.path)\n\n    def generate_tmp_path(self, path):\n        return path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n\n\nclass LocalFileSystem(FileSystem):\n    \"\"\"\n    Wrapper for access to file system operations.\n\n    Work in progress - add things as needed.\n    \"\"\"\n\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def mkdir(self, path, parents=True, raise_if_exists=False):\n        os.makedirs(path)\n\n    def isdir(self, path):\n        return os.path.isdir(path)\n\n    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)\n\n\nclass LocalTarget(FileSystemTarget):\n    fs = LocalFileSystem()\n\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if format is None:\n            format = get_default_format()\n\n        # Allow to write unicode in file for retrocompatibility\n        if sys.version_info[:2] <= (2, 6):\n            format = format >> MixedUnicodeBytes\n\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(LocalTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder and not os.path.exists(parentfolder):\n            os.makedirs(parentfolder)\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            self.makedirs()\n            return self.format.pipe_writer(atomic_file(self.path))\n\n        elif mode == 'r':\n            fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, 'r')))\n            return self.format.pipe_reader(fileobj)\n\n        else:\n            raise Exception('mode must be r/w')\n\n    @luigi.util.deprecate_kwarg('fail_if_exists', 'raise_if_exists', False)\n    def move(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        self.fs.remove(self.path)\n\n    @luigi.util.deprecate_kwarg('fail_if_exists', 'raise_if_exists', False)\n    def copy(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = LocalTarget(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n        tmp.makedirs()\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()\n\n\nclass File(LocalTarget):\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\"File has been renamed LocalTarget\", DeprecationWarning, stacklevel=2)\n        super(File, self).__init__(*args, **kwargs)\n",
          "file_after": "# -*- coding: utf-8 -*-\n#\n# Copyright 2012-2015 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n\"\"\"\n:class:`LocalTarget` provides a concrete implementation of a :py:class:`~luigi.target.Target` class that uses files on the local file system\n\"\"\"\n\nimport os\nimport random\nimport shutil\nimport tempfile\nimport io\nimport sys\nimport warnings\n\nimport luigi.util\nfrom luigi.format import FileWrapper, get_default_format, MixedUnicodeBytes\nfrom luigi.target import FileSystem, FileSystemTarget, AtomicLocalFile\n\n\nclass atomic_file(AtomicLocalFile):\n    \"\"\"Simple class that writes to a temp file and moves it on close()\n    Also cleans up the temp file if close is not invoked\n    \"\"\"\n\n    def move_to_final_destination(self):\n        os.rename(self.tmp_path, self.path)\n\n    def generate_tmp_path(self, path):\n        return path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n\n\nclass LocalFileSystem(FileSystem):\n    \"\"\"\n    Wrapper for access to file system operations.\n\n    Work in progress - add things as needed.\n    \"\"\"\n\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def mkdir(self, path, parents=True, raise_if_exists=False):\n        os.makedirs(path)\n\n    def isdir(self, path):\n        return os.path.isdir(path)\n\n    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)\n\n\nclass LocalTarget(FileSystemTarget):\n    fs = LocalFileSystem()\n\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if format is None:\n            format = get_default_format()\n\n        # Allow to write unicode in file for retrocompatibility\n        if sys.version_info[:2] <= (2, 6):\n            format = format >> MixedUnicodeBytes\n\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(LocalTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder and not os.path.exists(parentfolder):\n            os.makedirs(parentfolder)\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            self.makedirs()\n            return self.format.pipe_writer(atomic_file(self.path))\n\n        elif mode == 'r':\n            fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, 'r')))\n            return self.format.pipe_reader(fileobj)\n\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        self.fs.remove(self.path)\n\n    def copy(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = LocalTarget(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n        tmp.makedirs()\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()\n\n\nclass File(LocalTarget):\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\"File has been renamed LocalTarget\", DeprecationWarning, stacklevel=2)\n        super(File, self).__init__(*args, **kwargs)\n",
          "file_patch": "@@ -107,9 +107,8 @@ class LocalTarget(FileSystemTarget):\n         else:\n             raise Exception('mode must be r/w')\n \n-    @luigi.util.deprecate_kwarg('fail_if_exists', 'raise_if_exists', False)\n-    def move(self, new_path, fail_if_exists=False):\n-        if fail_if_exists and os.path.exists(new_path):\n+    def move(self, new_path, raise_if_exists=False):\n+        if raise_if_exists and os.path.exists(new_path):\n             raise RuntimeError('Destination exists: %s' % new_path)\n         d = os.path.dirname(new_path)\n         if d and not os.path.exists(d):\n@@ -122,9 +121,8 @@ class LocalTarget(FileSystemTarget):\n     def remove(self):\n         self.fs.remove(self.path)\n \n-    @luigi.util.deprecate_kwarg('fail_if_exists', 'raise_if_exists', False)\n-    def copy(self, new_path, fail_if_exists=False):\n-        if fail_if_exists and os.path.exists(new_path):\n+    def copy(self, new_path, raise_if_exists=False):\n+        if raise_if_exists and os.path.exists(new_path):\n             raise RuntimeError('Destination exists: %s' % new_path)\n         tmp = LocalTarget(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n         tmp.makedirs()\n",
          "files_name_in_blame_commit": [
            "hdfs.py",
            "mock.py",
            "file.py"
          ]
        }
      },
      "16070a9a6cf372d1192f69dfefa3fa18aa8c4817": {
        "commit": {
          "commit_id": "16070a9a6cf372d1192f69dfefa3fa18aa8c4817",
          "commit_message": "Another bug with relative paths and move()\n\nAdded a test and also made some existing tests a bit harder",
          "commit_author": "Erik Bernhardsson",
          "commit_date": "2014-03-26 21:18:58",
          "commit_parent": "c5b3738e6e6c07a2748bc25156b22a185b10f078"
        },
        "function": {
          "function_name": "move",
          "function_code_before": "def move(self, new_path, fail_if_exists=False):\n    if fail_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if not os.path.exists(d):\n        self.fs.mkdir(d)\n    os.rename(self.path, new_path)",
          "function_code_after": "def move(self, new_path, fail_if_exists=False):\n    if fail_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if d and (not os.path.exists(d)):\n        self.fs.mkdir(d)\n    os.rename(self.path, new_path)",
          "function_before_start_line": 104,
          "function_before_end_line": 110,
          "function_after_start_line": 104,
          "function_after_end_line": 110,
          "function_before_token_count": 69,
          "function_after_token_count": 71,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "exists",
            "__del__",
            "remove",
            "move_dir",
            "move",
            "fn",
            "open",
            "copy",
            "tmp_path",
            "mkdir",
            "isdir",
            "__exit__"
          ],
          "functions_name_all_files": [
            "tearDown",
            "fn",
            "test_exists",
            "tmp_path",
            "mkdir",
            "remove",
            "test_close",
            "test_format_injection",
            "open",
            "test_move",
            "test_del",
            "test_bzip2",
            "test_write_cleanup_with_error",
            "close",
            "exists",
            "move",
            "test_mkdir",
            "test_gzip",
            "test_copy",
            "test_tmp",
            "test_write_cleanup_no_close",
            "setUp",
            "__init__",
            "__del__",
            "move_dir",
            "copy",
            "isdir",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_move"
          ]
        },
        "file": {
          "file_name": "file.py",
          "file_nloc": 92,
          "file_complexity": 37,
          "file_token_count": 669,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport os\nimport random\nimport tempfile\nimport shutil\nfrom target import FileSystem, FileSystemTarget\nfrom luigi.format import FileWrapper\n\n\nclass atomic_file(file):\n    # Simple class that writes to a temp file and moves it on close()\n    # Also cleans up the temp file if close is not invoked\n    def __init__(self, path):\n        self.__tmp_path = path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n        self.path = path\n        super(atomic_file, self).__init__(self.__tmp_path, 'w')\n\n    def close(self):\n        super(atomic_file, self).close()\n        os.rename(self.__tmp_path, self.path)\n\n    def __del__(self):\n        if os.path.exists(self.__tmp_path):\n            os.remove(self.__tmp_path)\n\n    @property\n    def tmp_path(self):\n        return self.__tmp_path\n\n    def __exit__(self, exc_type, exc, traceback):\n        \" Close/commit the file if there are no exception \"\n        if exc_type:\n            return\n        return file.__exit__(self, exc_type, exc, traceback)\n\n\nclass LocalFileSystem(FileSystem):\n    \"\"\" Wrapper for access to file system operations\n\n    Work in progress - add things as needed\n    \"\"\"\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def mkdir(self, path):\n        os.makedirs(path)\n\n    def isdir(self, path):\n        return os.path.isdir(path)\n\n    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)\n\n\nclass File(FileSystemTarget):\n    fs = LocalFileSystem()\n\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(File, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            # Create folder if it does not exist\n            normpath = os.path.normpath(self.path)\n            parentfolder = os.path.dirname(normpath)\n            if parentfolder and not os.path.exists(parentfolder):\n                os.makedirs(parentfolder)\n\n            if self.format:\n                return self.format.pipe_writer(atomic_file(self.path))\n            else:\n                return atomic_file(self.path)\n\n        elif mode == 'r':\n            fileobj = FileWrapper(open(self.path, 'r'))\n            if self.format:\n                return self.format.pipe_reader(fileobj)\n            return fileobj\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        self.fs.remove(self.path)\n\n    def copy(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = File(is_tmp=True)\n        tmp.open('w')\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport os\nimport random\nimport tempfile\nimport shutil\nfrom target import FileSystem, FileSystemTarget\nfrom luigi.format import FileWrapper\n\n\nclass atomic_file(file):\n    # Simple class that writes to a temp file and moves it on close()\n    # Also cleans up the temp file if close is not invoked\n    def __init__(self, path):\n        self.__tmp_path = path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n        self.path = path\n        super(atomic_file, self).__init__(self.__tmp_path, 'w')\n\n    def close(self):\n        super(atomic_file, self).close()\n        os.rename(self.__tmp_path, self.path)\n\n    def __del__(self):\n        if os.path.exists(self.__tmp_path):\n            os.remove(self.__tmp_path)\n\n    @property\n    def tmp_path(self):\n        return self.__tmp_path\n\n    def __exit__(self, exc_type, exc, traceback):\n        \" Close/commit the file if there are no exception \"\n        if exc_type:\n            return\n        return file.__exit__(self, exc_type, exc, traceback)\n\n\nclass LocalFileSystem(FileSystem):\n    \"\"\" Wrapper for access to file system operations\n\n    Work in progress - add things as needed\n    \"\"\"\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def mkdir(self, path):\n        os.makedirs(path)\n\n    def isdir(self, path):\n        return os.path.isdir(path)\n\n    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)\n\n\nclass File(FileSystemTarget):\n    fs = LocalFileSystem()\n\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(File, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            # Create folder if it does not exist\n            normpath = os.path.normpath(self.path)\n            parentfolder = os.path.dirname(normpath)\n            if parentfolder and not os.path.exists(parentfolder):\n                os.makedirs(parentfolder)\n\n            if self.format:\n                return self.format.pipe_writer(atomic_file(self.path))\n            else:\n                return atomic_file(self.path)\n\n        elif mode == 'r':\n            fileobj = FileWrapper(open(self.path, 'r'))\n            if self.format:\n                return self.format.pipe_reader(fileobj)\n            return fileobj\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        self.fs.remove(self.path)\n\n    def copy(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = File(is_tmp=True)\n        tmp.open('w')\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()\n",
          "file_patch": "@@ -105,7 +105,7 @@ class File(FileSystemTarget):\n         if fail_if_exists and os.path.exists(new_path):\n             raise RuntimeError('Destination exists: %s' % new_path)\n         d = os.path.dirname(new_path)\n-        if not os.path.exists(d):\n+        if d and not os.path.exists(d):\n             self.fs.mkdir(d)\n         os.rename(self.path, new_path)\n \n",
          "files_name_in_blame_commit": [
            "file_test.py",
            "file.py"
          ]
        }
      },
      "69ecbade3d24a9080b861a27f78b877fb7c3e3bf": {
        "commit": {
          "commit_id": "69ecbade3d24a9080b861a27f78b877fb7c3e3bf",
          "commit_message": "HiveQueryTask automatically creates parent directory of output if it doesn't exist.\n\nPreviously, an INSERT OVERWRITE would fail if the parent directory didn't exist.\nAs part of this, I started working on a more generic file system abstraction for the local\nfile system in addition to the existing one for HDFS (HdfsClient)",
          "commit_author": "Elias Freider",
          "commit_date": "2013-05-16 17:37:22",
          "commit_parent": "d2b6da5cf78fbae57cd647bc48b59f3ba1ba8aea"
        },
        "function": {
          "function_name": "move",
          "function_code_before": "def move(self, new_path, fail_if_exists=False):\n    if fail_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if not os.path.exists(d):\n        os.makedirs(d)\n    os.rename(self.path, new_path)",
          "function_code_after": "def move(self, new_path, fail_if_exists=False):\n    if fail_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if not os.path.exists(d):\n        self.fs.mkdir(d)\n    os.rename(self.path, new_path)",
          "function_before_start_line": 82,
          "function_before_end_line": 88,
          "function_after_start_line": 103,
          "function_after_end_line": 109,
          "function_before_token_count": 67,
          "function_after_token_count": 69,
          "functions_name_modified_file": [
            "__init__",
            "close",
            "exists",
            "__del__",
            "remove",
            "move_dir",
            "move",
            "fn",
            "open",
            "tmp_path",
            "mkdir",
            "isdir",
            "__exit__"
          ],
          "functions_name_all_files": [
            "pipe_writer",
            "run_hive_script",
            "job_runner",
            "fn",
            "run_hive_cmd",
            "chmod",
            "output",
            "tearDown",
            "listdir",
            "test_instantiate_subclass",
            "tmppath",
            "test_exists",
            "tmp_path",
            "getmerge",
            "_is_writable",
            "mkdir",
            "hdfs_writer",
            "remove",
            "test_close",
            "use_cdh4_syntax",
            "table_location",
            "open",
            "__enter__",
            "rename",
            "load_hive_cmd",
            "table_schema",
            "hiverc",
            "fs",
            "path",
            "test_del",
            "glob_exists",
            "query",
            "test_write_cleanup_with_error",
            "close",
            "exists",
            "testRunHiveCommand",
            "partition_spec",
            "move",
            "put",
            "get_fn",
            "hiveconfs",
            "test_mkdir",
            "table_exists",
            "run_job",
            "mock_hive_cmd",
            "testRunHiveScriptNotExists",
            "test_abstract_subclass",
            "get",
            "test_gzip",
            "testRunHiveScriptExists",
            "test_tmp",
            "test_write_cleanup_no_close",
            "hdfs_reader",
            "chown",
            "count",
            "__init__",
            "setUp",
            "is_writable",
            "__del__",
            "move_dir",
            "test_cannot_instantiate",
            "test_create_parent_dirs",
            "prepare_outputs",
            "copy",
            "run_hive",
            "abort",
            "call_check",
            "isdir",
            "__exit__"
          ],
          "functions_name_co_evolved_modified_file": [
            "exists",
            "remove",
            "__init__",
            "__del__",
            "mkdir",
            "isdir"
          ],
          "functions_name_co_evolved_all_files": [
            "exists",
            "remove",
            "__init__",
            "__del__",
            "tearDown",
            "test_mkdir",
            "test_create_parent_dirs",
            "open",
            "prepare_outputs",
            "run_job",
            "test_abstract_subclass",
            "__enter__",
            "test_exists",
            "test_tmp",
            "mkdir",
            "fs",
            "isdir",
            "setUp"
          ]
        },
        "file": {
          "file_name": "file.py",
          "file_nloc": 84,
          "file_complexity": 33,
          "file_token_count": 598,
          "file_before": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport os\nimport random\nimport tempfile\nfrom target import Target\n\n\nclass atomic_file(file):\n    # Simple class that writes to a temp file and moves it on close()\n    # Also cleans up the temp file if close is not invoked\n    def __init__(self, path):\n        self.__tmp_path = path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n        self.path = path\n        super(atomic_file, self).__init__(self.__tmp_path, 'w')\n\n    def close(self):\n        super(atomic_file, self).close()\n        os.rename(self.__tmp_path, self.path)\n\n    def __del__(self):\n        if os.path.exists(self.__tmp_path):\n            os.remove(self.__tmp_path)\n\n    @property\n    def tmp_path(self):\n        return self.__tmp_path\n\n    def __exit__(self, exc_type, exc, traceback):\n        \" Close/commit the file if there are no exception \"\n        if exc_type:\n            return\n        return file.__exit__(self, exc_type, exc, traceback)\n\n\nclass File(Target):\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        self.path = path\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def exists(self):\n        return os.path.exists(self.path)\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            # Create folder if it does not exist\n            normpath = os.path.normpath(self.path)\n            parentfolder = os.path.dirname(normpath)\n            if parentfolder and not os.path.exists(parentfolder):\n                os.makedirs(parentfolder)\n\n            if self.format:\n                return self.format.pipe_writer(atomic_file(self.path))\n            else:\n                return atomic_file(self.path)\n\n        elif mode == 'r':\n            if self.format:\n                return self.format.pipe_reader(file(self.path))\n            else:\n                return open(self.path, mode)\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if not os.path.exists(d):\n            os.makedirs(d)\n        os.rename(self.path, new_path)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        os.remove(self.path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and os.path.exists(self.path):\n            self.remove()\n",
          "file_after": "# Copyright (c) 2012 Spotify AB\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n# use this file except in compliance with the License. You may obtain a copy of\n# the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under\n# the License.\n\nimport os\nimport random\nimport tempfile\nimport shutil\nfrom target import FileSystem, FileSystemTarget\n\n\nclass atomic_file(file):\n    # Simple class that writes to a temp file and moves it on close()\n    # Also cleans up the temp file if close is not invoked\n    def __init__(self, path):\n        self.__tmp_path = path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n        self.path = path\n        super(atomic_file, self).__init__(self.__tmp_path, 'w')\n\n    def close(self):\n        super(atomic_file, self).close()\n        os.rename(self.__tmp_path, self.path)\n\n    def __del__(self):\n        if os.path.exists(self.__tmp_path):\n            os.remove(self.__tmp_path)\n\n    @property\n    def tmp_path(self):\n        return self.__tmp_path\n\n    def __exit__(self, exc_type, exc, traceback):\n        \" Close/commit the file if there are no exception \"\n        if exc_type:\n            return\n        return file.__exit__(self, exc_type, exc, traceback)\n\n\nclass LocalFileSystem(FileSystem):\n    \"\"\" Wrapper for access to file system operations\n\n    Work in progress - add things as needed\n    \"\"\"\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def mkdir(self, path):\n        os.makedirs(path)\n\n    def isdir(self, path):\n        os.path.isdir(path)\n\n    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)\n\n\nclass File(FileSystemTarget):\n    fs = LocalFileSystem()\n\n    def __init__(self, path=None, format=None, is_tmp=False):\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(File, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            # Create folder if it does not exist\n            normpath = os.path.normpath(self.path)\n            parentfolder = os.path.dirname(normpath)\n            if parentfolder and not os.path.exists(parentfolder):\n                os.makedirs(parentfolder)\n\n            if self.format:\n                return self.format.pipe_writer(atomic_file(self.path))\n            else:\n                return atomic_file(self.path)\n\n        elif mode == 'r':\n            if self.format:\n                return self.format.pipe_reader(file(self.path))\n            else:\n                return open(self.path, mode)\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)\n\n    def move_dir(self, new_path):\n        self.move(new_path)\n\n    def remove(self):\n        self.fs.remove(self.path)\n\n    @property\n    def fn(self):\n        return self.path\n\n    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()\n",
          "file_patch": "@@ -15,7 +15,8 @@\n import os\n import random\n import tempfile\n-from target import Target\n+import shutil\n+from target import FileSystem, FileSystemTarget\n \n \n class atomic_file(file):\n@@ -45,19 +46,39 @@ class atomic_file(file):\n         return file.__exit__(self, exc_type, exc, traceback)\n \n \n-class File(Target):\n+class LocalFileSystem(FileSystem):\n+    \"\"\" Wrapper for access to file system operations\n+\n+    Work in progress - add things as needed\n+    \"\"\"\n+    def exists(self, path):\n+        return os.path.exists(path)\n+\n+    def mkdir(self, path):\n+        os.makedirs(path)\n+\n+    def isdir(self, path):\n+        os.path.isdir(path)\n+\n+    def remove(self, path, recursive=True):\n+        if recursive and self.isdir(path):\n+            shutil.rmtree(path)\n+        else:\n+            os.remove(path)\n+\n+\n+class File(FileSystemTarget):\n+    fs = LocalFileSystem()\n+\n     def __init__(self, path=None, format=None, is_tmp=False):\n         if not path:\n             if not is_tmp:\n                 raise Exception('path or is_tmp must be set')\n             path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n-        self.path = path\n+        super(File, self).__init__(path)\n         self.format = format\n         self.is_tmp = is_tmp\n \n-    def exists(self):\n-        return os.path.exists(self.path)\n-\n     def open(self, mode='r'):\n         if mode == 'w':\n             # Create folder if it does not exist\n@@ -84,19 +105,19 @@ class File(Target):\n             raise RuntimeError('Destination exists: %s' % new_path)\n         d = os.path.dirname(new_path)\n         if not os.path.exists(d):\n-            os.makedirs(d)\n+            self.fs.mkdir(d)\n         os.rename(self.path, new_path)\n \n     def move_dir(self, new_path):\n         self.move(new_path)\n \n     def remove(self):\n-        os.remove(self.path)\n+        self.fs.remove(self.path)\n \n     @property\n     def fn(self):\n         return self.path\n \n     def __del__(self):\n-        if self.is_tmp and os.path.exists(self.path):\n+        if self.is_tmp and self.exists():\n             self.remove()\n",
          "files_name_in_blame_commit": [
            "hive.py",
            "target.py",
            "target_test.py",
            "file_test.py",
            "file.py",
            "hive_test.py",
            "hdfs.py"
          ]
        }
      },
      "5c77d782b1cad537b63559fa162c61999a371f23": {
        "commit": {
          "commit_id": "5c77d782b1cad537b63559fa162c61999a371f23",
          "commit_message": "Added a test option to JobTask that samples data and then runs the job locally.\n\nChange-Id: I5098e703d8ec5c58defb89190bf68ef4f503d40c\nReviewed-on: https://gerrit.spotify.net/gerrit/19006\nTC-Compile-And-Test: teamcity teamcity <teamcity@spotify.com>\nReviewed-by: Fabian Alenius <fabian@spotify.com>",
          "commit_author": "Fabian Alenius",
          "commit_date": "2012-08-08 09:15:23",
          "commit_parent": "70d5b543d9316cd6048f7caf7123708b08aa265e"
        },
        "function": {
          "function_name": "move",
          "function_code_before": "",
          "function_code_after": "def move(self, new_path, fail_if_exists=False):\n    if fail_if_exists and os.path.exists(new_path):\n        raise RuntimeError('Destination exists: %s' % new_path)\n    d = os.path.dirname(new_path)\n    if not os.path.exists(d):\n        os.makedirs(d)\n    os.rename(self.path, new_path)",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 55,
          "function_after_end_line": 61,
          "function_before_token_count": 0,
          "function_after_token_count": 67,
          "functions_name_modified_file": [
            "__init__",
            "exists",
            "close",
            "__del__",
            "remove",
            "fn",
            "move",
            "open",
            "tmp_path"
          ],
          "functions_name_all_files": [
            "__init__",
            "exists",
            "close",
            "__del__",
            "remove",
            "fn",
            "move",
            "open",
            "tmp_path"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": []
        },
        "file": {
          "file_name": "file.py",
          "file_nloc": 51,
          "file_complexity": 19,
          "file_token_count": 383,
          "file_before": "import os\nimport random\n\n\nclass atomic_file(file):\n    # Simple class that writes to a temp file and moves it on close()\n    # Also cleans up the temp file if close is not invoked\n    def __init__(self, path):\n        self.__tmp_path = path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n        self.path = path\n        super(atomic_file, self).__init__(self.__tmp_path, 'w')\n\n    def close(self):\n        super(atomic_file, self).close()\n        os.rename(self.__tmp_path, self.path)\n\n    def __del__(self):\n        if os.path.exists(self.__tmp_path):\n            os.remove(self.__tmp_path)\n\n    @property\n    def tmp_path(self):\n        return self.__tmp_path\n\n\nclass File(object):\n    def __init__(self, path, format=None):\n        self.path = path\n        self.format = format\n\n    def exists(self):\n        return os.path.exists(self.path)\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            # Create folder if it does not exist\n            normpath = os.path.normpath(self.path)\n            parentfolder = os.path.dirname(normpath)\n            if not os.path.exists(parentfolder):\n                os.makedirs(parentfolder)\n\n            if self.format:\n                return self.format.pipe_writer(atomic_file(self.path))\n            else:\n                return atomic_file(self.path)\n\n        elif mode == 'r':\n            if self.format:\n                return self.format.pipe_reader(file(self.path))\n            else:\n                return open(self.path, mode)\n        else:\n            raise Exception('mode must be r/w')\n\n    def remove(self):\n        os.remove(self.path)\n\n    @property\n    def fn(self):\n        return self.path\n",
          "file_after": "import os\nimport random\n\n\nclass atomic_file(file):\n    # Simple class that writes to a temp file and moves it on close()\n    # Also cleans up the temp file if close is not invoked\n    def __init__(self, path):\n        self.__tmp_path = path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)\n        self.path = path\n        super(atomic_file, self).__init__(self.__tmp_path, 'w')\n\n    def close(self):\n        super(atomic_file, self).close()\n        os.rename(self.__tmp_path, self.path)\n\n    def __del__(self):\n        if os.path.exists(self.__tmp_path):\n            os.remove(self.__tmp_path)\n\n    @property\n    def tmp_path(self):\n        return self.__tmp_path\n\n\nclass File(object):\n    def __init__(self, path, format=None):\n        self.path = path\n        self.format = format\n\n    def exists(self):\n        return os.path.exists(self.path)\n\n    def open(self, mode='r'):\n        if mode == 'w':\n            # Create folder if it does not exist\n            normpath = os.path.normpath(self.path)\n            parentfolder = os.path.dirname(normpath)\n            if not os.path.exists(parentfolder):\n                os.makedirs(parentfolder)\n\n            if self.format:\n                return self.format.pipe_writer(atomic_file(self.path))\n            else:\n                return atomic_file(self.path)\n\n        elif mode == 'r':\n            if self.format:\n                return self.format.pipe_reader(file(self.path))\n            else:\n                return open(self.path, mode)\n        else:\n            raise Exception('mode must be r/w')\n\n    def move(self, new_path, fail_if_exists=False):\n        if fail_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if not os.path.exists(d):\n            os.makedirs(d)\n        os.rename(self.path, new_path)\n\n    def remove(self):\n        os.remove(self.path)\n\n    @property\n    def fn(self):\n        return self.path\n",
          "file_patch": "@@ -52,6 +52,14 @@ class File(object):\n         else:\n             raise Exception('mode must be r/w')\n \n+    def move(self, new_path, fail_if_exists=False):\n+        if fail_if_exists and os.path.exists(new_path):\n+            raise RuntimeError('Destination exists: %s' % new_path)\n+        d = os.path.dirname(new_path)\n+        if not os.path.exists(d):\n+            os.makedirs(d)\n+        os.rename(self.path, new_path)\n+\n     def remove(self):\n         os.remove(self.path)\n \n",
          "files_name_in_blame_commit": [
            "file.py"
          ]
        }
      }
    }
  }
}
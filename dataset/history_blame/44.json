{
  "id": "44",
  "blame_commit": {
    "commit": {
      "commit_id": "d16cce89521c84fcb9c7b7bb2e95629a6fe7acb7",
      "commit_message": "CLN: move/reorg pandas.tools -> pandas.core.reshape\n\nxref #13634\n\nAuthor: Jeff Reback <jeff.reback@twosigma.com>\n\nCloses #16032 from jreback/move_tools and squashes the following commits:\n\n376cef5 [Jeff Reback] move to_numeric\ncc6e059 [Jeff Reback] CLN: move/reorg pandas.tools -> pandas.core.reshape",
      "commit_author": "Jeff Reback",
      "commit_date": "2017-04-18 06:10:54",
      "commit_parent": "0ba305b15713aac0ada62e13768732485e374902"
    },
    "function": {
      "function_name": "_get_merge_keys",
      "function_code_before": "",
      "function_code_after": "def _get_merge_keys(self):\n    \"\"\"\n        Note: has side effects (copy/delete key columns)\n\n        Parameters\n        ----------\n        left\n        right\n        on\n\n        Returns\n        -------\n        left_keys, right_keys\n        \"\"\"\n    left_keys = []\n    right_keys = []\n    join_names = []\n    right_drop = []\n    left_drop = []\n    (left, right) = (self.left, self.right)\n    is_lkey = lambda x: isinstance(x, (np.ndarray, Series)) and len(x) == len(left)\n    is_rkey = lambda x: isinstance(x, (np.ndarray, Series)) and len(x) == len(right)\n    if _any(self.left_on) and _any(self.right_on):\n        for (lk, rk) in zip(self.left_on, self.right_on):\n            if is_lkey(lk):\n                left_keys.append(lk)\n                if is_rkey(rk):\n                    right_keys.append(rk)\n                    join_names.append(None)\n                elif rk is not None:\n                    right_keys.append(right[rk]._values)\n                    join_names.append(rk)\n                else:\n                    right_keys.append(right.index)\n                    join_names.append(right.index.name)\n            else:\n                if not is_rkey(rk):\n                    if rk is not None:\n                        right_keys.append(right[rk]._values)\n                    else:\n                        right_keys.append(right.index)\n                    if lk is not None and lk == rk:\n                        if len(left) > 0:\n                            right_drop.append(rk)\n                        else:\n                            left_drop.append(lk)\n                else:\n                    right_keys.append(rk)\n                if lk is not None:\n                    left_keys.append(left[lk]._values)\n                    join_names.append(lk)\n                else:\n                    left_keys.append(left.index)\n                    join_names.append(left.index.name)\n    elif _any(self.left_on):\n        for k in self.left_on:\n            if is_lkey(k):\n                left_keys.append(k)\n                join_names.append(None)\n            else:\n                left_keys.append(left[k]._values)\n                join_names.append(k)\n        if isinstance(self.right.index, MultiIndex):\n            right_keys = [lev._values.take(lab) for (lev, lab) in zip(self.right.index.levels, self.right.index.labels)]\n        else:\n            right_keys = [self.right.index.values]\n    elif _any(self.right_on):\n        for k in self.right_on:\n            if is_rkey(k):\n                right_keys.append(k)\n                join_names.append(None)\n            else:\n                right_keys.append(right[k]._values)\n                join_names.append(k)\n        if isinstance(self.left.index, MultiIndex):\n            left_keys = [lev._values.take(lab) for (lev, lab) in zip(self.left.index.levels, self.left.index.labels)]\n        else:\n            left_keys = [self.left.index.values]\n    if left_drop:\n        self.left = self.left.drop(left_drop, axis=1)\n    if right_drop:\n        self.right = self.right.drop(right_drop, axis=1)\n    return (left_keys, right_keys, join_names)",
      "function_before_start_line": "",
      "function_before_end_line": "",
      "function_after_start_line": 755,
      "function_after_end_line": 864,
      "function_before_token_count": 0,
      "function_after_token_count": 584,
      "functions_name_modified_file": [
        "_get_cython_type",
        "_get_multiindex_indexer",
        "_asof_key",
        "_any",
        "_maybe_add_join_keys",
        "_get_single_indexer",
        "_get_merge_keys",
        "_maybe_coerce_merge_keys",
        "_asof_function",
        "_indicator_post_merge",
        "ordered_merge",
        "_get_join_info",
        "_factorize_keys",
        "_left_join_on_index",
        "get_result",
        "merge",
        "_should_fill",
        "_get_join_indexers",
        "_asof_by_function",
        "merge_ordered",
        "_sort_labels",
        "__init__",
        "_groupby_and_merge",
        "merge_asof",
        "_merger",
        "_indicator_pre_merge",
        "_validate_specification",
        "_right_outer_join",
        "_get_join_keys",
        "_get_cython_type_upcast"
      ],
      "functions_name_all_files": [
        "check_for_ordered",
        "test_join_on_series_buglet",
        "test_pivot_no_values",
        "test_datetime64tz_aware",
        "identical",
        "test_ix_setitem_slice_dataframe",
        "order",
        "_is_ts_plot",
        "_python_apply_general",
        "_write_cell",
        "_get_levels",
        "test_invalid_suffixtype",
        "describe",
        "_string_data_error",
        "_validate_join_method",
        "test_xs",
        "test_index_tolerance",
        "test_error_seen_bool",
        "equal_levels",
        "drop_duplicates",
        "test_convert_objects",
        "_write_body",
        "_format_datetime64",
        "test_different",
        "test_mixed_integer",
        "test_constructor",
        "_update_inplace",
        "_sanitize_array",
        "is_",
        "_delegate_method",
        "size",
        "test_qcut_return_intervals",
        "rolling",
        "len",
        "_get_splitter",
        "test_dataframe_dummies_subset",
        "find_common_type",
        "test_character_overlap",
        "nunique",
        "plot_frame",
        "maybe_promote",
        "test_numpy_take",
        "inferred_type",
        "_get_adjustment",
        "_reindex_columns",
        "ravel",
        "_save_chunk",
        "_get_errorbars",
        "test_wrong_num_labels",
        "_compose2",
        "test_datetimelikes_nan",
        "test_copy_astype",
        "_assure_grouper",
        "_get_formatted_index",
        "test_merge_index_singlekey_inner",
        "test_cut_pass_series_name_to_factor",
        "test_right_outer_join",
        "value_counts",
        "test_left_outer_join",
        "_get_level_values",
        "test_ensure_platform_int",
        "box",
        "_use_dynamic_x",
        "test_to_excel_xlsxwriter",
        "test_panel_index",
        "test_get_axis_number",
        "set_levels",
        "_validate_ordered",
        "test_lookup_nan",
        "test_filter",
        "_get_codes_for_values",
        "test_compound",
        "_get_hashtable_algo",
        "_generate_marginal_results_without_values",
        "maybe_color_bp",
        "_get_axes_layout",
        "test_astype_all",
        "_join_non_unique",
        "test_sem",
        "visit_List",
        "get_splitter",
        "_compare_frame_evaluate",
        "test_missing_right_by",
        "argmin",
        "make_test_panel",
        "_cython_agg_blocks",
        "test_reindex_multi",
        "test_margins_no_values_no_cols",
        "repeat",
        "test_round_trip_preserve_multiindex_names",
        "test_numpy_round",
        "_apply_broadcast",
        "to_records",
        "test_multiindex_blocks",
        "_set_result_index_ordered",
        "_get_nearest_indexer",
        "_set_categories",
        "test_by_int",
        "update",
        "_get_categories",
        "_get_join_keys",
        "test_left_merge_empty_dataframe",
        "test_dataframe_dummies_drop_first_with_na",
        "view",
        "test_downcast_limits",
        "test_on_specialized_type",
        "test_value_counts_normalized",
        "test_abs",
        "test_get_attr",
        "read_data",
        "_hashed_indexing_key",
        "_format_multicolumn",
        "test_pivot_dtaccessor",
        "_get_unique_index",
        "_compare_constructor",
        "to_feather",
        "test_merge_overlap",
        "test_tolerance",
        "conform",
        "_apply_standard",
        "_validate_categories",
        "_parse_errorbars",
        "visit_UnaryOp",
        "test_pivot_with_tz",
        "_get_na_rep",
        "_format_datetime64_dateonly",
        "save",
        "test_inf_handling",
        "_verify_integrity",
        "empty",
        "test_dict_deprecate_kwarg",
        "test_basic_sort",
        "_join_multi",
        "test_merge_on_indexes",
        "take_2d_multi",
        "test_valid_allow_exact_matches",
        "merge",
        "test_categorical_aggfunc",
        "test_qcut_nas",
        "_apply_style_colors",
        "_post_plot_logic_common",
        "test_mean",
        "test_setitem_ndarray",
        "notnull",
        "test_to_panel_na_handling",
        "test_categorical_dtype",
        "test_ctor_orderedDict",
        "test_constructor_resize",
        "_partial_tup_index",
        "from_codes",
        "test_merge_nan_right",
        "test_multiindex",
        "lreshape",
        "test_join_append_timedeltas",
        "test_axis_dummies",
        "test_identical",
        "_make_selectors",
        "_getitem_slice",
        "plt",
        "_combine_series_infer",
        "is_categorical",
        "build_extensions",
        "test_strings",
        "test_get_plane_axes",
        "get_group",
        "test_value_counts_bins",
        "is_interval",
        "test_tolerance_forward",
        "_get_group_keys",
        "test_duplicated_with_nas",
        "test_update_raise",
        "test_datetime_with_timezone",
        "sortlevel",
        "test_concat_different_kind",
        "test_join_index_mixed",
        "_get_index_name",
        "dot",
        "write_th",
        "visit_Call_35",
        "test_select",
        "test_value_counts_int",
        "test_on_specialized_type_by_int",
        "test_pivot_complex_aggfunc",
        "_generate_marginal_results",
        "_add_numeric_methods",
        "__set__",
        "_set_name",
        "to_dense",
        "test_handle_overlap",
        "test_neg",
        "_normalize",
        "test_binary_operators",
        "test_merge_join_key_dtype_cast",
        "test_int64_add_overflow",
        "_check_view",
        "_coerce_scalar_to_index",
        "last_valid_index",
        "test_keys",
        "test_infinity_sort",
        "_evaluate_with_timedelta_like",
        "_add_margins",
        "test_timedelta_mode",
        "visit_Index",
        "_assert_same_contents",
        "_is_type",
        "dropna",
        "line",
        "astype_nansafe",
        "maybe_upcast",
        "_get_na_value",
        "groups",
        "_setitem_array",
        "test_number_mode",
        "swaplevel",
        "test_transpose_copy",
        "test_iteritems",
        "write_td",
        "_format_value",
        "test_get_unique",
        "test_to_coo_text_names_text_row_levels_nosort_col_level_single",
        "test_qcut_include_lowest",
        "_decide_output_index",
        "test_datetime_likes",
        "generate",
        "_get_formatter",
        "nbytes",
        "tolist",
        "recons_labels",
        "cummin",
        "test_monthly",
        "test_basic_left_index",
        "codes",
        "melt",
        "test_combine_series",
        "__init__",
        "test_to_dense_preserve_name",
        "_maybe_transform_eq_ne",
        "df",
        "contains",
        "test_allow_exact_matches_forward",
        "_try_visit_binop",
        "adjoin",
        "test_ix_align",
        "test_merge_on_periods",
        "test_crosstab_dropna",
        "test_duplicate_argument",
        "set_names",
        "get_indexer_for",
        "set_eng_float_format",
        "test_qcut_duplicates_bin",
        "_maybe_right_yaxis",
        "_validate_index_level",
        "test_quantile",
        "_get_format_datetime64_from_values",
        "on_right",
        "test_method_signatures",
        "_restrict_to_columns",
        "major_xs",
        "std",
        "test_basic2",
        "test_no_overlap_more_informative_error",
        "visit_NameConstant",
        "_right_outer_join",
        "__sizeof__",
        "justify",
        "_box_item_values",
        "test_setslice",
        "test_pivot_table_dropna",
        "names",
        "get_result_as_array",
        "test_merge_on_multikey",
        "var",
        "translate_In",
        "test_concat_different_fill",
        "not_hashable",
        "test_constructor_empty_panel",
        "_maybe_downcast_constants",
        "sort_index",
        "test_combine_first",
        "test_panel_join",
        "_selection_list",
        "test_invalid",
        "_get_join_indexers",
        "assign",
        "to_period",
        "from_array",
        "_can_reindex",
        "tokenize_string",
        "_choose_path",
        "test_join_many_non_unique_index",
        "test_to_coo_integer_names_integer_row_levels_nosort",
        "test_join_on_series",
        "test_merge_on_datetime64tz",
        "max",
        "test_isleapyear_deprecate",
        "from_records",
        "pivot_simple",
        "generate_bins_generic",
        "test_col_level",
        "test_validate_bool_kwarg",
        "_setup_subplots",
        "test_invalid_input",
        "has_index_names",
        "test_pass_array",
        "_set_values",
        "_set_names",
        "flags",
        "_compute_grand_margin",
        "_filter_indexer_tolerance",
        "_homogenize_dict",
        "_wrap_aggregated_output",
        "__copy__",
        "test_num_string_disambiguation",
        "_args_adjust",
        "test_set_minor_major",
        "test_update_from_dict",
        "test_join_on",
        "_reorder_arrays",
        "_save",
        "_decorate_ticks",
        "to_native_types",
        "test_constructor_error_msgs",
        "_from_nested_dict",
        "_sanitize_column",
        "test_get_locales",
        "test_astype",
        "_format_header",
        "_engine",
        "_asof_by_function",
        "maybe_convert_objects",
        "_get_values_tuple",
        "_is_memory_usage_qualified",
        "_maybe_update_attributes",
        "__setstate__",
        "test_large",
        "test_dataframe_dummies_prefix_sep_bad_length",
        "has_duplicates",
        "_ts_plot",
        "test_getitem_fancy_labels",
        "_reindex_multi",
        "_formatter_func",
        "_gca",
        "_convert_can_do_setop",
        "write",
        "hasnans",
        "_make_plot_keywords",
        "nlevels",
        "test_numpy_errstate_is_default",
        "test_strobj_mode",
        "test_numeric_object_likes",
        "test_isnull",
        "visit",
        "barh",
        "to_stata",
        "_compare_frame",
        "_construct_return_type",
        "_set_codes",
        "test_to_coo_text_names_integer_row_levels_nosort",
        "test_inner_join",
        "test_update_nooverwrite",
        "test_constructor_nonnan",
        "_assert_take_fillable",
        "fast_apply",
        "_ixs",
        "test_panel_join_overlap",
        "groupby",
        "_is_v2",
        "test_join_hierarchical_mixed",
        "_deepcopy_if_needed",
        "_initialize_stacker",
        "test_pivot_table",
        "_cython_agg_general",
        "test_getitem_callable",
        "style",
        "_get_labels",
        "remove_categories",
        "maybe_downcast_to_dtype",
        "test_update",
        "test_single_quantile",
        "check_cython_extensions",
        "_reset_identity",
        "is_integer",
        "_prep_ndarray",
        "test_period_weekly",
        "test_bins",
        "_apply_filter",
        "test_allow_exact_matches_and_tolerance2",
        "write_result",
        "to_excel",
        "_list_of_series_to_arrays",
        "_assert_can_do_setop",
        "test_get_get_value",
        "mean",
        "test_join_on_fails_with_different_left_index",
        "_unpickle_matrix_compat",
        "_aggregate_named",
        "reindex",
        "_get_cython_function",
        "test_escapable_characters",
        "_join_compat",
        "test_median",
        "get_duplicates",
        "test_join_on_singlekey_list",
        "_get_dummies_1d",
        "test_allow_exact_matches_and_tolerance3",
        "test_from_coo_nodense_index",
        "test_pivot_table_margins_name_with_aggfunc_list",
        "query",
        "to_datetime",
        "from_items",
        "test_pickle",
        "_maybe_eval",
        "test_construct_DataFrame_with_sp_series",
        "transpose",
        "test_index_and_on_parameters_confusion",
        "_validate_names",
        "_get_formatted_column_labels",
        "_apply_raw",
        "test_merge_different_column_key_names",
        "test_to_panel_duplicates",
        "test_left_join_index_multi_match",
        "map",
        "test_allow_exact_matches_nearest",
        "test_panel_dups",
        "is_floating",
        "test_basic_right_index",
        "test_copy_names",
        "test_getitem",
        "test_with_duplicates_no_on",
        "_check_merge",
        "stack",
        "eval",
        "tshift",
        "safe_sort",
        "visit_Attribute",
        "unique",
        "to_csv",
        "setUp",
        "_maybe_coerce_indexer",
        "_format_header_mi",
        "ngroups",
        "test_crosstab_errors",
        "visit_Str",
        "take_nd",
        "assigner",
        "_apply_axis_properties",
        "__bytes__",
        "to_html",
        "run",
        "get_indexer",
        "test_from_coo_dense_index",
        "between",
        "_get_level_number",
        "test_to_dense_fill_value",
        "test_constructor_dict_mixed",
        "_repr_categories_info",
        "indices",
        "_combine",
        "test_merge_left_empty_right_notempty",
        "_maybe_cast_slice_bound",
        "test_shape",
        "iterrows",
        "test_allow_exact_matches_and_tolerance_nearest",
        "concat_wrap",
        "test_numpy_cumsum",
        "duplicated",
        "test_empty",
        "_validate_specification",
        "_test_data1_zero",
        "pad",
        "right",
        "to_panel",
        "test_maybe_convert_scalar",
        "test_get_axis_name",
        "left",
        "_apply_2d",
        "test_dataframe_dummies_with_na",
        "_flex_compare_frame",
        "_getitem_array",
        "test_std",
        "_check_all",
        "test_panel_join_many",
        "test_examples2",
        "_aggregate_series_pure_python",
        "_nbytes",
        "get_result",
        "_ensure_data",
        "test_vector_resize",
        "droplevel",
        "test_min",
        "test_basic_drop_first",
        "to_frame",
        "test_unsortable",
        "symmetric_difference",
        "_set_levels",
        "_convert_object_array",
        "_reindex_index",
        "test_categorical_pivot_index_ordering",
        "test_object_refcount_bug",
        "itertuples",
        "_get_merge_keys",
        "test_series_numeric",
        "_get_names",
        "test_value_counts_dup",
        "__getattr__",
        "test_cut_corner",
        "test_timedelta64_dtype_array_returned",
        "infer_dtype_from_array",
        "_bounds",
        "__getitem__",
        "test_crosstab_margins",
        "test_combineFunc",
        "maybe_convert_platform",
        "test_merge_left_notempty_right_empty",
        "_init_data",
        "reshape",
        "_save_header",
        "test_concat_axis1_different_fill",
        "remove_unused_levels",
        "_getitem_frame",
        "nonzero",
        "_get_data_to_aggregate",
        "from_arrays",
        "__str__",
        "test_multiby",
        "test_dataframe_dummies_with_categorical",
        "test_cannot_create_instance_of_stolenbuffer",
        "ftypes",
        "test_cython_right_outer_join",
        "_list_of_dict_to_arrays",
        "set_labels",
        "_get_loc_only_exact_matches",
        "_get_multiindex_indexer",
        "test_constructor_scalar",
        "idxmin",
        "test_pivot_periods",
        "test_pivot_timegrouper",
        "__setattr__",
        "visit_Call_legacy",
        "strides",
        "test_pivot_multi_values",
        "pxd",
        "test_left_join_index_preserve_order",
        "get_loc_level",
        "test_basic_types",
        "is_valid_dtype_n_method",
        "visit_Div",
        "test_join_inner_multiindex",
        "_unstack_frame",
        "merge_ordered",
        "test_daily",
        "_slice",
        "__getslice__",
        "test_isnotnull",
        "test_to_coo_bad_partition_nonnull_intersection",
        "_chop",
        "test_allow_exact_matches_and_tolerance_forward",
        "_cython_transform",
        "__iter__",
        "_make_dt_accessor",
        "_format_regular_rows",
        "_needs_reindex_multi",
        "_start_base",
        "test_ix_frame_align",
        "_repr_fits_vertical_",
        "_make_labels",
        "maybe_upcast_putmask",
        "_convert_listlike_indexer",
        "test_not_all_none",
        "test_to_frame",
        "test_truncate_fillna_bug",
        "test_all_any_unhandled",
        "_dispatch",
        "_can_hold_na",
        "test_to_frame_multi_major_minor",
        "test_merge_misspecified",
        "test_mode_single",
        "test_multiby_heterogeneous_types",
        "__or__",
        "test_set_locale",
        "_reconstruct_data",
        "_add_logical_methods_disabled",
        "_set_item",
        "test_get_axis",
        "is_lexsorted_for_tuple",
        "_convert_slice_indexer",
        "_extract_axes_for_slice",
        "_combine_panel",
        "_sanitize_index",
        "dtype",
        "test_take",
        "searchsorted",
        "test_basic_categorical",
        "test_merge_inner_join_empty",
        "test_pad_backfill_object_segfault",
        "test_vars_work_with_multiindex",
        "format_array",
        "_gcf",
        "_aggregate_series_fast",
        "remove_unused_categories",
        "_binop",
        "test_compress_group_combinations",
        "test_repr",
        "mpl_ge_1_3_1",
        "truncate",
        "test_intelligently_handle_join_key",
        "_format_header_regular",
        "test_value_counts_dtypes",
        "_get_repr",
        "_indicator_post_merge",
        "test_handle_overlap_arbitrary_key",
        "test_pivot_columns_lexsorted",
        "test_full_outer_join",
        "test_left_join_index_multi_match_multiindex",
        "test_hourly",
        "take",
        "test_crosstab_with_empties",
        "axes",
        "_ensure_valid_index",
        "union",
        "_format_body",
        "test_merge_nocopy",
        "test_callable_deprecate_kwarg",
        "_wrap_applied_output",
        "test_cython_inner_join",
        "test_pivot_table_nocols",
        "test_nearest_by",
        "dtypes",
        "nth",
        "test_numeric_dtypes",
        "test_bad_arg_length_max_value_single",
        "get_formatted_cells",
        "corrwith",
        "test_str",
        "test_to_sparse",
        "_ensure_arraylike",
        "_repr_categories",
        "test_value_vars_types",
        "to_hierarchical",
        "test_downcast",
        "_convert_grouper",
        "test_margin_dropna",
        "_max_groupsize",
        "_convert_wrapper",
        "test_mixed_dtype",
        "_coerce_method",
        "test_join_on_fails_with_different_column_counts",
        "_get_compressed_labels",
        "result",
        "test_allow_exact_matches",
        "test_crosstab_multiple",
        "_indicator_pre_merge",
        "_mpl_repr",
        "_format_hierarchical_rows",
        "_make_sorted_values_labels",
        "test_on_float",
        "test_to_coo_bad_partition_small_union",
        "_init_ndarray",
        "test_custom_var_name",
        "_gotitem",
        "test_truncate",
        "test_get_locales_prefix",
        "soft_convert_objects",
        "_any",
        "lookup",
        "test_constructor_dtype",
        "_get_colors",
        "argmax",
        "_unpickle_frame_compat",
        "__and__",
        "test_other_timedelta_unit",
        "is_unique",
        "test_to_frame_mixed",
        "test_handle_join_key_pass_array",
        "test_crosstab_with_numpy_size",
        "_shallow_copy_with_infer",
        "get_value",
        "_getitem_column",
        "test_categorical",
        "_aggregate_multiple_funcs",
        "test_merge_index_singlekey_right_vs_left",
        "test_merge_nosort",
        "test_basic_no_by",
        "is_object",
        "test_join_float64_float32",
        "maybe_to_categorical",
        "test_multi_index",
        "test_index",
        "_homogenize",
        "test_dtypes",
        "test_join_on_fails_with_wrong_object_type",
        "_ensure_index",
        "visit_Compare",
        "test_consolidate",
        "_get_sorted_data",
        "is_dtype_equal",
        "test_repr_empty",
        "_reindex_non_unique",
        "group_index",
        "minor_xs",
        "_assert_all_na",
        "test_arith",
        "_get_subplots",
        "test_tolerance_tz",
        "format_percentiles",
        "test_raise_when_not_implemented",
        "test_value_counts_nat",
        "ftype",
        "isin",
        "_aggregate",
        "maybe_cast_item",
        "hist_series",
        "test_pad",
        "test_concat_sparse_dense",
        "test_unique_label_indices",
        "test_with_duplicates",
        "test_merge_na_keys",
        "_evalute_compare",
        "test_merge_non_unique_indexes",
        "test_left_merge_na_buglet",
        "asobject",
        "test_int_int",
        "median",
        "visit_Expr",
        "test_from_coo_long_repr",
        "test_dataframe_dummies_preserve_categorical_dtype",
        "test_backfill",
        "autocorr",
        "test_from_frame_level1_unsorted",
        "test_cython_left_outer_join",
        "__reduce__",
        "_wrap_union_result",
        "disallow",
        "wide_to_long",
        "_unpickle_panel_compat",
        "test_rands",
        "get_console_size",
        "_add_legend_handle",
        "test_left_join_multi_index",
        "cov",
        "test_group_var_generic_2d_some_nan",
        "combine_first",
        "unstack",
        "_convert_tolerance",
        "test_apply_no_or_zero_ndim",
        "test_bad_min_fname_arg_count",
        "_selected_obj",
        "_is_cython_func",
        "_have_mixed_levels",
        "_maybe_coerce_merge_keys",
        "test_pivot_integer_columns",
        "_grouped_plot",
        "mode",
        "_combine_match_index",
        "test_allow_exact_matches_and_tolerance",
        "_write_hierarchical_rows",
        "test_conform",
        "difference",
        "test_set_value",
        "test_stubs",
        "_groupby_and_merge",
        "applymap",
        "test_list",
        "test_qcut_bounds",
        "_insert_inaxis_grouper_inplace",
        "select_dtypes",
        "_format_data",
        "test_getitem_fancy_xs",
        "test_list_numeric",
        "_reduce",
        "scatter_plot",
        "set_categories",
        "backfill",
        "sort_idx",
        "_setitem_slice",
        "visit_Slice",
        "test_too_many_ndims",
        "test_forward_by",
        "is_platform_mac",
        "_list_to_arrays",
        "_wrap_result",
        "_combine_match_columns",
        "_add_delegate_accessors",
        "test_basic",
        "_get_codes",
        "test_indicator",
        "test_to_string",
        "join",
        "_convert_arr_indexer",
        "format",
        "real",
        "_extract_axes",
        "pivot_table",
        "test_scalar",
        "_repr_html_",
        "get_loc",
        "test_categorical_margins",
        "test_join_with_len0",
        "test_shift_dtype",
        "test_no_args_with_kwargs",
        "_delegate_property_set",
        "test_bad_deprecate_kwarg",
        "to_timestamp",
        "_set_ticklabels",
        "shape",
        "checked_add_with_arr",
        "_get_cython_type_upcast",
        "test_constructor_fails_with_not_3d_input",
        "_print_cline",
        "test_constructor_ndarray",
        "test_basic_drop_first_one_level",
        "test_cumsum",
        "_left_join_on_index",
        "_check_stat_op",
        "test_all_any",
        "_join_monotonic",
        "test_constructor_observe_dtype",
        "test_update_filtered",
        "detect_console_encoding",
        "_invalid_indexer",
        "reset_index",
        "__nonzero__",
        "test_basic_left_index_right_index",
        "test_series",
        "_repr_fits_horizontal_",
        "_append_same_dtype",
        "tearDownClass",
        "get_locs",
        "test_cut_out_of_range_more",
        "test_other_datetime_unit",
        "_get_column_name_list",
        "test_pairs",
        "test_bad_arg_length_max_value_multiple",
        "_get_join_info",
        "test_constructor_empty",
        "test_to_excel",
        "__array__",
        "visit_BoolOp",
        "_should_fill",
        "_from_elements",
        "test_order_of_appearance",
        "_try_get_item",
        "sem",
        "levshape",
        "cumcount",
        "_get_indices",
        "test_custom_value_name",
        "test_apply_slabs",
        "test_single_bin",
        "_values_for_rank",
        "test_labels",
        "coerce_indexer_dtype",
        "test_objects",
        "test_sum",
        "test_crosstab_normalize",
        "test_set_axis",
        "test_dataframe_dummies_prefix_bad_length",
        "put",
        "test_na_handling",
        "slice_locs",
        "ndim",
        "delete",
        "plot_series",
        "test_ffill_bfill",
        "test_interned",
        "result_index",
        "test_int_df",
        "info",
        "test_join_multiindex",
        "_write_header",
        "_define_paths",
        "test_join_unconsolidated",
        "test_dataframe_dummies_mix_default",
        "test_dataframe_dummies_all_obj",
        "cumprod",
        "test_bins_from_intervalindex",
        "_constructor_expanddim",
        "is_boolean",
        "test_merge_common",
        "_set_subtyp",
        "_add_numeric_methods_disabled",
        "set_index",
        "test_var",
        "_compute_plot_data",
        "slabels",
        "tail",
        "_get_ax_layer",
        "add_categories",
        "test_pivot_no_level_overlap",
        "keys",
        "_get_stacking_id",
        "test_groupsort_indexer",
        "get_indexer_non_unique",
        "test_qcut",
        "match",
        "_values",
        "_wrap_transformed_output",
        "ohlc",
        "test_tolerance_nearest",
        "_unstack_multiple",
        "test_invert",
        "test_group_var_constant",
        "compress",
        "_try_aggregate_string_function",
        "test_datetime_cut",
        "cartesian_product",
        "test_timedelta",
        "_test_op",
        "test_value_vars",
        "_reindex_output",
        "_is_label_like",
        "test_exceptions",
        "test_weekly",
        "test_qcut_binning_issues",
        "is_all_dates",
        "test_pivot_table_with_margins_set_margin_name",
        "test_valid_join_keys",
        "test_include_na",
        "test_i8",
        "slice_indexer",
        "test_crosstab_ndarray",
        "test_constructor_cast",
        "has_column_names",
        "_get_stacked_values",
        "is_lexsorted",
        "_reference_duplicate_name",
        "crosstab",
        "test_non_hashable",
        "test_margins_no_values_two_row_two_cols",
        "_take_nd_object",
        "visit_Assign",
        "_convert_index_indexer",
        "__radd__",
        "test_simple",
        "_get_take_nd_function",
        "test_group_var_generic_2d_all_finite",
        "item",
        "_concat_objects",
        "test_scipy_compat",
        "test_join_dups",
        "__repr__",
        "is_type_compatible",
        "__setitem__",
        "test_complex_sorting",
        "_get_level_indexer",
        "test_basic_left_by_right_by",
        "test_qcut_all_bins_same",
        "get_slice_bound",
        "_unpickle_series_compat",
        "set_value",
        "_asof_function",
        "test_getitem_fancy_slice",
        "_format_col",
        "test_join_on_inner",
        "_get_xticks",
        "_try_cast",
        "__array_prepare__",
        "_get_with",
        "summary",
        "_combine_series",
        "parse",
        "values",
        "test_merge_non_unique_index_many_to_many",
        "_get_join_index",
        "_get_ordered",
        "_dir_deletions",
        "_get_fill_indexer_searchsorted",
        "test_margins",
        "_selection_name",
        "_stack_multi_columns",
        "test_type_check",
        "right_df",
        "_drop_from_level",
        "_has_complex_internals",
        "area",
        "test_error",
        "__new__",
        "test_missing_deprecate_kwarg",
        "_filter_nodes",
        "visit_Num",
        "expanding",
        "_get_format_datetime64",
        "_apply_empty_result",
        "_is_indexed_like",
        "_delegate_property_get",
        "as_ordered",
        "build_extension",
        "is_numeric",
        "_value_formatter",
        "_test_data2_zero",
        "_make_fixed_width",
        "_ensure_like_indices",
        "asof_locs",
        "test_merge_left_empty_right_empty",
        "_transform_fast",
        "test_uint64_factorize",
        "test_rename",
        "_get_data_algo",
        "test_groupby_withnull",
        "__len__",
        "factorize",
        "transform",
        "_put_lines",
        "_reverse_indexer",
        "astype",
        "test_numpy_func_call",
        "_test_data1",
        "test_value_counts_uint64",
        "test_shift",
        "_get_level_lengths",
        "_getitem_multilevel",
        "_inferred_type_levels",
        "apply",
        "ordered_merge",
        "test_swapaxes",
        "test_constructor_preserve_attr",
        "_wrap_output",
        "cummax",
        "test_qcut_index",
        "test_datetime64_dtype_array_returned",
        "where",
        "_factorize_from_iterable",
        "_write_regular_rows",
        "to_gbq",
        "__unicode__",
        "_setitem_frame",
        "test_major_xs",
        "test_on_and_index",
        "test_custom_var_and_value_name",
        "test_datetimetz_dtype",
        "test_iteration_and_str",
        "test_series_retbins",
        "to_latex",
        "_dir_additions",
        "_add_logical_methods",
        "test_sparse_to_dense",
        "test_all_nan",
        "corr",
        "_series",
        "_reindex_axes",
        "test_dataframe_dummies_prefix_dict",
        "_add_table",
        "test_series_density",
        "_combine_frame",
        "_check_join",
        "test_sparse_reindex",
        "test_drop",
        "test_arraylike",
        "levels",
        "boxplot",
        "_set_with",
        "_index_with_as_index",
        "test_prod",
        "__delete__",
        "set_ordered",
        "_scalar_data_error",
        "_add_aggregate_operations",
        "_cleanup",
        "test_constructor_dtypes",
        "_reset_group_selection",
        "single_column_table",
        "to_dict",
        "test_pivot_index_with_nan",
        "test_pass_function",
        "test_delitem_and_pop",
        "_aggregate_item_by_item",
        "as_unordered",
        "nsmallest",
        "_init_dict",
        "legend_title",
        "test_shift_dtype_fill_value",
        "_count_level",
        "test_rank",
        "_get_grouper",
        "test_join_on_fails_with_different_right_index",
        "scatter",
        "itemsize",
        "_repr_latex_",
        "test_merge_copy",
        "_maybe_add_join_keys",
        "shift",
        "test_dropna",
        "test_pivot_table_multiple",
        "test_pivot_dtypes",
        "_add_numeric_methods_add_sub_disabled",
        "test_ops_scalar",
        "get_level_values",
        "test_factorize_nan",
        "_freeze",
        "_node_not_implemented",
        "_codes_for_groupby",
        "test_combine_scalar",
        "_get_formatted_values",
        "_wrap_generic_output",
        "_to_embed",
        "test_to_coo_bad_ilevel",
        "test_maybe_convert_objects_copy",
        "test_numeric",
        "_set_labels",
        "test_to_coo_text_names_integer_row_levels_sort",
        "_try_convert_to_int_index",
        "count",
        "_add_numeric_methods_binary",
        "_op_maker",
        "visit_Module",
        "_info_repr",
        "panel_index",
        "_get_ind",
        "get_iterator",
        "test_unique_index",
        "agg_series",
        "is_monotonic",
        "_assert_can_do_op",
        "test_validation",
        "_put_str",
        "insert",
        "_validate_color_args",
        "cumsum",
        "_make_cat_accessor",
        "left_df",
        "_slow_pivot",
        "test_apply",
        "_get_attributes_dict",
        "test_groupby",
        "first_valid_index",
        "maybe_cast_to_datetime",
        "test_dtype_on_merged_different",
        "test_fill_value_when_combine_const",
        "_extract_axis",
        "visit_BinOp",
        "_grouped_plot_by_column",
        "test_numpy_dtypes",
        "test_join_many",
        "_coerce_to_ndarray",
        "is_monotonic_increasing",
        "single_row_table",
        "_get_string_slice",
        "nlargest",
        "test_valid_tolerance",
        "maybe_convert_scalar",
        "data",
        "test_group_var_generic_1d",
        "from_dict",
        "ax",
        "__array_wrap__",
        "_combine_const",
        "get_values",
        "test_exactly_one_ref",
        "coerce_to_dtypes",
        "head",
        "sort",
        "_from_arrays",
        "__dir__",
        "test_arrmap",
        "_set_with_engine",
        "test_join_many_mixed",
        "test_merge_type",
        "test_operators",
        "test_join",
        "_format_native_types",
        "is_platform_linux",
        "test_invalid_separator",
        "_dense_series_compare",
        "is_nested_object",
        "_post_process_cython_aggregate",
        "_transform_general",
        "test_merge_right_vs_left",
        "test_noright",
        "_simple_new",
        "diff",
        "_apply_to_column_groupbys",
        "test_numeric_lists_and_arrays",
        "from_product",
        "visit_Subscript",
        "_hashed_values",
        "_trim_front",
        "argsort",
        "_new_Index",
        "__contains__",
        "_iter_data",
        "drop",
        "test_get_dummies",
        "_factorize_from_iterables",
        "test_getitem_slice",
        "_join_level",
        "test_group_var_generic_1d_flat_labels",
        "_get_consensus_name",
        "from_csv",
        "test_margins_no_values_one_row_one_col",
        "__xor__",
        "hist",
        "pie",
        "test_period",
        "test_to_coo_duplicate_index_entries",
        "make_axis_dummies",
        "extract_index",
        "_iterate_slices",
        "test_join_sort",
        "combine",
        "draw",
        "test_pivot_table_dropna_categoricals",
        "test_dataframe_dummies_drop_first",
        "_post_plot_logic",
        "test_datelike",
        "test_comparisons",
        "orientation",
        "grouped_hist",
        "_maybe_evaluate_binop",
        "test_round",
        "__call__",
        "test_overlapping_columns_error_message",
        "__deepcopy__",
        "test_from_dict_mixed_orient",
        "_validate_for_numeric_unaryop",
        "to_numeric",
        "pivot",
        "_trim_zeros",
        "test_unicode",
        "_cat_compare_op",
        "test_to_frame_multi_major",
        "to_sparse",
        "test_join_multi_levels2",
        "_get_format_timedelta64",
        "test_deprecate_kwarg",
        "_tidy_repr",
        "test_tshift",
        "test_ints",
        "reindex_axis",
        "_get_plane_axes",
        "_constructor",
        "_get_standard_kind",
        "_update_stacker",
        "reorder_categories",
        "_maybe_promote",
        "get_tag",
        "_chk_truncate",
        "_get_agg_axis",
        "_get_ax",
        "to_series",
        "test_skew",
        "test_dataframe_dummies_prefix_list",
        "maybe_castable",
        "_asof_key",
        "test_no_mode",
        "_is_dates_only",
        "sort_values",
        "_get_single_indexer",
        "finalize_options",
        "test_period_dtype",
        "test_default_col_names",
        "test_datetime_nan",
        "get_test_data",
        "_masked_rec_array_to_mgr",
        "test_iter",
        "_is_builtin_func",
        "test_crosstab_no_overlap",
        "rank",
        "test_mixed",
        "__sub__",
        "test_dataframe_dummies_prefix_str",
        "_make_wrapper",
        "_get_names_from_index",
        "to_string",
        "test_cut_return_intervals",
        "_validate_indexer",
        "test_to_coo_nlevels_less_than_two",
        "_convert_by",
        "test_sort_index",
        "_get_footer",
        "base",
        "get_new_values",
        "test_non_sorted",
        "_wrap_agged_blocks",
        "_get_fill_indexer",
        "_factorize_keys",
        "_set_group_selection",
        "test_to_sparse_preserve_multiindex_names_columns",
        "test_join_empty_bug",
        "test_count",
        "test_just_na",
        "_add_numeric_methods_unary",
        "merge_asof",
        "test_margins_no_values_two_rows",
        "test_pct_change",
        "_box_col_values",
        "srcpath",
        "_evaluate_with_datetime_like",
        "_test_data2",
        "test_round_frac",
        "_add_numeric_operations",
        "_replace_locals",
        "aggregate",
        "test_arith_flex_panel",
        "test_join_multi_dtypes",
        "__get__",
        "nkeys",
        "_has_names",
        "_format_with_header",
        "_run_test",
        "__hash__",
        "test_crosstab_single",
        "test_downcast_conv",
        "_init_matrix",
        "idxmax",
        "dtype_str",
        "__add__",
        "test_dense_to_sparse",
        "test_infer_dtype_from_scalar",
        "test_dataframe_dummies_drop_first_with_categorical",
        "_get_plane_axes_index",
        "curpath",
        "fillna",
        "_has_plotted_object",
        "setUpClass",
        "test_label_precision",
        "isnull",
        "_kind",
        "test_homogenize",
        "T",
        "get_group_levels",
        "test_sort",
        "from_tuples",
        "test_not_all_defaults",
        "bar",
        "test_transpose",
        "_format_attrs",
        "_convert_list_indexer",
        "intersection",
        "test_pivot",
        "test_pivot_table_with_iterator_values",
        "_whitelist_method_generator",
        "_validate_for_numeric_binop",
        "_transform",
        "xs",
        "test_to_coo_text_names_text_row_levels_nosort",
        "_init_arrays",
        "_sort_levels_monotonic",
        "memory_usage",
        "is_monotonic_decreasing",
        "get_new_index",
        "_cumcount_array",
        "_add_comparison_methods",
        "test_fill_value_corner",
        "_replace_booleans",
        "_cython_operation",
        "is_mixed",
        "_get_grouper_for_level",
        "visit_Name",
        "test_datetimelike",
        "test_minor_xs_mixed",
        "as_matrix",
        "test_cut_pass_labels",
        "test_getitem_fancy_xs_check_view",
        "test_period_daily",
        "test_reductions",
        "test_examples1",
        "_convert_for_op",
        "_to_arrays",
        "test_separating_character",
        "test_datetime_bin",
        "should_show_dimensions",
        "test_ctor_dict",
        "test_right",
        "compose",
        "imag",
        "test_max",
        "_join_multiline",
        "test_invalid_total_length_max_length_one",
        "_check_results_to_coo",
        "test_ops_differently_indexed",
        "_preparse",
        "filter",
        "_binify",
        "_python_agg_general",
        "test_pivot_multi_functions",
        "align",
        "test_rands_array",
        "_plot",
        "append",
        "_get_index",
        "_convert_to_list_like",
        "get_new_columns",
        "_view_wrapper",
        "rename_categories",
        "test_crosstab_with_categorial_columns",
        "invalidate_string_dtypes",
        "test_datelike_mode",
        "kde",
        "compute",
        "test_top_level_method",
        "test_major_xs_mixed",
        "group_info",
        "remove_na",
        "test_examples4",
        "test_on_float_by_int",
        "write_tr",
        "test_cut_out_of_bounds",
        "_maybe_cast_indexer",
        "_sort_labels",
        "_get_binner_for_grouping",
        "_to_str_columns",
        "_transform_item_by_item",
        "_merger",
        "groupings",
        "test_bad_kwarg",
        "test_preserve_categorical_dtype",
        "test_kind",
        "_rewrite_assign",
        "maybe_infer_to_datetimelike",
        "lexsort_depth",
        "assert_panel_equal",
        "equals",
        "rename",
        "_convert_scalar_indexer",
        "_set_axis",
        "_to_safe_for_reshape",
        "_is_v1",
        "test_shift_nan",
        "_ensure_has_len",
        "_is_mixed_type",
        "test_reindex",
        "test_group_var_large_inputs",
        "nseries",
        "test_concat",
        "test_unbalanced",
        "_format_strings",
        "test_combinePanel",
        "test_maybe_convert_string_to_array",
        "test_pivot_datetime_tz",
        "hist_frame",
        "test_basic_drop_first_NA",
        "hexbin",
        "test_combineFrame",
        "quantile",
        "_apply_1d",
        "test_qcut_specify_quantiles",
        "_format_space",
        "_wrap_joined_index",
        "_get_ax_legend",
        "_make_plot",
        "test_datetimeindex",
        "test_is_lexsorted",
        "_reset_cache",
        "maybe_convert_string_to_object",
        "_get_axes",
        "get_dummies",
        "test_get_value",
        "infer_dtype_from_scalar",
        "_join_by_hand",
        "_rewrite_membership_op",
        "_get_cython_type",
        "_isnan",
        "_take_2d_multi_object",
        "test_minor_xs",
        "_searchsorted_monotonic",
        "test_value_counts_datetime_outofbounds",
        "_iterate_column_groupbys",
        "initialize_options",
        "test_concat_axis1",
        "iteritems",
        "test_categorical_zeroes",
        "test_infer_dtype_from_array",
        "test_getitem_fancy_ints",
        "test_join_mixed_non_unique_index",
        "reorder_levels",
        "test_value_counts",
        "test_multiple_id_columns",
        "holds_integer",
        "mpl_ge_1_5_0",
        "_obj_with_exclusions",
        "test_more_than_one_ref",
        "_shallow_copy",
        "_nan_idxs",
        "labels",
        "name",
        "asof",
        "test_invalid_total_length_max_length_multiple",
        "test_uint64_overflow",
        "test_multiindex_get",
        "stack_multiple",
        "test_reindex_like",
        "test_join_multi_levels",
        "_aggregate_generic",
        "_arrays_to_mgr",
        "_get_values",
        "add_ops",
        "test_dataframe_dummies_prefix_sep",
        "test_other_columns",
        "is_platform_windows",
        "_format_multirow",
        "test_setitem",
        "putmask",
        "test_fillna",
        "copy",
        "test_crosstab_pass_values",
        "_repr_footer",
        "test_lookup_overflow",
        "test_on_index_object",
        "_adorn_subplots",
        "_make_legend",
        "test_examples3",
        "resample",
        "test_categorical_nans",
        "test_logical_with_nas",
        "test_tuple_vars_fail_with_multiindex",
        "test_period_monthly",
        "test_to_frame_multi_drop_level",
        "round",
        "_set_grouper",
        "test_mixed_type_join_with_suffix",
        "test_multiby_indexed",
        "_reindex_indexer",
        "boxplot_frame_groupby",
        "test_bins_not_monotonic",
        "_value_counts_arraylike",
        "test_join_on_pass_vector",
        "min",
        "_sparsify"
      ],
      "functions_name_co_evolved_modified_file": [
        "_get_cython_type",
        "_get_multiindex_indexer",
        "_asof_key",
        "_any",
        "_maybe_add_join_keys",
        "_get_single_indexer",
        "_maybe_coerce_merge_keys",
        "_asof_function",
        "_indicator_post_merge",
        "ordered_merge",
        "_get_join_info",
        "_factorize_keys",
        "_left_join_on_index",
        "get_result",
        "merge",
        "_should_fill",
        "_get_join_indexers",
        "_asof_by_function",
        "_sort_labels",
        "merge_ordered",
        "__init__",
        "_groupby_and_merge",
        "merge_asof",
        "_merger",
        "_indicator_pre_merge",
        "_validate_specification",
        "_right_outer_join",
        "_get_join_keys",
        "_get_cython_type_upcast"
      ],
      "functions_name_co_evolved_all_files": [
        "test_downcast_limits",
        "test_tz_convert_and_localize",
        "_asof_key",
        "test_type_check",
        "test_set_locale",
        "test_describe_none",
        "_get_single_indexer",
        "test_series_numeric",
        "test_scalar",
        "test_equals",
        "_ndim",
        "stack",
        "test_error",
        "test_metadata_propagation",
        "test_get_locales",
        "test_deepcopy_empty",
        "test_size_compat",
        "test_take",
        "test_get_numeric_data_preserve_dtype",
        "_asof_by_function",
        "test_datetimeindex",
        "melt",
        "setUp",
        "__init__",
        "test_describe_objects",
        "test_numpy_squeeze",
        "describe",
        "isin",
        "test_describe_timedelta",
        "_aggregate",
        "get_dummies",
        "_transform_general",
        "test_datetimelike",
        "test_rename_axis",
        "_get_cython_type_upcast",
        "test_error_seen_bool",
        "_get_cython_type",
        "match",
        "_apply_to_column_groupbys",
        "test_numeric_lists_and_arrays",
        "_maybe_add_join_keys",
        "from_product",
        "test_validate_bool_args",
        "test_describe_column_index_type",
        "test_describe_percentiles_equivalence",
        "test_describe_raises",
        "_indicator_post_merge",
        "test_describe_percentiles_unique",
        "test_describe_typefiltering_dupcol",
        "_factorize_keys",
        "_left_join_on_index",
        "nunique",
        "test_api_compat",
        "cartesian_product",
        "compose",
        "_axes",
        "test_get_dummies",
        "test_timedelta",
        "test_pipe_tuple",
        "merge",
        "test_describe_empty_int_columns",
        "test_unexpected_keyword",
        "test_numeric",
        "test_rename_mi",
        "test_describe_percentiles_percent_or_raw",
        "test_value_counts",
        "_compare",
        "test_rename",
        "test_squeeze",
        "merge_asof",
        "_wrap_applied_output",
        "test_describe_percentiles_insert_median_ndarray",
        "test_pct_change",
        "test_get_numeric_data",
        "test_period",
        "_right_outer_join",
        "_construct",
        "transform",
        "test_series",
        "test_numeric_dtypes",
        "test_describe_no_numeric",
        "_get_multiindex_indexer",
        "_compose2",
        "append",
        "test_pipe_panel",
        "tearDownClass",
        "test_str",
        "unstack",
        "test_get_default",
        "test_nonzero",
        "_maybe_coerce_merge_keys",
        "test_nonzero_single_element",
        "value_counts",
        "test_non_hashable",
        "ordered_merge",
        "test_describe_percentiles_formatting",
        "_get_join_info",
        "test_describe_multi_index_df_column_names",
        "test_axis_dummies",
        "test_downcast",
        "test_set_axis_name_mi",
        "test_copy_and_deepcopy",
        "test_simple",
        "test_pipe",
        "test_numpy_clip",
        "test_describe_percentiles_insert_median",
        "test_stat_non_defaults_args",
        "_should_fill",
        "_concat_objects",
        "_get_join_indexers",
        "concat_wrap",
        "merge_ordered",
        "_sort_labels",
        "test_empty",
        "setUpClass",
        "_groupby_and_merge",
        "test_set_axis_name",
        "_merger",
        "_indicator_pre_merge",
        "f",
        "_validate_specification",
        "to_numeric",
        "pivot",
        "test_sample",
        "test_list",
        "test_preserve_categorical_dtype",
        "test_describe_typefiltering",
        "test_set_attribute",
        "test_describe_typefiltering_groupby",
        "test_describe",
        "test_all_nan",
        "test_get_locales_prefix",
        "_any",
        "test_stat_unexpected_keyword",
        "_join_non_unique",
        "test_describe_empty",
        "test_list_numeric",
        "test_transpose",
        "_join_compat",
        "_asof_function",
        "test_invalid_input",
        "test_constructor_compound_dtypes",
        "test_clip",
        "test_truncate_out_of_bounds",
        "test_take_invalid_kwargs",
        "test_split_compat",
        "test_pivot",
        "round",
        "get_result",
        "test_pipe_tuple_error",
        "test_numpy_1_7_compat_numeric_methods",
        "_aggregate_multiple_funcs",
        "boxplot_frame_groupby",
        "test_metadata_propagation_indiv",
        "test_set_axis_name_raises",
        "_chk_truncate",
        "test_head_tail",
        "test_to_xarray",
        "join",
        "test_describe_typefiltering_category_bool",
        "_get_join_keys",
        "check_metadata",
        "test_numpy_transpose"
      ]
    },
    "file": {
      "file_name": "merge.py",
      "file_nloc": 1115,
      "file_complexity": 245,
      "file_token_count": 6404,
      "file_before": null,
      "file_after": "\"\"\"\nSQL-style merge routines\n\"\"\"\n\nimport copy\nimport warnings\nimport string\n\nimport numpy as np\nfrom pandas.compat import range, lzip, zip, map, filter\nimport pandas.compat as compat\n\nfrom pandas import (Categorical, Series, DataFrame,\n                    Index, MultiIndex, Timedelta)\nfrom pandas.core.frame import _merge_doc\nfrom pandas.core.dtypes.common import (\n    is_datetime64tz_dtype,\n    is_datetime64_dtype,\n    needs_i8_conversion,\n    is_int64_dtype,\n    is_categorical_dtype,\n    is_integer_dtype,\n    is_float_dtype,\n    is_numeric_dtype,\n    is_integer,\n    is_int_or_datetime_dtype,\n    is_dtype_equal,\n    is_bool,\n    is_list_like,\n    _ensure_int64,\n    _ensure_float64,\n    _ensure_object,\n    _get_dtype)\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.internals import (items_overlap_with_suffix,\n                                   concatenate_block_managers)\nfrom pandas.util.decorators import Appender, Substitution\n\nfrom pandas.core.sorting import is_int64_overflow_possible\nimport pandas.core.algorithms as algos\nimport pandas.core.common as com\nfrom pandas._libs import hashtable as libhashtable, join as libjoin, lib\n\n\n@Substitution('\\nleft : DataFrame')\n@Appender(_merge_doc, indents=0)\ndef merge(left, right, how='inner', on=None, left_on=None, right_on=None,\n          left_index=False, right_index=False, sort=False,\n          suffixes=('_x', '_y'), copy=True, indicator=False):\n    op = _MergeOperation(left, right, how=how, on=on, left_on=left_on,\n                         right_on=right_on, left_index=left_index,\n                         right_index=right_index, sort=sort, suffixes=suffixes,\n                         copy=copy, indicator=indicator)\n    return op.get_result()\n\n\nif __debug__:\n    merge.__doc__ = _merge_doc % '\\nleft : DataFrame'\n\n\nclass MergeError(ValueError):\n    pass\n\n\ndef _groupby_and_merge(by, on, left, right, _merge_pieces,\n                       check_duplicates=True):\n    \"\"\"\n    groupby & merge; we are always performing a left-by type operation\n\n    Parameters\n    ----------\n    by: field to group\n    on: duplicates field\n    left: left frame\n    right: right frame\n    _merge_pieces: function for merging\n    check_duplicates: boolean, default True\n        should we check & clean duplicates\n    \"\"\"\n\n    pieces = []\n    if not isinstance(by, (list, tuple)):\n        by = [by]\n\n    lby = left.groupby(by, sort=False)\n\n    # if we can groupby the rhs\n    # then we can get vastly better perf\n    try:\n\n        # we will check & remove duplicates if indicated\n        if check_duplicates:\n            if on is None:\n                on = []\n            elif not isinstance(on, (list, tuple)):\n                on = [on]\n\n            if right.duplicated(by + on).any():\n                right = right.drop_duplicates(by + on, keep='last')\n        rby = right.groupby(by, sort=False)\n    except KeyError:\n        rby = None\n\n    for key, lhs in lby:\n\n        if rby is None:\n            rhs = right\n        else:\n            try:\n                rhs = right.take(rby.indices[key])\n            except KeyError:\n                # key doesn't exist in left\n                lcols = lhs.columns.tolist()\n                cols = lcols + [r for r in right.columns\n                                if r not in set(lcols)]\n                merged = lhs.reindex(columns=cols)\n                merged.index = range(len(merged))\n                pieces.append(merged)\n                continue\n\n        merged = _merge_pieces(lhs, rhs)\n\n        # make sure join keys are in the merged\n        # TODO, should _merge_pieces do this?\n        for k in by:\n            try:\n                if k in merged:\n                    merged[k] = key\n            except:\n                pass\n\n        pieces.append(merged)\n\n    # preserve the original order\n    # if we have a missing piece this can be reset\n    from pandas.core.reshape.concat import concat\n    result = concat(pieces, ignore_index=True)\n    result = result.reindex(columns=pieces[0].columns, copy=False)\n    return result, lby\n\n\ndef ordered_merge(left, right, on=None,\n                  left_on=None, right_on=None,\n                  left_by=None, right_by=None,\n                  fill_method=None, suffixes=('_x', '_y')):\n\n    warnings.warn(\"ordered_merge is deprecated and replaced by merge_ordered\",\n                  FutureWarning, stacklevel=2)\n    return merge_ordered(left, right, on=on,\n                         left_on=left_on, right_on=right_on,\n                         left_by=left_by, right_by=right_by,\n                         fill_method=fill_method, suffixes=suffixes)\n\n\ndef merge_ordered(left, right, on=None,\n                  left_on=None, right_on=None,\n                  left_by=None, right_by=None,\n                  fill_method=None, suffixes=('_x', '_y'),\n                  how='outer'):\n    \"\"\"Perform merge with optional filling/interpolation designed for ordered\n    data like time series data. Optionally perform group-wise merge (see\n    examples)\n\n    Parameters\n    ----------\n    left : DataFrame\n    right : DataFrame\n    on : label or list\n        Field names to join on. Must be found in both DataFrames.\n    left_on : label or list, or array-like\n        Field names to join on in left DataFrame. Can be a vector or list of\n        vectors of the length of the DataFrame to use a particular vector as\n        the join key instead of columns\n    right_on : label or list, or array-like\n        Field names to join on in right DataFrame or vector/list of vectors per\n        left_on docs\n    left_by : column name or list of column names\n        Group left DataFrame by group columns and merge piece by piece with\n        right DataFrame\n    right_by : column name or list of column names\n        Group right DataFrame by group columns and merge piece by piece with\n        left DataFrame\n    fill_method : {'ffill', None}, default None\n        Interpolation method for data\n    suffixes : 2-length sequence (tuple, list, ...)\n        Suffix to apply to overlapping column names in the left and right\n        side, respectively\n    how : {'left', 'right', 'outer', 'inner'}, default 'outer'\n        * left: use only keys from left frame (SQL: left outer join)\n        * right: use only keys from right frame (SQL: right outer join)\n        * outer: use union of keys from both frames (SQL: full outer join)\n        * inner: use intersection of keys from both frames (SQL: inner join)\n\n        .. versionadded:: 0.19.0\n\n    Examples\n    --------\n    >>> A                      >>> B\n          key  lvalue group        key  rvalue\n    0   a       1     a        0     b       1\n    1   c       2     a        1     c       2\n    2   e       3     a        2     d       3\n    3   a       1     b\n    4   c       2     b\n    5   e       3     b\n\n    >>> ordered_merge(A, B, fill_method='ffill', left_by='group')\n       key  lvalue group  rvalue\n    0    a       1     a     NaN\n    1    b       1     a       1\n    2    c       2     a       2\n    3    d       2     a       3\n    4    e       3     a       3\n    5    f       3     a       4\n    6    a       1     b     NaN\n    7    b       1     b       1\n    8    c       2     b       2\n    9    d       2     b       3\n    10   e       3     b       3\n    11   f       3     b       4\n\n    Returns\n    -------\n    merged : DataFrame\n        The output type will the be same as 'left', if it is a subclass\n        of DataFrame.\n\n    See also\n    --------\n    merge\n    merge_asof\n\n    \"\"\"\n    def _merger(x, y):\n        # perform the ordered merge operation\n        op = _OrderedMerge(x, y, on=on, left_on=left_on, right_on=right_on,\n                           suffixes=suffixes, fill_method=fill_method,\n                           how=how)\n        return op.get_result()\n\n    if left_by is not None and right_by is not None:\n        raise ValueError('Can only group either left or right frames')\n    elif left_by is not None:\n        result, _ = _groupby_and_merge(left_by, on, left, right,\n                                       lambda x, y: _merger(x, y),\n                                       check_duplicates=False)\n    elif right_by is not None:\n        result, _ = _groupby_and_merge(right_by, on, right, left,\n                                       lambda x, y: _merger(y, x),\n                                       check_duplicates=False)\n    else:\n        result = _merger(left, right)\n    return result\n\n\nordered_merge.__doc__ = merge_ordered.__doc__\n\n\ndef merge_asof(left, right, on=None,\n               left_on=None, right_on=None,\n               left_index=False, right_index=False,\n               by=None, left_by=None, right_by=None,\n               suffixes=('_x', '_y'),\n               tolerance=None,\n               allow_exact_matches=True,\n               direction='backward'):\n    \"\"\"Perform an asof merge. This is similar to a left-join except that we\n    match on nearest key rather than equal keys.\n\n    Both DataFrames must be sorted by the key.\n\n    For each row in the left DataFrame:\n\n      - A \"backward\" search selects the last row in the right DataFrame whose\n        'on' key is less than or equal to the left's key.\n\n      - A \"forward\" search selects the first row in the right DataFrame whose\n        'on' key is greater than or equal to the left's key.\n\n      - A \"nearest\" search selects the row in the right DataFrame whose 'on'\n        key is closest in absolute distance to the left's key.\n\n    The default is \"backward\" and is compatible in versions below 0.20.0.\n    The direction parameter was added in version 0.20.0 and introduces\n    \"forward\" and \"nearest\".\n\n    Optionally match on equivalent keys with 'by' before searching with 'on'.\n\n    .. versionadded:: 0.19.0\n\n    Parameters\n    ----------\n    left : DataFrame\n    right : DataFrame\n    on : label\n        Field name to join on. Must be found in both DataFrames.\n        The data MUST be ordered. Furthermore this must be a numeric column,\n        such as datetimelike, integer, or float. On or left_on/right_on\n        must be given.\n    left_on : label\n        Field name to join on in left DataFrame.\n    right_on : label\n        Field name to join on in right DataFrame.\n    left_index : boolean\n        Use the index of the left DataFrame as the join key.\n\n        .. versionadded:: 0.19.2\n\n    right_index : boolean\n        Use the index of the right DataFrame as the join key.\n\n        .. versionadded:: 0.19.2\n\n    by : column name or list of column names\n        Match on these columns before performing merge operation.\n    left_by : column name\n        Field names to match on in the left DataFrame.\n\n        .. versionadded:: 0.19.2\n\n    right_by : column name\n        Field names to match on in the right DataFrame.\n\n        .. versionadded:: 0.19.2\n\n    suffixes : 2-length sequence (tuple, list, ...)\n        Suffix to apply to overlapping column names in the left and right\n        side, respectively.\n    tolerance : integer or Timedelta, optional, default None\n        Select asof tolerance within this range; must be compatible\n        with the merge index.\n    allow_exact_matches : boolean, default True\n\n        - If True, allow matching with the same 'on' value\n          (i.e. less-than-or-equal-to / greater-than-or-equal-to)\n        - If False, don't match the same 'on' value\n          (i.e., stricly less-than / strictly greater-than)\n\n    direction : 'backward' (default), 'forward', or 'nearest'\n        Whether to search for prior, subsequent, or closest matches.\n\n        .. versionadded:: 0.20.0\n\n    Returns\n    -------\n    merged : DataFrame\n\n    Examples\n    --------\n    >>> left\n        a left_val\n    0   1        a\n    1   5        b\n    2  10        c\n\n    >>> right\n       a  right_val\n    0  1          1\n    1  2          2\n    2  3          3\n    3  6          6\n    4  7          7\n\n    >>> pd.merge_asof(left, right, on='a')\n        a left_val  right_val\n    0   1        a          1\n    1   5        b          3\n    2  10        c          7\n\n    >>> pd.merge_asof(left, right, on='a', allow_exact_matches=False)\n        a left_val  right_val\n    0   1        a        NaN\n    1   5        b        3.0\n    2  10        c        7.0\n\n    >>> pd.merge_asof(left, right, on='a', direction='forward')\n        a left_val  right_val\n    0   1        a        1.0\n    1   5        b        6.0\n    2  10        c        NaN\n\n    >>> pd.merge_asof(left, right, on='a', direction='nearest')\n        a left_val  right_val\n    0   1        a          1\n    1   5        b          6\n    2  10        c          7\n\n    We can use indexed DataFrames as well.\n\n    >>> left\n       left_val\n    1         a\n    5         b\n    10        c\n\n    >>> right\n       right_val\n    1          1\n    2          2\n    3          3\n    6          6\n    7          7\n\n    >>> pd.merge_asof(left, right, left_index=True, right_index=True)\n       left_val  right_val\n    1         a          1\n    5         b          3\n    10        c          7\n\n    Here is a real-world times-series example\n\n    >>> quotes\n                         time ticker     bid     ask\n    0 2016-05-25 13:30:00.023   GOOG  720.50  720.93\n    1 2016-05-25 13:30:00.023   MSFT   51.95   51.96\n    2 2016-05-25 13:30:00.030   MSFT   51.97   51.98\n    3 2016-05-25 13:30:00.041   MSFT   51.99   52.00\n    4 2016-05-25 13:30:00.048   GOOG  720.50  720.93\n    5 2016-05-25 13:30:00.049   AAPL   97.99   98.01\n    6 2016-05-25 13:30:00.072   GOOG  720.50  720.88\n    7 2016-05-25 13:30:00.075   MSFT   52.01   52.03\n\n    >>> trades\n                         time ticker   price  quantity\n    0 2016-05-25 13:30:00.023   MSFT   51.95        75\n    1 2016-05-25 13:30:00.038   MSFT   51.95       155\n    2 2016-05-25 13:30:00.048   GOOG  720.77       100\n    3 2016-05-25 13:30:00.048   GOOG  720.92       100\n    4 2016-05-25 13:30:00.048   AAPL   98.00       100\n\n    By default we are taking the asof of the quotes\n\n    >>> pd.merge_asof(trades, quotes,\n    ...                       on='time',\n    ...                       by='ticker')\n                         time ticker   price  quantity     bid     ask\n    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96\n    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98\n    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93\n    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93\n    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN\n\n    We only asof within 2ms betwen the quote time and the trade time\n\n    >>> pd.merge_asof(trades, quotes,\n    ...                       on='time',\n    ...                       by='ticker',\n    ...                       tolerance=pd.Timedelta('2ms'))\n                         time ticker   price  quantity     bid     ask\n    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96\n    1 2016-05-25 13:30:00.038   MSFT   51.95       155     NaN     NaN\n    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93\n    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93\n    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN\n\n    We only asof within 10ms betwen the quote time and the trade time\n    and we exclude exact matches on time. However *prior* data will\n    propogate forward\n\n    >>> pd.merge_asof(trades, quotes,\n    ...                       on='time',\n    ...                       by='ticker',\n    ...                       tolerance=pd.Timedelta('10ms'),\n    ...                       allow_exact_matches=False)\n                         time ticker   price  quantity     bid     ask\n    0 2016-05-25 13:30:00.023   MSFT   51.95        75     NaN     NaN\n    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98\n    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93\n    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93\n    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN\n\n    See also\n    --------\n    merge\n    merge_ordered\n\n    \"\"\"\n    op = _AsOfMerge(left, right,\n                    on=on, left_on=left_on, right_on=right_on,\n                    left_index=left_index, right_index=right_index,\n                    by=by, left_by=left_by, right_by=right_by,\n                    suffixes=suffixes,\n                    how='asof', tolerance=tolerance,\n                    allow_exact_matches=allow_exact_matches,\n                    direction=direction)\n    return op.get_result()\n\n\n# TODO: transformations??\n# TODO: only copy DataFrames when modification necessary\nclass _MergeOperation(object):\n    \"\"\"\n    Perform a database (SQL) merge operation between two DataFrame objects\n    using either columns as keys or their row indexes\n    \"\"\"\n    _merge_type = 'merge'\n\n    def __init__(self, left, right, how='inner', on=None,\n                 left_on=None, right_on=None, axis=1,\n                 left_index=False, right_index=False, sort=True,\n                 suffixes=('_x', '_y'), copy=True, indicator=False):\n        self.left = self.orig_left = left\n        self.right = self.orig_right = right\n        self.how = how\n        self.axis = axis\n\n        self.on = com._maybe_make_list(on)\n        self.left_on = com._maybe_make_list(left_on)\n        self.right_on = com._maybe_make_list(right_on)\n\n        self.copy = copy\n        self.suffixes = suffixes\n        self.sort = sort\n\n        self.left_index = left_index\n        self.right_index = right_index\n\n        self.indicator = indicator\n\n        if isinstance(self.indicator, compat.string_types):\n            self.indicator_name = self.indicator\n        elif isinstance(self.indicator, bool):\n            self.indicator_name = '_merge' if self.indicator else None\n        else:\n            raise ValueError(\n                'indicator option can only accept boolean or string arguments')\n\n        if not isinstance(left, DataFrame):\n            raise ValueError(\n                'can not merge DataFrame with instance of '\n                'type {0}'.format(type(left)))\n        if not isinstance(right, DataFrame):\n            raise ValueError(\n                'can not merge DataFrame with instance of '\n                'type {0}'.format(type(right)))\n\n        if not is_bool(left_index):\n            raise ValueError(\n                'left_index parameter must be of type bool, not '\n                '{0}'.format(type(left_index)))\n        if not is_bool(right_index):\n            raise ValueError(\n                'right_index parameter must be of type bool, not '\n                '{0}'.format(type(right_index)))\n\n        # warn user when merging between different levels\n        if left.columns.nlevels != right.columns.nlevels:\n            msg = ('merging between different levels can give an unintended '\n                   'result ({0} levels on the left, {1} on the right)')\n            msg = msg.format(left.columns.nlevels, right.columns.nlevels)\n            warnings.warn(msg, UserWarning)\n\n        self._validate_specification()\n\n        # note this function has side effects\n        (self.left_join_keys,\n         self.right_join_keys,\n         self.join_names) = self._get_merge_keys()\n\n        # validate the merge keys dtypes. We may need to coerce\n        # to avoid incompat dtypes\n        self._maybe_coerce_merge_keys()\n\n    def get_result(self):\n        if self.indicator:\n            self.left, self.right = self._indicator_pre_merge(\n                self.left, self.right)\n\n        join_index, left_indexer, right_indexer = self._get_join_info()\n\n        ldata, rdata = self.left._data, self.right._data\n        lsuf, rsuf = self.suffixes\n\n        llabels, rlabels = items_overlap_with_suffix(ldata.items, lsuf,\n                                                     rdata.items, rsuf)\n\n        lindexers = {1: left_indexer} if left_indexer is not None else {}\n        rindexers = {1: right_indexer} if right_indexer is not None else {}\n\n        result_data = concatenate_block_managers(\n            [(ldata, lindexers), (rdata, rindexers)],\n            axes=[llabels.append(rlabels), join_index],\n            concat_axis=0, copy=self.copy)\n\n        typ = self.left._constructor\n        result = typ(result_data).__finalize__(self, method=self._merge_type)\n\n        if self.indicator:\n            result = self._indicator_post_merge(result)\n\n        self._maybe_add_join_keys(result, left_indexer, right_indexer)\n\n        return result\n\n    def _indicator_pre_merge(self, left, right):\n\n        columns = left.columns.union(right.columns)\n\n        for i in ['_left_indicator', '_right_indicator']:\n            if i in columns:\n                raise ValueError(\"Cannot use `indicator=True` option when \"\n                                 \"data contains a column named {}\".format(i))\n        if self.indicator_name in columns:\n            raise ValueError(\n                \"Cannot use name of an existing column for indicator column\")\n\n        left = left.copy()\n        right = right.copy()\n\n        left['_left_indicator'] = 1\n        left['_left_indicator'] = left['_left_indicator'].astype('int8')\n\n        right['_right_indicator'] = 2\n        right['_right_indicator'] = right['_right_indicator'].astype('int8')\n\n        return left, right\n\n    def _indicator_post_merge(self, result):\n\n        result['_left_indicator'] = result['_left_indicator'].fillna(0)\n        result['_right_indicator'] = result['_right_indicator'].fillna(0)\n\n        result[self.indicator_name] = Categorical((result['_left_indicator'] +\n                                                   result['_right_indicator']),\n                                                  categories=[1, 2, 3])\n        result[self.indicator_name] = (\n            result[self.indicator_name]\n            .cat.rename_categories(['left_only', 'right_only', 'both']))\n\n        result = result.drop(labels=['_left_indicator', '_right_indicator'],\n                             axis=1)\n        return result\n\n    def _maybe_add_join_keys(self, result, left_indexer, right_indexer):\n\n        left_has_missing = None\n        right_has_missing = None\n\n        keys = zip(self.join_names, self.left_on, self.right_on)\n        for i, (name, lname, rname) in enumerate(keys):\n            if not _should_fill(lname, rname):\n                continue\n\n            take_left, take_right = None, None\n\n            if name in result:\n\n                if left_indexer is not None and right_indexer is not None:\n                    if name in self.left:\n\n                        if left_has_missing is None:\n                            left_has_missing = (left_indexer == -1).any()\n\n                        if left_has_missing:\n                            take_right = self.right_join_keys[i]\n\n                            if not is_dtype_equal(result[name].dtype,\n                                                  self.left[name].dtype):\n                                take_left = self.left[name]._values\n\n                    elif name in self.right:\n\n                        if right_has_missing is None:\n                            right_has_missing = (right_indexer == -1).any()\n\n                        if right_has_missing:\n                            take_left = self.left_join_keys[i]\n\n                            if not is_dtype_equal(result[name].dtype,\n                                                  self.right[name].dtype):\n                                take_right = self.right[name]._values\n\n            elif left_indexer is not None \\\n                    and isinstance(self.left_join_keys[i], np.ndarray):\n\n                take_left = self.left_join_keys[i]\n                take_right = self.right_join_keys[i]\n\n            if take_left is not None or take_right is not None:\n\n                if take_left is None:\n                    lvals = result[name]._values\n                else:\n                    lfill = na_value_for_dtype(take_left.dtype)\n                    lvals = algos.take_1d(take_left, left_indexer,\n                                          fill_value=lfill)\n\n                if take_right is None:\n                    rvals = result[name]._values\n                else:\n                    rfill = na_value_for_dtype(take_right.dtype)\n                    rvals = algos.take_1d(take_right, right_indexer,\n                                          fill_value=rfill)\n\n                # if we have an all missing left_indexer\n                # make sure to just use the right values\n                mask = left_indexer == -1\n                if mask.all():\n                    key_col = rvals\n                else:\n                    key_col = Index(lvals).where(~mask, rvals)\n\n                if name in result:\n                    result[name] = key_col\n                else:\n                    result.insert(i, name or 'key_%d' % i, key_col)\n\n    def _get_join_indexers(self):\n        \"\"\" return the join indexers \"\"\"\n        return _get_join_indexers(self.left_join_keys,\n                                  self.right_join_keys,\n                                  sort=self.sort,\n                                  how=self.how)\n\n    def _get_join_info(self):\n        left_ax = self.left._data.axes[self.axis]\n        right_ax = self.right._data.axes[self.axis]\n\n        if self.left_index and self.right_index and self.how != 'asof':\n            join_index, left_indexer, right_indexer = \\\n                left_ax.join(right_ax, how=self.how, return_indexers=True,\n                             sort=self.sort)\n        elif self.right_index and self.how == 'left':\n            join_index, left_indexer, right_indexer = \\\n                _left_join_on_index(left_ax, right_ax, self.left_join_keys,\n                                    sort=self.sort)\n\n        elif self.left_index and self.how == 'right':\n            join_index, right_indexer, left_indexer = \\\n                _left_join_on_index(right_ax, left_ax, self.right_join_keys,\n                                    sort=self.sort)\n        else:\n            (left_indexer,\n             right_indexer) = self._get_join_indexers()\n\n            if self.right_index:\n                if len(self.left) > 0:\n                    join_index = self.left.index.take(left_indexer)\n                else:\n                    join_index = self.right.index.take(right_indexer)\n                    left_indexer = np.array([-1] * len(join_index))\n            elif self.left_index:\n                if len(self.right) > 0:\n                    join_index = self.right.index.take(right_indexer)\n                else:\n                    join_index = self.left.index.take(left_indexer)\n                    right_indexer = np.array([-1] * len(join_index))\n            else:\n                join_index = Index(np.arange(len(left_indexer)))\n\n        if len(join_index) == 0:\n            join_index = join_index.astype(object)\n        return join_index, left_indexer, right_indexer\n\n    def _get_merge_keys(self):\n        \"\"\"\n        Note: has side effects (copy/delete key columns)\n\n        Parameters\n        ----------\n        left\n        right\n        on\n\n        Returns\n        -------\n        left_keys, right_keys\n        \"\"\"\n        left_keys = []\n        right_keys = []\n        join_names = []\n        right_drop = []\n        left_drop = []\n        left, right = self.left, self.right\n\n        is_lkey = lambda x: isinstance(\n            x, (np.ndarray, Series)) and len(x) == len(left)\n        is_rkey = lambda x: isinstance(\n            x, (np.ndarray, Series)) and len(x) == len(right)\n\n        # Note that pd.merge_asof() has separate 'on' and 'by' parameters. A\n        # user could, for example, request 'left_index' and 'left_by'. In a\n        # regular pd.merge(), users cannot specify both 'left_index' and\n        # 'left_on'. (Instead, users have a MultiIndex). That means the\n        # self.left_on in this function is always empty in a pd.merge(), but\n        # a pd.merge_asof(left_index=True, left_by=...) will result in a\n        # self.left_on array with a None in the middle of it. This requires\n        # a work-around as designated in the code below.\n        # See _validate_specification() for where this happens.\n\n        # ugh, spaghetti re #733\n        if _any(self.left_on) and _any(self.right_on):\n            for lk, rk in zip(self.left_on, self.right_on):\n                if is_lkey(lk):\n                    left_keys.append(lk)\n                    if is_rkey(rk):\n                        right_keys.append(rk)\n                        join_names.append(None)  # what to do?\n                    else:\n                        if rk is not None:\n                            right_keys.append(right[rk]._values)\n                            join_names.append(rk)\n                        else:\n                            # work-around for merge_asof(right_index=True)\n                            right_keys.append(right.index)\n                            join_names.append(right.index.name)\n                else:\n                    if not is_rkey(rk):\n                        if rk is not None:\n                            right_keys.append(right[rk]._values)\n                        else:\n                            # work-around for merge_asof(right_index=True)\n                            right_keys.append(right.index)\n                        if lk is not None and lk == rk:\n                            # avoid key upcast in corner case (length-0)\n                            if len(left) > 0:\n                                right_drop.append(rk)\n                            else:\n                                left_drop.append(lk)\n                    else:\n                        right_keys.append(rk)\n                    if lk is not None:\n                        left_keys.append(left[lk]._values)\n                        join_names.append(lk)\n                    else:\n                        # work-around for merge_asof(left_index=True)\n                        left_keys.append(left.index)\n                        join_names.append(left.index.name)\n        elif _any(self.left_on):\n            for k in self.left_on:\n                if is_lkey(k):\n                    left_keys.append(k)\n                    join_names.append(None)\n                else:\n                    left_keys.append(left[k]._values)\n                    join_names.append(k)\n            if isinstance(self.right.index, MultiIndex):\n                right_keys = [lev._values.take(lab)\n                              for lev, lab in zip(self.right.index.levels,\n                                                  self.right.index.labels)]\n            else:\n                right_keys = [self.right.index.values]\n        elif _any(self.right_on):\n            for k in self.right_on:\n                if is_rkey(k):\n                    right_keys.append(k)\n                    join_names.append(None)\n                else:\n                    right_keys.append(right[k]._values)\n                    join_names.append(k)\n            if isinstance(self.left.index, MultiIndex):\n                left_keys = [lev._values.take(lab)\n                             for lev, lab in zip(self.left.index.levels,\n                                                 self.left.index.labels)]\n            else:\n                left_keys = [self.left.index.values]\n\n        if left_drop:\n            self.left = self.left.drop(left_drop, axis=1)\n\n        if right_drop:\n            self.right = self.right.drop(right_drop, axis=1)\n\n        return left_keys, right_keys, join_names\n\n    def _maybe_coerce_merge_keys(self):\n        # we have valid mergee's but we may have to further\n        # coerce these if they are originally incompatible types\n        #\n        # for example if these are categorical, but are not dtype_equal\n        # or if we have object and integer dtypes\n\n        for lk, rk, name in zip(self.left_join_keys,\n                                self.right_join_keys,\n                                self.join_names):\n            if (len(lk) and not len(rk)) or (not len(lk) and len(rk)):\n                continue\n\n            # if either left or right is a categorical\n            # then the must match exactly in categories & ordered\n            if is_categorical_dtype(lk) and is_categorical_dtype(rk):\n                if lk.is_dtype_equal(rk):\n                    continue\n            elif is_categorical_dtype(lk) or is_categorical_dtype(rk):\n                pass\n\n            elif is_dtype_equal(lk.dtype, rk.dtype):\n                continue\n\n            # if we are numeric, then allow differing\n            # kinds to proceed, eg. int64 and int8\n            # further if we are object, but we infer to\n            # the same, then proceed\n            if (is_numeric_dtype(lk) and is_numeric_dtype(rk)):\n                if lk.dtype.kind == rk.dtype.kind:\n                    continue\n\n                # let's infer and see if we are ok\n                if lib.infer_dtype(lk) == lib.infer_dtype(rk):\n                    continue\n\n            # Houston, we have a problem!\n            # let's coerce to object\n            if name in self.left.columns:\n                self.left = self.left.assign(\n                    **{name: self.left[name].astype(object)})\n            if name in self.right.columns:\n                self.right = self.right.assign(\n                    **{name: self.right[name].astype(object)})\n\n    def _validate_specification(self):\n        # Hm, any way to make this logic less complicated??\n        if self.on is None and self.left_on is None and self.right_on is None:\n\n            if self.left_index and self.right_index:\n                self.left_on, self.right_on = (), ()\n            elif self.left_index:\n                if self.right_on is None:\n                    raise MergeError('Must pass right_on or right_index=True')\n            elif self.right_index:\n                if self.left_on is None:\n                    raise MergeError('Must pass left_on or left_index=True')\n            else:\n                # use the common columns\n                common_cols = self.left.columns.intersection(\n                    self.right.columns)\n                if len(common_cols) == 0:\n                    raise MergeError('No common columns to perform merge on')\n                if not common_cols.is_unique:\n                    raise MergeError(\"Data columns not unique: %s\"\n                                     % repr(common_cols))\n                self.left_on = self.right_on = common_cols\n        elif self.on is not None:\n            if self.left_on is not None or self.right_on is not None:\n                raise MergeError('Can only pass argument \"on\" OR \"left_on\" '\n                                 'and \"right_on\", not a combination of both.')\n            self.left_on = self.right_on = self.on\n        elif self.left_on is not None:\n            n = len(self.left_on)\n            if self.right_index:\n                if len(self.left_on) != self.right.index.nlevels:\n                    raise ValueError('len(left_on) must equal the number '\n                                     'of levels in the index of \"right\"')\n                self.right_on = [None] * n\n        elif self.right_on is not None:\n            n = len(self.right_on)\n            if self.left_index:\n                if len(self.right_on) != self.left.index.nlevels:\n                    raise ValueError('len(right_on) must equal the number '\n                                     'of levels in the index of \"left\"')\n                self.left_on = [None] * n\n        if len(self.right_on) != len(self.left_on):\n            raise ValueError(\"len(right_on) must equal len(left_on)\")\n\n\ndef _get_join_indexers(left_keys, right_keys, sort=False, how='inner',\n                       **kwargs):\n    \"\"\"\n\n    Parameters\n    ----------\n    left_keys: ndarray, Index, Series\n    right_keys: ndarray, Index, Series\n    sort: boolean, default False\n    how: string {'inner', 'outer', 'left', 'right'}, default 'inner'\n\n    Returns\n    -------\n    tuple of (left_indexer, right_indexer)\n        indexers into the left_keys, right_keys\n\n    \"\"\"\n    from functools import partial\n\n    assert len(left_keys) == len(right_keys), \\\n        'left_key and right_keys must be the same length'\n\n    # bind `sort` arg. of _factorize_keys\n    fkeys = partial(_factorize_keys, sort=sort)\n\n    # get left & right join labels and num. of levels at each location\n    llab, rlab, shape = map(list, zip(* map(fkeys, left_keys, right_keys)))\n\n    # get flat i8 keys from label lists\n    lkey, rkey = _get_join_keys(llab, rlab, shape, sort)\n\n    # factorize keys to a dense i8 space\n    # `count` is the num. of unique keys\n    # set(lkey) | set(rkey) == range(count)\n    lkey, rkey, count = fkeys(lkey, rkey)\n\n    # preserve left frame order if how == 'left' and sort == False\n    kwargs = copy.copy(kwargs)\n    if how == 'left':\n        kwargs['sort'] = sort\n    join_func = _join_functions[how]\n\n    return join_func(lkey, rkey, count, **kwargs)\n\n\nclass _OrderedMerge(_MergeOperation):\n    _merge_type = 'ordered_merge'\n\n    def __init__(self, left, right, on=None, left_on=None, right_on=None,\n                 left_index=False, right_index=False, axis=1,\n                 suffixes=('_x', '_y'), copy=True,\n                 fill_method=None, how='outer'):\n\n        self.fill_method = fill_method\n        _MergeOperation.__init__(self, left, right, on=on, left_on=left_on,\n                                 left_index=left_index,\n                                 right_index=right_index,\n                                 right_on=right_on, axis=axis,\n                                 how=how, suffixes=suffixes,\n                                 sort=True  # factorize sorts\n                                 )\n\n    def get_result(self):\n        join_index, left_indexer, right_indexer = self._get_join_info()\n\n        # this is a bit kludgy\n        ldata, rdata = self.left._data, self.right._data\n        lsuf, rsuf = self.suffixes\n\n        llabels, rlabels = items_overlap_with_suffix(ldata.items, lsuf,\n                                                     rdata.items, rsuf)\n\n        if self.fill_method == 'ffill':\n            left_join_indexer = libjoin.ffill_indexer(left_indexer)\n            right_join_indexer = libjoin.ffill_indexer(right_indexer)\n        else:\n            left_join_indexer = left_indexer\n            right_join_indexer = right_indexer\n\n        lindexers = {\n            1: left_join_indexer} if left_join_indexer is not None else {}\n        rindexers = {\n            1: right_join_indexer} if right_join_indexer is not None else {}\n\n        result_data = concatenate_block_managers(\n            [(ldata, lindexers), (rdata, rindexers)],\n            axes=[llabels.append(rlabels), join_index],\n            concat_axis=0, copy=self.copy)\n\n        typ = self.left._constructor\n        result = typ(result_data).__finalize__(self, method=self._merge_type)\n\n        self._maybe_add_join_keys(result, left_indexer, right_indexer)\n\n        return result\n\n\ndef _asof_function(direction, on_type):\n    return getattr(libjoin, 'asof_join_%s_%s' % (direction, on_type), None)\n\n\ndef _asof_by_function(direction, on_type, by_type):\n    return getattr(libjoin, 'asof_join_%s_%s_by_%s' %\n                   (direction, on_type, by_type), None)\n\n\n_type_casters = {\n    'int64_t': _ensure_int64,\n    'double': _ensure_float64,\n    'object': _ensure_object,\n}\n\n_cython_types = {\n    'uint8': 'uint8_t',\n    'uint32': 'uint32_t',\n    'uint16': 'uint16_t',\n    'uint64': 'uint64_t',\n    'int8': 'int8_t',\n    'int32': 'int32_t',\n    'int16': 'int16_t',\n    'int64': 'int64_t',\n    'float16': 'error',\n    'float32': 'float',\n    'float64': 'double',\n}\n\n\ndef _get_cython_type(dtype):\n    \"\"\" Given a dtype, return a C name like 'int64_t' or 'double' \"\"\"\n    type_name = _get_dtype(dtype).name\n    ctype = _cython_types.get(type_name, 'object')\n    if ctype == 'error':\n        raise MergeError('unsupported type: ' + type_name)\n    return ctype\n\n\ndef _get_cython_type_upcast(dtype):\n    \"\"\" Upcast a dtype to 'int64_t', 'double', or 'object' \"\"\"\n    if is_integer_dtype(dtype):\n        return 'int64_t'\n    elif is_float_dtype(dtype):\n        return 'double'\n    else:\n        return 'object'\n\n\nclass _AsOfMerge(_OrderedMerge):\n    _merge_type = 'asof_merge'\n\n    def __init__(self, left, right, on=None, left_on=None, right_on=None,\n                 left_index=False, right_index=False,\n                 by=None, left_by=None, right_by=None,\n                 axis=1, suffixes=('_x', '_y'), copy=True,\n                 fill_method=None,\n                 how='asof', tolerance=None,\n                 allow_exact_matches=True,\n                 direction='backward'):\n\n        self.by = by\n        self.left_by = left_by\n        self.right_by = right_by\n        self.tolerance = tolerance\n        self.allow_exact_matches = allow_exact_matches\n        self.direction = direction\n\n        _OrderedMerge.__init__(self, left, right, on=on, left_on=left_on,\n                               right_on=right_on, left_index=left_index,\n                               right_index=right_index, axis=axis,\n                               how=how, suffixes=suffixes,\n                               fill_method=fill_method)\n\n    def _validate_specification(self):\n        super(_AsOfMerge, self)._validate_specification()\n\n        # we only allow on to be a single item for on\n        if len(self.left_on) != 1 and not self.left_index:\n            raise MergeError(\"can only asof on a key for left\")\n\n        if len(self.right_on) != 1 and not self.right_index:\n            raise MergeError(\"can only asof on a key for right\")\n\n        if self.left_index and isinstance(self.left.index, MultiIndex):\n            raise MergeError(\"left can only have one index\")\n\n        if self.right_index and isinstance(self.right.index, MultiIndex):\n            raise MergeError(\"right can only have one index\")\n\n        # set 'by' columns\n        if self.by is not None:\n            if self.left_by is not None or self.right_by is not None:\n                raise MergeError('Can only pass by OR left_by '\n                                 'and right_by')\n            self.left_by = self.right_by = self.by\n        if self.left_by is None and self.right_by is not None:\n            raise MergeError('missing left_by')\n        if self.left_by is not None and self.right_by is None:\n            raise MergeError('missing right_by')\n\n        # add 'by' to our key-list so we can have it in the\n        # output as a key\n        if self.left_by is not None:\n            if not is_list_like(self.left_by):\n                self.left_by = [self.left_by]\n            if not is_list_like(self.right_by):\n                self.right_by = [self.right_by]\n\n            if len(self.left_by) != len(self.right_by):\n                raise MergeError('left_by and right_by must be same length')\n\n            self.left_on = self.left_by + list(self.left_on)\n            self.right_on = self.right_by + list(self.right_on)\n\n        # check 'direction' is valid\n        if self.direction not in ['backward', 'forward', 'nearest']:\n            raise MergeError('direction invalid: ' + self.direction)\n\n    @property\n    def _asof_key(self):\n        \"\"\" This is our asof key, the 'on' \"\"\"\n        return self.left_on[-1]\n\n    def _get_merge_keys(self):\n\n        # note this function has side effects\n        (left_join_keys,\n         right_join_keys,\n         join_names) = super(_AsOfMerge, self)._get_merge_keys()\n\n        # validate index types are the same\n        for lk, rk in zip(left_join_keys, right_join_keys):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                raise MergeError(\"incompatible merge keys, \"\n                                 \"must be the same type\")\n\n        # validate tolerance; must be a Timedelta if we have a DTI\n        if self.tolerance is not None:\n\n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n\n            msg = \"incompatible tolerance, must be compat \" \\\n                  \"with type {0}\".format(type(lt))\n\n            if is_datetime64_dtype(lt) or is_datetime64tz_dtype(lt):\n                if not isinstance(self.tolerance, Timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n\n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n\n            else:\n                raise MergeError(\"key must be integer or timestamp\")\n\n        # validate allow_exact_matches\n        if not is_bool(self.allow_exact_matches):\n            raise MergeError(\"allow_exact_matches must be boolean, \"\n                             \"passed {0}\".format(self.allow_exact_matches))\n\n        return left_join_keys, right_join_keys, join_names\n\n    def _get_join_indexers(self):\n        \"\"\" return the join indexers \"\"\"\n\n        def flip(xs):\n            \"\"\" unlike np.transpose, this returns an array of tuples \"\"\"\n            labels = list(string.ascii_lowercase[:len(xs)])\n            dtypes = [x.dtype for x in xs]\n            labeled_dtypes = list(zip(labels, dtypes))\n            return np.array(lzip(*xs), labeled_dtypes)\n\n        # values to compare\n        left_values = (self.left.index.values if self.left_index else\n                       self.left_join_keys[-1])\n        right_values = (self.right.index.values if self.right_index else\n                        self.right_join_keys[-1])\n        tolerance = self.tolerance\n\n        # we required sortedness in the join keys\n        msg = \" keys must be sorted\"\n        if not Index(left_values).is_monotonic:\n            raise ValueError('left' + msg)\n        if not Index(right_values).is_monotonic:\n            raise ValueError('right' + msg)\n\n        # initial type conversion as needed\n        if needs_i8_conversion(left_values):\n            left_values = left_values.view('i8')\n            right_values = right_values.view('i8')\n            if tolerance is not None:\n                tolerance = tolerance.value\n\n        # a \"by\" parameter requires special handling\n        if self.left_by is not None:\n            # remove 'on' parameter from values if one existed\n            if self.left_index and self.right_index:\n                left_by_values = self.left_join_keys\n                right_by_values = self.right_join_keys\n            else:\n                left_by_values = self.left_join_keys[0:-1]\n                right_by_values = self.right_join_keys[0:-1]\n\n            # get tuple representation of values if more than one\n            if len(left_by_values) == 1:\n                left_by_values = left_by_values[0]\n                right_by_values = right_by_values[0]\n            else:\n                left_by_values = flip(left_by_values)\n                right_by_values = flip(right_by_values)\n\n            # upcast 'by' parameter because HashTable is limited\n            by_type = _get_cython_type_upcast(left_by_values.dtype)\n            by_type_caster = _type_casters[by_type]\n            left_by_values = by_type_caster(left_by_values)\n            right_by_values = by_type_caster(right_by_values)\n\n            # choose appropriate function by type\n            on_type = _get_cython_type(left_values.dtype)\n            func = _asof_by_function(self.direction, on_type, by_type)\n            return func(left_values,\n                        right_values,\n                        left_by_values,\n                        right_by_values,\n                        self.allow_exact_matches,\n                        tolerance)\n        else:\n            # choose appropriate function by type\n            on_type = _get_cython_type(left_values.dtype)\n            func = _asof_function(self.direction, on_type)\n            return func(left_values,\n                        right_values,\n                        self.allow_exact_matches,\n                        tolerance)\n\n\ndef _get_multiindex_indexer(join_keys, index, sort):\n    from functools import partial\n\n    # bind `sort` argument\n    fkeys = partial(_factorize_keys, sort=sort)\n\n    # left & right join labels and num. of levels at each location\n    rlab, llab, shape = map(list, zip(* map(fkeys, index.levels, join_keys)))\n    if sort:\n        rlab = list(map(np.take, rlab, index.labels))\n    else:\n        i8copy = lambda a: a.astype('i8', subok=False, copy=True)\n        rlab = list(map(i8copy, index.labels))\n\n    # fix right labels if there were any nulls\n    for i in range(len(join_keys)):\n        mask = index.labels[i] == -1\n        if mask.any():\n            # check if there already was any nulls at this location\n            # if there was, it is factorized to `shape[i] - 1`\n            a = join_keys[i][llab[i] == shape[i] - 1]\n            if a.size == 0 or not a[0] != a[0]:\n                shape[i] += 1\n\n            rlab[i][mask] = shape[i] - 1\n\n    # get flat i8 join keys\n    lkey, rkey = _get_join_keys(llab, rlab, shape, sort)\n\n    # factorize keys to a dense i8 space\n    lkey, rkey, count = fkeys(lkey, rkey)\n\n    return libjoin.left_outer_join(lkey, rkey, count, sort=sort)\n\n\ndef _get_single_indexer(join_key, index, sort=False):\n    left_key, right_key, count = _factorize_keys(join_key, index, sort=sort)\n\n    left_indexer, right_indexer = libjoin.left_outer_join(\n        _ensure_int64(left_key),\n        _ensure_int64(right_key),\n        count, sort=sort)\n\n    return left_indexer, right_indexer\n\n\ndef _left_join_on_index(left_ax, right_ax, join_keys, sort=False):\n    if len(join_keys) > 1:\n        if not ((isinstance(right_ax, MultiIndex) and\n                 len(join_keys) == right_ax.nlevels)):\n            raise AssertionError(\"If more than one join key is given then \"\n                                 \"'right_ax' must be a MultiIndex and the \"\n                                 \"number of join keys must be the number of \"\n                                 \"levels in right_ax\")\n\n        left_indexer, right_indexer = \\\n            _get_multiindex_indexer(join_keys, right_ax, sort=sort)\n    else:\n        jkey = join_keys[0]\n\n        left_indexer, right_indexer = \\\n            _get_single_indexer(jkey, right_ax, sort=sort)\n\n    if sort or len(left_ax) != len(left_indexer):\n        # if asked to sort or there are 1-to-many matches\n        join_index = left_ax.take(left_indexer)\n        return join_index, left_indexer, right_indexer\n\n    # left frame preserves order & length of its index\n    return left_ax, None, right_indexer\n\n\ndef _right_outer_join(x, y, max_groups):\n    right_indexer, left_indexer = libjoin.left_outer_join(y, x, max_groups)\n    return left_indexer, right_indexer\n\n\n_join_functions = {\n    'inner': libjoin.inner_join,\n    'left': libjoin.left_outer_join,\n    'right': _right_outer_join,\n    'outer': libjoin.full_outer_join,\n}\n\n\ndef _factorize_keys(lk, rk, sort=True):\n    if is_datetime64tz_dtype(lk) and is_datetime64tz_dtype(rk):\n        lk = lk.values\n        rk = rk.values\n\n    # if we exactly match in categories, allow us to use codes\n    if (is_categorical_dtype(lk) and\n            is_categorical_dtype(rk) and\n            lk.is_dtype_equal(rk)):\n        return lk.codes, rk.codes, len(lk.categories)\n\n    if is_int_or_datetime_dtype(lk) and is_int_or_datetime_dtype(rk):\n        klass = libhashtable.Int64Factorizer\n        lk = _ensure_int64(com._values_from_object(lk))\n        rk = _ensure_int64(com._values_from_object(rk))\n    else:\n        klass = libhashtable.Factorizer\n        lk = _ensure_object(lk)\n        rk = _ensure_object(rk)\n\n    rizer = klass(max(len(lk), len(rk)))\n\n    llab = rizer.factorize(lk)\n    rlab = rizer.factorize(rk)\n\n    count = rizer.get_count()\n\n    if sort:\n        uniques = rizer.uniques.to_array()\n        llab, rlab = _sort_labels(uniques, llab, rlab)\n\n    # NA group\n    lmask = llab == -1\n    lany = lmask.any()\n    rmask = rlab == -1\n    rany = rmask.any()\n\n    if lany or rany:\n        if lany:\n            np.putmask(llab, lmask, count)\n        if rany:\n            np.putmask(rlab, rmask, count)\n        count += 1\n\n    return llab, rlab, count\n\n\ndef _sort_labels(uniques, left, right):\n    if not isinstance(uniques, np.ndarray):\n        # tuplesafe\n        uniques = Index(uniques).values\n\n    l = len(left)\n    labels = np.concatenate([left, right])\n\n    _, new_labels = algos.safe_sort(uniques, labels, na_sentinel=-1)\n    new_labels = _ensure_int64(new_labels)\n    new_left, new_right = new_labels[:l], new_labels[l:]\n\n    return new_left, new_right\n\n\ndef _get_join_keys(llab, rlab, shape, sort):\n\n    # how many levels can be done without overflow\n    pred = lambda i: not is_int64_overflow_possible(shape[:i])\n    nlev = next(filter(pred, range(len(shape), 0, -1)))\n\n    # get keys for the first `nlev` levels\n    stride = np.prod(shape[1:nlev], dtype='i8')\n    lkey = stride * llab[0].astype('i8', subok=False, copy=False)\n    rkey = stride * rlab[0].astype('i8', subok=False, copy=False)\n\n    for i in range(1, nlev):\n        stride //= shape[i]\n        lkey += llab[i] * stride\n        rkey += rlab[i] * stride\n\n    if nlev == len(shape):  # all done!\n        return lkey, rkey\n\n    # densify current keys to avoid overflow\n    lkey, rkey, count = _factorize_keys(lkey, rkey, sort=sort)\n\n    llab = [lkey] + llab[nlev:]\n    rlab = [rkey] + rlab[nlev:]\n    shape = [count] + shape[nlev:]\n\n    return _get_join_keys(llab, rlab, shape, sort)\n\n\ndef _should_fill(lname, rname):\n    if (not isinstance(lname, compat.string_types) or\n            not isinstance(rname, compat.string_types)):\n        return True\n    return lname == rname\n\n\ndef _any(x):\n    return x is not None and len(x) > 0 and any([y is not None for y in x])\n",
      "file_patch": "@@ -0,0 +1,1481 @@\n+\"\"\"\n+SQL-style merge routines\n+\"\"\"\n+\n+import copy\n+import warnings\n+import string\n+\n+import numpy as np\n+from pandas.compat import range, lzip, zip, map, filter\n+import pandas.compat as compat\n+\n+from pandas import (Categorical, Series, DataFrame,\n+                    Index, MultiIndex, Timedelta)\n+from pandas.core.frame import _merge_doc\n+from pandas.core.dtypes.common import (\n+    is_datetime64tz_dtype,\n+    is_datetime64_dtype,\n+    needs_i8_conversion,\n+    is_int64_dtype,\n+    is_categorical_dtype,\n+    is_integer_dtype,\n+    is_float_dtype,\n+    is_numeric_dtype,\n+    is_integer,\n+    is_int_or_datetime_dtype,\n+    is_dtype_equal,\n+    is_bool,\n+    is_list_like,\n+    _ensure_int64,\n+    _ensure_float64,\n+    _ensure_object,\n+    _get_dtype)\n+from pandas.core.dtypes.missing import na_value_for_dtype\n+from pandas.core.internals import (items_overlap_with_suffix,\n+                                   concatenate_block_managers)\n+from pandas.util.decorators import Appender, Substitution\n+\n+from pandas.core.sorting import is_int64_overflow_possible\n+import pandas.core.algorithms as algos\n+import pandas.core.common as com\n+from pandas._libs import hashtable as libhashtable, join as libjoin, lib\n+\n+\n+@Substitution('\\nleft : DataFrame')\n+@Appender(_merge_doc, indents=0)\n+def merge(left, right, how='inner', on=None, left_on=None, right_on=None,\n+          left_index=False, right_index=False, sort=False,\n+          suffixes=('_x', '_y'), copy=True, indicator=False):\n+    op = _MergeOperation(left, right, how=how, on=on, left_on=left_on,\n+                         right_on=right_on, left_index=left_index,\n+                         right_index=right_index, sort=sort, suffixes=suffixes,\n+                         copy=copy, indicator=indicator)\n+    return op.get_result()\n+\n+\n+if __debug__:\n+    merge.__doc__ = _merge_doc % '\\nleft : DataFrame'\n+\n+\n+class MergeError(ValueError):\n+    pass\n+\n+\n+def _groupby_and_merge(by, on, left, right, _merge_pieces,\n+                       check_duplicates=True):\n+    \"\"\"\n+    groupby & merge; we are always performing a left-by type operation\n+\n+    Parameters\n+    ----------\n+    by: field to group\n+    on: duplicates field\n+    left: left frame\n+    right: right frame\n+    _merge_pieces: function for merging\n+    check_duplicates: boolean, default True\n+        should we check & clean duplicates\n+    \"\"\"\n+\n+    pieces = []\n+    if not isinstance(by, (list, tuple)):\n+        by = [by]\n+\n+    lby = left.groupby(by, sort=False)\n+\n+    # if we can groupby the rhs\n+    # then we can get vastly better perf\n+    try:\n+\n+        # we will check & remove duplicates if indicated\n+        if check_duplicates:\n+            if on is None:\n+                on = []\n+            elif not isinstance(on, (list, tuple)):\n+                on = [on]\n+\n+            if right.duplicated(by + on).any():\n+                right = right.drop_duplicates(by + on, keep='last')\n+        rby = right.groupby(by, sort=False)\n+    except KeyError:\n+        rby = None\n+\n+    for key, lhs in lby:\n+\n+        if rby is None:\n+            rhs = right\n+        else:\n+            try:\n+                rhs = right.take(rby.indices[key])\n+            except KeyError:\n+                # key doesn't exist in left\n+                lcols = lhs.columns.tolist()\n+                cols = lcols + [r for r in right.columns\n+                                if r not in set(lcols)]\n+                merged = lhs.reindex(columns=cols)\n+                merged.index = range(len(merged))\n+                pieces.append(merged)\n+                continue\n+\n+        merged = _merge_pieces(lhs, rhs)\n+\n+        # make sure join keys are in the merged\n+        # TODO, should _merge_pieces do this?\n+        for k in by:\n+            try:\n+                if k in merged:\n+                    merged[k] = key\n+            except:\n+                pass\n+\n+        pieces.append(merged)\n+\n+    # preserve the original order\n+    # if we have a missing piece this can be reset\n+    from pandas.core.reshape.concat import concat\n+    result = concat(pieces, ignore_index=True)\n+    result = result.reindex(columns=pieces[0].columns, copy=False)\n+    return result, lby\n+\n+\n+def ordered_merge(left, right, on=None,\n+                  left_on=None, right_on=None,\n+                  left_by=None, right_by=None,\n+                  fill_method=None, suffixes=('_x', '_y')):\n+\n+    warnings.warn(\"ordered_merge is deprecated and replaced by merge_ordered\",\n+                  FutureWarning, stacklevel=2)\n+    return merge_ordered(left, right, on=on,\n+                         left_on=left_on, right_on=right_on,\n+                         left_by=left_by, right_by=right_by,\n+                         fill_method=fill_method, suffixes=suffixes)\n+\n+\n+def merge_ordered(left, right, on=None,\n+                  left_on=None, right_on=None,\n+                  left_by=None, right_by=None,\n+                  fill_method=None, suffixes=('_x', '_y'),\n+                  how='outer'):\n+    \"\"\"Perform merge with optional filling/interpolation designed for ordered\n+    data like time series data. Optionally perform group-wise merge (see\n+    examples)\n+\n+    Parameters\n+    ----------\n+    left : DataFrame\n+    right : DataFrame\n+    on : label or list\n+        Field names to join on. Must be found in both DataFrames.\n+    left_on : label or list, or array-like\n+        Field names to join on in left DataFrame. Can be a vector or list of\n+        vectors of the length of the DataFrame to use a particular vector as\n+        the join key instead of columns\n+    right_on : label or list, or array-like\n+        Field names to join on in right DataFrame or vector/list of vectors per\n+        left_on docs\n+    left_by : column name or list of column names\n+        Group left DataFrame by group columns and merge piece by piece with\n+        right DataFrame\n+    right_by : column name or list of column names\n+        Group right DataFrame by group columns and merge piece by piece with\n+        left DataFrame\n+    fill_method : {'ffill', None}, default None\n+        Interpolation method for data\n+    suffixes : 2-length sequence (tuple, list, ...)\n+        Suffix to apply to overlapping column names in the left and right\n+        side, respectively\n+    how : {'left', 'right', 'outer', 'inner'}, default 'outer'\n+        * left: use only keys from left frame (SQL: left outer join)\n+        * right: use only keys from right frame (SQL: right outer join)\n+        * outer: use union of keys from both frames (SQL: full outer join)\n+        * inner: use intersection of keys from both frames (SQL: inner join)\n+\n+        .. versionadded:: 0.19.0\n+\n+    Examples\n+    --------\n+    >>> A                      >>> B\n+          key  lvalue group        key  rvalue\n+    0   a       1     a        0     b       1\n+    1   c       2     a        1     c       2\n+    2   e       3     a        2     d       3\n+    3   a       1     b\n+    4   c       2     b\n+    5   e       3     b\n+\n+    >>> ordered_merge(A, B, fill_method='ffill', left_by='group')\n+       key  lvalue group  rvalue\n+    0    a       1     a     NaN\n+    1    b       1     a       1\n+    2    c       2     a       2\n+    3    d       2     a       3\n+    4    e       3     a       3\n+    5    f       3     a       4\n+    6    a       1     b     NaN\n+    7    b       1     b       1\n+    8    c       2     b       2\n+    9    d       2     b       3\n+    10   e       3     b       3\n+    11   f       3     b       4\n+\n+    Returns\n+    -------\n+    merged : DataFrame\n+        The output type will the be same as 'left', if it is a subclass\n+        of DataFrame.\n+\n+    See also\n+    --------\n+    merge\n+    merge_asof\n+\n+    \"\"\"\n+    def _merger(x, y):\n+        # perform the ordered merge operation\n+        op = _OrderedMerge(x, y, on=on, left_on=left_on, right_on=right_on,\n+                           suffixes=suffixes, fill_method=fill_method,\n+                           how=how)\n+        return op.get_result()\n+\n+    if left_by is not None and right_by is not None:\n+        raise ValueError('Can only group either left or right frames')\n+    elif left_by is not None:\n+        result, _ = _groupby_and_merge(left_by, on, left, right,\n+                                       lambda x, y: _merger(x, y),\n+                                       check_duplicates=False)\n+    elif right_by is not None:\n+        result, _ = _groupby_and_merge(right_by, on, right, left,\n+                                       lambda x, y: _merger(y, x),\n+                                       check_duplicates=False)\n+    else:\n+        result = _merger(left, right)\n+    return result\n+\n+\n+ordered_merge.__doc__ = merge_ordered.__doc__\n+\n+\n+def merge_asof(left, right, on=None,\n+               left_on=None, right_on=None,\n+               left_index=False, right_index=False,\n+               by=None, left_by=None, right_by=None,\n+               suffixes=('_x', '_y'),\n+               tolerance=None,\n+               allow_exact_matches=True,\n+               direction='backward'):\n+    \"\"\"Perform an asof merge. This is similar to a left-join except that we\n+    match on nearest key rather than equal keys.\n+\n+    Both DataFrames must be sorted by the key.\n+\n+    For each row in the left DataFrame:\n+\n+      - A \"backward\" search selects the last row in the right DataFrame whose\n+        'on' key is less than or equal to the left's key.\n+\n+      - A \"forward\" search selects the first row in the right DataFrame whose\n+        'on' key is greater than or equal to the left's key.\n+\n+      - A \"nearest\" search selects the row in the right DataFrame whose 'on'\n+        key is closest in absolute distance to the left's key.\n+\n+    The default is \"backward\" and is compatible in versions below 0.20.0.\n+    The direction parameter was added in version 0.20.0 and introduces\n+    \"forward\" and \"nearest\".\n+\n+    Optionally match on equivalent keys with 'by' before searching with 'on'.\n+\n+    .. versionadded:: 0.19.0\n+\n+    Parameters\n+    ----------\n+    left : DataFrame\n+    right : DataFrame\n+    on : label\n+        Field name to join on. Must be found in both DataFrames.\n+        The data MUST be ordered. Furthermore this must be a numeric column,\n+        such as datetimelike, integer, or float. On or left_on/right_on\n+        must be given.\n+    left_on : label\n+        Field name to join on in left DataFrame.\n+    right_on : label\n+        Field name to join on in right DataFrame.\n+    left_index : boolean\n+        Use the index of the left DataFrame as the join key.\n+\n+        .. versionadded:: 0.19.2\n+\n+    right_index : boolean\n+        Use the index of the right DataFrame as the join key.\n+\n+        .. versionadded:: 0.19.2\n+\n+    by : column name or list of column names\n+        Match on these columns before performing merge operation.\n+    left_by : column name\n+        Field names to match on in the left DataFrame.\n+\n+        .. versionadded:: 0.19.2\n+\n+    right_by : column name\n+        Field names to match on in the right DataFrame.\n+\n+        .. versionadded:: 0.19.2\n+\n+    suffixes : 2-length sequence (tuple, list, ...)\n+        Suffix to apply to overlapping column names in the left and right\n+        side, respectively.\n+    tolerance : integer or Timedelta, optional, default None\n+        Select asof tolerance within this range; must be compatible\n+        with the merge index.\n+    allow_exact_matches : boolean, default True\n+\n+        - If True, allow matching with the same 'on' value\n+          (i.e. less-than-or-equal-to / greater-than-or-equal-to)\n+        - If False, don't match the same 'on' value\n+          (i.e., stricly less-than / strictly greater-than)\n+\n+    direction : 'backward' (default), 'forward', or 'nearest'\n+        Whether to search for prior, subsequent, or closest matches.\n+\n+        .. versionadded:: 0.20.0\n+\n+    Returns\n+    -------\n+    merged : DataFrame\n+\n+    Examples\n+    --------\n+    >>> left\n+        a left_val\n+    0   1        a\n+    1   5        b\n+    2  10        c\n+\n+    >>> right\n+       a  right_val\n+    0  1          1\n+    1  2          2\n+    2  3          3\n+    3  6          6\n+    4  7          7\n+\n+    >>> pd.merge_asof(left, right, on='a')\n+        a left_val  right_val\n+    0   1        a          1\n+    1   5        b          3\n+    2  10        c          7\n+\n+    >>> pd.merge_asof(left, right, on='a', allow_exact_matches=False)\n+        a left_val  right_val\n+    0   1        a        NaN\n+    1   5        b        3.0\n+    2  10        c        7.0\n+\n+    >>> pd.merge_asof(left, right, on='a', direction='forward')\n+        a left_val  right_val\n+    0   1        a        1.0\n+    1   5        b        6.0\n+    2  10        c        NaN\n+\n+    >>> pd.merge_asof(left, right, on='a', direction='nearest')\n+        a left_val  right_val\n+    0   1        a          1\n+    1   5        b          6\n+    2  10        c          7\n+\n+    We can use indexed DataFrames as well.\n+\n+    >>> left\n+       left_val\n+    1         a\n+    5         b\n+    10        c\n+\n+    >>> right\n+       right_val\n+    1          1\n+    2          2\n+    3          3\n+    6          6\n+    7          7\n+\n+    >>> pd.merge_asof(left, right, left_index=True, right_index=True)\n+       left_val  right_val\n+    1         a          1\n+    5         b          3\n+    10        c          7\n+\n+    Here is a real-world times-series example\n+\n+    >>> quotes\n+                         time ticker     bid     ask\n+    0 2016-05-25 13:30:00.023   GOOG  720.50  720.93\n+    1 2016-05-25 13:30:00.023   MSFT   51.95   51.96\n+    2 2016-05-25 13:30:00.030   MSFT   51.97   51.98\n+    3 2016-05-25 13:30:00.041   MSFT   51.99   52.00\n+    4 2016-05-25 13:30:00.048   GOOG  720.50  720.93\n+    5 2016-05-25 13:30:00.049   AAPL   97.99   98.01\n+    6 2016-05-25 13:30:00.072   GOOG  720.50  720.88\n+    7 2016-05-25 13:30:00.075   MSFT   52.01   52.03\n+\n+    >>> trades\n+                         time ticker   price  quantity\n+    0 2016-05-25 13:30:00.023   MSFT   51.95        75\n+    1 2016-05-25 13:30:00.038   MSFT   51.95       155\n+    2 2016-05-25 13:30:00.048   GOOG  720.77       100\n+    3 2016-05-25 13:30:00.048   GOOG  720.92       100\n+    4 2016-05-25 13:30:00.048   AAPL   98.00       100\n+\n+    By default we are taking the asof of the quotes\n+\n+    >>> pd.merge_asof(trades, quotes,\n+    ...                       on='time',\n+    ...                       by='ticker')\n+                         time ticker   price  quantity     bid     ask\n+    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96\n+    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98\n+    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93\n+    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93\n+    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN\n+\n+    We only asof within 2ms betwen the quote time and the trade time\n+\n+    >>> pd.merge_asof(trades, quotes,\n+    ...                       on='time',\n+    ...                       by='ticker',\n+    ...                       tolerance=pd.Timedelta('2ms'))\n+                         time ticker   price  quantity     bid     ask\n+    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96\n+    1 2016-05-25 13:30:00.038   MSFT   51.95       155     NaN     NaN\n+    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93\n+    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93\n+    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN\n+\n+    We only asof within 10ms betwen the quote time and the trade time\n+    and we exclude exact matches on time. However *prior* data will\n+    propogate forward\n+\n+    >>> pd.merge_asof(trades, quotes,\n+    ...                       on='time',\n+    ...                       by='ticker',\n+    ...                       tolerance=pd.Timedelta('10ms'),\n+    ...                       allow_exact_matches=False)\n+                         time ticker   price  quantity     bid     ask\n+    0 2016-05-25 13:30:00.023   MSFT   51.95        75     NaN     NaN\n+    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98\n+    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93\n+    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93\n+    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN\n+\n+    See also\n+    --------\n+    merge\n+    merge_ordered\n+\n+    \"\"\"\n+    op = _AsOfMerge(left, right,\n+                    on=on, left_on=left_on, right_on=right_on,\n+                    left_index=left_index, right_index=right_index,\n+                    by=by, left_by=left_by, right_by=right_by,\n+                    suffixes=suffixes,\n+                    how='asof', tolerance=tolerance,\n+                    allow_exact_matches=allow_exact_matches,\n+                    direction=direction)\n+    return op.get_result()\n+\n+\n+# TODO: transformations??\n+# TODO: only copy DataFrames when modification necessary\n+class _MergeOperation(object):\n+    \"\"\"\n+    Perform a database (SQL) merge operation between two DataFrame objects\n+    using either columns as keys or their row indexes\n+    \"\"\"\n+    _merge_type = 'merge'\n+\n+    def __init__(self, left, right, how='inner', on=None,\n+                 left_on=None, right_on=None, axis=1,\n+                 left_index=False, right_index=False, sort=True,\n+                 suffixes=('_x', '_y'), copy=True, indicator=False):\n+        self.left = self.orig_left = left\n+        self.right = self.orig_right = right\n+        self.how = how\n+        self.axis = axis\n+\n+        self.on = com._maybe_make_list(on)\n+        self.left_on = com._maybe_make_list(left_on)\n+        self.right_on = com._maybe_make_list(right_on)\n+\n+        self.copy = copy\n+        self.suffixes = suffixes\n+        self.sort = sort\n+\n+        self.left_index = left_index\n+        self.right_index = right_index\n+\n+        self.indicator = indicator\n+\n+        if isinstance(self.indicator, compat.string_types):\n+            self.indicator_name = self.indicator\n+        elif isinstance(self.indicator, bool):\n+            self.indicator_name = '_merge' if self.indicator else None\n+        else:\n+            raise ValueError(\n+                'indicator option can only accept boolean or string arguments')\n+\n+        if not isinstance(left, DataFrame):\n+            raise ValueError(\n+                'can not merge DataFrame with instance of '\n+                'type {0}'.format(type(left)))\n+        if not isinstance(right, DataFrame):\n+            raise ValueError(\n+                'can not merge DataFrame with instance of '\n+                'type {0}'.format(type(right)))\n+\n+        if not is_bool(left_index):\n+            raise ValueError(\n+                'left_index parameter must be of type bool, not '\n+                '{0}'.format(type(left_index)))\n+        if not is_bool(right_index):\n+            raise ValueError(\n+                'right_index parameter must be of type bool, not '\n+                '{0}'.format(type(right_index)))\n+\n+        # warn user when merging between different levels\n+        if left.columns.nlevels != right.columns.nlevels:\n+            msg = ('merging between different levels can give an unintended '\n+                   'result ({0} levels on the left, {1} on the right)')\n+            msg = msg.format(left.columns.nlevels, right.columns.nlevels)\n+            warnings.warn(msg, UserWarning)\n+\n+        self._validate_specification()\n+\n+        # note this function has side effects\n+        (self.left_join_keys,\n+         self.right_join_keys,\n+         self.join_names) = self._get_merge_keys()\n+\n+        # validate the merge keys dtypes. We may need to coerce\n+        # to avoid incompat dtypes\n+        self._maybe_coerce_merge_keys()\n+\n+    def get_result(self):\n+        if self.indicator:\n+            self.left, self.right = self._indicator_pre_merge(\n+                self.left, self.right)\n+\n+        join_index, left_indexer, right_indexer = self._get_join_info()\n+\n+        ldata, rdata = self.left._data, self.right._data\n+        lsuf, rsuf = self.suffixes\n+\n+        llabels, rlabels = items_overlap_with_suffix(ldata.items, lsuf,\n+                                                     rdata.items, rsuf)\n+\n+        lindexers = {1: left_indexer} if left_indexer is not None else {}\n+        rindexers = {1: right_indexer} if right_indexer is not None else {}\n+\n+        result_data = concatenate_block_managers(\n+            [(ldata, lindexers), (rdata, rindexers)],\n+            axes=[llabels.append(rlabels), join_index],\n+            concat_axis=0, copy=self.copy)\n+\n+        typ = self.left._constructor\n+        result = typ(result_data).__finalize__(self, method=self._merge_type)\n+\n+        if self.indicator:\n+            result = self._indicator_post_merge(result)\n+\n+        self._maybe_add_join_keys(result, left_indexer, right_indexer)\n+\n+        return result\n+\n+    def _indicator_pre_merge(self, left, right):\n+\n+        columns = left.columns.union(right.columns)\n+\n+        for i in ['_left_indicator', '_right_indicator']:\n+            if i in columns:\n+                raise ValueError(\"Cannot use `indicator=True` option when \"\n+                                 \"data contains a column named {}\".format(i))\n+        if self.indicator_name in columns:\n+            raise ValueError(\n+                \"Cannot use name of an existing column for indicator column\")\n+\n+        left = left.copy()\n+        right = right.copy()\n+\n+        left['_left_indicator'] = 1\n+        left['_left_indicator'] = left['_left_indicator'].astype('int8')\n+\n+        right['_right_indicator'] = 2\n+        right['_right_indicator'] = right['_right_indicator'].astype('int8')\n+\n+        return left, right\n+\n+    def _indicator_post_merge(self, result):\n+\n+        result['_left_indicator'] = result['_left_indicator'].fillna(0)\n+        result['_right_indicator'] = result['_right_indicator'].fillna(0)\n+\n+        result[self.indicator_name] = Categorical((result['_left_indicator'] +\n+                                                   result['_right_indicator']),\n+                                                  categories=[1, 2, 3])\n+        result[self.indicator_name] = (\n+            result[self.indicator_name]\n+            .cat.rename_categories(['left_only', 'right_only', 'both']))\n+\n+        result = result.drop(labels=['_left_indicator', '_right_indicator'],\n+                             axis=1)\n+        return result\n+\n+    def _maybe_add_join_keys(self, result, left_indexer, right_indexer):\n+\n+        left_has_missing = None\n+        right_has_missing = None\n+\n+        keys = zip(self.join_names, self.left_on, self.right_on)\n+        for i, (name, lname, rname) in enumerate(keys):\n+            if not _should_fill(lname, rname):\n+                continue\n+\n+            take_left, take_right = None, None\n+\n+            if name in result:\n+\n+                if left_indexer is not None and right_indexer is not None:\n+                    if name in self.left:\n+\n+                        if left_has_missing is None:\n+                            left_has_missing = (left_indexer == -1).any()\n+\n+                        if left_has_missing:\n+                            take_right = self.right_join_keys[i]\n+\n+                            if not is_dtype_equal(result[name].dtype,\n+                                                  self.left[name].dtype):\n+                                take_left = self.left[name]._values\n+\n+                    elif name in self.right:\n+\n+                        if right_has_missing is None:\n+                            right_has_missing = (right_indexer == -1).any()\n+\n+                        if right_has_missing:\n+                            take_left = self.left_join_keys[i]\n+\n+                            if not is_dtype_equal(result[name].dtype,\n+                                                  self.right[name].dtype):\n+                                take_right = self.right[name]._values\n+\n+            elif left_indexer is not None \\\n+                    and isinstance(self.left_join_keys[i], np.ndarray):\n+\n+                take_left = self.left_join_keys[i]\n+                take_right = self.right_join_keys[i]\n+\n+            if take_left is not None or take_right is not None:\n+\n+                if take_left is None:\n+                    lvals = result[name]._values\n+                else:\n+                    lfill = na_value_for_dtype(take_left.dtype)\n+                    lvals = algos.take_1d(take_left, left_indexer,\n+                                          fill_value=lfill)\n+\n+                if take_right is None:\n+                    rvals = result[name]._values\n+                else:\n+                    rfill = na_value_for_dtype(take_right.dtype)\n+                    rvals = algos.take_1d(take_right, right_indexer,\n+                                          fill_value=rfill)\n+\n+                # if we have an all missing left_indexer\n+                # make sure to just use the right values\n+                mask = left_indexer == -1\n+                if mask.all():\n+                    key_col = rvals\n+                else:\n+                    key_col = Index(lvals).where(~mask, rvals)\n+\n+                if name in result:\n+                    result[name] = key_col\n+                else:\n+                    result.insert(i, name or 'key_%d' % i, key_col)\n+\n+    def _get_join_indexers(self):\n+        \"\"\" return the join indexers \"\"\"\n+        return _get_join_indexers(self.left_join_keys,\n+                                  self.right_join_keys,\n+                                  sort=self.sort,\n+                                  how=self.how)\n+\n+    def _get_join_info(self):\n+        left_ax = self.left._data.axes[self.axis]\n+        right_ax = self.right._data.axes[self.axis]\n+\n+        if self.left_index and self.right_index and self.how != 'asof':\n+            join_index, left_indexer, right_indexer = \\\n+                left_ax.join(right_ax, how=self.how, return_indexers=True,\n+                             sort=self.sort)\n+        elif self.right_index and self.how == 'left':\n+            join_index, left_indexer, right_indexer = \\\n+                _left_join_on_index(left_ax, right_ax, self.left_join_keys,\n+                                    sort=self.sort)\n+\n+        elif self.left_index and self.how == 'right':\n+            join_index, right_indexer, left_indexer = \\\n+                _left_join_on_index(right_ax, left_ax, self.right_join_keys,\n+                                    sort=self.sort)\n+        else:\n+            (left_indexer,\n+             right_indexer) = self._get_join_indexers()\n+\n+            if self.right_index:\n+                if len(self.left) > 0:\n+                    join_index = self.left.index.take(left_indexer)\n+                else:\n+                    join_index = self.right.index.take(right_indexer)\n+                    left_indexer = np.array([-1] * len(join_index))\n+            elif self.left_index:\n+                if len(self.right) > 0:\n+                    join_index = self.right.index.take(right_indexer)\n+                else:\n+                    join_index = self.left.index.take(left_indexer)\n+                    right_indexer = np.array([-1] * len(join_index))\n+            else:\n+                join_index = Index(np.arange(len(left_indexer)))\n+\n+        if len(join_index) == 0:\n+            join_index = join_index.astype(object)\n+        return join_index, left_indexer, right_indexer\n+\n+    def _get_merge_keys(self):\n+        \"\"\"\n+        Note: has side effects (copy/delete key columns)\n+\n+        Parameters\n+        ----------\n+        left\n+        right\n+        on\n+\n+        Returns\n+        -------\n+        left_keys, right_keys\n+        \"\"\"\n+        left_keys = []\n+        right_keys = []\n+        join_names = []\n+        right_drop = []\n+        left_drop = []\n+        left, right = self.left, self.right\n+\n+        is_lkey = lambda x: isinstance(\n+            x, (np.ndarray, Series)) and len(x) == len(left)\n+        is_rkey = lambda x: isinstance(\n+            x, (np.ndarray, Series)) and len(x) == len(right)\n+\n+        # Note that pd.merge_asof() has separate 'on' and 'by' parameters. A\n+        # user could, for example, request 'left_index' and 'left_by'. In a\n+        # regular pd.merge(), users cannot specify both 'left_index' and\n+        # 'left_on'. (Instead, users have a MultiIndex). That means the\n+        # self.left_on in this function is always empty in a pd.merge(), but\n+        # a pd.merge_asof(left_index=True, left_by=...) will result in a\n+        # self.left_on array with a None in the middle of it. This requires\n+        # a work-around as designated in the code below.\n+        # See _validate_specification() for where this happens.\n+\n+        # ugh, spaghetti re #733\n+        if _any(self.left_on) and _any(self.right_on):\n+            for lk, rk in zip(self.left_on, self.right_on):\n+                if is_lkey(lk):\n+                    left_keys.append(lk)\n+                    if is_rkey(rk):\n+                        right_keys.append(rk)\n+                        join_names.append(None)  # what to do?\n+                    else:\n+                        if rk is not None:\n+                            right_keys.append(right[rk]._values)\n+                            join_names.append(rk)\n+                        else:\n+                            # work-around for merge_asof(right_index=True)\n+                            right_keys.append(right.index)\n+                            join_names.append(right.index.name)\n+                else:\n+                    if not is_rkey(rk):\n+                        if rk is not None:\n+                            right_keys.append(right[rk]._values)\n+                        else:\n+                            # work-around for merge_asof(right_index=True)\n+                            right_keys.append(right.index)\n+                        if lk is not None and lk == rk:\n+                            # avoid key upcast in corner case (length-0)\n+                            if len(left) > 0:\n+                                right_drop.append(rk)\n+                            else:\n+                                left_drop.append(lk)\n+                    else:\n+                        right_keys.append(rk)\n+                    if lk is not None:\n+                        left_keys.append(left[lk]._values)\n+                        join_names.append(lk)\n+                    else:\n+                        # work-around for merge_asof(left_index=True)\n+                        left_keys.append(left.index)\n+                        join_names.append(left.index.name)\n+        elif _any(self.left_on):\n+            for k in self.left_on:\n+                if is_lkey(k):\n+                    left_keys.append(k)\n+                    join_names.append(None)\n+                else:\n+                    left_keys.append(left[k]._values)\n+                    join_names.append(k)\n+            if isinstance(self.right.index, MultiIndex):\n+                right_keys = [lev._values.take(lab)\n+                              for lev, lab in zip(self.right.index.levels,\n+                                                  self.right.index.labels)]\n+            else:\n+                right_keys = [self.right.index.values]\n+        elif _any(self.right_on):\n+            for k in self.right_on:\n+                if is_rkey(k):\n+                    right_keys.append(k)\n+                    join_names.append(None)\n+                else:\n+                    right_keys.append(right[k]._values)\n+                    join_names.append(k)\n+            if isinstance(self.left.index, MultiIndex):\n+                left_keys = [lev._values.take(lab)\n+                             for lev, lab in zip(self.left.index.levels,\n+                                                 self.left.index.labels)]\n+            else:\n+                left_keys = [self.left.index.values]\n+\n+        if left_drop:\n+            self.left = self.left.drop(left_drop, axis=1)\n+\n+        if right_drop:\n+            self.right = self.right.drop(right_drop, axis=1)\n+\n+        return left_keys, right_keys, join_names\n+\n+    def _maybe_coerce_merge_keys(self):\n+        # we have valid mergee's but we may have to further\n+        # coerce these if they are originally incompatible types\n+        #\n+        # for example if these are categorical, but are not dtype_equal\n+        # or if we have object and integer dtypes\n+\n+        for lk, rk, name in zip(self.left_join_keys,\n+                                self.right_join_keys,\n+                                self.join_names):\n+            if (len(lk) and not len(rk)) or (not len(lk) and len(rk)):\n+                continue\n+\n+            # if either left or right is a categorical\n+            # then the must match exactly in categories & ordered\n+            if is_categorical_dtype(lk) and is_categorical_dtype(rk):\n+                if lk.is_dtype_equal(rk):\n+                    continue\n+            elif is_categorical_dtype(lk) or is_categorical_dtype(rk):\n+                pass\n+\n+            elif is_dtype_equal(lk.dtype, rk.dtype):\n+                continue\n+\n+            # if we are numeric, then allow differing\n+            # kinds to proceed, eg. int64 and int8\n+            # further if we are object, but we infer to\n+            # the same, then proceed\n+            if (is_numeric_dtype(lk) and is_numeric_dtype(rk)):\n+                if lk.dtype.kind == rk.dtype.kind:\n+                    continue\n+\n+                # let's infer and see if we are ok\n+                if lib.infer_dtype(lk) == lib.infer_dtype(rk):\n+                    continue\n+\n+            # Houston, we have a problem!\n+            # let's coerce to object\n+            if name in self.left.columns:\n+                self.left = self.left.assign(\n+                    **{name: self.left[name].astype(object)})\n+            if name in self.right.columns:\n+                self.right = self.right.assign(\n+                    **{name: self.right[name].astype(object)})\n+\n+    def _validate_specification(self):\n+        # Hm, any way to make this logic less complicated??\n+        if self.on is None and self.left_on is None and self.right_on is None:\n+\n+            if self.left_index and self.right_index:\n+                self.left_on, self.right_on = (), ()\n+            elif self.left_index:\n+                if self.right_on is None:\n+                    raise MergeError('Must pass right_on or right_index=True')\n+            elif self.right_index:\n+                if self.left_on is None:\n+                    raise MergeError('Must pass left_on or left_index=True')\n+            else:\n+                # use the common columns\n+                common_cols = self.left.columns.intersection(\n+                    self.right.columns)\n+                if len(common_cols) == 0:\n+                    raise MergeError('No common columns to perform merge on')\n+                if not common_cols.is_unique:\n+                    raise MergeError(\"Data columns not unique: %s\"\n+                                     % repr(common_cols))\n+                self.left_on = self.right_on = common_cols\n+        elif self.on is not None:\n+            if self.left_on is not None or self.right_on is not None:\n+                raise MergeError('Can only pass argument \"on\" OR \"left_on\" '\n+                                 'and \"right_on\", not a combination of both.')\n+            self.left_on = self.right_on = self.on\n+        elif self.left_on is not None:\n+            n = len(self.left_on)\n+            if self.right_index:\n+                if len(self.left_on) != self.right.index.nlevels:\n+                    raise ValueError('len(left_on) must equal the number '\n+                                     'of levels in the index of \"right\"')\n+                self.right_on = [None] * n\n+        elif self.right_on is not None:\n+            n = len(self.right_on)\n+            if self.left_index:\n+                if len(self.right_on) != self.left.index.nlevels:\n+                    raise ValueError('len(right_on) must equal the number '\n+                                     'of levels in the index of \"left\"')\n+                self.left_on = [None] * n\n+        if len(self.right_on) != len(self.left_on):\n+            raise ValueError(\"len(right_on) must equal len(left_on)\")\n+\n+\n+def _get_join_indexers(left_keys, right_keys, sort=False, how='inner',\n+                       **kwargs):\n+    \"\"\"\n+\n+    Parameters\n+    ----------\n+    left_keys: ndarray, Index, Series\n+    right_keys: ndarray, Index, Series\n+    sort: boolean, default False\n+    how: string {'inner', 'outer', 'left', 'right'}, default 'inner'\n+\n+    Returns\n+    -------\n+    tuple of (left_indexer, right_indexer)\n+        indexers into the left_keys, right_keys\n+\n+    \"\"\"\n+    from functools import partial\n+\n+    assert len(left_keys) == len(right_keys), \\\n+        'left_key and right_keys must be the same length'\n+\n+    # bind `sort` arg. of _factorize_keys\n+    fkeys = partial(_factorize_keys, sort=sort)\n+\n+    # get left & right join labels and num. of levels at each location\n+    llab, rlab, shape = map(list, zip(* map(fkeys, left_keys, right_keys)))\n+\n+    # get flat i8 keys from label lists\n+    lkey, rkey = _get_join_keys(llab, rlab, shape, sort)\n+\n+    # factorize keys to a dense i8 space\n+    # `count` is the num. of unique keys\n+    # set(lkey) | set(rkey) == range(count)\n+    lkey, rkey, count = fkeys(lkey, rkey)\n+\n+    # preserve left frame order if how == 'left' and sort == False\n+    kwargs = copy.copy(kwargs)\n+    if how == 'left':\n+        kwargs['sort'] = sort\n+    join_func = _join_functions[how]\n+\n+    return join_func(lkey, rkey, count, **kwargs)\n+\n+\n+class _OrderedMerge(_MergeOperation):\n+    _merge_type = 'ordered_merge'\n+\n+    def __init__(self, left, right, on=None, left_on=None, right_on=None,\n+                 left_index=False, right_index=False, axis=1,\n+                 suffixes=('_x', '_y'), copy=True,\n+                 fill_method=None, how='outer'):\n+\n+        self.fill_method = fill_method\n+        _MergeOperation.__init__(self, left, right, on=on, left_on=left_on,\n+                                 left_index=left_index,\n+                                 right_index=right_index,\n+                                 right_on=right_on, axis=axis,\n+                                 how=how, suffixes=suffixes,\n+                                 sort=True  # factorize sorts\n+                                 )\n+\n+    def get_result(self):\n+        join_index, left_indexer, right_indexer = self._get_join_info()\n+\n+        # this is a bit kludgy\n+        ldata, rdata = self.left._data, self.right._data\n+        lsuf, rsuf = self.suffixes\n+\n+        llabels, rlabels = items_overlap_with_suffix(ldata.items, lsuf,\n+                                                     rdata.items, rsuf)\n+\n+        if self.fill_method == 'ffill':\n+            left_join_indexer = libjoin.ffill_indexer(left_indexer)\n+            right_join_indexer = libjoin.ffill_indexer(right_indexer)\n+        else:\n+            left_join_indexer = left_indexer\n+            right_join_indexer = right_indexer\n+\n+        lindexers = {\n+            1: left_join_indexer} if left_join_indexer is not None else {}\n+        rindexers = {\n+            1: right_join_indexer} if right_join_indexer is not None else {}\n+\n+        result_data = concatenate_block_managers(\n+            [(ldata, lindexers), (rdata, rindexers)],\n+            axes=[llabels.append(rlabels), join_index],\n+            concat_axis=0, copy=self.copy)\n+\n+        typ = self.left._constructor\n+        result = typ(result_data).__finalize__(self, method=self._merge_type)\n+\n+        self._maybe_add_join_keys(result, left_indexer, right_indexer)\n+\n+        return result\n+\n+\n+def _asof_function(direction, on_type):\n+    return getattr(libjoin, 'asof_join_%s_%s' % (direction, on_type), None)\n+\n+\n+def _asof_by_function(direction, on_type, by_type):\n+    return getattr(libjoin, 'asof_join_%s_%s_by_%s' %\n+                   (direction, on_type, by_type), None)\n+\n+\n+_type_casters = {\n+    'int64_t': _ensure_int64,\n+    'double': _ensure_float64,\n+    'object': _ensure_object,\n+}\n+\n+_cython_types = {\n+    'uint8': 'uint8_t',\n+    'uint32': 'uint32_t',\n+    'uint16': 'uint16_t',\n+    'uint64': 'uint64_t',\n+    'int8': 'int8_t',\n+    'int32': 'int32_t',\n+    'int16': 'int16_t',\n+    'int64': 'int64_t',\n+    'float16': 'error',\n+    'float32': 'float',\n+    'float64': 'double',\n+}\n+\n+\n+def _get_cython_type(dtype):\n+    \"\"\" Given a dtype, return a C name like 'int64_t' or 'double' \"\"\"\n+    type_name = _get_dtype(dtype).name\n+    ctype = _cython_types.get(type_name, 'object')\n+    if ctype == 'error':\n+        raise MergeError('unsupported type: ' + type_name)\n+    return ctype\n+\n+\n+def _get_cython_type_upcast(dtype):\n+    \"\"\" Upcast a dtype to 'int64_t', 'double', or 'object' \"\"\"\n+    if is_integer_dtype(dtype):\n+        return 'int64_t'\n+    elif is_float_dtype(dtype):\n+        return 'double'\n+    else:\n+        return 'object'\n+\n+\n+class _AsOfMerge(_OrderedMerge):\n+    _merge_type = 'asof_merge'\n+\n+    def __init__(self, left, right, on=None, left_on=None, right_on=None,\n+                 left_index=False, right_index=False,\n+                 by=None, left_by=None, right_by=None,\n+                 axis=1, suffixes=('_x', '_y'), copy=True,\n+                 fill_method=None,\n+                 how='asof', tolerance=None,\n+                 allow_exact_matches=True,\n+                 direction='backward'):\n+\n+        self.by = by\n+        self.left_by = left_by\n+        self.right_by = right_by\n+        self.tolerance = tolerance\n+        self.allow_exact_matches = allow_exact_matches\n+        self.direction = direction\n+\n+        _OrderedMerge.__init__(self, left, right, on=on, left_on=left_on,\n+                               right_on=right_on, left_index=left_index,\n+                               right_index=right_index, axis=axis,\n+                               how=how, suffixes=suffixes,\n+                               fill_method=fill_method)\n+\n+    def _validate_specification(self):\n+        super(_AsOfMerge, self)._validate_specification()\n+\n+        # we only allow on to be a single item for on\n+        if len(self.left_on) != 1 and not self.left_index:\n+            raise MergeError(\"can only asof on a key for left\")\n+\n+        if len(self.right_on) != 1 and not self.right_index:\n+            raise MergeError(\"can only asof on a key for right\")\n+\n+        if self.left_index and isinstance(self.left.index, MultiIndex):\n+            raise MergeError(\"left can only have one index\")\n+\n+        if self.right_index and isinstance(self.right.index, MultiIndex):\n+            raise MergeError(\"right can only have one index\")\n+\n+        # set 'by' columns\n+        if self.by is not None:\n+            if self.left_by is not None or self.right_by is not None:\n+                raise MergeError('Can only pass by OR left_by '\n+                                 'and right_by')\n+            self.left_by = self.right_by = self.by\n+        if self.left_by is None and self.right_by is not None:\n+            raise MergeError('missing left_by')\n+        if self.left_by is not None and self.right_by is None:\n+            raise MergeError('missing right_by')\n+\n+        # add 'by' to our key-list so we can have it in the\n+        # output as a key\n+        if self.left_by is not None:\n+            if not is_list_like(self.left_by):\n+                self.left_by = [self.left_by]\n+            if not is_list_like(self.right_by):\n+                self.right_by = [self.right_by]\n+\n+            if len(self.left_by) != len(self.right_by):\n+                raise MergeError('left_by and right_by must be same length')\n+\n+            self.left_on = self.left_by + list(self.left_on)\n+            self.right_on = self.right_by + list(self.right_on)\n+\n+        # check 'direction' is valid\n+        if self.direction not in ['backward', 'forward', 'nearest']:\n+            raise MergeError('direction invalid: ' + self.direction)\n+\n+    @property\n+    def _asof_key(self):\n+        \"\"\" This is our asof key, the 'on' \"\"\"\n+        return self.left_on[-1]\n+\n+    def _get_merge_keys(self):\n+\n+        # note this function has side effects\n+        (left_join_keys,\n+         right_join_keys,\n+         join_names) = super(_AsOfMerge, self)._get_merge_keys()\n+\n+        # validate index types are the same\n+        for lk, rk in zip(left_join_keys, right_join_keys):\n+            if not is_dtype_equal(lk.dtype, rk.dtype):\n+                raise MergeError(\"incompatible merge keys, \"\n+                                 \"must be the same type\")\n+\n+        # validate tolerance; must be a Timedelta if we have a DTI\n+        if self.tolerance is not None:\n+\n+            if self.left_index:\n+                lt = self.left.index\n+            else:\n+                lt = left_join_keys[-1]\n+\n+            msg = \"incompatible tolerance, must be compat \" \\\n+                  \"with type {0}\".format(type(lt))\n+\n+            if is_datetime64_dtype(lt) or is_datetime64tz_dtype(lt):\n+                if not isinstance(self.tolerance, Timedelta):\n+                    raise MergeError(msg)\n+                if self.tolerance < Timedelta(0):\n+                    raise MergeError(\"tolerance must be positive\")\n+\n+            elif is_int64_dtype(lt):\n+                if not is_integer(self.tolerance):\n+                    raise MergeError(msg)\n+                if self.tolerance < 0:\n+                    raise MergeError(\"tolerance must be positive\")\n+\n+            else:\n+                raise MergeError(\"key must be integer or timestamp\")\n+\n+        # validate allow_exact_matches\n+        if not is_bool(self.allow_exact_matches):\n+            raise MergeError(\"allow_exact_matches must be boolean, \"\n+                             \"passed {0}\".format(self.allow_exact_matches))\n+\n+        return left_join_keys, right_join_keys, join_names\n+\n+    def _get_join_indexers(self):\n+        \"\"\" return the join indexers \"\"\"\n+\n+        def flip(xs):\n+            \"\"\" unlike np.transpose, this returns an array of tuples \"\"\"\n+            labels = list(string.ascii_lowercase[:len(xs)])\n+            dtypes = [x.dtype for x in xs]\n+            labeled_dtypes = list(zip(labels, dtypes))\n+            return np.array(lzip(*xs), labeled_dtypes)\n+\n+        # values to compare\n+        left_values = (self.left.index.values if self.left_index else\n+                       self.left_join_keys[-1])\n+        right_values = (self.right.index.values if self.right_index else\n+                        self.right_join_keys[-1])\n+        tolerance = self.tolerance\n+\n+        # we required sortedness in the join keys\n+        msg = \" keys must be sorted\"\n+        if not Index(left_values).is_monotonic:\n+            raise ValueError('left' + msg)\n+        if not Index(right_values).is_monotonic:\n+            raise ValueError('right' + msg)\n+\n+        # initial type conversion as needed\n+        if needs_i8_conversion(left_values):\n+            left_values = left_values.view('i8')\n+            right_values = right_values.view('i8')\n+            if tolerance is not None:\n+                tolerance = tolerance.value\n+\n+        # a \"by\" parameter requires special handling\n+        if self.left_by is not None:\n+            # remove 'on' parameter from values if one existed\n+            if self.left_index and self.right_index:\n+                left_by_values = self.left_join_keys\n+                right_by_values = self.right_join_keys\n+            else:\n+                left_by_values = self.left_join_keys[0:-1]\n+                right_by_values = self.right_join_keys[0:-1]\n+\n+            # get tuple representation of values if more than one\n+            if len(left_by_values) == 1:\n+                left_by_values = left_by_values[0]\n+                right_by_values = right_by_values[0]\n+            else:\n+                left_by_values = flip(left_by_values)\n+                right_by_values = flip(right_by_values)\n+\n+            # upcast 'by' parameter because HashTable is limited\n+            by_type = _get_cython_type_upcast(left_by_values.dtype)\n+            by_type_caster = _type_casters[by_type]\n+            left_by_values = by_type_caster(left_by_values)\n+            right_by_values = by_type_caster(right_by_values)\n+\n+            # choose appropriate function by type\n+            on_type = _get_cython_type(left_values.dtype)\n+            func = _asof_by_function(self.direction, on_type, by_type)\n+            return func(left_values,\n+                        right_values,\n+                        left_by_values,\n+                        right_by_values,\n+                        self.allow_exact_matches,\n+                        tolerance)\n+        else:\n+            # choose appropriate function by type\n+            on_type = _get_cython_type(left_values.dtype)\n+            func = _asof_function(self.direction, on_type)\n+            return func(left_values,\n+                        right_values,\n+                        self.allow_exact_matches,\n+                        tolerance)\n+\n+\n+def _get_multiindex_indexer(join_keys, index, sort):\n+    from functools import partial\n+\n+    # bind `sort` argument\n+    fkeys = partial(_factorize_keys, sort=sort)\n+\n+    # left & right join labels and num. of levels at each location\n+    rlab, llab, shape = map(list, zip(* map(fkeys, index.levels, join_keys)))\n+    if sort:\n+        rlab = list(map(np.take, rlab, index.labels))\n+    else:\n+        i8copy = lambda a: a.astype('i8', subok=False, copy=True)\n+        rlab = list(map(i8copy, index.labels))\n+\n+    # fix right labels if there were any nulls\n+    for i in range(len(join_keys)):\n+        mask = index.labels[i] == -1\n+        if mask.any():\n+            # check if there already was any nulls at this location\n+            # if there was, it is factorized to `shape[i] - 1`\n+            a = join_keys[i][llab[i] == shape[i] - 1]\n+            if a.size == 0 or not a[0] != a[0]:\n+                shape[i] += 1\n+\n+            rlab[i][mask] = shape[i] - 1\n+\n+    # get flat i8 join keys\n+    lkey, rkey = _get_join_keys(llab, rlab, shape, sort)\n+\n+    # factorize keys to a dense i8 space\n+    lkey, rkey, count = fkeys(lkey, rkey)\n+\n+    return libjoin.left_outer_join(lkey, rkey, count, sort=sort)\n+\n+\n+def _get_single_indexer(join_key, index, sort=False):\n+    left_key, right_key, count = _factorize_keys(join_key, index, sort=sort)\n+\n+    left_indexer, right_indexer = libjoin.left_outer_join(\n+        _ensure_int64(left_key),\n+        _ensure_int64(right_key),\n+        count, sort=sort)\n+\n+    return left_indexer, right_indexer\n+\n+\n+def _left_join_on_index(left_ax, right_ax, join_keys, sort=False):\n+    if len(join_keys) > 1:\n+        if not ((isinstance(right_ax, MultiIndex) and\n+                 len(join_keys) == right_ax.nlevels)):\n+            raise AssertionError(\"If more than one join key is given then \"\n+                                 \"'right_ax' must be a MultiIndex and the \"\n+                                 \"number of join keys must be the number of \"\n+                                 \"levels in right_ax\")\n+\n+        left_indexer, right_indexer = \\\n+            _get_multiindex_indexer(join_keys, right_ax, sort=sort)\n+    else:\n+        jkey = join_keys[0]\n+\n+        left_indexer, right_indexer = \\\n+            _get_single_indexer(jkey, right_ax, sort=sort)\n+\n+    if sort or len(left_ax) != len(left_indexer):\n+        # if asked to sort or there are 1-to-many matches\n+        join_index = left_ax.take(left_indexer)\n+        return join_index, left_indexer, right_indexer\n+\n+    # left frame preserves order & length of its index\n+    return left_ax, None, right_indexer\n+\n+\n+def _right_outer_join(x, y, max_groups):\n+    right_indexer, left_indexer = libjoin.left_outer_join(y, x, max_groups)\n+    return left_indexer, right_indexer\n+\n+\n+_join_functions = {\n+    'inner': libjoin.inner_join,\n+    'left': libjoin.left_outer_join,\n+    'right': _right_outer_join,\n+    'outer': libjoin.full_outer_join,\n+}\n+\n+\n+def _factorize_keys(lk, rk, sort=True):\n+    if is_datetime64tz_dtype(lk) and is_datetime64tz_dtype(rk):\n+        lk = lk.values\n+        rk = rk.values\n+\n+    # if we exactly match in categories, allow us to use codes\n+    if (is_categorical_dtype(lk) and\n+            is_categorical_dtype(rk) and\n+            lk.is_dtype_equal(rk)):\n+        return lk.codes, rk.codes, len(lk.categories)\n+\n+    if is_int_or_datetime_dtype(lk) and is_int_or_datetime_dtype(rk):\n+        klass = libhashtable.Int64Factorizer\n+        lk = _ensure_int64(com._values_from_object(lk))\n+        rk = _ensure_int64(com._values_from_object(rk))\n+    else:\n+        klass = libhashtable.Factorizer\n+        lk = _ensure_object(lk)\n+        rk = _ensure_object(rk)\n+\n+    rizer = klass(max(len(lk), len(rk)))\n+\n+    llab = rizer.factorize(lk)\n+    rlab = rizer.factorize(rk)\n+\n+    count = rizer.get_count()\n+\n+    if sort:\n+        uniques = rizer.uniques.to_array()\n+        llab, rlab = _sort_labels(uniques, llab, rlab)\n+\n+    # NA group\n+    lmask = llab == -1\n+    lany = lmask.any()\n+    rmask = rlab == -1\n+    rany = rmask.any()\n+\n+    if lany or rany:\n+        if lany:\n+            np.putmask(llab, lmask, count)\n+        if rany:\n+            np.putmask(rlab, rmask, count)\n+        count += 1\n+\n+    return llab, rlab, count\n+\n+\n+def _sort_labels(uniques, left, right):\n+    if not isinstance(uniques, np.ndarray):\n+        # tuplesafe\n+        uniques = Index(uniques).values\n+\n+    l = len(left)\n+    labels = np.concatenate([left, right])\n+\n+    _, new_labels = algos.safe_sort(uniques, labels, na_sentinel=-1)\n+    new_labels = _ensure_int64(new_labels)\n+    new_left, new_right = new_labels[:l], new_labels[l:]\n+\n+    return new_left, new_right\n+\n+\n+def _get_join_keys(llab, rlab, shape, sort):\n+\n+    # how many levels can be done without overflow\n+    pred = lambda i: not is_int64_overflow_possible(shape[:i])\n+    nlev = next(filter(pred, range(len(shape), 0, -1)))\n+\n+    # get keys for the first `nlev` levels\n+    stride = np.prod(shape[1:nlev], dtype='i8')\n+    lkey = stride * llab[0].astype('i8', subok=False, copy=False)\n+    rkey = stride * rlab[0].astype('i8', subok=False, copy=False)\n+\n+    for i in range(1, nlev):\n+        stride //= shape[i]\n+        lkey += llab[i] * stride\n+        rkey += rlab[i] * stride\n+\n+    if nlev == len(shape):  # all done!\n+        return lkey, rkey\n+\n+    # densify current keys to avoid overflow\n+    lkey, rkey, count = _factorize_keys(lkey, rkey, sort=sort)\n+\n+    llab = [lkey] + llab[nlev:]\n+    rlab = [rkey] + rlab[nlev:]\n+    shape = [count] + shape[nlev:]\n+\n+    return _get_join_keys(llab, rlab, shape, sort)\n+\n+\n+def _should_fill(lname, rname):\n+    if (not isinstance(lname, compat.string_types) or\n+            not isinstance(rname, compat.string_types)):\n+        return True\n+    return lname == rname\n+\n+\n+def _any(x):\n+    return x is not None and len(x) > 0 and any([y is not None for y in x])\n",
      "files_name_in_blame_commit": [
        "test_series.py",
        "merge.py",
        "test_generic.py",
        "api.py",
        "format.py",
        "reshape.py",
        "test_pivot.py",
        "cast.py",
        "__init__.py",
        "pivot.py",
        "test_hashing.py",
        "frame.py",
        "test_join.py",
        "groupby.py",
        "series.py",
        "test_tile.py",
        "tile.py",
        "base.py",
        "test_merge_asof.py",
        "setup.py",
        "test_merge.py",
        "util.py",
        "_core.py",
        "test_concat.py",
        "test_panel.py",
        "test_merge_ordered.py",
        "categorical.py",
        "test_util.py",
        "algorithms.py",
        "test_algos.py",
        "test_cast.py",
        "test_convert.py",
        "panel.py",
        "concat.py",
        "multi.py",
        "test_reshape.py",
        "test_union_categoricals.py",
        "expr.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 290
  },
  "recursive_blame_commits": {}
}
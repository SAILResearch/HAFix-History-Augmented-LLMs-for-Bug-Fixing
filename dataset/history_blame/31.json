{
  "id": "31",
  "blame_commit": {
    "commit": {
      "commit_id": "d3ffc915bdee59658db433a4bf5a17b09d389fa6",
      "commit_message": "REF: .values -> ._values (#32947)",
      "commit_author": "jbrockmendel",
      "commit_date": "2020-03-24 15:41:34",
      "commit_parent": "55636e6ceb759baae851d38da09729a3b91b1ac9"
    },
    "function": {
      "function_name": "_get_series_list",
      "function_code_before": "def _get_series_list(self, others):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n    from pandas import Series, DataFrame\n    idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n    if isinstance(others, ABCSeries):\n        return [others]\n    elif isinstance(others, ABCIndexClass):\n        return [Series(others.values, index=others)]\n    elif isinstance(others, ABCDataFrame):\n        return [others[x] for x in others]\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return [others[x] for x in others]\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((isinstance(x, (ABCSeries, ABCIndexClass)) or (isinstance(x, np.ndarray) and x.ndim == 1) for x in others)):\n            los = []\n            while others:\n                los = los + self._get_series_list(others.pop(0))\n            return los\n        elif all((not is_list_like(x) for x in others)):\n            return [Series(others, index=idx)]\n    raise TypeError('others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/np.ndarray[1-dim])')",
      "function_code_after": "def _get_series_list(self, others):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n    from pandas import Series, DataFrame\n    idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n    if isinstance(others, ABCSeries):\n        return [others]\n    elif isinstance(others, ABCIndexClass):\n        return [Series(others._values, index=others)]\n    elif isinstance(others, ABCDataFrame):\n        return [others[x] for x in others]\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return [others[x] for x in others]\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((isinstance(x, (ABCSeries, ABCIndexClass)) or (isinstance(x, np.ndarray) and x.ndim == 1) for x in others)):\n            los = []\n            while others:\n                los = los + self._get_series_list(others.pop(0))\n            return los\n        elif all((not is_list_like(x) for x in others)):\n            return [Series(others, index=idx)]\n    raise TypeError('others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/np.ndarray[1-dim])')",
      "function_before_start_line": 2212,
      "function_before_end_line": 2267,
      "function_after_start_line": 2212,
      "function_after_end_line": 2267,
      "function_before_token_count": 232,
      "function_after_token_count": 232,
      "functions_name_modified_file": [
        "str_endswith",
        "rsplit",
        "str_encode",
        "str_get",
        "translate",
        "lstrip",
        "str_pad",
        "_make_accessor",
        "str_count",
        "forbid_nonstring_types",
        "str_rsplit",
        "rjust",
        "rindex",
        "str_slice",
        "str_slice_replace",
        "__getitem__",
        "__init__",
        "_pat_wrapper",
        "slice",
        "extractall",
        "str_extractall",
        "get_dummies",
        "_map_object",
        "contains",
        "match",
        "wrap",
        "str_extract",
        "str_translate",
        "_noarg_wrapper",
        "partition",
        "_na_map",
        "cat_core",
        "_validate",
        "zfill",
        "_groups_or_na_fun",
        "str_replace",
        "str_join",
        "str_decode",
        "_get_single_group_name",
        "str_strip",
        "_str_extract_noexpand",
        "normalize",
        "str_find",
        "slice_replace",
        "rpartition",
        "decode",
        "ljust",
        "encode",
        "str_index",
        "str_startswith",
        "split",
        "str_findall",
        "copy",
        "pad",
        "extract",
        "rfind",
        "_str_extract_frame",
        "rstrip",
        "center",
        "find",
        "str_repeat",
        "__iter__",
        "_map_stringarray",
        "_result_dtype",
        "str_contains",
        "strip",
        "index",
        "repeat",
        "get",
        "_wrap_result",
        "str_get_dummies",
        "replace",
        "str_split",
        "_get_series_list",
        "join",
        "str_wrap",
        "cat_safe",
        "str_match",
        "cat"
      ],
      "functions_name_all_files": [
        "get_callable_name",
        "map",
        "masked_arith_op",
        "date_range",
        "freq",
        "_maybe_update_cacher",
        "_new_IntervalIndex",
        "_get_value",
        "_set_with_engine",
        "pivot_table",
        "swapaxes",
        "_make_accessor",
        "str_count",
        "get_loc",
        "_get_axis",
        "_maybe_convert_timedelta",
        "_constructor_sliced",
        "slice_shift",
        "arithmetic_op",
        "_construct_axes_from_arguments",
        "stack",
        "tshift",
        "asarray_tuplesafe",
        "__arrow_array__",
        "_sub_period",
        "_box_func",
        "is_full",
        "safe_sort",
        "_delegate_property_set",
        "_format_native_types",
        "unique",
        "_is_label_or_level_reference",
        "to_csv",
        "__gt__",
        "_pat_wrapper",
        "_get_binner",
        "_apply_meta",
        "mid",
        "describe",
        "is_nested_object",
        "to_timestamp",
        "extractall",
        "shape",
        "checked_add_with_arr",
        "components",
        "comparison_op",
        "_get_cython_type_upcast",
        "_single_replace",
        "_adjust_binner_for_upsample",
        "drop_duplicates",
        "_convert",
        "_simple_new",
        "diff",
        "_drop_axis",
        "infer_objects",
        "maybe_convert_platform_interval",
        "indexer_between_time",
        "_update_inplace",
        "take_nd",
        "maybe_infer_freq",
        "_get_period_range_edges",
        "_delegate_method",
        "size",
        "_noarg_wrapper",
        "remove_na_arraylike",
        "_is_comparable_dtype",
        "find_common_type",
        "_map_values",
        "argsort",
        "__contains__",
        "_scalar_type",
        "get_indexer",
        "length",
        "_left_join_on_index",
        "nunique",
        "partition",
        "_is_numeric_mixed_type",
        "drop",
        "between",
        "__lt__",
        "validate_endpoints",
        "_add_timedelta_arraylike",
        "_isna_compat",
        "_get_axis_resolvers",
        "__getstate__",
        "__finalize__",
        "maybe_promote",
        "bool",
        "_get_next_label",
        "array_equivalent",
        "zfill",
        "reset_index",
        "maybe_make_list",
        "inferred_type",
        "__nonzero__",
        "_agg_by_level",
        "ravel",
        "calculate_center_offset",
        "zsqrt",
        "_set_binner",
        "standardize_mapping",
        "_doc_parms",
        "random_state",
        "str_strip",
        "inferred_freq",
        "_assure_grouper",
        "prep_binary",
        "value_counts",
        "combine",
        "_stat_axis",
        "_get_join_info",
        "_isna_ndarraylike_old",
        "__ge__",
        "_maybe_cast_slice_bound",
        "__array__",
        "_should_fill",
        "_factorize_array",
        "duplicated",
        "_get_hashtable_algo",
        "__call__",
        "_time_shift",
        "abs",
        "ceil",
        "is_bool_indexer",
        "__deepcopy__",
        "_generate_marginal_results_without_values",
        "_validate_specification",
        "_is_monotonic_increasing",
        "right",
        "pad",
        "pivot",
        "_add_timedeltalike_scalar",
        "extract",
        "rfind",
        "left",
        "_set_as_cached",
        "__neg__",
        "coerce_indexer_dtype",
        "str_repeat",
        "_check_method",
        "infer_dtype_from",
        "_time_to_micros",
        "_add_datetimelike_scalar",
        "_get_time_bins",
        "argmin",
        "_protect_consolidate",
        "_result_dtype",
        "snap",
        "get_result",
        "apply_if_callable",
        "from_breaks",
        "_ensure_data",
        "repeat",
        "_scalar_from_string",
        "_constructor",
        "to_json",
        "ndim",
        "droplevel",
        "delete",
        "_maybe_promote",
        "update",
        "str_split",
        "add_suffix",
        "_get_series_list",
        "to_series",
        "_clip_with_one_bound",
        "_typ",
        "_get_join_keys",
        "to_frame",
        "maybe_upcast_for_op",
        "cat",
        "view",
        "str_endswith",
        "maybe_castable",
        "rsplit",
        "str_get",
        "_is_dates_only",
        "get_resampler",
        "sort_values",
        "_get_numeric_data",
        "_get_single_indexer",
        "mask",
        "_constructor_expanddim",
        "_align_series",
        "cast_scalar_to_array",
        "_get_merge_keys",
        "_find_valid_index",
        "_check_inplace_setting",
        "_sub_period_array",
        "_get_names",
        "str_pad",
        "to_pytimedelta",
        "array",
        "__le__",
        "__getattr__",
        "_consolidate",
        "tail",
        "_is_builtin_func",
        "infer_dtype_from_array",
        "na_logical_op",
        "str_slice_replace",
        "rank",
        "_make_stat_function",
        "__getitem__",
        "__sub__",
        "keys",
        "_intersection_unique",
        "str_extractall",
        "maybe_convert_platform",
        "to_string",
        "all_not_none",
        "get_indexer_non_unique",
        "obj",
        "empty",
        "match",
        "_validate_partial_date_slice",
        "_values",
        "attrs",
        "reshape",
        "_add_series_or_dataframe_operations",
        "_convert_by",
        "_unstack_multiple",
        "is_null_slice",
        "take_2d_multi",
        "_try_aggregate_string_function",
        "_drop_labels_or_levels",
        "get_new_values",
        "_resolution",
        "_factorize_keys",
        "_is_unique",
        "_get_axis_number",
        "_na_map",
        "merge",
        "convert_dtypes",
        "_adjust_bin_edges",
        "_isna_new",
        "_init_mgr",
        "_get_time_micros",
        "_setop",
        "_asfreq_compat",
        "from_arrays",
        "__str__",
        "is_true_slices",
        "_add_offset",
        "merge_asof",
        "is_all_dates",
        "maybe_cast_to_integer_array",
        "_where",
        "_groups_or_na_fun",
        "closed",
        "_reset_cacher",
        "slice_indexer",
        "notnull",
        "_maybe_restore_index_levels",
        "_get_cacher",
        "_resampler_for_grouping",
        "_get_multiindex_indexer",
        "_add_numeric_operations",
        "aggregate",
        "idxmin",
        "tz_localize",
        "_info_axis",
        "lreshape",
        "_clear_item_cache",
        "crosstab",
        "define_na_arithmetic_op",
        "__setattr__",
        "_format_with_header",
        "normalize",
        "__hash__",
        "str_find",
        "_take_nd_object",
        "not_none",
        "_validate_dtype",
        "_make_selectors",
        "__radd__",
        "_maybe_cast_for_get_loc",
        "slice_replace",
        "_get_take_nd_function",
        "_maybe_cache_changed",
        "_apply_loffset",
        "idxmax",
        "__add__",
        "rpartition",
        "_sub_datetimelike_scalar",
        "_maybe_convert_i8",
        "item",
        "_from_selection",
        "is_valid_dtype_n_method",
        "_needs_i8_conversion",
        "_unstack_frame",
        "__repr__",
        "merge_ordered",
        "fillna",
        "isnull",
        "any_none",
        "is_type_compatible",
        "str_startswith",
        "__iadd__",
        "clip",
        "_slice",
        "_new_PeriodIndex",
        "dot",
        "__setitem__",
        "_to_dict_of_blocks",
        "_is_type_compatible",
        "_take_with_is_copy",
        "_isna_old",
        "from_tuples",
        "_convert_dtypes",
        "_from_sequence",
        "_reorder_for_extension_array_stack",
        "_is_cached",
        "_generate_marginal_results",
        "convert_scalar_for_putitemlike",
        "add_prefix",
        "_format_attrs",
        "_set_name",
        "_asof_function",
        "__iter__",
        "_is_view",
        "_maybe_clear_freq",
        "_normalize",
        "_needs_reindex_multi",
        "_convert_list_indexer",
        "intersection",
        "strip",
        "_is_label_reference",
        "last_valid_index",
        "maybe_iterable_to_list",
        "to_pickle",
        "maybe_upcast_putmask",
        "get",
        "_get_with",
        "_add_margins",
        "_get_item_cache",
        "xs",
        "__rmatmul__",
        "_dispatch",
        "values",
        "_use_inf_as_na",
        "_union",
        "_validate_operand",
        "_make_stat_function_ddof",
        "sample",
        "_can_hold_na",
        "dropna",
        "astype_nansafe",
        "maybe_upcast",
        "h",
        "_selection_name",
        "period_range",
        "_stack_multi_columns",
        "str_encode",
        "na_value_for_dtype",
        "_items_overlap_with_suffix",
        "_sub_nat",
        "swaplevel",
        "memory_usage",
        "to_clipboard",
        "is_monotonic_decreasing",
        "_reconstruct_data",
        "g",
        "get_new_index",
        "_get_time_period_bins",
        "_set_item",
        "validate_periods",
        "is_non_overlapping_monotonic",
        "__round__",
        "_convert_slice_indexer",
        "_has_complex_internals",
        "nbytes",
        "forbid_nonstring_types",
        "resolution",
        "tolist",
        "rjust",
        "dtype",
        "rindex",
        "searchsorted",
        "__new__",
        "str_slice",
        "_infer_fill_value",
        "first",
        "_int64index",
        "_make_logical_function",
        "_clip_with_scalar",
        "to_sql",
        "melt",
        "__init__",
        "slice",
        "_broadcast_comparison_op",
        "_flex_binary_moment",
        "_delegate_property_get",
        "contains",
        "last",
        "_binop",
        "_restore_dropped_levels_multijoin",
        "tz_convert",
        "asfreq",
        "maybe_box_datetimelike",
        "truncate",
        "_hasnans",
        "_iset_item",
        "_maybe_fill",
        "at_time",
        "get_indexer_for",
        "_convert_for_op",
        "str_extract",
        "str_translate",
        "reindex_like",
        "_check_is_chained_assignment_possible",
        "_box_values",
        "_indicator_post_merge",
        "_na_value",
        "_is_level_reference",
        "cast_scalar_indexer",
        "asof_locs",
        "std",
        "take",
        "_get_axis_name",
        "construct_1d_ndarray_preserving_na",
        "_isna_ndarraylike",
        "filter",
        "axes",
        "_get_data_algo",
        "__invert__",
        "__len__",
        "_adjust_dates_anchored",
        "_right_outer_join",
        "__sizeof__",
        "factorize",
        "dtypes",
        "transform",
        "align",
        "_box_item_values",
        "astype",
        "_can_broadcast",
        "is_full_slice",
        "maybe_infer_dtype_type",
        "_is_valid_endpoint",
        "str_join",
        "_get_period_bins",
        "append",
        "interpolate",
        "count_not_none",
        "to_hdf",
        "var",
        "get_new_columns",
        "_view_wrapper",
        "_get_label_or_level_values",
        "__array_ufunc__",
        "_ensure_arraylike",
        "_get_resampler_for_grouping",
        "invalidate_string_dtypes",
        "apply",
        "isna",
        "compute",
        "to_numpy",
        "sort_index",
        "where",
        "_convert_obj",
        "_selection_list",
        "decode",
        "strftime",
        "encode",
        "_set_is_copy",
        "_get_join_indexers",
        "comp_method_OBJECT_ARRAY",
        "_convert_wrapper",
        "to_period",
        "set_closed",
        "get_rename_function",
        "_sort_labels",
        "_coerce_method",
        "to_latex",
        "_can_reindex",
        "_indicator_pre_merge",
        "split",
        "f",
        "_mpl_repr",
        "_check_compatible_with",
        "_upsample",
        "_make_sorted_values_labels",
        "_hasna",
        "_take_new_index",
        "rstrip",
        "_dir_additions",
        "maybe_infer_to_datetimelike",
        "_gotitem",
        "max",
        "_reindex_axes",
        "corr",
        "center",
        "_unstack_extension_series",
        "_intersection_non_unique",
        "interval_range",
        "soft_convert_objects",
        "_check_object_for_strings",
        "_any",
        "indexer_at_time",
        "argmax",
        "to_pydatetime",
        "_is_monotonic_decreasing",
        "equals",
        "is_unique",
        "rename",
        "_set_axis",
        "_map_stringarray",
        "_set_with",
        "index_labels_to_array",
        "_set_values",
        "_concat_same_type",
        "any_not_none",
        "_get_timestamp_range_edges",
        "index",
        "get_array_op",
        "_is_mixed_type",
        "_construct_axes_dict",
        "_aggregate_multiple_funcs",
        "_compute_grand_margin",
        "_from_factorized",
        "_ensure_dtype_type",
        "__copy__",
        "construct_1d_arraylike_from_scalar",
        "try_sort",
        "_align_frame",
        "maybe_downcast_numeric",
        "_downsample",
        "_get_prev_label",
        "overlaps",
        "translate",
        "lstrip",
        "bfill",
        "freqstr",
        "quantile",
        "to_tuples",
        "_format_space",
        "_reindex_with_indexers",
        "str_rsplit",
        "_set_value",
        "to_dict",
        "_round",
        "notna",
        "_engine",
        "pop",
        "pipe",
        "nsmallest",
        "_indexed_same",
        "_asof_by_function",
        "_init_dict",
        "_check_setitem_copy",
        "nearest",
        "explode",
        "maybe_convert_objects",
        "_consolidate_inplace",
        "is_overlapping",
        "isin",
        "_reset_cache",
        "_aggregate",
        "union_many",
        "_get_values_tuple",
        "get_dummies",
        "__setstate__",
        "_get_grouper",
        "infer_dtype_from_scalar",
        "_map_object",
        "_get_values_for_rank",
        "__rsub__",
        "pct_change",
        "maybe_upcast_datetimelike_array",
        "_reindex_multi",
        "_isnan",
        "_get_cleaned_column_resolvers",
        "wrap",
        "_get_binner_for_time",
        "_repr_latex_",
        "_apply",
        "_get_time_delta_bins",
        "_take_2d_multi_object",
        "_maybe_add_join_keys",
        "shift",
        "rename_axis",
        "_formatter_func",
        "hasnans",
        "_searchsorted_monotonic",
        "_freeze",
        "_check_label_or_level_ambiguity",
        "__delitem__",
        "_repr_data_resource_",
        "validate_numeric_casting",
        "_get_index_resolvers",
        "autocorr",
        "iteritems",
        "_parsed_string_to_bounds",
        "_get_resampler",
        "_set_labels",
        "cat_core",
        "_maybe_mask_results",
        "__reduce__",
        "reorder_levels",
        "_add_nat",
        "_validate",
        "count",
        "wide_to_long",
        "consensus_name_attr",
        "_obj_with_exclusions",
        "_get_center_of_mass",
        "_shallow_copy",
        "_values_for_factorize",
        "_get_block_manager_axis",
        "_ixs",
        "name",
        "groupby",
        "__isub__",
        "asof",
        "__pos__",
        "str_replace",
        "str_decode",
        "cov",
        "is_monotonic",
        "_get_single_group_name",
        "combine_first",
        "get_weighted_roll_func",
        "unstack",
        "_str_extract_noexpand",
        "stack_multiple",
        "_with_freq",
        "_selected_obj",
        "insert",
        "_maybe_coerce_merge_keys",
        "asi8",
        "ffill",
        "maybe_downcast_to_dtype",
        "__abs__",
        "mode",
        "_get_values",
        "set_axis",
        "_make_cum_function",
        "ljust",
        "_values_for_argsort",
        "_validate_fill_value",
        "squeeze",
        "_formatter",
        "__eq__",
        "to_excel",
        "difference",
        "first_valid_index",
        "_get_bool_data",
        "_assert_can_do_setop",
        "maybe_cast_to_datetime",
        "_new_DatetimeIndex",
        "_groupby_and_merge",
        "str_index",
        "__matmul__",
        "to_xarray",
        "mean",
        "copy",
        "all_none",
        "logical_op",
        "str_findall",
        "_multiindex",
        "items",
        "_str_extract_frame",
        "_datetimelike_array_cmp",
        "bdate_range",
        "_create_join_index",
        "_should_fallback_to_positional",
        "_format_data",
        "_get_cython_func",
        "_groupby_and_aggregate",
        "_make_min_count_stat_function",
        "find",
        "is_valid_nat_for_dtype",
        "resample",
        "validate_inferred_freq",
        "dict_compat",
        "_reduce",
        "reindex",
        "is_monotonic_increasing",
        "_validate_frequency",
        "flatten",
        "calculate_min_periods",
        "_get_string_slice",
        "backfill",
        "_get_dummies_1d",
        "nlargest",
        "construct_1d_object_array_from_listlike",
        "str_contains",
        "round",
        "ax",
        "__array_wrap__",
        "to_markdown",
        "_unbox_scalar",
        "_reindex_indexer",
        "_wrap_result",
        "transpose",
        "str_get_dummies",
        "replace",
        "between_time",
        "_addsub_object_array",
        "get_resampler_for_grouping",
        "na_arithmetic_op",
        "_value_counts_arraylike",
        "coerce_to_dtypes",
        "join",
        "_set_axis_name",
        "floor",
        "min",
        "__ne__",
        "cat_safe",
        "head",
        "str_wrap",
        "str_match"
      ],
      "functions_name_co_evolved_modified_file": [
        "__init__",
        "_map_object"
      ],
      "functions_name_co_evolved_all_files": [
        "zsqrt",
        "_restore_dropped_levels_multijoin",
        "astype_nansafe",
        "asof",
        "_is_dates_only",
        "lreshape",
        "value_counts",
        "combine",
        "apply",
        "_map_values",
        "mode",
        "stack",
        "_isna_ndarraylike_old",
        "asarray_tuplesafe",
        "asof_locs",
        "__new__",
        "_isna_ndarraylike",
        "item",
        "_setop",
        "_get_join_indexers",
        "comp_method_OBJECT_ARRAY",
        "_clip_with_scalar",
        "melt",
        "count",
        "__init__",
        "pivot",
        "_mpl_repr",
        "_where",
        "_map_object",
        "_take_new_index"
      ]
    },
    "file": {
      "file_name": "strings.py",
      "file_nloc": 2060,
      "file_complexity": 290,
      "file_token_count": 8391,
      "file_before": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Type, Union\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.missing as libmissing\nimport pandas._libs.ops as libops\nfrom pandas._typing import ArrayLike, Dtype\nfrom pandas.util._decorators import Appender\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_extension_array_dtype,\n    is_integer,\n    is_integer_dtype,\n    is_list_like,\n    is_object_dtype,\n    is_re,\n    is_scalar,\n    is_string_dtype,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame,\n    ABCIndexClass,\n    ABCMultiIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.core.construction import extract_array\n\nif TYPE_CHECKING:\n    from pandas.arrays import StringArray\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs: Dict[str, str] = dict()\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        arr_of_cols = np.asarray(list_of_columns, dtype=object)\n        return np.sum(arr_of_cols, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    arr_with_sep = np.asarray(list_with_sep, dtype=object)\n    return np.sum(arr_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    f\"column {dtype}\"\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=None, dtype=object):\n    if is_extension_array_dtype(arr.dtype):\n        if na_result is None:\n            na_result = libmissing.NA\n        # just StringDtype\n        arr = extract_array(arr)\n        return _map_stringarray(f, arr, na_value=na_result, dtype=dtype)\n    if na_result is None:\n        na_result = np.nan\n    return _map_object(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map_stringarray(\n    func: Callable[[str], Any], arr: \"StringArray\", na_value: Any, dtype: Dtype\n) -> ArrayLike:\n    \"\"\"\n    Map a callable over valid elements of a StringArrray.\n\n    Parameters\n    ----------\n    func : Callable[[str], Any]\n        Apply to each valid element.\n    arr : StringArray\n    na_value : Any\n        The value to use for missing values. By default, this is\n        the original value (NA).\n    dtype : Dtype\n        The result dtype to use. Specifying this avoids an intermediate\n        object-dtype allocation.\n\n    Returns\n    -------\n    ArrayLike\n        An ExtensionArray for integer or string dtypes, otherwise\n        an ndarray.\n\n    \"\"\"\n    from pandas.arrays import IntegerArray, StringArray, BooleanArray\n\n    mask = isna(arr)\n\n    assert isinstance(arr, StringArray)\n    arr = np.asarray(arr)\n\n    if is_integer_dtype(dtype) or is_bool_dtype(dtype):\n        constructor: Union[Type[IntegerArray], Type[BooleanArray]]\n        if is_integer_dtype(dtype):\n            constructor = IntegerArray\n        else:\n            constructor = BooleanArray\n\n        na_value_is_na = isna(na_value)\n        if na_value_is_na:\n            na_value = 1\n        result = lib.map_infer_mask(\n            arr,\n            func,\n            mask.view(\"uint8\"),\n            convert=False,\n            na_value=na_value,\n            dtype=np.dtype(dtype),\n        )\n\n        if not na_value_is_na:\n            mask[:] = False\n\n        return constructor(result, mask)\n\n    elif is_string_dtype(dtype) and not is_object_dtype(dtype):\n        # i.e. StringDtype\n        result = lib.map_infer_mask(\n            arr, func, mask.view(\"uint8\"), convert=False, na_value=na_value\n        )\n        return StringArray(result)\n    else:\n        # This is when the result type is object. We reach this when\n        # -> We know the result type is truly object (e.g. .encode returns bytes\n        #    or .findall returns a list).\n        # -> We don't know the result type. E.g. `.get` can return anything.\n        return lib.map_infer_mask(arr, func, mask.view(\"uint8\"))\n\n\ndef _map_object(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        convert = not np.all(mask)\n        try:\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                # FIXME: this should be totally avoidable\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map_object(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=\"int64\")\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the \"\n                \"groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: regex.search(x) is not None\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`, depending on the regex value.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        Determines if replace is case sensitive:\n\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex.\n\n    flags : int, default 0 (no flags)\n        Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled\n        regex.\n    regex : bool, default True\n        Determines if assumes the passed-in pattern is a regular expression:\n\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (isinstance(repl, str) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr, dtype=str)\n    else:\n\n        def rep(x, r):\n            if x is libmissing.NA:\n                return x\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(np.asarray(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Regex module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: regex.match(x) is not None\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _result_dtype(arr):\n    # workaround #27953\n    # ideally we just pass `dtype=arr.dtype` unconditionally, but this fails\n    # when the list of values is empty.\n    if arr.dtype.name == \"string\":\n        return \"string\"\n    else:\n        return object\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, ABCIndexClass):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            dtype = _result_dtype(arr)\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=dtype,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    dtype = _result_dtype(arr)\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=dtype,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n    dtype = _result_dtype(arr)\n\n    result = arr._constructor_expanddim(\n        match_list, index=index, columns=columns, dtype=dtype\n    )\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.to_numpy(), lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr, dtype=str)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n    if not isinstance(sub, str):\n        msg = f\"expected a string object, not {type(sub).__name__}\"\n        raise TypeError(msg)\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=\"int64\")\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = f\"expected a string object, not {type(sub).__name__}\"\n        raise TypeError(msg)\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=\"int64\")\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill : Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = f\"fillchar must be a character, not {type(fillchar).__name__}\"\n        raise TypeError(msg)\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = f\"width must be of integer type, not {type(width).__name__}\"\n        raise TypeError(msg)\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(start=-1)\n    0           a\n    1           x\n    2           n\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr, dtype=str)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr, dtype=str)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    f\"Cannot use .str.{func_name} with values of \"\n                    f\"inferred dtype '{self._inferred_dtype}'.\"\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(\n    f,\n    name=None,\n    docstring=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kargs,\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f,\n    flags=False,\n    na=False,\n    name=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kwargs,\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"\"\"Copy a docstring from another source function (if present)\"\"\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n        self._is_string = data.dtype.name == \"string\"\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        from pandas import StringDtype\n\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # explicitly allow StringDtype\n        if isinstance(values.dtype, StringDtype):\n            return \"string\"\n\n        try:\n            inferred_dtype = lib.infer_dtype(values, skipna=True)\n        except ValueError:\n            # GH#27571 mostly occurs with ExtensionArray\n            inferred_dtype = None\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        warnings.warn(\n            \"Columnar iteration over characters will be deprecated in future releases.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self,\n        result,\n        use_codes=True,\n        name=None,\n        expand=None,\n        fill_value=np.nan,\n        returns_string=True,\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        # We can be wrapping a string / object / categorical result, in which\n        # case we'll want to return the same dtype as the input.\n        # Or we can be wrapping a numeric output, in which case we don't want\n        # to return a StringArray.\n        if self._is_string and returns_string:\n            dtype = \"string\"\n        else:\n            dtype = None\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndexClass):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                result = cons(result, columns=name, index=index, dtype=dtype)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                result = cons(result, name=name, index=index, dtype=dtype)\n            return result\n\n    def _get_series_list(self, others):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n        from pandas import Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n        if isinstance(others, ABCSeries):\n            return [others]\n        elif isinstance(others, ABCIndexClass):\n            return [Series(others.values, index=others)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[x] for x in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return [others[x] for x in others]\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either Series/Index/np.ndarray (1-dim)...\n            if all(\n                isinstance(x, (ABCSeries, ABCIndexClass))\n                or (isinstance(x, np.ndarray) and x.ndim == 1)\n                for x in others\n            ):\n                los = []\n                while others:  # iterate through list and append each element\n                    los = los + self._get_series_list(others.pop(0))\n                return los\n            # ... or just strings\n            elif all(not is_list_like(x) for x in others):\n                return [Series(others, index=idx)]\n        raise TypeError(\n            \"others must be Series, Index, DataFrame, np.ndarrary \"\n            \"or list-like (either containing only strings or \"\n            \"containing only objects of type Series/Index/\"\n            \"np.ndarray[1-dim])\"\n        )\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=\"left\"):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). To disable\n            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n\n            .. versionadded:: 0.23.0\n            .. versionchanged:: 1.0.0\n                Changed default of `join` from None to `'left'`.\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndexClass):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others = self._get_series_list(others)\n        except ValueError as err:  # do not catch TypeError raised by _get_series_list\n            raise ValueError(\n                \"If `others` contains arrays or lists (or other \"\n                \"list-likes without an index), these must all be \"\n                \"of the same length as the calling Series/Index.\"\n            ) from err\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndexClass):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            if is_categorical_dtype(self._orig.dtype):\n                # We need to infer the new categories.\n                dtype = None\n            else:\n                dtype = self._orig.dtype\n            result = Series(result, dtype=dtype, index=data.index, name=self._orig.name)\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the split strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``.\n    fillchar : str\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    filled : Series/Index of objects.\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects.\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        # TODO: Not sure how to handle this.\n        return self._wrap_result(result, returns_string=False)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result,\n            use_codes=(not self._is_categorical),\n            name=name,\n            expand=True,\n            returns_string=False,\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\", returns_string=False)\n    startswith = _pat_wrapper(\n        str_startswith, na=True, name=\"startswith\", returns_string=False\n    )\n    endswith = _pat_wrapper(\n        str_endswith, na=True, name=\"endswith\", returns_string=False\n    )\n    findall = _pat_wrapper(\n        str_findall, flags=True, name=\"findall\", returns_string=False\n    )\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of int.\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form.\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent, dtype=str)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len,\n        docstring=_shared_docs[\"len\"],\n        forbidden_types=None,\n        dtype=\"int64\",\n        returns_string=False,\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args: Dict[str, Dict[str, str]] = {}\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n        dtype=str,\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n        dtype=str,\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n        dtype=str,\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n        dtype=str,\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n        dtype=str,\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n        dtype=str,\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    # force _noarg_wrapper return type with dtype=bool (GH 29624)\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n        returns_string=False,\n        dtype=bool,\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
      "file_after": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Type, Union\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.missing as libmissing\nimport pandas._libs.ops as libops\nfrom pandas._typing import ArrayLike, Dtype\nfrom pandas.util._decorators import Appender\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_extension_array_dtype,\n    is_integer,\n    is_integer_dtype,\n    is_list_like,\n    is_object_dtype,\n    is_re,\n    is_scalar,\n    is_string_dtype,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame,\n    ABCIndexClass,\n    ABCMultiIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.core.construction import extract_array\n\nif TYPE_CHECKING:\n    from pandas.arrays import StringArray\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs: Dict[str, str] = dict()\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        arr_of_cols = np.asarray(list_of_columns, dtype=object)\n        return np.sum(arr_of_cols, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    arr_with_sep = np.asarray(list_with_sep, dtype=object)\n    return np.sum(arr_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    f\"column {dtype}\"\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=None, dtype=object):\n    if is_extension_array_dtype(arr.dtype):\n        if na_result is None:\n            na_result = libmissing.NA\n        # just StringDtype\n        arr = extract_array(arr)\n        return _map_stringarray(f, arr, na_value=na_result, dtype=dtype)\n    if na_result is None:\n        na_result = np.nan\n    return _map_object(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map_stringarray(\n    func: Callable[[str], Any], arr: \"StringArray\", na_value: Any, dtype: Dtype\n) -> ArrayLike:\n    \"\"\"\n    Map a callable over valid elements of a StringArrray.\n\n    Parameters\n    ----------\n    func : Callable[[str], Any]\n        Apply to each valid element.\n    arr : StringArray\n    na_value : Any\n        The value to use for missing values. By default, this is\n        the original value (NA).\n    dtype : Dtype\n        The result dtype to use. Specifying this avoids an intermediate\n        object-dtype allocation.\n\n    Returns\n    -------\n    ArrayLike\n        An ExtensionArray for integer or string dtypes, otherwise\n        an ndarray.\n\n    \"\"\"\n    from pandas.arrays import IntegerArray, StringArray, BooleanArray\n\n    mask = isna(arr)\n\n    assert isinstance(arr, StringArray)\n    arr = np.asarray(arr)\n\n    if is_integer_dtype(dtype) or is_bool_dtype(dtype):\n        constructor: Union[Type[IntegerArray], Type[BooleanArray]]\n        if is_integer_dtype(dtype):\n            constructor = IntegerArray\n        else:\n            constructor = BooleanArray\n\n        na_value_is_na = isna(na_value)\n        if na_value_is_na:\n            na_value = 1\n        result = lib.map_infer_mask(\n            arr,\n            func,\n            mask.view(\"uint8\"),\n            convert=False,\n            na_value=na_value,\n            dtype=np.dtype(dtype),\n        )\n\n        if not na_value_is_na:\n            mask[:] = False\n\n        return constructor(result, mask)\n\n    elif is_string_dtype(dtype) and not is_object_dtype(dtype):\n        # i.e. StringDtype\n        result = lib.map_infer_mask(\n            arr, func, mask.view(\"uint8\"), convert=False, na_value=na_value\n        )\n        return StringArray(result)\n    else:\n        # This is when the result type is object. We reach this when\n        # -> We know the result type is truly object (e.g. .encode returns bytes\n        #    or .findall returns a list).\n        # -> We don't know the result type. E.g. `.get` can return anything.\n        return lib.map_infer_mask(arr, func, mask.view(\"uint8\"))\n\n\ndef _map_object(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr._values  # TODO: extract_array?\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        convert = not np.all(mask)\n        try:\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                # FIXME: this should be totally avoidable\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map_object(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=\"int64\")\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the \"\n                \"groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: regex.search(x) is not None\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`, depending on the regex value.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        Determines if replace is case sensitive:\n\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex.\n\n    flags : int, default 0 (no flags)\n        Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled\n        regex.\n    regex : bool, default True\n        Determines if assumes the passed-in pattern is a regular expression:\n\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (isinstance(repl, str) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr, dtype=str)\n    else:\n\n        def rep(x, r):\n            if x is libmissing.NA:\n                return x\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(np.asarray(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Regex module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: regex.match(x) is not None\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _result_dtype(arr):\n    # workaround #27953\n    # ideally we just pass `dtype=arr.dtype` unconditionally, but this fails\n    # when the list of values is empty.\n    if arr.dtype.name == \"string\":\n        return \"string\"\n    else:\n        return object\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, ABCIndexClass):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            dtype = _result_dtype(arr)\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=dtype,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    dtype = _result_dtype(arr)\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=dtype,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n    dtype = _result_dtype(arr)\n\n    result = arr._constructor_expanddim(\n        match_list, index=index, columns=columns, dtype=dtype\n    )\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.to_numpy(), lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr, dtype=str)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n    if not isinstance(sub, str):\n        msg = f\"expected a string object, not {type(sub).__name__}\"\n        raise TypeError(msg)\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=\"int64\")\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = f\"expected a string object, not {type(sub).__name__}\"\n        raise TypeError(msg)\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=\"int64\")\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill : Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = f\"fillchar must be a character, not {type(fillchar).__name__}\"\n        raise TypeError(msg)\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = f\"width must be of integer type, not {type(width).__name__}\"\n        raise TypeError(msg)\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(start=-1)\n    0           a\n    1           x\n    2           n\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr, dtype=str)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr, dtype=str)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr, dtype=str)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    f\"Cannot use .str.{func_name} with values of \"\n                    f\"inferred dtype '{self._inferred_dtype}'.\"\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(\n    f,\n    name=None,\n    docstring=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kargs,\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f,\n    flags=False,\n    na=False,\n    name=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kwargs,\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"\"\"Copy a docstring from another source function (if present)\"\"\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n        self._is_string = data.dtype.name == \"string\"\n\n        # ._values.categories works for both Series/Index\n        self._parent = data._values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        from pandas import StringDtype\n\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # explicitly allow StringDtype\n        if isinstance(values.dtype, StringDtype):\n            return \"string\"\n\n        try:\n            inferred_dtype = lib.infer_dtype(values, skipna=True)\n        except ValueError:\n            # GH#27571 mostly occurs with ExtensionArray\n            inferred_dtype = None\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        warnings.warn(\n            \"Columnar iteration over characters will be deprecated in future releases.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self,\n        result,\n        use_codes=True,\n        name=None,\n        expand=None,\n        fill_value=np.nan,\n        returns_string=True,\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        # We can be wrapping a string / object / categorical result, in which\n        # case we'll want to return the same dtype as the input.\n        # Or we can be wrapping a numeric output, in which case we don't want\n        # to return a StringArray.\n        if self._is_string and returns_string:\n            dtype = \"string\"\n        else:\n            dtype = None\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndexClass):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                result = cons(result, columns=name, index=index, dtype=dtype)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                result = cons(result, name=name, index=index, dtype=dtype)\n            return result\n\n    def _get_series_list(self, others):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n        from pandas import Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n        if isinstance(others, ABCSeries):\n            return [others]\n        elif isinstance(others, ABCIndexClass):\n            return [Series(others._values, index=others)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[x] for x in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return [others[x] for x in others]\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either Series/Index/np.ndarray (1-dim)...\n            if all(\n                isinstance(x, (ABCSeries, ABCIndexClass))\n                or (isinstance(x, np.ndarray) and x.ndim == 1)\n                for x in others\n            ):\n                los = []\n                while others:  # iterate through list and append each element\n                    los = los + self._get_series_list(others.pop(0))\n                return los\n            # ... or just strings\n            elif all(not is_list_like(x) for x in others):\n                return [Series(others, index=idx)]\n        raise TypeError(\n            \"others must be Series, Index, DataFrame, np.ndarrary \"\n            \"or list-like (either containing only strings or \"\n            \"containing only objects of type Series/Index/\"\n            \"np.ndarray[1-dim])\"\n        )\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=\"left\"):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). To disable\n            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n\n            .. versionadded:: 0.23.0\n            .. versionchanged:: 1.0.0\n                Changed default of `join` from None to `'left'`.\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndexClass):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others = self._get_series_list(others)\n        except ValueError as err:  # do not catch TypeError raised by _get_series_list\n            raise ValueError(\n                \"If `others` contains arrays or lists (or other \"\n                \"list-likes without an index), these must all be \"\n                \"of the same length as the calling Series/Index.\"\n            ) from err\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndexClass):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            if is_categorical_dtype(self._orig.dtype):\n                # We need to infer the new categories.\n                dtype = None\n            else:\n                dtype = self._orig.dtype\n            result = Series(result, dtype=dtype, index=data.index, name=self._orig.name)\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the split strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``.\n    fillchar : str\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    filled : Series/Index of objects.\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects.\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        # TODO: Not sure how to handle this.\n        return self._wrap_result(result, returns_string=False)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result,\n            use_codes=(not self._is_categorical),\n            name=name,\n            expand=True,\n            returns_string=False,\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\", returns_string=False)\n    startswith = _pat_wrapper(\n        str_startswith, na=True, name=\"startswith\", returns_string=False\n    )\n    endswith = _pat_wrapper(\n        str_endswith, na=True, name=\"endswith\", returns_string=False\n    )\n    findall = _pat_wrapper(\n        str_findall, flags=True, name=\"findall\", returns_string=False\n    )\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of int.\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form.\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent, dtype=str)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len,\n        docstring=_shared_docs[\"len\"],\n        forbidden_types=None,\n        dtype=\"int64\",\n        returns_string=False,\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args: Dict[str, Dict[str, str]] = {}\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n        dtype=str,\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n        dtype=str,\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n        dtype=str,\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n        dtype=str,\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n        dtype=str,\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n        dtype=str,\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    # force _noarg_wrapper return type with dtype=bool (GH 29624)\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n        returns_string=False,\n        dtype=bool,\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n        returns_string=False,\n        dtype=bool,\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
      "file_patch": "@@ -205,7 +205,7 @@ def _map_object(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n         return np.ndarray(0, dtype=dtype)\n \n     if isinstance(arr, ABCSeries):\n-        arr = arr.values\n+        arr = arr._values  # TODO: extract_array?\n     if not isinstance(arr, np.ndarray):\n         arr = np.asarray(arr, dtype=object)\n     if na_mask:\n@@ -2034,8 +2034,8 @@ class StringMethods(NoNewAttributesMixin):\n         self._is_categorical = is_categorical_dtype(data)\n         self._is_string = data.dtype.name == \"string\"\n \n-        # .values.categories works for both Series/Index\n-        self._parent = data.values.categories if self._is_categorical else data\n+        # ._values.categories works for both Series/Index\n+        self._parent = data._values.categories if self._is_categorical else data\n         # save orig to blow up categoricals to the right type\n         self._orig = data\n         self._freeze()\n@@ -2236,7 +2236,7 @@ class StringMethods(NoNewAttributesMixin):\n         if isinstance(others, ABCSeries):\n             return [others]\n         elif isinstance(others, ABCIndexClass):\n-            return [Series(others.values, index=others)]\n+            return [Series(others._values, index=others)]\n         elif isinstance(others, ABCDataFrame):\n             return [others[x] for x in others]\n         elif isinstance(others, np.ndarray) and others.ndim == 2:\n",
      "files_name_in_blame_commit": [
        "period.py",
        "merge.py",
        "interval.py",
        "reshape.py",
        "generic.py",
        "cast.py",
        "pivot.py",
        "common.py",
        "series.py",
        "masked.py",
        "base.py",
        "datetimes.py",
        "array_ops.py",
        "melt.py",
        "algorithms.py",
        "missing.py",
        "accessors.py",
        "strings.py",
        "datetimelike.py",
        "resample.py"
      ]
    }
  },
  "commits_modify_file_before_fix": {
    "size": 262
  },
  "recursive_blame_commits": {
    "recursive_blame_function_lines": {
      "2212": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "    def _get_series_list(self, others):",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2213": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        \"\"\"",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2214": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2215": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        into a list of Series (elements without an index must match the length",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2216": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        of the calling Series/Index).",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2217": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 0
      },
      "2218": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        Parameters",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2219": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        ----------",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2220": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "        others : Series, DataFrame, np.ndarray, list-like or list-like of",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2221": {
        "commit_id": "18a9e4c8ab253e83ba43767d890576186be13332",
        "line_code": "            Objects that are either Series, Index or np.ndarray (1-dim).",
        "commit_date": "2019-10-13 21:38:59",
        "valid": 1
      },
      "2222": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 0
      },
      "2223": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        Returns",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2224": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        -------",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2225": {
        "commit_id": "18a9e4c8ab253e83ba43767d890576186be13332",
        "line_code": "        list of Series",
        "commit_date": "2019-10-13 21:38:59",
        "valid": 1
      },
      "2226": {
        "commit_id": "18a9e4c8ab253e83ba43767d890576186be13332",
        "line_code": "            Others transformed into list of Series.",
        "commit_date": "2019-10-13 21:38:59",
        "valid": 1
      },
      "2227": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        \"\"\"",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2228": {
        "commit_id": "ed487653bc98f9e8b98e4e1175c49678ad68fa9f",
        "line_code": "        from pandas import Series, DataFrame",
        "commit_date": "2019-07-22 07:52:31",
        "valid": 1
      },
      "2229": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 0
      },
      "2230": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        # self._orig is either Series or Index",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2231": {
        "commit_id": "ed487653bc98f9e8b98e4e1175c49678ad68fa9f",
        "line_code": "        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index",
        "commit_date": "2019-07-22 07:52:31",
        "valid": 1
      },
      "2232": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 0
      },
      "2233": {
        "commit_id": "ef019faa06f762c8c203985a11108731384b2dae",
        "line_code": "        # Generally speaking, all objects without an index inherit the index",
        "commit_date": "2018-05-04 06:11:12",
        "valid": 1
      },
      "2234": {
        "commit_id": "ef019faa06f762c8c203985a11108731384b2dae",
        "line_code": "        # `idx` of the calling Series/Index - i.e. must have matching length.",
        "commit_date": "2018-05-04 06:11:12",
        "valid": 1
      },
      "2235": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2236": {
        "commit_id": "ed487653bc98f9e8b98e4e1175c49678ad68fa9f",
        "line_code": "        if isinstance(others, ABCSeries):",
        "commit_date": "2019-07-22 07:52:31",
        "valid": 1
      },
      "2237": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            return [others]",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2238": {
        "commit_id": "ed487653bc98f9e8b98e4e1175c49678ad68fa9f",
        "line_code": "        elif isinstance(others, ABCIndexClass):",
        "commit_date": "2019-07-22 07:52:31",
        "valid": 1
      },
      "2239": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            return [Series(others.values, index=others)]",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2240": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "        elif isinstance(others, ABCDataFrame):",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2241": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            return [others[x] for x in others]",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2242": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "        elif isinstance(others, np.ndarray) and others.ndim == 2:",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2243": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "            others = DataFrame(others, index=idx)",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2244": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            return [others[x] for x in others]",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2245": {
        "commit_id": "779aeacd4d1560b23df6f0e9d153c5452ad28759",
        "line_code": "        elif is_list_like(others, allow_sets=False):",
        "commit_date": "2018-10-22 23:10:07",
        "valid": 1
      },
      "2246": {
        "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
        "line_code": "            others = list(others)  # ensure iterators do not get read twice etc",
        "commit_date": "2018-05-02 06:13:35",
        "valid": 1
      },
      "2247": {
        "commit_id": "ef019faa06f762c8c203985a11108731384b2dae",
        "line_code": "",
        "commit_date": "2018-05-04 06:11:12",
        "valid": 0
      },
      "2248": {
        "commit_id": "ef019faa06f762c8c203985a11108731384b2dae",
        "line_code": "            # in case of list-like `others`, all elements must be",
        "commit_date": "2018-05-04 06:11:12",
        "valid": 1
      },
      "2249": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            # either Series/Index/np.ndarray (1-dim)...",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2250": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            if all(",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2251": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                isinstance(x, (ABCSeries, ABCIndexClass))",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2252": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                or (isinstance(x, np.ndarray) and x.ndim == 1)",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2253": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                for x in others",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2254": {
        "commit_id": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
        "line_code": "            ):",
        "commit_date": "2019-07-03 23:28:23",
        "valid": 1
      },
      "2255": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                los = []",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2256": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                while others:  # iterate through list and append each element",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2257": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                    los = los + self._get_series_list(others.pop(0))",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2258": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                return los",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2259": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            # ... or just strings",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2260": {
        "commit_id": "ef019faa06f762c8c203985a11108731384b2dae",
        "line_code": "            elif all(not is_list_like(x) for x in others):",
        "commit_date": "2018-05-04 06:11:12",
        "valid": 1
      },
      "2261": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "                return [Series(others, index=idx)]",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2262": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "        raise TypeError(",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2263": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            \"others must be Series, Index, DataFrame, np.ndarrary \"",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2264": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            \"or list-like (either containing only strings or \"",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2265": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            \"containing only objects of type Series/Index/\"",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2266": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "            \"np.ndarray[1-dim])\"",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      },
      "2267": {
        "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
        "line_code": "        )",
        "commit_date": "2019-07-31 08:32:35",
        "valid": 1
      }
    },
    "commits": {
      "18a9e4c8ab253e83ba43767d890576186be13332": {
        "commit": {
          "commit_id": "18a9e4c8ab253e83ba43767d890576186be13332",
          "commit_message": "DOC: Fixed PR08 and PR09 docstring errors in pandas.Series (#28845)",
          "commit_author": "Jack Bicknell",
          "commit_date": "2019-10-13 21:38:59",
          "commit_parent": "851ca1ab2cecaf4e91a8553f449c4f73faad325e"
        },
        "function": {
          "function_name": "_get_series_list",
          "function_code_before": "def _get_series_list(self, others):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, Index or np.ndarray (1-dim)\n\n        Returns\n        -------\n        list : others transformed into list of Series\n        \"\"\"\n    from pandas import Series, DataFrame\n    idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n    if isinstance(others, ABCSeries):\n        return [others]\n    elif isinstance(others, ABCIndexClass):\n        return [Series(others.values, index=others)]\n    elif isinstance(others, ABCDataFrame):\n        return [others[x] for x in others]\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return [others[x] for x in others]\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((isinstance(x, (ABCSeries, ABCIndexClass)) or (isinstance(x, np.ndarray) and x.ndim == 1) for x in others)):\n            los = []\n            while others:\n                los = los + self._get_series_list(others.pop(0))\n            return los\n        elif all((not is_list_like(x) for x in others)):\n            return [Series(others, index=idx)]\n    raise TypeError('others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/np.ndarray[1-dim])')",
          "function_code_after": "def _get_series_list(self, others):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n    from pandas import Series, DataFrame\n    idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n    if isinstance(others, ABCSeries):\n        return [others]\n    elif isinstance(others, ABCIndexClass):\n        return [Series(others.values, index=others)]\n    elif isinstance(others, ABCDataFrame):\n        return [others[x] for x in others]\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return [others[x] for x in others]\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((isinstance(x, (ABCSeries, ABCIndexClass)) or (isinstance(x, np.ndarray) and x.ndim == 1) for x in others)):\n            los = []\n            while others:\n                los = los + self._get_series_list(others.pop(0))\n            return los\n        elif all((not is_list_like(x) for x in others)):\n            return [Series(others, index=idx)]\n    raise TypeError('others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/np.ndarray[1-dim])')",
          "function_before_start_line": 2128,
          "function_before_end_line": 2182,
          "function_after_start_line": 2133,
          "function_after_end_line": 2188,
          "function_before_token_count": 232,
          "function_after_token_count": 232,
          "functions_name_modified_file": [
            "str_endswith",
            "rsplit",
            "str_encode",
            "str_get",
            "translate",
            "lstrip",
            "str_pad",
            "_make_accessor",
            "str_count",
            "forbid_nonstring_types",
            "str_rsplit",
            "rjust",
            "rindex",
            "str_slice",
            "str_slice_replace",
            "__getitem__",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "get_dummies",
            "contains",
            "match",
            "wrap",
            "str_extract",
            "str_translate",
            "_noarg_wrapper",
            "partition",
            "_na_map",
            "cat_core",
            "_validate",
            "zfill",
            "_groups_or_na_fun",
            "str_replace",
            "str_join",
            "str_decode",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "normalize",
            "str_find",
            "_map",
            "slice_replace",
            "rpartition",
            "decode",
            "ljust",
            "encode",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "center",
            "find",
            "str_repeat",
            "__iter__",
            "_result_dtype",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "get",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "str_split",
            "_get_series_list",
            "join",
            "str_wrap",
            "cat_safe",
            "str_match",
            "cat"
          ],
          "functions_name_all_files": [
            "__dir__",
            "map",
            "check_for_ordered",
            "date_range",
            "freq",
            "real",
            "_maybe_update_cacher",
            "_get_value",
            "_set_with_engine",
            "validate_tz_from_dtype",
            "swapaxes",
            "_make_accessor",
            "str_count",
            "get_loc",
            "_onOffset",
            "_get_axis",
            "_is_homogeneous_type",
            "_constructor_sliced",
            "slice_shift",
            "_to_M8",
            "ordered",
            "_construct_axes_from_arguments",
            "date",
            "_validate_dt64_dtype",
            "_addsub_int_array",
            "tshift",
            "_sub_period",
            "_box_func",
            "_delegate_property_set",
            "_format_native_types",
            "unique",
            "_is_label_or_level_reference",
            "to_csv",
            "_maybe_coerce_indexer",
            "_pat_wrapper",
            "describe",
            "to_timestamp",
            "extractall",
            "shape",
            "clip_upper",
            "_single_replace",
            "timedelta_range",
            "drop_duplicates",
            "_convert",
            "_simple_new",
            "diff",
            "_drop_axis",
            "infer_objects",
            "indexer_between_time",
            "_update_inplace",
            "take_nd",
            "maybe_infer_freq",
            "_delegate_method",
            "size",
            "_noarg_wrapper",
            "_map_values",
            "argsort",
            "__contains__",
            "_scalar_type",
            "cbday_roll",
            "_prev_opening_time",
            "nunique",
            "partition",
            "_is_numeric_mixed_type",
            "drop",
            "_factorize_from_iterables",
            "between",
            "_get_suffix_prefix",
            "validate_endpoints",
            "hist",
            "_get_axis_resolvers",
            "__getstate__",
            "__finalize__",
            "bool",
            "zfill",
            "reset_index",
            "_get_closing_time",
            "inferred_type",
            "__nonzero__",
            "pie",
            "_ensure_localized",
            "_get_offset_day",
            "_agg_by_level",
            "ravel",
            "_add_series_only_operations",
            "_repr_categories_info",
            "time",
            "_doc_parms",
            "_can_fast_union",
            "str_strip",
            "inferred_freq",
            "value_counts",
            "combine",
            "_stat_axis",
            "box",
            "_apply_index_days",
            "day_name",
            "sequence_to_dt64ns",
            "_maybe_cast_slice_bound",
            "__array__",
            "_get_codes_for_values",
            "_get_business_hours_by_sec",
            "get_ftype_counts",
            "duplicated",
            "__call__",
            "_time_shift",
            "abs",
            "ceil",
            "__deepcopy__",
            "_is_monotonic_increasing",
            "pad",
            "_add_timedeltalike_scalar",
            "_cat_compare_op",
            "extract",
            "rfind",
            "_values_for_rank",
            "_set_as_cached",
            "__neg__",
            "str_repeat",
            "_time_to_micros",
            "_tidy_repr",
            "_add_datetimelike_scalar",
            "argmin",
            "_protect_consolidate",
            "_result_dtype",
            "snap",
            "objects_to_datetime64ns",
            "put",
            "repeat",
            "_field_accessor",
            "_constructor",
            "_scalar_from_string",
            "to_json",
            "ndim",
            "reorder_categories",
            "_set_categories",
            "maybe_convert_dtype",
            "droplevel",
            "delete",
            "next_bday",
            "_maybe_promote",
            "update",
            "str_split",
            "add_suffix",
            "tz",
            "to_series",
            "_get_series_list",
            "year_has_extra_week",
            "_clip_with_one_bound",
            "to_frame",
            "cat",
            "view",
            "_add_delta_tdi",
            "clip_lower",
            "str_endswith",
            "rsplit",
            "str_get",
            "_is_dates_only",
            "sort_values",
            "_get_numeric_data",
            "mask",
            "_constructor_expanddim",
            "_align_series",
            "str_pad",
            "_find_valid_index",
            "_check_inplace_setting",
            "_sub_period_array",
            "_set_subtyp",
            "array",
            "__getattr__",
            "blocks",
            "_setup_axes",
            "_consolidate",
            "tail",
            "_is_builtin_func",
            "str_slice_replace",
            "rank",
            "_make_stat_function",
            "add_categories",
            "__getitem__",
            "__sub__",
            "keys",
            "str_extractall",
            "to_string",
            "empty",
            "match",
            "to_msgpack",
            "_values",
            "_add_series_or_dataframe_operations",
            "compress",
            "base",
            "_maybe_localize_point",
            "_try_aggregate_string_function",
            "_ndarray_values",
            "_drop_labels_or_levels",
            "_resolution",
            "_add_delta",
            "_is_unique",
            "_get_axis_number",
            "_na_map",
            "nonzero",
            "_prefix",
            "_timezone",
            "_init_mgr",
            "_get_time_micros",
            "m_offset",
            "_tick_comp",
            "ftypes",
            "_add_offset",
            "is_all_dates",
            "_is_convertible_to_index",
            "_wrap_setop_result",
            "_where",
            "_groups_or_na_fun",
            "_reset_cacher",
            "slice_indexer",
            "onOffset",
            "apply_index",
            "notnull",
            "_get_space_character_free_column_resolvers",
            "_get_cacher",
            "_add_numeric_operations",
            "aggregate",
            "idxmin",
            "tz_localize",
            "from_codes",
            "_info_axis",
            "__get__",
            "_clear_item_cache",
            "__setattr__",
            "_partial_td_slice",
            "normalize",
            "strides",
            "__hash__",
            "str_find",
            "_validate_dtype",
            "__radd__",
            "slice_replace",
            "_maybe_cache_changed",
            "idxmax",
            "rollforward",
            "__add__",
            "rpartition",
            "_sub_datetimelike_scalar",
            "item",
            "register_series_accessor",
            "month_name",
            "__repr__",
            "fillna",
            "isnull",
            "is_type_compatible",
            "str_startswith",
            "__iadd__",
            "is_copy",
            "_slice",
            "clip",
            "dot",
            "__setitem__",
            "to_perioddelta",
            "nanos",
            "_parse_suffix",
            "_to_dict_of_blocks",
            "_repr_attrs",
            "T",
            "_join_i8_wrapper",
            "_from_sequence",
            "_unpickle_series_compat",
            "_ensure_datetimelike_to_i8",
            "_is_cached",
            "add_prefix",
            "_addsub_offset_array",
            "bar",
            "_get_roll",
            "_set_name",
            "to_dense",
            "_infer_tz_from_endpoints",
            "__iter__",
            "_is_view",
            "_maybe_clear_freq",
            "_needs_reindex_multi",
            "intersection",
            "strip",
            "_register_accessor",
            "_is_label_reference",
            "last_valid_index",
            "categorical",
            "to_pickle",
            "get",
            "_get_with",
            "_get_item_cache",
            "xs",
            "__rmatmul__",
            "_rollback_to_year",
            "values",
            "_set_dtype",
            "_union",
            "_make_stat_function_ddof",
            "sample",
            "_can_hold_na",
            "dropna",
            "line",
            "_local_timestamps",
            "_dir_deletions",
            "_selection_name",
            "month_roll",
            "str_encode",
            "as_timestamp",
            "_sub_nat",
            "swaplevel",
            "memory_usage",
            "to_clipboard",
            "is_normalized",
            "is_monotonic_decreasing",
            "_set_item",
            "validate_periods",
            "__round__",
            "forbid_nonstring_types",
            "nbytes",
            "delta",
            "area",
            "resolution",
            "tolist",
            "rjust",
            "dtype",
            "rindex",
            "searchsorted",
            "__new__",
            "str_slice",
            "rule_code",
            "first",
            "_make_logical_function",
            "codes",
            "_clip_with_scalar",
            "to_sql",
            "__init__",
            "slice",
            "delegate_names",
            "_delegate_property_get",
            "as_ordered",
            "contains",
            "as_matrix",
            "remove_unused_categories",
            "_sub_datetime_arraylike",
            "last",
            "_binop",
            "tz_convert",
            "asfreq",
            "truncate",
            "_iget_item_cache",
            "_hasnans",
            "at_time",
            "str_extract",
            "_convert_for_op",
            "str_translate",
            "reindex_like",
            "_check_is_chained_assignment_possible",
            "_get_repr",
            "_box_values",
            "get_value_maybe_box",
            "_is_level_reference",
            "imag",
            "take",
            "_get_axis_name",
            "get_year_end",
            "filter",
            "axes",
            "valid",
            "__invert__",
            "__len__",
            "__sizeof__",
            "factorize",
            "dtypes",
            "transform",
            "align",
            "_box_item_values",
            "_reverse_indexer",
            "astype",
            "str_join",
            "apply_wraps",
            "append",
            "interpolate",
            "to_hdf",
            "_convert_to_list_like",
            "rename_categories",
            "_offset",
            "_get_label_or_level_values",
            "__array_ufunc__",
            "_repr_categories",
            "apply",
            "isna",
            "kde",
            "to_numpy",
            "sort_index",
            "where",
            "remove_na",
            "_factorize_from_iterable",
            "_selection_list",
            "decode",
            "strftime",
            "encode",
            "_set_is_copy",
            "to_period",
            "_coerce_method",
            "from_array",
            "to_latex",
            "register_dataframe_accessor",
            "split",
            "_mpl_repr",
            "_check_compatible_with",
            "generate_range",
            "rstrip",
            "_dir_additions",
            "_fast_union",
            "_gotitem",
            "max",
            "_reindex_axes",
            "corr",
            "center",
            "indexer_at_time",
            "to_pydatetime",
            "argmax",
            "equals",
            "_is_monotonic_decreasing",
            "_delta_to_tick",
            "is_unique",
            "rename",
            "_set_axis",
            "_set_with",
            "boxplot",
            "_set_values",
            "_partial_date_slice",
            "_concat_same_type",
            "index",
            "flags",
            "get_value",
            "_is_mixed_type",
            "_construct_axes_dict",
            "isAnchored",
            "_aggregate_multiple_funcs",
            "_from_factorized",
            "set_ordered",
            "get_rule_code_suffix",
            "__copy__",
            "_align_frame",
            "_get_call_args",
            "categories",
            "hist_frame",
            "hexbin",
            "translate",
            "_has_same_tz",
            "_recode_for_categories",
            "lstrip",
            "bfill",
            "freqstr",
            "quantile",
            "_offset_str",
            "is_dtype_equal",
            "_reindex_with_indexers",
            "str_rsplit",
            "_wrap_joined_index",
            "_set_value",
            "tzinfo",
            "to_dict",
            "_internal_get_values",
            "_round",
            "notna",
            "_find_backend",
            "pop",
            "as_unordered",
            "_indexed_same",
            "pipe",
            "nsmallest",
            "_init_dict",
            "_check_setitem_copy",
            "explode",
            "_generate_range",
            "_consolidate_inplace",
            "ftype",
            "isin",
            "_reset_cache",
            "_aggregate",
            "union_many",
            "_get_values_tuple",
            "get_dummies",
            "__setstate__",
            "timetz",
            "hist_series",
            "__rsub__",
            "scatter",
            "as_blocks",
            "pct_change",
            "_create_indexer",
            "_reindex_multi",
            "_isnan",
            "itemsize",
            "_end_apply_index",
            "wrap",
            "offset",
            "_repr_latex_",
            "_apply",
            "_from_name",
            "shift",
            "rename_axis",
            "_formatter_func",
            "hasnans",
            "_from_inferred_categories",
            "_freeze",
            "_check_label_or_level_ambiguity",
            "__delitem__",
            "to_julian_date",
            "_repr_data_resource_",
            "asobject",
            "barh",
            "_next_opening_time",
            "_get_index_resolvers",
            "_get_plot_backend",
            "autocorr",
            "get_weeks",
            "iteritems",
            "_parsed_string_to_bounds",
            "_set_labels",
            "cat_core",
            "_maybe_mask_results",
            "__reduce__",
            "reorder_levels",
            "_validate",
            "_add_nat",
            "_set_codes",
            "count",
            "boxplot_frame",
            "_obj_with_exclusions",
            "_shallow_copy",
            "_values_for_factorize",
            "tz_to_dtype",
            "_get_block_manager_axis",
            "name",
            "groupby",
            "__isub__",
            "asof",
            "__pos__",
            "_ixs",
            "str_replace",
            "_maybe_utc_convert",
            "str_decode",
            "cov",
            "is_monotonic",
            "_get_single_group_name",
            "combine_first",
            "unstack",
            "_str_extract_noexpand",
            "rollback",
            "_selected_obj",
            "insert",
            "asi8",
            "ffill",
            "remove_categories",
            "__abs__",
            "_map",
            "mode",
            "_get_values",
            "set_axis",
            "_make_cum_function",
            "ljust",
            "_values_for_argsort",
            "_validate_fill_value",
            "squeeze",
            "_formatter",
            "to_excel",
            "__eq__",
            "first_valid_index",
            "_get_bool_data",
            "get_dtype_counts",
            "_new_DatetimeIndex",
            "str_index",
            "__matmul__",
            "to_xarray",
            "mean",
            "copy",
            "str_findall",
            "_repr_footer",
            "items",
            "_str_extract_frame",
            "bdate_range",
            "_get_cython_func",
            "_is_datelike_mixed_type",
            "_construct_axes_dict_from",
            "_make_min_count_stat_function",
            "maybe_infer_tz",
            "find",
            "_maybe_normalize_endpoints",
            "_from_axes",
            "resample",
            "validate_inferred_freq",
            "_reduce",
            "reindex",
            "set_categories",
            "_validate_frequency",
            "_get_string_slice",
            "_dt_array_cmp",
            "nlargest",
            "register_index_accessor",
            "str_contains",
            "round",
            "data",
            "__array_wrap__",
            "_unbox_scalar",
            "_reindex_indexer",
            "_wrap_result",
            "transpose",
            "str_get_dummies",
            "get_values",
            "replace",
            "boxplot_frame_groupby",
            "between_time",
            "_add_delegate_accessors",
            "_get_codes",
            "join",
            "_set_axis_name",
            "floor",
            "min",
            "str_wrap",
            "cat_safe",
            "head",
            "__ne__",
            "str_match",
            "_assert_tzawareness_compat"
          ],
          "functions_name_co_evolved_modified_file": [
            "str_replace",
            "zfill",
            "normalize",
            "cat_core",
            "cat_safe",
            "str_translate",
            "str_match"
          ],
          "functions_name_co_evolved_all_files": [
            "_binop",
            "timedelta_range",
            "drop_duplicates",
            "asfreq",
            "_gotitem",
            "corr",
            "str_replace",
            "to_msgpack",
            "str_translate",
            "tz_localize",
            "reindex_like",
            "rename_categories",
            "reindex",
            "insert",
            "_set_name",
            "quantile",
            "normalize",
            "_check_label_or_level_ambiguity",
            "argsort",
            "rename",
            "to_numpy",
            "slice_shift",
            "_set_value",
            "sequence_to_dt64ns",
            "objects_to_datetime64ns",
            "tshift",
            "round",
            "to_pickle",
            "rank",
            "to_json",
            "cat_core",
            "boxplot_frame_groupby",
            "reorder_levels",
            "_add_delegate_accessors",
            "_init_dict",
            "duplicated",
            "delegate_names",
            "zfill",
            "cat_safe",
            "str_match",
            "hist_series"
          ]
        },
        "file": {
          "file_name": "strings.py",
          "file_nloc": 1982,
          "file_complexity": 278,
          "file_token_count": 7973,
          "file_before": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import Dict, List\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nfrom pandas.util._decorators import Appender, deprecate_kwarg\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_integer,\n    is_list_like,\n    is_re,\n    is_scalar,\n    is_string_like,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame,\n    ABCIndexClass,\n    ABCMultiIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nimport pandas.core.common as com\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs = dict()  # type: Dict[str, str]\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        return np.sum(list_of_columns, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    \"column {}\".format(dtype)\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the\"\n                \" groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : bool, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _result_dtype(arr):\n    # workaround #27953\n    # ideally we just pass `dtype=arr.dtype` unconditionally, but this fails\n    # when the list of values is empty.\n    if arr.dtype.name == \"string\":\n        return \"string\"\n    else:\n        return object\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, ABCIndexClass):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    dtype = _result_dtype(arr)\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=dtype,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n    dtype = _result_dtype(arr)\n\n    result = arr._constructor_expanddim(\n        match_list, index=index, columns=columns, dtype=dtype\n    )\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.to_numpy(), lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill :  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = \"fillchar must be a character, not {0}\"\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = \"width must be of integer type, not {0}\"\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(start=-1)\n    0           a\n    1           x\n    2           n\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    \"Cannot use .str.{name} with values of inferred dtype \"\n                    \"{inf_type!r}.\".format(\n                        name=func_name, inf_type=self._inferred_dtype\n                    )\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(\n    f,\n    name=None,\n    docstring=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f,\n    flags=False,\n    na=False,\n    name=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kwargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n        self._is_string = data.dtype.name == \"string\"\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        from pandas import StringDtype\n\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # explicitly allow StringDtype\n        if isinstance(values.dtype, StringDtype):\n            return \"string\"\n\n        try:\n            inferred_dtype = lib.infer_dtype(values, skipna=True)\n        except ValueError:\n            # GH#27571 mostly occurs with ExtensionArray\n            inferred_dtype = None\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self,\n        result,\n        use_codes=True,\n        name=None,\n        expand=None,\n        fill_value=np.nan,\n        returns_string=True,\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        # We can be wrapping a string / object / categorical result, in which\n        # case we'll want to return the same dtype as the input.\n        # Or we can be wrapping a numeric output, in which case we don't want\n        # to return a StringArray.\n        if self._is_string and returns_string:\n            dtype = \"string\"\n        else:\n            dtype = None\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndexClass):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                result = cons(result, columns=name, index=index, dtype=dtype)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                result = cons(result, name=name, index=index, dtype=dtype)\n            return result\n\n    def _get_series_list(self, others):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, Index or np.ndarray (1-dim)\n\n        Returns\n        -------\n        list : others transformed into list of Series\n        \"\"\"\n        from pandas import Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n        if isinstance(others, ABCSeries):\n            return [others]\n        elif isinstance(others, ABCIndexClass):\n            return [Series(others.values, index=others)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[x] for x in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return [others[x] for x in others]\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either Series/Index/np.ndarray (1-dim)...\n            if all(\n                isinstance(x, (ABCSeries, ABCIndexClass))\n                or (isinstance(x, np.ndarray) and x.ndim == 1)\n                for x in others\n            ):\n                los = []\n                while others:  # iterate through list and append each element\n                    los = los + self._get_series_list(others.pop(0))\n                return los\n            # ... or just strings\n            elif all(not is_list_like(x) for x in others):\n                return [Series(others, index=idx)]\n        raise TypeError(\n            \"others must be Series, Index, DataFrame, np.ndarrary \"\n            \"or list-like (either containing only strings or \"\n            \"containing only objects of type Series/Index/\"\n            \"np.ndarray[1-dim])\"\n        )\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=\"left\"):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). To disable\n            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n\n            .. versionadded:: 0.23.0\n            .. versionchanged:: 1.0.0\n                Changed default of `join` from None to `'left'`.\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndexClass):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others = self._get_series_list(others)\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            raise ValueError(\n                \"If `others` contains arrays or lists (or other \"\n                \"list-likes without an index), these must all be \"\n                \"of the same length as the calling Series/Index.\"\n            )\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndexClass):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            if is_categorical_dtype(self._orig.dtype):\n                # We need to infer the new categories.\n                dtype = None\n            else:\n                dtype = self._orig.dtype\n            result = Series(result, dtype=dtype, index=data.index, name=self._orig.name)\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    pat : str, default whitespace\n        .. deprecated:: 0.24.0\n           Use ``sep`` instead\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        # TODO: Not sure how to handle this.\n        return self._wrap_result(result, returns_string=False)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result,\n            use_codes=(not self._is_categorical),\n            name=name,\n            expand=True,\n            returns_string=False,\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\", returns_string=False)\n    startswith = _pat_wrapper(\n        str_startswith, na=True, name=\"startswith\", returns_string=False\n    )\n    endswith = _pat_wrapper(\n        str_endswith, na=True, name=\"endswith\", returns_string=False\n    )\n    findall = _pat_wrapper(\n        str_findall, flags=True, name=\"findall\", returns_string=False\n    )\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len,\n        docstring=_shared_docs[\"len\"],\n        forbidden_types=None,\n        dtype=int,\n        returns_string=False,\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args = {}  # type: Dict[str, Dict[str, str]]\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n        returns_string=False,\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n        returns_string=False,\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n        returns_string=False,\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n        returns_string=False,\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n        returns_string=False,\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n        returns_string=False,\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n        returns_string=False,\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n        returns_string=False,\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n        returns_string=False,\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_after": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import Dict, List\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nfrom pandas.util._decorators import Appender, deprecate_kwarg\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_integer,\n    is_list_like,\n    is_re,\n    is_scalar,\n    is_string_like,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame,\n    ABCIndexClass,\n    ABCMultiIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nimport pandas.core.common as com\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs = dict()  # type: Dict[str, str]\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        return np.sum(list_of_columns, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns.\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep.\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    \"column {}\".format(dtype)\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the\"\n                \" groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        Determines if replace is case sensitive:\n\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex.\n\n    flags : int, default 0 (no flags)\n        Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled\n        regex.\n    regex : bool, default True\n        Determines if assumes the passed-in pattern is a regular expression:\n\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Regex module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _result_dtype(arr):\n    # workaround #27953\n    # ideally we just pass `dtype=arr.dtype` unconditionally, but this fails\n    # when the list of values is empty.\n    if arr.dtype.name == \"string\":\n        return \"string\"\n    else:\n        return object\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, ABCIndexClass):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    dtype = _result_dtype(arr)\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=dtype,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n    dtype = _result_dtype(arr)\n\n    result = arr._constructor_expanddim(\n        match_list, index=index, columns=columns, dtype=dtype\n    )\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.to_numpy(), lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill :  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = \"fillchar must be a character, not {0}\"\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = \"width must be of integer type, not {0}\"\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(start=-1)\n    0           a\n    1           x\n    2           n\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    \"Cannot use .str.{name} with values of inferred dtype \"\n                    \"{inf_type!r}.\".format(\n                        name=func_name, inf_type=self._inferred_dtype\n                    )\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(\n    f,\n    name=None,\n    docstring=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f,\n    flags=False,\n    na=False,\n    name=None,\n    forbidden_types=[\"bytes\"],\n    returns_string=True,\n    **kwargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result, returns_string=returns_string)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n        self._is_string = data.dtype.name == \"string\"\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        from pandas import StringDtype\n\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # explicitly allow StringDtype\n        if isinstance(values.dtype, StringDtype):\n            return \"string\"\n\n        try:\n            inferred_dtype = lib.infer_dtype(values, skipna=True)\n        except ValueError:\n            # GH#27571 mostly occurs with ExtensionArray\n            inferred_dtype = None\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self,\n        result,\n        use_codes=True,\n        name=None,\n        expand=None,\n        fill_value=np.nan,\n        returns_string=True,\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        # We can be wrapping a string / object / categorical result, in which\n        # case we'll want to return the same dtype as the input.\n        # Or we can be wrapping a numeric output, in which case we don't want\n        # to return a StringArray.\n        if self._is_string and returns_string:\n            dtype = \"string\"\n        else:\n            dtype = None\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndexClass):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                result = cons(result, columns=name, index=index, dtype=dtype)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                result = cons(result, name=name, index=index, dtype=dtype)\n            return result\n\n    def _get_series_list(self, others):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            Objects that are either Series, Index or np.ndarray (1-dim).\n\n        Returns\n        -------\n        list of Series\n            Others transformed into list of Series.\n        \"\"\"\n        from pandas import Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n        if isinstance(others, ABCSeries):\n            return [others]\n        elif isinstance(others, ABCIndexClass):\n            return [Series(others.values, index=others)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[x] for x in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return [others[x] for x in others]\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either Series/Index/np.ndarray (1-dim)...\n            if all(\n                isinstance(x, (ABCSeries, ABCIndexClass))\n                or (isinstance(x, np.ndarray) and x.ndim == 1)\n                for x in others\n            ):\n                los = []\n                while others:  # iterate through list and append each element\n                    los = los + self._get_series_list(others.pop(0))\n                return los\n            # ... or just strings\n            elif all(not is_list_like(x) for x in others):\n                return [Series(others, index=idx)]\n        raise TypeError(\n            \"others must be Series, Index, DataFrame, np.ndarrary \"\n            \"or list-like (either containing only strings or \"\n            \"containing only objects of type Series/Index/\"\n            \"np.ndarray[1-dim])\"\n        )\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=\"left\"):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). To disable\n            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n\n            .. versionadded:: 0.23.0\n            .. versionchanged:: 1.0.0\n                Changed default of `join` from None to `'left'`.\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndexClass):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others = self._get_series_list(others)\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            raise ValueError(\n                \"If `others` contains arrays or lists (or other \"\n                \"list-likes without an index), these must all be \"\n                \"of the same length as the calling Series/Index.\"\n            )\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndexClass):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            if is_categorical_dtype(self._orig.dtype):\n                # We need to infer the new categories.\n                dtype = None\n            else:\n                dtype = self._orig.dtype\n            result = Series(result, dtype=dtype, index=data.index, name=self._orig.name)\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    pat : str, default whitespace\n        .. deprecated:: 0.24.0\n           Use ``sep`` instead.\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand, returns_string=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na, returns_string=False)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``.\n    fillchar : str\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    filled : Series/Index of objects.\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects.\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        # TODO: Not sure how to handle this.\n        return self._wrap_result(result, returns_string=False)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result,\n            use_codes=(not self._is_categorical),\n            name=name,\n            expand=True,\n            returns_string=False,\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\", returns_string=False)\n    startswith = _pat_wrapper(\n        str_startswith, na=True, name=\"startswith\", returns_string=False\n    )\n    endswith = _pat_wrapper(\n        str_endswith, na=True, name=\"endswith\", returns_string=False\n    )\n    findall = _pat_wrapper(\n        str_findall, flags=True, name=\"findall\", returns_string=False\n    )\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of int.\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form.\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result, returns_string=False)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result, returns_string=False)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len,\n        docstring=_shared_docs[\"len\"],\n        forbidden_types=None,\n        dtype=int,\n        returns_string=False,\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series or Index of object\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args = {}  # type: Dict[str, Dict[str, str]]\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n        returns_string=False,\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n        returns_string=False,\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n        returns_string=False,\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n        returns_string=False,\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n        returns_string=False,\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n        returns_string=False,\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n        returns_string=False,\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n        returns_string=False,\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n        returns_string=False,\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_patch": "@@ -57,12 +57,12 @@ def cat_core(list_of_columns: List, sep: str):\n         List of arrays to be concatenated with sep;\n         these arrays may not contain NaNs!\n     sep : string\n-        The separator string for concatenating the columns\n+        The separator string for concatenating the columns.\n \n     Returns\n     -------\n     nd.array\n-        The concatenation of list_of_columns with sep\n+        The concatenation of list_of_columns with sep.\n     \"\"\"\n     if sep == \"\":\n         # no need to interleave sep if it is empty\n@@ -85,12 +85,12 @@ def cat_safe(list_of_columns: List, sep: str):\n         List of arrays to be concatenated with sep;\n         these arrays may not contain NaNs!\n     sep : string\n-        The separator string for concatenating the columns\n+        The separator string for concatenating the columns.\n \n     Returns\n     -------\n     nd.array\n-        The concatenation of list_of_columns with sep\n+        The concatenation of list_of_columns with sep.\n     \"\"\"\n     try:\n         result = cat_core(list_of_columns, sep)\n@@ -506,13 +506,18 @@ def str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n     n : int, default -1 (all)\n         Number of replacements to make from start.\n     case : bool, default None\n+        Determines if replace is case sensitive:\n+\n         - If True, case sensitive (the default if `pat` is a string)\n         - Set to False for case insensitive\n-        - Cannot be set if `pat` is a compiled regex\n+        - Cannot be set if `pat` is a compiled regex.\n+\n     flags : int, default 0 (no flags)\n-        - re module flags, e.g. re.IGNORECASE\n-        - Cannot be set if `pat` is a compiled regex\n+        Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled\n+        regex.\n     regex : bool, default True\n+        Determines if assumes the passed-in pattern is a regular expression:\n+\n         - If True, assumes the passed-in pattern is a regular expression.\n         - If False, treats the pattern as a literal string\n         - Cannot be set to False if `pat` is a compiled regex or `repl` is\n@@ -713,7 +718,7 @@ def str_match(arr, pat, case=True, flags=0, na=np.nan):\n     case : bool, default True\n         If True, case sensitive.\n     flags : int, default 0 (no flags)\n-        re module flags, e.g. re.IGNORECASE.\n+        Regex module flags, e.g. re.IGNORECASE.\n     na : default NaN\n         Fill value for missing values.\n \n@@ -1681,7 +1686,7 @@ def str_translate(arr, table):\n     Parameters\n     ----------\n     table : dict\n-        table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n+        Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n         None. Unmapped characters are left untouched.\n         Characters mapped to None are deleted. :meth:`str.maketrans` is a\n         helper function for making translation tables.\n@@ -2134,11 +2139,12 @@ class StringMethods(NoNewAttributesMixin):\n         Parameters\n         ----------\n         others : Series, DataFrame, np.ndarray, list-like or list-like of\n-            objects that are either Series, Index or np.ndarray (1-dim)\n+            Objects that are either Series, Index or np.ndarray (1-dim).\n \n         Returns\n         -------\n-        list : others transformed into list of Series\n+        list of Series\n+            Others transformed into list of Series.\n         \"\"\"\n         from pandas import Series, DataFrame\n \n@@ -2556,7 +2562,7 @@ class StringMethods(NoNewAttributesMixin):\n         String to split on.\n     pat : str, default whitespace\n         .. deprecated:: 0.24.0\n-           Use ``sep`` instead\n+           Use ``sep`` instead.\n     expand : bool, default True\n         If True, return DataFrame/MultiIndex expanding dimensionality.\n         If False, return Series/Index.\n@@ -2712,13 +2718,13 @@ class StringMethods(NoNewAttributesMixin):\n     ----------\n     width : int\n         Minimum width of resulting string; additional characters will be filled\n-        with ``fillchar``\n+        with ``fillchar``.\n     fillchar : str\n-        Additional character for filling, default is whitespace\n+        Additional character for filling, default is whitespace.\n \n     Returns\n     -------\n-    filled : Series/Index of objects\n+    filled : Series/Index of objects.\n     \"\"\"\n \n     @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n@@ -2754,7 +2760,7 @@ class StringMethods(NoNewAttributesMixin):\n \n         Returns\n         -------\n-        Series/Index of objects\n+        Series/Index of objects.\n \n         See Also\n         --------\n@@ -2842,7 +2848,7 @@ class StringMethods(NoNewAttributesMixin):\n \n     Returns\n     -------\n-    Series/Index of objects\n+    Series or Index of object\n \n     See Also\n     --------\n@@ -2967,15 +2973,15 @@ class StringMethods(NoNewAttributesMixin):\n     Parameters\n     ----------\n     sub : str\n-        Substring being searched\n+        Substring being searched.\n     start : int\n-        Left edge index\n+        Left edge index.\n     end : int\n-        Right edge index\n+        Right edge index.\n \n     Returns\n     -------\n-    found : Series/Index of integer values\n+    Series or Index of int.\n \n     See Also\n     --------\n@@ -3018,7 +3024,7 @@ class StringMethods(NoNewAttributesMixin):\n         Parameters\n         ----------\n         form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n-            Unicode form\n+            Unicode form.\n \n         Returns\n         -------\n@@ -3041,15 +3047,15 @@ class StringMethods(NoNewAttributesMixin):\n     Parameters\n     ----------\n     sub : str\n-        Substring being searched\n+        Substring being searched.\n     start : int\n-        Left edge index\n+        Left edge index.\n     end : int\n-        Right edge index\n+        Right edge index.\n \n     Returns\n     -------\n-    found : Series/Index of objects\n+    Series or Index of object\n \n     See Also\n     --------\n@@ -3147,7 +3153,7 @@ class StringMethods(NoNewAttributesMixin):\n \n     Returns\n     -------\n-    Series/Index of objects\n+    Series or Index of object\n \n     See Also\n     --------\n",
          "files_name_in_blame_commit": [
            "series.py",
            "datetimelike.py",
            "categorical.py",
            "base.py",
            "datetimes.py",
            "offsets.py",
            "timedeltas.py",
            "_core.py",
            "generic.py",
            "accessor.py",
            "strings.py"
          ]
        }
      },
      "9000c3997b0bed60392225e9d2c6ced236eabe2b": {
        "commit": {
          "commit_id": "9000c3997b0bed60392225e9d2c6ced236eabe2b",
          "commit_message": "DEPR: execute deprecations for str.cat in v1.0 (#27611)",
          "commit_author": "h-vetinari",
          "commit_date": "2019-07-31 08:32:35",
          "commit_parent": "eb9a8e35eff001bffbe484a969ed36c818163ad0"
        },
        "function": {
          "function_name": "_get_series_list",
          "function_code_before": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Series, DataFrame\n    idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarray or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, ABCSeries):\n        warn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and warn else others]\n        return (los, warn)\n    elif isinstance(others, ABCIndexClass):\n        warn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, warn)\n    elif isinstance(others, DataFrame):\n        warn = not others.index.equals(idx)\n        if ignore_index and warn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], warn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((is_list_like(x, allow_sets=False) for x in others)):\n            los = []\n            join_warn = False\n            depr_warn = False\n            while others:\n                nxt = others.pop(0)\n                if not (isinstance(nxt, (Series, ABCIndexClass)) or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)):\n                    depr_warn = True\n                if not isinstance(nxt, (DataFrame, Series, ABCIndexClass, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, ABCIndexClass))\n                is_legal = no_deep and nxt.dtype == object or all((not is_list_like(x) for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, wnx) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                join_warn = join_warn or wnx\n            if depr_warn:\n                warnings.warn('list-likes other than Series, Index, or np.ndarray WITHIN another list-like are deprecated and will be removed in a future version.', FutureWarning, stacklevel=4)\n            return (los, join_warn)\n        elif all((not is_list_like(x) for x in others)):\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_code_after": "def _get_series_list(self, others):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, Index or np.ndarray (1-dim)\n\n        Returns\n        -------\n        list : others transformed into list of Series\n        \"\"\"\n    from pandas import Series, DataFrame\n    idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n    if isinstance(others, ABCSeries):\n        return [others]\n    elif isinstance(others, ABCIndexClass):\n        return [Series(others.values, index=others)]\n    elif isinstance(others, ABCDataFrame):\n        return [others[x] for x in others]\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return [others[x] for x in others]\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((isinstance(x, (ABCSeries, ABCIndexClass)) or (isinstance(x, np.ndarray) and x.ndim == 1) for x in others)):\n            los = []\n            while others:\n                los = los + self._get_series_list(others.pop(0))\n            return los\n        elif all((not is_list_like(x) for x in others)):\n            return [Series(others, index=idx)]\n    raise TypeError('others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/np.ndarray[1-dim])')",
          "function_before_start_line": 2064,
          "function_before_end_line": 2184,
          "function_after_start_line": 2069,
          "function_after_end_line": 2123,
          "function_before_token_count": 491,
          "function_after_token_count": 232,
          "functions_name_modified_file": [
            "str_endswith",
            "rsplit",
            "str_encode",
            "str_get",
            "translate",
            "lstrip",
            "str_pad",
            "_make_accessor",
            "str_count",
            "forbid_nonstring_types",
            "str_rsplit",
            "rjust",
            "rindex",
            "str_slice",
            "str_slice_replace",
            "__getitem__",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "get_dummies",
            "contains",
            "match",
            "wrap",
            "str_extract",
            "str_translate",
            "_noarg_wrapper",
            "partition",
            "_na_map",
            "cat_core",
            "_validate",
            "zfill",
            "_groups_or_na_fun",
            "str_replace",
            "str_join",
            "str_decode",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "normalize",
            "str_find",
            "_map",
            "slice_replace",
            "rpartition",
            "decode",
            "ljust",
            "encode",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "center",
            "find",
            "str_repeat",
            "__iter__",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "get",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "str_split",
            "_get_series_list",
            "join",
            "str_wrap",
            "cat_safe",
            "str_match",
            "cat"
          ],
          "functions_name_all_files": [
            "test_get_dummies_with_name_dummy",
            "test_extractall_same_as_extract",
            "str_endswith",
            "test_extractall_single_group",
            "test_strip_lstrip_rstrip_args",
            "rsplit",
            "test_partition_deprecation",
            "str_encode",
            "str_get",
            "test_extract_expand_None",
            "translate",
            "test_len",
            "lstrip",
            "test_replace_compiled_regex",
            "test_extractall_no_matches",
            "test_match_findall_flags",
            "str_pad",
            "_make_accessor",
            "str_count",
            "any_allowed_skipna_inferred_dtype",
            "test_lower_upper",
            "test_str_cat_special_cases",
            "forbid_nonstring_types",
            "str_rsplit",
            "test_casemethods",
            "test_pipe_failures",
            "rjust",
            "test_iter",
            "rindex",
            "test_join",
            "str_slice",
            "test_get",
            "str_slice_replace",
            "test_encode_decode",
            "test_api_mi_raises",
            "test_api_per_method",
            "test_cat_on_filtered_index",
            "test_str_cat_categorical",
            "__getitem__",
            "test_capitalize",
            "test_split_no_pat_with_nonzero_n",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "test_extractall",
            "get_dummies",
            "test_extract_expand_unspecified",
            "test_rsplit_to_multiindex_expand",
            "test_extractall_same_as_extract_subject_index",
            "contains",
            "test_str_cat_raises_intuitive_error",
            "test_str_cat",
            "test_pad",
            "test_casefold",
            "test_method_on_bytes",
            "test_match",
            "test_split_blank_string",
            "match",
            "test_contains",
            "test_extract_expand_True",
            "wrap",
            "test_contains_nan",
            "str_extract",
            "str_translate",
            "test_center_ljust_rjust_fillchar",
            "test_pad_width",
            "test_contains_for_object_category",
            "_noarg_wrapper",
            "test_rsplit",
            "test_extractall_single_group_with_quantifier",
            "test_empty_str_methods_to_frame",
            "test_swapcase",
            "test_replace_literal",
            "test_strip_lstrip_rstrip_mixed",
            "test_iter_single_element",
            "test_translate",
            "partition",
            "test_wrap",
            "test_str_cat_align_mixed_inputs",
            "test_get_dummies",
            "_na_map",
            "test_title",
            "test_extract_index_one_two_groups",
            "test_str_cat_name",
            "test_center_ljust_rjust",
            "test_replace",
            "cat_core",
            "test_count",
            "test_index_str_accessor_visibility",
            "_validate",
            "test_split_noargs",
            "test_get_complex",
            "test_pad_fillchar",
            "zfill",
            "test_extract_series",
            "test_zfill",
            "test_extract_optional_groups",
            "_groups_or_na_fun",
            "test_api_for_categorical",
            "test_find_nan",
            "str_replace",
            "str_join",
            "str_decode",
            "test_split_to_multiindex_expand",
            "test_replace_callable",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "test_iter_object_try_string",
            "test_empty_str_methods",
            "test_str_accessor_no_new_attributes",
            "test_encode_decode_errors",
            "test_partition_to_dataframe",
            "test_split",
            "test_split_maxsplit",
            "normalize",
            "test_partition_series",
            "test_strip_lstrip_rstrip",
            "str_find",
            "_map",
            "test_extract_single_group_returns_frame",
            "test_api_per_dtype",
            "test_repeat",
            "slice_replace",
            "test_api",
            "test_str_cat_wrong_dtype_raises",
            "rpartition",
            "decode",
            "test_rsplit_to_dataframe_expand",
            "ljust",
            "encode",
            "test_endswith",
            "test_slice",
            "test_split_with_name",
            "assert_series_or_index_equal",
            "test_slice_replace",
            "test_contains_moar",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "test_partition_with_name",
            "test_str_cat_align_indexed",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "test_iter_empty",
            "test_extractall_errors",
            "center",
            "find",
            "any_string_method",
            "test_ismethods",
            "test_string_slice_out_of_bounds",
            "str_repeat",
            "test_split_nan_expand",
            "test_extract_expand_False",
            "test_replace_moar",
            "test_normalize",
            "test_str_cat_all_na",
            "__iter__",
            "test_extractall_stringindex",
            "test_find",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "test_get_complex_nested",
            "test_findall",
            "get",
            "test_string_slice_get_syntax",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "test_isnumeric",
            "str_split",
            "_get_series_list",
            "join",
            "test_str_cat_mixed_inputs",
            "str_wrap",
            "cat_safe",
            "test_split_to_dataframe",
            "test_partition_index",
            "str_match",
            "test_index",
            "cat",
            "test_startswith"
          ],
          "functions_name_co_evolved_modified_file": [
            "cat"
          ],
          "functions_name_co_evolved_all_files": [
            "test_str_cat_align_mixed_inputs",
            "test_str_cat_mixed_inputs",
            "test_str_cat",
            "test_str_cat_name",
            "test_str_cat_categorical",
            "cat"
          ]
        },
        "file": {
          "file_name": "strings.py",
          "file_nloc": 1912,
          "file_complexity": 271,
          "file_token_count": 7711,
          "file_before": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import Dict, List\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nfrom pandas.util._decorators import Appender, deprecate_kwarg\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_integer,\n    is_list_like,\n    is_re,\n    is_scalar,\n    is_string_like,\n)\nfrom pandas.core.dtypes.generic import ABCIndexClass, ABCMultiIndex, ABCSeries\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nimport pandas.core.common as com\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs = dict()  # type: Dict[str, str]\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        return np.sum(list_of_columns, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    \"column {}\".format(dtype)\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the\"\n                \" groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : bool, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, ABCIndexClass):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index, columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill :  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = \"fillchar must be a character, not {0}\"\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = \"width must be of integer type, not {0}\"\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    \"Cannot use .str.{name} with values of inferred dtype \"\n                    \"{inf_type!r}.\".format(\n                        name=func_name, inf_type=self._inferred_dtype\n                    )\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(f, name=None, docstring=None, forbidden_types=[\"bytes\"], **kargs):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f, flags=False, na=False, name=None, forbidden_types=[\"bytes\"], **kwargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # missing values obfuscate type inference -> skip\n        inferred_dtype = lib.infer_dtype(values, skipna=True)\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self, result, use_codes=True, name=None, expand=None, fill_value=np.nan\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndexClass):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # Once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n\n        err_msg = (\n            \"others must be Series, Index, DataFrame, np.ndarray or \"\n            \"list-like (either containing only strings or containing \"\n            \"only objects of type Series/Index/list-like/np.ndarray)\"\n        )\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n        # index, *unless* ignore_index is set to True.\n        if isinstance(others, ABCSeries):\n            warn = not others.index.equals(idx)\n            # only reconstruct Series when absolutely necessary\n            los = [\n                Series(others.values, index=idx) if ignore_index and warn else others\n            ]\n            return (los, warn)\n        elif isinstance(others, ABCIndexClass):\n            warn = not others.equals(idx)\n            los = [Series(others.values, index=(idx if ignore_index else others))]\n            return (los, warn)\n        elif isinstance(others, DataFrame):\n            warn = not others.index.equals(idx)\n            if ignore_index and warn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], warn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either one-dimensional list-likes or scalars\n            if all(is_list_like(x, allow_sets=False) for x in others):\n                los = []\n                join_warn = False\n                depr_warn = False\n                # iterate through list and append list of series for each\n                # element (which we check to be one-dimensional and non-nested)\n                while others:\n                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n\n                    # GH 21950 - DeprecationWarning\n                    # only allowing Series/Index/np.ndarray[1-dim] will greatly\n                    # simply this function post-deprecation.\n                    if not (\n                        isinstance(nxt, (Series, ABCIndexClass))\n                        or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                    ):\n                        depr_warn = True\n\n                    if not isinstance(\n                        nxt, (DataFrame, Series, ABCIndexClass, np.ndarray)\n                    ):\n                        # safety for non-persistent list-likes (e.g. iterators)\n                        # do not map indexed/typed objects; info needed below\n                        nxt = list(nxt)\n\n                    # known types for which we can avoid deep inspection\n                    no_deep = (\n                        isinstance(nxt, np.ndarray) and nxt.ndim == 1\n                    ) or isinstance(nxt, (Series, ABCIndexClass))\n                    # nested list-likes are forbidden:\n                    # -> elements of nxt must not be list-like\n                    is_legal = (no_deep and nxt.dtype == object) or all(\n                        not is_list_like(x) for x in nxt\n                    )\n\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, wnx = self._get_series_list(nxt, ignore_index=ignore_index)\n                    los = los + nxt\n                    join_warn = join_warn or wnx\n\n                if depr_warn:\n                    warnings.warn(\n                        \"list-likes other than Series, Index, or \"\n                        \"np.ndarray WITHIN another list-like are \"\n                        \"deprecated and will be removed in a future \"\n                        \"version.\",\n                        FutureWarning,\n                        stacklevel=4,\n                    )\n                return (los, join_warn)\n            elif all(not is_list_like(x) for x in others):\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndexClass):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, warn = self._get_series_list(others, ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError(\n                    \"All arrays must be same length, except \"\n                    \"those having an index if `join` is not None\"\n                )\n            else:\n                raise ValueError(\n                    \"If `others` contains arrays or lists (or \"\n                    \"other list-likes without an index), these \"\n                    \"must all be of the same length as the \"\n                    \"calling Series/Index.\"\n                )\n\n        if join is None and warn:\n            warnings.warn(\n                \"A future version of pandas will perform index \"\n                \"alignment when `others` is a Series/Index/\"\n                \"DataFrame (or a list-like containing one). To \"\n                \"disable alignment (the behavior before v.0.23) and \"\n                \"silence this warning, use `.values` on any Series/\"\n                \"Index/DataFrame in `others`. To enable alignment \"\n                \"and silence this warning, pass `join='left'|\"\n                \"'outer'|'inner'|'right'`. The future default will \"\n                \"be `join='left'`.\",\n                FutureWarning,\n                stacklevel=3,\n            )\n\n        # if join is None, _get_series_list already force-aligned indexes\n        join = \"left\" if join is None else join\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndexClass):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            result = Series(\n                result, dtype=object, index=data.index, name=self._orig.name\n            )\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    pat : str, default whitespace\n        .. deprecated:: 0.24.0\n           Use ``sep`` instead\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result, use_codes=(not self._is_categorical), name=name, expand=True\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\")\n    startswith = _pat_wrapper(str_startswith, na=True, name=\"startswith\")\n    endswith = _pat_wrapper(str_endswith, na=True, name=\"endswith\")\n    findall = _pat_wrapper(str_findall, flags=True, name=\"findall\")\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len, docstring=_shared_docs[\"len\"], forbidden_types=None, dtype=int\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args = {}  # type: Dict[str, Dict[str, str]]\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_after": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import Dict, List\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nfrom pandas.util._decorators import Appender, deprecate_kwarg\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_integer,\n    is_list_like,\n    is_re,\n    is_scalar,\n    is_string_like,\n)\nfrom pandas.core.dtypes.generic import (\n    ABCDataFrame,\n    ABCIndexClass,\n    ABCMultiIndex,\n    ABCSeries,\n)\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nimport pandas.core.common as com\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs = dict()  # type: Dict[str, str]\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    if sep == \"\":\n        # no need to interleave sep if it is empty\n        return np.sum(list_of_columns, axis=0)\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    \"column {}\".format(dtype)\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the\"\n                \" groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : bool, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, ABCIndexClass):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index, columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill :  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = \"fillchar must be a character, not {0}\"\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = \"width must be of integer type, not {0}\"\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    \"Cannot use .str.{name} with values of inferred dtype \"\n                    \"{inf_type!r}.\".format(\n                        name=func_name, inf_type=self._inferred_dtype\n                    )\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(f, name=None, docstring=None, forbidden_types=[\"bytes\"], **kargs):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f, flags=False, na=False, name=None, forbidden_types=[\"bytes\"], **kwargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # missing values obfuscate type inference -> skip\n        inferred_dtype = lib.infer_dtype(values, skipna=True)\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self, result, use_codes=True, name=None, expand=None, fill_value=np.nan\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndexClass):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, Index or np.ndarray (1-dim)\n\n        Returns\n        -------\n        list : others transformed into list of Series\n        \"\"\"\n        from pandas import Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n        if isinstance(others, ABCSeries):\n            return [others]\n        elif isinstance(others, ABCIndexClass):\n            return [Series(others.values, index=others)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[x] for x in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return [others[x] for x in others]\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either Series/Index/np.ndarray (1-dim)...\n            if all(\n                isinstance(x, (ABCSeries, ABCIndexClass))\n                or (isinstance(x, np.ndarray) and x.ndim == 1)\n                for x in others\n            ):\n                los = []\n                while others:  # iterate through list and append each element\n                    los = los + self._get_series_list(others.pop(0))\n                return los\n            # ... or just strings\n            elif all(not is_list_like(x) for x in others):\n                return [Series(others, index=idx)]\n        raise TypeError(\n            \"others must be Series, Index, DataFrame, np.ndarrary \"\n            \"or list-like (either containing only strings or \"\n            \"containing only objects of type Series/Index/\"\n            \"np.ndarray[1-dim])\"\n        )\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=\"left\"):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). To disable\n            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n\n            .. versionadded:: 0.23.0\n            .. versionchanged:: 1.0.0\n                Changed default of `join` from None to `'left'`.\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndexClass):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others = self._get_series_list(others)\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            raise ValueError(\n                \"If `others` contains arrays or lists (or other \"\n                \"list-likes without an index), these must all be \"\n                \"of the same length as the calling Series/Index.\"\n            )\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndexClass):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            result = Series(\n                result, dtype=object, index=data.index, name=self._orig.name\n            )\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    pat : str, default whitespace\n        .. deprecated:: 0.24.0\n           Use ``sep`` instead\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of `sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result, use_codes=(not self._is_categorical), name=name, expand=True\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\")\n    startswith = _pat_wrapper(str_startswith, na=True, name=\"startswith\")\n    endswith = _pat_wrapper(str_endswith, na=True, name=\"endswith\")\n    findall = _pat_wrapper(str_findall, flags=True, name=\"findall\")\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len, docstring=_shared_docs[\"len\"], forbidden_types=None, dtype=int\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args = {}  # type: Dict[str, Dict[str, str]]\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_patch": "@@ -21,7 +21,12 @@ from pandas.core.dtypes.common import (\n     is_scalar,\n     is_string_like,\n )\n-from pandas.core.dtypes.generic import ABCIndexClass, ABCMultiIndex, ABCSeries\n+from pandas.core.dtypes.generic import (\n+    ABCDataFrame,\n+    ABCIndexClass,\n+    ABCMultiIndex,\n+    ABCSeries,\n+)\n from pandas.core.dtypes.missing import isna\n \n from pandas.core.algorithms import take_1d\n@@ -2061,7 +2066,7 @@ class StringMethods(NoNewAttributesMixin):\n                 cons = self._orig._constructor\n                 return cons(result, name=name, index=index)\n \n-    def _get_series_list(self, others, ignore_index=False):\n+    def _get_series_list(self, others):\n         \"\"\"\n         Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n         into a list of Series (elements without an index must match the length\n@@ -2069,122 +2074,56 @@ class StringMethods(NoNewAttributesMixin):\n \n         Parameters\n         ----------\n-        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n-            of objects that are Series, Index or np.ndarray (1-dim)\n-        ignore_index : boolean, default False\n-            Determines whether to forcefully align others with index of caller\n+        others : Series, DataFrame, np.ndarray, list-like or list-like of\n+            objects that are either Series, Index or np.ndarray (1-dim)\n \n         Returns\n         -------\n-        tuple : (others transformed into list of Series,\n-                 boolean whether FutureWarning should be raised)\n+        list : others transformed into list of Series\n         \"\"\"\n-\n-        # Once str.cat defaults to alignment, this function can be simplified;\n-        # will not need `ignore_index` and the second boolean output anymore\n-\n         from pandas import Series, DataFrame\n \n         # self._orig is either Series or Index\n         idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n \n-        err_msg = (\n-            \"others must be Series, Index, DataFrame, np.ndarray or \"\n-            \"list-like (either containing only strings or containing \"\n-            \"only objects of type Series/Index/list-like/np.ndarray)\"\n-        )\n-\n         # Generally speaking, all objects without an index inherit the index\n         # `idx` of the calling Series/Index - i.e. must have matching length.\n-        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n-        # index, *unless* ignore_index is set to True.\n+        # Objects with an index (i.e. Series/Index/DataFrame) keep their own.\n         if isinstance(others, ABCSeries):\n-            warn = not others.index.equals(idx)\n-            # only reconstruct Series when absolutely necessary\n-            los = [\n-                Series(others.values, index=idx) if ignore_index and warn else others\n-            ]\n-            return (los, warn)\n+            return [others]\n         elif isinstance(others, ABCIndexClass):\n-            warn = not others.equals(idx)\n-            los = [Series(others.values, index=(idx if ignore_index else others))]\n-            return (los, warn)\n-        elif isinstance(others, DataFrame):\n-            warn = not others.index.equals(idx)\n-            if ignore_index and warn:\n-                # without copy, this could change \"others\"\n-                # that was passed to str.cat\n-                others = others.copy()\n-                others.index = idx\n-            return ([others[x] for x in others], warn)\n+            return [Series(others.values, index=others)]\n+        elif isinstance(others, ABCDataFrame):\n+            return [others[x] for x in others]\n         elif isinstance(others, np.ndarray) and others.ndim == 2:\n             others = DataFrame(others, index=idx)\n-            return ([others[x] for x in others], False)\n+            return [others[x] for x in others]\n         elif is_list_like(others, allow_sets=False):\n             others = list(others)  # ensure iterators do not get read twice etc\n \n             # in case of list-like `others`, all elements must be\n-            # either one-dimensional list-likes or scalars\n-            if all(is_list_like(x, allow_sets=False) for x in others):\n+            # either Series/Index/np.ndarray (1-dim)...\n+            if all(\n+                isinstance(x, (ABCSeries, ABCIndexClass))\n+                or (isinstance(x, np.ndarray) and x.ndim == 1)\n+                for x in others\n+            ):\n                 los = []\n-                join_warn = False\n-                depr_warn = False\n-                # iterate through list and append list of series for each\n-                # element (which we check to be one-dimensional and non-nested)\n-                while others:\n-                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n-\n-                    # GH 21950 - DeprecationWarning\n-                    # only allowing Series/Index/np.ndarray[1-dim] will greatly\n-                    # simply this function post-deprecation.\n-                    if not (\n-                        isinstance(nxt, (Series, ABCIndexClass))\n-                        or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n-                    ):\n-                        depr_warn = True\n-\n-                    if not isinstance(\n-                        nxt, (DataFrame, Series, ABCIndexClass, np.ndarray)\n-                    ):\n-                        # safety for non-persistent list-likes (e.g. iterators)\n-                        # do not map indexed/typed objects; info needed below\n-                        nxt = list(nxt)\n-\n-                    # known types for which we can avoid deep inspection\n-                    no_deep = (\n-                        isinstance(nxt, np.ndarray) and nxt.ndim == 1\n-                    ) or isinstance(nxt, (Series, ABCIndexClass))\n-                    # nested list-likes are forbidden:\n-                    # -> elements of nxt must not be list-like\n-                    is_legal = (no_deep and nxt.dtype == object) or all(\n-                        not is_list_like(x) for x in nxt\n-                    )\n-\n-                    # DataFrame is false positive of is_legal\n-                    # because \"x in df\" returns column names\n-                    if not is_legal or isinstance(nxt, DataFrame):\n-                        raise TypeError(err_msg)\n-\n-                    nxt, wnx = self._get_series_list(nxt, ignore_index=ignore_index)\n-                    los = los + nxt\n-                    join_warn = join_warn or wnx\n-\n-                if depr_warn:\n-                    warnings.warn(\n-                        \"list-likes other than Series, Index, or \"\n-                        \"np.ndarray WITHIN another list-like are \"\n-                        \"deprecated and will be removed in a future \"\n-                        \"version.\",\n-                        FutureWarning,\n-                        stacklevel=4,\n-                    )\n-                return (los, join_warn)\n+                while others:  # iterate through list and append each element\n+                    los = los + self._get_series_list(others.pop(0))\n+                return los\n+            # ... or just strings\n             elif all(not is_list_like(x) for x in others):\n-                return ([Series(others, index=idx)], False)\n-        raise TypeError(err_msg)\n+                return [Series(others, index=idx)]\n+        raise TypeError(\n+            \"others must be Series, Index, DataFrame, np.ndarrary \"\n+            \"or list-like (either containing only strings or \"\n+            \"containing only objects of type Series/Index/\"\n+            \"np.ndarray[1-dim])\"\n+        )\n \n     @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n-    def cat(self, others=None, sep=None, na_rep=None, join=None):\n+    def cat(self, others=None, sep=None, na_rep=None, join=\"left\"):\n         \"\"\"\n         Concatenate strings in the Series/Index with given separator.\n \n@@ -2218,16 +2157,15 @@ class StringMethods(NoNewAttributesMixin):\n             - If `na_rep` is None, and `others` is not None, a row containing a\n               missing value in any of the columns (before concatenation) will\n               have a missing value in the result.\n-        join : {'left', 'right', 'outer', 'inner'}, default None\n+        join : {'left', 'right', 'outer', 'inner'}, default 'left'\n             Determines the join-style between the calling Series/Index and any\n             Series/Index/DataFrame in `others` (objects without an index need\n-            to match the length of the calling Series/Index). If None,\n-            alignment is disabled, but this option will be removed in a future\n-            version of pandas and replaced with a default of `'left'`. To\n-            disable alignment, use `.values` on any Series/Index/DataFrame in\n-            `others`.\n+            to match the length of the calling Series/Index). To disable\n+            alignment, use `.values` on any Series/Index/DataFrame in `others`.\n \n             .. versionadded:: 0.23.0\n+            .. versionchanged:: 1.0.0\n+                Changed default of `join` from None to `'left'`.\n \n         Returns\n         -------\n@@ -2343,39 +2281,14 @@ class StringMethods(NoNewAttributesMixin):\n \n         try:\n             # turn anything in \"others\" into lists of Series\n-            others, warn = self._get_series_list(others, ignore_index=(join is None))\n+            others = self._get_series_list(others)\n         except ValueError:  # do not catch TypeError raised by _get_series_list\n-            if join is None:\n-                raise ValueError(\n-                    \"All arrays must be same length, except \"\n-                    \"those having an index if `join` is not None\"\n-                )\n-            else:\n-                raise ValueError(\n-                    \"If `others` contains arrays or lists (or \"\n-                    \"other list-likes without an index), these \"\n-                    \"must all be of the same length as the \"\n-                    \"calling Series/Index.\"\n-                )\n-\n-        if join is None and warn:\n-            warnings.warn(\n-                \"A future version of pandas will perform index \"\n-                \"alignment when `others` is a Series/Index/\"\n-                \"DataFrame (or a list-like containing one). To \"\n-                \"disable alignment (the behavior before v.0.23) and \"\n-                \"silence this warning, use `.values` on any Series/\"\n-                \"Index/DataFrame in `others`. To enable alignment \"\n-                \"and silence this warning, pass `join='left'|\"\n-                \"'outer'|'inner'|'right'`. The future default will \"\n-                \"be `join='left'`.\",\n-                FutureWarning,\n-                stacklevel=3,\n+            raise ValueError(\n+                \"If `others` contains arrays or lists (or other \"\n+                \"list-likes without an index), these must all be \"\n+                \"of the same length as the calling Series/Index.\"\n             )\n \n-        # if join is None, _get_series_list already force-aligned indexes\n-        join = \"left\" if join is None else join\n-\n         # align if required\n         if any(not data.index.equals(x.index) for x in others):\n             # Need to add keys for uniqueness in case of duplicate columns\n",
          "files_name_in_blame_commit": [
            "strings.py",
            "test_strings.py"
          ]
        }
      },
      "ed487653bc98f9e8b98e4e1175c49678ad68fa9f": {
        "commit": {
          "commit_id": "ed487653bc98f9e8b98e4e1175c49678ad68fa9f",
          "commit_message": "CLN: avoid runtime imports (#27461)",
          "commit_author": "jbrockmendel",
          "commit_date": "2019-07-22 07:52:31",
          "commit_parent": "88ccb25e74c5e88bc393fa15790d341574f2bff8"
        },
        "function": {
          "function_name": "_get_series_list",
          "function_code_before": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Index, Series, DataFrame\n    idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarray or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, Series):\n        warn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and warn else others]\n        return (los, warn)\n    elif isinstance(others, Index):\n        warn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, warn)\n    elif isinstance(others, DataFrame):\n        warn = not others.index.equals(idx)\n        if ignore_index and warn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], warn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((is_list_like(x, allow_sets=False) for x in others)):\n            los = []\n            join_warn = False\n            depr_warn = False\n            while others:\n                nxt = others.pop(0)\n                if not (isinstance(nxt, (Series, Index)) or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)):\n                    depr_warn = True\n                if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, Index))\n                is_legal = no_deep and nxt.dtype == object or all((not is_list_like(x) for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, wnx) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                join_warn = join_warn or wnx\n            if depr_warn:\n                warnings.warn('list-likes other than Series, Index, or np.ndarray WITHIN another list-like are deprecated and will be removed in a future version.', FutureWarning, stacklevel=4)\n            return (los, join_warn)\n        elif all((not is_list_like(x) for x in others)):\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_code_after": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Series, DataFrame\n    idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarray or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, ABCSeries):\n        warn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and warn else others]\n        return (los, warn)\n    elif isinstance(others, ABCIndexClass):\n        warn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, warn)\n    elif isinstance(others, DataFrame):\n        warn = not others.index.equals(idx)\n        if ignore_index and warn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], warn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((is_list_like(x, allow_sets=False) for x in others)):\n            los = []\n            join_warn = False\n            depr_warn = False\n            while others:\n                nxt = others.pop(0)\n                if not (isinstance(nxt, (Series, ABCIndexClass)) or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)):\n                    depr_warn = True\n                if not isinstance(nxt, (DataFrame, Series, ABCIndexClass, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, ABCIndexClass))\n                is_legal = no_deep and nxt.dtype == object or all((not is_list_like(x) for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, wnx) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                join_warn = join_warn or wnx\n            if depr_warn:\n                warnings.warn('list-likes other than Series, Index, or np.ndarray WITHIN another list-like are deprecated and will be removed in a future version.', FutureWarning, stacklevel=4)\n            return (los, join_warn)\n        elif all((not is_list_like(x) for x in others)):\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_before_start_line": 2063,
          "function_before_end_line": 2181,
          "function_after_start_line": 2063,
          "function_after_end_line": 2183,
          "function_before_token_count": 493,
          "function_after_token_count": 491,
          "functions_name_modified_file": [
            "str_endswith",
            "rsplit",
            "str_encode",
            "str_get",
            "translate",
            "lstrip",
            "str_pad",
            "_make_accessor",
            "str_count",
            "forbid_nonstring_types",
            "str_rsplit",
            "rjust",
            "rindex",
            "str_slice",
            "str_slice_replace",
            "__getitem__",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "get_dummies",
            "contains",
            "match",
            "wrap",
            "str_extract",
            "str_translate",
            "_noarg_wrapper",
            "partition",
            "_na_map",
            "cat_core",
            "_validate",
            "zfill",
            "_groups_or_na_fun",
            "str_replace",
            "str_join",
            "str_decode",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "normalize",
            "str_find",
            "_map",
            "slice_replace",
            "rpartition",
            "decode",
            "ljust",
            "encode",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "center",
            "find",
            "str_repeat",
            "__iter__",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "get",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "str_split",
            "_get_series_list",
            "join",
            "str_wrap",
            "cat_safe",
            "str_match",
            "cat"
          ],
          "functions_name_all_files": [
            "get_callable_name",
            "get_dtype_kinds",
            "map",
            "check_for_ordered",
            "freq",
            "set_use_bottleneck",
            "register_extension_dtype",
            "_make_accessor",
            "_onOffset",
            "str_count",
            "_maybe_process_deprecations",
            "_is_homogeneous_type",
            "stack",
            "ordered",
            "_from_values_or_dtype",
            "_addsub_int_array",
            "asarray_tuplesafe",
            "_sub_period",
            "_box_func",
            "_delegate_property_set",
            "_format_native_types",
            "unique",
            "_maybe_coerce_indexer",
            "_pat_wrapper",
            "_get_binner",
            "describe",
            "mid",
            "extractall",
            "shape",
            "checked_add_with_arr",
            "_get_cython_type_upcast",
            "unit",
            "_adjust_binner_for_upsample",
            "drop_duplicates",
            "_simple_new",
            "construct_array_type",
            "diff",
            "dict_keys_to_ordered_list",
            "maybe_convert_platform_interval",
            "_update_inplace",
            "take_nd",
            "maybe_infer_freq",
            "_get_period_range_edges",
            "_delegate_method",
            "size",
            "_noarg_wrapper",
            "remove_na_arraylike",
            "_map_values",
            "nanmean",
            "argsort",
            "__contains__",
            "_scalar_type",
            "length",
            "_left_join_on_index",
            "nunique",
            "_prev_opening_time",
            "partition",
            "cbday_roll",
            "_factorize_from_iterables",
            "_create_unary_method",
            "_get_suffix_prefix",
            "nanpercentile",
            "validate_endpoints",
            "_is_numeric",
            "_isna_compat",
            "to_coo",
            "__getstate__",
            "zfill",
            "array_equivalent",
            "_get_closing_time",
            "maybe_make_list",
            "_ensure_localized",
            "_get_offset_day",
            "make_axis_dummies",
            "ravel",
            "_set_binner",
            "_concat_index_asobject",
            "standardize_mapping",
            "make_nancomp",
            "_repr_categories_info",
            "update_dtype",
            "random_state",
            "validate_ordered",
            "str_strip",
            "inferred_freq",
            "_assure_grouper",
            "load_newobj",
            "value_counts",
            "_get_join_info",
            "_apply_index_days",
            "_isna_ndarraylike_old",
            "_zero_out_fperr",
            "__array__",
            "_should_fill",
            "_get_codes_for_values",
            "_factorize_array",
            "sem",
            "_get_business_hours_by_sec",
            "_get_hashtable_algo",
            "duplicated",
            "_from_fastpath",
            "__call__",
            "_time_shift",
            "ceil",
            "is_bool_indexer",
            "nansem",
            "_validate_specification",
            "_is_monotonic_increasing",
            "right",
            "pad",
            "_add_timedeltalike_scalar",
            "_cat_compare_op",
            "extract",
            "rfind",
            "_maybe_null_out",
            "left",
            "_values_for_rank",
            "is_dtype",
            "str_repeat",
            "coerce_to_array",
            "_tidy_repr",
            "_add_datetimelike_scalar",
            "_get_time_bins",
            "_get_frame_result_type",
            "_hash_categories",
            "argmin",
            "_any_none",
            "get_result",
            "apply_if_callable",
            "put",
            "from_breaks",
            "_ensure_data",
            "repeat",
            "_constructor",
            "_scalar_from_string",
            "ndim",
            "reorder_categories",
            "_set_categories",
            "next_bday",
            "_take_with_fill",
            "_is_na_fill_value",
            "str_split",
            "_get_series_list",
            "tz",
            "year_has_extra_week",
            "_typ",
            "_get_join_keys",
            "cat",
            "view",
            "_add_delta_tdi",
            "_parse_dtype_strict",
            "str_endswith",
            "nancorr",
            "make_sparse",
            "rsplit",
            "_asof_key",
            "str_get",
            "sort_values",
            "_get_single_indexer",
            "load",
            "_get_merge_keys",
            "str_pad",
            "_sub_period_array",
            "load_newobj_ex",
            "nanargmax",
            "array",
            "_attributes",
            "__getattr__",
            "_concat_sparse",
            "_valid_sp_values",
            "_is_builtin_func",
            "str_slice_replace",
            "rank",
            "add_categories",
            "__getitem__",
            "__sub__",
            "reset_cache",
            "str_extractall",
            "npoints",
            "obj",
            "_bn_ok_dtype",
            "match",
            "empty",
            "nanvar",
            "_unstack_multiple",
            "is_null_slice",
            "take_2d_multi",
            "base",
            "_try_aggregate_string_function",
            "get_new_values",
            "_ndarray_values",
            "_resolution",
            "_add_delta",
            "_factorize_keys",
            "type",
            "_is_unique",
            "_na_map",
            "nonzero",
            "merge",
            "_adjust_bin_edges",
            "_isna_new",
            "m_offset",
            "_create_comparison_method",
            "from_arrays",
            "_tick_comp",
            "__str__",
            "is_true_slices",
            "_add_offset",
            "prod",
            "merge_asof",
            "_groups_or_na_fun",
            "closed",
            "_null_fill_value",
            "_parse_subtype",
            "onOffset",
            "apply_index",
            "_maybe_restore_index_levels",
            "_resampler_for_grouping",
            "_get_multiindex_indexer",
            "any",
            "skew",
            "aggregate",
            "from_codes",
            "construct_from_string",
            "__setattr__",
            "normalize",
            "__hash__",
            "strides",
            "_take_nd_object",
            "str_find",
            "nankurt",
            "_make_selectors",
            "__radd__",
            "_concat_datetimetz",
            "_create_arithmetic_method",
            "slice_replace",
            "_get_take_nd_function",
            "_apply_loffset",
            "rollforward",
            "__add__",
            "rpartition",
            "density",
            "_sub_datetimelike_scalar",
            "item",
            "_from_selection",
            "is_valid_dtype_n_method",
            "_unstack_frame",
            "find_class",
            "__repr__",
            "merge_ordered",
            "fillna",
            "_concat_categorical",
            "str_startswith",
            "__iadd__",
            "_slice",
            "__setitem__",
            "nanos",
            "_parse_suffix",
            "_repr_attrs",
            "T",
            "nanskew",
            "_isna_old",
            "from_tuples",
            "_take_without_fill",
            "_from_sequence",
            "nanprod",
            "_reorder_for_extension_array_stack",
            "_ensure_datetimelike_to_i8",
            "_addsub_offset_array",
            "_get_roll",
            "_asof_function",
            "to_dense",
            "__iter__",
            "_maybe_clear_freq",
            "_not_none",
            "_maybe_to_categorical",
            "strip",
            "maybe_iterable_to_list",
            "categorical",
            "_add_comparison_ops",
            "get",
            "safe_cast",
            "_rollback_to_year",
            "values",
            "_use_inf_as_na",
            "_set_dtype",
            "_all_none",
            "_maybe_get_mask",
            "_has_infs",
            "_from_sequence_of_strings",
            "from_coo",
            "_can_hold_na",
            "dropna",
            "maybe_box",
            "nanstd",
            "h",
            "_selection_name",
            "_fill_value_matches",
            "month_roll",
            "kind",
            "_stack_multi_columns",
            "str_encode",
            "na_value_for_dtype",
            "_items_overlap_with_suffix",
            "as_timestamp",
            "_sub_nat",
            "memory_usage",
            "is_monotonic_decreasing",
            "_reconstruct_data",
            "_get_rename_function",
            "g",
            "get_new_index",
            "_get_time_period_bins",
            "subtype",
            "validate_periods",
            "is_non_overlapping_monotonic",
            "forbid_nonstring_types",
            "nbytes",
            "delta",
            "resolution",
            "tolist",
            "_concat_rangeindex_same_dtype",
            "rjust",
            "dtype",
            "rindex",
            "searchsorted",
            "__new__",
            "str_slice",
            "rule_code",
            "_infer_fill_value",
            "sp_values",
            "codes",
            "integer_array",
            "__init__",
            "slice",
            "_delegate_property_get",
            "as_ordered",
            "validate_operand",
            "contains",
            "remove_unused_categories",
            "_restore_dropped_levels_multijoin",
            "asfreq",
            "maybe_box_datetimelike",
            "_hasnans",
            "_pipe",
            "_maybe_fill",
            "str_extract",
            "str_translate",
            "_get_repr",
            "nanmedian",
            "_box_values",
            "_indicator_post_merge",
            "_is_boolean",
            "_na_value",
            "cast_scalar_indexer",
            "std",
            "take",
            "from_spmatrix",
            "get_year_end",
            "_all_not_none",
            "_isna_ndarraylike",
            "numpy_dtype",
            "_get_data_algo",
            "__invert__",
            "_isfinite",
            "_nanpercentile_1d",
            "__len__",
            "_adjust_dates_anchored",
            "_right_outer_join",
            "_na_ok_dtype",
            "__sizeof__",
            "factorize",
            "transform",
            "_reverse_indexer",
            "astype",
            "_get_fill",
            "is_full_slice",
            "str_join",
            "apply_wraps",
            "_get_period_bins",
            "load_reduce",
            "interpolate",
            "count_not_none",
            "var",
            "_convert_to_list_like",
            "get_new_columns",
            "_view_wrapper",
            "_from_categorical_dtype",
            "_get_counts_nanvar",
            "rename_categories",
            "_offset",
            "__array_ufunc__",
            "_ensure_arraylike",
            "_get_resampler_for_grouping",
            "_repr_categories",
            "apply",
            "isna",
            "compute",
            "to_numpy",
            "_factorize_from_iterable",
            "_convert_obj",
            "_selection_list",
            "decode",
            "strftime",
            "_prep_index",
            "encode",
            "_get_join_indexers",
            "_convert_wrapper",
            "set_closed",
            "_sort_labels",
            "_indicator_pre_merge",
            "all",
            "split",
            "f",
            "kurt",
            "_check_compatible_with",
            "_get_series_result_type",
            "generate_range",
            "_upsample",
            "_make_sorted_values_labels",
            "_take_new_index",
            "rstrip",
            "_gotitem",
            "max",
            "center",
            "_unstack_extension_series",
            "register",
            "_any",
            "_convert_datetimelike_to_object",
            "argmax",
            "equals",
            "_is_monotonic_decreasing",
            "_delta_to_tick",
            "_get_val_at",
            "is_unique",
            "index_labels_to_array",
            "_finalize",
            "_concat_same_type",
            "_get_timestamp_range_edges",
            "index",
            "flags",
            "isAnchored",
            "_aggregate_multiple_funcs",
            "is_unsigned_integer",
            "_from_factorized",
            "set_ordered",
            "nanany",
            "_ensure_numeric",
            "get_rule_code_suffix",
            "_nanminmax",
            "try_sort",
            "_first_fill_value_loc",
            "categories",
            "_downsample",
            "overlaps",
            "translate",
            "_recode_for_categories",
            "lstrip",
            "freqstr",
            "sp_index",
            "quantile",
            "_offset_str",
            "is_dtype_equal",
            "to_tuples",
            "_format_space",
            "str_rsplit",
            "_internal_get_values",
            "_na_for_min_count",
            "_round",
            "notna",
            "as_unordered",
            "nsmallest",
            "pipe",
            "validate_categories",
            "_asof_by_function",
            "nearest",
            "nancov",
            "isin",
            "_reset_cache",
            "_aggregate",
            "_get_fill_value",
            "get_dummies",
            "__setstate__",
            "_get_grouper",
            "__rsub__",
            "_isnan",
            "itemsize",
            "_end_apply_index",
            "wrap",
            "_get_binner_for_time",
            "_apply",
            "_get_time_delta_bins",
            "offset",
            "_take_2d_multi_object",
            "_maybe_add_join_keys",
            "_from_name",
            "shift",
            "hasnans",
            "_from_inferred_categories",
            "_freeze",
            "_next_opening_time",
            "median",
            "get_weeks",
            "_any_not_none",
            "_get_resampler",
            "cat_core",
            "_maybe_mask_results",
            "_maybe_mask_result",
            "_validate",
            "_add_nat",
            "_set_codes",
            "_subtype_with_str",
            "consensus_name_attr",
            "_add_unary_ops",
            "_concat_compat",
            "_obj_with_exclusions",
            "_concat_index_same_dtype",
            "_shallow_copy",
            "_values_for_factorize",
            "_prefix",
            "name",
            "str_replace",
            "__isub__",
            "_get_counts",
            "str_decode",
            "is_monotonic",
            "get_corr_func",
            "_get_single_group_name",
            "check",
            "unstack",
            "_str_extract_noexpand",
            "rollback",
            "stack_multiple",
            "_selected_obj",
            "_is_cython_func",
            "_maybe_coerce_merge_keys",
            "cumsum",
            "asi8",
            "remove_categories",
            "__abs__",
            "_map",
            "_sparse_array_op",
            "mode",
            "_get_values",
            "ljust",
            "_values_for_argsort",
            "_validate_fill_value",
            "nansum",
            "_formatter",
            "_get_attributes_dict",
            "__eq__",
            "_groupby_and_merge",
            "str_index",
            "mean",
            "copy",
            "str_findall",
            "_make_index",
            "_maybe_arg_null_out",
            "_repr_footer",
            "_str_extract_frame",
            "_create_join_index",
            "_concatenate_2d",
            "_format_data",
            "_groupby_and_aggregate",
            "sum",
            "find",
            "is_valid_nat_for_dtype",
            "is_signed_integer",
            "resample",
            "validate_inferred_freq",
            "dict_compat",
            "nanall",
            "_concat_datetime",
            "_reduce",
            "_coerce_to_ndarray",
            "set_categories",
            "nanargmin",
            "_wrap_results",
            "_validate_frequency",
            "flatten",
            "backfill",
            "_get_dummies_1d",
            "nlargest",
            "na_value",
            "str_contains",
            "round",
            "data",
            "fill_value",
            "ax",
            "_unbox_scalar",
            "_wrap_result",
            "transpose",
            "str_get_dummies",
            "get_values",
            "_maybe_to_dense",
            "replace",
            "_get_codes",
            "get_resampler_for_grouping",
            "_value_counts_arraylike",
            "union_categoricals",
            "join",
            "floor",
            "min",
            "str_wrap",
            "cat_safe",
            "__ne__",
            "str_match"
          ],
          "functions_name_co_evolved_modified_file": [
            "_str_extract_noexpand",
            "_wrap_result",
            "cat"
          ],
          "functions_name_co_evolved_all_files": [
            "nanskew",
            "_get_multiindex_indexer",
            "diff",
            "_get_period_bins",
            "nanvar",
            "validate_ordered",
            "_get_period_range_edges",
            "_recode_for_categories",
            "_ensure_datetimelike_to_i8",
            "_str_extract_noexpand",
            "size",
            "_get_time_period_bins",
            "value_counts",
            "array",
            "__hash__",
            "isna",
            "_is_boolean",
            "mode",
            "nankurt",
            "_get_values",
            "_from_values_or_dtype",
            "asarray_tuplesafe",
            "take",
            "__add__",
            "_get_codes_for_values",
            "_get_join_indexers",
            "_wrap_result",
            "unique",
            "_is_numeric",
            "__getitem__",
            "duplicated",
            "__init__",
            "_is_na_fill_value",
            "_use_inf_as_na",
            "union_categoricals",
            "get_dummies",
            "_typ",
            "cat"
          ]
        },
        "file": {
          "file_name": "strings.py",
          "file_nloc": 1966,
          "file_complexity": 290,
          "file_token_count": 8017,
          "file_before": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import Dict, List\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nfrom pandas.util._decorators import Appender, deprecate_kwarg\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_integer,\n    is_list_like,\n    is_re,\n    is_scalar,\n    is_string_like,\n)\nfrom pandas.core.dtypes.generic import ABCIndexClass, ABCMultiIndex, ABCSeries\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nimport pandas.core.common as com\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs = dict()  # type: Dict[str, str]\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    \"column {}\".format(dtype)\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the\"\n                \" groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : bool, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set\" \" when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement \" \"pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \" \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, Index\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, Index):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index, columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill :  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = \"fillchar must be a character, not {0}\"\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = \"width must be of integer type, not {0}\"\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    \"Cannot use .str.{name} with values of inferred dtype \"\n                    \"{inf_type!r}.\".format(\n                        name=func_name, inf_type=self._inferred_dtype\n                    )\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(f, name=None, docstring=None, forbidden_types=[\"bytes\"], **kargs):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f, flags=False, na=False, name=None, forbidden_types=[\"bytes\"], **kwargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, \" \"not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # missing values obfuscate type inference -> skip\n        inferred_dtype = lib.infer_dtype(values, skipna=True)\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string \" \"values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self, result, use_codes=True, name=None, expand=None, fill_value=np.nan\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, Index):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, Index):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # Once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Index, Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n\n        err_msg = (\n            \"others must be Series, Index, DataFrame, np.ndarray or \"\n            \"list-like (either containing only strings or containing \"\n            \"only objects of type Series/Index/list-like/np.ndarray)\"\n        )\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n        # index, *unless* ignore_index is set to True.\n        if isinstance(others, Series):\n            warn = not others.index.equals(idx)\n            # only reconstruct Series when absolutely necessary\n            los = [\n                Series(others.values, index=idx) if ignore_index and warn else others\n            ]\n            return (los, warn)\n        elif isinstance(others, Index):\n            warn = not others.equals(idx)\n            los = [Series(others.values, index=(idx if ignore_index else others))]\n            return (los, warn)\n        elif isinstance(others, DataFrame):\n            warn = not others.index.equals(idx)\n            if ignore_index and warn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], warn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either one-dimensional list-likes or scalars\n            if all(is_list_like(x, allow_sets=False) for x in others):\n                los = []\n                join_warn = False\n                depr_warn = False\n                # iterate through list and append list of series for each\n                # element (which we check to be one-dimensional and non-nested)\n                while others:\n                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n\n                    # GH 21950 - DeprecationWarning\n                    # only allowing Series/Index/np.ndarray[1-dim] will greatly\n                    # simply this function post-deprecation.\n                    if not (\n                        isinstance(nxt, (Series, Index))\n                        or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                    ):\n                        depr_warn = True\n\n                    if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n                        # safety for non-persistent list-likes (e.g. iterators)\n                        # do not map indexed/typed objects; info needed below\n                        nxt = list(nxt)\n\n                    # known types for which we can avoid deep inspection\n                    no_deep = (\n                        isinstance(nxt, np.ndarray) and nxt.ndim == 1\n                    ) or isinstance(nxt, (Series, Index))\n                    # nested list-likes are forbidden:\n                    # -> elements of nxt must not be list-like\n                    is_legal = (no_deep and nxt.dtype == object) or all(\n                        not is_list_like(x) for x in nxt\n                    )\n\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, wnx = self._get_series_list(nxt, ignore_index=ignore_index)\n                    los = los + nxt\n                    join_warn = join_warn or wnx\n\n                if depr_warn:\n                    warnings.warn(\n                        \"list-likes other than Series, Index, or \"\n                        \"np.ndarray WITHIN another list-like are \"\n                        \"deprecated and will be removed in a future \"\n                        \"version.\",\n                        FutureWarning,\n                        stacklevel=4,\n                    )\n                return (los, join_warn)\n            elif all(not is_list_like(x) for x in others):\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, Index):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, warn = self._get_series_list(others, ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError(\n                    \"All arrays must be same length, except \"\n                    \"those having an index if `join` is not None\"\n                )\n            else:\n                raise ValueError(\n                    \"If `others` contains arrays or lists (or \"\n                    \"other list-likes without an index), these \"\n                    \"must all be of the same length as the \"\n                    \"calling Series/Index.\"\n                )\n\n        if join is None and warn:\n            warnings.warn(\n                \"A future version of pandas will perform index \"\n                \"alignment when `others` is a Series/Index/\"\n                \"DataFrame (or a list-like containing one). To \"\n                \"disable alignment (the behavior before v.0.23) and \"\n                \"silence this warning, use `.values` on any Series/\"\n                \"Index/DataFrame in `others`. To enable alignment \"\n                \"and silence this warning, pass `join='left'|\"\n                \"'outer'|'inner'|'right'`. The future default will \"\n                \"be `join='left'`.\",\n                FutureWarning,\n                stacklevel=3,\n            )\n\n        # if join is None, _get_series_list already force-aligned indexes\n        join = \"left\" if join is None else join\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, Index):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            result = Series(\n                result, dtype=object, index=data.index, name=self._orig.name\n            )\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    pat : str, default whitespace\n        .. deprecated:: 0.24.0\n           Use ``sep`` instead\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of \" \"`sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of \" \"`sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result, use_codes=(not self._is_categorical), name=name, expand=True\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\")\n    startswith = _pat_wrapper(str_startswith, na=True, name=\"startswith\")\n    endswith = _pat_wrapper(str_endswith, na=True, name=\"endswith\")\n    findall = _pat_wrapper(str_findall, flags=True, name=\"findall\")\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len, docstring=_shared_docs[\"len\"], forbidden_types=None, dtype=int\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args = {}  # type: Dict[str, Dict[str, str]]\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_after": "import codecs\nfrom functools import wraps\nimport re\nimport textwrap\nfrom typing import Dict, List\nimport warnings\n\nimport numpy as np\n\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nfrom pandas.util._decorators import Appender, deprecate_kwarg\n\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_integer,\n    is_list_like,\n    is_re,\n    is_scalar,\n    is_string_like,\n)\nfrom pandas.core.dtypes.generic import ABCIndexClass, ABCMultiIndex, ABCSeries\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas.core.algorithms import take_1d\nfrom pandas.core.base import NoNewAttributesMixin\nimport pandas.core.common as com\n\n_cpython_optimized_encoders = (\n    \"utf-8\",\n    \"utf8\",\n    \"latin-1\",\n    \"latin1\",\n    \"iso-8859-1\",\n    \"mbcs\",\n    \"ascii\",\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\"utf-16\", \"utf-32\")\n\n_shared_docs = dict()  # type: Dict[str, str]\n\n\ndef cat_core(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef cat_safe(list_of_columns: List, sep: str):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`.\n\n    Same signature as cat_core, but handles TypeErrors in concatenation, which\n    happen if the arrays in list_of columns have the wrong dtypes or content.\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    try:\n        result = cat_core(list_of_columns, sep)\n    except TypeError:\n        # if there are any non-string values (wrong dtype or hidden behind\n        # object dtype), np.sum will fail; catch and return with better message\n        for column in list_of_columns:\n            dtype = lib.infer_dtype(column, skipna=True)\n            if dtype not in [\"string\", \"empty\"]:\n                raise TypeError(\n                    \"Concatenation requires list-likes containing only \"\n                    \"strings (or missing values). Offending values found in \"\n                    \"column {}\".format(dtype)\n                ) from None\n    return result\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            p_err = (\n                r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n                r\"(?(3)required )positional arguments?\"\n            )\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the calling object containing the integer counts.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : Analogous, but stricter, relying on re.match instead of re.search.\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\n                \"This pattern has match groups. To actually get the\"\n                \" groups, use str.extract.\",\n                UserWarning,\n                stacklevel=3,\n            )\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : str or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : str or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start.\n    case : bool, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : bool, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> import re\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\n                    \"case and flags cannot be set\" \" when pat is a compiled regex\"\n                )\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\n                \"Cannot use a compiled regex as replacement \" \"pattern with regex=False\"\n            )\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \" \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n    dtype: object\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    dtype: object\n    \"\"\"\n    if is_scalar(repeats):\n\n        def scalar_rep(x):\n            try:\n                return bytes.__mul__(x, repeats)\n            except TypeError:\n                return str.__mul__(x, repeats)\n\n        return _na_map(scalar_rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return bytes.__mul__(x, r)\n            except TypeError:\n                return str.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : Analogous, but less strict, relying on re.search instead of\n        re.match.\n    extract : Extract matched groups.\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, str):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, ABCIndexClass):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object,\n            )\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object,\n    )\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : Returns all matches (not just the first match).\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : Returns first match only (not all matches).\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndexClass):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.items():\n        if isinstance(subject, str):\n\n            if not is_mi:\n                subject_key = (subject_key,)\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, str):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i,))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n\n    index = MultiIndex.from_tuples(index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index, columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep=\"|\"):\n    \"\"\"\n    Split each string in the Series by sep and return a DataFrame\n    of dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : str, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    DataFrame\n        Dummy variables corresponding to values of the Series.\n\n    See Also\n    --------\n    get_dummies : Convert categorical variable into dummy/indicator\n        variables.\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n    \"\"\"\n    arr = arr.fillna(\"\")\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    ------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : str\n        Pattern or regular expression.\n    flags : int, default 0\n        Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which\n        means no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side=\"left\"):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched.\n    start : int\n        Left edge index.\n    end : int\n        Right edge index.\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``.\n\n    Returns\n    -------\n    Series or Index\n        Indexes where substring is found.\n    \"\"\"\n\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"find\"\n    elif side == \"right\":\n        method = \"rfind\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side=\"left\"):\n    if not isinstance(sub, str):\n        msg = \"expected a string object, not {0}\"\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == \"left\":\n        method = \"index\"\n    elif side == \"right\":\n        method = \"rindex\"\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side=\"left\", fillchar=\" \"):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust : Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust : Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center : Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill :  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, str):\n        msg = \"fillchar must be a character, not {0}\"\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError(\"fillchar must be a character, not str\")\n\n    if not is_integer(width):\n        msg = \"width must be of integer type, not {0}\"\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == \"left\":\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == \"right\":\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == \"both\":\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = \"\"\n\n    def f(x):\n        if x[start:stop] == \"\":\n            local_stop = start\n        else:\n            local_stop = stop\n        y = \"\"\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side=\"both\"):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if side == \"both\":\n        f = lambda x: x.strip(to_strip)\n    elif side == \"left\":\n        f = lambda x: x.lstrip(to_strip)\n    elif side == \"right\":\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError(\"Invalid side\")\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line width.\n    expand_tabs : bool, optional\n        If True, tab characters will be expanded to spaces (default: True).\n    replace_whitespace : bool, optional\n        If True, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True).\n    drop_whitespace : bool, optional\n        If True, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True).\n    break_long_words : bool, optional\n        If True, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width (default: True).\n    break_on_hyphens : bool, optional\n        If True, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words (default: True).\n\n    Returns\n    -------\n    Series or Index\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    dtype: object\n    \"\"\"\n    kwargs[\"width\"] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: \"\\n\".join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`.\n\n    Parameters\n    ----------\n    table : dict\n        table is a mapping of Unicode ordinals to Unicode ordinals, strings, or\n        None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    return _na_map(lambda x: x.translate(table), arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    Series or Index\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n    ...               (1, 2, 3),\n    ...               [\"a\", \"b\", \"c\"],\n    ...               123,\n    ...               -456,\n    ...               {1: \"Hello\", \"2\": \"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    None\n    dtype: object\n    \"\"\"\n\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    Series or Index\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef forbid_nonstring_types(forbidden, name=None):\n    \"\"\"\n    Decorator to forbid specific types for a method of StringMethods.\n\n    For calling `.str.{method}` on a Series or Index, it is necessary to first\n    initialize the :class:`StringMethods` object, and then call the method.\n    However, different methods allow different input types, and so this can not\n    be checked during :meth:`StringMethods.__init__`, but must be done on a\n    per-method basis. This decorator exists to facilitate this process, and\n    make it explicit which (inferred) types are disallowed by the method.\n\n    :meth:`StringMethods.__init__` allows the *union* of types its different\n    methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),\n    namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\n    The default string types ['string', 'empty'] are allowed for all methods.\n    For the additional types ['bytes', 'mixed', 'mixed-integer'], each method\n    then needs to forbid the types it is not intended for.\n\n    Parameters\n    ----------\n    forbidden : list-of-str or None\n        List of forbidden non-string types, may be one or more of\n        `['bytes', 'mixed', 'mixed-integer']`.\n    name : str, default None\n        Name of the method to use in the error message. By default, this is\n        None, in which case the name from the method being wrapped will be\n        copied. However, for working with further wrappers (like _pat_wrapper\n        and _noarg_wrapper), it is necessary to specify the name.\n\n    Returns\n    -------\n    func : wrapper\n        The method to which the decorator is applied, with an added check that\n        enforces the inferred type to not be in the list of forbidden types.\n\n    Raises\n    ------\n    TypeError\n        If the inferred type of the underlying data is in `forbidden`.\n    \"\"\"\n\n    # deal with None\n    forbidden = [] if forbidden is None else forbidden\n\n    allowed_types = {\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"} - set(\n        forbidden\n    )\n\n    def _forbid_nonstring_types(func):\n        func_name = func.__name__ if name is None else name\n\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._inferred_dtype not in allowed_types:\n                msg = (\n                    \"Cannot use .str.{name} with values of inferred dtype \"\n                    \"{inf_type!r}.\".format(\n                        name=func_name, inf_type=self._inferred_dtype\n                    )\n                )\n                raise TypeError(msg)\n            return func(self, *args, **kwargs)\n\n        wrapper.__name__ = func_name\n        return wrapper\n\n    return _forbid_nonstring_types\n\n\ndef _noarg_wrapper(f, name=None, docstring=None, forbidden_types=[\"bytes\"], **kargs):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError(\"Provide docstring\")\n\n    return wrapper\n\n\ndef _pat_wrapper(\n    f, flags=False, na=False, name=None, forbidden_types=[\"bytes\"], **kwargs\n):\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types(forbidden_types, name=name)\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__ if name is None else name\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._inferred_dtype = self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        \"\"\"\n        Auxiliary function for StringMethods, infers and checks dtype of data.\n\n        This is a \"first line of defence\" at the creation of the StringMethods-\n        object (see _make_accessor), and just checks that the dtype is in the\n        *union* of the allowed types over all string methods below; this\n        restriction is then refined on a per-method basis using the decorator\n        @forbid_nonstring_types (more info in the corresponding docstring).\n\n        This really should exclude all series/index with any non-string values,\n        but that isn't practical for performance reasons until we have a str\n        dtype (GH 9343 / 13877)\n\n        Parameters\n        ----------\n        data : The content of the Series\n\n        Returns\n        -------\n        dtype : inferred dtype of data\n        \"\"\"\n        if isinstance(data, ABCMultiIndex):\n            raise AttributeError(\n                \"Can only use .str accessor with Index, \" \"not MultiIndex\"\n            )\n\n        # see _libs/lib.pyx for list of inferred types\n        allowed_types = [\"string\", \"empty\", \"bytes\", \"mixed\", \"mixed-integer\"]\n\n        values = getattr(data, \"values\", data)  # Series / Index\n        values = getattr(values, \"categories\", values)  # categorical / normal\n\n        # missing values obfuscate type inference -> skip\n        inferred_dtype = lib.infer_dtype(values, skipna=True)\n\n        if inferred_dtype not in allowed_types:\n            raise AttributeError(\"Can only use .str accessor with string \" \"values!\")\n        return inferred_dtype\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(\n        self, result, use_codes=True, name=None, expand=None, fill_value=np.nan\n    ):\n\n        from pandas import Index, Series, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            # if self._orig is a CategoricalIndex, there is no .cat-accessor\n            result = take_1d(\n                result, Series(self._orig, copy=False).cat.codes, fill_value=fill_value\n            )\n\n        if not hasattr(result, \"ndim\") or not hasattr(result, \"dtype\"):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = result.ndim != 1\n\n        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [\n                    x * max_len if len(x) == 0 or x[0] is np.nan else x for x in result\n                ]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, \"name\", None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, ABCIndexClass):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # Once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n\n        err_msg = (\n            \"others must be Series, Index, DataFrame, np.ndarray or \"\n            \"list-like (either containing only strings or containing \"\n            \"only objects of type Series/Index/list-like/np.ndarray)\"\n        )\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n        # index, *unless* ignore_index is set to True.\n        if isinstance(others, ABCSeries):\n            warn = not others.index.equals(idx)\n            # only reconstruct Series when absolutely necessary\n            los = [\n                Series(others.values, index=idx) if ignore_index and warn else others\n            ]\n            return (los, warn)\n        elif isinstance(others, ABCIndexClass):\n            warn = not others.equals(idx)\n            los = [Series(others.values, index=(idx if ignore_index else others))]\n            return (los, warn)\n        elif isinstance(others, DataFrame):\n            warn = not others.index.equals(idx)\n            if ignore_index and warn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], warn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either one-dimensional list-likes or scalars\n            if all(is_list_like(x, allow_sets=False) for x in others):\n                los = []\n                join_warn = False\n                depr_warn = False\n                # iterate through list and append list of series for each\n                # element (which we check to be one-dimensional and non-nested)\n                while others:\n                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n\n                    # GH 21950 - DeprecationWarning\n                    # only allowing Series/Index/np.ndarray[1-dim] will greatly\n                    # simply this function post-deprecation.\n                    if not (\n                        isinstance(nxt, (Series, ABCIndexClass))\n                        or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                    ):\n                        depr_warn = True\n\n                    if not isinstance(\n                        nxt, (DataFrame, Series, ABCIndexClass, np.ndarray)\n                    ):\n                        # safety for non-persistent list-likes (e.g. iterators)\n                        # do not map indexed/typed objects; info needed below\n                        nxt = list(nxt)\n\n                    # known types for which we can avoid deep inspection\n                    no_deep = (\n                        isinstance(nxt, np.ndarray) and nxt.ndim == 1\n                    ) or isinstance(nxt, (Series, ABCIndexClass))\n                    # nested list-likes are forbidden:\n                    # -> elements of nxt must not be list-like\n                    is_legal = (no_deep and nxt.dtype == object) or all(\n                        not is_list_like(x) for x in nxt\n                    )\n\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, wnx = self._get_series_list(nxt, ignore_index=ignore_index)\n                    los = los + nxt\n                    join_warn = join_warn or wnx\n\n                if depr_warn:\n                    warnings.warn(\n                        \"list-likes other than Series, Index, or \"\n                        \"np.ndarray WITHIN another list-like are \"\n                        \"deprecated and will be removed in a future \"\n                        \"version.\",\n                        FutureWarning,\n                        stacklevel=4,\n                    )\n                return (los, join_warn)\n            elif all(not is_list_like(x) for x in others):\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    @forbid_nonstring_types([\"bytes\", \"mixed\", \"mixed-integer\"])\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : str, default ''\n            The separator between the different elements/columns. By default\n            the empty string `''` is used.\n        na_rep : str or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        str, Series or Index\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index.\n        join : Join lists contained as elements in the Series/Index.\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, str):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = \"\"\n\n        if isinstance(self._orig, ABCIndexClass):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, warn = self._get_series_list(others, ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError(\n                    \"All arrays must be same length, except \"\n                    \"those having an index if `join` is not None\"\n                )\n            else:\n                raise ValueError(\n                    \"If `others` contains arrays or lists (or \"\n                    \"other list-likes without an index), these \"\n                    \"must all be of the same length as the \"\n                    \"calling Series/Index.\"\n                )\n\n        if join is None and warn:\n            warnings.warn(\n                \"A future version of pandas will perform index \"\n                \"alignment when `others` is a Series/Index/\"\n                \"DataFrame (or a list-like containing one). To \"\n                \"disable alignment (the behavior before v.0.23) and \"\n                \"silence this warning, use `.values` on any Series/\"\n                \"Index/DataFrame in `others`. To enable alignment \"\n                \"and silence this warning, pass `join='left'|\"\n                \"'outer'|'inner'|'right'`. The future default will \"\n                \"be `join='left'`.\",\n                FutureWarning,\n                stacklevel=3,\n            )\n\n        # if join is None, _get_series_list already force-aligned indexes\n        join = \"left\" if join is None else join\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(\n                others,\n                axis=1,\n                join=(join if join == \"inner\" else \"outer\"),\n                keys=range(len(others)),\n                sort=False,\n                copy=False,\n            )\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_safe([x[not_masked] for x in all_cols], sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [\n                np.where(nm, na_rep, col) for nm, col in zip(na_masks, all_cols)\n            ]\n            result = cat_safe(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_safe(all_cols, sep)\n\n        if isinstance(self._orig, ABCIndexClass):\n            # add dtype for case that result is all-NA\n            result = Index(result, dtype=object, name=self._orig.name)\n        else:  # Series\n            result = Series(\n                result, dtype=object, index=data.index, name=self._orig.name\n            )\n        return result\n\n    _shared_docs[\n        \"str_split\"\n    ] = r\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n    Series.str.split : Split strings around given separator/delimiter.\n    Series.str.rsplit : Splits string around given separator/delimiter,\n        starting from the right.\n    Series.str.join : Join lists contained as elements in the Series/Index\n        with passed delimiter.\n    str.split : Standard library version for split.\n    str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    ...                \"https://docs.python.org/3/tutorial/index.html\",\n    ...                np.nan])\n    0                       this is a regular sentence\n    1    https://docs.python.org/3/tutorial/index.html\n    2                                              NaN\n    dtype: object\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n\n    Remember to escape special characters when explicitly using regular\n    expressions.\n\n    >>> s = pd.Series([\"1+1=2\"])\n\n    >>> s.str.split(r\"\\+|=\", expand=True)\n         0    1    2\n    0    1    1    2\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"beginning\", \"method\": \"split\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs[\"str_split\"] % {\"side\": \"end\", \"method\": \"rsplit\"})\n    @forbid_nonstring_types([\"bytes\"])\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs[\n        \"str_partition\"\n    ] = \"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    sep : str, default whitespace\n        String to split on.\n    pat : str, default whitespace\n        .. deprecated:: 0.24.0\n           Use ``sep`` instead\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containing tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex([('X', ' ', '123'),\n                ('Y', ' ', '999')],\n               dtype='object')\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"first\",\n            \"return\": \"3 elements containing the string itself, followed by two \"\n            \"empty strings\",\n            \"also\": \"rpartition : Split the string at the last occurrence of \" \"`sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def partition(self, sep=\" \", expand=True):\n        f = lambda x: x.partition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(\n        _shared_docs[\"str_partition\"]\n        % {\n            \"side\": \"last\",\n            \"return\": \"3 elements containing two empty strings, followed by the \"\n            \"string itself\",\n            \"also\": \"partition : Split the string at the first occurrence of \" \"`sep`.\",\n        }\n    )\n    @deprecate_kwarg(old_arg_name=\"pat\", new_arg_name=\"sep\")\n    @forbid_nonstring_types([\"bytes\"])\n    def rpartition(self, sep=\" \", expand=True):\n        f = lambda x: x.rpartition(sep)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    @forbid_nonstring_types([\"bytes\"])\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    @forbid_nonstring_types([\"bytes\"])\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(\n            self._parent, pat, case=case, flags=flags, na=na, regex=regex\n        )\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_match)\n    @forbid_nonstring_types([\"bytes\"])\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result, fill_value=na)\n\n    @copy(str_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(\n            self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex\n        )\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    @forbid_nonstring_types([\"bytes\"])\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    @forbid_nonstring_types([\"bytes\"])\n    def pad(self, width, side=\"left\", fillchar=\" \"):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_pad\"\n    ] = \"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\"\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left and right\", method=\"center\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def center(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"both\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"right\", method=\"ljust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def ljust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"right\", fillchar=fillchar)\n\n    @Appender(_shared_docs[\"str_pad\"] % dict(side=\"left\", method=\"rjust\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rjust(self, width, fillchar=\" \"):\n        return self.pad(width, side=\"left\", fillchar=fillchar)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects\n\n        See Also\n        --------\n        Series.str.rjust : Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust : Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad : Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center : Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side=\"left\", fillchar=\"0\")\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    @forbid_nonstring_types([\"bytes\"])\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        # need to allow bytes here\n        result = str_decode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    @forbid_nonstring_types([\"bytes\"])\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"str_strip\"\n    ] = r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index.\n    Series.str.lstrip : Remove leading characters in Series/Index.\n    Series.str.rstrip : Remove trailing characters in Series/Index.\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"str_strip\"] % dict(side=\"left and right sides\", method=\"strip\")\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"both\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"left side\", method=\"lstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs[\"str_strip\"] % dict(side=\"right side\", method=\"rstrip\"))\n    @forbid_nonstring_types([\"bytes\"])\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side=\"right\")\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    @forbid_nonstring_types([\"bytes\"])\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    @forbid_nonstring_types([\"bytes\"])\n    def get_dummies(self, sep=\"|\"):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(\n            result, use_codes=(not self._is_categorical), name=name, expand=True\n        )\n\n    @copy(str_translate)\n    @forbid_nonstring_types([\"bytes\"])\n    def translate(self, table):\n        result = str_translate(self._parent, table)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True, name=\"count\")\n    startswith = _pat_wrapper(str_startswith, na=True, name=\"startswith\")\n    endswith = _pat_wrapper(str_endswith, na=True, name=\"endswith\")\n    findall = _pat_wrapper(str_findall, flags=True, name=\"findall\")\n\n    @copy(str_extract)\n    @forbid_nonstring_types([\"bytes\"])\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    @forbid_nonstring_types([\"bytes\"])\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs[\n        \"find\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"lowest\",\n            method=\"find\",\n            also=\"rfind : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"find\"]\n        % dict(\n            side=\"highest\",\n            method=\"rfind\",\n            also=\"find : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    @forbid_nonstring_types([\"bytes\"])\n    def normalize(self, form):\n        \"\"\"\n        Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n\n        f = lambda x: unicodedata.normalize(form, x)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"index\"\n    ] = \"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\"\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"lowest\",\n            similar=\"find\",\n            method=\"index\",\n            also=\"rindex : Return highest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"left\")\n        return self._wrap_result(result)\n\n    @Appender(\n        _shared_docs[\"index\"]\n        % dict(\n            side=\"highest\",\n            similar=\"rfind\",\n            method=\"rindex\",\n            also=\"index : Return lowest indexes in each strings.\",\n        )\n    )\n    @forbid_nonstring_types([\"bytes\"])\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub, start=start, end=end, side=\"right\")\n        return self._wrap_result(result)\n\n    _shared_docs[\n        \"len\"\n    ] = \"\"\"\n    Compute the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\"\n    len = _noarg_wrapper(\n        len, docstring=_shared_docs[\"len\"], forbidden_types=None, dtype=int\n    )\n\n    _shared_docs[\n        \"casemethods\"\n    ] = \"\"\"\n    Convert strings in the Series/Index to %(type)s.\n    %(version)s\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n    Series.str.casefold: Removes all case distinctions in the string.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\"\n\n    # _doc_args holds dict of strings to use in substituting casemethod docs\n    _doc_args = {}  # type: Dict[str, Dict[str, str]]\n    _doc_args[\"lower\"] = dict(type=\"lowercase\", method=\"lower\", version=\"\")\n    _doc_args[\"upper\"] = dict(type=\"uppercase\", method=\"upper\", version=\"\")\n    _doc_args[\"title\"] = dict(type=\"titlecase\", method=\"title\", version=\"\")\n    _doc_args[\"capitalize\"] = dict(\n        type=\"be capitalized\", method=\"capitalize\", version=\"\"\n    )\n    _doc_args[\"swapcase\"] = dict(type=\"be swapcased\", method=\"swapcase\", version=\"\")\n    _doc_args[\"casefold\"] = dict(\n        type=\"be casefolded\",\n        method=\"casefold\",\n        version=\"\\n    .. versionadded:: 0.25.0\\n\",\n    )\n    lower = _noarg_wrapper(\n        lambda x: x.lower(),\n        name=\"lower\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"lower\"],\n    )\n    upper = _noarg_wrapper(\n        lambda x: x.upper(),\n        name=\"upper\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"upper\"],\n    )\n    title = _noarg_wrapper(\n        lambda x: x.title(),\n        name=\"title\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"title\"],\n    )\n    capitalize = _noarg_wrapper(\n        lambda x: x.capitalize(),\n        name=\"capitalize\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"capitalize\"],\n    )\n    swapcase = _noarg_wrapper(\n        lambda x: x.swapcase(),\n        name=\"swapcase\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"swapcase\"],\n    )\n    casefold = _noarg_wrapper(\n        lambda x: x.casefold(),\n        name=\"casefold\",\n        docstring=_shared_docs[\"casemethods\"] % _doc_args[\"casefold\"],\n    )\n\n    _shared_docs[\n        \"ismethods\"\n    ] = \"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters separated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    _doc_args[\"isalnum\"] = dict(type=\"alphanumeric\", method=\"isalnum\")\n    _doc_args[\"isalpha\"] = dict(type=\"alphabetic\", method=\"isalpha\")\n    _doc_args[\"isdigit\"] = dict(type=\"digits\", method=\"isdigit\")\n    _doc_args[\"isspace\"] = dict(type=\"whitespace\", method=\"isspace\")\n    _doc_args[\"islower\"] = dict(type=\"lowercase\", method=\"islower\")\n    _doc_args[\"isupper\"] = dict(type=\"uppercase\", method=\"isupper\")\n    _doc_args[\"istitle\"] = dict(type=\"titlecase\", method=\"istitle\")\n    _doc_args[\"isnumeric\"] = dict(type=\"numeric\", method=\"isnumeric\")\n    _doc_args[\"isdecimal\"] = dict(type=\"decimal\", method=\"isdecimal\")\n    isalnum = _noarg_wrapper(\n        lambda x: x.isalnum(),\n        name=\"isalnum\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalnum\"],\n    )\n    isalpha = _noarg_wrapper(\n        lambda x: x.isalpha(),\n        name=\"isalpha\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isalpha\"],\n    )\n    isdigit = _noarg_wrapper(\n        lambda x: x.isdigit(),\n        name=\"isdigit\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdigit\"],\n    )\n    isspace = _noarg_wrapper(\n        lambda x: x.isspace(),\n        name=\"isspace\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isspace\"],\n    )\n    islower = _noarg_wrapper(\n        lambda x: x.islower(),\n        name=\"islower\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"islower\"],\n    )\n    isupper = _noarg_wrapper(\n        lambda x: x.isupper(),\n        name=\"isupper\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isupper\"],\n    )\n    istitle = _noarg_wrapper(\n        lambda x: x.istitle(),\n        name=\"istitle\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"istitle\"],\n    )\n    isnumeric = _noarg_wrapper(\n        lambda x: x.isnumeric(),\n        name=\"isnumeric\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isnumeric\"],\n    )\n    isdecimal = _noarg_wrapper(\n        lambda x: x.isdecimal(),\n        name=\"isdecimal\",\n        docstring=_shared_docs[\"ismethods\"] % _doc_args[\"isdecimal\"],\n    )\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_patch": "@@ -763,7 +763,7 @@ def _str_extract_noexpand(arr, pat, flags=0):\n     Index.\n \n     \"\"\"\n-    from pandas import DataFrame, Index\n+    from pandas import DataFrame\n \n     regex = re.compile(pat, flags=flags)\n     groups_or_na = _groups_or_na_fun(regex)\n@@ -772,7 +772,7 @@ def _str_extract_noexpand(arr, pat, flags=0):\n         result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n         name = _get_single_group_name(regex)\n     else:\n-        if isinstance(arr, Index):\n+        if isinstance(arr, ABCIndexClass):\n             raise ValueError(\"only one regex group is supported with Index\")\n         name = None\n         names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n@@ -2001,7 +2001,7 @@ class StringMethods(NoNewAttributesMixin):\n             # infer from ndim if expand is not specified\n             expand = result.ndim != 1\n \n-        elif expand is True and not isinstance(self._orig, Index):\n+        elif expand is True and not isinstance(self._orig, ABCIndexClass):\n             # required when expand=True is explicitly specified\n             # not needed when inferred\n \n@@ -2034,7 +2034,7 @@ class StringMethods(NoNewAttributesMixin):\n \n         # Wait until we are sure result is a Series or Index before\n         # checking attributes (GH 12180)\n-        if isinstance(self._orig, Index):\n+        if isinstance(self._orig, ABCIndexClass):\n             # if result is a boolean np.array, return the np.array\n             # instead of wrapping it into a boolean Index (GH 8875)\n             if is_bool_dtype(result):\n@@ -2082,10 +2082,10 @@ class StringMethods(NoNewAttributesMixin):\n         # Once str.cat defaults to alignment, this function can be simplified;\n         # will not need `ignore_index` and the second boolean output anymore\n \n-        from pandas import Index, Series, DataFrame\n+        from pandas import Series, DataFrame\n \n         # self._orig is either Series or Index\n-        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n+        idx = self._orig if isinstance(self._orig, ABCIndexClass) else self._orig.index\n \n         err_msg = (\n             \"others must be Series, Index, DataFrame, np.ndarray or \"\n@@ -2097,14 +2097,14 @@ class StringMethods(NoNewAttributesMixin):\n         # `idx` of the calling Series/Index - i.e. must have matching length.\n         # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n         # index, *unless* ignore_index is set to True.\n-        if isinstance(others, Series):\n+        if isinstance(others, ABCSeries):\n             warn = not others.index.equals(idx)\n             # only reconstruct Series when absolutely necessary\n             los = [\n                 Series(others.values, index=idx) if ignore_index and warn else others\n             ]\n             return (los, warn)\n-        elif isinstance(others, Index):\n+        elif isinstance(others, ABCIndexClass):\n             warn = not others.equals(idx)\n             los = [Series(others.values, index=(idx if ignore_index else others))]\n             return (los, warn)\n@@ -2137,12 +2137,14 @@ class StringMethods(NoNewAttributesMixin):\n                     # only allowing Series/Index/np.ndarray[1-dim] will greatly\n                     # simply this function post-deprecation.\n                     if not (\n-                        isinstance(nxt, (Series, Index))\n+                        isinstance(nxt, (Series, ABCIndexClass))\n                         or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                     ):\n                         depr_warn = True\n \n-                    if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n+                    if not isinstance(\n+                        nxt, (DataFrame, Series, ABCIndexClass, np.ndarray)\n+                    ):\n                         # safety for non-persistent list-likes (e.g. iterators)\n                         # do not map indexed/typed objects; info needed below\n                         nxt = list(nxt)\n@@ -2150,7 +2152,7 @@ class StringMethods(NoNewAttributesMixin):\n                     # known types for which we can avoid deep inspection\n                     no_deep = (\n                         isinstance(nxt, np.ndarray) and nxt.ndim == 1\n-                    ) or isinstance(nxt, (Series, Index))\n+                    ) or isinstance(nxt, (Series, ABCIndexClass))\n                     # nested list-likes are forbidden:\n                     # -> elements of nxt must not be list-like\n                     is_legal = (no_deep and nxt.dtype == object) or all(\n@@ -2323,7 +2325,7 @@ class StringMethods(NoNewAttributesMixin):\n         if sep is None:\n             sep = \"\"\n \n-        if isinstance(self._orig, Index):\n+        if isinstance(self._orig, ABCIndexClass):\n             data = Series(self._orig, index=self._orig)\n         else:  # Series\n             data = self._orig\n@@ -2409,7 +2411,7 @@ class StringMethods(NoNewAttributesMixin):\n             # no NaNs - can just concatenate\n             result = cat_safe(all_cols, sep)\n \n-        if isinstance(self._orig, Index):\n+        if isinstance(self._orig, ABCIndexClass):\n             # add dtype for case that result is all-NA\n             result = Index(result, dtype=object, name=self._orig.name)\n         else:  # Series\n",
          "files_name_in_blame_commit": [
            "lib.pyx",
            "merge.py",
            "offsets.py",
            "interval.py",
            "reshape.py",
            "pickle_compat.py",
            "common.py",
            "base.py",
            "array_.py",
            "categorical.py",
            "nanops.py",
            "sparse.py",
            "algorithms.py",
            "missing.py",
            "integer.py",
            "strings.py",
            "numpy_.py",
            "datetimelike.py",
            "concat.py",
            "dtypes.py",
            "resample.py"
          ]
        }
      },
      "bb6135880e5e453d7701764b9f2e4ad3356a68d7": {
        "commit": {
          "commit_id": "bb6135880e5e453d7701764b9f2e4ad3356a68d7",
          "commit_message": "STYLE: Apply black formatting",
          "commit_author": "Joris Van den Bossche",
          "commit_date": "2019-07-03 23:28:23",
          "commit_parent": "4199c98a26ed51674b5d21cba039867640225510"
        },
        "function": {
          "function_name": "_get_series_list",
          "function_code_before": "",
          "function_code_after": "",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": "",
          "function_after_end_line": "",
          "function_before_token_count": 0,
          "function_after_token_count": 0,
          "functions_name_modified_file": [
            "time_cat",
            "time_wrap",
            "time_get_dummies",
            "time_startswith",
            "time_rpartition",
            "time_endswith",
            "time_center",
            "time_contains",
            "time_join",
            "time_pad",
            "time_count",
            "time_translate",
            "time_findall",
            "time_len",
            "time_encode_decode",
            "time_get",
            "time_repeat",
            "time_title",
            "time_vector_slice",
            "time_partition",
            "time_lower",
            "time_replace",
            "time_rsplit",
            "time_split",
            "time_strip",
            "time_upper",
            "time_zfill",
            "time_lstrip",
            "time_rstrip",
            "setup",
            "time_rfind",
            "time_match",
            "time_slice",
            "time_extract",
            "time_find",
            "time_normalize"
          ],
          "functions_name_all_files": [
            "check_funs",
            "test_fifth_week_of_month_infer",
            "check_for_ordered",
            "test_to_records_dict_like",
            "test_truncate_ndots",
            "test_apply_iteration",
            "test_join_on_series_buglet",
            "time_merge_ordered",
            "test_spam_url",
            "test_equality",
            "test_wide_repr_multiindex_cols",
            "test_to_offset_no_evaluate",
            "test_to_latex_format",
            "test_td64arr_mod_int",
            "test_rank_empty_group",
            "test_set_index_pass_arrays",
            "test_inf_na_values_with_int_index",
            "test_pivot_no_values",
            "test_datetime64tz_aware",
            "select",
            "ordered",
            "test_groupby_bool_aggs",
            "test_long_strings",
            "_handle_lowerdim_multi_index_axis0",
            "time_iter",
            "_box_func",
            "test_loc_multiindex_missing_label_raises",
            "test_nbytes_integer",
            "test_merge_on_extension_array",
            "test_upsampling_ohlc",
            "_sqlalchemy_type",
            "_clean_spaces_backtick_quoted_names",
            "test_groupby_multilevel_with_transform",
            "is_nested_tuple",
            "test_dt64arr_add_sub_DateOffsets",
            "period_index",
            "test_datetime64formatter_yearmonth",
            "test_groupby_with_hier_columns",
            "test_same_len_hash_collisions",
            "test_from_coo",
            "in_interactive_session",
            "test_to_json_compression",
            "test_omit_nuisance_python_multiple",
            "test_format_timedelta_ticks_narrow",
            "_transform_should_cast",
            "_build_xpath_expr",
            "test_interp_unlimited",
            "test_usecols_with_parse_dates2",
            "from_range",
            "test_loc_getitem_label_list",
            "drop_duplicates",
            "test_dti_equals_with_tz",
            "test_numpy_type_funcs",
            "test_match",
            "test_set_index_pass_arrays_duplicate",
            "test_is_unique_class_ne",
            "test_split_blank_string",
            "test_multilevel_name_print",
            "_format_datetime64",
            "test_constructor_with_datetimelike",
            "test_first_last_tz_multi_column",
            "test_to_csv_from_csv2",
            "test_constructor_map",
            "test_columns_dtypes",
            "get_calendar",
            "test_set_index_cast",
            "test_comparison_flex_alignment",
            "test_get_indexer_consistency",
            "test_dataframe_constructor_with_dtype",
            "assert_class_equal",
            "_convert_axes",
            "_get_splitter",
            "test_dataframe_dummies_subset",
            "test_name_printing",
            "__next__",
            "is_datetime_or_timedelta_dtype",
            "test_setitem_single_column_mixed_datetime",
            "test_read_with_bad_header",
            "get_sheet_by_index",
            "test_frame_equal_index_mismatch",
            "test_empty_constructor",
            "test_frame_non_unique_index",
            "_infer_types",
            "test_query_with_partially_named_multiindex",
            "test_replace",
            "test_drop_preserve_names",
            "test_rolling_sum",
            "_get_axis_resolvers",
            "test_expanding_corr",
            "test_categorical_conversion",
            "test_round_trip_frame",
            "test_numpy_take",
            "test_to_offset_pd_timedelta",
            "test_date_export_formats",
            "test_read_gbq_without_deprecated_kwargs",
            "test_asarray_datetime64",
            "test_ragged_max",
            "test_iterator2",
            "test_query_with_named_multiindex",
            "test_3",
            "test_failing_subscript_with_name_error",
            "test_assert_almost_equal_dicts",
            "test_union_misc",
            "test_read_with_parse_dates_scalar_non_bool",
            "test_coerce_outside_ns_bounds",
            "test_regex_replace_list_to_scalar",
            "test_td64arr_add_sub_float",
            "test_convert_nested",
            "test_bytes_io",
            "_get_errorbars",
            "_add_series_only_operations",
            "_check_for_default_values",
            "validate_ordered",
            "test_take_allow_fill",
            "test_frame_equal_block_mismatch",
            "test_cmov_window_na_min_periods",
            "test_conversions",
            "test_column_select_via_attr",
            "test_partially_invalid_plot_data",
            "test_str_accessor_no_new_attributes",
            "test_map_with_nan",
            "test_merge_index_singlekey_inner",
            "test_right_outer_join",
            "no_description_period",
            "test_left_outer_join",
            "time_rename_axis0",
            "test_ensure_platform_int",
            "get_series_na",
            "test_parse_dates_implicit_first_col",
            "test_grouper_iter",
            "test_slice_floats",
            "test_partial_setting_mixed_dtype",
            "_f1",
            "sequence_to_dt64ns",
            "test_sum_bool",
            "test_intersection_non_monotonic_non_unique",
            "mixed_int_frame",
            "test_trailing_delimiters",
            "test_lookup_nan",
            "time_index_from_array_string",
            "time_isnull_floats_no_null",
            "test_nan_irregular_index",
            "test_multi_function_flexible_mix",
            "test_frame_to_time_stamp",
            "get_locator",
            "_time_shift",
            "_not_in",
            "multi_line",
            "_generate_marginal_results_without_values",
            "header_style",
            "test_encoding_latin1_118",
            "test_constructor_freq_mult",
            "test_tdi_total_seconds",
            "test_2d_other_dtypes",
            "test_set_index_append_to_multiindex",
            "test_overlaps_interval_container",
            "test_copy_name",
            "test_grouper_getting_correct_binner",
            "test_infer_freq_index",
            "test_repr_obeys_max_seq_limit",
            "from_scalars",
            "_get_axes_layout",
            "_read",
            "test_reindex_level",
            "storable",
            "test_reader_dtype",
            "test_read_map_header",
            "test_series_map_box_timestamps",
            "test_missing_unicode_key",
            "test_at_time_raises",
            "is_dtype",
            "test_excel_sheet_by_name_raise",
            "__divmod__",
            "test_boolean_indexing_mixed",
            "time_days_in_month",
            "by_blocks_fixture",
            "_get_object_parser",
            "test_difference_incomparable_true",
            "test_reindex_dtype",
            "test_missing_right_by",
            "_skew_kurt_wrap",
            "argmin",
            "test_fillna_series_timedelta64",
            "test_interp_limit_bad_direction",
            "test_date_range_int64_overflow_non_recoverable",
            "test_date_range_timestamp_equiv_from_datetime_instance",
            "test_empty_fancy_raises",
            "time_frame_xs",
            "test_group_selection_cache",
            "ensure_categorical",
            "_get_nearest_indexer",
            "_set_categories",
            "test_complex",
            "test_to_records_with_Mapping_type",
            "test_to_string_without_index",
            "test_complex_series_frame_alignment",
            "get_random_path",
            "tsplot",
            "test_tz_localize_roundtrip",
            "string_dtype",
            "_typ",
            "test_pi_sub_isub_pi",
            "test_get_loc_closed",
            "time_parse_iso8601_no_tz",
            "test_dataframe_dummies_drop_first_with_na",
            "_replace_nans",
            "test_default_date_load",
            "clip_lower",
            "time_series_timedeltas",
            "rsplit",
            "test_set_option_multiple",
            "compat_props",
            "test_nearest",
            "test_resample_with_nat",
            "test_value_counts_normalized",
            "test_extractall_no_matches",
            "test_to_string_line_width",
            "test_get_attr",
            "_load_test1_data",
            "test_constructor_bad_file",
            "test_constructor_invalid_dtype_raises",
            "test_excel_roundtrip_datetime",
            "time_rank",
            "pad_1d",
            "time_iteritems_cached",
            "test_arith_ops_df_compat",
            "_get_unique_index",
            "to_feather",
            "test_xs_loc_equality",
            "test_set_value_resize",
            "test_update_from_non_df",
            "pytest_addoption",
            "render_pep440_post",
            "test_replace_multiple",
            "test_binop_typecasting",
            "str_slice_replace",
            "test_getitem_simple",
            "_parse_errorbars",
            "test_apply_multi_index",
            "test_closed_median_quantile",
            "makeCategoricalIndex",
            "test_read_excel_multiindex_header_only",
            "test_to_string_left_justify_cols",
            "test_astype_str_compat",
            "any_numpy_array",
            "test_cmov_window_frame",
            "test_take_bounds",
            "test_downcast_conversion_no_nan",
            "_format_datetime64_dateonly",
            "validate_kwargs",
            "cython_table_items",
            "time_week",
            "test_filter_single_column_df",
            "_verify_integrity",
            "write_index",
            "test_maybe_promote_datetimetz_with_any_numpy_dtype",
            "_assert_insert_conversion",
            "obj",
            "test_concat_bug_3602",
            "test_nat_ops",
            "time_read_excel",
            "test_array_equivalent_compat",
            "test_pct_max_many_rows",
            "test_mixed_index_at_iat_loc_iloc_dataframe",
            "test_invalid_xy_args_dup_cols",
            "test_construction_not_supported",
            "test_after_nearest_workday",
            "test_add_string",
            "test_sort_nat",
            "test_iloc_getitem_array",
            "_get_opstr",
            "test_td64arr_add_td64_array",
            "test_iso_conversion",
            "test_reset_index_name",
            "test_query_scope",
            "test_apply_out_of_range",
            "test_euro_decimal_format",
            "_write_map",
            "test_to_integer_array_error",
            "test_fancy_slice_partial",
            "test_getitem_boolean_empty",
            "time_unique",
            "test_pindex_fieldaccessor_nat",
            "time_to_time",
            "test_line_plot_datetime_frame",
            "test_dti_date",
            "test_new_axis",
            "_get_op_name",
            "test_merge_incompat_infer_boolean_object",
            "time_series_datetimeindex_repr",
            "test_agg_period_index",
            "test_frame_mixedtype_orient",
            "test_cython_with_timestamp_and_nat",
            "test_as_index_series_return_frame",
            "test_join_multi",
            "test_set_levels_categorical",
            "test_downcast_not8bit",
            "_is_multi_agg_with_relabel",
            "test_mean",
            "test_closed_one_entry_groupby",
            "test_hash_scalar",
            "test_dti_tz_localize_nonexistent_raise_coerce",
            "test_na_values_dict_aliasing",
            "test_build_table_schema",
            "test_numpy_array",
            "read_index",
            "notnull",
            "test_set_categories_inplace",
            "zip_html",
            "test_datetime_invalid_datatype",
            "test_where_other",
            "_partial_tup_index",
            "_check_bar_alignment",
            "tz_localize",
            "test_td64arr_floordiv_tdscalar",
            "test_groupby_dtype_inference_empty",
            "from_codes",
            "construct_from_string",
            "test_round_nonunique_categorical",
            "test_warns_non_roundtrippable_names",
            "test_join_append_timedeltas",
            "test_split",
            "get_flattened_iterator",
            "test_to_hdf_with_object_column_names",
            "time_plot_table",
            "test_get_loc_bad_tolerance_raises",
            "test_identical",
            "nankurt",
            "_make_selectors",
            "test_get_filepath_or_buffer_with_buffer",
            "test_repeat",
            "test_fake_qtconsole_repr_html",
            "time_float_int_lines",
            "is_categorical",
            "test_agg_reduce",
            "_apply_loffset",
            "test_df_arith_2d_array_rowlike_broadcasts",
            "test_sub_delta",
            "test_date_range_out_of_bounds",
            "_check_method_works",
            "test_value_counts_bins",
            "_from_selection",
            "test_reindex_positional_warns",
            "test_lines_with_compression",
            "dataframe_with_duplicate_index",
            "is_interval",
            "test_unit_ignore_keeps_name",
            "plus_or_dot",
            "_get_group_keys",
            "test_hash",
            "test_cython_agg_boolean",
            "test_loc_axis_arguments",
            "sortlevel",
            "time_dt_accessor_month_name",
            "test_dti_custom_getitem_matplotlib_hackaround",
            "test_join_index_mixed",
            "dot",
            "_check_parser",
            "time_sortlevel_int64",
            "test_value_counts_int",
            "test_maybe_indices_to_slice_middle",
            "test_get_locales_at_least_one",
            "build_fill",
            "test_str_uses_object",
            "test_constructor_int_overflow",
            "test_rmod_invalid",
            "test_series_tz_convert",
            "test_tdi_sub_dt64_array",
            "_convert_to_indexer",
            "_from_sequence",
            "test_seriesgroupby_name_attr",
            "test_str_bool_series_indexing",
            "test_empty_dtypes",
            "_addsub_offset_array",
            "test_at_time_errors",
            "test_read_csv_buglet_4x_multi_index2",
            "time_float_int",
            "is_timedelta64_dtype",
            "test_ufuncs",
            "test_to_datetime_pydatetime",
            "_maybe_clear_freq",
            "test_two_backtick_variables_query",
            "time_on_int",
            "test_contains_dunder",
            "test_pi_comp_period_nat",
            "test_fillna_index_period",
            "test_unsorted_index",
            "exists",
            "test_css_to_excel_good_colors",
            "test_replace_dst_fold",
            "test_setitem_empty_indxer",
            "test_multiindex_period_datetime",
            "test_keys",
            "test_default_handler_numpy_unsupported_dtype",
            "_check_promote",
            "test_parse_public_s3_bucket_chunked_python",
            "_evaluate_with_timedelta_like",
            "_read_old_header",
            "test_calendar_roundtrip_issue",
            "test_localized_at_time_between_time",
            "test_matmul",
            "test_is_all_dates",
            "test_timedelta_mode",
            "correct_parameters",
            "test_label_overflow",
            "test_getitem_boolean_list",
            "visit_Index",
            "test_hash_collisions",
            "test_basic_downsample",
            "test_append_series_dict",
            "end_time",
            "read_coordinates",
            "test_combine_add",
            "test_to_records_with_multindex",
            "is_datelike_mixed_type",
            "test_groupby_multiindex_missing_pair",
            "test_tsplot_deprecated",
            "test_format_with_name_time_info",
            "test_secondary_bar_frame",
            "maybe_upcast",
            "test_setitem_invalidates_datetime_index_freq",
            "test_bar_barwidth_position",
            "test_argsort_missing_array",
            "generate_filter_op",
            "_check_op_integer",
            "test_at",
            "test_resample_to_quarterly",
            "test_store_timezone",
            "test_range_misspecified",
            "test_expanding_func",
            "time_series_categorical",
            "_bool_method_SERIES",
            "test_register_writer",
            "swaplevel",
            "ex",
            "mem_itertuples_to_list",
            "test_info_wide",
            "test_to_sql_method_callable",
            "_format_value",
            "test_add_iadd_timedeltalike_annual",
            "test_bar_align_left_0points",
            "_check_thousands",
            "test_reset_index_range",
            "test_dt64arr_sub_datetime64_not_ns",
            "test_take_na_value_other_decimal",
            "_get_formatter",
            "test_to_csv_write_to_open_file",
            "tolist",
            "test_is_float_dtype",
            "engine_has_neg_frac",
            "_flex_method_SERIES",
            "test_getitem_scalar",
            "test_sub_single_tz",
            "time_chained_indexing",
            "time_getitem_pos_slice",
            "test_to_string_with_formatters",
            "test_sort_index_level_and_column_label",
            "test_agg_ser_multi_key",
            "_rows_to_cols",
            "cummin",
            "_clean_index_names",
            "set_atom_data",
            "test_sub_n_gt_1_offsets",
            "test_hash_equivalent",
            "test_holiday_dates",
            "test_categorical_concat_append",
            "_get_canonical_key",
            "test_replace_str_to_str_chain",
            "test_frame_setitem",
            "time_reindex_missing",
            "codes",
            "test_constructor_ragged",
            "test_cumcount_mi",
            "test_rw_nthreads",
            "test_if_scatterplot_colorbar_affects_xaxis_visibility",
            "test_concat_ignore_index",
            "test_concat_sorts_index",
            "test_constructor_keyword",
            "test_split_no_pat_with_nonzero_n",
            "test_isna_isnull",
            "df_duplabels",
            "df",
            "test_view_index",
            "test_buffer_rd_bytes",
            "test_dropna_no_nan",
            "axis_series",
            "test_tz_convert_nat",
            "test_groupby_dict_mapping",
            "_validate_td64_dtype",
            "test_total_seconds",
            "test_reindex_preserves_name_if_target_is_list_or_ndarray",
            "test_read_hdf_iterator",
            "test_allow_exact_matches_forward",
            "test1_index",
            "test_construct_errors",
            "test_duplicate_argument",
            "test_replace_mixed_types",
            "_cast_values_for_fillna",
            "test_union_bug_1745",
            "set_eng_float_format",
            "test_subclassed_melt",
            "dst",
            "unconvert",
            "_validate_index_level",
            "test_concat_datetime_timezone",
            "test_extractall_single_group_with_quantifier",
            "test_generic",
            "test_astype_idempotent",
            "test_add_datetimelike_and_dti",
            "on_right",
            "test_getitem_unordered_dup",
            "test_bar_align_mid_axis_none",
            "_align_core",
            "any_numpy_dtype",
            "cast_scalar_indexer",
            "test_str_for_named_is_name",
            "format_date_labels",
            "test_nth_column_order",
            "test_get_loc_datetimelike_nonoverlapping",
            "from_spmatrix",
            "test_corr_callable_method",
            "sort_with_none",
            "box_expected",
            "test_encode_numeric_overflow_nested",
            "test_iloc_getitem_neg_int",
            "test_iso_8601_strings_with_different_offsets",
            "test_loc_getitem_dups2",
            "test_date_index_query_with_NaT",
            "test_multiple_header_rows",
            "test_frame_getitem_not_sorted",
            "test_roundtrip_pickle_with_tz",
            "test_na_actions_categorical",
            "ror_",
            "test_maybe_promote_float_with_int",
            "test_astype_to_incorrect_datetimelike",
            "numpy_dtype",
            "check_setitem_lengths",
            "test_categorical_dtype_latin1",
            "test_file_handle_string_io",
            "test_nanall",
            "time_read_sql_query",
            "test_apply_categorical_with_nan_values",
            "_convert_to_font",
            "test_groupby_level",
            "testStrictUnicodePack",
            "testRollforward2",
            "justify",
            "time_index_slice",
            "test_constructor_single_value",
            "_background_gradient",
            "test_eval_resolvers_as_list",
            "test_all_values_single_bin",
            "test_nat_vector_field_access",
            "test_setslice",
            "test_describe_empty_object",
            "coerce_to_target_dtype",
            "test_css_to_excel_multiple",
            "test_indexing",
            "test_resample_empty_series",
            "test_merge_on_multikey",
            "load_iris_data",
            "var",
            "to_ea_dtypes",
            "test_pivot_with_interval_index",
            "test_td_floordiv_numeric_scalar",
            "run_binary",
            "translate_In",
            "_summary",
            "test_ops_general",
            "test_index_ctor_infer_periodindex",
            "test_categorical_comparisons",
            "test_index_subclass_constructor_wrong_kwargs",
            "test_join_multi_to_multi",
            "test_partition_to_dataframe",
            "test_to_csv_from_csv_w_all_infs",
            "_process_date_conversion",
            "test_decode_broken_json_leak",
            "to_numpy",
            "time_get_indexer_list",
            "strict_data_files",
            "test_reset_index_with_drop",
            "test_fillna_raise",
            "test_datetime_nan_mask",
            "test_drop_column",
            "_selection_list",
            "_read_value_labels",
            "test_tdarr_div_length_mismatch",
            "build_kwargs",
            "test_nested_dict_construction",
            "test_sum_corner",
            "time_qcut_timedelta",
            "test_rank_avg_even_vals",
            "to_period",
            "_process_columntext_subheader",
            "test_whitespace_preservation",
            "_handle_date_column",
            "test_ix_deprecation",
            "test__bn_ok_dtype",
            "time_cache_readonly",
            "time_rolling",
            "test_concat_empty_series_dtypes_roundtrips",
            "test_categorical_equal_ordered_mismatch",
            "test_encode_with_decimal",
            "test_getslice_tuple",
            "test_put_string_index",
            "test_add_signed_zeros",
            "_choose_path",
            "test_join_many_non_unique_index",
            "test_to_string_with_datetime64_monthformatter",
            "test_minmax_nat_dataframe",
            "_maybe_convert_index",
            "_stop",
            "test_constructor_from_index_series_period",
            "test_where_setitem_invalid",
            "test_maybe_promote_bytes_with_any",
            "test_consistent_names",
            "test_astype_to_datetimelike_unit",
            "test_info_categorical",
            "test_downsample_non_unique",
            "test_constructor_convert_index_once",
            "month_classes",
            "register",
            "test_td64arr_with_offset_series",
            "test_map_with_categorical_series",
            "_check_grid_settings",
            "from_records",
            "test_to_timestamp",
            "test_encode_date_conversion",
            "test_file_binary_mode",
            "test_is_empty",
            "test_quantile_interpolation_dtype",
            "test_interpolate_invalid_nonpositive_limit",
            "_setup_subplots",
            "test_validate_bool_kwarg",
            "test_datetime_fractional_seconds",
            "test_td_add_sub_numeric_raises",
            "test_not_equal",
            "test_extension_array",
            "test_from_freq_recreate_from_data",
            "double_blank_lines",
            "test_is_numeric_v_string_like",
            "time_timedelta_seconds",
            "_finalize",
            "test_series_ix_getitem_fancy",
            "decons_group_index",
            "test_read_excel_chunksize",
            "test_setitem_iloc_scalar_multiple_homogoneous",
            "test_compression_blosc",
            "test_replace_aware",
            "test_rank_average_pct",
            "test_ops_properties_basic",
            "test_isAnchored",
            "test_write_bytes",
            "_construct_axes_dict",
            "_compute_grand_margin",
            "test_axis_share_x",
            "test_frame_from_records_utc",
            "_from_factorized",
            "test_repr_set",
            "test_resample_base_with_timedeltaindex",
            "col",
            "test_get_loc_length_one_scalar",
            "test_iterator",
            "try_sort",
            "test_cython_agg_empty_buckets_nanops",
            "test_empty_field_eof",
            "_args_adjust",
            "_check_comparison_ops",
            "_importers",
            "_get_call_args",
            "test_groupby_as_index_cython",
            "test_decode_array_with_big_int",
            "test_usecols_index_col_conflict",
            "test_returned_dtype",
            "test_join_on",
            "test_dt_accessor_api",
            "time_from_datetime_timedelta",
            "test_dti_tz_localize_nonexistent_shift",
            "test_select_with_dups",
            "test_tdi_add_timestamp_nat_masking",
            "test_handle_empty_objects",
            "get_object",
            "test_dropna_array",
            "test_new_empty_index",
            "test_unstack_unobserved_keys",
            "create_index",
            "test_add_offset",
            "count_empty_vals",
            "test_aggfuncs",
            "test_replace_method",
            "test_secondary_y_non_ts_xlim",
            "test_left_outer_join_bug",
            "test_resample_apply_with_additional_args",
            "test_equals",
            "test_maybe_promote_any_with_bytes",
            "isnumeric",
            "_reindex_with_indexers",
            "test_setting_fill_value_updates",
            "_sanitize_column",
            "test_mod_numeric",
            "test_reduce_series_numeric",
            "wrap_results_for_axis",
            "test_fillna_float64",
            "test_ignore_display_max_colwidth",
            "test_from_arrays_index_series_categorical",
            "interpolate_1d",
            "test_deepcopy_empty",
            "test_constructor_mixed_type_rows",
            "test_astype",
            "test_get",
            "test_multiindex_slicers_edges",
            "test_interpolate_non_ts",
            "time_intersection",
            "test_where_none",
            "_format_header",
            "test_isoformat",
            "_make_skipna_wrapper",
            "test_multi_index_naming_not_all_at_beginning",
            "_check_box_return_type",
            "test_to_latex_non_string_index",
            "_interpolate_with_fill",
            "test_setitem_na",
            "_assert_not_series_equal_both",
            "is_overlapping",
            "time_frame_series_dot",
            "time_categorical_contains",
            "_is_memory_usage_qualified",
            "test_range_with_millisecond_resolution",
            "test_reader_converters",
            "test_dt_round_tz",
            "test_delta_to_nanoseconds",
            "test_td64arr_mul_int_series",
            "test_constructor_dict_input",
            "test_dataframe_dummies_prefix_sep_bad_length",
            "test_conv_weekly_legacy",
            "test_subclass_unstack_multi",
            "test_add_series_with_period_index",
            "any_real_dtype",
            "test_css_absolute_font_size",
            "time_repr_tall",
            "test_astype_cannot_cast",
            "render_git_describe",
            "_reindex_multi",
            "test_reset_index_multiindex_columns",
            "test_resolution_bumping",
            "test_float_subtype",
            "test_cat",
            "offset",
            "_get_binner_for_time",
            "_apply",
            "test_binary_ufunc_with_array",
            "test_loc_name",
            "test_dti_reset_index_round_trip",
            "_formatter_func",
            "_convert_1d",
            "test_parallel_coordinates",
            "test_naive_aware_conflicts",
            "_make_plot_keywords",
            "test_identity",
            "_get_valid_sqlite_name",
            "test_max_bin_len",
            "parametrize_fixture_doc",
            "test_series_equal_values_mismatch",
            "test_setitem_ambiguous_keyerror",
            "test_mod_timedeltalike",
            "test_reindex_with_nans",
            "test_constructor_list_of_series_aligned_index",
            "test_decode_pairs_hook",
            "test_to_excel_periodindex",
            "test_to_frame_with_falsey_names",
            "time_downcast",
            "nearest_workday",
            "test_css_to_excel_inherited",
            "time_write_store_table_wide",
            "test_numpy_sum",
            "_write_table",
            "test_drop_by_str_label_errors_ignore",
            "test_select_dtypes_include_using_scalars",
            "_set_codes",
            "test_intervals",
            "test_to_coo_text_names_integer_row_levels_nosort",
            "test_update_raise_bad_parameter",
            "test_series_equal_index_dtype",
            "_write_strls",
            "test_drop_multiindex_not_lexsorted",
            "time_frame_int_div_by_zero",
            "test_validate_n_error",
            "test_can_set_locale_valid_set",
            "fast_apply",
            "_ixs",
            "test_table_mixed_dtypes",
            "groupby",
            "test_astype_cast_nan_inf_int",
            "test_from_sequence_dtype",
            "test_parr_cmp_period_scalar",
            "test_replace_list",
            "test_agg_cython_table_transform",
            "test_raises_on_usecols_names_mismatch",
            "test_roundtrip_tz_aware_index",
            "test_constructor_ordered_dict_preserve_order",
            "test_td_sub_timedelta64",
            "_f2",
            "test_comparison_object_numeric_nas",
            "test_agg_consistency",
            "test_coordinates",
            "test_basic_frame_series_alignment",
            "test_in_numeric_groupby",
            "test_pivot_table",
            "test_offset_freqstr",
            "test_bool_properties",
            "_create_sql_schema",
            "test_NaT_scalar",
            "_raise_on_incompatible",
            "test_empty_with_multi_index",
            "test_multi",
            "test_dti_tz_localize_roundtrip",
            "remove_categories",
            "maybe_downcast_to_dtype",
            "test_overwrite_warns",
            "test_frame_no_datetime64_dtype",
            "time_frame_multi_and",
            "check_cython_extensions",
            "is_integer",
            "test_sparse_series_ops_z",
            "_apply_filter",
            "test_allow_exact_matches_and_tolerance2",
            "time_sum",
            "write_result",
            "_list_of_series_to_arrays",
            "test_period_immutable",
            "_get_bool_data",
            "test_query_builtin",
            "test_bad_url_protocol",
            "test_excel_sep_warning",
            "to_xarray",
            "test_apply_categorical",
            "test_xs_level_series",
            "test_rowspan_at_end_of_row",
            "test_copy_delim_warning",
            "test_dti_shift_localized",
            "test_nonfile_writing",
            "test_nat_methods_nan",
            "_maybe_normalize_endpoints",
            "test_corrwith_with_objects",
            "set_table_styles",
            "test_numpy_minmax_timedelta64",
            "test_numeric_range_too_wide",
            "reindex",
            "test_to_latex_no_header",
            "test_read_gbq_without_new_kwargs",
            "test_timedelta64_analytics",
            "test_agg_multiple_functions_maintain_order",
            "nanargmin",
            "_write_data",
            "_join_compat",
            "test_ufunc_reduce_raises",
            "test_items",
            "fillna_method",
            "test_constructor_ordereddict",
            "test_wide_repr_wide_columns",
            "test_join_on_singlekey_list",
            "test_intersection_difference",
            "test_readbytes",
            "test_iterable",
            "time_rank_string",
            "_get_dummies_1d",
            "test_kind_both_ways",
            "test_merge_all_na_column",
            "test_allow_exact_matches_and_tolerance3",
            "test_iteration",
            "test_getitem_preserve_name",
            "test_int_max",
            "test_nanosecond_index_access",
            "test_dates_display",
            "test_guess_datetime_format_with_parseable_formats",
            "test_bar_categorical",
            "test_pickle",
            "test_construct_DataFrame_with_sp_series",
            "time_frame_float_equal",
            "test_constructor_simple_new_empty",
            "test_broadcast",
            "test_column_dups_indexing2",
            "test_categorical_concat_preserve",
            "test_integer_arithmetic_frame",
            "test_concat_same_type_different_freq",
            "test_ceil",
            "test_constructor_multi_index",
            "test_date_query_with_non_date",
            "test_setitem_datetimelike_with_inference",
            "test_to_csv_with_mix_columns",
            "test_ensure_categorical",
            "assert_frame_equal",
            "test_dups_index",
            "test_sparse_frame_stack",
            "test_comparison_tuples",
            "generic_parser",
            "test_groupby_series_whitelist",
            "_convert_to_number_format",
            "test_count_objects",
            "test_add_prefix_suffix",
            "check_metadata",
            "test_statsmodels",
            "setup_ops",
            "test_area_lim",
            "time_iso8601",
            "test_frame_inferred",
            "test_construction_generic",
            "test_constructor_categorical_dtype",
            "test_timestamp_to_datetime_tzoffset",
            "test_datetime_assignment_with_NaT_and_diff_time_units",
            "_expand_colspan_rowspan",
            "test_copy_names",
            "test_datetime_NaT",
            "test_getitem",
            "test_class_axis",
            "test_pivot_table_categorical",
            "parameter_type",
            "test_set_na",
            "test_dtype_and_names_error",
            "_is_dtype",
            "test_ufunc",
            "test_constructor_cast_object",
            "test_select_dtypes_include_exclude_using_scalars",
            "_fill_mi_header",
            "slice_shift",
            "is_dict_like",
            "eval",
            "test_factorize_repeated",
            "test_sort_index_and_reconstruction",
            "test_multiple_functions_tuples_and_non_tuples",
            "test_parse_dates_list",
            "test_datetime64tz_fillna_round_issue",
            "test_keyword_as_column_names",
            "check_modulus",
            "test_slice_specialised",
            "test_iloc_getitem_invalid_scalar",
            "test_concat_empty_series",
            "test_applymap_subset",
            "test_apply_bug",
            "_buffered_line",
            "test_query",
            "test_to_datetime_errors_ignore_utc_true",
            "test_update_nan",
            "_format_header_mi",
            "test_tz_convert_unsorted",
            "test_rename_set_name",
            "test_transform_with_non_scalar_group",
            "_extended_gcd",
            "test_resample_as_freq_with_subperiod",
            "test_python_engine_file_no_next",
            "test_crosstab_errors",
            "test_where_ordered_differs_rasies",
            "hash_tuple",
            "test_binary_ufuncs",
            "test_to_numpy_alias",
            "_convert",
            "raw",
            "background_gradient",
            "test_pie_series",
            "test_filter_series",
            "test_dt_namespace_accessor",
            "test_interp_leading_nans",
            "test_stat_op_corner",
            "maybe_infer_freq",
            "test_set_option_invalid_single_argument_type",
            "test_maybe_mangle_lambdas_named",
            "_prep_values",
            "test_rolling_cov_pairwise",
            "test_constructor_Series_copy_bug",
            "test_div_td64arr",
            "test_float_types",
            "test_east_asian_unicode_series",
            "test_read_nokey_table",
            "test_usecols_with_mixed_encoding_strings",
            "_trim_excel_header",
            "test_is_names_tuple_fails",
            "_apply_axis_properties",
            "test_path_pathlib",
            "to_html",
            "_convert_bin_to_datelike_type",
            "test_to_csv_float32_nanrep",
            "test_at_and_iat_get",
            "test_asfreq_near_zero",
            "test_secondary_kde",
            "time_asfreq",
            "test_align_int_fill_bug",
            "test_more_na_comparisons",
            "test_unstack_fill_frame_object",
            "test_rename_inplace",
            "test_frame_iloc_callable_setitem",
            "nanpercentile",
            "test_is_one_of_factory",
            "test_to_frame_expanddim",
            "test_from_frame_valid_names",
            "time_transform_multi_key4",
            "dates",
            "test_get_complex",
            "_get_level_number",
            "test_to_timestamp_out_of_bounds",
            "test_append_numpy_bug_1681",
            "time_get_index",
            "time_convert_string_days",
            "test_concat_multiindex_dfs_with_deepcopy",
            "test_blockplacement_add_int",
            "test_read_array_header",
            "test_scalar_error",
            "makeTimedeltaIndex",
            "test_round_invalid_arg",
            "utcoffset",
            "start_blank_lines",
            "time_read_csv_dayfirst",
            "test_getitem_int_dtype",
            "test_kde_df",
            "downsample_method",
            "test_options_auto",
            "test_1000_sep",
            "test_to_string_truncate_indices",
            "combine_concat_plans",
            "test_binops_level",
            "test_unsupported",
            "_stat_axis",
            "test_encode_unicode_conversion",
            "test_loc_setitem_slice",
            "test_categorical_series_repr_ordered",
            "test_parsers_time",
            "test_from_tdi",
            "test_to_string_no_header",
            "time_len",
            "_parse_float_vec",
            "test_api_per_dtype",
            "test_merge_left_empty_right_notempty",
            "time_query_store_table",
            "test_default_handler",
            "test_combine_first_align_nan",
            "test_math_floordiv",
            "test_encode_array_of_doubles",
            "test_preserve_metadata",
            "test_rolling_axis_sum",
            "is_datetimelike",
            "time_frame_assign_timeseries_index",
            "test_to_sql_fail",
            "test_from_arrays_index_series_datetimetz",
            "_is_monotonic_increasing",
            "right",
            "pad",
            "to_timedelta",
            "test_construct_timestamp_near_dst",
            "test_asfreq_keep_index_name",
            "peakmem_float",
            "test_to_records_with_unicode_column_names",
            "test_wide_repr_unicode",
            "test_rank_pct_true",
            "test_fillna_series",
            "test_file_url",
            "time_store_str",
            "test_concat_categoricalindex",
            "read_msgpack",
            "test_notna_dtype",
            "test_categorical_concat",
            "time_series_plot",
            "test_bigint",
            "time_loc",
            "test_shift_month_dt",
            "__neg__",
            "test_set_codes",
            "test_intersection_base",
            "test_multi_thread_path_multipart_read_csv",
            "test_loc_uint64",
            "test_is_dtype",
            "test_arith_mixed",
            "_fillna_prep",
            "time_read_msgpack",
            "test_corr",
            "test_subplots_timeseries",
            "test_is_scipy_sparse",
            "_aggregate_series_pure_python",
            "_nbytes",
            "test_query_index_with_name",
            "test_to_hdf_errors",
            "test_if_exists",
            "test_rank_apply",
            "_check_mixed_int",
            "get_result",
            "test_tdi_isub_int",
            "_find_non_overlapping_monotonic_bounds",
            "test_ms_vs_capital_ms",
            "get_test_result",
            "test_align_fill_method",
            "hour_deltas",
            "test_line_plot_datetime_series",
            "test_already_underscore_variable",
            "test_union_dt_as_obj",
            "test_skiprows_int",
            "test_large_dataframe_indexing",
            "randu",
            "str_split",
            "test_to_offset",
            "test_resampler_is_iterable",
            "test_encode_to_utf8",
            "_check_ew",
            "test_unsortable",
            "test_categorical_from_codes",
            "test_read_non_existant",
            "test_freq_name_separation",
            "test_fillna_method_doesnt_change_orig",
            "test_end_time",
            "test_header_multi_index_common_format_malformed2",
            "test_construction_errors",
            "test_columns_multiindex_modified",
            "test_to_period_tz_utc_offset_consistency",
            "test_apply_series_to_frame",
            "itertuples",
            "test_categorical_equality",
            "_validate_sort_keyword",
            "test_agg_relabel_other_raises",
            "load",
            "_data_to_frame",
            "test_nat_arithmetic_index",
            "test_generic_errors",
            "test_non_monotonic",
            "_get_names",
            "test_diff_timedelta",
            "test_usecols_with_parse_dates4",
            "read_metadata",
            "_validate_key",
            "test_round_trip_exception_",
            "test_value_counts_dup",
            "test_only_one_obj_hook",
            "test_is_unique",
            "test_is_level_or_label_reference_df_simple",
            "time_get_dummies_1d_sparse",
            "test_constructor_categorical_valid",
            "head1",
            "infer_dtype_from_array",
            "test_inplace_ops_alignment",
            "test_pi_sub_pdnat",
            "testPackBytes",
            "_simple_blockify",
            "infer",
            "test_to_csv_dtnat",
            "not_hourly",
            "test_constructor_mixed_dict_and_Series",
            "_write_expansion_fields",
            "test_bool_same_index",
            "test_pindex_multiples",
            "numeric_indexing_engine_type_and_dtype",
            "_intersection_unique",
            "test_empty_with_reversed_multi_index",
            "test_pickle_path_pathlib",
            "test_hist_legacy",
            "test_time",
            "test_construct_cast_invalid",
            "test_filter_condition_raises",
            "apply_empty_result",
            "test_drop_duplicates_empty",
            "read_multi_index",
            "test_compact_numerical_values",
            "test_contains_nan",
            "_where_numexpr",
            "test_setitem_index_object",
            "test_concat_axis1_different_fill",
            "testPack",
            "test_pprint",
            "_evaluate_standard",
            "test_Second",
            "read_csv",
            "test_na_flags_int_categories",
            "_get_codes_for_sorting",
            "test_non_scalar_raises",
            "test_perf_min",
            "nonzero",
            "_get_data_to_aggregate",
            "test_to_datetime_iso_week_year_format",
            "test_categorical_series_repr",
            "test_fillna_series_complex128",
            "test_constructor_dtypes_timedelta",
            "test_constructor_dict_multiindex",
            "_tick_comp",
            "tsd",
            "test_boolean_cmp",
            "time_concat_small_frames",
            "time_all_nan",
            "test_periodindex",
            "test_cython_right_outer_join",
            "test_from_tuples_with_tuple_label",
            "_trim_zeros_float",
            "add_flex_arithmetic_methods",
            "test_quote_char_various",
            "test_concat_named_keys",
            "test_reindex_frame_add_nat",
            "test_set_axis_inplace",
            "test_encode_unicode_surrogate_pair",
            "test_xs_corner",
            "test_infs_n_nans",
            "_list_of_dict_to_arrays",
            "test_maybe_promote_timedelta64_with_any",
            "test_loc_getitem_bool",
            "onOffset",
            "test_cut_duplicates_bin",
            "init_dict",
            "autoscale",
            "test_numpy_array_complex",
            "test_pivot_periods",
            "test_sum_prod_nanops",
            "test_pi_sub_period_nat",
            "test_replace_mixed_types_with_string",
            "test_copy_blocks",
            "test_axis_aliases",
            "test_groupby_with_timegrouper_methods",
            "test_to_string_format_inf",
            "_check_decimal",
            "safe_remove",
            "str_find",
            "test_groupby_groups_periods",
            "test_excel_table_sheet_by_index",
            "test_astype_datetime64",
            "test_categorical_sorting",
            "test_series_pos",
            "_assert_series_equal",
            "test_asfreq_ts",
            "test_get_backfill_indexer",
            "test_left_join_index_preserve_order",
            "test_int32_overflow",
            "test_inner_join_indexer",
            "test_getitem_generator",
            "time_fastpath",
            "update_kwargs",
            "time_title",
            "test_nonzero_base",
            "test_concat_NaT_series",
            "test_describe_categorical",
            "test_decode_big_escape",
            "test_negative_log",
            "test_tdi_cmp_str_invalid",
            "visit_Div",
            "test_join_inner_multiindex",
            "test_assignment_in_query",
            "_close_conn",
            "merge_ordered",
            "test_categorical_repr_period_ordered",
            "assert_array_dicts_equal",
            "test_daily",
            "test_dti_add_tdi",
            "test_append_with_timezones_dateutil",
            "test_append_many",
            "_slice",
            "test_fillna_int",
            "_blknos",
            "test_group_fill_methods",
            "test_pandas_datareader",
            "_gen_eval_kwargs",
            "test_overlaps_na",
            "test_to_coo_bad_partition_nonnull_intersection",
            "test_concat_columns",
            "test_concat_dataframe",
            "test_frame_fillna_limit",
            "test_filter_maintains_ordering",
            "maybe_cythonize",
            "test_to_datetime_other_datetime64_units",
            "time_bool_indexer",
            "_get_roll",
            "test_end_time_timevalues",
            "check_values",
            "read_pickle",
            "test_to_sql_index_label_multiindex",
            "test_split_nan_expand",
            "test_repr_with_unicode_data",
            "assert_level_values",
            "test_merge_empty_frame",
            "test_slice_to_array_conversion",
            "test_eq_with_str",
            "_format_regular_rows",
            "test_deprecated_numpy_func_call",
            "_needs_reindex_multi",
            "_start_base",
            "test_both_offset_observance_raises",
            "test_ix_frame_align",
            "test_at_fill_value",
            "test_decode_too_extreme_numbers",
            "test_max_ext_len",
            "test_write_bytes_multi_buffer",
            "time_reindex",
            "maybe_upcast_putmask",
            "_search_replace_num_columns",
            "test_css_to_excel_bad_colors",
            "test_delimit_whitespace",
            "test_105",
            "_default_locale_getter",
            "test_difference",
            "test_read_empty_with_usecols",
            "test_recreate_from_data",
            "test_not_all_none",
            "test_series_given_mismatched_index_raises",
            "test_to_frame",
            "time_argsort",
            "_dispatch",
            "test_disallow_setting_tz",
            "test_set_frame_overwrite_object",
            "test_get_loc_decreasing",
            "test_standardize_mapping",
            "_datetime_to_stata_elapsed_vec",
            "test_sort_nan",
            "test_stack_timezone_aware_values",
            "test_greater",
            "test_roundtrip_thru_setitem",
            "test_deprecated",
            "test_merge_misspecified",
            "test_color_single_series_list",
            "test_pickle_path_localpath",
            "time_series_groups",
            "test_unicode_print",
            "check_alignment",
            "test_df_subplots_patterns_minorticks",
            "test_append_different_columns_types_raises",
            "test_loc",
            "test_index_tab_completion",
            "test_scalar_from_string",
            "test_subclassed_apply",
            "test_set_locale",
            "list_of_str",
            "_unconvert_index",
            "test_td64arr_pow_invalid",
            "_get_rename_function",
            "test_quantile_datetime",
            "test_to_html_border",
            "test_parse_all_fields",
            "test_value_counts_categorical_ordered",
            "test_level_with_tuples",
            "_insert_strls",
            "test_unstack_nan_index",
            "test_ewma",
            "_union_incompatible_dtypes",
            "_ndim",
            "test_cov",
            "test_text_color_threshold_raises",
            "test_mask_inplace",
            "_getitem_iterable",
            "test_ngroup_cumcount_pair",
            "construction_error",
            "test_take",
            "test_loc_setitem_consistency_slice_column_len",
            "test_groupby_mean_no_overflow",
            "operand_types",
            "test_shift_month_ts",
            "test_nan_invalid",
            "infer_setup",
            "test_index_mixed_closed",
            "_get_all_lines",
            "test_to_string_float_na_spacing",
            "test_vars_work_with_multiindex",
            "test_to_datetime_format_weeks",
            "test_plot_scatter_with_categorical_data",
            "test_dayfirst",
            "time_replace_across_dst",
            "test_corrwith_dup_cols",
            "test_fill_corner",
            "test_timestamp_sub_datetime",
            "update_pr",
            "test_interp_inplace_row",
            "remove_unused_categories",
            "test_different_number_of_cols",
            "test_eng_float_formatter",
            "_sub_datetime_arraylike",
            "test_period_mean",
            "test_align_same_index",
            "test_tz_localize_errors_coerce",
            "_getitem_nested_tuple",
            "_get_consensus_names",
            "test_pi_ops_array_int",
            "time_html_repr_trunc_si",
            "test_td64arr_add_offset_array",
            "test_stack_preserve_categorical_dtype_values",
            "test_agg_callables",
            "df1",
            "test_readjson_chunks_multiple_empty_lines",
            "test_constructor_categorical_string",
            "_format_header_regular",
            "run_cmd",
            "test_corrwith_series",
            "local_name",
            "test_aggregate_api_consistency",
            "nargsort",
            "test_unstack_group_index_overflow",
            "validate_argmax_with_skipna",
            "_get_repr",
            "_get_root",
            "test_info_memory_usage_deep_pypy",
            "test_loc_setitem_consistency",
            "test_swapcase",
            "test_constructor_list_str",
            "test_add_different_nans",
            "time_fromordinal",
            "test_can_hold_identifiers",
            "test_ops_properties",
            "test_left_join_index_multi_match_multiindex",
            "time_iteritems",
            "test_diff_datetime_axis0",
            "test_assert_not_almost_equal_strings",
            "test_arith_flex_frame_mixed",
            "test_raises_attribute_error",
            "assert_timedelta_array_equal",
            "assert_raises_regex",
            "test_lookup_float",
            "df_compat",
            "test_setitem_chained_no_consolidate",
            "get_slice",
            "time_list_of_dict",
            "test_merge_nocopy",
            "__invert__",
            "_write_variable_types",
            "right_multi",
            "test_nearest_by",
            "test_cache_readonly_preserve_docstrings",
            "pprint_hits",
            "test_radviz",
            "test_frame_info_encoding",
            "test_parse_time_quarter_with_dash",
            "_get_fill",
            "test_ewm_domain_checks",
            "test_unpack_ext_type",
            "test_outer_join_indexer",
            "test_astype_column_metadata",
            "test_map_header",
            "test_encode_builtin_values_conversion",
            "test_read_missing_key_close_store",
            "test_tick_offset",
            "test_date_range_timestamp_equiv",
            "_from_categorical_dtype",
            "test_if_hexbin_xaxis_label_is_visible",
            "test_concat_period_other_series",
            "test_retain_index_attributes",
            "test_pass_args_kwargs",
            "test_usecols_name_length_conflict",
            "build_font",
            "_execute_insert",
            "_non_reducing_slice",
            "test_no_keep_default_na_dict_na_values",
            "test_single_vars_work_with_multiindex",
            "test_value_vars_types",
            "test_take_filling_fill_value",
            "test_categorical_category_dtype",
            "_convert_grouper",
            "test_logical_ops_label_based",
            "time_float_int_str",
            "test_banklist",
            "test_pos_object",
            "test_is_bool",
            "df_idx",
            "_safe_reshape",
            "is_bool_dtype",
            "_convert_wrapper",
            "test_int",
            "test_consistency",
            "_coerce_method",
            "_clean_dict",
            "test_monotonic_on",
            "test_nlevels",
            "test_join_on_fails_with_different_column_counts",
            "test_empty_fancy",
            "test_numeric_like_ops",
            "test_get_timestamp_range_edges",
            "test_nancorr_pearson",
            "test_array_not_registered",
            "time_multi_int_nunique",
            "test_tick_equality",
            "test_fillna_mixed_float",
            "_format_hierarchical_rows",
            "test_to_html_multiindex_index_false",
            "test_typ",
            "make_empty",
            "test_on_float",
            "_upsample_others",
            "test_repr_truncation_column_size",
            "has_info_repr",
            "test_get_locales_prefix",
            "test_setitem_sequence",
            "test_decode_hook",
            "set",
            "test_multi_func",
            "test_to_string_index_formatter",
            "set_atom",
            "tz_aware_fixture",
            "backtick_quote_name_with_no_spaces",
            "test_read_writer_table",
            "test_readjson_invalid_chunksize",
            "take_data",
            "render_git_describe_long",
            "test_reindex_boolean",
            "argmax",
            "test_notna_notnull",
            "test_apply_datetimetz",
            "test_rank_methods_series",
            "test_complex_across_dimensions_fixed",
            "test_loc_getitem",
            "test_mutate_groups",
            "is_unique",
            "test_append_concat_tz_explicit_pytz",
            "test_line_comment",
            "test_frame_timeseries_column",
            "test_constructor_generic_timestamp_no_frequency",
            "test_getitem_boolean",
            "test_read_chunksize_bad",
            "test_convert_pandas_type_to_json_field_datetime",
            "test_sortlevel_not_sort_remaining",
            "test_other_dtypes_for_array",
            "test_basic_no_by",
            "_is_empty_array",
            "test_frame_setitem_copy_no_write",
            "test_create_and_drop_table",
            "test_constructor_dtypes_to_categorical",
            "_write_value_labels",
            "test_set_levels",
            "test_iloc_setitem_with_scalar_index",
            "test_append_same_columns_type",
            "_convert_to_line_delimits",
            "get_default_ax",
            "generate_index_types",
            "_validate_codes",
            "test_append_to_multiple",
            "test_pi_add_sub_timedeltalike_freq_mismatch_daily",
            "test_dt64_mean",
            "test_getitem_slice_fill_value",
            "test_index",
            "test_catch_oob",
            "test_min_max_categorical",
            "test_index_not_contains",
            "_get_column_repeat",
            "test_value_counts_inferred",
            "test_categorical_nan_equality",
            "test_dropna_multiple_axes",
            "test_categorical_repr_timedelta_ordered",
            "test_agg_namedtuple",
            "test_fillna_datelike",
            "test_to_excel_multiindex",
            "test_to_html_with_classes",
            "test_dtypes",
            "test_asfreq",
            "test_fixed_offset_tz",
            "test_sparsea_max_row_truncated",
            "test_constructor_nan",
            "test_searchsorted",
            "time_dtype_as_field",
            "test_read_csv_dataframe",
            "cd_and_set_engine",
            "test_na_value_for_dtype",
            "test_setitem_index_period",
            "is_dtype_equal",
            "test_shift_nat",
            "test_where_other_categorical",
            "_reindex_non_unique",
            "_assert_ytickslabels_visibility",
            "test_corr_kendall",
            "test_decode_numeric_int_exp",
            "new_func",
            "test_categorical_dtype_chunksize_infer_categories",
            "_create_sp_series",
            "_arr_to_str",
            "time_frame_get_numeric_data",
            "_maybe_coerce_values",
            "test_tuple_width",
            "test_fillna_index_int64",
            "test_already_encoded",
            "_maybe_cast_indexed",
            "makeStringIndex",
            "test_encode_decode",
            "test_tz_pytz",
            "test_where_int64",
            "test_rolling_min",
            "test_read_dta2",
            "time_crosstab",
            "nearest",
            "test_integer_thousands",
            "test_pie_df_nan",
            "ftype",
            "isin",
            "test_read",
            "_prepare_data",
            "tz_replacer",
            "test_td64arr_mul_too_short_raises",
            "_make_parser_function",
            "ensure_clean_path",
            "test_loc_setitem_frame_multiples",
            "test_resample_weekly_all_na",
            "hist_series",
            "test_reindex_nan",
            "test_bar_align_zero_pos_and_neg",
            "test_upsample_with_limit",
            "_codes_to_ints",
            "test_gold_canyon",
            "test_ragged_mean",
            "_from_derivatives",
            "test_pass_TimedeltaIndex_to_index",
            "test_concat_different_columns",
            "_make_field_arrays",
            "test_apply_none",
            "test_setitem_datetime_coercion",
            "test_repr_min_rows",
            "biggie_df_fixture",
            "_validate_usecols_arg",
            "test_mangled",
            "test_str_attribute_raises",
            "test_read_from_file_url",
            "test_fwf_thousands",
            "test_to_string_int_formatting",
            "tsframe",
            "test_expand_user_normal_path",
            "test_loc_setitem_consistency_empty",
            "test_only_1dim_accepted",
            "test_config_default_off",
            "test_array_ufunc",
            "test_column_in",
            "_validate_read_indexer",
            "test_wrap",
            "datetime64_dtype",
            "get_weeks",
            "c_parser_only",
            "ts2",
            "test_to_datetime_infer_datetime_format_series_with_nans",
            "test_skiprows_slice_short",
            "makeBoolIndex",
            "test_construction_with_alt_tz_localize",
            "test_numpy_array_equal_object",
            "test_dti_convert_tz_aware_datetime_datetime",
            "_maybe_mask_result",
            "_add_nat",
            "test_where_unsafe_upcast",
            "convert_to_index_sliceable",
            "time_large_get_loc_warm",
            "disallow",
            "test_donot_drop_nonevalues",
            "test_groupby_multilevel",
            "test_rands",
            "test_date_range_timestamp_equiv_dateutil",
            "test_dti_constructor_static_tzinfo",
            "test_diff_datetime_axis1",
            "test_normalize_nat",
            "test_to_string_float_format",
            "deprecation_in_wrong_order",
            "test_agg_structs_dataframe",
            "test_getitem_setitem_fancy_exceptions",
            "compare_frame_dt_mixed_tzs",
            "test_pickle_preserve_name",
            "cov",
            "time_center",
            "create_index_with_nan",
            "test_parse_dates_custom_euro_format",
            "test_maybe_promote_any_with_datetime64",
            "test_getitem_ix_mixed_integer",
            "test_parse_date_time_multi_level_column_name",
            "test_mul_float_series",
            "test_isin_df_dupe_values",
            "_have_mixed_levels",
            "_maybe_coerce_merge_keys",
            "test_usecols_list",
            "test_index_resolvers_come_after_columns_with_the_same_name",
            "test_union_categoricals_empty",
            "test_float_scalar",
            "test_not_monotonic",
            "test_valid_object_plot",
            "_check_engine",
            "time_floats_with_int_idex_lines",
            "_check_timedeltalike_freq_compat",
            "test_dataframe_dtypes",
            "test_excelwriter_fspath",
            "time_merge_cat",
            "test_unsortedindex_doc_examples",
            "test_to_html_with_col_space_units",
            "test_start_stop_multiple",
            "ljust",
            "test_replace_with_empty_dictlike",
            "_write_hierarchical_rows",
            "test_no_header",
            "_formatter",
            "test_set_group_name",
            "test_corner_union",
            "missing_whitespace_around_arithmetic_operator",
            "test_select_dtypes_bad_arg_raises",
            "test_is_numeric_dtype",
            "test_apply_with_mixed_types",
            "str_index",
            "test_dropna_categorical_interval_index",
            "time_loc_list_like",
            "test_sum_nanops_timedelta",
            "test_flex_comparison_nat",
            "test_to_datetime_box_deprecated",
            "test_datetime_units",
            "test_constructor_infer_period",
            "time_copy_function_multi_col",
            "makePeriodFrame",
            "test_dtype_conversion",
            "invert",
            "test_sort_index_preserve_levels",
            "test_union_categorical_same_categories_different_order",
            "test_frame_column_inplace_sort_exception",
            "_get_cython_table_params",
            "is_string_dtype",
            "test_constructor_DataFrame",
            "test_constructor_with_naive_string_and_datetimetz_dtype",
            "_concatenate_2d",
            "_simple_ts",
            "test_overwrite_node",
            "test_consolidate_ordering_issues",
            "test_reindex_single_named_indexer",
            "series_generator",
            "test_date_format_frame",
            "test_where_error",
            "validate_inferred_freq",
            "is_int64_dtype",
            "dict_compat",
            "two_hours",
            "test_values_lcd",
            "test_list_numeric",
            "assert_dict_equal",
            "iget",
            "test_pi_offset_errors",
            "test_merge_incompat_dtypes_error",
            "test_rmod_timedelta64",
            "test_constructor_dict_order_insertion",
            "time_isin_categorical",
            "test_too_many_ndims",
            "test_implicit_label",
            "str_contains",
            "test_iterator_skipfooter_errors",
            "test_print_none_width",
            "test_frame_setitem_multi_column",
            "test_assignment",
            "string_parameter",
            "test_hypothesis_delimited_date",
            "test_overlap_public_nat_methods",
            "_get_dtypes",
            "test_to_latex_specified_header",
            "test_read_chunksize_compat",
            "test_mod_invalid",
            "_maybe_to_dense",
            "test_objarr_add_str",
            "test_header_multi_index",
            "test_linspace_dst_transition",
            "_get_codes",
            "test_select_bad_cols",
            "test_cummin_datetime64",
            "test_exit_status_errors_for_validate_all",
            "test_indicator",
            "_highlight_extrema",
            "test_escaped_table_name",
            "test_concat_sparse_dense_cols",
            "join",
            "test_round_frequencies",
            "checknull_old",
            "test_crossed_dtypes_weird_corner",
            "write_metadata",
            "test_missing_raises",
            "test_to_offset_whitespace",
            "is_exists",
            "test_add_integer",
            "time_rename_single",
            "_get_default_annual_spacing",
            "test_extractall_same_as_extract",
            "test_nancov",
            "mem_itertuples_raw_to_list",
            "_combine_series_frame",
            "left_right_dtypes",
            "linebreak_at_end_of_docstring",
            "test_apply_chunk_view",
            "test_mixed_arithmetic_series",
            "maybe_expression",
            "test_shallow_copy_i8",
            "test_roll_qtr_day_mod_equal",
            "test_iloc_getitem_int",
            "date_format",
            "test_add_offset_nat",
            "s_main_dtypes_split",
            "test_grouping_ndarray",
            "test_series_with_dtype",
            "test_maybe_promote_any_with_bool",
            "test_is_full",
            "test_str_vs_repr",
            "test_importcheck_thread_safety",
            "test_categorical_margins",
            "test_categorical_preserves_tz",
            "test_empty_method",
            "test_tz_dtype_mismatch_raises",
            "_to_M8",
            "test_write_explicit_bad",
            "test_arith_flex_frame",
            "test_shift_dtype",
            "test_constructor_no_pandas_array",
            "ngroup",
            "test_invalid_index_types_unicode",
            "test_assert_numpy_array_equal_value_mismatch6",
            "test_interval_array_equal_periods_mismatch",
            "test_multiindex_column_lookup",
            "_delegate_property_set",
            "test_freq_code",
            "set_caption",
            "_assert_setitem_index_conversion",
            "test_categorical_with_nan_consistency",
            "_apply_meta",
            "test_round_int64",
            "test_float_array_comparison",
            "test_to_html_empty_dataframe",
            "test_properties_hourly",
            "test_groupby_level_no_obs",
            "test_replace_series_no_regex",
            "test_concat_tz_frame",
            "hide_columns",
            "test_duplicated_drop_duplicates",
            "write_block_index",
            "test_is_leap_year",
            "_expand_elements",
            "test_td_floordiv_timedeltalike_array",
            "test_error_on_using_partition_cols_and_partition_on",
            "construct_array_type",
            "test_divmod_numeric",
            "test_get_indexer_strings",
            "test_constructor_ndarray",
            "test_ix_multiindex_missing_label_raises",
            "time_write_msgpack",
            "time_chained_cmp",
            "time_ix_scalar",
            "raise_with_traceback",
            "test_hist_kde",
            "test_path_path_lib",
            "test_validate_bool_args",
            "test_non_matching",
            "test_getitem_get",
            "_get_vars",
            "test_arith_getitem_commute",
            "test_basic_drop_first_one_level",
            "remove_na_arraylike",
            "test_from_pandas_array",
            "test_get_offset_day_error",
            "test_intersect_identical",
            "test_multi_assign",
            "test_merge_on_ints_floats_warning",
            "test_iloc_returns_scalar",
            "validate_attr",
            "test_take_fill_value_datetime",
            "test_equals_different_blocks",
            "test_observed_groups",
            "nanmean",
            "is_instance_factory",
            "test_fy5253_last_onoffset",
            "return_type",
            "time_set_categories",
            "test_get_loc_interval",
            "test_astype_unicode",
            "_check_stat_op",
            "test_interp_multiIndex",
            "new_func_no_docstring",
            "_validate_integer",
            "test_finder_daily",
            "time_is_month_start",
            "list_of_tuples",
            "test_from_product_empty_two_levels",
            "test_boxplot_return_type_none",
            "test_zip",
            "test_sub_object",
            "_get_objs_combined_axis",
            "test_dti_sub_offset_index",
            "test_from_product_datetimeindex",
            "test_partition_cols_supported",
            "detect_console_encoding",
            "rmod",
            "test_loc_getitem_int",
            "test_from_records_tuples_generator",
            "_check_ndim",
            "__nonzero__",
            "result_columns",
            "test_is_datetimelike_v_numeric",
            "test_table",
            "test_apply_series_on_date_time_index_aware_series",
            "test_spam_no_match",
            "test_interpolate",
            "test_hash_keys",
            "_concat_index_asobject",
            "_doc_parms",
            "test_constructor_with_timedelta_window",
            "test_to_html_truncate",
            "test_isin_level_kwarg_bad_level_raises",
            "test_apply_with_args_kwds",
            "test_series_getitem_corner_generator",
            "test_to_basic",
            "test_other_datetime_unit",
            "test_woy_boundary",
            "_get_column_name_list",
            "load_newobj",
            "test_numpy_ops",
            "test_take_empty",
            "_use_window",
            "prng",
            "test_partition_series",
            "test_xarray",
            "test_hash_error",
            "atomize",
            "test_timedelta64_conversions",
            "test_decode_invalid_dict",
            "test_encode_unicode_4bytes_utf8highest",
            "test_multiindex_roundtrip",
            "needs_i8_conversion",
            "test_categorical_coerces_timestamp",
            "test_default_color_cycle",
            "_unstack",
            "test_addition_subtraction_types",
            "test_cummin_timedelta64",
            "test_to_latex_escape",
            "test_compression_roundtrip",
            "test_resample_size",
            "__array__",
            "make_block",
            "test_read_dta3",
            "test_difference_identity",
            "timedelta_index",
            "time_get_loc_sorted",
            "test_order_of_appearance",
            "test_groupby_frame_whitelist",
            "levshape",
            "test_to_html",
            "test_timedelta64_equal_timedelta_supported_ops",
            "build_alignment",
            "test_apply_series_yield_constant",
            "test_to_latex_multiindex_nans",
            "test_parallel",
            "test_constructor_list_of_iterators",
            "test_to_datetime_unprocessable_input",
            "test_arg_passthru",
            "test_td64arr_sub_NaT",
            "test_iterable_items",
            "dispatch_to_extension_op",
            "test_skiprows_infield_quote",
            "test_methods",
            "test_conv_business",
            "test_reindex_nearest",
            "wide_multi_index",
            "test_tdi_addsub_integer_array_no_freq",
            "test_single_bin",
            "test_utc_z_designator",
            "mem_itertuples_raw_start",
            "time_read_uint64_na_values",
            "test_numpy_reduction",
            "test_constructor_generic_timestamp_bad_frequency",
            "test_options_py",
            "test_secondary_bar",
            "test_constructor_from_unknown_type",
            "test_unexpected_kwargs_raises",
            "test_raises_for_invalid_attribute_name",
            "test_labels",
            "intframe",
            "assert_resolves",
            "test_invalid_dtype_per_column",
            "test_table_values_dtypes_roundtrip",
            "render",
            "test_safe_import_dummy",
            "test_encode_time_conversion_basic",
            "test_objects",
            "test_reindex_axes",
            "test_accessor_works",
            "test_xcompat",
            "has_horizontally_truncated_repr",
            "_add_datetimelike_scalar",
            "test_to_pytimedelta",
            "test_skiprows_set",
            "test_nunique_with_empty_series",
            "test_bounds_check_small",
            "test_comparison_different_length",
            "_select_options",
            "test_dataframe_dummies_prefix_bad_length",
            "test_series_plot_color_kwargs",
            "apply_if_callable",
            "test_is_string_like_dtype",
            "test_where",
            "test_from_records_misc_brokenness",
            "test_select_columns_in_where",
            "test_read_excel_nrows_greater_than_nrows_in_file",
            "test_round_dst_border_nonexistent",
            "test_getname_categorical_accessor",
            "test_unstack_categorical",
            "test_fillna_mixed_type",
            "set_atom_complex",
            "test_is_integer",
            "test_int_df",
            "time_frame_float_unequal",
            "test_constructor_freq_combined",
            "_harmonize_columns",
            "read_feather",
            "test_mangle_series_groupby",
            "test_interp_limit_to_ends",
            "test_map_with_tuples_mi",
            "test_productsales",
            "test_transform_dtype",
            "test_timedelta_ops",
            "test_method_on_bytes",
            "_add_delta_tdi",
            "_parse",
            "test_plot_int_columns",
            "_define_paths",
            "test_join_unconsolidated",
            "test_float_precision_round_trip_with_text",
            "test_time_formatter",
            "_get_numeric_data",
            "test_mul_datelike_raises",
            "assert_numpy_array_equal",
            "rpow",
            "_managle_lambda_list",
            "test_single_line",
            "nanargmax",
            "test_merge_common",
            "array",
            "test_bar_align_mid_pos_and_neg",
            "test_string_index_repr",
            "_create_dtype_data",
            "test_setitem_expand_columns",
            "_check_colors",
            "test_conv_secondly",
            "test_put_mixed_type",
            "test_getitem_list_duplicates",
            "test_scalarop_preserve_name",
            "test_rw_use_threads",
            "test_bar_align_zero_nans",
            "_add_arithmetic_ops",
            "test_not_equals_object",
            "mixed_float",
            "_compute_plot_data",
            "_get_metadata_path",
            "test_read_sql_parameter",
            "test_option_no_warning",
            "time_remove_categories",
            "test_reorder_categories",
            "test_filter_enforces_scalarness",
            "add_categories",
            "test_concat_multiple_frames_dtypes",
            "test_extension_type",
            "test_to_html_multiindex_sparsify",
            "test_div_equiv_binop",
            "_check_columns",
            "test_construction_index_with_mixed_timezones_with_NaT",
            "test_direct_arith_with_series_returns_not_implemented",
            "test_constructor_string",
            "test_invalid_value",
            "test_unordered_compare_equal",
            "test_string_categorical_index_repr",
            "time_read_special_date",
            "test_convert",
            "test_deprecate_order",
            "get_indexer_non_unique",
            "test_boxplot_vertical",
            "idx_dup",
            "check_mutable_error",
            "test_binary_ufunc_scalar",
            "check_ops_properties",
            "_assert_almost_equal_both",
            "test_to_csv_moar",
            "examples",
            "test_where_complex",
            "_is_sup",
            "_parse_thead_tbody_tfoot",
            "test_cast_on_putmask",
            "test_sort_values_frame",
            "_unstack_multiple",
            "test_numeric_values",
            "test_replace_series",
            "test_td64arr_add_sub_numeric_scalar_invalid",
            "makeMissingCustomDataframe",
            "_try_aggregate_string_function",
            "test_rename_axis_inplace",
            "test_subplots_sharex_axes_existing_axes",
            "test_caching",
            "test_setitem_clears_freq",
            "time_corr",
            "test_lookup_bool",
            "fp",
            "non_coercible_categorical",
            "test_categorical_coerces_datetime",
            "test_astype_categorical_to_categorical",
            "test_shallow_copy_changing_freq_raises",
            "test_where_series_timedelta64",
            "test_mode_intoverflow",
            "test_index_repr_in_frame_with_nan",
            "test_iloc_slice_fill_value",
            "test_options_get_engine",
            "test_is_extension_type",
            "test_getitem_setitem_float_labels",
            "_create_comparison_method",
            "mixed_float_frame",
            "test_nbytes",
            "time_read_store",
            "prod",
            "test_get_loc_single_level",
            "test_parse_public_s3_bucket_python",
            "_highlight_null",
            "test_infer_objects",
            "test_at_time_between_time_datetimeindex",
            "_wrap_setop_result",
            "_groups_or_na_fun",
            "test_valid_join_keys",
            "test_properties_secondly",
            "time_asof",
            "test_index_equal_values_too_far",
            "test_value_counts_datetime64",
            "maybe_set_size",
            "test_as_json_table_type_date_data",
            "test_compound_invert_op",
            "test_nanmin",
            "time_isin_long_series_short_values",
            "test_dti_tz_localize_ambiguous_times",
            "test_comp_ops_df_compat",
            "test_safe_import_non_existent",
            "crosstab",
            "read_hdf",
            "mock_clipboard",
            "test_margins_no_values_two_row_two_cols",
            "test_arith_coerce_scalar",
            "test_series_broadcasting",
            "test_to_csv_unicode_index",
            "test_encode_long_conversion",
            "test_dates",
            "_create_arithmetic_method",
            "test_loc_multiindex_indexer_none",
            "test_excel_sheet_size",
            "test_apply_corner",
            "test_dropna_intervals",
            "test_put_deprecated",
            "time_repeat",
            "test_timezone_comparaison_assert",
            "test_nancorr_kendall",
            "test_constructor_name",
            "time_frame_object_unequal",
            "test_nbytes_block",
            "test_map_with_tuples",
            "item",
            "test_deprecate_wrong_docstring",
            "test_nyse_wsj_commas_table",
            "test_join_dups",
            "test_constructor_empty_with_string_dtype",
            "test_interp_all_good",
            "test_parse_failure_unseekable",
            "test_from_codes_neither",
            "test_apply_simple_series",
            "test_pi_sub_isub_timedeltalike_hourly",
            "clip",
            "month_position_check",
            "test_copy_from_callable_insertion_method",
            "test_timestamp_timetz_equivalent_with_datetime_tz",
            "test_get_label_or_level_values_df_duplabels",
            "test_is_mixed_dtype",
            "test_invalid_double_precision",
            "test_slice_locs_indexerror",
            "test_transform_datetime_to_timedelta",
            "test_unpack_buffer",
            "test_divmod_series",
            "config_prefix",
            "test_bfill",
            "test_agg_timezone_round_trip",
            "test_is_not_extension_array_dtype",
            "time_get_value",
            "test_isna_lists",
            "test_fspath",
            "test_logical_ops_df_compat",
            "test_rename_by_series",
            "_unpickle_series_compat",
            "_from_ordinal",
            "test_repr_large",
            "_formatting_values",
            "_asof_function",
            "test_series_index_name",
            "dtype_fill_out_dtype",
            "_is_view",
            "test_pandas_dtype_valid",
            "test_rolling",
            "test_merge_categorical",
            "test_normalize_date_sub_types",
            "test_group_apply_once_per_group",
            "select_column",
            "get",
            "set_atom_timedelta64",
            "test_contains_interval",
            "test_more_flexible_frame_multi_function",
            "test_join_with_period_index",
            "test_with_tz",
            "arithmetic_win_operators",
            "test_parsing_timezone_offsets",
            "render_pep440_old",
            "test_construction_with_categorical_index",
            "_badobj_wrap",
            "test_dti_business_summary",
            "parse",
            "test_maybe_promote_datetime64_with_any",
            "_should_parse_dates",
            "_use_inf_as_na",
            "has_vertically_truncated_repr",
            "test_rolling_axis_count",
            "test_union_different_type_base",
            "_has_infs",
            "test_take_fill_value_with_timezone",
            "_in_travis_environment",
            "time_microsecond",
            "_from_sequence_of_strings",
            "test_n_duplicate_index",
            "test_empty_lines",
            "_local_timestamps",
            "test_date_time",
            "test_diff",
            "_selection_name",
            "test_numpy_unique",
            "test_nanosecond_timestamp",
            "_to_sql",
            "test_date_range_timestamp_equiv_explicit_pytz",
            "test_hash_array_errors",
            "test_read_dta18",
            "test_line_area_nan_df",
            "test_database_uri_string",
            "test_read_gbq_with_new_kwargs",
            "radviz",
            "test_astype_with_tz",
            "validate_periods",
            "test_combineSeries",
            "test_rolling_skew_eq_value_fperr",
            "delta",
            "test_excel_multiindex_index",
            "test_ewm_alpha",
            "test_error",
            "test_non_unique",
            "_convert_tuple",
            "test_missing_deprecate_kwarg",
            "categorical_index",
            "_has_valid_positional_setitem_indexer",
            "test_deprecated_get_dtype_counts",
            "time_lookup_iloc",
            "test_divmod",
            "time_count_level_mixed_dtypes_multi",
            "test_append_missing_column_proper_upcast",
            "test_api_per_method",
            "test_getitem_fancy_scalar",
            "test_get_indexer_non_unique",
            "use_numpy",
            "test_infer_row_shape",
            "time_add_overflow_b_mask_nan",
            "test_dti_add_series",
            "test_index_equal_values_close",
            "test_fillna_downcast",
            "test__isfinite",
            "_check_plot_works",
            "test_constructor_tuple",
            "_delegate_property_get",
            "as_ordered",
            "get_names_from_index",
            "test_ix_weird_slicing",
            "test_resample_anchored_monthstart",
            "test_tuples_have_na",
            "test_arg_for_errors_in_astype",
            "test_put_compression_blosc",
            "test_isin_multiIndex",
            "test_rsub",
            "reindex_like",
            "test_resample_nunique_preserves_column_level_names",
            "test_not_string",
            "time_frame_get_dtype_counts",
            "test_skip_row_with_quote",
            "time_boolean_rows_object",
            "test_handle_dict_return_value",
            "time_timedelta_plus_datetime",
            "test_slice_locs_with_ints_and_floats_succeeds",
            "_make_fixed_width",
            "_test_moments_consistency",
            "test_setitem_clear_caches",
            "test_floating_misc",
            "_get_nobs",
            "test_array_inference",
            "test_datetime_time",
            "test_categorical_category_dtype_unsorted",
            "set_default_names",
            "multiple_elts",
            "_write_file_close_tag",
            "test_resample_upsample",
            "get_cmdclass",
            "test_nunique",
            "test_negative_non_tick_frequency_descending_dates",
            "test_converter_index_col_bug",
            "time_different_numpy_functions",
            "test_guess_datetime_format_with_locale_specific_formats",
            "_all_not_none",
            "test_annual_upsample_cases",
            "test_meta_name_conflict",
            "test_setitem_None",
            "test_multiple_types",
            "test_repeated_column_labels",
            "time_cov_series",
            "test_categorial_datetimelike",
            "test_get_datevalue",
            "test_1d_fill_nonna",
            "test_skiprows_inference_empty",
            "test_asfreq_non_unique",
            "fix_version_from_branch",
            "test_mi_falsey_name",
            "test_greater_Raises_Value",
            "test_quantile_box",
            "astype",
            "test_write_infer",
            "is_full_slice",
            "test_join_non_int_index",
            "test_frame_getitem_setitem_boolean",
            "load_reduce",
            "to_hdf",
            "is_truncated",
            "test_is_bool_dtype_sparse",
            "test_replicate_describe",
            "test_shift",
            "test_get_standard_colors_no_appending",
            "test_divide_decimal",
            "test_numpy_compress",
            "test_constructor_coerce_float_valid",
            "time_convert_direct",
            "test_series_constructor_coerce_data_to_extension_dtype_raises",
            "test_shift_empty",
            "test_to_csv_unicode",
            "concat",
            "_compare_utc_to_local",
            "test_series_constructor",
            "test_swapaxes",
            "_get_interval",
            "_convert_to_side",
            "test_string_methods_dont_fail",
            "_check_align_fill",
            "test_tuple_warns",
            "test_from_codes_with_nan_code",
            "_write_regular_rows",
            "_prep_index",
            "test_constructor_start_end_with_tz",
            "get_versions",
            "test_union_sort_special_true",
            "test_clip_with_datetimes",
            "test_get_freq_code",
            "test_weeks_onoffset",
            "_block_shape",
            "set_closed",
            "indexables",
            "test_concat_tz_series_with_datetimelike",
            "test_raises_on_dtype_object",
            "test_td_floordiv_offsets",
            "test_iteration_and_str",
            "test_contains_moar",
            "test_append_empty",
            "test_ix_empty_list_indexer_is_ok",
            "test_td64arr_div_td64nat",
            "testPackUnicode",
            "test_interval_array_equal_start_mismatch",
            "_next_line",
            "test_union_not_cacheable",
            "_set_tz",
            "test_per_axis_per_level_doc_examples",
            "test_to_datetime_with_space_in_series",
            "_dir_additions",
            "time_unstack",
            "test_dt_timetz_accessor",
            "check_min_structure",
            "corr",
            "test_setitem_frame_float",
            "test_dti_constructor_with_fixed_tz",
            "dtype_format_for_platform",
            "_unstack_extension_series",
            "test_tuple_correct_keyerror",
            "get_block_values",
            "test_fancy_getitem_slice_mixed",
            "test_multiindex_setitem",
            "html",
            "test_array_equivalent",
            "test_name_repr_generic",
            "test_round_30min",
            "_dtype_to_stata_type",
            "highlight_null",
            "author_missing_data",
            "test_df_add_2d_array_rowlike_broadcasts",
            "time_read_json_lines",
            "parse_table_schema",
            "test_sortlevel",
            "_class_to_alias",
            "levels",
            "test_rule_code",
            "_set_with",
            "test_ax_plot",
            "test_resolution_string",
            "compress_group_index",
            "time_append_homogenous",
            "test_floating_index_doc_example",
            "test_large_difference_in_columns",
            "test_interpolate_akima",
            "test_to_numpy",
            "test_nunique_with_timegrouper",
            "test_to_csv_mixed",
            "test_datetime_shift_always_copy",
            "_validate_date_like_dtype",
            "test_density",
            "test_unstack_fill_frame_period",
            "test_adjoin_unicode",
            "test_nat_handling",
            "test_to_offset_leading_plus",
            "test_readonly_axis_zlib_to_sql",
            "set_ordered",
            "test_categorical_ordering",
            "get_rule_code_suffix",
            "test_codes_immutable",
            "test_indexer_caching",
            "test_empty_with_index_col_false",
            "test_repr_tuples",
            "test_empty_sequence_concat",
            "_align_frame",
            "test_timegrouper_with_reg_groups",
            "test_negative_skiprows",
            "test_strip_lstrip_rstrip_args",
            "test_get_loc_length_one_interval",
            "categories",
            "_downsample",
            "test_constructor_dict_of_tuples",
            "_get_prev_label",
            "test_week_without_day_and_calendar_year",
            "test_compression_zlib",
            "test_corner_cases",
            "sp_index",
            "test_take_fill_valid",
            "_skip_if_not_us_locale",
            "_check_divmod_op",
            "test_dataframe_box_false",
            "test_to_latex_multindex_header",
            "_offset_str",
            "test_apply_empty_infer_type",
            "test_encoding",
            "compare_sp_series_ts",
            "test_getitem_with_duplicates_indices",
            "test_asfreq_MS",
            "test_period_cons_mult",
            "test_to_datetime_bijective",
            "test_pivot_index_with_nan",
            "test_npoints",
            "test_datetime64_with_index",
            "test_is_unsigned_integer_dtype",
            "test_insert_index_bool",
            "_convert_listlike",
            "test_mixed_freq_irregular_first_df",
            "read_ext",
            "_init_dict",
            "test_fy5253_nearest_onoffset",
            "time_concat_empty_right",
            "_count_level",
            "time_dict_rename_both_axes",
            "test_read_from_s3_url",
            "test_to_string_complex_float_formatting",
            "test_set_index_custom_label_type_raises",
            "test_period_ordinal_week",
            "desc_no_period",
            "test_iloc_sparse_propegate_fill_value",
            "test_bad_apply_shape",
            "_read_header",
            "scatter",
            "set_codes",
            "test_fast_unique_multiple_list_gen_sort",
            "_infer_compression",
            "itemsize",
            "fields",
            "test_resample_anchored_ticks",
            "test_underlying_data_conversion",
            "idx",
            "test_pivot_table_multiple",
            "test_pivot_dtypes",
            "_add_numeric_methods_add_sub_disabled",
            "time_shape",
            "test_assert_almost_equal_iterable_values_mismatch",
            "test_ewmcorr_pairwise",
            "test_irregular_ts_shared_ax_xlim",
            "test_factorize_nan",
            "test_df_add_td64_columnwise",
            "test_unsupported_other",
            "test_translate",
            "test_sort_nat_values_in_int_column",
            "test_td_constructor_on_nanoseconds",
            "test_msgpacks_legacy",
            "test_reindex_doesnt_preserve_type_if_target_is_empty_index",
            "test_roundtrip_chunksize",
            "test_compare_unknown_type",
            "test_pipe_tuple",
            "_get_default_writer",
            "test_series_getitem_indexing_errors",
            "test_series_operators",
            "test_spss_usecols",
            "test_to_coo_bad_ilevel",
            "test_dti_shift_near_midnight",
            "test_constructor_scalar_inference",
            "test_setattr_column",
            "test_ngroup_groupby_not_col",
            "_set_labels",
            "time_read_uint64",
            "test_nth_multi_index_as_expected",
            "test_freq_conversion",
            "_maybe_resample",
            "test_1d_other_dtypes",
            "test_nonunicode_nonascii_alignment",
            "test_extract_series",
            "visit_Module",
            "test_boxplot_series",
            "testFixMap",
            "wrong_line",
            "test_plot_figsize_and_title",
            "test_constructor_default_index",
            "test_astype_cast_object_int",
            "_open_file_binary_write",
            "test_time_loc",
            "book",
            "test_length_one",
            "test_con_string_import_error",
            "test_inferred_dtype",
            "test_categorical_series_repr_datetime",
            "_generate_range_overflow_safe_signed",
            "test_setitem_tuple",
            "test_array_to_slice_conversion",
            "test_setitem_scalar",
            "get_corr_func",
            "test_to_datetime_overflow",
            "bad_colon_spacing",
            "test_rollforward",
            "test_validation",
            "test_guess_datetime_format_no_padding",
            "test_naneq",
            "test_infer_freq_custom",
            "test_td64arr_add_intlike",
            "test_unary_ops",
            "test_frame_any_all_group",
            "cumsum",
            "_where_standard",
            "test_slice_consolidate_invalidate_item_cache",
            "test_to_latex_midrule_location",
            "test_split_maxsplit",
            "test_single_mgr_ctor",
            "test_array_list",
            "test_json_normalize_errors",
            "test_frame_nonprintable_bytes",
            "test_factorize_dst",
            "test_expand_user",
            "test_to_timestamp_1703",
            "test_index_unique",
            "test_to_datetime_infer_datetime_format_consistent_format",
            "test_groupby_transform_rename",
            "test_where_series_bool",
            "test_ensure_index_from_sequences",
            "test_groupby",
            "test_coercion_with_setitem_and_series",
            "test_duplicate_level_names_access_raises",
            "_data",
            "test_header_multi_index_invalid",
            "test_start_time",
            "test_offset",
            "_subplots",
            "time_rank_string_cat_ordered",
            "test_agg_nested_dicts",
            "df2",
            "test_get_group",
            "test_timestamp_constructor_near_dst_boundary",
            "test_nanany",
            "test_dtype_on_merged_different",
            "test_getitem_listlike",
            "time_iteritems_indexing",
            "test_compare_series_interval_keyword",
            "_combine_lines",
            "test_empty_nonzero",
            "test_reindex_items",
            "test_join_multiindex_leftright",
            "test_concat_categorical_empty",
            "rand_",
            "test_constructor_same",
            "_insert_index",
            "test_unit_consistency",
            "test_to_latex_multiindex",
            "test_drop_names",
            "test_mixed_type_suffix",
            "_get_freq",
            "test_arith_integer_array",
            "test_ngroup_descending",
            "test_not_slice_like_arrays",
            "pprint_thing",
            "holder",
            "test_parse_public_s3_bucket_nrows_python",
            "register_index_accessor",
            "test_hist_df_with_nonnumerics",
            "test_comparison_tzawareness_compat",
            "test_skip_group_keys",
            "test_compression_warning",
            "test_rolling_quantile_interpolation_options",
            "test_is_datetime_arraylike",
            "test_to_html_with_col_space",
            "test_parse_date_all_fields",
            "test_default_date_conversion",
            "test_infer_output_shape_columns",
            "__rdivmod__",
            "_unbox_scalar",
            "test_loads_non_str_bytes_raises",
            "test_repr_html_wide",
            "test_constructor_unsortable",
            "test_formatting_values_deprecated",
            "test_iter_python_types",
            "test_duplicate_column_name",
            "test_ragged_apply",
            "simple_date_range_series",
            "__ne__",
            "test_maybe_mangle_lambdas_args",
            "test_iloc_getitem_dups",
            "test_tfoot_read",
            "mixed_frame",
            "test_minmax_timedelta64",
            "sort",
            "effective_dtype",
            "test_pi_add_offset_n_gt1",
            "test_get_level_values_box",
            "test_apply_corner_cases",
            "test_df_div_zero_int",
            "test_multitype_list_index_access",
            "test_float_comparison_bin_op",
            "test_ravel",
            "test_repr_np_nat_with_object",
            "test_to_datetime_tz",
            "time_infer_freq",
            "test_nonunique_raises",
            "validate_clip_with_axis",
            "sparse_reindex",
            "test_replace_int_to_int_chain",
            "test_dti_take_dont_lose_meta",
            "test_datetime_invalid_scalar",
            "date",
            "test_dataframe_constructor_from_dict",
            "test_pairwise_with_self",
            "tick_classes",
            "time_rank_ties",
            "test_groupby_grouper",
            "day_deltas",
            "period_code_item",
            "_can_hold_identifiers_and_holds_name",
            "test_from_records_decimal",
            "test_mixed_freq_second_millisecond",
            "time_replace",
            "test_take_pandas_style_negative_raises",
            "test_as_json_table_type_date_dtypes",
            "test_to_csv_defualt_encoding",
            "time_categorical_index_contains",
            "test_slice_locs_negative_step",
            "test_accessor_raises",
            "test_dti_custom_business_summary_dateutil",
            "signature_parameters",
            "test_constructor_spindex_dtype",
            "_infer_precision",
            "_get_layout",
            "test_corner",
            "test_assignment_fails",
            "test_unstack_bool",
            "test_tz_convert_corner",
            "_is_url",
            "test_tdi_add_overflow",
            "test_constructor_dict_timedelta_index",
            "test_casefold",
            "test_frame_setitem_slice",
            "test_interpolate_timedelta_index",
            "test_from_arrays",
            "diff",
            "test_slice_locs_not_sorted",
            "test_default_handler_raises",
            "test_categories",
            "test__cython_agg_general",
            "test_rename_axis_mapper",
            "visit_Subscript",
            "test_slice_floats2",
            "data_missing",
            "test_multi_index_header",
            "test_resample_dup_index",
            "test_result_types",
            "test_at_time",
            "_get_foo",
            "test_factorize_equivalence",
            "_parse_metadata",
            "test_scalar_comparison_tzawareness",
            "test_validate_ordered",
            "test_incomplete_first_row",
            "test_series_negate",
            "test_align_nocopy",
            "time_dropna_axis_mixed_dtypes",
            "_bar",
            "test_to_integer_array_inferred_dtype",
            "test_concat_dataframe_keys_bug",
            "test_to_html_float_format_no_fixed_width",
            "test_str_cat_align_mixed_inputs",
            "test_get_dummies",
            "test_to_sql_index_label",
            "test_empty_dtype_coerce",
            "_is_dtype_compat",
            "test_mod_offset",
            "test_default_separator",
            "test_rhs_alignment",
            "test_from_resampling_area_line_mixed",
            "test_rolling_apply",
            "_create_consistency_data",
            "hist",
            "test_replace_unicode_with_number",
            "test_interpolate_pchip",
            "test_swapped_columns",
            "test_recode_to_categories",
            "time_get_loc_non_unique",
            "test_with_kwargs",
            "pytables_hdf5_file",
            "test_pivot_table_not_series",
            "test_item_section",
            "time_dt_accessor",
            "_get_offset_day",
            "test_getitem_box_float64",
            "test_attribute_access",
            "test_series_from_json_to_json",
            "test_mixed_depth_drop",
            "test_bool_handling",
            "test_whitespace_lines",
            "test_dictwrapper_getattr",
            "test_unique",
            "extract_index",
            "time_iloc_slice",
            "test_astype_duplicate_col",
            "_get_combined_index",
            "test_assert_produces_warning_honors_filter",
            "test_construction_dti_with_mixed_timezones",
            "test_round_frac_just_works",
            "test_nanvar_all_finite",
            "test_join_sort",
            "test_boxplot_return_type",
            "test_dt_accessor_api_for_categorical",
            "test_select_dtypes",
            "apply_raw",
            "test_suppress_error_output",
            "test_frame_to_json_except",
            "draw",
            "interval_values",
            "no_period_multi",
            "test_inf",
            "test_invalid_terms",
            "test_constructor_from_categorical_with_dtype",
            "test_read_expands_user_home_dir",
            "test_unstack_preserve_dtypes",
            "time_isin_nans",
            "test_nan_fullcolumn",
            "test_unicode_encoding",
            "test_datelike",
            "test_tdi_shift_empty",
            "has_level_label",
            "test_incorrect_type_nested_map",
            "time_add_offset",
            "test_union_categoricals_sort_false",
            "test_hash_tuples_err",
            "test_masked_setitem",
            "agg_axis",
            "test_read_duplicate_index_implicit",
            "test_pairwise_with_series",
            "test_store_datetime_mixed",
            "all_index_generator",
            "test_round",
            "abs",
            "test_corr_pearson",
            "test_more_values",
            "test_groupby_complex",
            "test_recode_to_categories_large",
            "test_setitem_listlike",
            "pivot",
            "_get_fmtlist",
            "_add_timedeltalike_scalar",
            "test_unicode",
            "assert_series_equal",
            "_cat_compare_op",
            "time_stack",
            "latex_forced",
            "rfind",
            "test_to_csv_dups_cols",
            "test_interp_basic",
            "is_terminal",
            "test_deprecate_kwarg",
            "test_reindex_bool_pad",
            "_check_method",
            "test_date_range_with_tz",
            "test_int64_nocopy",
            "test_conv_annual",
            "spmatrix",
            "test_to_csv_from_csv1",
            "test_export",
            "_setup_build_doc",
            "examples_errors",
            "test_can_set_locale_invalid_get",
            "_protect_consolidate",
            "test_reduce_series_boolean",
            "test_from_tuples_iterator",
            "test_multi_index_names",
            "test_mode_numerical_nan",
            "reindex_axis",
            "test_symmetric_difference",
            "test_constructor_coerce_float_fail",
            "test_read_table_columns",
            "test_compare_str",
            "_scalar_from_string",
            "test_hide_single_index",
            "test_sparse_mi_max_row",
            "test_to_sql_series",
            "maybe_convert_dtype",
            "test_filter_corner",
            "test_listlike_setitem",
            "test_merge_on_datetime64tz_empty",
            "test_nanosecond_getitem_setitem_with_tz",
            "_get_ax",
            "test_read_infer",
            "other_closed",
            "makePeriodIndex",
            "_maybe_convert",
            "_get_unit",
            "test_decode_numeric_int",
            "test_nsmallest",
            "test_sparse_frame_fillna_limit",
            "test_uuid",
            "test_get_dummies_all_sparse",
            "str_get",
            "test_encode_dict_conversion",
            "_getitem_scalar",
            "_write_sortlist",
            "test_fromValue",
            "test_iloc_getitem_slice_dups",
            "test_frame_groupby_columns",
            "test_dict_compat",
            "test_skip_rows_bad_callable",
            "test_mangled_unnamed_placeholders",
            "_convert_to_ndarrays",
            "test_categorical_dtype_high_cardinality_numeric",
            "test_nested_scope",
            "test_read_write_dta10",
            "test_convert_preserve_all_bool",
            "test_values_consistent",
            "test_isna",
            "to_time",
            "time_write_store_table",
            "test_shift_empty_array",
            "after_nearest_workday",
            "_convert_expression",
            "get_test_data",
            "test_reindex_dups",
            "_setup_axes",
            "test_cython_group_transform_cumsum",
            "test_exponents_without_eng_prefix",
            "rank",
            "_maybe_remove",
            "test_no_na_values_no_keep_default",
            "gen_binary_data",
            "test_nan_to_nat_conversions",
            "time_store_repr",
            "test_range_float_union_dtype",
            "test_slice_iter",
            "test_assert_almost_equal_strings",
            "test_same_tz_min_max_axis_1",
            "setup",
            "test_performance_warning_for_poor_alignment",
            "test_dataframe_dummies_prefix_str",
            "test_get_callable_name",
            "test_subclass_sparse_transpose",
            "make_invalid_op",
            "test_infer_freq_business_hour",
            "to_string",
            "test_setitem_scalar_series",
            "_write_col_header",
            "test_maybe_promote_any_numpy_dtype_with_datetimetz",
            "test_constructor_list_like",
            "is_na",
            "test_excel_stop_iterator",
            "test_series_named_agg_duplicates_raises",
            "test_max_rows_eq_one",
            "test_spline",
            "is_string_like",
            "_validate_indexer",
            "test_datetime_invalid_index",
            "set_table_attributes",
            "test_constructor_datetime64arr_ok",
            "_join_unicode",
            "time_col_select_numpy_sum",
            "test_business_daily",
            "test_at_and_iat_set",
            "test_render_empty_dfs",
            "test_pivot_with_tuple_of_values",
            "test_take_coerces_list",
            "test_frame_from_json_bad_data",
            "test_assign_with_sparse_frame",
            "test_invalid_origin",
            "_get_op_result_fill_value",
            "test_difference_sort_incomparable",
            "test_generate_bins",
            "base",
            "_ndarray_values",
            "test_objarr_radd_str",
            "test_ser_flex_cmp_return_dtypes_empty",
            "test_concat_mixed_dtypes",
            "_wrap_agged_blocks",
            "_get_fill_indexer",
            "test_to_datetime_dt64s",
            "test_loc_coerceion",
            "test_empty_str_inp",
            "test_path",
            "test_c_engine",
            "test_check_many_exprs",
            "test_infer_tz_utc_localize",
            "_is_sqlalchemy_connectable",
            "test_duplicated_do_not_fail_on_wide_dataframes",
            "test_setitem_corner",
            "_isna_new",
            "test_count",
            "test_assert_almost_equal_shape_mismatch_override",
            "time_parse_today",
            "test_rolling_kurt_eq_value_fperr",
            "deltas_asi8",
            "test_groupby_resample_api",
            "time_series_align_int64_index",
            "holidays",
            "time_period_constructor",
            "_check_unsupported",
            "time_floats_with_dt_index",
            "setup_indices",
            "skip_numpy_object",
            "test_unstack_fill_frame_datetime",
            "test_kde_kwargs",
            "test_mean_datetimelike",
            "test_constructor_interval",
            "test_constructor_miscast_na_int_dtype",
            "test_to_tuples_na",
            "test_datetime_likes_nan",
            "test_numpy_round_nan",
            "test_assert_extension_array_equal_non_extension_array",
            "test_timegrouper_apply_return_type_value",
            "test_to_offset_pd_timedelta_invalid",
            "test_column_dups2",
            "test_too_many_names",
            "test_hash_equal",
            "test_union_categoricals_sort",
            "test_map_dict_subclass_without_missing",
            "test_transform_casting",
            "test_astype_str_float",
            "test_repr_roundtrip_raises",
            "time_query_datetime_index",
            "_run_test",
            "__hash__",
            "test_multiindex_header_skiprows",
            "test_interpolate_from_derivatives",
            "test_from_categorical_dtype_ordered",
            "init_osx_clipboard",
            "units",
            "_get_option",
            "rollforward",
            "dtype_str",
            "rpartition",
            "test_setitem_datetimeindex_tz",
            "test_ignore_empty_rows_when_inferring_header",
            "test_mode_str_obj",
            "test_table_styles",
            "test_style_by_column",
            "_minmax",
            "test_to_csv_path_is_none",
            "create_block_manager_from_arrays",
            "test_week_of_month_infer",
            "str_startswith",
            "test_multigroup",
            "is_copy",
            "test_int_name_format",
            "test_setitem_frame_mixed",
            "time_getitem_array",
            "test_datetime_understood",
            "get_node",
            "time_from_iso_format",
            "test_constructor_name_unhashable",
            "test_resample_entirly_nat_window",
            "get_group_levels",
            "time_dataframe_describe",
            "test_agg_over_numpy_arrays",
            "from_tuples",
            "test_rank_args_missing",
            "test_multiindex_slicers_non_unique",
            "test_rename_bug",
            "test_where_series_datetime64",
            "test_not_all_defaults",
            "test_mode_mixeddtype",
            "test_astype_specific_casting",
            "test_set_index_custom_label_type",
            "test_pickles",
            "test_index_col_empty_data",
            "test_constructor_dtype_timedelta64",
            "test_time_zone_aware_index",
            "test_transpose",
            "test_timestamp",
            "setup_cache",
            "assert_index_parameters",
            "test_get_loc_multiple_dtypes",
            "test_loc_frame",
            "test_ops_series",
            "test_to_timestamp_mult",
            "test_indexing_doesnt_change_class",
            "test_resample_loffset_arg_type",
            "test_infer_dtype_timedelta",
            "time_plot_regular",
            "time_nlargest",
            "test_datetime64_ops_nat",
            "test_set_ContextManager",
            "test_greaterEqual",
            "test_resample_fill_missing",
            "test_groupby_multiindex_categorical_datetime",
            "test_detect_string_na",
            "test_as_frame_columns",
            "test_astype_to_timedelta_unit",
            "test_slice_can_reorder_not_uniquely_indexed",
            "make_block_same_class",
            "test_equal",
            "test_chunk_whitespace_on_boundary",
            "test_type_coercion_at_construction",
            "_transform",
            "test_at_iat_coercion",
            "test_closed_empty",
            "test_frame_setitem_view_direct",
            "test_super_sub_symmetry",
            "_get_columns_formatted_values",
            "convert_from_missing_indexer_tuple",
            "test_append",
            "test_empty_series_add_sub",
            "test_get_group_grouped_by_tuple",
            "test_dt_round_tz_ambiguous",
            "test_constant_series",
            "test_spss_umlauts",
            "test_value_array_record_prefix",
            "test_maybe_convert_i8_nat",
            "test_is_datetimelike_array_all_nan_nat_like",
            "time_dtype_as_group",
            "sample",
            "test_iloc",
            "time_remove_unused_levels",
            "test_merge_datatype_categorical_error_raises",
            "test_parse_tz_aware",
            "get_json_no_auth",
            "maybe_box",
            "test_dropna_frame",
            "test_fillna_timedelta",
            "convert",
            "test_getitem_setitem_ellipsis",
            "test_git_version",
            "test_constructor_datetime_outofbound",
            "test_isna_numpy_nat",
            "_fill_value_matches",
            "test_usecols_single_string",
            "test_nat_comparisons_scalar",
            "time_frame_quantile",
            "_sub_nat",
            "test_simple_expr",
            "test_sort_index_multicolumn",
            "test_mixed_timezone_series_ops_object",
            "test_interleave_non_unique_cols",
            "test_to_string_no_index",
            "test_construction_quarter",
            "time_rename_both_axes",
            "test_grouped_hist_legacy2",
            "test_maybe_promote_int_with_float",
            "yield_not_documented",
            "test_merge_right_index_right",
            "test_regex_idempotency",
            "test_fill_value_corner",
            "test_to_records_datetimeindex_with_tz",
            "test_constructor_mixed_dtypes",
            "test_fancy_getitem",
            "test_series_non_unique_index",
            "list_of_lists",
            "test_corr_constant",
            "metadata",
            "test_cross_type_arithmetic",
            "test_type_error_multiindex",
            "_cython_operation",
            "test_select_dtypes_typecodes",
            "test_frame_series_agg_multiple_levels",
            "time_series_int",
            "test_date_index_query_with_NaT_duplicates",
            "test_shift_corner_cases",
            "deprecated",
            "rule_code",
            "test_reindex_series_add_nat",
            "_stringify_path",
            "test_frame_loc_callable_setitem",
            "sp_values",
            "test_inplace_return_self",
            "get_period_alias",
            "test_from_dtype",
            "to_arrays",
            "test_pivot_table_aggfunc_scalar_dropna",
            "test_replace_tzinfo",
            "test_series_datetime_index",
            "test_quarterly_resampling",
            "_arith_method_FRAME",
            "test_left_join_indexer",
            "test_arith_zero_dim_ndarray",
            "test_series_align_aware",
            "test_as_json_table_type_string_data",
            "test_replace_naive",
            "test_constructor_freq_mult_dti_compat",
            "as_matrix",
            "test_constructor_from_items",
            "time_regular",
            "test_passed_bar_colors",
            "test_merge_on_index_with_more_values",
            "test_comparison_flex_alignment_fill",
            "test_detect_console_encoding_fallback_to_locale",
            "test_construct_index",
            "test_series_to_json_except",
            "test_numpy_scalar_float",
            "test_bad_hook",
            "is_any_int_dtype",
            "test_cumcount_groupby_not_col",
            "time_now",
            "import_optional_dependency",
            "_coo_to_sparse_series",
            "test_upcast",
            "test_object",
            "test_logscales",
            "df_none",
            "test_isna_behavior",
            "_index_start",
            "test_to_excel_multiindex_nan_label",
            "set_use_numexpr",
            "time_series_drop_dups_int",
            "test_query_with_string_columns",
            "_to_original_callable",
            "nanmedian",
            "test_to_csv_date_format",
            "test_boxplot_colors",
            "should_show_dimensions",
            "test_td_mul_scalar",
            "test_right",
            "test_dataframe_nested",
            "test_math_div",
            "_get_window",
            "test_complex_cmp_ops",
            "test_td_rdiv_timedeltalike_scalar",
            "test_do_not_mangle_na_values",
            "test_unordered_same",
            "test_construct_from_string",
            "test_hash_pandas_object2",
            "_get_axis_name",
            "test_fillna_series_int64",
            "test_from_spmatrix_raises",
            "_join_multiline",
            "test_invalid_total_length_max_length_one",
            "test_sum_overflow",
            "test_bad_quote_char",
            "test_append_hierarchical",
            "assert_period_array_equal",
            "get_atom_data",
            "test_integer_positional_indexing",
            "test_from_product_index_series_categorical",
            "test_ngroup_distinct",
            "_print_as_set",
            "test_fails_on_no_datetime_index",
            "test_groupby_as_index_apply",
            "test_series_invert",
            "test_api_for_categorical",
            "test_get_numeric_data_extension_dtype",
            "set_locale",
            "test_unicode_dta_118",
            "test_tz_is_utc",
            "test_mixed_freq_alignment",
            "test_cannot_create_instance_of_stolen_buffer",
            "str_join",
            "time_startswith",
            "ensure_float",
            "test__get_dtype_sparse",
            "test_explicit_conversions",
            "time_to_timestamp",
            "test_duplicate_dates_indexing",
            "test_floats",
            "test_dtype_name_in_info",
            "time_pad",
            "test_compression_size",
            "test_crosstab_with_categorial_columns",
            "test_concat_all_na_block",
            "test_interpolate_spline_invalid_order",
            "test_interp_raise_on_all_object_dtype",
            "test_order_aggregate_multiple_funcs",
            "is_signed_integer_dtype",
            "test_loc_multiindex_incomplete",
            "assert_contains_all",
            "test_datelike_mode",
            "test_sunday_to_monday",
            "__enter__",
            "default_fill_value",
            "kde",
            "test_hongkong_tz_convert",
            "test_empty_usecols",
            "get_rows",
            "test_take_filling",
            "_need_convert",
            "test_examples4",
            "test_monthly_infer",
            "time_frame_dtypes",
            "time_itertuples_read_first",
            "test_custom_business_day_freq",
            "_set_is_copy",
            "_sort_labels",
            "_to_str_columns",
            "test_line_plot_period_frame",
            "test_copy_name2",
            "test_date_range_localize",
            "_tuplify",
            "test_builtins_apply",
            "test_int_array_comparison",
            "_create_sp_frame",
            "run_command",
            "_get_series_result_type",
            "_describe_option",
            "test_dt64arr_aware_sub_dt64ndarray_raises",
            "test_kind",
            "test_parr_ops_errors",
            "test_partial_string_timestamp_multiindex",
            "test_no_args_raises",
            "test_coerce_outside_ns_bounds_one_valid",
            "test_assert_not_almost_equal_dicts",
            "test_datapath",
            "test_rands_array_2d",
            "test_dot",
            "test_unstack_timezone_aware_values",
            "test_aaa_group_order",
            "peakmem_itertuples",
            "start",
            "test_read_csv_buglet_4x_multi_index",
            "_try_coerce_args",
            "test_is_dtype_no_warning",
            "test_td_floordiv_timedeltalike_scalar",
            "_hash_scalar",
            "time_from_numeric_str",
            "_check_is_partition",
            "float_frame",
            "time_nlargest_two_columns",
            "test_to_M8",
            "test_read_clipboard_infer_excel",
            "test_from_array_deprecated",
            "time_findall",
            "_generate_body",
            "test_tuple_warns_unhashable",
            "test_repr_embedded_ndarray",
            "test_clip",
            "test_xs_level_eq_2",
            "test_timedelta_plot",
            "test_dti_cmp_nat_behaves_like_float_cmp_nan",
            "_set_axis",
            "test_1",
            "_to_safe_for_reshape",
            "test_difference_sort_special_true",
            "test_mode_numerical",
            "test_slice_bounds_empty",
            "is_dtype_union_equal",
            "time_frame_int_mod",
            "_concat_same_type",
            "test_diff_neg_n",
            "index",
            "test_astype_assignment_with_dups",
            "test_agg_item_by_item_raise_typeerror",
            "test_dti_from_tzaware_datetime",
            "test_intersection_equal",
            "test_header_not_first_line",
            "test_drop_level",
            "test_intersection_bug",
            "test_group_var_large_inputs",
            "test_scalar_ops",
            "test_same_name_scoping",
            "test_difference_incomparable",
            "test_invalid_xy_args",
            "test_repr_big",
            "test_rank_descending",
            "test_to_object_array_width",
            "test_invalid_index_types",
            "test_resample_irregular_sparse",
            "test_comparison",
            "test_dt_subclass_add_timedelta",
            "peakmem_read_json_lines",
            "test_empty_with_mangled_column_pass_dtype_by_indexes",
            "test_compare_len1_raises",
            "test_repr_name_coincide",
            "test_convert_pandas_type_to_json_field_float",
            "test_sort_column_level_and_index_label",
            "test_to_period_quarterlyish",
            "test_from_list_dtype",
            "python_parser_only",
            "test_pivot_datetime_tz",
            "hist_frame",
            "test_basic_drop_first_NA",
            "test_len",
            "test_frame_describe_multikey",
            "df_main_dtypes",
            "test_duplicate_multiindex_codes",
            "test_concat_tz_series",
            "test_bool_ops_raise_on_arithmetic",
            "time_align_level",
            "test_to_datetime_barely_out_of_bounds",
            "test_zip_error_multiple_files",
            "test_filter_against_workaround",
            "test_roll_yearday2",
            "test_read_csv_chunked_download",
            "_format_space",
            "test_constructor_nano",
            "test_assert_almost_equal_pandas",
            "_wrap_joined_index",
            "test_from_product",
            "test_cast_internals",
            "test_apply_keep_sparse_dtype",
            "time_frame_dot",
            "test_merge_on_ints_floats",
            "_get_ax_legend",
            "test_next_monday_or_tuesday",
            "time_plot_irregular",
            "test_validate_stat_keepdims",
            "test_inplace_ops_identity2",
            "test_dti_representation_to_series",
            "test_repr_truncation",
            "remove_flags_docstring",
            "test_constructor_nat",
            "test_assert_almost_equal_unicode",
            "test_spline_extrapolate",
            "validate_categories",
            "test_from_iterator",
            "test_multi_index_no_level_names_implicit",
            "test_multiindex_symmetric_difference",
            "union_many",
            "test_freq_infer_raises",
            "test_promote_datetime_date",
            "_get_axes",
            "test_get_value",
            "get_indexers_list",
            "test_get_indexer2",
            "test_append_list_of_series_dicts",
            "test_empty_string_raises",
            "test_numpy_argmax_deprecated",
            "test_array_interface",
            "test_is_non_overlapping_monotonic",
            "test_dti_construction_nonexistent_endpoint",
            "test_agg_dict_parameter_cast_result_dtypes",
            "test_grouping_labels",
            "test_multi_index_blank_df",
            "test_maybe_convert_i8",
            "_end_apply_index",
            "test_day_of_month",
            "assert_equal",
            "test_out_of_bounds_integer_value",
            "time_append_int_list",
            "test_register_option",
            "test_old_import_warns",
            "test_is_scalar_numpy_arrays",
            "test_construction_outofbounds",
            "test__get_dtype",
            "test_unstack_multiple_hierarchical",
            "test_coercion_with_setitem_and_dataframe",
            "test_to_html_justify",
            "test_to_period_nofreq",
            "test_getitem_dupe_cols",
            "test_groupby_reindex_inside_function",
            "test_to_html_with_empty_string_label",
            "test_constructor_pass_none",
            "test_cummax",
            "initialize_options",
            "test_compat",
            "test_convert_dates",
            "test_date_boolean",
            "test_encoding_non_utf8_multichar_sep",
            "test_mixed_depth_pop",
            "test_rolling_corr_cov",
            "iteritems",
            "test_categorical_zeroes",
            "test_resample_empty_dataframe",
            "test_bar_align_mid_vmin_vmax_clipping",
            "_get_resampler",
            "test_nan_columnname",
            "test_join_mixed_non_unique_index",
            "test_as_index_series_column_slice_raises",
            "test_mod_timedelta64",
            "test_value_counts",
            "test_mask_with_boolean_raises",
            "test_sort_values_na_position",
            "test_dti_summary",
            "test_bool_uint",
            "test_interp_limit_forward",
            "test_merge_by_col_tz_aware",
            "_concat_compat",
            "test_from_sparse_dtype",
            "test_rounding",
            "_merge_blocks",
            "test_raise_on_find_unsupported_value",
            "_shallow_copy",
            "_values_for_factorize",
            "is_datetime64_ns_dtype",
            "labels",
            "name",
            "makeUnicodeIndex",
            "asof",
            "test_get_dummies_dont_sparsify_all_columns",
            "test_parse_integers_above_fp_precision",
            "test_dropna_preserve_name",
            "test_uint64_overflow",
            "test_skip_row_with_newline",
            "lexsort_indexer",
            "test_check_label_or_level_ambiguity_df",
            "time_different_offset",
            "test_ops_ndarray",
            "test_period_array_freq_mismatch",
            "test_integer_array_constructor_none_is_nan",
            "test_where_index_datetime64tz",
            "test_drop_duplicates_bool",
            "test_reindex_level_partial_selection",
            "test_get_offset_name",
            "_get_data_from_filepath",
            "_aggregate_generic",
            "time_pivot_table_categorical",
            "_apply_columns",
            "test_CategoricalAccessor_categorical_deprecation",
            "test_unstack_level_name",
            "test_frame_select",
            "test_constructor_dtypes_to_object",
            "test_resample_dst_anchor",
            "concat_same_type",
            "test_loc_duplicates",
            "test_compare_custom_object",
            "test_read_hdf_generic_buffer_errors",
            "test_concat_period_multiple_freq_series",
            "putmask",
            "test_sort_datetimes",
            "copy",
            "str_findall",
            "test_median_empty_bins",
            "test_pickle_v0_15_2",
            "_create_join_index",
            "test_td_rsub_mixed_most_timedeltalike_object_dtype_array",
            "test_finder_monthly",
            "_check_cast",
            "test_rolling_cov_diff_length",
            "_can_use_numexpr",
            "is_signed_integer",
            "resample",
            "test_stack_mixed_dtype",
            "test_iloc_setitem_dups",
            "test_set_index",
            "test_get_item",
            "test_custom_repr",
            "test_read_tarfile",
            "test_has_duplicates",
            "ensure_index_from_sequences",
            "time_add_overflow_arr_mask_nan",
            "test_series_add_tz_mismatch_converts_to_utc_duplicate",
            "test_dti_add_offset_index",
            "test_drop_labels_or_levels_series",
            "test_getitem_with_datestring_with_UTC_offset",
            "test_constructor_mix_series_nonseries",
            "test_subplots_timeseries_y_axis",
            "test_mixed_type_join_with_suffix",
            "test_fillna_datetime64tz",
            "test_nan_to_missing_value",
            "test_multiby_indexed",
            "test_resample_axis1",
            "test_negate_lt_eq_le",
            "test_to_datetime_utc_true_with_series_single_value",
            "test_parse_time_quarter_with_dash_error",
            "test_nan_stays_float",
            "boxplot_frame_groupby",
            "test_rename_positional",
            "test_bins_not_monotonic",
            "test_to_datetime_cache_scalar",
            "test_as_array_datetime_tz",
            "test_add_sub_nat",
            "test_resample_dtype_preservation",
            "cat_safe",
            "time_frame_nunique",
            "test_set_incompatible_types",
            "test_intersection_name_preservation2",
            "test_assign_dependent",
            "test_parsers_quarter_invalid",
            "_assert_tzawareness_compat",
            "test_pi_cmp_nat",
            "test_unique_ordered",
            "test_bad_engine_raises",
            "has_expanded_repr",
            "test_range_closed",
            "test_resample_ohlc",
            "test_sub_offset",
            "test_unstack_fill",
            "test_margins_dtype_len",
            "test_append_new_columns",
            "test_where_tz",
            "test_excel_010_hemstring",
            "set_files",
            "sample_values",
            "test_line_plot_period_series",
            "test_integer_arithmetic",
            "test_read_json_table_orient",
            "test_dups_fancy_indexing",
            "test_rank_tie_methods_on_infs_nans",
            "_is_ts_plot",
            "test_groupby_nat_exclude",
            "test_dt64_mul_div_numeric_invalid",
            "time_isnull",
            "_write_cell",
            "axis",
            "test_get_schema2",
            "test_is_overlapping_endpoints",
            "tz_naive_fixture",
            "test_maybe_infer_to_datetimelike_df_construct",
            "test_replace2",
            "test_convert_infs",
            "no_description",
            "test_slicing_directly",
            "test_to_hierarchical",
            "test_maybe_promote_float_with_float",
            "test_subclass_align",
            "test_index_equal_category_mismatch",
            "describe",
            "test_rename_objects",
            "_string_data_error",
            "check_pow",
            "test_thorough_mangle_columns",
            "test_secondary_y_mixed_freq_ts_xlim",
            "test_series_add_tz_mismatch_converts_to_utc",
            "test_xs",
            "test_dataframe_insert_column_all_na",
            "test_set_categories_rename_less",
            "test_constructor_int64_nocopy",
            "test_index_tolerance",
            "test_str_cat_raises_intuitive_error",
            "insert_statement",
            "test_tz_localize_ambiguous",
            "test_iloc_getitem_neg_int_can_reach_first_index",
            "test_append_empty_frame_to_series_with_dateutil_tz",
            "test_mixed_integer",
            "test_different",
            "test_construction_from_replaced_timestamps_with_dst",
            "test_multiindex_objects",
            "test_to_csv_string_with_lf",
            "_update_inplace",
            "peakmem_read_json_lines_concat",
            "is_",
            "gen_of_str",
            "test_datetime_with_tz_dtypes",
            "test_to_string_name",
            "testRaw",
            "test_set_reset",
            "split_and_operate",
            "test_period_index_date_overflow",
            "len",
            "is_datetime64_dtype",
            "find_common_type",
            "test_constructor_single_str",
            "test_rank_args",
            "test_character_overlap",
            "nunique",
            "test_timestamp_tz_localize_nonexistent_shift_invalid",
            "test_prod_numpy16_bug",
            "test_align_nested_unary_op",
            "test_copy_index_name_checking",
            "_is_deprecated",
            "test_title",
            "test_put_compression",
            "_check_for_locals",
            "_excel2num",
            "test_read_one_empty_col_with_header",
            "prop",
            "test_quantile_interpolation",
            "test_temporary_file",
            "time_comment",
            "maybe_promote",
            "array_equivalent",
            "inferred_type",
            "_get_adjustment",
            "_reindex_columns",
            "whitelist_method_generator",
            "test_to_hdf_multiindex_extension_dtype",
            "test_merging_with_bool_or_int_cateorical_column",
            "hide_index",
            "test_setitem_same_ordered_rasies",
            "_validate_freq",
            "test_constructor_dtype_nocast_view",
            "test_joins",
            "time_reindex_both_axes",
            "narrow_multi_index",
            "test_pytables_native_read",
            "test_bool_header_arg",
            "test_read_csv_compat",
            "random_state",
            "test_fwf_compression",
            "test_copy_astype",
            "test_tuple_with_strings",
            "test_frame_iloc_callable",
            "decons_obs_group_ids",
            "test_cut_pass_series_name_to_factor",
            "test_iadd",
            "test_csv_to_string",
            "time_mi_series",
            "test_line_continuation",
            "test_from_records_bad_index_column",
            "test_empty_with_nrows_chunksize",
            "test_value_counts_unique_nunique_null",
            "examples_source_code",
            "_use_dynamic_x",
            "should_store",
            "test_to_html_multiindex_odd_even_truncate",
            "test_color_and_style_arguments",
            "test_where_unsafe_float",
            "_apply_index_days",
            "test_constructor_from_too_large_array",
            "test_searchsorted_numeric_dtypes_vector",
            "utc_fixture",
            "test_radd",
            "test_slice_locs_with_interval",
            "_engine_builder",
            "test_timestamp_invalid_key",
            "test_fancy_index_int_labels_exceptions",
            "set_levels",
            "test_invalid_logscale",
            "test_filter",
            "test_max_str_len",
            "test_12659",
            "test_from_product_empty_three_levels",
            "test_constructor_subclassed_datetime",
            "test_should_cache",
            "test_weekly_resample_buglet",
            "_get_hashtable_algo",
            "test_from_buffer",
            "join_type",
            "test_replace_with_empty_list",
            "_set_formats_and_types",
            "_border_style",
            "test_union_categoricals_ordered",
            "_convert_to_protection",
            "test_groupby_return_type",
            "test_sql_open_close",
            "maybe_color_bp",
            "_maybe_null_out",
            "test_int64_overflow_moar",
            "test_subtype_integer",
            "test_dti_to_pydatetime",
            "test_weekofmonth_onoffset",
            "test_slicing_and_getting_ops",
            "test_anchored_lowercase_buglet",
            "test_none_coercion_loc_and_dataframe",
            "test_cumprod",
            "test_is_list_like",
            "test_parse_delimited_date_swap",
            "time_sort_index",
            "data_orientation",
            "test_extract_expand_False",
            "test_normalize",
            "visit_List",
            "test_read_data_list",
            "test_expanding_count",
            "time_rank_string_cat",
            "test_to_dict_index_not_unique_with_index_orient",
            "time_shift",
            "_cython_agg_blocks",
            "test_date_index_query",
            "test_categorical_equal_codes_mismatch",
            "test_construct_timestamp_preserve_original_frequency",
            "test_join_self",
            "test_series_to_categorical",
            "test_reindex_multi",
            "_write_formats",
            "test_drop_by_numeric_label_raises_missing_keys",
            "test_ix_assign_column_mixed",
            "test_cast_j_int",
            "test_ser_flex_cmp_return_dtypes",
            "nblocks",
            "test_apply_issues",
            "_set_default_format",
            "leaf_size",
            "test_take_negative",
            "test_non_unique_invalid",
            "bad_complex_decoder",
            "test_simple_in_ops",
            "repeat",
            "test_count_nonnumeric_types",
            "_preprocess_data",
            "test_read_csv_gcs",
            "test_ix_multi_take_multiindex",
            "add_suffix",
            "_maybe_match_name",
            "_get_series_list",
            "test_series_getitem_multiindex_xs_by_label",
            "read_axes",
            "test_no_cast",
            "test_categorical_order",
            "test_get_indexer_array",
            "time_tz_convert",
            "view",
            "test_constructor_datelike_coercion",
            "test_header_names_backward_compat",
            "test_on_specialized_type",
            "time_unique_seconds_and_unit",
            "test_assert_numpy_array_equal_value_mismatch4",
            "mdiffs",
            "time_frame_float_mod",
            "test_na_values_with_cache",
            "test_constructor_timedelta",
            "test_decode_bad_string",
            "test_assert_not_almost_equal_numbers_with_zeros",
            "set_kind",
            "test_record_prefix",
            "test_timedelta_conversions",
            "read_data",
            "test_getitem_datetime",
            "test_setitem_iloc_scalar_single",
            "_hashed_indexing_key",
            "_format_multicolumn",
            "to_decimal",
            "test_tolerance",
            "test_astype_conversion",
            "test_is_overlapping_trivial",
            "test_groupby_2d_malformed",
            "_parser_dispatch",
            "test_drop_not_lexsorted",
            "test_hist_single_row",
            "time_read_pickle",
            "test_partial_boolean_frame_indexing",
            "get_group_index_sorter",
            "test_parsers_month_freq",
            "default_index",
            "test_to_string_header",
            "test_replace_series_datetime_datetime",
            "colorconverter",
            "test_upcast_error",
            "test_constructor_dtype_str_na_values",
            "test_replace_series_dict",
            "test_array_ufunc_series",
            "test_closed_min_max_minp",
            "test_boolean_indexing",
            "test_get_schema",
            "test_pivot_with_tz",
            "test_pivot_empty",
            "empty_value",
            "_convert_params",
            "test_astype_empty_constructor_equality",
            "test_getitem_overload",
            "setitem",
            "time_iloc_scalar",
            "test_inf_handling",
            "_convert_key",
            "get_expected_pow_result",
            "python_engine",
            "test_getitem_negative_out_of_bounds",
            "test_overflow_on_construction",
            "test_flush",
            "__instancecheck__",
            "test_bar_align_mid_all_pos",
            "test_dict_deprecate_kwarg",
            "_check_cython_group_transform_cumulative",
            "test_filter_with_axis_in_groupby",
            "test_hashtable_factorize",
            "test_concat_categorical",
            "new_child",
            "test_timeseries_preepoch",
            "test_merge_join_different_levels",
            "compare_frame_cat_and_float",
            "_prep_window",
            "test_create_table",
            "test_object_array_eq_ne",
            "_axify",
            "test_concat_inner_join_empty",
            "test_ragged_count",
            "_test_compression",
            "test_any_all_extra",
            "df_ambig",
            "test_intersection2",
            "_get_cythonized_result",
            "_get_axis_number",
            "test_append_with_different_block_ordering",
            "get_chunk",
            "test_symmetric_difference_mi",
            "test_append_different_columns",
            "test_mpl_compat_hack",
            "generate_table",
            "test_to_dense",
            "test_setitem_fancy_mixed_2d",
            "all_compare_operators",
            "test_no_legend",
            "test_infer_s3_compression",
            "test_basic_frame_alignment",
            "test_set_index_pass_single_array",
            "test_astype_object_tz",
            "_get_overlap_public_nat_methods",
            "time_dir_strings",
            "test_timedelta_ops_with_missing_values",
            "test_read_csv_no_index_name",
            "test_constructor_sanitize",
            "test_drop_table",
            "time_from_unit",
            "_apply_style_colors",
            "_post_plot_logic_common",
            "test_uneven_length_cols",
            "test_bday_near_overflow",
            "test_invalid_flavor",
            "test_where_float64",
            "apply_index",
            "test_searchsorted_monotonic",
            "test_freq_setter_deprecated",
            "test_keep_default_na",
            "test_search_sorted_datetime64_list",
            "test_categorical_dtype",
            "test_replace_for_new_dtypes",
            "test_find_nan",
            "assert_almost_equal",
            "test_to_timestamp_tz_arg_dateutil",
            "reset_testing_mode",
            "test_format_sparse_display",
            "test_fillna_integer_limit",
            "test_get_default",
            "test_merge_two_empty_df_no_division_error",
            "test_merge_nan_right",
            "test_ewmcov",
            "_info_axis",
            "test_ser_cmp_result_names",
            "test_setitem_float_labels",
            "expected_html",
            "test_no_header_prefix",
            "test_unstack_bug",
            "test_regex_replace_dict_nested_gh4115",
            "test_as_json_table_type_int_data",
            "array_dtype",
            "test_simple_normalize_with_separator",
            "test_frame_loc_callable_labels",
            "_maybe_cache_changed",
            "test_searchsorted_sorter",
            "get_attr",
            "test_aggregate_with_nat_size",
            "test_repr_truncates_terminal_size",
            "_needs_i8_conversion",
            "test_setitem_slice_array",
            "test_delta_to_nanoseconds_error",
            "test_construction_int_rountrip",
            "test_set",
            "test_binary_ops",
            "test_multilevel_consolidate",
            "test_isin_dict",
            "test_rename_set_name_inplace",
            "generate_value_label",
            "_check_column_names",
            "validate_indices",
            "test_concat_different_kind",
            "_fill",
            "test_combine_first_with_asymmetric_other",
            "test_select",
            "test_str_cat_align_indexed",
            "_parse_suffix",
            "test_stack_ints",
            "test_duplicate_level_names",
            "test_missing",
            "test_set_change_dtype",
            "test_constructor_with_datetime_tz",
            "test_remove",
            "test_last_raises",
            "test_store_datetime_fractional_secs",
            "test_info_memory_usage_bug_on_multiindex",
            "test_infer_output_shape_listlike_columns",
            "test_std_var_pass_ddof",
            "test_interpolate_index_values",
            "test_big_print",
            "test_pyint_engine",
            "test_infer_dtype_from_datetime",
            "test_observed_groups_with_nan",
            "_add_numeric_methods",
            "_set_name",
            "test_datetime_cut_roundtrip",
            "test_bar_log_subplots",
            "test_count_with_datetimelike",
            "has_doubly_truncated_repr",
            "test_parse_bool",
            "test_skip_row_with_newline_and_quote",
            "test_handle_overlap",
            "test_extractall_stringindex",
            "_normalize",
            "_reorder_by_uniques",
            "test_reindex_corner",
            "time_from_np_timedelta",
            "test_is_monotonic",
            "test_values_compatibility",
            "time_frame_repr_wide",
            "test_apply_large_n",
            "_coerce_scalar_to_index",
            "test_nargsort",
            "get_ftypes",
            "_convert_to_fill",
            "test_interval_array_equal_end_mismatch",
            "test_no_tz",
            "test_infinity_sort",
            "parameter_desc",
            "test_nd_raises",
            "test_repr_array_long",
            "test_observed_perf",
            "test_maybe_mangle_lambdas_passthrough",
            "_assert_same_contents",
            "round_trip_pickle",
            "test_info",
            "test_excel_read_buffer",
            "test_usecols_subset_names_mismatch_orig_columns",
            "line",
            "needs_filling",
            "astype_nansafe",
            "test_convert_accepts_unicode",
            "test_concat_bug",
            "df_copy_function",
            "test_assert_numpy_array_equal_bad_type",
            "test_uses_first_kind",
            "groups",
            "test_frame_from_list_subclass",
            "test_unicode_longer_encoded",
            "test_drop_nonunique",
            "_set_ticks_props",
            "kind",
            "period_range",
            "test_combine_first_timedelta",
            "test_ExcelWriter_dispatch",
            "test_decode_from_unicode",
            "test_0d_array",
            "test_conversion",
            "test_merge_equal_cat_dtypes2",
            "test_series_partial_set_period",
            "set_table",
            "test_number_mode",
            "test_parsing_valid_dates",
            "test_join_index_series",
            "test_apply_reduce_Series",
            "_decide_output_index",
            "test_sparse_frame_unstack",
            "test_groupby_whitelist",
            "__rtruediv__",
            "test_infer_dtype_all_nan_nat_like",
            "recons_labels",
            "test_binops",
            "test_dti_tz_localize_bdate_range",
            "test_reset_index_multiindex_col",
            "time_write_store_mixed",
            "test_monthly",
            "test_fillna_nat",
            "test_series_at",
            "test_groupby_apply_identity",
            "first",
            "test_datetime_count",
            "test_crosstab_dup_index_names",
            "_get_pretty_string",
            "test_coercion_with_loc_setitem",
            "__init__",
            "test_td64arr_div_td64_ndarray",
            "test_constructor_with_index",
            "time_groupby_apply_dict_return",
            "_do_select_columns",
            "test_frame_mixed_depth_get",
            "test_array_numpy_labelled",
            "_apply_rule",
            "test_lower_int_prec_count",
            "test_store_index_name_numpy_str",
            "test_skiprows_slice",
            "adjoin",
            "get_schema",
            "time_reindex_columns",
            "tz_convert",
            "test_n_error",
            "check_binary_arith_op",
            "test_crosstab_dropna",
            "test_2d_datetime64",
            "get_indexer_for",
            "test_assert_aliases_deprecated",
            "_cast_to_stata_types",
            "test_merge_non_unique_period_index",
            "_handle_truncated_float_vec",
            "test_value_counts_with_nan",
            "_get_format_datetime64_from_values",
            "test_duplicate_meta_data",
            "test_series_loc_getitem_fancy",
            "test_wide_repr_wide_long_columns",
            "test_format_kwarg_in_constructor",
            "test_method_signatures",
            "test_compare_2100",
            "makeTimeSeries",
            "test_repr_mixed",
            "test_set_index_nan",
            "test_reindex_non_na_fill_value",
            "time_iterrows",
            "test_nonnumeric_exclude",
            "test_to_dict",
            "test_groupby_levels_and_columns",
            "_restrict_to_columns",
            "test_compare_timedelta_ndarray",
            "autocorrelation_plot",
            "test_rename_mi",
            "test_series_tz_localize_nonexistent",
            "test_subtype_datetimelike",
            "test_dict_entries",
            "test_timedelta_invalid_key",
            "test_split_noargs",
            "dt64arr_to_periodarr",
            "cartesian_product_for_groupers",
            "test_no_overlap_more_informative_error",
            "test_empty_array",
            "test_intersection_monotonic",
            "test_invalid_dialect",
            "test_basic_names",
            "_infer_daily_rule",
            "visit_NameConstant",
            "test_chained_union",
            "test_catch_too_many_names",
            "_na_ok_dtype",
            "test_series_grouper_noncontig_index",
            "test_path_pathlib_hdfstore",
            "_get_xlim",
            "test_as_json_table_type_int_dtypes",
            "test_encode_double_tiny_exponential",
            "_box_item_values",
            "test_delete_slice",
            "test_view_with_args_object_array_raises",
            "empty_index",
            "check_array",
            "test_replace_doesnt_replace_without_regex",
            "testArraySize",
            "get_result_as_array",
            "apply_wraps",
            "ts1",
            "test_get_loc_nat",
            "convert_rows_list_to_csv_str",
            "test_unstack_period_series",
            "test_good_class",
            "test_at_time_tz",
            "test_tdi_shift_nonstandard_freq",
            "test_maxbuffersize_bufferfull",
            "test_converters",
            "test_quantile_raises",
            "test_timeseries_periodindex",
            "register_option",
            "test_tricky_container_to_bytes_raises",
            "test_moment_functions_zero_length",
            "test_drop_tz_aware_timestamp_across_dst",
            "test_nan_string",
            "time_reindex_dates",
            "test_categorical_series_repr_timedelta",
            "test_all_offset_classes",
            "test_compare_hour01",
            "test_to_timedelta_invalid",
            "test_agg_regression1",
            "_convert_obj",
            "test_union_categorical",
            "test_item_subsection",
            "test_union_sort_other_empty",
            "encode",
            "test_slice",
            "test_info_max_cols",
            "test_index_dupes_contains",
            "test_usecols_int",
            "_pad_bytes",
            "test_nat_converters",
            "test_round_issue",
            "split",
            "test_series_put_names",
            "test_constructor_no_levels",
            "tokenize_string",
            "backfill_1d",
            "test_loc_getitem_setitem_integer_slice_keyerrors",
            "test_tdi_sub_integer_array",
            "_check_compatible_with",
            "test_fancy_setitem_int_labels",
            "test_constructor_from_series_freq",
            "test_to_coo_integer_names_integer_row_levels_nosort",
            "test_series_invalid_type",
            "test_next_workday",
            "test_conv_hourly",
            "test_duplicates",
            "get_api_items",
            "test_merge_on_datetime64tz",
            "test_alias_to_unit_bad_alias_raises",
            "test_none_comparison",
            "test_multiindex_compare",
            "test_partial_set_empty_series",
            "test_list_numpy_float",
            "test_from_frame_invalid_names",
            "test_seaborn",
            "test_invalid_input",
            "_get_val_at",
            "simple_frame",
            "test_df_string_comparison",
            "has_index_names",
            "test_cant_fill_missing_dups",
            "use_inf_as_na_cb",
            "test_stack_datetime_column_multiIndex",
            "test_pass_array",
            "test_duplicated_drop_duplicates_index",
            "test_cast_NA_to_bool_raises_error",
            "test_period_nat_comp",
            "test_constructor_string_element_string_type",
            "test_round_nonstandard_freq",
            "test_pivot_number_of_levels_larger_than_int32",
            "flags",
            "test_astype_extension_dtypes",
            "test_parsers_nat",
            "test_apply_concat_preserve_names",
            "get_level_lengths",
            "is_unsigned_integer",
            "time_groupby_ordered_nosort",
            "_require_min_periods",
            "test_early_truncation",
            "test_spline_smooth",
            "test_excel_date_datetime_format",
            "test_repr_html_long_multiindex",
            "test_fwf_regression",
            "test_field_access_localize",
            "test_binary_ufunc_other_types",
            "test_to_json_categorical_index",
            "test_get_last_bday",
            "total_seconds",
            "test_index_type_coercion",
            "test_concat_series_partial_columns_names",
            "test_shallow_nested",
            "time_operation",
            "test_iter_python_types_datetime",
            "test_usecols",
            "_get_col_names",
            "test_take_categorical",
            "test_non_datetime_index",
            "test_partial_slicing_with_multiindex",
            "get_sheet_by_name",
            "test_apply_non_numpy_dtype",
            "test_hist_non_numerical_raises",
            "test_where_unsafe_int",
            "check_results",
            "test_to_csv_new_dupe_cols",
            "test_insert_benchmark",
            "test_skiprows_slice_long",
            "to_native_types",
            "test_from_inferred_categories",
            "test_properties",
            "s_main_dtypes",
            "test_ambiguous_warns",
            "test_representation",
            "test_boundary_datetimelike",
            "test_pipe_failures",
            "test_groupby_function_tuple_1677",
            "test_multiple_ouput_binary_ufuncs",
            "test_select_dtypes_not_an_attr_but_still_valid_dtype",
            "test_union_from_iterables",
            "test_excel_multiindex_columns_and_index_true",
            "test_float64_factorize",
            "_assert_not_almost_equal",
            "test_td64arr_add_offset_index",
            "test_file_like",
            "test_drop_duplicates_categorical_bool",
            "test_many_columns",
            "test_range_bug",
            "test_round_trip_valid_encodings",
            "test_reading_all_sheets",
            "assert_range_equal",
            "test_append_dtype_coerce",
            "_generate_range",
            "check_fun",
            "test_invalid_type_for_operator_raises",
            "__setstate__",
            "test_mean_excludeds_datetimes",
            "test_maybe_promote_dimensions",
            "test_concat_aligned_sort_does_not_raise",
            "__rsub__",
            "test_integer_overflow_bug",
            "test_setitem_boolean_mask",
            "test_compatible_inconsistent_pairs",
            "test_na_values_keep_default",
            "test_td_op_timedelta_timedeltalike_array",
            "test_map_with_dict_or_series",
            "peakmem_itertuples_raw_read_first",
            "test_astype_uint",
            "test_same_categories_different_order",
            "scan_setup_py",
            "test_int_index_make_union",
            "get_op_from_name",
            "test_invalid_parser",
            "test_loc_with_overlap",
            "_convert_can_do_setop",
            "test_bad_take",
            "hasnans",
            "test_map_na_exclusion",
            "test_plot_kwargs",
            "test_integers",
            "_from_inferred_categories",
            "test_read_hdf_series_mode_r",
            "list_of_lists_with_none",
            "test_query_syntax_error",
            "barh",
            "init_ndarray",
            "_get_index_resolvers",
            "test_align_series",
            "test_tdi_shift_minutes",
            "test_encode_string_conversion2",
            "test_set_index_raise_keys",
            "test_dti_cmp_datetimelike",
            "is_datetimelike_v_object",
            "check_simple_cmp_op",
            "test_concat_join_axes_deprecated",
            "to_offset",
            "validate_pep8",
            "test_iso_8601_strings_same_offset_no_box",
            "test_groupby_as_index_corner",
            "test_inner_join",
            "test_conversion_outofbounds_datetime",
            "test_convert_strl_name_swap",
            "test_unstack_multiple_no_empty_columns",
            "test_east_asian_unicode_false",
            "test_is_datetime64_ns_dtype",
            "test_transform_doesnt_clobber_ints",
            "test_usecols_excel_range_str",
            "test_to_jsonl",
            "date_range_frame",
            "test_describe_tz_values",
            "test_constructor_nonnan",
            "test_td64arr_div_tdlike_scalar_with_nat",
            "test_repr_html_wide_multiindex_cols",
            "test_frame_from_json_nones",
            "test_convert_no_arg_error",
            "_mpl_version",
            "test_to_csv_na_rep",
            "render_pep440_pre",
            "_get_counts",
            "test_ExcelWriter_dispatch_raises",
            "validate_and_set",
            "check_raw",
            "test_iterrows",
            "_check_box_coord",
            "test_resample_equivalent_offsets",
            "test_replace_with_single_list",
            "test_css_parse_normalisation",
            "test_axis_share_y",
            "test_constructor_inferred_fill_value",
            "_cython_agg_general",
            "test_to_dict_index_dtypes",
            "write_array_empty",
            "test_read_nokey_empty",
            "test_from_sparse_dtype_fill_value",
            "time_dropna",
            "test_round_daily",
            "test_setitem_series_float64",
            "test_categorical_margins_category",
            "test_tick_rdiv",
            "ffill",
            "test_msgpack_period_freq",
            "test_subclass_stack_multi_mixed",
            "test_non_datetime_index2",
            "_reset_identity",
            "test_output_significant_digits",
            "test_read_table_index_col",
            "test_parse_date_time",
            "test_setitem_index_bool",
            "_mpl",
            "time_is_dates_only",
            "test_pivot_table_multi",
            "ip",
            "test_reorder_levels",
            "test_bins",
            "test_timegrouper_apply_return_type_series",
            "_grouped_hist",
            "randu_array",
            "test_constructor_categorical",
            "test_consolidate_inplace",
            "test_timtetonum_accepts_unicode",
            "test_timedelta64_operations_with_timedeltas",
            "test_iso_constructor",
            "_check",
            "test_to_html_index",
            "test_dataframe_clip",
            "_set_endianness",
            "test_combine_first_dt64",
            "test_constructor_numpy_scalar",
            "test_scalar_fail",
            "test_second",
            "test_frame_getitem_slice",
            "_check_align",
            "_apply_window",
            "test_rpow_one_to_na",
            "test_index_convert_to_datetime_array_dateutil",
            "test_read_csv_handles_boto_s3_object",
            "test_set_option_uneven_args",
            "test_is_float",
            "_aggregate_named",
            "test_assert_numpy_array_equal_shape_mismatch_override",
            "test_overlaps_endpoint",
            "_arith_method_SPARSE_SERIES",
            "teardown_method",
            "merge_pr",
            "test_as_json_table_type_float_dtypes",
            "test_concat_categorical_coercion_nan",
            "test_write_with_index",
            "periods",
            "time_apply_lambda_mean",
            "_check_holiday_results",
            "makeFloatSeries",
            "test_categorical_concat_dtypes",
            "test_escapable_characters",
            "test_tz_localize_nonexistent",
            "test_construction_from_string",
            "test_median",
            "test_asof",
            "get_duplicates",
            "test_set_value_keeps_names",
            "test_operation_on_NaT",
            "create_single_mgr",
            "test_index_with_nan",
            "test_from_coo_nodense_index",
            "test_iteration_over_chunksize",
            "query",
            "test_mode_dropna",
            "test_bar_align_left_axis_none",
            "test_filter_and_transform_with_multiple_non_unique_int_index",
            "test_write_column_multiindex",
            "test_replace_dst_border",
            "_maybe_eval",
            "test_selection_api_validation",
            "test_reader_seconds",
            "test_resample_reresample",
            "transpose",
            "test_td64arr_sub_td64_array",
            "_left_indexer_unique",
            "test_index_and_on_parameters_confusion",
            "network",
            "test_constructor_timestamp_near_dst",
            "test_unstack_unused_level",
            "test_corr_rank",
            "get_resampler_for_grouping",
            "test_multiindex_assignment",
            "test_finder_annual",
            "test_maybe_convert_numeric_post_floatify_nan",
            "test_reindex_bool",
            "_pickle_roundtrip",
            "test_invalid_numexpr_version",
            "test_previous_workday",
            "read_spss",
            "test_to_csv_float_format",
            "test_annual_upsample",
            "test_interp_ignore_all_good",
            "test_join_index",
            "time_frame_fancy_lookup_all",
            "_get_cell_value",
            "pad_2d",
            "_preprocess_for_cut",
            "test_infer_dtype_misc",
            "test_maxbuffersize",
            "test_left_join_index_multi_match",
            "test_constructor_iso",
            "test_get_dummies_with_name_dummy",
            "should_cache",
            "test_comment_first_line",
            "test_to_records_with_categorical",
            "test_pprint_pathological_object",
            "test_get_schema_dtypes",
            "set_use_bottleneck",
            "test_bad_version",
            "test_infer_dtype_from_python_scalar",
            "state_data",
            "test_simple_records",
            "test_convertable_values",
            "is_floating",
            "test_basic_right_index",
            "test_use_bottleneck",
            "time_datetime_level_values_copy",
            "test_both_style_and_color",
            "test_td_add_td",
            "_shape",
            "test_join_does_not_recur",
            "_convert_string_array",
            "test_drop_by_str_label_raises_missing_keys",
            "test_monotonic",
            "test_metadata_propagation",
            "_from_values_or_dtype",
            "asarray_tuplesafe",
            "float_dtype",
            "test_nanargmax",
            "_parse_td",
            "test_tuple_union_bug",
            "to_csv",
            "test_groupby_empty_list_raises",
            "convert_json_field_to_pandas_type",
            "test_drop_with_ignore_errors",
            "test_capitalize",
            "test_compare_invalid",
            "test_decode_floating_point",
            "test_object_comparisons",
            "test_td64arr_floordiv_tdlike_scalar",
            "test_reindex_axis_style",
            "test_min_max_numeric_only",
            "test_read_write_reread_dta15",
            "test_construction_index_with_mixed_timezones",
            "stop",
            "test_round_mixed_type",
            "parse_args",
            "test_corr_spearman",
            "test_read_csv_memory_growth_chunksize",
            "compare_element",
            "test_is_datetimetz",
            "test_contains",
            "_highlight_handler",
            "test_constructor_with_non_normalized_pytz",
            "engine",
            "mframe",
            "_open_browser",
            "test_df_mod_zero_series_does_not_commute",
            "set_object_info",
            "datetime_index",
            "test_float_array",
            "time_interpolate",
            "pandas_dtype",
            "test_frame_multi_key_function_list",
            "test_annual",
            "test_large_value_conversion",
            "test_pad_stable_sorting",
            "test_hide_columns_mult_levels",
            "test_union_sort_other_special",
            "get_indexer",
            "test_floor",
            "test_from_coo_dense_index",
            "time_align_series_irregular_string",
            "between",
            "test_numarr_with_dtype_add_nan",
            "test_astype_extension_dtypes_1d",
            "test_value_counts_nunique",
            "test_to_csv_unicode_index_col",
            "test_construction_with_ordered",
            "test_engine_type",
            "test_setitem_series_timedelta64",
            "check_error_on_write",
            "validate_endpoints",
            "time_join_dataframe_index_shuffle_key_bigger_sort",
            "test_tdi_isub_timedeltalike",
            "test_nth_nan_in_grouper",
            "test_chunksize_read",
            "test_dti_isub_tdi",
            "test_assignment_column",
            "test_take_fill_with_negative_one",
            "test_to_dense_fill_value",
            "test_constructor_coerce",
            "test_filter_and_transform_with_non_unique_string_index",
            "test_flex_binary_frame",
            "test_to_string_mixed",
            "test_fillna_dtype_conversion",
            "insert_data",
            "get_numeric_mat",
            "time_iso8601_format_no_sep",
            "test_replace_series_period",
            "test_shallow_copy",
            "test_multiple_date_cols_index",
            "test_zero",
            "test_td64_series_astype_object",
            "time_left_outer_join_index",
            "test_hashtable_unique",
            "_arith_method_SPARSE_ARRAY",
            "test_to_csv_compression",
            "write_file",
            "test_series_named_agg",
            "test_transform_broadcast",
            "test_loc_getitem_int_slice",
            "df_levels",
            "test_group_name_available_in_inference_pass",
            "julian_dates",
            "_encode",
            "test_multi_index_no_level_names",
            "test_fill_value_reindex_coerces_float_int",
            "test_signed_zero",
            "test_get_indexer_nearest_listlike_tolerance",
            "_get_reconciled_name_object",
            "is_hashable",
            "test_series_repr",
            "time_reest_datetimeindex",
            "test_info_duplicate_columns_shows_correct_dtypes",
            "test_to_csv_quoting",
            "test_groupby_multi_corner",
            "all_parsers",
            "test_resample_anchored_multiday",
            "_is_potential_multi_index",
            "_maybe_cast_slice_bound",
            "packb",
            "test_fillna_datetime_columns",
            "test_overlapping_names",
            "test_constructor_dict_dont_upcast",
            "time_to_html_mixed",
            "test_month_range_union_tz_dateutil",
            "test_query_index_without_name",
            "get_ftype_counts",
            "duplicated",
            "_check_numeric_ops",
            "test_get_indexer_with_NA_values",
            "test_coerce_list",
            "test_align_frame",
            "time_baseline",
            "_u",
            "test_timestamp_tz_localize",
            "test_numpy_cumsum",
            "assert_series_or_index_equal",
            "test_rolling_skew_edge_cases",
            "test_read_excel_nrows",
            "_import_path",
            "invalid_comparison",
            "_validate_specification",
            "test_yy_format_with_year_first",
            "_test_data1_zero",
            "test_get_indexer_pad",
            "test_astype_timedelta64",
            "left",
            "test_get_level_values_na",
            "test_pivot_string_func_vs_func",
            "test_dti_with_period_data_raises",
            "test_map_callable",
            "test_default_type_conversion",
            "test_matplotlib_formatters",
            "test_remove_na_deprecation",
            "test_rangeindex_fallback_coercion_bug",
            "_three_digit_exp",
            "coerce_to_array",
            "test_validate_indices_high",
            "test_examples2",
            "test_set_name",
            "_alert_malformed",
            "test_level_get_group",
            "_any_none",
            "test_sas_buffer_format",
            "objects_to_datetime64ns",
            "test_set_categories_private",
            "assert_fp_equal",
            "test_to_html_escaped",
            "validate_one",
            "test_get_complex_nested",
            "test_concat_order",
            "test_from_product_empty_one_level",
            "to_json",
            "droplevel",
            "test_take_axis_0",
            "test_multi_index_naming",
            "test_infer_tz_compat",
            "test_float64_ns_rounded",
            "test_cached_properties_not_settable",
            "test_arg_tz_ns_unit",
            "test_to_timedelta",
            "check_round_trip",
            "test_resample_base",
            "_set_levels",
            "test_expanding_cov_pairwise_diff_length",
            "time_apply_pass_thru",
            "astype3",
            "test_tricky_container_to_bytes",
            "test_assert_almost_equal_value_mismatch4",
            "test_categorical_pivot_index_ordering",
            "test_sniff_delimiter_encoding",
            "test_partial_slice",
            "test_utf",
            "test_loc_getitem_duplicates_multiindex_missing_indexers",
            "test_uint64_type_handling",
            "test_numpy_ufuncs",
            "cast_scalar_to_array",
            "test_error_rename",
            "test_file_handles_with_open",
            "raise_or_return",
            "time_frame_nth",
            "test_is_dtype_from_self",
            "test_downsample_across_dst",
            "test_index_col_with_unnamed",
            "test_missing_value_generator",
            "test_upcast_datetime",
            "makeMissingDataframe",
            "blocks",
            "test_constructor_pass_nan_nat",
            "test_constructor_data_aware_dtype_naive",
            "test_preserve_refs",
            "test_cut_corner",
            "test_timedelta64_dtype_array_returned",
            "test_finder_monthly_long",
            "test_intersection_name_preservation",
            "test_infer_dtype_from_timedelta",
            "test_to_timestamp_preserve_name",
            "test_put_integer",
            "_delegate_class",
            "test_multi_line_expression",
            "_clean_na_values",
            "test_ops_series_period",
            "reset_cache",
            "test_get_set_value_no_partial_indexing",
            "maybe_convert_platform",
            "detect_colspecs",
            "test_groupby_non_arithmetic_agg_int_like_precision",
            "test_encode_time_conversion_pytz",
            "test_store_multiindex",
            "test_to_timestamp_quarterly_bug",
            "time_quarter",
            "test_xs_integer_key",
            "test_sparray_inplace",
            "test_agg_must_agg",
            "_check_moment_func",
            "to_array",
            "test_default_delimiter",
            "_fetchall_as_list",
            "test_getitem_int64",
            "clear",
            "test_extended_gcd",
            "time_from_float",
            "time_categorical_level",
            "test_encoding_options",
            "time_sparse_array",
            "test_expanding_quantile",
            "_validate_parse_dates_arg",
            "_save_header",
            "_next_iter_line",
            "test_operators_none_as_na",
            "test_dti_tz_convert_hour_overflow_dst_timestamps",
            "test_loc_getitem_label_array_like",
            "test_enable_data_resource_formatter",
            "time_read_store_table_wide",
            "_drop_labels_or_levels",
            "test_ignore_leading_whitespace",
            "test_pi_add_timedeltalike_minute_gt1",
            "test_tz_convert_roundtrip",
            "id_func",
            "mmap_file",
            "test_replace_dtypes",
            "remove_unused_levels",
            "test_td_rsub_offset",
            "infer_to_same_shape",
            "test_td_rfloordiv_numeric_series",
            "test_dt_accessor_updates_on_inplace",
            "test_applymap_box",
            "section_titles",
            "test_seriesgroupby_observed_true",
            "test_ix_loc_setitem_consistency",
            "test_ns_index",
            "decompress_file",
            "test_integer_with_zeros",
            "check_nancorr_nancov_2d",
            "makeFY5253LastOfMonth",
            "test_date_range_bms_bug",
            "as_array",
            "__str__",
            "test_custom_asserts",
            "test_subclass_iterrows",
            "test_multiby",
            "getPeriodData",
            "test_integer",
            "test_dataframe_dummies_with_categorical",
            "_assert_not_almost_equal_both",
            "test_dropna_series",
            "test_constructor_no_precision_warns",
            "test_to_coo",
            "test_utf16_example",
            "test_constructor_corner_shape",
            "create_pandas_abc_type",
            "test_multiple_date_col_custom",
            "test_concat_NaT_series_dataframe_all_NaT",
            "test_pad_fillchar",
            "_split_line",
            "_read_group",
            "test_datetime_outofbounds_scalar",
            "time_iloc_array",
            "test_cache_updating",
            "c2f",
            "test_non_array_raises",
            "test_maybe_promote_datetimetz_with_datetimetz",
            "test_dt64arr_naive_sub_dt64ndarray",
            "test_bins_unequal_len",
            "_get_space_character_free_column_resolvers",
            "test_StringIO",
            "test_gcs_not_present_exception",
            "test_mixing_naive_tzaware_raises",
            "time_parallel",
            "pandas_type",
            "pprint_thing_encoded",
            "get_atom_coltype",
            "test_chunksize_read_type",
            "test_replace_truthy",
            "test_fillna_index_timedelta64",
            "test_memory_usage_deep",
            "test_pivot_timegrouper",
            "test_clipboard_copy_strings",
            "test_blockplacement_add",
            "test_from_records_duplicates",
            "write_sparse_intindex",
            "__setattr__",
            "test_write_explicit",
            "time_groupby_sort",
            "test_iterrows_corner",
            "test_stringified_slice_with_tz",
            "test_nanosecond_string_parsing",
            "dtype_can_hold_na",
            "_get_result_dim",
            "check_extension",
            "test_offsets_compare_equal",
            "_get_sqlite_column_type",
            "time_rank_int_cat_ordered",
            "test_ix_duplicate_returns_series",
            "test_read_with_where_tz_aware_index",
            "test_numeric_compat2",
            "test_complibs_default_settings",
            "custom_dialect",
            "test_skip_rows_bug",
            "test_endswith",
            "_unstack_frame",
            "find_class",
            "test_asfreq_combined_pi",
            "test_fillna_index_bool",
            "test_update_deprecation",
            "test_get_level_lengths_un_sorted",
            "test_nth_empty",
            "test_roundtrip_pickle",
            "test_series_box_timestamp",
            "test_ngroup_matches_cumcount",
            "test_conv_quarterly",
            "test_generator_warnings",
            "__getslice__",
            "test_ewma_cases",
            "time_isin_long_series_long_values",
            "test_cython_agg_nothing_to_agg",
            "test_donot_overwrite_index_name",
            "_store_test_result",
            "test_consistent_coerce_for_shapes",
            "_isna_old",
            "test_display_format",
            "time_categorical_index_is_monotonic_increasing",
            "_chop",
            "test_crosstab_tuple_name",
            "test_setitem_raises_length",
            "test_freq_validation_with_nat",
            "_eval_single_bin",
            "time_nested_dict_columns",
            "test_round_trip_frame_string",
            "continue_maybe",
            "test_col_substring_of_stubname",
            "test_is_equal_dtype",
            "_get_subheader_index",
            "test_encode_decimal",
            "test_assign_order",
            "test_map_int",
            "test_thorough_mangle_names",
            "test_from_product_empty_zero_levels",
            "test_iterator_stop_on_chunksize",
            "_not_none",
            "_make_labels",
            "strip",
            "time_boolean_array",
            "test_reading_multiple_specific_sheets",
            "time_getitem_slice",
            "test_timeseries_repr_object_dtype",
            "test_hasnans_unchached_for_series",
            "test_list_float",
            "time_timestamp_series_compare",
            "_convert_listlike_indexer",
            "_get_time_stamp",
            "test_multiindex_name",
            "test_reindex_pad",
            "float_frame_fill0",
            "test_binary_ufunc_with_index",
            "is_re_compilable",
            "test_dtypes_are_correct_after_column_slice",
            "assert_offset_equal",
            "_set_dtype",
            "test_combine_le",
            "test_constructor_list_frames",
            "test_deprecated_contains",
            "test_td64arr_mul_td64arr_raises",
            "test_replace_regex_metachar",
            "test_asarray_homogenous",
            "test_array_unboxes",
            "test_1000_sep_with_decimal",
            "test_dti_date_out_of_range",
            "test_slice_non_numeric",
            "test_different_nans",
            "test_df_div_zero_array",
            "test_as_matrix_deprecated",
            "test_contains_top_level",
            "test_loc_getitem_array",
            "test_read_write_reread_dta14",
            "test_pindex_qaccess",
            "test_multiby_heterogeneous_types",
            "test_get_offset",
            "test_setitem_chained_setfault",
            "chck_ncols",
            "set_info",
            "test_transform_coercion",
            "test_copy_method_kwargs",
            "test_AbstractMethodError_classmethod",
            "_has_valid_tuple",
            "test_stack_order_with_unsorted_levels",
            "_reconstruct_data",
            "test_from_to_scipy_object",
            "test_ewmcorr",
            "test_is_string_dtype",
            "test_get_axis",
            "is_lexsorted_for_tuple",
            "test_nonsense_func",
            "test_spline_interpolation",
            "test_Millisecond",
            "check_comprehensiveness",
            "test_set_index_directly",
            "test_from_tuples_empty",
            "test_to_html_notebook_has_style",
            "parse_results",
            "dtype",
            "test_query_multiindex_get_index_resolvers",
            "time_transform_ufunc_max",
            "searchsorted",
            "test_get_indexer_with_int_and_float",
            "test_fillna_consistency",
            "time_frame_nonunique_equal",
            "_int64index",
            "test_readonly_axis_blosc_to_sql",
            "test_pad_backfill_object_segfault",
            "test_getitem_ellipsis",
            "rewrite_axis_style_signature",
            "test_merge",
            "test_replace_datetimetz",
            "supported_extensions",
            "format_array",
            "_flex_binary_moment",
            "test_chained_cmp_and_in",
            "validate_operand",
            "test_invalid_parse_delimited_date",
            "time_scalar_function_single_col",
            "test_intercept_builtin_sum",
            "test_multiindex_index",
            "_restore_dropped_levels_multijoin",
            "test_fillna_series_bool",
            "time_get_dummies",
            "test_int_to_datetime_format_YYYYMMDD_typeerror",
            "test_ewmvar",
            "bool_frame_with_na",
            "makeCustomIndex",
            "test_constructor_range_based_deprecated_different_freq",
            "test_to_csv_doublequote",
            "assert_is_valid_plot_return_object",
            "test_to_latex_with_formatters",
            "str_translate",
            "_executable_exists",
            "test_geopandas",
            "time_count",
            "test_value_counts_dtypes",
            "test_to_string_unicode_two",
            "test_read_excel_skiprows_list",
            "_range2cols",
            "open",
            "test_nanprod",
            "reset",
            "test_td64arr_rfloordiv_tdscalar_explicit",
            "test_getitem_setitem_datetime_tz_pytz",
            "ensure_str",
            "test_constructor_mixed",
            "test_drop_duplicates_NA_for_take_all",
            "test_index_object_dtype",
            "test_encode_big_set",
            "test_loc_setitem_dups",
            "test_pivot_columns_lexsorted",
            "test_na_values_na_filter_override",
            "test_hist_secondary_legend",
            "test_constructor_unsigned_dtype_overflow",
            "test_round_nat",
            "_is_strictly_monotonic_increasing",
            "test_rank_dense_method",
            "_comp_method_SERIES",
            "test_categorical_index_repr_datetime_ordered",
            "test_read_complete",
            "test_kde_colors",
            "test_plot_xy",
            "test_rank_min_pct",
            "axes",
            "test_frame_basic_dtypes",
            "test_timezones_fixed",
            "_get_column_names_and_types",
            "test_timedelta_range",
            "test_tzlocal_maybe_get_tz",
            "_format_body",
            "test_callable_deprecate_kwarg",
            "_wrap_applied_output",
            "test_infer_dtype_from_scalar_errors",
            "test_apply_with_mutated_index",
            "test_get_numeric_data",
            "_adjust_dates_anchored",
            "test_asarray_tz_naive",
            "test_agg",
            "test_setitem_index_complex128",
            "dtypes",
            "test_get_level_lengths",
            "test_ne",
            "nth",
            "test_date_range_fy5252",
            "test_format_pre_1900_dates",
            "corrwith",
            "parse_all_fields",
            "test_str",
            "test_getitem_setitem_integers",
            "_offset",
            "test_union3",
            "test_encode_decode_errors",
            "frame_random_data_integer_multi_index",
            "test_is_sparse",
            "test_is_null_datetimelike",
            "test_asarray_tz_aware",
            "test_timestamp_equality_different_timezones",
            "test_timestamp_to_datetime_explicit_dateutil",
            "test_unstack_odd_failure",
            "test_downcast",
            "test_where_invalid_input",
            "test_pipe",
            "test_drop_by_numeric_label_errors_ignore",
            "_create_from_codes",
            "_bool_agg",
            "is_list_like",
            "test_repr_summary",
            "test_multiple_open_close",
            "test_nat_operations",
            "test_unary_operators",
            "time_large_get_loc",
            "test_tz_convert_single_matches_tz_convert",
            "test_mixed_dtype",
            "_get_compressed_labels",
            "test_allow_exact_matches",
            "test_crosstab_multiple",
            "test_overflow",
            "all",
            "register_dataframe_accessor",
            "build_border",
            "_mpl_repr",
            "full_scope",
            "test_setitem_scalar_key_sequence_raise",
            "test_loc_setitem_datetime",
            "_bank_data",
            "test_custom_var_name",
            "test_fill_value_reindex",
            "test_sort_values_inplace",
            "test_timestamp_tz_localize_nonexistent_raise",
            "test_agg_apply_corner",
            "soft_convert_objects",
            "_any",
            "lookup",
            "test_invalid_dtype",
            "_compute",
            "_check_isinstance",
            "test_categorical_index_repr_datetime",
            "test_construct_from_string_own_name",
            "test_truncate_with_different_dtypes",
            "test_other_timedelta_unit",
            "test_overlaps_interval",
            "test_frame_empty",
            "test_unary_op",
            "test_convert_numeric_int64_uint64",
            "test_file_handle_mmap",
            "test_object_dtype_ok",
            "test_pass_spec_to_storer",
            "test_pi_sub_period",
            "test_index_equal_class_mismatch",
            "test_equal_but_different",
            "test_no_na_filter_on_index",
            "test_pad_require_monotonicity",
            "_shallow_copy_with_infer",
            "test_to_weekly_resampling",
            "test_reindex_columns_method",
            "test_float_trim_zeros",
            "get_value",
            "test_categorical",
            "test_filter_multiple_timestamp",
            "test_calendar_caching",
            "test_to_timestamp_repr_is_code",
            "assert_framelist_equal",
            "_test_all_offsets",
            "test_pi_add_sub_timedeltalike_freq_mismatch_monthly",
            "test_dataframe_compression_defaults_to_infer",
            "test_merge_index_singlekey_right_vs_left",
            "_check_accum_op",
            "is_object",
            "test_chunksize_with_compression",
            "time_is_leap_year",
            "nanany",
            "test_join_float64_float32",
            "time_lambda_sum",
            "test_str_cat_mixed_inputs",
            "test_unsortedindex",
            "test_hist_df_legacy",
            "test_apply_typecast_fail",
            "test_drop_col_still_multiindex",
            "test_sqlalchemy_type_mapping",
            "test_ohlc_5min",
            "time_by_object",
            "get_json_auth",
            "test_to_records_dtype_mi",
            "to_flat_index",
            "test_regex_replace_list_obj",
            "test_quotechar_unicode",
            "set_defaults",
            "test_infer_from_scalar_tz",
            "test_join_on_fails_with_wrong_object_type",
            "test_grouping_grouper",
            "test_bool_ops_warn_on_arithmetic",
            "test_copy_tzaware",
            "test_fillna_categorical",
            "test_encode_as_null",
            "test_factorize_empty",
            "test_rank_object_raises",
            "test_iso_8601_strings_with_same_offset",
            "validate_bool_kwarg",
            "test_bin32",
            "test_casemethods",
            "test_1700",
            "test_loc_slice",
            "_assert_all_na",
            "_internal_get_values",
            "test_infer_freq",
            "test_next_monday",
            "test_concat_tz_series_tzlocal",
            "test_ops_notimplemented",
            "test_array_reshaped",
            "object_dtype",
            "test_zip_error_invalid_zip",
            "test_class_ops_pytz",
            "test_getitem_pydatetime_tz",
            "test_value_counts_nat",
            "test_loc_getitem_bool_diff_len",
            "test_drop_tuple",
            "test_adjoin",
            "test_read_write_dta11",
            "test_take_fill_value_new_raises",
            "maybe_cast_item",
            "timetz",
            "testPackUTF32",
            "trim_join_unit",
            "parse_tables",
            "test_unbox_scalar",
            "test_variable_labels",
            "test_concat_sparse_dense",
            "test_unique_label_indices",
            "time_cat",
            "test_describe_with_tz",
            "test_mask_with_boolean",
            "test_mul_int_array",
            "test_infer_freq_tz_transition",
            "test_range_slice",
            "test_get_loc_na",
            "test_append_with_empty_string",
            "is_period_arraylike",
            "test_transpose_tzaware_2col_mixed_tz",
            "time_write_store_table_mixed",
            "test_rank_2d_tie_methods",
            "test_index_name_retained",
            "test_duplicated_subset",
            "test_subset",
            "test_date_range_timestamp_equiv_explicit_dateutil",
            "test_flex_binary_moment",
            "get_op_result_name",
            "test_repr_categorical_dates_periods",
            "_convert_to_stop",
            "test_callable_deprecate_kwarg_fail",
            "test_loc_getitem_label_out_of_range",
            "__mod__",
            "test_int_int",
            "median",
            "visit_Expr",
            "time_frame_fancy_lookup",
            "test_loc_empty_list_indexer_is_ok",
            "test_get_combined_index",
            "no_capitalization",
            "test_series_count",
            "test_empty_arr",
            "unary_fns_for_ne",
            "test_frame_apply_dont_convert_datetime64",
            "test_creating_and_reading_multiple_sheets",
            "test_weekmask",
            "test_astype_category",
            "_from_datetime64",
            "test_maybe_match_name",
            "test_frame_setitem_ix",
            "_add_unary_ops",
            "unions",
            "source_file_name",
            "time_series_align_left_monotonic",
            "get_console_size",
            "test_inf_upcast",
            "test_assert_extension_array_equal_missing_values",
            "_concat_index_same_dtype",
            "test_groupby_sort_multiindex_series",
            "wrap_results",
            "test_astype_object_with_nat",
            "test_wide_repr",
            "write_array",
            "test_sharey_and_ax",
            "test_timestamp_in_columns",
            "test_iso_constructor_raises",
            "time_frame_float_div",
            "test_single_variable",
            "test_multi_line_expression_not_inplace",
            "__isub__",
            "test_fillna_scalar",
            "__mul__",
            "test_xs_setting_with_copy_error_multiple",
            "test_nanstd_nans",
            "_convert_tolerance",
            "test_sparse_max_row",
            "test_to_latex",
            "_selected_obj",
            "test_preserve_empty_rows",
            "test_categorical_repr_int_with_nan",
            "test_timestamp_constructor_tz_utc",
            "is_unsigned_integer_dtype",
            "test_basic_binop",
            "sparse",
            "test_bool_ops_with_constants",
            "_grouped_plot",
            "test_frame_datetime64_duplicated",
            "test_query_with_nested_strings",
            "test_v12_compat",
            "test_concat_tz_not_aligned",
            "test_resample_single_group",
            "test_constructor_with_existing_categories",
            "test_groupby_extension_transform",
            "test_skip_rows_blank",
            "test_rank_dense_pct",
            "test_binop_other",
            "test_CategoricalAccessor_index_deprecation",
            "test_setitem_raises",
            "_get_listlike_indexer",
            "epoch_1960",
            "time_get_slice",
            "test_categorical_coerces_timedelta",
            "_groupby_and_merge",
            "test_seriesgroupby_observed_false_or_none",
            "applymap",
            "test_validate_any_all_out_keepdims_raises",
            "test_numeric_columns",
            "test_reindex_int",
            "test_qcut_bounds",
            "test_an_exception_in_objecthook1",
            "test_tdi_round",
            "test_deep_skip_rows",
            "get_table",
            "select_dtypes",
            "test_utf8_bom",
            "_construct_axes_dict_from",
            "test_bad_reduce_raises",
            "test_date_query_with_NaT",
            "test_display_format_raises",
            "test_banklist_no_match",
            "_get_wom_rule",
            "test_from_values_or_dtype",
            "test_from_frame_dtype_fidelity",
            "test_rolling_mean",
            "test_symmetric_difference_missing",
            "test_convert_json_field_to_pandas_type",
            "set_categories",
            "test_show_null_counts",
            "test_constructor_iterable",
            "_create_sp_tsseries",
            "time_subtract_10",
            "run_series",
            "test_format_date_axis",
            "test_query_non_str",
            "test_read_write_dta12",
            "test_asfreq_mult_pi",
            "test_td64_df_add_int_frame",
            "time_addition",
            "is_gcs_url",
            "is_platform_mac",
            "test_timestamp_multiindex_indexer",
            "test_get_indexer_length_one_interval",
            "time_qcut_float",
            "_combine_match_columns",
            "test_subplots_timeseries_y_axis_not_supported",
            "_add_delegate_accessors",
            "use_numexpr",
            "test_string_factorize",
            "test_invalid_dtype_error",
            "test_transactions",
            "testSimpleValue",
            "test_series_frame_radd_bug",
            "test_as_array_int_bool",
            "_convert_arr_indexer",
            "time_timeseries_is_month_start",
            "get_default_val",
            "get_callable_name",
            "time_take1d",
            "time_max_trivial",
            "format",
            "test_rowspan_only_rows",
            "test_to_integer_array",
            "test_dti_iadd_int",
            "real",
            "test_datetimeindex_sub_datetimeindex_overflow",
            "test_usecols_dtypes",
            "_maybe_update_cacher",
            "_new_IntervalIndex",
            "test_union_name_preservation",
            "test_preserve_dtypes",
            "test_series_constructor_with_copy",
            "test_large_mi_dataframe_indexing",
            "test_frame_to_json_float_precision",
            "test_replace_simple_nested_dict_with_nonexistent_value",
            "test_scalar",
            "_repr_html_",
            "get_loc",
            "test_to_latex_multiindex_dupe_level",
            "test_url",
            "is_one_of_factory",
            "get_group_index",
            "test_ufunc_compat",
            "test_size_compat",
            "test_equals_op_mismatched_multiindex_raises",
            "_arith_method_SERIES",
            "test_dont_modify_colors",
            "test_astype_datetime64tz",
            "test_reset_index_datetime",
            "test_ndarray_compat_properties",
            "test_groupby_extension_agg",
            "test_fallback_singular",
            "values_cols",
            "test_parse_public_s3_bucket_chunked",
            "test_take_series",
            "validate_window_func",
            "test_catch_infinite_loop",
            "_getitem_tuple",
            "test_rcParams_bar_colors",
            "is_valid",
            "test_take_misc",
            "time_cut_timedelta",
            "extractall",
            "test_string_slice",
            "_set_ticklabels",
            "test_frame_describe_unstacked_format",
            "test_add_timestamp_raises",
            "shape",
            "test_encode_control_escaping",
            "test_td_add_mixed_timedeltalike_object_dtype_array",
            "test_special_holidays",
            "test_is_categorical",
            "test_dataframe",
            "test_name_repr",
            "test_get_loc_duplicates",
            "test_to_csv_string_array_ascii",
            "test_merge_on_extension_array_duplicates",
            "_convert_for_reindex",
            "_print_cline",
            "test_concat_numerical_names",
            "test_tseries_indices_series",
            "test_addsub_arithmetic",
            "test_read_json_large_numbers",
            "test_insert_index_complex128",
            "test_merge_index_types",
            "_guess_datetime_format_for_array",
            "test_high_freq",
            "test_to_period_monthish",
            "test_constructor_from_items_scalars",
            "test_read_jsonl",
            "_left_join_on_index",
            "test_date_like_qcut_bins",
            "partition",
            "test_api_compat",
            "test_tdi_shift_hours",
            "test_grouped_hist_layout",
            "test_all_any",
            "test_setitem_tuple_index",
            "test_drop_duplicates_for_take_all",
            "test_unexpected_keyword",
            "test_drop_non_empty_list",
            "test_boxplot_axis_limits",
            "test_weekly_infer",
            "_check_basic_constructor",
            "_compare",
            "__getstate__",
            "test_monthly_ambiguous",
            "bool",
            "_get_next_label",
            "test_int_index",
            "_invalid_indexer",
            "test_read_csv_low_memory_no_rows_with_index",
            "test_numpy_argsort",
            "tostring",
            "test_period_deprecated_freq",
            "test_set_frame_expand_extension_with_regular",
            "test_now",
            "homogenize",
            "test_sub_dti_dti",
            "test_basic_left_index_right_index",
            "assert_stat_op_calc",
            "test_concat_rename_index",
            "test_align_mixed_type",
            "test_groupby_apply_return_empty_chunk",
            "_get_all_tables",
            "test_read_csv_utf_aliases",
            "time_multiby",
            "_validate_freeze_panes",
            "test_logical_ops_invalid",
            "time_is_year_start",
            "obj_fixture",
            "_can_fast_union",
            "_get_lines",
            "time_dup_string_dates_and_format",
            "maybe_unwrap_index",
            "inferred_freq",
            "test_map_defaultdict",
            "test_clip_against_frame",
            "_get_credentials",
            "test_drop_by_numeric_label_loc",
            "get_unit_generic",
            "test_cut_out_of_range_more",
            "test_modulo",
            "test_groupby_as_index_agg",
            "sanitize_array",
            "test_constructor_empty",
            "_close",
            "test_take_non_na_fill_value",
            "test_query_lex_compare_strings",
            "test_wrong_number_names",
            "testDecodeBinary",
            "test_binary_ops_docs",
            "test_astype_to_timedelta_unit_ns",
            "test_expanding_corr_pairwise",
            "time_frame_fillna",
            "test_set_option_empty_args",
            "test_internal_null_byte",
            "test_to_timedelta_float",
            "test_really_large_in_arr",
            "pp_options_list",
            "sem",
            "test_datetime_bool",
            "test_default_encoding",
            "test_max_min_range",
            "time_write_excel",
            "test_getitem_dataframe",
            "test_agg_with_datetime_index_list_agg_func",
            "test_slice_keep_name",
            "test_pow_ops_object",
            "_get_data_label",
            "_window_type",
            "test_today",
            "test_frame_mi_access_returns_series",
            "test_info_memory_usage_deep_not_pypy",
            "test_comment_header",
            "test_custom_lineterminator",
            "test_datetime_index",
            "test_mask",
            "_values_for_rank",
            "test_hist_layout_with_by",
            "test_to_html_decimal",
            "test_to_string_specified_header",
            "test_to_string_float_formatting",
            "test_where_with_numeric_data_and_other",
            "test_where_axis",
            "test_transform_and_agg_err",
            "test_to_timestamp_pi_combined",
            "_is_aligned",
            "test_subtype_float",
            "_count_rows",
            "test_boxplot_subplots_return_type",
            "make_mixed_dataframe_v2",
            "test_sum",
            "test_hexbin_with_c",
            "rfloordiv",
            "test_rolling_quantile",
            "check_level_names",
            "test_query_single_element_booleans",
            "_make_engine",
            "test_dt64arr_add_sub_relativedelta_offsets",
            "time_existing_categorical",
            "test_separator_date_conflict",
            "test_setitem_expand_with_extension",
            "test_zero_variables",
            "put",
            "time_isin",
            "test_mod_zero",
            "test_reindex_cast",
            "test_na_handling",
            "slice_locs",
            "test_setitem_dtype",
            "test_dropna_dt_like",
            "test_bool_ops_column_name_dtype",
            "groupby_apply_op",
            "test_to_datetime_fixed_offset",
            "test_dateindex_conversion",
            "_align_core_single_unary_op",
            "test_unique_level",
            "time_pivot_table",
            "test_to_csv_cols_reordering",
            "test_scalar_bool",
            "_is_datetime",
            "_stack_arrays",
            "test_divmod_ndarray",
            "test_ptp",
            "test_deprecate_keyword",
            "test_to_string_with_datetime64_hourformatter",
            "test_xs_values",
            "test_inconsistent_number_of_rows",
            "test_str8",
            "info",
            "test_join_multiindex",
            "cat",
            "make_array",
            "test_encode_num_conversion",
            "_add_redirects",
            "cumprod",
            "test_str_label_slicing_with_negative_step",
            "time_merge_object",
            "equalContents",
            "test_where_raises",
            "test_minmax_nat_datetime64",
            "test_roll_qtr_day_not_mod_unequal",
            "test_dti_tz_convert_hour_overflow_dst",
            "test_internal_eof_byte_to_file",
            "test_mixed_freq_irreg_period",
            "test_array_object_dtype",
            "_constructor_expanddim",
            "_align_series",
            "test_fillna_datetime",
            "test_resample_single_period_timedelta",
            "test_pandas_errors",
            "is_timedelta64_ns_dtype",
            "is_boolean",
            "test_concat_sparse_dense_rows",
            "test_infer_datetimelike_array_timedelta",
            "test_irreg_dtypes",
            "_attributes",
            "test_date_tz",
            "test_dti_business_summary_pytz",
            "do_setup",
            "dispatch_to_index_op",
            "time_crosstab_normalize",
            "_valid_sp_values",
            "slabels",
            "test_to_datetime_default",
            "test_parsers_timestring",
            "_convert_to_alignment",
            "test_sort_index_na_position_with_categories",
            "test_to_datetime_cache_series",
            "test_pivot_no_level_overlap",
            "test_dti_custom_business_summary",
            "test_slice_locs_not_contained",
            "multi_index3",
            "time_ix_array",
            "_get_stacking_id",
            "time_frame_ix",
            "test_is_period",
            "no_type",
            "time_weekday_name",
            "test_select_iterator",
            "test_from_custom_template",
            "test_add_extension_scalar",
            "test_pickle_freq",
            "test_getitem_mask",
            "test_unpack_bytearray",
            "test_css_to_excel",
            "_bn_ok_dtype",
            "as_sparse_array",
            "import_module",
            "test_unimplemented_dtypes_table_columns",
            "test_loc_scalar",
            "time_dt_accessor_date",
            "test_last_week_of_month_on_offset",
            "test_apply_box",
            "test_to_datetime_different_offsets",
            "test_timedelta64",
            "test_basic_setitem_with_labels",
            "test_logical_ops_bool_frame",
            "skip_ods_files",
            "test_integer_thousands_alt",
            "test_invert",
            "test_header_not_enough_lines",
            "compress",
            "test_timestamp_utc_true",
            "_read_subheader_signature",
            "test_convert_dates_infer",
            "test_get_reverse_indexer",
            "cartesian_product",
            "test_repr_array",
            "test_reindex_api_equivalence",
            "test_read_excel_blank",
            "test_to_latex_empty",
            "test_timedelta",
            "test_numeric_embedded_arr_likes",
            "test_cumcount_empty",
            "test_mean_corner",
            "test_drop_duplicates_tuple",
            "test_where_index_datetime",
            "test_construct_from_string_raises",
            "test_try_parse_dates",
            "test_EA_types",
            "_concat_indexes",
            "_reindex_output",
            "test_join_left",
            "test_exceptions",
            "fnx",
            "test_mean_datetimelike_numeric_only_false",
            "test_categorical_writing",
            "test_self_join_multiple_categories",
            "test_ops_series_timedelta",
            "reset_display_options",
            "test_4d_ndarray_fails",
            "test_infer_compression",
            "test_qcut_binning_issues",
            "test_dti_add_tick_tzaware",
            "test_rowwise_alt",
            "test_rank_tie_methods",
            "complex_dtype",
            "assert_categorical_equal",
            "test_pivot_table_with_margins_set_margin_name",
            "test_construction_with_conversions",
            "test_iter_raises",
            "test_length",
            "_parse_subtype",
            "test_i8",
            "_reset_cacher",
            "slice_indexer",
            "test_crosstab_ndarray",
            "test_constructor_cast",
            "test_array_from_scalars",
            "test_get_day_of_month_error",
            "test_line_colors_and_styles_subplots",
            "_check_implicitly_registered",
            "test_apply_empty",
            "test_frame_mi_access",
            "test_read_json_table_dtype_raises",
            "_do_convert_categoricals",
            "test_pivot_preserve_dtypes",
            "test_unpack_array_header_from_file",
            "_get_stacked_values",
            "test_align",
            "test_ops_nat_mixed_datetime64_timedelta64",
            "test_concat_keys_specific_levels",
            "test_to_period_millisecond",
            "test_computer_sales_page",
            "test_concat_datetime_datetime64_frame",
            "time_apply",
            "_convert_index_indexer",
            "time_same_offset",
            "test_pi_sub_isub_timedeltalike_daily",
            "_concat_datetimetz",
            "test_setitem_with_tz_dst",
            "test_dt64_series_add_mixed_tick_DateOffset",
            "test_join_multi_multi",
            "test_infer_tz_mismatch",
            "test_bar_edge",
            "_concat_objects",
            "test_scipy_compat",
            "concatenate_block_managers",
            "test_index_false_to_json_split",
            "test_sort_index_categorical_index",
            "is_type_compatible",
            "test_drop_duplicates_series_vs_dataframe",
            "test_append_with_timedelta",
            "__setitem__",
            "test_hist_bins_legacy",
            "test_quantile_nan",
            "test_dropna_empty",
            "test_arith_flex_frame_corner",
            "test_complex_sorting",
            "test_evaluate_with_empty_groups",
            "test_groupby_agg_observed_true_single_column",
            "test_setitem_dtypes",
            "test_to_datetime_dtarr",
            "test_missing_args_or_kwargs",
            "test_sub_offset_nat",
            "test_setitem_cast",
            "get_slice_bound",
            "_is_cached",
            "test_mismatching_tz_raises_err",
            "test_delete_base",
            "test_coercion_with_loc",
            "test_to_csv_deprecation",
            "test_set_value_with_index_dtype_change",
            "test_take_sequence",
            "test_from_arrays_empty",
            "_format_col",
            "test_mixed_arithmetic_frame",
            "assert_attr_equal",
            "test_bounds_with_different_units",
            "test_fillna_invalid_method",
            "test_join_on_inner",
            "_get_xticks",
            "test_multiple_date_col_multiple_index_compat",
            "_execute_insert_multi",
            "_try_cast",
            "test_minmax_period",
            "_add_comparison_ops",
            "test_dst",
            "_get_with",
            "test_secondary_legend",
            "infer_dtype_from_object",
            "size_to_pt",
            "test_xy_args_integer",
            "get_commit_vitals",
            "time_read_hdf",
            "test_tdi_mul_int_array",
            "test_kde_missing_vals",
            "column_types",
            "test_parse_header_of_non_string_column",
            "test_replace_string_with_number",
            "test_repr_dimensions",
            "test_repr_no_backslash",
            "test_period_set_index_reindex",
            "test_read_sql_delegate",
            "values",
            "test_to_series_with_arguments",
            "_all_none",
            "test_resample_group_info",
            "test_to_xarray",
            "test_read_excel_nrows_non_integer_parameter",
            "test_series_equal_categorical_mismatch",
            "test_crosstab_margins_set_margin_name",
            "test_loc_preserve_names",
            "test_setitem_iloc_scalar_mixed",
            "test_consistency_for_boxed",
            "add_imports",
            "test_pop_non_unique_cols",
            "test_read_sql_view",
            "test_corrwith_index_union",
            "_stack_multi_columns",
            "test_from_scipy_fillna",
            "test_type_check",
            "test_freq",
            "test_round_trip",
            "test_df_flex_cmp_constant_return_types_empty",
            "test_plot_submethod_works",
            "makeMultiIndex",
            "test_sparse_series_round_trip2",
            "test_to_latex_no_bold_rows",
            "test_astype_copies",
            "test_slice_keeps_name",
            "_read_sql_iris_parameter",
            "test_dt64arr_sub_timestamp",
            "test_constructor_from_string",
            "area",
            "compare_operators_no_eq_ne",
            "test_constructor_list_of_derived_dicts",
            "safe_close",
            "nselect_method",
            "test_days_neg",
            "__new__",
            "test_intersection",
            "test_setitem_boolean",
            "test_series_getitem_multiindex",
            "box_with_array",
            "test_multiindex_set_index",
            "visit_Num",
            "legacy_pickle",
            "test_modulo2",
            "expanding",
            "test_subplots",
            "test_getitem_label_list_with_missing",
            "test_cdaterange_weekmask",
            "time_property",
            "time_transform_multi_key1",
            "_is_indexed_like",
            "test_series_box_timedelta",
            "_cast_types",
            "unused_import",
            "test_observed_codes_remap",
            "build_extension",
            "test_getitem_bool_index_single",
            "test_all_custom_freq",
            "last",
            "test_aggregate_normal",
            "sheet_names",
            "test_is_numeric_array",
            "_hasnans",
            "test_2d_bool",
            "test_na_values_with_dtype_str_and_na_filter",
            "_value_formatter",
            "test_where_numeric_with_string",
            "test_index_namedtuple",
            "test_week_of_month_fake",
            "test_long",
            "test_infer_datetimelike_array_date",
            "test_nanvar",
            "test_series_not_equal_value_mismatch",
            "test_isinf_scalar",
            "time_query_store_table_wide",
            "test_line_area_nan_series",
            "test_raise_with_traceback",
            "test_slice_locs_na",
            "test_astype_dict_like",
            "test_datetime64_tz_dropna",
            "test_hash_pandas_empty_object",
            "test_timestamp_constructed_by_date_and_tz",
            "_transform_fast",
            "_convert_range",
            "df_strings",
            "test_td64arr_add_int_series_invalid",
            "datapath",
            "set_data",
            "test_pivot_with_list_like_values",
            "test_take_fill",
            "check_keys_split",
            "test_usecols_relative_to_names",
            "test_constructor_maskedarray_nonfloat",
            "test_set_index_append",
            "test_apply_to_timedelta",
            "_skip_if_no_private_key_path",
            "_get_tz",
            "test_categorical_repr_ordered",
            "test_assign_columns",
            "first_line_ends_in_dot",
            "test_small_strings_no_warn_zlib",
            "test_deprecated_fastpath",
            "get_series",
            "convert_value",
            "assert_bool_op_api",
            "_reverse_indexer",
            "_check_expanding",
            "time_qcut_int",
            "test_value_labels_iterator",
            "test_na_roundtrip",
            "test_frame_ctor_datetime64_column",
            "_test_data1",
            "test_value_counts_uint64",
            "test_decode_jibberish",
            "test_union_same_types",
            "test_dt64arr_add_mixed_offset_array",
            "test_difference_freq",
            "test_datetime_nan_error",
            "test_length_zero_copy",
            "test_result_types2",
            "mixed_type_frame",
            "_getitem_multilevel",
            "_get_label_or_level_values",
            "test_infer_dtype_from_float_scalar",
            "__array_ufunc__",
            "do_vcs_install",
            "test_value_counts_unique_nunique",
            "test_loc_listlike_dtypes",
            "test_excessively_long_string",
            "apply",
            "time_write_store_table_dc",
            "time_frame_plot",
            "isna",
            "validate_metadata",
            "_wrap_output",
            "test_shift_int",
            "cummax",
            "_expand_user",
            "test_to_latex_filename",
            "test_qcut_index",
            "test_tab_completion_with_categorical",
            "test_assert_extension_array_equal_not_exact",
            "to_gbq",
            "read_fwf",
            "test_str_cat_wrong_dtype_raises",
            "test_boolean_context_compat2",
            "test_dti_tz_localize_tzlocal",
            "test_df_gridspec_patterns",
            "test_rolling_corr",
            "test_read_chunks_columns",
            "test_apply_nanoseconds",
            "test_concat_datetimeindex_freq",
            "test_series_pad_backfill_limit",
            "test_constructor_invalid",
            "get_filepath_or_buffer",
            "test_read_xlrd_book",
            "testMap",
            "test_stat_operators_attempt_obj_array",
            "test_index_col_named",
            "test_from_inferred_categories_coerces",
            "time_from_string",
            "test_categorical_dtype_single",
            "test_concat_empty_dataframe_dtypes",
            "test_constructor_list_of_dicts",
            "test_setitem_with_different_tz",
            "test_read_only_header_no_rows",
            "test_all_nan",
            "_reindex_axes",
            "test_fill_consistency",
            "test_default_index",
            "test_idxmax",
            "_minmax_wrap",
            "_permute",
            "test_as_array_float",
            "test_replace_moar",
            "testFixArray",
            "mix_ab",
            "_delta_to_tick",
            "_check_join",
            "time_set_index",
            "test_timestamp_tz_localize_nonexistent_NaT",
            "test_to_html_with_no_bold",
            "test_concat_multiindex_with_tz",
            "_ensure_term",
            "test_ngroup",
            "compare_sp_frame_float",
            "test_constructor_invalid_quarters",
            "test_arith_frame_with_scalar",
            "test_indexing_assignment_dict_already_exists",
            "test_td64arr_rfloordiv_tdscalar",
            "test_can_serialize_dates",
            "test_prod",
            "test_resample_empty_dtypes",
            "test_non_cython_api",
            "test_constructor_fromordinal",
            "test_isin",
            "test_tdi_mul_int_series",
            "testIgnoreErrorsPack",
            "test_to_sql_replace",
            "test_concat_timedelta64_block",
            "test_sub_character",
            "test_columns_dtypes_invalid",
            "test_to_html_invalid_justify",
            "test_update_dtype_raises",
            "test_resample_anchored_intraday",
            "test_rolling_max",
            "test_append_to_multiple_dropna",
            "test_concat_keys_levels_no_overlap",
            "test_indexing_over_size_cutoff",
            "test_insert_index",
            "test_has_duplicates_from_tuples",
            "test_setitem_index_datetime64tz",
            "_scalar_data_error",
            "test_concat_period_series",
            "scipy_sem",
            "test_weird_nested_json",
            "test_comparisons_coverage",
            "test_cross_engine_fp_pa",
            "test_bar_linewidth",
            "test_groupby_first_datetime64",
            "test_datetimeindex_constructor_misc",
            "test_cmov_window_special_linear_range",
            "parsed_114",
            "test_indexing_mixed_frame_bug",
            "testNoEncoding",
            "_maybe_downcast",
            "test_tick_add_sub",
            "test_td_add_pytimedelta",
            "boolean_parameter",
            "_cleanup",
            "test_constructor_sparse_dtype_str",
            "swapkey",
            "mixed_int",
            "_check_binary_ew",
            "test_indexing_dtypes_on_empty",
            "_justify",
            "test_categorical_dtype_coerces_boolean",
            "str_rsplit",
            "test_dt64arr_add_sub_td64_nat",
            "test_isin_cats",
            "test_css_parse_invalid",
            "time_pivot_table_agg",
            "_reset_group_selection",
            "test_td64arr_div_int",
            "to_dict",
            "datetime_frame",
            "test_empty_dtype",
            "test_constructor_int_dtype_float",
            "test_is_homogeneous_type",
            "test_setitem_different_tz_raises",
            "test_timedelta64_operations_with_DateOffset",
            "test_factorize_tuple_list",
            "test_pi_add_iadd_timedeltalike_M",
            "maybe_list_like",
            "test_to_datetime_today",
            "test_to_series",
            "as_unordered",
            "test_inferred_dtype_fixture",
            "test_invalid_date_kwarg_with_string_input",
            "yields",
            "time_tz_localize",
            "test_shift_dtype_fill_value",
            "time_apply_axis_1",
            "test_excel_roundtrip_indexname",
            "test_api_compat_before_use",
            "test_rank",
            "test_from_weekly_resampling",
            "test_arith_non_pandas_object",
            "test_combine_generic",
            "test_dti_cmp_object_dtype",
            "scalar_td",
            "test_filter_bad_shapes",
            "time_from_str",
            "_handle_shared_axes",
            "test_to_timedelta_via_apply",
            "test_infer_datetimelike_array_datetime",
            "test_to_records_index_name",
            "deprecate_kwarg",
            "prune",
            "test_concat_multiindex_with_keys",
            "test_float_same_index_comparison",
            "func",
            "test_setattr_warnings",
            "_daily_finder",
            "test_compression_size_fh",
            "_get_time_delta_bins",
            "_group_selection_context",
            "shift",
            "is_period_dtype",
            "test_string",
            "as_json_table_type",
            "prep_ndarray",
            "test_replace_series_datetime_tz",
            "_freeze",
            "_node_not_implemented",
            "column_data_offsets",
            "test_period_cons_weekly",
            "_get_formatted_values",
            "test_pandas_array",
            "_get_plot_backend",
            "is_sequence",
            "test_bar_align_zero_axis_none",
            "test_op_corners",
            "_check_mixed_float",
            "interval",
            "test_series_group_min_max",
            "test_numeric",
            "test_setitem_raises_type",
            "_maybe_mask_results",
            "_astype",
            "_trim_zeros_complex",
            "test_asfreq_corner",
            "test_append_concat",
            "test_float_index_to_mixed",
            "_info_repr",
            "test_cython_agg_empty_buckets",
            "test_constructor_column_duplicates",
            "test_constructor_timedelta_window_and_minperiods",
            "resolve",
            "test_constructor_tz_mixed_data",
            "_get_ind",
            "_get_center_of_mass",
            "test_concat_datetime64_block",
            "test_select_dtypes_str_raises",
            "test_isna_for_inf",
            "test_mixed_freq_hf_first",
            "test_iloc_non_unique_indexing",
            "test_insert",
            "test_cython_fail_agg",
            "test_unique_index",
            "_engine_type",
            "test_to_csv_stringio",
            "test_set_index_verify_integrity",
            "test_map_identity_mapping",
            "agg_series",
            "test_constructor_fromarraylike",
            "get_version",
            "test_boxplot",
            "rands",
            "test_registry_find",
            "test_to_latex_multicolumnrow",
            "test_merge_datetime64tz_with_dst_transition",
            "rollback",
            "compare_all",
            "test_reset_index_multiindex_nan",
            "test_numpy_array_equal_copy_flag",
            "insert",
            "_validate_color_args",
            "test_constructor_errors",
            "test_get_indexer_numeric_index_boolean_target",
            "test_is_dict_like_fails",
            "test_ignore_error",
            "replace_list",
            "test_publishes",
            "test_map_empty",
            "test_categorical_coerces_numeric",
            "test_sparse_series_fillna_limit",
            "_is_nested_tuple_indexer",
            "test_list_grouper_with_nat",
            "left_df",
            "test_symmetric_difference_non_index",
            "time_by_int",
            "_dtype_to_stata_type_117",
            "test_replace_bool_with_string",
            "test_numpy_argmin_deprecated",
            "test_groupby_nonobject_dtype",
            "test_droplevel_list",
            "test_slice_replace",
            "time_modulo",
            "test_read_csv_parse_simple_list",
            "test_subdays_neg",
            "test_repr_truncates_terminal_size_full",
            "test_is_monotonic_decreasing",
            "test_agg_compat",
            "test_legacy_table_fixed_format_read_py2",
            "test_deprecate_option",
            "test_td_sub_offset",
            "test_convert_non_hashable",
            "test_setitem_mixed_datetime",
            "test_rolling_kurt_edge_cases",
            "test_reconstruct_remove_unused",
            "time_frame_mult",
            "render_pep440",
            "test_publishes_not_implemented",
            "test_setitem_series_complex128",
            "validate_expanding_func",
            "test_read_from_http_url",
            "test_set_index_dst",
            "unknown_section",
            "test_skiprows_inference",
            "_make_min_count_stat_function",
            "test_getitem_setitem_ix_negative_integers",
            "test_read_csv_unicode",
            "test_constructor_empty_boolean",
            "test_fillna_copy_series",
            "time_delta_int_tstamp_lines",
            "test_min_periods",
            "test_join_many",
            "test_fillna_dict_series",
            "test_take_out_of_bounds_raises",
            "test_read_chunksize_and_nrows_changing_size",
            "time_iso8601_tz_spaceformat",
            "test_dti_constructor_numpy_timeunits",
            "test_astype_to_datetime_unit",
            "test_raise_on_info",
            "test_factorize_tz",
            "_update_map",
            "test_datetime_date",
            "construct_1d_object_array_from_listlike",
            "test_filter_dropna_with_empty_groups",
            "test_union_bug_1730",
            "test_stack_sparse_frame",
            "test_verbose_read2",
            "test_append_some_nans",
            "test_no_mutable_funcs",
            "fill_value",
            "test_modf",
            "test_str_accessor_updates_on_inplace",
            "test_loc_getitem_label_slice",
            "test_to_csv_from_csv3",
            "multiindex_dataframe_random_data",
            "_combine_const",
            "test_resample_upsampling_picked_but_not_correct",
            "test_encode_datetime_conversion",
            "test_drop_duplicates_with_duplicate_column_names",
            "test_td_construction_with_np_dtypes",
            "test_constructor_errors_tz",
            "test_to_datetime_utc_true_with_series_datetime_ns",
            "test_inf_roundtrip",
            "time_different_python_functions_singlecol",
            "test_prevent_casting",
            "test_period_ordinal_start_values",
            "test_lookup_raises",
            "no_punctuation",
            "test_repr_utcoffset",
            "__exit__",
            "_from_arrays",
            "test_getitem_setitem_non_ix_labels",
            "test_regex_replace_numeric_to_object_conversion",
            "validate_data_columns",
            "time_float_32",
            "test_loc_label_slicing",
            "test_repeat_range",
            "test_dti_repr_short",
            "time_clip",
            "bytes_dtype",
            "test_binary_arith_ops",
            "current_packers_data",
            "test_dateoffset_misc",
            "test_join_many_mixed",
            "df_whitelist_fixture",
            "test_class_ops_dateutil",
            "time_check_datetimes",
            "test_compound_deprecated",
            "test_pi_add_offset_array",
            "skip_if_no_pandas_parser",
            "_is_homogeneous_type",
            "test_to_timedelta_on_missing_values",
            "test_bs4_version_fails",
            "mem_itertuples_start",
            "test_maybe_booleans_to_slice",
            "time_add_overflow_both_arg_nan",
            "test_operators",
            "test_series_append_dst",
            "test_td_rfloordiv_offsets",
            "test_group_shift_with_null_key",
            "test_repr_nat",
            "test_invalid_separator",
            "test_fromDict",
            "test_read_from_pathlib_path",
            "test_stat_op_api",
            "test_resample_basic_grouper",
            "_pat_wrapper",
            "_get_binner",
            "test_rank_methods_frame",
            "test_timestamp_compare_scalars",
            "is_nested_object",
            "test_view_asi8",
            "time_isin_long_series_long_values_floats",
            "test_random_state",
            "test_groupby_as_index_series_scalar",
            "test_str_bool_return",
            "ensure_int_or_float",
            "test_groupby_mixed_type_columns",
            "test_date_parser_int_bug",
            "time_without_last_row",
            "test_rolling_apply_mutability",
            "_simple_new",
            "test_resolution_deprecated",
            "get_block_type",
            "testMapSize",
            "_drop_axis",
            "time_parse_dateutil",
            "_helper_hypothesis_delimited_date",
            "time_get_loc",
            "test_dti_tz_localize",
            "test_with_listlike_columns",
            "next",
            "_trim_front",
            "test_where_subset",
            "test_rename_categories_dict",
            "_iter_data",
            "setup_class",
            "_join_level",
            "time_frame_from_ndarray",
            "test_monthly_resample_error",
            "test_decompression_regex_sep",
            "test_resample_nunique_with_date_gap",
            "__xor__",
            "test_index_ctor_infer_nan_nat",
            "test_loc_getitem_int_raises_exception",
            "test_compare_timedelta64_zerodim",
            "test_index_str_accessor_visibility",
            "read_index_legacy",
            "test_agg_api",
            "test_slice_with_negative_step",
            "test_is_period_arraylike",
            "test_datetime_categorical_comparison",
            "to_coo",
            "_get_simple_index",
            "test_any_none",
            "_is_empty_row",
            "is_extension_type",
            "test_as_json_table_type_timedelta_dtypes",
            "test_period",
            "test_business_freq",
            "test_excelfile_fspath",
            "base_delta_code_pair",
            "test_irregular_datetime",
            "make_axis_dummies",
            "_make_timestamp",
            "_check_for_bom",
            "test_spam_header",
            "test_write_fspath_hdf5",
            "test_series_append_aware",
            "_validate_where",
            "test_read_nrows",
            "test_constructor_dtype_only",
            "test_read_one_empty_col_no_header",
            "test_replace_bool_with_string_no_op",
            "str_strip",
            "makeIntIndex",
            "series_of_dtype2",
            "test__is_dtype_type_sparse",
            "test_xs_level_multiple",
            "test_parse_dates_empty_string",
            "_op_tests",
            "test_merge_suffix_error",
            "combine",
            "_process_single_doc",
            "test_singleton_header",
            "time_delta_int_tstamp",
            "test_get_loc_datetimelike_overlapping",
            "day_name",
            "test_round_invalid",
            "test_type_coercion_valid",
            "test_tz_convert_single_matches_tz_convert_hourly",
            "test_string_na_nat_conversion",
            "test_parse_public_s3_bucket",
            "_post_plot_logic",
            "test_to_html_timestamp",
            "test_mutability",
            "test_loc_incremental_setitem_with_dst",
            "test_long_series",
            "test_to_csv_numpy_16_bug",
            "test_get_level_values",
            "_maybe_evaluate_binop",
            "tables",
            "assert_labels_dropped",
            "test_read_table_equivalency_to_read_csv",
            "test_readjson_chunks_series",
            "__call__",
            "test_consolidate_datetime64",
            "test_to_hdf_with_min_itemsize",
            "_validate_for_numeric_unaryop",
            "to_numeric",
            "test_any_all_np_func",
            "test_dictify",
            "test_groupby_monotonic",
            "test_monotone_DTI_indexing_bug",
            "test_to_datetime_cache",
            "test_with_local_timezone_pytz",
            "get_storer",
            "_index_factory",
            "time_dtindex_from_series",
            "test_csv_mixed_type",
            "test_cant_compare_tz_naive_w_aware",
            "test_empty_decimal_marker",
            "test_s3_roundtrip",
            "test_select_dtypes_exclude_using_list_like",
            "test_nanvar_nans",
            "is_uniform_join_units",
            "three_days",
            "test_append_records",
            "test_replace_bool_with_bool",
            "_update_strl_names",
            "test_arithmetic_with_frame_or_series",
            "test_xs_with_duplicates",
            "infer_dtype_from",
            "test_hash_tuple",
            "test_constructor_complex_dtypes",
            "test_datapath_missing",
            "test_mutated",
            "test_closed_one_entry",
            "_tidy_repr",
            "test_stack_unstack_multiple",
            "_make_na_block",
            "test_bad_resolver_raises",
            "_get_frame_result_type",
            "test_assert_raises_regex_deprecated",
            "test_negone_ordinals",
            "_bool_and_frame",
            "test_ragged_quantile",
            "test_reindex_with_datetimes",
            "test_view",
            "test_range_in_series_indexing",
            "test_melt_missing_columns_raises",
            "_update_stacker",
            "test_replace_inplace",
            "test_to_csv_index_no_leading_comma",
            "is_freq_type",
            "test_columns_with_dups",
            "test_apply_index_implementations",
            "test_to_latex_bold_rows",
            "show_col_idx_names",
            "test_mixed_ops",
            "makeFY5253NearestEndMonthQuarter",
            "test_value_counts_datetime_tz",
            "test_datetimeindex_accessors",
            "_set_no_thousands_columns",
            "test_na_values_scalar",
            "test_invalid_plot_data",
            "test_contains_not_nans",
            "test_partial_setting_with_datetimelike_dtype",
            "test_iloc_returns_series",
            "_convert_data",
            "_asof_key",
            "test_nonexistent_path",
            "test_dialect_str",
            "test_nat_representations",
            "test_all_any_params",
            "str_pad",
            "test_groupby_datetime64_32_bit",
            "test_astype_to_same",
            "any_extension_types",
            "test_categorical_index_repr_ordered",
            "test_apply_raw",
            "test_loc_multiindex_too_many_dims_raises",
            "compare_series_cat",
            "test_boxplot_legacy1",
            "test_slice_locs_with_ints_and_floats_errors",
            "test_default_col_names",
            "test_slice_quarter",
            "test_multiindex_header_index",
            "test_bool_na_values",
            "test_utf16_bom_skiprows",
            "test_mul",
            "test_apply_mixed_datetimelike",
            "test_multiindex_contains_dropped",
            "test_nanmax",
            "test_set_levels_codes_directly",
            "_convert_bin_to_numeric_type",
            "test_mixed",
            "test_loc_getitem_label_list_fails",
            "_f3",
            "format_type",
            "test_datetimeindex_union_join_empty",
            "str_extractall",
            "test_is_array_like",
            "time_corrwith_rows",
            "frame_of_index_cols",
            "test_resample_not_monotonic",
            "_complib",
            "test_dt_conversion_preserves_name",
            "test_is_timedelta64_dtype",
            "test_processing_order",
            "makeIntervalIndex",
            "test_1d_bool",
            "tzframe",
            "test_slice_year",
            "test_freq_validation",
            "test_is_monotonic_incomparable",
            "test_corr_int",
            "time_period_to_datetime",
            "test_center_ljust_rjust_fillchar",
            "_get_seek_variable_labels",
            "test_read_empty_dta",
            "test_fails_and",
            "test_east_asian_len",
            "test_operators_datetimelike",
            "test_fillna_dataframe",
            "test_to_excel_multiindex_no_write_index",
            "test_period_from_ordinal",
            "is_uniform_reindex",
            "_factorize_keys",
            "_set_group_selection",
            "test_to_sparse_preserve_multiindex_names_columns",
            "test_nonunique_assignment_1750",
            "check_compressed_urls",
            "use_numexpr_cb",
            "test_invalid_complib",
            "test_concatlike_common_period_diff_freq_to_object",
            "is_re",
            "test_constructor_invalid_items_unused",
            "test_constructor_list_of_lists",
            "test_filter_out_no_groups",
            "test_store_index_name",
            "test_pct_change",
            "test_render_double",
            "test_all_not_none",
            "test_on_offset_implementations",
            "test_dt64_series_astype_object",
            "test_add_column_with_pandas_array",
            "test_compare_frame",
            "_validate_usecols_names",
            "test_expanding_corr_diff_index",
            "test_assert_almost_equal_iterables",
            "test_td64arr_rmod_tdscalar",
            "_test_data2",
            "test_applymap_subset_multiindex",
            "test_overflow_offset",
            "test_union_different_types",
            "test_parse_dates_combine",
            "skew",
            "test_xs_partial",
            "aggregate",
            "test_get_value_duplicates",
            "test_get_indexer_strings_raises",
            "test_multiple_date_col_timestamp_parse",
            "test_positional_take_unobserved",
            "test_write_row_by_row",
            "__get__",
            "maybe_convert_ix",
            "test_concat_tz_NaT",
            "test_convert_non_ns",
            "test_unpacker_hook_refcnt",
            "test_list_slice",
            "test_read_nrows_bad",
            "test_constructor_index_dtype",
            "register_plotting_backend_cb",
            "test_nat_iso_format",
            "test_compare_ticks_to_strs",
            "_init_matrix",
            "test_stringify_path_localpath",
            "no_description_period_with_directives",
            "test_time_accessor",
            "test_where_inplace",
            "idxmax",
            "__add__",
            "test_read_py2_hdf_file_in_py3",
            "density",
            "test2",
            "test_asfreq_resample_set_correct_freq",
            "test_dense_to_sparse",
            "test_nan_handling",
            "test_dataframe_dummies_drop_first_with_categorical",
            "test_names",
            "test_td_floordiv_null_scalar",
            "test_construction_caching",
            "curpath",
            "test_rolling_median",
            "_fast_count_smallints",
            "test_slice_len",
            "test_label_precision",
            "test_getitem_fill_value",
            "test_is_names_tuple_passes",
            "test_resample_tz_localized",
            "test_setting_with_copy_bug",
            "time_sparse_series_from_coo",
            "test_to_datetime_tz_pytz",
            "test_parse_nanoseconds_with_formula",
            "test_encode_dict_with_unicode_keys",
            "test_repr_column_name_unicode_truncation_bug",
            "test_sort",
            "is_int64_overflow_possible",
            "test_get_loc_cast_bool",
            "time_apply_index",
            "_join_i8_wrapper",
            "test_union_bug_4564",
            "bar",
            "test_categorical_repr_datetime_ordered",
            "test_to_datetime_infer_datetime_format_inconsistent_format",
            "test_ix_setitem_out_of_bounds_axis_1",
            "test_apply_dict_depr",
            "test_stack",
            "_mklbl",
            "time_replace_tz",
            "test_apply_multiindex_fail",
            "test_misc_example",
            "test_constructor_Series_differently_indexed",
            "apply_series_generator",
            "test_td_floordiv_numeric_series",
            "test_call",
            "test_groupby_transform",
            "_convert_list_indexer",
            "test_ops",
            "test_parsers",
            "time_read_sql_query_select_column",
            "test_array_ufunc_series_scalar_other",
            "_series_name",
            "_is_dtype_type",
            "_align_method_SERIES",
            "test_arg_for_errors_in_astype_dictlist",
            "test_constructor_set",
            "categorical",
            "test_rank_zero_div",
            "test_buffer_overflow",
            "test_invalid_variable_labels",
            "is_sparse",
            "test_integer_values_and_tz_deprecated",
            "test_reindex_empty_series_tz_dtype",
            "test_sort_index_and_reconstruction_doc_example",
            "test_stringify_path_fspath",
            "hash_pandas_object",
            "doc_parameters",
            "is_scipy_sparse",
            "xs",
            "test_parr_add_sub_datetime_scalar",
            "test_ix_categorical_index",
            "_rollback_to_year",
            "test_constructor_for_list_with_dtypes",
            "test_ndarray_inplace",
            "test_constructor_int_dtype_nan_raises",
            "test_unique_na",
            "test_nan_multiple_containment",
            "csv1",
            "test_NanosecondGeneric",
            "test_set_index_drop_inplace",
            "test_constructor_strptime",
            "test_line_plot_inferred_freq",
            "test_reduce_series",
            "test_to_coo_text_names_text_row_levels_nosort",
            "test_2d_float32",
            "_sort_levels_monotonic",
            "test_any_all",
            "test_interp_limit",
            "test_mixed_freq_irregular_first",
            "_hash_categorical",
            "test_max_fitting_element",
            "test_iloc_getitem_doc_issue",
            "test_drop_duplicates_inplace",
            "get_new_index",
            "test_append_mixed_dtypes",
            "test_unicode_repr_doesnt_raise",
            "test_nsmallest_nlargest",
            "create",
            "test_cut_pass_labels_compat",
            "nrows_expected",
            "test_gaps",
            "fail",
            "test_duplicate_groupby_issues",
            "test_interp_rowwise",
            "time_melt_dataframe",
            "test_multiindex_columns_empty_level",
            "test_grouper_index_level_as_string",
            "test_between_time",
            "df_letters",
            "test_constructor_range_based_deprecated",
            "test_execute_closed_connection",
            "test_series_append_aware_naive",
            "test_slicing",
            "test_duplicated",
            "test_delim_whitespace_custom_terminator",
            "data_for_sorting",
            "test_indexing_with_category",
            "test_float_index_non_scalar_assignment",
            "test_where_series_period",
            "test_datetime_name_accessors",
            "test_to_html_invalid_classes_type",
            "maybe_convert_indices",
            "test_read_hdf_errors",
            "test_cut_pass_labels",
            "assert_produces_warning",
            "test_tick_addition",
            "test_agg_transform",
            "test_to_string_utf8_columns",
            "test_to_sql_method_multi",
            "ensure_index",
            "test_invalid_quantile_value",
            "test_duplicated_columns",
            "test_examples1",
            "test_dti_timestamp_freq_fields",
            "test_grouped_box_return_type",
            "test_constructor_non_hashable_name",
            "_get_cells",
            "plot",
            "skip_if_no",
            "test_invalid_filtering",
            "test_categorical_equal",
            "test_constructor_spindex_dtype_scalar_broadcasts",
            "test_groupby_level_with_nas",
            "_index_name",
            "test_resample_with_timedeltas",
            "test_infer_dtype_bytes",
            "test_datetime_bin",
            "time_series_constructor",
            "test_strip_lstrip_rstrip_mixed",
            "rdivmod",
            "test_reindex_preserve_levels",
            "test_get_finder",
            "test_set_dtype_new_categories",
            "test_is_re_fails",
            "test_disallowed_nodes",
            "test_astype_with_view_mixed_float",
            "test_slice_locs_with_type_mismatch",
            "test_anchored_shortcuts",
            "imag",
            "test_reader_closes_file",
            "test_mixed_freq_shared_ax",
            "test_to_datetime_format_YYYYMMDD",
            "_check_results_to_coo",
            "test_parsers_quarterly_with_freq",
            "determine_clipboard",
            "test_isin_empty",
            "test_set_reset_index",
            "test_date_range_unsigned_overflow_handling",
            "_binify",
            "test_dti_shift_across_dst",
            "test_neg_numeric",
            "test_to_period",
            "test_timedeltas",
            "test_clip_types_and_nulls",
            "test_map_box",
            "randbool",
            "test_doc_example",
            "test_not_slice_like_slices",
            "align",
            "test_constructor_U",
            "test_usecols_with_single_byte_unicode_strings",
            "test_is_unique_interval",
            "test_loc_setitem_empty_append_raises",
            "test_safe_import_versions",
            "test_nanops",
            "test_maybe_promote_bool_with_any",
            "test_timestamp_to_datetime_explicit_pytz",
            "interpolate",
            "count_not_none",
            "test_is_period_dtype",
            "test_does_not_convert_mixed_integer",
            "_convert_to_list_like",
            "time_existing_series",
            "test_getitem_fancy_2d",
            "_view_wrapper",
            "test_pi_ops",
            "test_iloc_getitem_bool",
            "time_datetimes",
            "test_too_long",
            "test_read_with_start",
            "test_select_dtypes_include_exclude_mixed_scalars_lists",
            "time_frame_from_lists",
            "test_linspace_behavior",
            "validate_args_and_kwargs",
            "_process_rowsize_subheader",
            "invalidate_string_dtypes",
            "test_df_arith_2d_array_collike_broadcasts",
            "test_trailing_spaces",
            "test_setitem_fancy_boolean",
            "test_to_excel_interval_no_labels",
            "test_colspecs",
            "catch_to_csv_depr",
            "setup_connect",
            "test_rule_from_name",
            "time_is_quarter_end",
            "test_with_string_args",
            "test_shift_periods",
            "test_timetz_accessor",
            "property",
            "test_basic_regression",
            "test_encode_content_write_to_file",
            "test_is_overlapping",
            "test_series_ctor_datetime64",
            "test_type_promote_putmask",
            "test_ndarray_values",
            "_generate_multi_thread_dataframe",
            "test_reindex_fill_value",
            "test_is_strictly_monotonic_decreasing",
            "test_bar_subplots_center",
            "test_string_select",
            "test_wrap_aggregated_output_multindex",
            "test_from_records_dictlike",
            "_transform_item_by_item",
            "test_wom_len",
            "_format_axes",
            "test_constructor_maskedarray",
            "test_query_numexpr",
            "test_usecols_pass_non_existent_column",
            "time_floats_with_dt_index_lines",
            "test_reindex_indexer",
            "read_clipboard",
            "test_any_all_bool_only",
            "makeTimeDataFrame",
            "test_frame_from_json_precise_float",
            "_fletcher32",
            "test_constructor_positional",
            "test_concat_empty_and_non_empty_frame_regression",
            "test_schema",
            "list_incorrect_parameter_type",
            "center",
            "test_regex_replace_list_mixed",
            "test_to_datetime_format_microsecond",
            "test_getitem_dups_with_missing",
            "check_whitelist",
            "test_astype_with_view_float",
            "_get_registered_option",
            "test_compare_different_lengths",
            "test_groupby_sort_multi",
            "test_construction_consistency",
            "test_constructor_with_categorical_categories",
            "test_delta_to_tick",
            "test_iadd_preserves_name",
            "equals",
            "test_from_frame",
            "test_legacy_datetimetz_object",
            "no_change",
            "test_is_recompilable_passes",
            "test_cumcount_dupe_index",
            "test_to_timestamp_to_period_astype",
            "test_parsers_timezone_minute_offsets_roundtrip",
            "test_complibs",
            "test_apply_ignore_failures",
            "test_to_excel_interval_labels",
            "rename",
            "test_all2",
            "_convert_scalar_indexer",
            "test_constructor_range",
            "test_large_series",
            "test_deprecated_start_stop_step_attrs",
            "test_disable_bool_parsing",
            "test_shift_nan",
            "test_unstack_number_of_levels_larger_than_int32",
            "test_dti_business_summary_dateutil",
            "test_read_s3_jsonl",
            "_read_new_header",
            "time_html_repr_trunc_mi",
            "test_isin_nan_common_float64",
            "test_fixraw",
            "_on",
            "test_time_series_plot_color_kwargs",
            "_replacer",
            "test_get_level_number_out_of_bounds",
            "time_is_year_end",
            "test_ndframe_indexing_raises",
            "test_no_exit_status_noerrors_for_validate_all",
            "test_non_coerce_uint64_conflict",
            "is_file_like",
            "nseries",
            "test_convert_rows_list_to_csv_str",
            "test_invalid_arguments",
            "test_groupby_groups_datetimeindex",
            "test_multiple_matches",
            "test_setitem_list_of_tuples",
            "test_east_asian_unicode_true",
            "test_subtraction_ops",
            "test_repr_max_seq_item_setting",
            "_generate_range_overflow_safe",
            "test_to_excel_float_format",
            "test_concat_date_col_fail",
            "time_frame_float_div_by_zero",
            "test_int_conversion",
            "test_applymap_box_timestamps",
            "test_float_scalar_comparison",
            "test_nth_multi_index",
            "test_combineFrame",
            "test_reindex_axis",
            "test_multilevel_preserve_name",
            "quantile",
            "time_read_json",
            "_process_converter",
            "is_complex_dtype",
            "test_empty_csv_input",
            "test_groupby_multiple_columns",
            "test_get_duplicates",
            "test_empty_window_median_quantile",
            "time_align",
            "time_dup_seconds_and_unit",
            "rdiv",
            "test_fails_not",
            "test_to_dict_box_scalars",
            "test_to_excel_styleconverter",
            "test_union_sorted",
            "time_series_string",
            "test_datetimeindex",
            "test_custom_grouper",
            "test_sniff_delimiter",
            "test_is_lexsorted",
            "test_insert_index_datetimes",
            "test_categorical_series_repr_period",
            "_enable_data_resource_formatter",
            "test_reduce_invalid",
            "test_nunique_preserves_column_level_names",
            "test_rolling_apply_with_pandas_objects",
            "time_categorical_index_is_monotonic_decreasing",
            "test_from_tzaware_mixed_object_array",
            "test_setitem_fancy_1d",
            "infer_dtype_from_scalar",
            "test_constructor_dtype_list_data",
            "test_float_arithemtic_frame",
            "test_replace_invalid_kwarg",
            "_join_by_hand",
            "test_labels_deprecated",
            "test_conversion_float",
            "ensure_safe_environment_variables",
            "test_axis",
            "test_list_like_indexing",
            "test_sheets",
            "test_raises_empty_input",
            "_cast_sparse_series_op",
            "test_group_ohlc",
            "test_constructor_explicit",
            "test_datetime64_fillna",
            "test_not_subperiod",
            "test_constructor_with_stringoffset",
            "_searchsorted_monotonic",
            "test_dt64arr_series_sub_tick_DateOffset",
            "get_writer",
            "test",
            "test_unsupported_type",
            "_check_label_or_level_ambiguity",
            "time_convert",
            "test_td_sub_td",
            "_iterate_column_groupbys",
            "test_outside_int64_uint64_range",
            "_read_next_page",
            "test_allow_cmap",
            "test_multiindex_perf_warn",
            "time_parse_now",
            "test_construction_from_string_error_subtype",
            "test_functions_no_warnings",
            "test_infer_dtype_from_array",
            "test_parsers_iso8601_invalid",
            "test_take_preserve_name",
            "test_numpy_minmax_period",
            "test_business_freq_convert",
            "test_no_unnamed_index",
            "test_properties_annually",
            "test_rename_axis_style",
            "value",
            "test_multiple_id_columns",
            "time_upper",
            "test_nearest_workday",
            "needs_summary",
            "test_join_non_unique",
            "holds_integer",
            "test_combine_first_int",
            "test_hist_df",
            "test_more_than_one_ref",
            "time_merge_dataframe_integer_key",
            "test_get_loc_missing_nan",
            "compare",
            "_tables",
            "_nan_idxs",
            "test_getitem_multi_tuple",
            "test_displayed_only",
            "str_decode",
            "test_from_codes_with_float",
            "time_datetime_field_normalize",
            "test_3d_with_out",
            "test_rank_inf",
            "test_groupby_transform_timezone_column",
            "test_ragged_min",
            "test_nonzero_single_element",
            "test_dt64arr_series_add_tick_DateOffset",
            "test_cmov_mean",
            "test_mismatched_timezone_raises",
            "_get_offset",
            "time_get_dummies_1d",
            "test_apply_dup_names_multi_agg",
            "test_join_multi_levels",
            "time_getitem_list",
            "_map",
            "time_from_ints_daily",
            "_get_values",
            "test_write_preserves_original",
            "test_from_dti",
            "test_update_dtype_errors",
            "test_period_cons_nat",
            "test_unsorted_index_lims",
            "test_index_groupby",
            "test_big_dates",
            "test_apply_trivial",
            "test_dataframe_dummies_prefix_sep",
            "test_is_level_reference_df_ambig",
            "test_read_hdf_open_store",
            "test_equals_op",
            "test_numeric_df_columns",
            "test_from_pi",
            "test_resample_ambiguous_time_bin_edge",
            "test_timezone_info",
            "test_to_html_render_links",
            "_new_DatetimeIndex",
            "test_dateutil_tzoffset_support",
            "test_get_duplicates_deprecated",
            "clean_checkout",
            "test_is_datetime_dtypes",
            "test_add_invalid",
            "test_crosstab_pass_values",
            "test_timedelta_other_units",
            "time_map",
            "_repr_footer",
            "items",
            "test_reindex_base",
            "test_init_series",
            "test_append_length0_frame",
            "test_n_all_dtypes",
            "test_lookup_overflow",
            "test_set_labels_deprecated",
            "test_query_by_select_obj",
            "test_compress",
            "test_manualreset",
            "test_to_html_alignment_with_truncation",
            "test_bytes_exceed_2gb",
            "infer_axes",
            "get_pull_requests",
            "build_number_format",
            "test_wide_repr_named",
            "test_iloc_getitem_labels",
            "test_encode_double_conversion",
            "test_string_filename",
            "test_sparse_series_ops_fill",
            "test_take_axis_1",
            "test_single_element_ix_dont_upcast",
            "test_tuple_vars_fail_with_multiindex",
            "test_iloc_empty_list_indexer_is_ok",
            "na_value",
            "test_setitem_series_period",
            "_set_grouper",
            "test_remove_categories",
            "test_business_daily_look_alike",
            "_assemble_from_unit_mappings",
            "test_to_csv_with_dst_transitions",
            "test_array_header",
            "test_converters_no_implicit_conv",
            "test_resample_basic_from_daily",
            "test_pandas_gbq",
            "test_hist_kde_color",
            "time_add_overflow_scalar",
            "test_between_time_axis_raises",
            "test_constructor_spindex_dtype_scalar",
            "_create_missing_idx",
            "test_contains_with_float_index",
            "test_unstack_fill_frame_timedelta",
            "set_properties",
            "_value_counts_arraylike",
            "test_td64arr_div_nat_invalid",
            "time_multiindex_from_iterables",
            "_set_axis_name",
            "min",
            "test_is_not_integer_dtype",
            "test_valid_file_buffer_seems_invalid",
            "test_loc_getitem_not_monotonic",
            "qcut",
            "_flex_comp_method_FRAME",
            "test_values_consolidate",
            "time_parse_iso8601_tz",
            "test_tz_localize_ambiguous_bool",
            "test_equals_missing_values",
            "test_asfreq_mult",
            "test_multiple_date_col",
            "time_intersect",
            "test_extractall_single_group",
            "test_set_closed_errors",
            "test_decimals",
            "_getbool_axis",
            "test_nat_comparison_tzawareness",
            "get_base_missing_value",
            "test_downsample_but_actually_upsampling",
            "walk",
            "test_construction_from_period",
            "_load_test3_data",
            "test_infer_compression_from_path",
            "test_unknown_attribute",
            "test_empty_with_index",
            "test_series_groupby_plotting_nominally_works",
            "test_doc_string",
            "_maybe_process_deprecations",
            "test_plot_single_color",
            "test_from_array_keeps_base",
            "test_frame_add_tz_mismatch_converts_to_utc",
            "validate_cum_func_with_skipna",
            "test_double_quote",
            "_sub_period",
            "test_encode_unicode_4bytes_utf8",
            "test_xs_setting_with_copy_error",
            "test_date_parsing_ignores_format_details",
            "test_frame_to_period",
            "test_rolling_count",
            "_to_ordinalf",
            "test_asi8",
            "time_frame_comparison",
            "assert_matching",
            "test_dti_ne_null_scalar",
            "mid",
            "test_compression_warns_when_decompress_caches_blosc",
            "time_from_components",
            "test_tab_completion",
            "test_constructor_with_nas",
            "test_binary_functions",
            "test_n_identical_values",
            "test_pivot_string_as_func",
            "is_object_dtype",
            "_set_noconvert_columns",
            "test_from_arrays_different_lengths",
            "test_reader_dtype_str",
            "equal_levels",
            "_adjust_binner_for_upsample",
            "test_usecols_with_unicode_strings",
            "test_to_csv_chunking",
            "test_is_gcs_url",
            "test_build_series",
            "_write_body",
            "test_roll_yearday",
            "test_append_join_nondatetimeindex",
            "_ensure_frozen",
            "test_concat_exclude_none",
            "tips_df",
            "test_numpy_informed",
            "test_agg_dict_nested_renaming_depr",
            "test_tz_range_is_utc",
            "test_obj_none_preservation",
            "_delegate_method",
            "test_arithmetic_conversion",
            "test_constructor_cast_failure",
            "test_banklist_header",
            "test_qcut_return_intervals",
            "test_transform",
            "test_dt64arr_add_sub_period_scalar",
            "test_frame_select_complex",
            "time_monotonic_inc",
            "_rolling_consistency_cases",
            "test_unit_parser",
            "_skip_if_has_locale",
            "test_reduce_to_float",
            "test_asfreq_datetimeindex_empty_series",
            "length",
            "cbday_roll",
            "test_replace_preserves_nanos",
            "test_to_html_regression_GH6098",
            "test_string_indexing",
            "time_query_with_boolean_selection",
            "test_last_subset",
            "uint64_frame",
            "parse_date_fields",
            "test_julian_round_trip",
            "time_nested_dict_index",
            "test_append_multiple",
            "test_rolling_skew",
            "test_constructor_lists_to_object_dtype",
            "test_smaller_Raises_Type",
            "test_dt_accessor_no_new_attributes",
            "test_loc_non_unique",
            "testRollback1",
            "time_is_unique",
            "_isna_compat",
            "test_floor_and_ceil_functions_raise_error",
            "test_strl_latin1",
            "test_total_seconds_scalar",
            "test_union_noncomparable",
            "test_numpy_timedelta_scalar_indexing",
            "test_qcut_nat",
            "test_decode_broken_json",
            "test_dt64arr_sub_NaT",
            "test_unnamed_columns",
            "test_dt64_overflow_masking",
            "length_of_indexer",
            "test_pickle_unpickle",
            "test_datetimes",
            "_save_chunk",
            "any_skipna_inferred_dtype",
            "time_append_range_list",
            "test_is_",
            "test_dti_cmp_null_scalar_inequality",
            "test_resample_median_bug_1688",
            "time_series_dates",
            "_bool_arith_check",
            "mgr_locs",
            "highlight_min",
            "test_str_split",
            "test_interp_limit_no_nans",
            "test_cython_agg_frame_columns",
            "test_from_spmatrix_columns",
            "_assure_grouper",
            "compute_expected",
            "test_all_none_exception",
            "test_dt64ser_cmp_date_invalid",
            "value_counts",
            "test_groupby_with_dst_time_change",
            "test_str_list_query_method",
            "test_loc_to_fail",
            "test_rolling_std_1obs",
            "box",
            "test_lhs_expression_subscript",
            "test_insert_missing",
            "test_tzlocal_offset",
            "test_constructor_copy",
            "time_series_timestamp_compare",
            "test_loc_getitem_label_list_with_missing",
            "test_fillna_copy_frame",
            "test_read_dta1",
            "any_numpy_dtype_reduced",
            "test_mixed_index_assignment",
            "test_nan_data_with_int_dtype_raises_error",
            "test_partial_slice_second_precision",
            "test_mixed_underscores_and_spaces",
            "is_bool_indexer",
            "test_pairwise_with_other",
            "test_scientific_no_exponent",
            "test_read_dta4",
            "test_validate_inplace",
            "time_average_old",
            "test_series_period_index",
            "test_ext",
            "test_replace_with_dict_with_bool_keys",
            "na_cmp",
            "test_constructor_Series_named",
            "test_setitem_scalars_no_index",
            "test_replace_mixed",
            "test_bunched_yearends",
            "_left_indexer",
            "test_values_multiindex_periodindex",
            "test_mixin",
            "test_astype_all",
            "test_unsupported_datetype",
            "test_sparse_pow_issue",
            "test_expanding_corr_pairwise_diff_length",
            "_join_non_unique",
            "test_select_dtypes_empty",
            "test_sort_index_multiindex",
            "test_sem",
            "test_fontsize",
            "test_maybe_mangle_lambdas_listlike",
            "test_loc_datetime_length_one",
            "arrays_for_binary_ufunc",
            "get_splitter",
            "internal_values",
            "test_take_mixed_numeric",
            "test_ngroup_respects_groupby_order",
            "test_period_index_indexer",
            "test_npdiff",
            "test_remove_unused_nan",
            "test_to_latex_escape_special_chars",
            "test_no_mutate_but_looks_like",
            "write_legacy_file",
            "test_dti_union_mixed",
            "from_breaks",
            "test_margins_no_values_no_cols",
            "test_add_categories",
            "test_round_trip_preserve_multiindex_names",
            "test_dti_to_period",
            "test_empty_multi",
            "test_comparison_of_ordered_categorical_with_nan_to_scalar",
            "test_extension_array_cross_section",
            "_dtype_to_default_stata_fmt",
            "_parse_tables",
            "test_constructor_from_categorical_string",
            "_check_double_roundtrip",
            "test_series_nested",
            "test_roll_date_object",
            "test_objarr_radd_str_invalid",
            "update",
            "test_delitem_multiindex",
            "test_mixed_freq_regular_first",
            "tz",
            "test_ensure_int32",
            "time_lib_fast_zip",
            "test_ffill_mixed_dtypes_without_missing_data",
            "test_left_merge_empty_dataframe",
            "time_multi_columns",
            "test_frame_on",
            "test_count_level_series",
            "_get_variable_labels",
            "test_downcast_limits",
            "create_pickle_data",
            "test_to_string_with_col_space",
            "test_to_period_tz",
            "time_write_pickle",
            "__fspath__",
            "make_sparse",
            "test_take_fill_value_none_raises",
            "test_read_nokey",
            "test_concatlike_datetimetz",
            "test_detect_chained_assignment_warnings",
            "test_mixed_freq_lf_first",
            "test_agg_multiple_mixed_no_warning",
            "test_multifunc_select_col_integer_cols",
            "test_abs",
            "test_series_from_coo",
            "test_div_zero_inf_signs",
            "test_describe_categorical_columns",
            "test_map_tseries_indices_accsr_return_index",
            "mentioned_private_classes",
            "test_agg_dict_renaming_deprecation",
            "test_pivot_dtaccessor",
            "test_weekend_to_monday",
            "units_from_epochs",
            "bootstrap_plot",
            "test_over_specified",
            "test_groupby_boxplot_sharex",
            "test_array_repr_unicode",
            "test_tz",
            "readline",
            "test_date_range_linspacing_tz",
            "test_to_csv_quote_none",
            "test_astype_str_cast",
            "test_nange",
            "test_unstack",
            "test_null_byte_char",
            "visit_UnaryOp",
            "_get_na_rep",
            "test_regex_replace_scalar",
            "test_dup_datetime_index_plot",
            "test_resample_how_ohlc",
            "test_set_nan",
            "test_setitem_sequence_mismatched_length_raises",
            "test_dt64_series_add_intlike",
            "test_schema_support",
            "test_cmov_window_regular_linear_range",
            "test_to_csv_write_to_open_file_with_newline_py3",
            "_get_label",
            "test_deprecated_to_sparse",
            "check_binop",
            "test_setops_preserve_freq",
            "test_td64arr_floordiv_int",
            "test_stable_descending_sort",
            "testSignedInt",
            "test_string_datetime_like_compat",
            "test_dti_tz_convert_trans_pos_plus_1__bug",
            "test_dataframe_numpy_labelled",
            "test_index_equal_values_less_close",
            "_get_comb_axis",
            "test_series_repr_nat",
            "test_rolling_cov",
            "test_on",
            "platform_name",
            "validate_axis_style_args",
            "_compare_other",
            "int_frame_const_col",
            "test_mixed_float_int",
            "is_in_table",
            "__rmod__",
            "test_sort_index_intervalindex",
            "test_to_datetime_array_of_dt64s",
            "test_fillna_tzaware",
            "test_rank_mixed_frame",
            "test_weekmask_and_holidays",
            "_create_storer",
            "test_incorrect_dtype_raises",
            "test_groupby_boxplot_sharey",
            "_handle_usecols",
            "backfill_2d",
            "is_datetime",
            "assert_bool_op_calc",
            "test_where_dt_tz_values",
            "test_trim",
            "_get_index_columns",
            "_timezone",
            "test_center_ljust_rjust",
            "test_reset_index_tz",
            "test_frame_pad_backfill_limit",
            "test_categorical_aggfunc",
            "test_corrwith_mixed_dtypes",
            "test_get_period_field_array_raises_on_out_of_range",
            "test_qcut_nas",
            "test_cummin_cummax",
            "test_dti_cmp_list",
            "test_dti_union_aware",
            "test_df_div_zero_df",
            "test_get_indexer_closed",
            "test_partial_set_empty_frame_row",
            "test_standard_colors_all",
            "assert_is_sorted",
            "_is_convertible_to_index",
            "_null_fill_value",
            "_zsqrt",
            "_check_expression",
            "test_ufuncs_single_int",
            "test_inplace_no_assignment",
            "test_drop_empty_list",
            "time_lookup_and_cleanup",
            "test_constructor_invalid_tz",
            "test_repeat_preserves_tz",
            "test_slice_integer_frame_getitem",
            "_conv",
            "test_nlargest",
            "test_tdi_sub_int",
            "test_subclass_stack_multi",
            "test_multiindex",
            "_ensure_encoding",
            "lreshape",
            "test_constructor_ndarray_like",
            "tests_datetimeindex_freq_issue",
            "test_same_nan_is_in",
            "test_is_integer_dtype",
            "test_dtype_all_columns_empty",
            "test_chained_getitem_with_lists",
            "test_missing_minp_zero_variable",
            "test_comment_used",
            "test_raises_for_invalid_module_name",
            "_validate_dtype",
            "test_warning_case_insensitive_table_name",
            "test_ngroup_one_group",
            "test_isin_nan_common_object",
            "ensure_clean_store",
            "build_extensions",
            "test_interp_limit_area",
            "get_group",
            "time_itertuples_to_list",
            "test_memory_leak",
            "_null_terminate",
            "test_nonetype_top_level_bottom_level",
            "test_iadd_string",
            "test_bad_quoting",
            "register_series_accessor",
            "test_drop_duplicates_NA",
            "test_to_json",
            "check_round_trip_frame",
            "test_resample_loffset_upsample",
            "test_nans_equal",
            "month_name",
            "test_ragged_std",
            "test_path_localpath",
            "test_tolerance_forward",
            "test_iloc_setitem_list",
            "test_duplicated_with_nas",
            "test_max_multi_index_display",
            "time_insert",
            "test_datetime_with_timezone",
            "test_set_dtype_many",
            "test_groupby_agg_coercing_bools",
            "test_000constructor_resolution",
            "_get_index_name",
            "_new_PeriodIndex",
            "is_array_like",
            "test_python_docs_table",
            "_to_dict_of_blocks",
            "test_on_specialized_type_by_int",
            "test_setitem_cache_updating",
            "series",
            "test_from_records_to_records",
            "test_pivot_complex_aggfunc",
            "test_categorical_dtype_unsorted",
            "test_where_series",
            "test_reindex_no_type_preserve_target_empty_mi",
            "test_hashable",
            "test_bootstrap_plot",
            "_generate_marginal_results",
            "test_set_index_after_mutation",
            "test_shift_always_copy",
            "test_quoting_various",
            "test_to_csv_string_array_utf8",
            "validate_take_with_convert",
            "test_numeric_dtype",
            "test_zero_step_raises",
            "_get_project_id",
            "test_categories_none_comparisons",
            "test_comparison_of_ordered_categorical_with_nan_to_listlike",
            "test_insert_index_int64",
            "test_pivot_with_non_observable_dropna",
            "test_tz_localize_errors_ambiguous",
            "test_unicode_repr_issues",
            "test_usecols_implicit_index_col",
            "large_val",
            "test_binary_operators",
            "makePeriodSeries",
            "test_float_arithmetic_series",
            "test_int64_add_overflow",
            "test_list_float_complex",
            "_register_accessor",
            "test_is_datetime64_any_dtype",
            "test_concat_series_axis1",
            "test_assert_almost_equal_value_mismatch",
            "_add_margins",
            "test_constructor_sparse_dtype",
            "test_assert_numpy_array_equal_class_mismatch",
            "test_api_default_format",
            "test_set_fill_invalid_non_scalar",
            "_check_freq",
            "test_level_setting_resets_attributes",
            "_is_type",
            "format_dateaxis",
            "test_pi_sub_offset_array",
            "test_replace_dict_no_regex",
            "test_resample_loffset_count",
            "test_comparison_flex_basic",
            "test_indexing_unordered",
            "hash_tuples",
            "test_more_deeply_nested",
            "_maybe_dedup_names",
            "test_infer_freq_tz_transition_custom",
            "test_int64_factorize",
            "on_cols_multi",
            "time_all",
            "_get_converter",
            "test_get_none",
            "test_df_mod_zero_df",
            "test_concat_same_type",
            "setup_data",
            "test_mixed_offsets_with_native_datetime_raises",
            "test_info_repr_html",
            "test_grouped_hist_legacy",
            "test_missing_meta",
            "_clean_options",
            "test_partition_deprecation",
            "test_assert_not_almost_equal_numbers_with_mixed",
            "merge_cells",
            "as_timestamp",
            "test_astype_categorical",
            "to_clipboard",
            "test_repr_html_ok",
            "test_groupby_level_nonmulti",
            "_get_time_period_bins",
            "test_maybe_promote_object_with_any",
            "test_reindexing",
            "test_to_coo_text_names_text_row_levels_nosort_col_level_single",
            "test_get_unique",
            "test_integer_arithmetic_series",
            "test_qcut_include_lowest",
            "_dt_to_float_ordinal",
            "test_series_inconvertible_string",
            "test_categorical_series_repr_timedelta_ordered",
            "test_euro_decimal",
            "test_non_contiguous",
            "nbytes",
            "test_is_bool_dtype",
            "_maybe_add_count",
            "test_write_lists_dict",
            "test_getitem_empty_frame_with_boolean",
            "compare_series_ts",
            "create_block",
            "test_operators_reverse_object",
            "create_msgpack_data",
            "test_nonetype_multiple_levels",
            "box_transpose_fail",
            "time_datetime_field_year",
            "_clip_with_scalar",
            "melt",
            "test_is_scalar_builtin_nonscalars",
            "_check_generated_range",
            "test_to_dense_preserve_name",
            "_maybe_transform_eq_ne",
            "test_infer_dtype_period",
            "test_rgb_tuple_color",
            "test_nanmean_overflow",
            "test_sparse_frame_pad_backfill_limit",
            "time_med_get_loc",
            "parallel_coordinates",
            "clean_interp_method",
            "test_multiindex_na_repr",
            "test_agg_relabel_non_identifier",
            "test_apply_broadcast_error",
            "_check_behavior",
            "test_usecols_regex_sep",
            "test_to_integer_array_dtype_keyword",
            "test_ix_align",
            "maybe_box_datetimelike",
            "sequence_to_td64ns",
            "test_outer_join",
            "test_slice_float_locs",
            "test_colspan_rowspan_copy_values",
            "str_extract",
            "test_setitem_callable",
            "test_to_html_with_index_names_false",
            "test_qcut_duplicates_bin",
            "test_timestamp_tz_localize_nonexistent_shift",
            "test_springforward_singular",
            "simple",
            "_index_end",
            "_process_format_subheader",
            "test_apply_future_warning",
            "test_rolling_corr_diff_length",
            "_pprint_dict",
            "init_xsel_clipboard",
            "test_maybe_promote_datetimetz_with_na",
            "test_no_millisecond_field",
            "test_selection",
            "test_resample_with_only_nat",
            "time_transform_lambda_max",
            "test_regex_replace_list_obj_inplace",
            "test_complex_append",
            "set_metadata",
            "test_td64arr_mul_int",
            "test_constructor_tuple_of_tuples",
            "test_at_inside_string",
            "test_consistency_with_window",
            "test_apply_same_length_inference_bug",
            "test_index_equal_names",
            "test_join_level",
            "test_remove_unused_levels_large",
            "std",
            "test_default_dtype",
            "test_basic2",
            "test_pivot_table_aggfunc_dropna",
            "test_stack_multiple_bug",
            "_isna_ndarraylike",
            "test_tz_aware_asfreq",
            "dispatch_missing",
            "test_dialect",
            "skip_if_installed",
            "test_date_range_convenience_periods",
            "should_series_dispatch",
            "test_daterange_bug_456",
            "get_objs",
            "test_missing_public_nat_methods",
            "test_store_series_name",
            "test_deprecate_ok",
            "_check_expected_dtype",
            "test_validate_indices_ok",
            "test_rank_axis",
            "make_data",
            "test_string_no_dates",
            "test_groupby_non_arithmetic_agg_types",
            "test_expanding",
            "test_warns",
            "names",
            "maybe_infer_dtype_type",
            "_is_valid_endpoint",
            "test_raise_from_object_hook",
            "test_filter_row_groups",
            "test_pi_sub_isub_offset",
            "test_encode_set",
            "test_constructor_no_data_index_order",
            "test_frame_invert",
            "_init_spmatrix",
            "test_dt64arr_timestamp_equality",
            "test_registry",
            "time_month_name",
            "test_shift_no_freq",
            "test_concat_no_unnecessary_upcast",
            "test_how_lambda_functions",
            "test_concat_different_fill",
            "test_resample_quantile",
            "test_read_excel_blank_with_header",
            "test_partial_loc_missing",
            "test_to_dict_errors",
            "test_div_int",
            "test_lag_plot",
            "test_concat_empty_series_timelike",
            "test_flat_stays_flat",
            "test_read_excel_bool_header_arg",
            "test_resample_to_timestamps",
            "test_combine_first",
            "test_container_shift",
            "test_shift_bool",
            "test_update_ctx",
            "test_query_long_float_literal",
            "test_non_sparse_raises",
            "test_invalid",
            "_get_join_indexers",
            "test_from_product_invalid_input",
            "_update_ctx",
            "data_for_grouping",
            "test_expand_frame_repr",
            "_can_reindex",
            "_make_concat_multiindex",
            "test_guess_datetime_format_with_dayfirst",
            "kurt",
            "test_expanding_axis",
            "time_mult",
            "upsample_method",
            "test_series_tz_localize",
            "process_class_docstrings",
            "test_join_on_series",
            "test_constructor_invalid_frequency",
            "max",
            "test_parser",
            "makeFY5253LastOfMonthQuarter",
            "time_append_obj_list",
            "test_freeze_panes",
            "test_stack_partial_multiIndex",
            "test_concat_multiple_tzs",
            "test_constructor_datetime64_tzformat",
            "generate_bins_generic",
            "test_round_dst_border_ambiguous",
            "test_complex_mixed_fixed",
            "index_labels_to_array",
            "test_constructor_dtype_str",
            "test_missing_trailing_delimiters",
            "test_spss_labelled_num_na",
            "test_start_stop_step_attrs",
            "test_where_with_one_style",
            "test_concat_same_type_invalid",
            "test_assert_almost_equal_timestamp",
            "test_na_value_dict_multi_index",
            "read_parquet",
            "_read_int",
            "test_astype_raises",
            "test_readjson_each_chunk",
            "assert_check_nselect_boundary",
            "test_isnumeric",
            "test_grouping_string_repr",
            "test_groupby_timedelta_cython_count",
            "check_chained_cmp_op",
            "test_constructor_simple_new",
            "_get_properties",
            "git_pieces_from_vcs",
            "test_mixed_index_at_iat_loc_iloc_series",
            "_ensure_numeric",
            "_wrap_aggregated_output",
            "__copy__",
            "test_float_index_at_iat",
            "test_nanargmin",
            "_nanminmax",
            "_concat_same_dtype",
            "time_isnull_obj",
            "test_int_series_slicing",
            "test_loc_getitem_series",
            "test_tz_conversion_freq",
            "test_constructor_with_datetimes",
            "test_interpolate_piecewise_polynomial",
            "test_cmov_window_regular",
            "test_reindex_duplicate_target",
            "test_parse_time_string",
            "test_hash_pandas_object",
            "test_frame_group_ops",
            "test_from_records_lists_generator",
            "test_embedded_newline",
            "_evaluate",
            "_save",
            "test_disallow_python_keywords",
            "freqstr",
            "test_finder_hourly",
            "test_dti_to_pydatetime_fizedtz",
            "test_dialect_conflict_delimiter",
            "ints_to_td64ns",
            "test_append_missing_cols",
            "test_constructor_error_msgs",
            "_get_exec",
            "time_loc_list",
            "test_astype_no_copy",
            "test_groupby_function_rename",
            "test_rank_categorical",
            "_from_nested_dict",
            "time_to_julian_date",
            "test_setitem_fancy_2d",
            "check_nancomp",
            "test_array_type",
            "test_stack_int_level_names",
            "test_parametrized_factorize_na_value",
            "test_days",
            "test_constructor_str_category",
            "test_infer_freq_delta",
            "test_unit_rounding",
            "time_loc_dups",
            "test_pivot_table_categorical_observed_equal",
            "notna",
            "test_set_index_multiindexcolumns",
            "test_reindex_lvl_preserves_names_when_target_is_list_or_array",
            "test_centered_axis_validation",
            "maybe_convert_objects",
            "test_from_array",
            "test_period_ordinal_business_day",
            "_get_fill_value",
            "_get_values_tuple",
            "test_setitem_single_column_mixed",
            "_maybe_update_attributes",
            "time_reshape_pivot_time_series",
            "test_from_arrays_iterator",
            "test_large",
            "time_frame_drop_dups_bool",
            "test_interp_raise_on_only_mixed",
            "test_apply_subset",
            "test_guess_datetime_format_for_array",
            "_ts_plot",
            "test_slice_float_get_set",
            "test_repr_html_mathjax",
            "time_crosstab_values",
            "test_validate_bool_kwarg_fail",
            "test_numpy_all",
            "_check_resolvers",
            "test_from_tuples",
            "wrap",
            "test_sort2",
            "test_to_frame_dtype_fidelity",
            "generate_regular_range",
            "rename_axis",
            "test_xticklabels",
            "test_alias_equality",
            "test_assign_multiple",
            "nlevels",
            "test_df_numeric_cmp_dt64_raises",
            "test_strobj_mode",
            "test_unsorted_index_xlim",
            "test_numeric_object_likes",
            "test_from_inferred_categories_sorts",
            "test_convert_objects_no_conversion",
            "test_dt_round",
            "test_datetime_other_units",
            "test_frame_dict_constructor_empty_series",
            "time_series_nth",
            "is_label_like",
            "test_array_interface_tz",
            "test_get_loc_level",
            "test_usecols_relative_to_names2",
            "test_round_trip_equals",
            "_attempt_YYYYMMDD",
            "_preprocess_slice_or_indexer",
            "test_union_sort_other_incomparable",
            "test_table_attributes",
            "test_array_inference_fails",
            "test_fillna_tzaware_different_column",
            "test_extract_optional_groups",
            "time_make_union",
            "test_update_nooverwrite",
            "test_df_arithmetic_subexpression",
            "_convert_freq",
            "errors",
            "test_replace_limit",
            "_assert_take_fillable",
            "_write_value_label_names",
            "test_get_option",
            "test_append_frame_column_oriented",
            "test_frame_subclassing_and_slicing",
            "time_timedelta_microseconds",
            "ydiffs",
            "test_encode_big_escape",
            "test_dropna_invalid_how_raises",
            "read",
            "test_factory",
            "test_basic_series_frame_alignment",
            "test_duplicated_keep",
            "_initialize_stacker",
            "test_fillna_series_method",
            "test_constructor_with_convert",
            "test_iter_object_try_string",
            "test_cummin",
            "test_nan_first_take_datetime",
            "test_getitem_callable",
            "style",
            "_coerce_scalar_to_timedelta_type",
            "test_loc_getitem_tuple_plus_slice",
            "export",
            "test_single_quantile",
            "test_safe_import_exists",
            "test_constructor_list_of_ranges",
            "test_multiple_delimiters",
            "test_insert_index_object",
            "test_apply_with_reduce_empty",
            "_make_cum_function",
            "test_resample_datetime_values",
            "test_asm8",
            "test_constructor_na_dtype",
            "test_iso8601_strings_mixed_offsets_with_naive",
            "time_lower",
            "test_getattr",
            "test_array32",
            "test_apply_dont_convert_dtype",
            "test_constructor_dtype_datetime64",
            "test_sparse_repr_after_set",
            "test_converters_type_must_be_dict",
            "_warn_if_deprecated",
            "test_where_dups",
            "test_multiple_date_cols_int_cast",
            "test_dtype",
            "mean",
            "write_data_chunk",
            "test_join_on_fails_with_different_left_index",
            "_validate_monotonic",
            "_maybe_arg_null_out",
            "test_filter_regex_search",
            "test_interp_non_timedelta_index",
            "test_get_loc_tolerance",
            "test_series_tz_convert_to_utc",
            "test_rounding_on_int_unit_construction",
            "build_xlstyle",
            "test_apply_deprecate_reduce",
            "test_write_index",
            "test_multiple_date_cols_chunked",
            "test_iter_empty",
            "table_schema_cb",
            "test_values_boxed",
            "test_set_fill_value",
            "test_left_join_indexer2",
            "test_encode_empty_set",
            "test_partition_on_supported",
            "test_depreciate_tz_and_tzinfo_in_datetime_input",
            "test_filter_unicode",
            "test_op_duplicate_index",
            "test_outer_join_sort",
            "time_replace_series",
            "test_factorized_sort",
            "test_invalid_arg",
            "test_pi_add_intarray",
            "test_minute",
            "test_sub",
            "test_sparse_bool",
            "test_auto_detect",
            "test_concat_NaT_dataframes",
            "test_dt64arr_add_td64_scalar",
            "test_mode_sortwarning",
            "test_regex_replace_dict_nested_non_first_character",
            "test_info_memory_usage_qualified",
            "test_is_error_nozeroindex",
            "test_execute",
            "test_td_add_timedelta64",
            "to_datetime",
            "observed",
            "box_in_series",
            "time_infer_dst",
            "test_roll",
            "test_array_repr",
            "test_grouping_error_on_multidim_input",
            "test_td64arr_add_sub_tdi",
            "test_set_index_pass_multiindex",
            "test_date_range_with_fixedoffset_noname",
            "between_time",
            "test_unbounded_slice_raises",
            "test_multiple_date_col_name_collision",
            "_check_ax_scales",
            "test_resample_categorical_data_with_timedeltaindex",
            "_get_formatted_column_labels",
            "test_freq_group",
            "test_asfreq_normalize",
            "time_getitem_scalar",
            "floor",
            "_make_iris_table_metadata",
            "test_to_latex_special_escape",
            "testPackFloat",
            "test_parallel_coordinates_with_sorted_labels",
            "HolidayCalendarFactory",
            "test_set_index_empty_column",
            "test_concat_categorical_ordered",
            "test_td64arr_add_timestamp",
            "time_get_loc_non_unique_sorted",
            "test_bar_align_mid_vmin",
            "test_maybe_promote_string_with_any",
            "test_allow_exact_matches_nearest",
            "test_iat",
            "concatenate_join_units",
            "test_series_interpolate_method_values",
            "test_fillna_overlap",
            "test_constructor_from_series",
            "test_frame_repr",
            "test_partial_slice_high_reso",
            "validate_multiindex",
            "test_line_plot_period_mlt_frame",
            "test_constructor_dict_of_ranges",
            "test_subplot_titles",
            "test_construction_with_ndarray",
            "_pickle_roundtrip_name",
            "test_header_multi_index_common_format_malformed1",
            "test_set_dtype_no_overlap",
            "test_isin_tuples",
            "test_no_keep_default_na_dict_na_values_diff_reprs",
            "test_nanvar_axis",
            "_onOffset",
            "test_mixed_array_comparison",
            "test_from_arrays_index_series_period",
            "test_round_minute_freq",
            "test_to_sql_type_mapping",
            "test_groupby_head_tail",
            "_check_merge",
            "test_frame_getitem_multicolumn_empty_level",
            "test_to_dict_not_unique_warning",
            "test_plain",
            "test_rename_axis_none",
            "tshift",
            "test_asfreq_nat",
            "test_remove_unused_categories",
            "_test_compression_warns_when_decompress_caches",
            "is_full",
            "test_make_block_no_pandas_array",
            "test_date_range_businesshour",
            "validate_minmax_axis",
            "unique",
            "visit_Attribute",
            "test_append_index",
            "test_timegrouper_with_reg_groups_freq",
            "mem_itertuples_read_first",
            "test_dt64arr_add_sub_td64ndarray",
            "test_subclass_stack",
            "test_get_loc_tolerance_no_method_raises",
            "_check_equal",
            "time_multi_count",
            "_set_option",
            "test_fillna_columns",
            "as_frame",
            "ngroups",
            "test_to_datetime_format_time",
            "test_different_nan_objects",
            "test_constructor_empty_list",
            "test_parse_dates_string",
            "time_ewm",
            "is_extension_array_dtype",
            "test_frame_index_to_string",
            "test_str_cat",
            "_single_replace",
            "test_series_getitem_multiindex_xs",
            "test_coerce_uint64_conflict",
            "test_bar_log",
            "test_drop_unique_and_non_unique_index",
            "_remove_whitespace",
            "test_equals_object",
            "test_contains_for_object_category",
            "test_get_loc_implicit_cast",
            "test_pop",
            "test_apply_ticks",
            "test_full_file_with_missing",
            "test_iloc_exceeds_bounds",
            "test_upsample_daily_business_daily",
            "assigner",
            "test_series_partial_set",
            "test_fy5253qtr_onoffset_last",
            "time_frame",
            "test_equals_op_multiindex",
            "test_read_from_py_localpath",
            "test_date_explicit_date_format",
            "_map_values",
            "test_replace_literal",
            "objects_to_td64ns",
            "test_to_datetime_list_of_integers",
            "ea_passthrough",
            "git_versions_from_keywords",
            "test_from_json_to_json_table_index_and_columns",
            "test_changing_names",
            "test_where_series_complex128",
            "test_comment_whitespace_delimited",
            "test_float_parser",
            "test_na_substitution",
            "_prev_opening_time",
            "_is_numeric_mixed_type",
            "test_attrs",
            "use",
            "time_convert_int",
            "continue_maybe2",
            "time_frame_getitem_single_column_int",
            "not_daily",
            "test_apply_fill",
            "apply_standard",
            "test_comparison_protected_from_errstate",
            "test_series_fast_transform_date",
            "test_addition_ops",
            "test_column_multiindex",
            "test_is_recompilable_fails",
            "test_reindex_index",
            "test_duplicate_keep_all_ties",
            "test_drop_dst_boundary",
            "test_df_grid_settings",
            "test_fwf_colspecs_is_list_or_tuple_of_two_element_tuples",
            "test_filter_non_bool_raises",
            "test_register_by_default",
            "maybe_make_list",
            "test_getslice",
            "_skip_if_different_combine",
            "test_numpy_array_all_dtypes",
            "test_read_with_startstop",
            "test_downcast_conversion_empty",
            "frame_apply",
            "test_setitem_series_datetime64tz",
            "_quarterly_finder",
            "_repr_categories_info",
            "_extend_blocks",
            "coerce",
            "_get_dtype",
            "test_nan_interpolate",
            "time_from_ints",
            "test_pickle_compat_construction",
            "test_column_dups_operations",
            "uint_dtype",
            "test_sum_uint64_overflow",
            "test_info_shows_column_dtypes",
            "test_non_unique_moar",
            "test_tz_convert_utc_with_system_utc",
            "test_nanne",
            "test_freq_offsets",
            "test_readjson_chunks_closes",
            "test_is_dtype_unboxes_dtype",
            "test_hist_layout",
            "test_loc_setitem",
            "test_join_outer",
            "test_shallow_copying",
            "test_binop_maybe_preserve_name",
            "test_constructor_from_index_dtlike",
            "test_np_sum",
            "test_shape",
            "test_to_datetime_format",
            "test_putmask_with_wrong_mask",
            "test_x_multiindex_values_ticks",
            "test_dups_fancy_indexing2",
            "test_quarterly_upsample",
            "test_get_day_of_year_dt",
            "test_local_syntax",
            "test_between",
            "write_multi_index",
            "_get_business_hours_by_sec",
            "time_datetime_level_values_sliced",
            "time_to_sql_dataframe_column",
            "test_empty",
            "test_get_loc",
            "test_usecols_wrong_type",
            "test_encode_null_character",
            "test_finder_quarterly",
            "test_ts_line_lim",
            "test_get_to_timestamp_base",
            "test_drop_duplicates",
            "test_concatlike_datetimetz_to_object",
            "test_assert_numpy_array_equal_value_mismatch5",
            "_decode_complex",
            "test_clip_against_series",
            "test_hist_colors",
            "test_quantile_axis_parameter",
            "_getitem_bool_array",
            "test_reasonable_key_error",
            "time_datetime_to_period",
            "test_merged_cell_custom_objects",
            "test_getitem_out_of_bounds",
            "_valid_locales",
            "test_rands_array_1d",
            "test_fancy_index_misc",
            "test_union_dtypes",
            "test_is_list_like_disallow_sets",
            "test_replace_integer_args",
            "_is_strictly_monotonic_decreasing",
            "test_math_sub",
            "end_blank_lines",
            "test_colspan_rowspan_1",
            "time_timestamp_ops_diff_with_shift",
            "interp_methods_ind",
            "dtype_for",
            "time_iter_preexit",
            "test_na_tuples",
            "test_attr_wrapper",
            "test_apply_dict",
            "test_where_index_period",
            "test_interleave",
            "test_bool_describe_in_mixed_frame",
            "test_constructor_dtypes_to_datetime",
            "test_frame_getitem_toplevel",
            "test__is_dtype_type",
            "_check_all",
            "_get_time_bins",
            "test_usecols_with_integer_like_header",
            "test_frame_equal_index_dtype_mismatch",
            "add_methods",
            "test_subclassed_wide_to_long",
            "test_engineless_lookup",
            "test_constructor_floats",
            "test_alignment_non_pandas",
            "_ensure_data",
            "test_year_has_extra_week",
            "test_usecols_with_multi_byte_characters",
            "_field_accessor",
            "test_diff_axis",
            "test_astype_dispatches",
            "time_replace_None",
            "test_vector_resize",
            "test_to_frame_datetime_tz",
            "test_cmov_window",
            "test_escapechar",
            "get_sheet_data",
            "test_min",
            "test_hide_multiindex",
            "test_index_ctor_nat_result",
            "peakmem_itertuples_start",
            "time_frame_sort_values_by_columns",
            "_failover_to_python",
            "test_naive_datetimeindex_roundtrip",
            "test_subclass_unstack_multi_mixed",
            "time_rendering",
            "test_reindex_preserves_tz_if_target_is_empty_list_or_array",
            "test_setitem_with_datetime_tz",
            "maybe_upcast_for_op",
            "get_items",
            "symmetric_difference",
            "buffer",
            "test_hasnans_isnans",
            "test_empty_with_dup_column_pass_dtype_by_indexes",
            "_convert_object_array",
            "str_endswith",
            "test_parr_add_sub_float_raises",
            "is_s3_url",
            "test_sparse_series_round_trip",
            "test_object_refcount_bug",
            "no_description_period_with_directive",
            "test_dataframe_utc_true",
            "test_astype_from_object",
            "evaluate",
            "test_from_dtype_from_float",
            "test_union_sort_other_incomparable_sort",
            "time_read_store_table_mixed",
            "test_series_numeric",
            "create_block_manager_from_blocks",
            "test_getitem_arraylike_mask",
            "test_callback",
            "conda_package_to_pip",
            "test_ts_frame",
            "time_kth_smallest",
            "load_newobj_ex",
            "test_str_cat_special_cases",
            "test_set_names_unset",
            "test_groupby_one_row",
            "time_asof_nan",
            "test_loc_multiindex_ints",
            "round_trip_pathlib",
            "test_where_warns",
            "test_concat_categorical_3elem_coercion",
            "test_is_interval_dtype",
            "_concat_sparse",
            "_consolidate",
            "test_constructor_list_of_series",
            "_consolidate_check",
            "test_result_type",
            "test_apply_with_mixed_dtype",
            "test_summary",
            "test_options_fp",
            "test_sub_day",
            "assert_levels_dropped",
            "test_put",
            "test_df_add_flex_filled_mixed_dtypes",
            "_check_arg_length",
            "__getitem__",
            "time_loc_array",
            "test_fillna_skip_certain_blocks",
            "getCols",
            "test_read_local_jsonl",
            "test_duplicate_columns",
            "test_resample_daily_anchored",
            "test_default_handler_indirect",
            "test_operators_datetimelike_invalid",
            "time_corr_series",
            "test_freq_divides_end_in_nanos",
            "test_sort_index_level_large_cardinality",
            "test_read_json_table_convert_axes_raises",
            "test_constructor_use_start_freq",
            "time_med_get_loc_warm",
            "test_rename_categories_series",
            "test_bool_flex_frame",
            "test_dti_constructor_small_int",
            "test_iloc_returns_dataframe",
            "test_range_slice_outofbounds",
            "test_validate_median_initial",
            "to_msgpack",
            "_parse_thead_tr",
            "set_timezone",
            "test_fillna_period",
            "test_to_string_line_width_no_index",
            "test_resample_weekly_bug_1726",
            "test_loc_non_unique_memory_error",
            "test_parser_error_on_empty_header_row",
            "_compare_with_tz",
            "test_nunique_with_timegrouper_and_nat",
            "_filters",
            "_interleaved_dtype",
            "test_repr_missing",
            "_getitem_frame",
            "test_write_variable_labels",
            "test_default_left_closed_label",
            "time_reindex_method",
            "test_argmin_argmax",
            "_init_mgr",
            "test_chained_cmp_op",
            "test_pi_cmp_nat_mismatched_freq_raises",
            "ftypes",
            "is_true_slices",
            "_attr_getter",
            "test_merge_incompat_dtypes_are_ok",
            "test_dt64arr_sub_dtscalar",
            "time_slice",
            "test_floor_division",
            "test_constructor_numeric",
            "get_freq",
            "test_iloc_integer_locations",
            "test_xs_level_series_slice_not_implemented",
            "test_to_csv_quotechar",
            "test_astype_float",
            "test_empty_with_mangled_column_pass_dtype_by_names",
            "test_multiindex_header_index_skiprows",
            "test_display_subset",
            "time_pivot_table_categorical_observed",
            "test_constructor_tz_or_tzinfo",
            "test_quantile_interpolation_datetime",
            "test_get_slice",
            "idxmin",
            "test_non_monotonic_reindex_methods",
            "time_isin_nan_values",
            "test_append_overlap_raises",
            "test_setitem_frame_align",
            "test_plot_multiple_inferred_freq",
            "should_warn",
            "check_coerce",
            "is_categorical_dtype",
            "test_alignment",
            "test_isin_empty_datetimelike",
            "test_get_loc_outside_tolerance_raises",
            "test_groupby_groups_datetimeindex_tz",
            "strides",
            "test_constructor_dict_datetime64_index",
            "test_from_records_len0_with_columns",
            "test_concat_keys_and_levels",
            "test_ix_get_set_consistency",
            "test_series_ctor_plus_datetimeindex",
            "test_header_inferred_from_rows_with_only_th",
            "test_secondary_y_irregular_ts_xlim",
            "_combine_hash_arrays",
            "_sub_datetimelike_scalar",
            "test_isin_level_kwarg_bad_label_raises",
            "test_empty_df_expanding",
            "test_mask_callable",
            "test_unbalanced_quoting",
            "test_rolling_corr_pairwise",
            "test_groupby_cumprod",
            "test_tdi_ops_attributes",
            "test_frame_equal_columns_mismatch",
            "test_block_names",
            "test_assert_extension_array_equal_less_precise",
            "test_labels_dtypes",
            "test_operator_series_comparison_zerorank",
            "test_dti_constructor_preserve_dti_freq",
            "test_concat_different_extension_dtypes_upcasts",
            "test_agg_python_multiindex",
            "nanos",
            "test_maxbuffersize_read_size_exceeds_max_buffer_size",
            "validate_rolling_func",
            "test_no_reference_cycle",
            "test_constructor_dtypes_to_int64",
            "UnicodeWriter",
            "test_to_html_no_index_max_rows",
            "_sparse_series_to_coo",
            "test_astype_array_fallback",
            "test_constructor_sequence",
            "test_search_sorted_datetime64_scalar",
            "test_to_csv_multiindex",
            "time_boolean_series",
            "test_round_subsecond",
            "test_nancorr",
            "value_labels",
            "test_skip_rows_skip_all",
            "test_resample_how_method",
            "nanprod",
            "test_tuples_with_name_string",
            "time_getitem_list_like",
            "test_frame_indexing_single",
            "test_concatlike_datetimetz_short",
            "_normalize_keyword_aggregation",
            "test_reset_option_all",
            "test_rename_bug2",
            "test_order_without_freq",
            "test_from_records_with_index_data",
            "test_categorical_ordered_none_deprecated",
            "test_compare_ticks",
            "test_to_integer_array_float",
            "test_sort_index_nan",
            "rep_stamp",
            "time_scalar_function_multi_col",
            "signed",
            "_is_label_reference",
            "test_to_string_ascii_error",
            "test_convert_numeric_uint64",
            "_series_and_frame",
            "test_invalid_encoding",
            "time_searchsorted",
            "test_astype_str",
            "test_overlapping_datetime",
            "test_comment_skiprows_header",
            "test_min_valid",
            "test_frame_getitem_simple_key_error",
            "test_shift_identity",
            "_get_version",
            "_create_table_setup",
            "test_where_index_datetimetz",
            "test_loc_with_slices",
            "test_tdi_add_dt64_array",
            "test_plot_offset_freq",
            "_can_hold_na",
            "test_is_not_string_type",
            "test_unstack_mixed_extension_types",
            "test_dst_transitions",
            "test_constructor_from_index_series_datetimetz",
            "h",
            "test_mode_single",
            "test_add_matplotlib_datetime64",
            "test_shallow_copy_empty",
            "test_groupby_categorical_index_and_columns",
            "test_read_column",
            "__or__",
            "time_with_nan",
            "test_drop_api_equivalence",
            "test_iloc_series",
            "test_ewma_span_com_args",
            "_filter_usecols",
            "test_raise_when_saving_timezones",
            "test_extract_expand_None",
            "_get_options_with_defaults",
            "is_normalized",
            "makeStringSeries",
            "_add_logical_methods_disabled",
            "index_cols",
            "test_raise_on_drop_duplicate_index",
            "get_validation_data",
            "_set_item",
            "all_timeseries_index_generator",
            "set_attrs",
            "_convert_slice_indexer",
            "test_index_cast_datetime64_other_units",
            "test_interval_array_equal_closed_mismatch",
            "test_merge_datetime_index",
            "test_fillna_datetime64",
            "test_plot_scatter_with_c",
            "epochs",
            "test_invalid_raises",
            "test_read_explicit",
            "rindex",
            "test_day_not_in_month_coerce",
            "test_constructor_dict",
            "time_get_loc_inc",
            "_record_count",
            "test_sort_datetimelike",
            "test_highlight_null",
            "format_query",
            "time_on_offset",
            "test_case_insensitive",
            "compression_only",
            "integer_parameter",
            "time_exact",
            "is_datetimetz",
            "test_apply_convert_objects",
            "test_from_arrays_invalid_input",
            "_load_raw_sql",
            "test_to_datetime_with_non_exact",
            "_test_offset",
            "test_valid",
            "time_reindex_multiindex",
            "salaries_table",
            "set_atom_categorical",
            "test_transform_numeric_to_boolean",
            "test_pairlist",
            "test_concat_invalid_first_argument",
            "test_agg_cython_table_raises",
            "is_platform_32bit",
            "test_set_properties",
            "test_subdays",
            "test_xs_level0",
            "test_spam",
            "test_timestamp_add_timedelta_push_over_dst_boundary",
            "test_repr",
            "test_smallerEqual_Raises_Type",
            "_pipe",
            "test_maybe_promote_any_numpy_dtype_with_na",
            "test_with_datetimelikes",
            "assert_extension_array_equal",
            "_get_method_wrappers",
            "_step",
            "test_reindex_signature",
            "test_resample_frame_basic",
            "_box_values",
            "configure_tests",
            "_indicator_post_merge",
            "test_loffset_returns_datetimeindex",
            "time_datetimes_with_nat",
            "test_array_type_with_arg",
            "UnicodeReader",
            "_na_value",
            "test_groupby_with_small_elem",
            "test_oo_optimizable",
            "test_groupby_agg_ohlc_non_first",
            "prefix_pandas",
            "extended_summary",
            "init_qt_clipboard",
            "test_no_keep_default_na_dict_na_scalar_values",
            "test_full_outer_join",
            "test_sort_index_reorder_on_ops",
            "test_iterator_read_too_much",
            "test_td_div_timedeltalike_scalar",
            "test_to_excel_output_encoding",
            "test_nth",
            "_to_sql_replace",
            "_parse_tbody_tr",
            "test_check_integrity",
            "test_str_cat_name",
            "_maybe_cache",
            "test_empty_with_dup_column_pass_dtype_by_indexes_raises",
            "test_concat_series_axis1_same_names_ignore_index",
            "test_get_loc_raises_missized_tolerance",
            "classmethod",
            "_ensure_valid_index",
            "union",
            "test_cython_inner_join",
            "_get_index_factory",
            "is_categorical_astype",
            "get_numeric_data",
            "test_td_constructor_value_error",
            "_text_getter",
            "test_take_scalar_raises",
            "test_categorical_index_preserver",
            "assert_index_equal",
            "test_loc_slice_index_fill_value",
            "_try_coerce_result",
            "test_nat_doc_strings",
            "get_formatted_cells",
            "test_frame_datetime64_mixed_index_ctor_1681",
            "test_write_unsupported_compression_type",
            "test_from_records_with_datetimes",
            "is_named_tuple",
            "test_to_sparse",
            "_ensure_arraylike",
            "_repr_categories",
            "test_tz_localize_ambiguous_compat",
            "test_corrwith",
            "test_filter_out_all_groups_in_df",
            "test_date_format_series",
            "_import_deprmod",
            "test_copy_in_constructor",
            "_get_setitem_indexer",
            "test_bin16",
            "test_per_axis_per_level_getitem",
            "register_vcs_handler",
            "test_compare_2000",
            "test_bar_barwidth",
            "float_frame_fill0_dense",
            "can_connect",
            "test_show_dimensions",
            "test_numeric_compat",
            "arr_dict",
            "_indicator_pre_merge",
            "test_hash_array_mixed",
            "test_datetime_like",
            "testIgnoreUnicodeErrors",
            "test_issue124",
            "test_basic_frame",
            "test_resample_with_dst_time_change",
            "test_nat_arithmetic_td64_vector",
            "test_join_multi_empty_frames",
            "test_truncate",
            "test_multiindex_header_skiprows_tuples",
            "test_getitem_error",
            "test_string_slice_out_of_bounds",
            "test_interp_limit_direction",
            "test_between_time_formats",
            "test_nrows_skipfooter_errors",
            "test_loc_setitem_with_scalar_index",
            "test_constructor_dtype",
            "remove",
            "test_getitem_numeric_column_names",
            "_is_monotonic_decreasing",
            "_unpickle_frame_compat",
            "__and__",
            "test_maybe_convert_numeric_infinities",
            "np_array_datetime64_compat",
            "test_resample_same_freq",
            "test_correct_type_nested_array",
            "test_overflow_offset_raises",
            "test_malformed",
            "ts",
            "test_append_preserve_index_name",
            "time_getitem_bool_array",
            "_try_convert_to_date",
            "test_sparse_mixed",
            "time_iso8601_nosep",
            "test_getitem_boolean_casting",
            "validate_dtype_freq",
            "_aggregate_multiple_funcs",
            "test_setitem_loc_scalar_mixed",
            "test_map_tseries_indices_return_index",
            "test_elementwise_comparison_warning",
            "test_convert_pandas_type_to_json_period_range",
            "get_locales",
            "test_invalid_engine",
            "test_data_method",
            "test_read_sql_named_parameter",
            "test_rmod_pytimedelta",
            "is_datetime64tz_dtype",
            "test_nangt",
            "construct_1d_arraylike_from_scalar",
            "test_combine_first_mixed",
            "test_nested_dict_frame_constructor",
            "test_update_ctx_flatten_multi",
            "test_is_scalar_numpy_array_scalars",
            "test_invalid_skipfooter_negative",
            "time_merge_dataframe_integer_2key",
            "test_decode_depth_too_big",
            "test_non_reducing_slice",
            "test_skiprows_xrange",
            "test_multi_index",
            "test_replace_tzinfo_equiv_tz_localize_none",
            "test_dt64arr_add_sub_DateOffset",
            "test_numpy_repeat",
            "test_is_datetimelike_v_object",
            "test_1d_with_out",
            "test_getitem_ix_boolean_duplicates_multiple",
            "test_multiples",
            "test_freq_code_match",
            "_homogenize",
            "test_isin_against_series",
            "translate",
            "test_complex_raises",
            "test_holder",
            "bfill",
            "test_reset_index_with_datetimeindex_cols",
            "test_file_handles_mmap",
            "convert_values",
            "test_get_indexer_errors",
            "test_consolidate",
            "test_combine_datetlike_udf",
            "test_rank_signature",
            "time_series_describe",
            "test_pi_add_iadd_timedeltalike_daily",
            "test_repr_empty",
            "test_intersect_equal_sort_true",
            "test_fake_inferred_business",
            "test_read_chunks_115",
            "group_index",
            "test_constructor_name_hashable",
            "test_cant_or_shouldnt_cast",
            "test_astype_datetime",
            "float_frame_with_na",
            "test_non_reducing_slice_on_multiindex",
            "test_to_string_float_format_no_fixed_width",
            "_get_subplots",
            "test_difference_base",
            "test_get_X_columns",
            "test_td_floordiv_invalid_scalar",
            "_roundtrip",
            "test_bar_colors",
            "_round",
            "_td_array_cmp",
            "format_percentiles",
            "is_consolidated",
            "test_constructor_dtype_and_others_raises",
            "test_groupby_empty",
            "test_map_missing_mixed",
            "_check_setitem_copy",
            "test_multiindex_label_slicing_with_negative_step",
            "is_integer_dtype",
            "test_bar_ignore_index",
            "_equals_tag",
            "_consolidate_inplace",
            "_aggregate",
            "test_int64_overflow",
            "test_extract_expand_unspecified",
            "_is_multiple",
            "test_first_last_nth",
            "test_inplace_ops_identity",
            "test_modify_values",
            "test_to_string_small_float_values",
            "test_repr_non_interactive",
            "test_merge_on_nans",
            "test_pad",
            "test_astype_no_pandas_dtype",
            "as_blocks",
            "time_infer_quarter",
            "test_mode_category",
            "test_with_duplicates",
            "test_quantile_invalid",
            "test_encode_array_in_array",
            "test_bar_stacked_center",
            "test_basic_getitem_setitem_corner",
            "test_multiple_date_cols_with_header",
            "test_td64arr_add_timedeltalike",
            "get_compressed_ids",
            "test_series_indexing_single",
            "test_intersection_bug_1708",
            "time_rename_axis1",
            "time_write_hdf",
            "test_should_cache_errors",
            "_monthly_finder",
            "test_full_format_converters",
            "test_interval_array_equal",
            "time_groupby_sum_multiindex",
            "test_equals_multi",
            "test_setitem_scalar_into_readonly_backing_data",
            "to_julian_date",
            "test_resample_float_base",
            "csv_dir_path",
            "test_merge_non_unique_indexes",
            "test_left_merge_na_buglet",
            "asobject",
            "test_from_coo_long_repr",
            "test_dti_custom_business_summary_pytz",
            "test_mixed_index_no_fallback",
            "test_to_html_truncation_index_false_max_rows",
            "_is_business_daily",
            "time_add_timedelta",
            "test_to_numpy_dtype",
            "test_cython_left_outer_join",
            "test_union_categorical_same_category",
            "test_insert_index_period",
            "test_constructor_unwraps_index",
            "test_out_of_range_float",
            "test_expanding_apply",
            "test_select_filter_corner",
            "test_get_loc_raises_object_nearest",
            "wide_to_long",
            "exception_matches",
            "test_transform_mixed_type",
            "test_thousands_macau_index_col",
            "time_write_stata",
            "test_is_categorical_dtype",
            "test_walk",
            "test_concat_multiindex_rangeindex",
            "test_plot_fails_with_dupe_color_and_style",
            "read_excel",
            "test_exceeding_unpacker_read_size",
            "test_demo",
            "test_where_datetime",
            "test_slicing_maintains_type",
            "test_cannot_copy_item",
            "test_reset_option",
            "peakmem_itertuples_raw",
            "test_object_empty",
            "test_getitem_scalar_na",
            "test_preserve_categories",
            "test_decons",
            "test_series_constructor_with_astype",
            "_build_option_description",
            "test_resample_with_pytz",
            "test_ewm_alpha_arg",
            "_is_cython_func",
            "test_first_row_bom",
            "time_crosstab_normalize_margins",
            "test_rolling_quantile_param",
            "previous_workday",
            "test_quantile_axis_mixed",
            "test_pivot_integer_columns",
            "_multi_take_opportunity",
            "test_cmov_window_regular_missing_data",
            "__abs__",
            "_assert_setitem_series_conversion",
            "test_invalid_columns",
            "test_legacy_table_read_py2",
            "mode",
            "set_locs",
            "test_subplots_layout",
            "test_decode_with_trailing_whitespaces",
            "test_other_type_raises",
            "test_date_range_ambiguous_arguments",
            "_combine_match_index",
            "default_units",
            "test_cummax_timedelta64",
            "_convert_to_color",
            "test_constructor_list_of_tuples",
            "test_grouped_plot_fignums",
            "test_ufunc_multiple_return_values",
            "test_is_timedelta",
            "test_construction_with_nat_and_tzlocal",
            "test_groupby_level_apply",
            "_read_page_header",
            "test_view_tz",
            "test_irregular_datetime64_repr_bug",
            "test_deprecated_dense_to_sparse",
            "test_split_with_name",
            "test_append_with_strings",
            "test_stubs",
            "test_int_indexing",
            "_set_foo",
            "test_to_latex_multiindex_empty_name",
            "test_block_shape",
            "_insert_inaxis_grouper_inplace",
            "test_ignore_downcast_cannot_convert_float",
            "test_nanle",
            "test_bad_docstrings",
            "test_period_array_ok",
            "test_dt_round_tz_nonexistent",
            "test_shift_month_error",
            "html_encoding_file",
            "test_line_plot_period_mlt_series",
            "test_bar_align_mid_vmin_vmax_wide",
            "test_divmod_zero",
            "astype2",
            "_concat_datetime",
            "test_agg_grouping_is_list_tuple",
            "_prepare_categoricals",
            "testCall",
            "test_series_describe_single",
            "backfill",
            "sort_idx",
            "test_preserve_timedeltaindex_type",
            "_setitem_slice",
            "validate_names",
            "test_interp_invalid_method",
            "test_argsort",
            "test_bar_user_colors",
            "test_getitem_partial_column_select",
            "test_get_standard_colors_random_seed",
            "_wrap_result",
            "str_get_dummies",
            "_flatten",
            "test_frame_from_json_to_json",
            "test_upsample_apply_functions",
            "test_rolling_quantile_np_percentile",
            "_assert_fillna_conversion",
            "test_empty_series",
            "_pprint_seq",
            "_resolve_name",
            "_read_sql_iris",
            "_process_subheader_counts",
            "test_to_string",
            "test_multiindex_with_columns",
            "test_getitem_fancy_boolean",
            "test_get_day_of_year_numeric",
            "test_duplicate_mi",
            "mem_parser_chunks",
            "test_numpy_transpose",
            "test_radd_tdscalar",
            "_align_method_FRAME",
            "test_getitem_group_select",
            "test_frame_pos",
            "test_duplicate_ref_loc_failure",
            "ignore_xlrd_time_clock_warning",
            "test_rank_int",
            "_get_value",
            "numpy",
            "test_truncated_float_support",
            "num_summary_lines",
            "test_constructor_with_generator",
            "test_duplicates_on_starter_columns",
            "test_getitem_ix_float_duplicates",
            "test_ensure_copied_data",
            "test_next",
            "test_overlaps_self",
            "any_allowed_skipna_inferred_dtype",
            "test_item_function",
            "test_before_nearest_workday",
            "test_drop_duplicates_metadata",
            "test_join_with_len0",
            "_construct_result",
            "test_is_not_int64_dtype",
            "test_reduce_mixed_frame",
            "test_constructor_dict_nan_key",
            "check_cases",
            "_block",
            "test_mock_clipboard",
            "test_no_version_raises",
            "test_from_arrays_index_datetimelike_mixed",
            "test_series_truncate_datetimeindex_tz",
            "test_memorial_day",
            "test_resample_count",
            "test_make_block_same_class",
            "test_anchor_week_end_time",
            "time_value_counts",
            "test_categorical_repr_datetime",
            "test_secondary_upsample",
            "test_matplotlib_scatter_datetime64",
            "checked_add_with_arr",
            "_all_indexes_same",
            "test_index_col_named2",
            "test_types",
            "time_find",
            "components",
            "test_no_values_attribute",
            "_get_cython_type_upcast",
            "test_justify",
            "_parse_date",
            "string_series",
            "test_convert_json_field_to_pandas_type_raises",
            "test_ground_truth",
            "test_is_complex_dtype",
            "test_range_tz_pytz",
            "test_pi_add_sub_td64_array_non_tick_raises",
            "test_date_conversion_overflow",
            "test_construct_from_string_fill_value_raises",
            "_coerce_values",
            "infer_objects",
            "dict_keys_to_ordered_list",
            "clean_fill_method",
            "test_getitem_pop_assign_name",
            "connect",
            "indexer_between_time",
            "ensure_clean",
            "test_iloc_frame",
            "test_bytes_io_input",
            "test_reindex_methods_nearest_special",
            "test_constructor_dtype_copy",
            "test_dti_tz_convert_to_utc",
            "test_read_inline_jsonl",
            "test_corr_nooverlap",
            "test_cumsum",
            "test_clip_against_unordered_columns",
            "test_coerce_of_invalid_datetimes",
            "before_nearest_workday",
            "test_to_integer_array_bool",
            "test_construct_1d_ndarray_preserving_na",
            "test_iloc_setitem_pandas_object",
            "_get_client",
            "test_series_nat_conversion",
            "time_add_td_ts",
            "test_multi_line_expression_callable_local_variable_with_kwargs",
            "_join_monotonic",
            "add_tmp",
            "pa",
            "all_arithmetic_operators",
            "test_ops_np_scalar",
            "test_secondary_y_ts",
            "test_update_filtered",
            "test_to_html_multiindex",
            "test_getitem_ambiguous_keyerror",
            "time_read_sql_table_parse_dates",
            "test_foobar_skip",
            "_get_varlist",
            "test_negative_ordinals",
            "deltas",
            "reset_index",
            "test_small_year_parsing",
            "test_groupby_count_dateparseerror",
            "test_equals_range",
            "test_missing_field",
            "test_series",
            "_iterable_not_string",
            "test_slice_with_zero_step_raises",
            "gen_of_tuples",
            "is_period",
            "test_fwf_colspecs_is_list_or_tuple",
            "test_insert_error_msmgs",
            "test_simple_bool_ops",
            "test_reflected_comparison_with_scalars",
            "test_sort_values",
            "test_tick_division",
            "_check_roundtrip",
            "get_locs",
            "test_set_frame_expand_regular_with_extension",
            "time_asof_single_early",
            "test_constructor_Series_named_and_columns",
            "has_non_verbose_info_repr",
            "test_astype_categorical_to_other",
            "test_astype_category_ordered_none_deprecated",
            "test_quantile_multi",
            "test_unique_all_sparse",
            "test_float",
            "test_bad_arg_length_max_value_multiple",
            "_get_join_info",
            "test_difference_sort_incomparable_true",
            "_write_characteristics",
            "test_dti_tz_nat",
            "ensure_removed",
            "_isna_ndarraylike_old",
            "test_concat_sorts_columns",
            "test_arith_flex_series",
            "test_properties_weekly_legacy",
            "test_setitem_more",
            "test_index_equal_length_mismatch",
            "test_safe_names_warning",
            "test_describe_timedelta_values",
            "test_dti_isub_int",
            "test_to_datetime_format_integer",
            "_from_fastpath",
            "tree",
            "test_fillna_bug",
            "sunday_to_monday",
            "test_slice_locs",
            "test_print",
            "test_read_procedure",
            "test_cython_agg_nothing_to_agg_with_dates",
            "test_vectorized_offset_addition",
            "test_frame_equal_unicode",
            "test_onOffset",
            "test_freq_setter",
            "test_mixed_freq_regular_first_df",
            "test_uneven_lines_with_usecols",
            "test_categorical_index_repr",
            "test_grouper_index_level_as_string_series",
            "time_loc_slice",
            "test_dti_cmp_str",
            "test_usecols_with_parse_dates",
            "test_reindex_datetimeindexes_tz_naive_and_aware",
            "test_getitem_multi",
            "test_from_records_sequencelike",
            "test_apply_bad_return",
            "_unconvert_index_legacy",
            "test_to_dict_wide",
            "coerce_indexer_dtype",
            "test_cumcount",
            "test_plain_axes",
            "test_compare_hour13",
            "test_subplots_dup_columns",
            "test_wrap_agg_out",
            "test_reader_list",
            "test_precision",
            "test_excel_writer_context_manager",
            "test_ser_div_ser",
            "seed_df",
            "test_dataframe_duplicate_column_names",
            "_expand_axes",
            "test_crosstab_normalize",
            "assert_label_reference",
            "test_background_gradient_axis",
            "test_median_duplicate_columns",
            "test_find",
            "test_dt64tz_setitem_does_not_mutate_dti",
            "test_interp_various",
            "test_count_with_only_nans_in_first_group",
            "test_value_counts_unique",
            "test_itertuples",
            "test_partial_set",
            "test_factorize",
            "test_setitem_ndarray_1d",
            "test_intersect_str_dates",
            "test_coercion_with_setitem",
            "validate_argmin_with_skipna",
            "test_errorbar_with_integer_column_names",
            "test_string_slice_get_syntax",
            "test_parr_sub_pi_mismatched_freq",
            "test_parse_subtype",
            "ndim",
            "test_to_latex_decimal",
            "delete",
            "test_mixed_integer_from_list",
            "test_tdi_rmul_arraylike",
            "next_bday",
            "_is_unorderable_exception",
            "test_range_tz_dateutil",
            "all_data",
            "test_2d_fill_nonna",
            "result_index",
            "test_raise_on_mixed_dtype_usecols",
            "test_with_dictlike_columns",
            "_stata_elapsed_date_to_datetime_vec",
            "test_dti_tz_convert_tzlocal",
            "test_math_add",
            "_can_hold_element",
            "test_is_sequence",
            "test_divmod_scalar",
            "test_comment_skiprows",
            "_reset_option",
            "test_apply_reduce_rows_to_dict",
            "test_series_groupby_value_counts",
            "test_constructor_with_embedded_frames",
            "test_none_coercion_mixed_dtypes",
            "test_dataframe_dummies_mix_default",
            "test_dataframe_dummies_all_obj",
            "test_empty_index_name_doesnt_display",
            "test_arithmetic_overflow",
            "test_getitem_setitem_boolean_misaligned",
            "test_full_file_with_spaces_and_missing",
            "test_to_string_dtype",
            "test_axis_share_xy",
            "test_set_index_raise_on_len",
            "test_constructor_nonhashable_names",
            "test_ops_consistency_on_empty",
            "_add_numeric_methods_disabled",
            "set_index",
            "_is_scalar_access",
            "test_parse_public_s3_bucket_nrows",
            "test_exit_status_for_validate_one",
            "test_pytables_native2_read",
            "_parse_tfoot_tr",
            "test_categorical_equal_categories_mismatch",
            "time_loc_scalar",
            "clean",
            "test_iterator_loop",
            "time_to_datetime_dayfirst",
            "test_column_dups_indexing",
            "test_to_datetime_iso8601_noleading_0s",
            "keys",
            "get_bool_data",
            "from_custom_template",
            "test_from_to_scipy",
            "test_stable_categorial",
            "test_groupsort_indexer",
            "time_join_dataframe_index_single_key_bigger",
            "test_rsplit_to_multiindex_expand",
            "test_dtypes_gh8722",
            "test_one_level_deep_flattens",
            "test_constructor_rec",
            "test_nan_selection_bug_4858",
            "test_agg_list_like_func",
            "test_union_categorical_unwrap",
            "run_arithmetic",
            "test_series_unnamed",
            "test_qcut",
            "test_series_partial_set_datetime",
            "test_convert_array_of_periods",
            "time_frame_drop_dups",
            "_skip_if_no_project_id",
            "test_frame_reset_index",
            "test_read_chunksize_and_nrows",
            "sparse_df",
            "test_good_functions",
            "infer_freq",
            "test_timedelta_hash_equality",
            "test_ufunc_coercions",
            "test_plot",
            "test_tolerance_nearest",
            "previous_friday",
            "assert_multiindex_copied",
            "test_constructor_cant_cast_period",
            "test_usecols_excel_range_str_invalid",
            "test_sort_non_lexsorted",
            "_convert_index",
            "_get_skiprows",
            "check_is_index",
            "test_to_string_repr_unicode",
            "_check_file_or_buffer",
            "test_dt64ser_sub_datetime_dtype",
            "test_ops_error_str",
            "compare_index_period",
            "test_groupby_name_propagation",
            "test_header_with_index_col",
            "test_to_datetime_parse_timezone_keeps_name",
            "test_double_precision",
            "type",
            "create_data",
            "test_datetime_cut",
            "test_pyarrow",
            "test_setindex",
            "test_groupby_aggregation_mixed_dtype",
            "test_isin_with_string_scalar",
            "test_value_vars",
            "test_combine_first_period",
            "_is_label_like",
            "test_sum_bools",
            "test_convert_preserve_bool",
            "test_union_categoricals_ignore_order",
            "test_contains_nans",
            "time_groupby_nosort",
            "classes_and_not_datetimelike",
            "test_to_object_array_tuples",
            "frame",
            "is_all_dates",
            "assert_same_resolution",
            "time_resample",
            "test_op",
            "_decode",
            "_construct",
            "_interp_limit",
            "test_categorical_no_compress",
            "test_get_dtype_error_catch",
            "test_sort_index_na_position",
            "write_to_version_file",
            "_generate_regular_range",
            "test_getitem_nat",
            "test_sorting_repr_8017",
            "test_validate_reduction_keyword_args",
            "test_droplevel_with_names",
            "test_where_empty_df_and_empty_cond_having_non_bool_dtypes",
            "test_concat_series_axis1_names_applied",
            "test_begin_year_alias",
            "read_block_index",
            "_is_compatible_with_other",
            "test_dict_numpy_complex",
            "test_construction_with_dtype",
            "test_deepcopy",
            "monotonic_index",
            "test_rdivmod_pytimedelta",
            "test_non_hashable",
            "test_strip_lstrip_rstrip",
            "test_count_cross_type",
            "test_sort_index_level_by_name",
            "_take_nd_object",
            "test_context",
            "visit_Assign",
            "test_cast_1d_array",
            "__radd__",
            "_interleave",
            "test_integer_index_astype_datetime",
            "time_frame_object_equal",
            "test_is_level_reference_series_axis1_error",
            "slice_replace",
            "time_get_loc_scalar",
            "test_memory_map",
            "_get_take_nd_function",
            "test_map_dict_with_tuple_keys",
            "test_compare_1700",
            "_try_convert_data",
            "test_categorical_series_repr_period_ordered",
            "test_is_not_signed_integer_dtype",
            "__repr__",
            "test_equality_invalid",
            "_read_float",
            "test_dt64arr_add_dt64ndarray_raises",
            "test_rich_comparison_with_unsupported_type",
            "test_parse_public_s3a_bucket",
            "_to_ijv",
            "test_range_tz_dst_straddle_pytz",
            "test_header_and_index_with_types",
            "test_uhf",
            "test_constructor_maskedarray_hardened",
            "test_iloc_duplicates",
            "_get_level_indexer",
            "test_sort_multi_index",
            "test_ragged_var",
            "_repr_attrs",
            "test_basic_left_by_right_by",
            "test_qcut_all_bins_same",
            "_argminmax_wrap",
            "test_kde_colors_and_styles_subplots",
            "_ensure_datetimelike_to_i8",
            "test_index_col_label_error",
            "test_with_nan",
            "test_get_attributes",
            "get_config_from_root",
            "time_category_size",
            "_infer_tz_from_endpoints",
            "test_loc_str_slicing",
            "test_split_compat",
            "close",
            "test_astype_assignment",
            "test_implementation_limits",
            "test_rolling_apply_out_of_bounds",
            "test_float_suffix",
            "test_intercept_astype_object",
            "to_pickle",
            "test_append_misc",
            "test_align_mixed_float",
            "_maybe_numeric_slice",
            "test_dict_float",
            "test_merge_indexes_and_columns_on",
            "summary",
            "test_reading_all_sheets_with_blank",
            "time_reindex_upcast",
            "test_maybe_promote_any_with_object",
            "test_comparison_tzawareness_compat_scalars",
            "test_categorical_index_repr_period_ordered",
            "test_tidy_repr",
            "test_constructor_dict_of_generators",
            "test_groupby_apply_all_none",
            "test_multi_iter_frame",
            "test_get_indexer_length_one",
            "test_non_unique_pickle",
            "read_stata",
            "test_rank_max_pct",
            "test_get_freq_roundtrip",
            "test_infer_freq_tz",
            "test_day_not_in_month_raise",
            "test_intra_day_conversion_factors",
            "_sql_type_name",
            "_get_fill_indexer_searchsorted",
            "test_transform_multiple",
            "_check_iris_loaded_frame",
            "test_basic_period_index_subscript_expression",
            "test_any_all_object",
            "test_td64arr_addsub_anchored_offset_arraylike",
            "test_lookup_basics",
            "check_reduce",
            "test_unstack_dtypes",
            "test_margins",
            "test_ufuncs_single_float",
            "time_ix_list_like",
            "test_date_range_multiplication_overflow",
            "_copy",
            "right_df",
            "test_default_fill_value_with_no_data",
            "reindex_indexer",
            "test_figsize",
            "_drop_from_level",
            "dt64arr_cmp_non_datetime",
            "test_CategoricalAccessor_name_deprecation",
            "is_offsetlike",
            "rxor",
            "test_getitem_ndarray_3d",
            "test_series_from_coo_incorrect_format_raises",
            "test_compare_tick",
            "resolution",
            "test_replace_gh5319",
            "test_pack_ext_type",
            "ascending",
            "test_timeseries_coercion",
            "test_infinity_against_nan",
            "test_skip_rows_callable",
            "rjust",
            "test_skiprows_list",
            "test_cdaterange_weekmask_and_holidays",
            "str_slice",
            "test_concat_will_upcast",
            "object_series",
            "test_series_from_json_precise_float",
            "test_repr_chop_threshold_column_below",
            "test_read_timezone_information",
            "test_period_array_non_period_series_raies",
            "_filter_nodes",
            "_infer_fill_value",
            "test_ix_setitem_out_of_bounds_axis_0",
            "test_assert_almost_equal_value_mismatch2",
            "test_reindex_methods",
            "_get_format_datetime64",
            "test_setops_disallow_true",
            "test_fillna_copies",
            "test_invalid_file_not_written",
            "test_dt64_ser_cmp_date_warning",
            "test_df_mod_zero_array",
            "test_setitem_list",
            "test_aggregate_item_by_item",
            "test_assert_almost_equal_numbers",
            "test_setitem_index_float64",
            "get_pairs",
            "test_tdi_shift_int",
            "test_double_long_numbers",
            "test_subclass_sparse_to_frame",
            "test_rename_axis_raises",
            "test_bounds_check_large",
            "test_iteration_open_handle",
            "test_numpy_compat",
            "test_end_year_alias",
            "test_left_join_indexer_unique",
            "test_nulls",
            "test_constructor_int_dtype_nan",
            "test_series_fillna_limit",
            "test_bool_types",
            "test_to_datetime_types",
            "test_bool_arith_expr",
            "test_from_tuples_index_values",
            "test_bool_ops_fails_on_scalars",
            "time_iloc_list_like",
            "test_color_empty_string",
            "test_numpy_any",
            "test_series_getitem_not_sorted",
            "test_astype_from_datetimelike_to_objectt",
            "test_eof_states",
            "test_dt_namespace_accessor_categorical",
            "test_astype_more",
            "test_missing_values",
            "test_stata_111",
            "test_array_float",
            "test_empty_frame_dtypes_ftypes",
            "setup_import",
            "table_type_short",
            "test_header_and_one_column",
            "test_apply_axis1",
            "test_deprecated_to_dense",
            "test_subclass_pivot",
            "test_merge_left_empty_right_empty",
            "test_constructor_dtype_no_cast",
            "test_to_csv_unicodewriter_quoting",
            "test_constructor_subclass_dict",
            "test_rank_desc_mix_nans_infs",
            "test_reindex_preserves_names_when_target_is_list_or_ndarray",
            "test_cannot_item_assign",
            "test_to_offset_leading_zero",
            "test_tz_standardize",
            "test_partial_slicing_dataframe",
            "test_skiprows_invalid",
            "_get_data_algo",
            "validate_read",
            "_validate_flavor",
            "test_single_invert_op",
            "test_dti_tz_localize_ambiguous_nat",
            "__len__",
            "test_scalar_unary",
            "test_zip_error_no_files",
            "_return_parsed_timezone_results",
            "empty_frame",
            "test_fillna_empty",
            "test_constructor_invalid_args",
            "_take",
            "test_upsample_sum",
            "_maybe_parse_dates",
            "test_mi_sparse_disabled",
            "masked_rec_array_to_mgr",
            "_maybe_cast",
            "test_numpy_func_call",
            "ordered_fixture",
            "test_maybe_mangle_lambdas",
            "test_get_standard_colors_default_num_colors",
            "test_mixed_timedelta_datetime",
            "_get_level_lengths",
            "test_ragged_kurt",
            "test_constructor_from_series_dtlike",
            "take_invalid_kwargs",
            "test_arith_alignment_non_pandas_object",
            "_to_sql_save_index",
            "test_fields",
            "test_tdi_iadd_timedeltalike",
            "test_constructor_preserve_attr",
            "test_get_unique_index",
            "test_unstack_fill_frame_categorical",
            "_is_visible",
            "time_subtract",
            "test_floordiv_zero",
            "test_datetime64_dtype_array_returned",
            "_slice_take_blocks_ax0",
            "where",
            "_floatify_na_values",
            "_factorize_from_iterable",
            "test_store_hierarchical",
            "_setitem_frame",
            "test_get_dtype_kinds",
            "test_on_and_index",
            "test_local_file",
            "test_sparse_series_unstack",
            "_check_has_errorbars",
            "test_categorical_sideeffects_free",
            "test_constructor_limit_copies",
            "test_errorbar_with_partial_columns",
            "test_store_index_name_with_tz",
            "test_conv_minutely",
            "_zip_axes_from_type",
            "time_series_drop_dups_string",
            "test_repr_html_long",
            "test_decode_number_with_32bit_sign_bit",
            "test_setitem_array",
            "rstrip",
            "_construct_axes_dict_for_slice",
            "test_grow_boundary_at_cap",
            "test_spss_labelled_num",
            "test_sparse_to_dense",
            "_process_subheader_pointers",
            "testMult1",
            "test_where_with_numeric_data",
            "test_agg_apply_evaluate_lambdas_the_same",
            "read_column",
            "_series",
            "_get_page_title",
            "time_c_ordered",
            "validate_version",
            "_intersection_non_unique",
            "test_iloc_col",
            "_check_all_fields",
            "test_gzip_writing",
            "_construct_divmod_result",
            "test_tuple_categories",
            "test_consistent_format",
            "test_unstack_sparse_keyspace",
            "test_where_unsafe",
            "test_fillna_categorical_nan",
            "test_read_nrows_large",
            "test_usecols_diff_positional_int_columns_order",
            "test_is_offsetlike",
            "test_wide_repr_multiindex",
            "test_series_density",
            "_combine_frame",
            "test_apply_nonuq",
            "test_bad_month_fail",
            "test_as_json_table_type_bool_data",
            "test_iloc_mask",
            "datetime_tz_utc",
            "test_index_ctor_infer_nat_dt_like",
            "test_td_sub_mixed_most_timedeltalike_object_dtype_array",
            "test_generated_op_names",
            "day_opt",
            "test_sub_fail",
            "_make_wrapped_arith_op",
            "test_select_as_multiple",
            "test_nanskew",
            "parser_and_data",
            "_get_sheet_name",
            "_partial_date_slice",
            "test_datetimeindex_from_empty_datetime64_array",
            "test_groupby_selection_with_methods",
            "_get_timestamp_range_edges",
            "test_setitem_series_object",
            "test_dt64arr_add_sub_offset_ndarray",
            "test_read_dta12",
            "test_period_cons_quarterly",
            "_read_sql_iris_named_parameter",
            "_do_convert_missing",
            "test_operators_timedelta64_with_timedelta",
            "test_map_datetimetz",
            "test_construction_with_categorical_dtype",
            "optional_args",
            "test_construction_overflow",
            "time_itertuples_raw_read_first",
            "_handle",
            "test_apply_axis",
            "read_sql_query",
            "test_groupby_corner",
            "test_head_tail",
            "test_setitem_loc_scalar_multiple_homogoneous",
            "test_concat_categorical_coercion",
            "test_td_rfloordiv_invalid_scalar",
            "_make_table",
            "_is_single_block",
            "test_with_dictlike_columns_with_infer",
            "test_constructor_pi_nat",
            "test_array_hook",
            "row_levels",
            "test_to_tuples",
            "time_freqstr",
            "_first_fill_value_loc",
            "get_fill_func",
            "_convert_listlike_datetimes",
            "test_transpose_object_to_tzaware_mixed_tz",
            "test_malformed_skipfooter",
            "test_combine_first_with_dense",
            "get_engine",
            "time_read_uint64_neg_values",
            "start_time",
            "test_file_like_no_next",
            "time_datetime_field_daysinmonth",
            "test_series_interpolate_intraday",
            "test_getitem_boolean_iadd",
            "test_swaplevel",
            "test_iat_fill_value",
            "error",
            "test_dti_convert_datetime_list",
            "test_nanmedian",
            "method_returns_something",
            "test_append_raise",
            "test_maybe_indices_to_slice_both_edges",
            "test_ffill_not_in_axis",
            "tzinfo",
            "time_floats_with_int_index",
            "is_multi_index",
            "test_xs_keep_level",
            "test_ngroup_dupe_index",
            "test_update_raise_on_overlap",
            "time_series_float",
            "test_pivot_integer_bug",
            "test_mixed_dtype_insert",
            "ewm",
            "_aggregate_item_by_item",
            "pop",
            "check_opname",
            "_indexed_same",
            "nsmallest",
            "pipe",
            "test_index_make_union",
            "test_neg_raises",
            "test_construction_month",
            "test_filename_with_special_chars",
            "test_valid_dt_with_missing_values",
            "test_decode_with_trailing_non_whitespaces",
            "test_where_align",
            "test_read_excel_multiindex",
            "test_dti_cmp_nat",
            "test_stack_unstack_preserve_names",
            "test_datetimetz_dtype_match",
            "test_join_on_fails_with_different_right_index",
            "test_with_multi_index",
            "test_get_weeks",
            "time_take",
            "test_drop_labels_or_levels_df",
            "test_date_range_span_dst_transition",
            "test_merge_copy",
            "get_kwargs_from_breaks",
            "test_str_query_method",
            "test_int64_uint64_range",
            "test_update_dtypes",
            "test_representation_to_series",
            "test_incorrect_type_map",
            "test_unpacker_ext_hook",
            "test_index_equal_levels_mismatch",
            "test_sas_read_no_format_or_extension",
            "test_nan_in_object_array",
            "test_isna_nat",
            "test_quantile_interpolation_int",
            "time_lookup_loc",
            "test_excel_multindex_roundtrip",
            "__delitem__",
            "convert_missing_indexer",
            "_codes_for_groupby",
            "test_combine_scalar",
            "read_query",
            "time_series_loc",
            "test_index_col_empty",
            "test_math_mult",
            "test_tdi_add_integer_array",
            "test_frame_non_unique_columns",
            "test_string_index_alias_tz_aware",
            "test_errors_invalid_value",
            "test_timestamp_compare_series",
            "cat_core",
            "test_empty_print",
            "_try_convert_to_int_index",
            "test_groupby_transform_with_nan_group",
            "_validate",
            "TextParser",
            "test_between_time_axis",
            "test_groupby_multiindex_nat",
            "test_datetime_tz",
            "test_filter_nan_is_false",
            "time_rstrip",
            "_op_maker",
            "test_series_groupby_nunique",
            "test_constructor_infer_freq",
            "test_nans",
            "test_groupby_resample_on_api",
            "test_to_html_compat",
            "test_dt64_series_arith_overflow",
            "time_frame_drop_dups_na",
            "_make_reader",
            "test_rename_positional_named",
            "get_iterator",
            "test_plotting_with_float_index_works",
            "write_style",
            "test_ftypes",
            "test_astype_categoricaldtype_class_raises",
            "_populate_tables",
            "period_array",
            "test_to_latex_series",
            "resolve_name",
            "_get_handle",
            "is_monotonic",
            "test_raise_on_sep_with_delim_whitespace",
            "test_str_max_colwidth",
            "test_unstack_level_binding",
            "test_construction_with_alt",
            "test_deprecation",
            "_put_str",
            "test_render",
            "test_concatlike_common_period",
            "test_unary_ufunc",
            "test_getitem_setitem_boolean_corner",
            "pathname",
            "test_td64arr_add_sub_td64_nat",
            "test_pivot_tz_in_values",
            "test_rolling_median_memory_error",
            "test_no_pairwise_with_other",
            "test_series_getitem_duplicates_multiindex",
            "test_get_dtype_kinds_period",
            "test_secondary_y",
            "test_float64index_slicing_bug",
            "render_templates",
            "time_ix_slice",
            "test_illegal_names",
            "test_subtype_conversion",
            "test_mixed_string_strl",
            "_get_attributes_dict",
            "first_valid_index",
            "_build_doc",
            "index_pair",
            "maybe_cast_to_datetime",
            "test_where_invalid_input_single",
            "test_dtype_str",
            "_index_freq",
            "test_gcs_get_filepath_or_buffer",
            "test_astype_invalid_dtype",
            "test_compare_array",
            "test_nearest_upsample_with_limit",
            "test_resample_with_non_zero_base",
            "test_where_index_bool",
            "test_dti_shift_no_freq",
            "test_rename_axis_style_raises",
            "test_table_index_incompatible_dtypes",
            "time_dtindex_from_index_with_series",
            "test_extractall_errors",
            "visit_BinOp",
            "test_constructor_mismatched_raises",
            "time_method",
            "test_setitem_corner2",
            "test_infer_dtype_from_boolean",
            "find",
            "_ensure_str",
            "test_tz_localize_pushes_out_of_bounds",
            "_from_axes",
            "test_constructor_single_level",
            "root",
            "data_repeated",
            "test_numpy_dtypes",
            "test_round_tzaware",
            "test_as_json_table_type_float_data",
            "_coerce_to_ndarray",
            "is_monotonic_increasing",
            "test_constructor_broadcast_list",
            "test_cython_grouper_series_bug_noncontig",
            "test_int_properties",
            "test_numarr_with_dtype_add_int",
            "test_to_datetime_coerce",
            "test_to_datetime_with_apply",
            "test_getitem_setitem_datetimeindex",
            "test_astype_object",
            "test_cdaterange_holidays",
            "test_pass_datetimeindex_to_index",
            "test_add",
            "test_on_offset",
            "test_is_nested_list_like_passes",
            "test_valid_tolerance",
            "test_css_precedence",
            "test_append_duplicates",
            "_convert_strls",
            "_get_colors_mapped",
            "test_corrwith_kendall",
            "test_dask",
            "test_sparse_series_ops_i",
            "test_group_var_generic_1d",
            "from_dict",
            "test_to_string_length",
            "__array_wrap__",
            "test_setitem_list_not_dataframe",
            "test_to_html_unicode",
            "test_first_last_valid",
            "test_frame_equal_row_order_mismatch",
            "validate_dataframe",
            "test_autocorr",
            "test_exactly_one_ref",
            "test_constructor_str_unknown",
            "test_to_frame_resulting_column_order",
            "test_hist_no_overlap",
            "test_index_contains",
            "coerce_to_dtypes",
            "test_2d_with_out",
            "test_transform_function_aliases",
            "test_loc_setitem_corner",
            "test_setitem_series",
            "test_range_closed_boundary",
            "test_split_to_dataframe",
            "head",
            "test_intersection_equal_sort",
            "test_with_nested_series",
            "test_asfreq_datetimeindex",
            "test_getitem_median_slice_bug",
            "test_store_mixed",
            "test_divmod_series_array",
            "masked_arith_op",
            "time_from_date_range",
            "test_invalid_skipfooter_non_int",
            "time_series_nth_all",
            "date_range",
            "test_read_excel_parse_dates",
            "_try_convert_dates",
            "test_replace_simple_nested_dict",
            "test_tick_normalize_raises",
            "check_dtypes",
            "time_dt_accessor_day_name",
            "test_arith_flex_frame_raise",
            "test_return_type",
            "_set_with_engine",
            "test_intersection_non_monotonic",
            "test_comment",
            "test_operators_frame",
            "test_copy_method",
            "time_len_groupby_object",
            "swapaxes",
            "test_alternate_encoding",
            "time_groupby_ordered_sort",
            "test_tolerance_float",
            "test_get_filepath_or_buffer_with_path",
            "test_min_max_empty",
            "test_basic_dtype",
            "test_join",
            "test_dti_representation",
            "test_constructor_with_win_type",
            "is_platform_linux",
            "time_apply_np_dt64",
            "meta",
            "test_bad_date_parse",
            "test_dtype_coerceion",
            "test_resample_extra_index_point",
            "test_years_only",
            "_dense_series_compare",
            "test_line_use_index_false",
            "test_resample_integerarray",
            "load_workbook",
            "test_apply_frame_concat_series",
            "test_ix_slicing_strings",
            "test_extractall",
            "_transform_general",
            "test_td64arr_add_sub_timestamp",
            "test_td_rfloordiv_timedeltalike_array",
            "test_mode_empty",
            "test_raise_if_too_few",
            "test_transform_axis",
            "test_bar_align_left",
            "test_dt64arr_cmp_scalar_invalid",
            "test_td_add_datetimelike_scalar",
            "return_not_documented",
            "test_connectable_issue_example",
            "test_where_ndframe_align",
            "test_out_of_bounds_value",
            "from_product",
            "test_is_strictly_monotonic_increasing",
            "test_sort_index_kind",
            "_get_marker_compat",
            "test_constructor_dict_block",
            "test_complex_across_dimensions",
            "test_groups",
            "test_resample_timegrouper",
            "test_astype_generic_timestamp_no_frequency",
            "_to_sql_append",
            "test_frame_indexing_multiple",
            "argsort",
            "_new_Index",
            "_scalar_type",
            "test_groupby_duplicated_column_errormsg",
            "test_equal_Raises_Value",
            "drop",
            "test_dti_construction_ambiguous_endpoint",
            "_factorize_from_iterables",
            "test_excel_old_index_format",
            "test_categories_assigments",
            "test_pi_add_offset_n_gt1_not_divisible",
            "_get_unicode_name",
            "test_to_string_float_index",
            "test_hexbin_cmap",
            "_make_arithmetic_op",
            "test_scatter_colors",
            "test_properties_weekly",
            "test_interp_quad",
            "test_operators_timedelta64",
            "test_margins_no_values_one_row_one_col",
            "test_nancorr_spearman",
            "sections_in_wrong_order",
            "test_agg_datetimes_mixed",
            "test_cython_transform_frame",
            "test_comparisons_nat",
            "test_series_with_dtype_radd_timedelta",
            "_ensure_scope",
            "test_setitem_empty_frame_with_boolean",
            "test_rsub_object",
            "arrays_to_mgr",
            "pie",
            "test_no_rounding_occurs",
            "test_is_int64_dtype",
            "get_atom_datetime64",
            "tquery",
            "time_frame_float_floor_by_zero",
            "test_append_all_nans",
            "test_categorical_block_pickle",
            "test_empty_dataframe_groupby",
            "test_dti_add_intarray_non_tick",
            "test_subtraction_ops_with_tz",
            "test_loc_iloc_frame_single_dtype",
            "test_maybe_numeric_slice",
            "deprecate",
            "_write_variable_labels",
            "test_timedelta_fillna",
            "test_valid_default_arguments",
            "testStrictUnicodeUnpack",
            "_iterate_slices",
            "test_neg_object",
            "test_to_timestamp_freq",
            "test_replace_with_no_overflowerror",
            "test_stack_level_name",
            "check_bool",
            "_convert_to_border",
            "test_encode_list_long_conversion",
            "test_construction_bday",
            "test_ew_empty_series",
            "test_to_string_truncate_multilevel",
            "_check_axes_shape",
            "test_append_with_data_columns",
            "test_to_csv_single_level_multi_index",
            "time_no_exact",
            "filename",
            "test_delta_preserve_nanos",
            "test_constructor_periodindex",
            "format_timedelta_ticks",
            "test_pivot_table_dropna_categoricals",
            "test_dataframe_dummies_drop_first",
            "test_testing",
            "test_max_array_len",
            "test_store_index_types",
            "test_spss_labelled_str",
            "test_concat_iterables",
            "test_encode_array_of_nested_arrays",
            "test_setitem_slice_mismatch_length_raises",
            "test_finder_minutely",
            "create_table_index",
            "test_period_dtype_match",
            "test_dataframe_repr",
            "time_dup_string_dates",
            "_create_index",
            "test_applymap",
            "test_count_uses_size_on_exception",
            "peakmem_itertuples_to_list",
            "test_pivot_duplicates",
            "test_groupby_blacklist",
            "test_multiple_ouput_ufunc",
            "time_series_ix",
            "time_series_to_frame",
            "_skip_if_no_scipy",
            "time_copy_overhead_single_col",
            "to_sparse",
            "test_epoch",
            "test_join_multi_levels2",
            "test_ops_frame_period",
            "test_parse_date_fields",
            "_assert_not_series_equal",
            "set_function_name",
            "_set_as_cached",
            "_blklocs",
            "test_transform_exclude_nuisance",
            "_get_format_timedelta64",
            "test_fwf_colspecs_infer_nrows",
            "test_extension_array_labels",
            "test_sum_object",
            "test_getitem_setitem_boolean_multi",
            "get_labels_levels",
            "test_join_period_index",
            "test_mixed_comparison",
            "time_to_sql_dataframe",
            "test_constructor_dict_timedelta64_index",
            "test_day_corner",
            "snap",
            "test_ints",
            "test_bool_with_none",
            "test_where_unobserved_nan",
            "test_fixarray",
            "all_numeric_reductions",
            "test_write_append_mode",
            "test_series_set_value",
            "_maybe_wrap_formatter",
            "test_groupby_max_datetime64",
            "test_banklist_url",
            "test_series_not_equal_metadata_mismatch",
            "test_series_setitem",
            "test_downcast_basic",
            "test_loc_with_interval",
            "test_contiguous_mixed_data_table",
            "reorder_categories",
            "test_delete_raises",
            "check_single_invert_op",
            "time_subtract_datetimes",
            "_maybe_promote",
            "test_disallow_scalar_bool_ops",
            "test_multiindex_slice_first_level",
            "test_chunk_begins_with_newline_whitespace",
            "time_getitem_lists",
            "test_loc_setitem_boolean",
            "test_notEqual",
            "test_between_time_types",
            "test_lexsort_indexer",
            "year_has_extra_week",
            "test_stable_descending_multicolumn_sort",
            "test_booleanindex",
            "test_empty_pass_dtype",
            "test_errorbar_timeseries",
            "test_array_i8_dtype",
            "test_nankurt",
            "test_boolean_slice_empty",
            "sort_names",
            "test_object_factorize",
            "test_series_agg_multi_pure_python",
            "maybe_castable",
            "test_setitem_raises_incompatible_freq",
            "_is_dates_only",
            "test_min_fitting_element",
            "sort_values",
            "test_categorical_index_repr_timedelta",
            "test_item_name",
            "test_pandas_plots_register",
            "test_convert_pandas_type_to_json_field_int",
            "test_groupby_transform_with_datetimes",
            "test_match_findall_flags",
            "_skip_if_no_mpl",
            "time_frame_mask_bools",
            "process_skipna",
            "test_isin_nan_pypy",
            "test_time_series_plot_color_with_empty_kwargs",
            "finalize_options",
            "time_iloc_dups",
            "test_period_dtype",
            "test_rolling_std_neg_sqrt",
            "test_isin_df",
            "test_conv_weekly",
            "test_repr_binary_type",
            "test_modulus",
            "test_expanding_apply_args_kwargs",
            "test_bdays_and_open_boundaries",
            "test_write_missing_strings",
            "test_as_json_table_type_string_dtypes",
            "time_concat_mixed_ndims",
            "test_scalar_complex",
            "test_resolution",
            "test_iter",
            "mask_cmp_op",
            "test_assert_not_almost_equal_iterables",
            "test_cython_median",
            "test_crosstab_no_overlap",
            "test_loc_setitem_empty_append",
            "test_boolean_ops",
            "test_groupby_average_dup_values",
            "test_cat_on_filtered_index",
            "test_series_equal_length_mismatch",
            "test_invalid_colormap",
            "test_reshaping_multi_index_categorical",
            "__sub__",
            "test_date_query_no_attribute_access",
            "time_frame_add",
            "test_missing_value_conversion",
            "test_asfreq_fillvalue",
            "test_complex_indexing_error",
            "test_read_sql_iris",
            "test_get_offset_legacy",
            "test_skipfooter_with_decimal",
            "time_wide_to_long_big",
            "test_groupby_groups_in_BaseGrouper",
            "test_datetime_timedelta_quantiles",
            "test_query_inplace",
            "test_timestamp_add_timedelta64_unit",
            "test_astype_str_map",
            "test_invalid_unit",
            "test_decode_array",
            "test_set_item",
            "test_get_label_or_level_values_df_ambig",
            "test_to_coo_nlevels_less_than_two",
            "test_get_code_invalid",
            "nanvar",
            "time_index_from_array_floats",
            "_convert_by",
            "test_basic_indexing",
            "test_time_overflow_for_32bit_machines",
            "test_to_string_na_rep",
            "_create_categorical",
            "test_xs_named_levels_axis_eq_1",
            "_get_footer",
            "test_addition_subtraction_preserve_frequency",
            "test_apply_use_categorical_name",
            "test_timedelta_arithmetic",
            "test_duplicated_nan_none",
            "test_constructor_arrays_negative_year",
            "get_hits",
            "test_non_sorted",
            "test_dti_tz_convert_compat_timestamp",
            "test_info_categorical_column",
            "test_to_sql_save_index",
            "close_open_fixture",
            "test_9",
            "test_infer_types",
            "test_join_empty_bug",
            "_adjust_bin_edges",
            "test_rank_object_bug",
            "test_has_duplicates_overflow",
            "test_constructor_dataframe",
            "_get_time_micros",
            "test_pi_shift_ndarray",
            "test_sortlevel_deterministic",
            "test_parse_date_float",
            "_check_offsetfunc_works",
            "test_observed",
            "_write_varnames",
            "test_argsort_missing",
            "_add_numeric_methods_unary",
            "test_td64arr_sub_timedeltalike",
            "time_i8merge",
            "test_getitem_setitem_slice_integers",
            "test_sparse",
            "merge_asof",
            "test_range_slice_seconds",
            "test_write_multiindex",
            "test_pi_add_sub_td64_array_tick",
            "_box_col_values",
            "test_mul_size_mismatch_raises",
            "test_format_datetime_with_time",
            "test_resample_unequal_times",
            "srcpath",
            "_evaluate_with_datetime_like",
            "_comp_method_OBJECT_ARRAY",
            "_annual_finder",
            "test_get_label_or_level_values_series_axis0",
            "test_interp_limit_before_ends",
            "set_error_bad_lines",
            "test_categorical_dtype_missing",
            "test_replace_callable",
            "any",
            "test_resample_ohlc_result",
            "time_nested_dict",
            "skipif_32bit",
            "format_name",
            "test_join_multi_dtypes",
            "test_all_finite",
            "test_start_stop_table",
            "test_series_grouper",
            "test_pickle_v0_14_1",
            "_has_names",
            "read_dta",
            "_format_with_header",
            "_partial_td_slice",
            "test_nested_raises_on_local_self_reference",
            "normalize",
            "_execute_sql",
            "test_categorical_equal_order_mismatch",
            "time_groupby_extra_cat_sort",
            "test_crosstab_single",
            "test_read_excel_squeeze",
            "test_df_add_2d_array_collike_broadcasts",
            "time_factorize",
            "is_datetime64_any_dtype",
            "test_mi_sparse",
            "test_if_scatterplot_colorbars_are_next_to_parent_axes",
            "test_truthiness",
            "_sparse_series_op",
            "test_with_max_level",
            "_series_and_2d_ndarray",
            "test_set_option",
            "test_with_offset",
            "_get_row_repeat",
            "_has_plotted_object",
            "test_xs_missing_values_in_index",
            "test_raw16",
            "test_basic_period_index_boolean_expression",
            "isnull",
            "test_equals_categorical",
            "test_difference_dupe",
            "test_deprecated_get_values",
            "_kind",
            "test_ignore_downcast_invalid_data",
            "test_regex_replace_dict_mixed",
            "test_annual_ambiguous",
            "test_rdivmod_invalid",
            "test_map_categorical",
            "T",
            "test_concat_inner_sort",
            "test_is_hashable",
            "test_pie_nan",
            "is_numeric_dtype",
            "time_apply_user_func",
            "test_concat_dict",
            "test_simple_normalize",
            "test_compressed_urls",
            "test_properties_business",
            "test_any_all_level_axis_none_raises",
            "_gen_fill_zeros",
            "add_prefix",
            "test_to_sql_empty",
            "test_count_level",
            "test_duplicated_on_empty_frame",
            "test_parse_public_s3n_bucket",
            "_format_attrs",
            "test_window_with_args",
            "test_constructor_compound_dtypes",
            "clean_up",
            "time_corrwith_cols",
            "test_boolean_set_uncons",
            "_check_if_open",
            "test_assert_almost_equal_inf",
            "test_frame_comparison",
            "test_unit_mixed",
            "test_groupby_transform_with_int",
            "test_notna",
            "_validate_for_numeric_binop",
            "test_detect_chained_assignment_warnings_filter_and_dupe_cols",
            "assert_sp_array_equal",
            "test_repr_unsortable",
            "test_set_axis_name_raises",
            "_parse_numpy",
            "test_astype_index",
            "to_parquet",
            "_maybe_get_mask",
            "test_dti_set_index_reindex",
            "test_stack_preserve_categorical_dtype",
            "test_set_axis_prior_to_deprecation_signature",
            "test_is_numeric_honored",
            "test_unknown_engine",
            "from_coo",
            "test_misspecified",
            "test_setitem_with_string_index",
            "create_mgr",
            "test_indexing_over_hashtable_size_cutoff",
            "test_merge_equal_cat_dtypes",
            "test_from_file",
            "test_fillna_col_reordering",
            "fetch",
            "test_td64arr_div_numeric_scalar",
            "_get_single_key",
            "test_setitem_multiindex",
            "test_abc_types",
            "test_is_scalar_pandas_scalars",
            "test_resample_nunique",
            "test_from_sequence_from_cls",
            "ensure_python_int",
            "read_sql",
            "str_encode",
            "na_value_for_dtype",
            "parser",
            "test_no_nonsense_name",
            "test_unicode_string_with_unicode",
            "test_int_bins_with_inf",
            "test_properties_monthly",
            "_maybe_rename_join",
            "make_block_array",
            "test_hash_pandas_object_works",
            "_decorate_axes",
            "_cumcount_array",
            "test_insert_with_columns_dups",
            "time_pivot_table_margins",
            "test_no_new_locals",
            "is_bool",
            "setup_method",
            "time_frame_duplicated",
            "test_select_iterator_many_empty_frames",
            "_replace_booleans",
            "test_quarterly_dont_normalize",
            "test_really_large_scalar",
            "test_concat_axis_parameter",
            "test_cast_1d_array_like_from_scalar_categorical",
            "test_construction_list_mixed_tuples",
            "test_simple_arith_ops",
            "test_value_labels_old_format",
            "_remove_empty_lines",
            "test_cmov_window_special",
            "test_maybe_indices_to_slice_right_edge",
            "can_set_locale",
            "test_repr_html_long_and_wide",
            "test_rename_mapper_multi",
            "test_where_index_complex128",
            "test_construct_over_dst",
            "_get_grouper_for_level",
            "test_frame_setitem_copy_raises",
            "_check_visible",
            "_check_legend_labels",
            "test_constructor_with_tz",
            "test_sort_index_intervals",
            "test_frame_append_datetime64_col_other_units",
            "test_groupby_includes_fill_value",
            "test_make_time_series",
            "test_thead_without_tr",
            "test_contains_method",
            "time_isnull_strngs",
            "test_lookup",
            "test_constructor_period_incompatible_frequency",
            "weekend_to_monday",
            "__rfloordiv__",
            "test_reset_index_with_intervals",
            "_maybe_fill",
            "test_get_label_or_level_values_df_simple",
            "test_to_timestamp_tz_arg_dateutil_from_string",
            "test_fails_or",
            "test_different_normalize_equals",
            "get_config",
            "test_read_unsupported_compression_type",
            "is_string_like_dtype",
            "test_springforward_plural",
            "test_intersection_cases",
            "test_secondary_y_regular_ts_xlim",
            "_translate",
            "test_df_float_none_comparison",
            "test_at_time_axis",
            "test_repeat_raises",
            "test_objarr_add_invalid",
            "test_td64arr_sub_offset_index",
            "_process_subheader",
            "test_order_matters",
            "test_rolling_corr_with_zero_variance",
            "test_td_add_sub_ten_seconds",
            "test_align_series_combinations",
            "test_encode_list_conversion",
            "test_constructor_from_sparse",
            "test_to_html_columns_arg",
            "test_sort_index_na_position_with_categories_raises",
            "_python_agg_general",
            "test_dti_tz_localize_naive",
            "_isfinite",
            "_interpolate",
            "test_delete",
            "test_dti_tz_localize_ambiguous_infer",
            "test_to_csv_decimal",
            "test_iloc_setitem_series",
            "test_apply_modify_traceback",
            "test_all_nans",
            "set_clipboard",
            "test_ensure_index_mixed_closed_intervals",
            "cherry_pick",
            "test_from_records_empty",
            "test_dont_modify_rcParams",
            "test_exception_importable",
            "_plot",
            "test_with_list",
            "_make_date_converter",
            "_plot_colorbar",
            "test_multi_iter",
            "test_max_level_with_records_path",
            "test_ewma_halflife_arg",
            "append",
            "test_subplots_warnings",
            "test_to_flat_index",
            "test_union_base",
            "_cast_inplace",
            "rename_categories",
            "test_searchsorted_numeric_dtypes_scalar",
            "test_ts_plot_format_coord",
            "test_get_label_or_level_values_series_axis1_error",
            "_get_resampler_for_grouping",
            "test_float_series_rdiv_td64arr",
            "time_skipprows",
            "test_dont_clobber_name_column",
            "test_convert_int_overflow",
            "test_read_with_stop",
            "compute",
            "test_default_right_closed_label",
            "test_first_fill_value_loc",
            "test_df_boolean_comparison_error",
            "_compare_stacked_y_cood",
            "test_parsers_dayfirst_yearfirst",
            "test_from_M8_structured",
            "indexer_from_factorized",
            "group_info",
            "test_insert_base",
            "_write_to_group",
            "test_concat_different_columns_buggy",
            "test_map_decimal",
            "test_on_float_by_int",
            "test_bday_overflow_error",
            "test_select_iterator_non_complete_8014",
            "test_to_sparse_pass_name",
            "write_tr",
            "test_concat_invalid",
            "test_ufuncs_binary_int",
            "test_cut_out_of_bounds",
            "test_join_index_mixed_overlap",
            "test_agg_relabel",
            "_maybe_cast_indexer",
            "test_to_period_annualish",
            "test_repr_to_string",
            "get_empty_dtype_and_na",
            "test_dropIncompleteRows",
            "test_multiple_agg_funcs",
            "test_comparison_op_scalar",
            "groupings",
            "test_subclass_attr_err_propagation",
            "test_resample_5minute",
            "test_with_mixed_tuples",
            "test_bad_kwarg",
            "test_shift_fill_value",
            "time_op",
            "test_info_repr_max_cols",
            "test_with_nans",
            "test_reindex_backfill",
            "test_constructor_generator",
            "test_ndarray_compat",
            "_rewrite_assign",
            "_stringify_na_values",
            "maybe_infer_to_datetimelike",
            "_applymap",
            "validate_groupby_func",
            "test_append_with_diff_col_name_types_raises_value_error",
            "test_format_sparse_config",
            "test_frame_select_complex2",
            "test_astype_asfreq",
            "_post_setstate",
            "_value_with_fmt",
            "test_streaming_s3_objects",
            "test_get_accessor_args",
            "test_iloc_fill_value",
            "test_from_categorical_dtype_categories",
            "test_to_csv_from_csv4",
            "test_unstack_period_frame",
            "win_types",
            "test_MillisecondTimestampArithmetic",
            "test_namespace",
            "to_pydatetime",
            "get_finder",
            "test_unique_datetimelike",
            "test_str_cat_all_na",
            "test_loc_index_fill_value",
            "test_data",
            "test_integer_col_names",
            "time_cython_sum",
            "transform_assert_equal",
            "objSeries",
            "test_agg_misc",
            "test_get_str_from_freq",
            "test_is_datetime_or_timedelta_dtype",
            "test_dropEmptyRows",
            "test_smaller",
            "test_parsers_iso8601",
            "test_hexbin_basic",
            "test_apply_differently_indexed",
            "test_normalize_date",
            "_prep_binary",
            "test_groupby_resample_on_api_with_getitem",
            "test_datetimeindex_diff",
            "_compare_or_regex_search",
            "test_merge_suffix_none_error",
            "time_reindexed",
            "with_csv_dialect",
            "test_unbalanced",
            "_format_strings",
            "test_get_loc_raises_bad_label",
            "test_join_overlap",
            "test_timegrouper_get_group",
            "time_categorical_series_is_monotonic_increasing",
            "test_concat_with_group_keys",
            "test_dt_accessor_datetime_name_accessors",
            "test_rng_context",
            "test_from_arrays_tuples",
            "time_dt_accessor_year",
            "test_multi_thread_string_io_read_csv",
            "test_count_level_corner",
            "test_subclass_sparse_slice",
            "test_2",
            "test_xs_level_series_ymd",
            "get_root",
            "test_string_index_series_name_converted",
            "test_minimal_size_col",
            "test_dataframe_dummies_unicode",
            "hexbin",
            "_has_same_tz",
            "test_assigning_ops",
            "orient",
            "test_standard_colors",
            "show_row_idx_names",
            "test_offset_whole_year",
            "test_categorical_repr_timedelta",
            "time_multi_size",
            "time_datetime_difference_disjoint",
            "test_dt64_nat_comparison",
            "test_scalar_non_numeric",
            "rule_from_name",
            "test_encode_non_c_locale",
            "test_index_duplicate_periods",
            "assignment_not_inplace",
            "test_date_accessor",
            "test_td64arr_mul_tdscalar_invalid",
            "test_asfreq_bug",
            "test_version",
            "test_get_set_value",
            "test_basic_names_raise",
            "test_operators_na_handling",
            "_make_plot",
            "test_series_grid_settings",
            "tests_merge_categorical_unordered_equal",
            "test_constructor_nan_dataframe",
            "test_ix_loc_consistency",
            "test_construction_to_datetimelike_unit",
            "test_is_strictly_monotonic",
            "test_rename_errors_raises",
            "test_dtype_equal",
            "test_global_scope",
            "test_parse_failure_rewinds",
            "test_assert_not_almost_equal_numbers",
            "get_dummies",
            "test_usecols_index_col_false",
            "test_datetime_subclass",
            "test_array",
            "get_atom_timedelta64",
            "_rewrite_membership_op",
            "test_check_label_or_level_ambiguity_series",
            "test_array_tz",
            "__doc__",
            "_create_indexer",
            "_maybe_mangle_lambdas",
            "test_constructor_datetimes_with_nulls",
            "test_pipe_args",
            "test_getitem_list_periods",
            "test_onecolumn_of_integer",
            "write_legacy_msgpack",
            "test_nat_comparisons",
            "test_constructor_cant_cast_datetimelike",
            "test_query_default",
            "test_codes_dtypes",
            "test_combine_first_name",
            "test_map_counter",
            "test_date",
            "test_read_write_dta5",
            "test_repr_with_mi_nat",
            "test_filter_and_transform_with_non_unique_timestamp_index",
            "test_value_counts_datetime_outofbounds",
            "test_invalid_timestamp",
            "test_td64_mean",
            "test_parr_add_sub_dt64_array_raises",
            "test_rolling_kurt",
            "test_array_equivalent_str",
            "test_to_string_decimal",
            "test_constructor_mixed_tz",
            "test_loc_multi_tuple",
            "test_ragged_skew",
            "test_from_records_iterator",
            "test_assert_almost_equal_class_mismatch",
            "time_cut_float",
            "test_pi_ops_offset",
            "test_range_kwargs_deprecated",
            "test_string_repr_encoding",
            "test_Nanosecond",
            "test_indices_concatenation_order",
            "test_getitem_fancy_ints",
            "git_get_keywords",
            "default_kind",
            "gen_series_formatting",
            "test_constant",
            "sint_dtype",
            "test_nat_parse",
            "test_ix_dup",
            "time_nsmallest_one_column",
            "boxplot_frame",
            "time_get_loc_dec",
            "test_pi_sub_pi_with_nat",
            "test_nan_numeric",
            "writeable",
            "_exclude_implicit_index",
            "test_write_dta6",
            "test_numpy_minmax_integer",
            "test_numexpr_builtin_raises",
            "test_astype_nan_raises",
            "test_bool",
            "test_to_datetime_infer_datetime_format_series_start_with_nans",
            "get_indexer_dict",
            "_multi_blockify",
            "time_append_mixed",
            "test_difference_empty_arg",
            "merge_class",
            "is_mixed_type",
            "test_repr_html_ipython_config",
            "_calcsize",
            "test_split_to_multiindex_expand",
            "test_invalid_total_length_max_length_multiple",
            "test_rank_resets_each_group",
            "test_categorical_equality_strings",
            "test_parse_timezone",
            "visit_Call",
            "test_reindex_like",
            "time_cut_int",
            "test_is_signed_integer_dtype",
            "test_iterrows_iso8601",
            "use_bottleneck_cb",
            "test_grouped_hist_multiple_axes",
            "test_nonnumeric_suffix",
            "test_to_csv_from_csv5",
            "validate_resampler_func",
            "test_set_axis_name_mi",
            "test_is_object",
            "json_normalize",
            "test_pi_sub_isub_int",
            "_coerce_to_type",
            "test_identity_slice_returns_new_object",
            "test_api",
            "time_is_monotonic",
            "test_constructor_coverage",
            "add_ops",
            "test_stat_non_defaults_args",
            "_static_values",
            "test_other_columns",
            "missing_whitespace_after_comma",
            "_format_multirow",
            "_validate_fill_value",
            "squeeze",
            "test_groupby_multiindex_series_keys_len_equal_group_axis",
            "test_groupby_cum_skipna",
            "test_setitem",
            "_chunk_to_dataframe",
            "time_cut_datetime",
            "test_multifunc_sum_bug",
            "test_view_with_args",
            "test_td_div_numeric_scalar",
            "test_binary_ufunc_with_series",
            "test_csv_custom_parser",
            "test_fillna",
            "test_setitem_series_int8",
            "test_offset_deprecated",
            "time_extract",
            "set_precision",
            "test_is_string_array",
            "test_reindex_columns",
            "test_is_mixed_type",
            "test_sample",
            "test1_basic",
            "test_timedelta64_nan",
            "test_colspan_rowspan_both_not_1",
            "test_where_with_bool_data_and_other",
            "test_pow_float",
            "_style_to_xlwt",
            "test_empty_series_frame",
            "test_on_index_object",
            "nrows",
            "set_attr",
            "test_equality_generic",
            "test_read_invalid_types_raises",
            "test_get_first_bday",
            "test_examples3",
            "execute",
            "test_get_loc_msg",
            "time_groupby_nth_all",
            "test_roundtrip_indexlabels",
            "test_numpy_minmax_range",
            "lines_json_df",
            "test_categorical_nans",
            "test_asof_datetime_partial",
            "test_series_getitem",
            "test_first_last_nth_dtypes",
            "test_setitem_index_timedelta64",
            "_dt_array_cmp",
            "test_set_categories_many",
            "init_xclip_clipboard",
            "test_to_string_unicode_columns",
            "round",
            "all_packers_data",
            "test_resample_loffset",
            "test_pipe_tuple_error",
            "test_frame_operators",
            "test_none",
            "test_maybe_convert_objects_uint64",
            "test_astype_extension_dtypes_duplicate_col",
            "_skip_if_no_pchip",
            "test_buffer_rd_bytes_bad_unicode",
            "test_arith_flex_zero_len_raises",
            "test_astype_mixed_type",
            "test_invalid_local_variable_reference",
            "test_delitem",
            "test_tick_zero",
            "test_stack_multiple_out_of_bounds",
            "_sparsify",
            "test_merge_index_as_on_arg",
            "test_replace_period",
            "test_get_indexer_non_unique_with_int_and_float",
            "test_reverse_ops_with_index",
            "test_string_nas",
            "test_read_fspath_all",
            "test_int64_min_issues",
            "validate_fillna_kwargs",
            "test_xlrd_version_fallback",
            "test_concat_different_columns_sort_warns",
            "test_multiindex_passthru",
            "test_usecols_with_parse_dates_and_names",
            "test_agg_apply",
            "test_empty_sum",
            "time_reindex_axis1",
            "test_fillna_fill_value",
            "_unpickle_sparse_frame_compat",
            "test_wikipedia_states_table",
            "time_to_string_floats",
            "test_registry_resets",
            "test_pivot_with_multiindex",
            "test_Easter",
            "_maybe_convert_timedelta",
            "_maybe_convert_usecols",
            "identical",
            "is_scalar",
            "test_getitem_fancy_1d",
            "test_date_range_nat",
            "test_td_rfloordiv_numeric_scalar",
            "test_ngroup_empty",
            "test_latex_repr",
            "test_join_non_unique_period_index",
            "time_multiple_date",
            "_python_apply_general",
            "test_sort_values_categorical",
            "test_from_dict_columns_parameter",
            "list_of_tuples_with_none",
            "test_inplace_mutation_resets_values",
            "time_rank_int_cat",
            "nulls_fixture",
            "test_first_subset",
            "test_getitem_partial_int",
            "test_invalid_suffixtype",
            "_get_monthly_rule",
            "_unpack_cycler",
            "test_to_datetime_on_datetime64_series",
            "test_idxmin",
            "test_fallback_success",
            "time_get_indexer",
            "test_write_fspath_all",
            "test_from_frame_error",
            "time_write_store",
            "_validate_join_method",
            "test_imethods_with_dups",
            "test_extractall_same_as_extract_subject_index",
            "test_setitem_mask_broadcast",
            "test_set_ordered",
            "read_sql_table",
            "unit",
            "time_intersection_both_duplicate",
            "test_scalar_assignment",
            "timedelta_range",
            "test_interp_inplace",
            "test_ambiguous_width",
            "test_convert_objects",
            "time_on_int32",
            "set_test_mode",
            "test_constructor",
            "test_resample_how_callables",
            "test_to_csv_wide_frame_formatting",
            "_box_as_indexlike",
            "test_constructor_with_int_tz",
            "makeUIntIndex",
            "_start",
            "test_sort_index_duplicates",
            "test_to_period_quarterly",
            "test_properties_quarterly",
            "size",
            "time_unique_date_strings",
            "_putmask_smart",
            "test_pandas_dtypes",
            "time_from_scipy",
            "test_registering_no_warning",
            "rolling",
            "storage_obj_type",
            "test_dispatch_transform",
            "test_properties_daily",
            "makeObjectSeries",
            "test_multiple_aggregators_with_dict_api",
            "test_secondary_axis_font_size",
            "test_groupby_level_mapper",
            "test_iter_single_element",
            "assert_block_equal",
            "_agg_index",
            "test_is_number",
            "test_constructor_invalid_Z0_isostring",
            "test_aggregate_float64_no_int64",
            "test_series_add_aware_naive_raises",
            "file_filter",
            "_create_unary_method",
            "test_infer_objects_series",
            "_get_loc",
            "test_replace_across_dst",
            "time_dup_string_tzoffset_dates",
            "test_bigint_warning",
            "test_align_int",
            "_query_iterator",
            "test_reindex_preserves_type_if_target_is_empty_list_or_array",
            "testFixnum",
            "day",
            "test_subclass",
            "zfill",
            "has_truncated_repr",
            "test_constructor_categorical_series",
            "test_resample_timestamp_to_period",
            "test_take2",
            "time_itertuples_start",
            "test_not_reflect_all_tables",
            "ravel",
            "test_append_different_columns_types",
            "test_period_cons_annual",
            "test_wrong_num_labels",
            "standardize_mapping",
            "_compose2",
            "test_all",
            "test_constructor_range_dtype",
            "update_dtype",
            "_get_formatted_index",
            "test_check_dtype",
            "test_agg_structs_series",
            "test_raw_roundtrip",
            "mask_zero_div_zero",
            "test_slice_month",
            "test_read_excel_without_slicing",
            "_load_test2_data",
            "test_dti_tz_localize_ambiguous_flags",
            "test_scalar_call_versus_list_call",
            "_get_level_values",
            "test_rename_categories",
            "test_multi_index_parse_dates",
            "test_join_indexes_and_columns_on",
            "test_skipfooter_bad_row",
            "test_replace_replacer_equals_replacement",
            "test_date_range_int64_overflow_stride_endpoint_different_signs",
            "test_to_csv_string_with_crlf",
            "test_stack_dropna",
            "test_filter_using_len",
            "test_series_indexing_zerodim_np_array",
            "test_rsplit_to_dataframe_expand",
            "_get_codes_for_values",
            "test_get_loc_scalar",
            "time_rsplit",
            "mgr",
            "test_series_tz_localize_ambiguous_bool",
            "from_params",
            "test_transform_datetime_to_numeric",
            "test_getitem_setitem_tuple_plus_columns",
            "test_repr_max_columns_max_rows",
            "test_integer_passthrough",
            "test_fillna_different_dtype",
            "time_lstrip",
            "test_eq_with_numpy_object",
            "makeMixedDataFrame",
            "test_float_array_different_kind",
            "test_messed_up_data",
            "test_get_loc_raises_object_tolerance",
            "test_scalar_with_mixed",
            "time_small_get_loc_warm",
            "test_create_table_index",
            "test_quantile_sparse",
            "test_fillna_object",
            "_get_index_freq",
            "_get_complex_date_index",
            "test_read_excel_multiindex_empty_level",
            "test_reset_index_level",
            "_unpickle_array",
            "test_pi_add_iadd_timedeltalike_hourly",
            "test_loc_slice_fill_value",
            "test_corrwith_index_intersection",
            "str_repeat",
            "test_set_index_names",
            "test_nat_fields",
            "test_is_monotonic_increasing",
            "_in",
            "test_ops_datetimelike_align",
            "test_construction",
            "test_reindex_axis_style_raises",
            "test_sub_n_gt_1_ticks",
            "test_pow",
            "test_frame_to_dict_tz",
            "test_series_ret_bins",
            "time_add_10",
            "test_tolist",
            "test_parse_date_column_with_empty_string",
            "test_is_scalar_numpy_zerodim_arrays",
            "test_conv_monthly",
            "time_nested_dict_int64",
            "registry_without_decimal",
            "test_drop_exception_raised",
            "test_groupby_with_single_column",
            "test_numpy_round",
            "test_slicing_doc_examples",
            "to_records",
            "test_validate_ndim",
            "test_nat_arithmetic_scalar",
            "test_constructor_casting",
            "_set_result_index_ordered",
            "test_by_int",
            "test_align_series_frame",
            "test_mixed_depth_insert",
            "test_info_repr",
            "test_repr_small",
            "versions_from_file",
            "_get_join_keys",
            "mix_abc",
            "test_to_datetime_today_now_unicode_bytes",
            "test_cr_delimited",
            "test_multi_line_expression_local_variable",
            "_reference_dates",
            "test_needs_i8_conversion",
            "test_transform_bug",
            "test_values_numeric_cols",
            "test_ewmvol",
            "_recast_datetimelike_result",
            "test_subtype_integer_errors",
            "_align",
            "test_constructor_tuples",
            "test1_incremental",
            "mask",
            "test_nansem",
            "test_nat_pinned_docstrings",
            "_compose",
            "test_to_datetime_utc",
            "test_to_csv",
            "to_pytimedelta",
            "test_na_values_uint64",
            "test_argsort_stable",
            "test_mi_sparse_column_names",
            "test_datetime_tz_qcut",
            "test_from_csv",
            "compression",
            "test_apply_multikey_corner",
            "test_config_on",
            "test_resample_timedelta_idempotency",
            "test_contains_with_nat",
            "fill_binop",
            "time_read_csv",
            "test_merge_overlap",
            "time_encode_decode",
            "test_iloc_slice",
            "conform",
            "test_sharex_and_ax",
            "test_no_flex",
            "test_period_ops_offset",
            "test_parse_booleans",
            "validate_all",
            "time_duplicated_unique",
            "test_boolean_index_empty_corner",
            "test_merge_suffix",
            "test_ewmcov_pairwise",
            "test_slice_locs_dup",
            "linkcode_resolve",
            "_remove_labels_from_axis",
            "test_numeric_only_flag",
            "test_scalar_raises",
            "test_multi_line_expression_callable_local_variable",
            "test_parse_dates_no_convert_thousands",
            "test_excel_table",
            "test_apply_attach_name",
            "test_frame_values_with_tz",
            "test_dti_tz_localize_nonexistent",
            "test_list_numpy_float_complex",
            "save",
            "test_indexing_ambiguity_bug_1678",
            "__truediv__",
            "test_true_and_false_value_options",
            "test_operators_bitwise",
            "test_numpy_string_dtype",
            "test_agg_category_nansum",
            "test_tz_localize_errors_invalid_arg",
            "test_join_index_more",
            "load_test_data_and_sql",
            "empty",
            "check_equal",
            "test_basic_sort",
            "test_quantile_empty",
            "test_any",
            "_add_series_or_dataframe_operations",
            "_akima_interpolate",
            "test_td_rfloordiv_null_scalar",
            "test_dti_eq_null_scalar",
            "test_round_trip_frame_sep",
            "_check_frame_ops",
            "test_interp_alt_scipy",
            "test_unicode_repr_level_names",
            "_join_multi",
            "_check_not_equal_with_index",
            "test_merge_on_indexes",
            "is_null_slice",
            "take_2d_multi",
            "to_numpy_dtypes",
            "simple_multiindex_dataframe",
            "test_date_range_gen_error",
            "test_parse_ragged_csv",
            "_resolution",
            "_add_delta",
            "test_to_csv_no_index",
            "test_valid_allow_exact_matches",
            "_create_methods",
            "test_tick_equalities",
            "_get_data_as_items",
            "merge",
            "test_mode_timedelta",
            "test_copy",
            "m_offset",
            "test_resample_interpolate",
            "test_concat_multiindex_with_none_in_index_names",
            "test_where_series_datetime64tz",
            "_write_row_header",
            "_add_offset",
            "test_more_than_one_expression_raises",
            "maybe_cast_to_integer_array",
            "test_stack_unstack",
            "test_unicode_name_in_footer",
            "test_convert_pandas_type_to_json_field_categorical",
            "test_corrwith_spearman",
            "test_verbose_read",
            "peakmem_int",
            "test_number_looking_strings_not_into_datetime",
            "test_selection_by_datetimelike",
            "test_ctor_str_intraday",
            "flush",
            "test_getitem_seconds",
            "_maybe_restore_index_levels",
            "test_append_preserve_name",
            "test_calendar_observance_dates",
            "compress_file",
            "test_mixed_datetime64",
            "clean_reindex_fill_method",
            "ensure_clean_dir",
            "test_td64arr_sub_pi",
            "test_parsing_non_iso_timezone_offset",
            "test_no_invalid_float_truncation",
            "test_resample_segfault",
            "test_sheet_name",
            "test_datetime_tz_cut",
            "_max_fitting_element",
            "test_to_string_with_formatters_unicode",
            "plt",
            "test_kurt",
            "test_strings",
            "test_unordered_different_order_equal",
            "_try_cast_result",
            "_handle_hidden_tables",
            "test_multiple_tbody",
            "test_setitem_index_datetime64",
            "test_from_inferred_categories_dtype",
            "test_idxmin_idxmax_returns_int_types",
            "test_to_datetime_iso8601",
            "time_isin_many_different",
            "test_apply_without_aggregation",
            "_concat_categorical",
            "test_map",
            "test_as_json_table_type_bool_dtypes",
            "test_reindex_non_unique",
            "raise_assert_detail",
            "test_partition_with_name",
            "_get_list_axis",
            "write_th",
            "test_config_prefix",
            "test_checknull",
            "_is_type_compatible",
            "test_regular_min",
            "test_from_records_non_tuple",
            "fill_frame",
            "test_isin_dupe_self",
            "time_rpartition",
            "pytest_runtest_setup",
            "test_override_set_noconvert_columns",
            "test_sparse_series_ops",
            "test_join_right",
            "test_subclass_sparse_addition",
            "test_query_empty_string",
            "format_object_summary",
            "get_key",
            "to_dense",
            "test_constructor_not_sequence",
            "test_neg",
            "test_unit_m_y_deprecated",
            "test_map_missing",
            "test_merge_join_key_dtype_cast",
            "isiterable",
            "test_frame_groupby",
            "test_union",
            "test_rolling_median_resample",
            "set_atom_datetime64",
            "test_read_s3_with_hash_in_key",
            "test_skiprows_lineterminator",
            "time_multiply",
            "last_valid_index",
            "test_maybe_convert_i8_errors",
            "test_delevel_infer_dtype",
            "test_closed_uneven",
            "_join_index",
            "scatter_matrix",
            "_get_item_cache",
            "test_resample_ohlc_dataframe",
            "_setup_dtype",
            "_workbook_class",
            "test_repr_should_return_str",
            "test_rolling_min_max_numeric_types",
            "_union",
            "test_iloc_getitem_frame",
            "test_get_schema_keys",
            "test_resample_groupby_with_label",
            "test_errors_param_filters_errors",
            "test_boxplot_legacy2",
            "time_format_YYYYMMDD",
            "test_getitem_with_scalar",
            "dropna",
            "test_size",
            "test_mi_sparse_index_names",
            "test_is_file_like",
            "_setitem_array",
            "test_fillna_preserves_tz",
            "test_reset_index_period",
            "test_header_multi_index_common_format_malformed3",
            "_get_slice_axis",
            "test_line_lim",
            "test_is_not_unsigned_integer_dtype",
            "test_iteritems",
            "write_td",
            "test_print_unicode_columns",
            "test_exponents_with_eng_prefix",
            "g",
            "test_default_na_values",
            "test_is_s3_url",
            "test_expanding_corr_cov",
            "test_to_offset_negative",
            "search",
            "test_logical_ops_with_index",
            "subtype",
            "test_single_backtick_variable_expr",
            "_get_ax_freq",
            "_read_strls",
            "test_td64arr_mul_numeric_scalar",
            "test_categorical_concat_gh7864",
            "is_non_overlapping_monotonic",
            "test_set_names_with_nlevel_1",
            "generate",
            "test_readjson_chunks_from_file",
            "test_datetime_likes",
            "test_where_different_freq_raises",
            "sql_schema",
            "test_to_html_truncation_index_false_max_cols",
            "test_nanlt",
            "test_basic_left_index",
            "test_error_iso_week_year",
            "test_is_numeric",
            "test_fillna_series_period",
            "_is_metadata_of",
            "test_works_on_valid_markup",
            "integer_array",
            "test_concat_astype_dup_col",
            "test_readjson_chunksize_requires_lines",
            "test_union_identity",
            "test_slice_locs_partial",
            "appends",
            "time_timestamp_ops_diff",
            "test_constructor_list_str_na",
            "test_precise_conversion",
            "_create_blocks",
            "time_duplicated",
            "test_astype_object2",
            "contains",
            "_try_visit_binop",
            "test_getitem_partial",
            "test_boolean_comparison",
            "test_date_range_timestamp_equiv_preserve_frequency",
            "asfreq",
            "test_join_on_tz_aware_datetimeindex",
            "time_setitem_period_column",
            "_any_pandas_objects",
            "form_blocks",
            "test_add_series_with_extension_array",
            "test_merge_on_periods",
            "test_non_string_na_values",
            "_iget_item_cache",
            "at_time",
            "set_names",
            "test_apply_index",
            "test_regex_replace_regex_list_to_numeric",
            "test_basic_getitem_with_labels",
            "init_klipper_clipboard",
            "_maybe_right_yaxis",
            "test_quantile",
            "test_align_mixed_int",
            "test_assert_almost_equal_edge_case_ndarrays",
            "_check_is_chained_assignment_possible",
            "test_truncate_nonsortedindex",
            "test_setitem_slice_into_readonly_backing_data",
            "test_warn_if_chunks_have_mismatched_type",
            "makeFY5253NearestEndMonth",
            "test_frame_append_datetime64_column",
            "is_unique_asi8",
            "test_line_label_none",
            "test_start_stop_fixed",
            "test_iat_setter_incompatible_assignment",
            "test_partial_set_empty_frame",
            "test_ufunc_at",
            "test_factorize_na_sentinel",
            "test_invalid_key",
            "test_read_jsonl_unicode_chars",
            "test_length_timestamp",
            "time_get_groups",
            "valid",
            "current_pickle_data",
            "_right_outer_join",
            "__sizeof__",
            "test_error_bad_lines",
            "test_group_shift_with_fill_value",
            "test_nonzero_warning",
            "test_pivot_table_dropna",
            "_assert_safe_casting",
            "test_logical_operators",
            "_get_deprecated_option",
            "test_groupby_with_empty",
            "df_full",
            "test_to_csv_with_single_column",
            "test_iterable_map",
            "test_nat_rfloordiv_timedelta",
            "test_partial_slice_minutely",
            "test_float_same_index",
            "test_cmp_dt64_arraylike_tznaive",
            "_get_counts_nanvar",
            "test_lookup_array",
            "test_getitem_dups",
            "test_internal_eof_byte",
            "test_assert_almost_equal_value_mismatch1",
            "_maybe_downcast_constants",
            "sort_index",
            "is_list_like_indexer",
            "test_getitem_sparse_column",
            "test_floordiv_div",
            "set_atom_string",
            "stack_sparse_frame",
            "test_apply_trivial_fail",
            "test_assert_not_almost_equal_null",
            "test_normalize_tz",
            "test_raise_on_no_columns",
            "time_read_csv_python_engine",
            "test_inner_join_indexer2",
            "assign",
            "test_setitem_change_dtype",
            "time_nsmallest_two_columns",
            "from_array",
            "test_first_raises",
            "set_atom_datetime64tz",
            "test_set_axis_name",
            "test_airline",
            "test_compare_zerodim_array",
            "test_object_series_ok",
            "time_first",
            "time_fromtimestamp",
            "test_sort_values_missing",
            "test_groupby_series_with_name",
            "test_any_datetime",
            "test_fill_method_and_how_upsample",
            "test_sub_period",
            "test_loc_getitem_iterator",
            "test_numpy_mean",
            "test_type_coercion_fail",
            "test_basic_index",
            "test_rolling_cov_offset",
            "test_pass_names_with_index",
            "_upsample",
            "time_dt_accessor_normalize",
            "test_filter_and_transform_with_non_unique_int_index",
            "test_tab_complete_ipython6_warning",
            "test_dti_custom_getitem",
            "test_mul_int_identity",
            "test_latin_encoding",
            "test_transform_and_agg_error",
            "test_transpose_tzaware_1col_single_tz",
            "_strip_schema",
            "test_read_duplicate_index_explicit",
            "test_resample_across_dst",
            "time_frame_from_records_generator",
            "test_itemsize",
            "indentation_is_not_a_multiple_of_four",
            "test_numpy_array_float",
            "_replace_single",
            "test_constructor_empty_special",
            "convert_pandas_type_to_json_field",
            "test_per_axis_per_level_setitem",
            "test_valid_relativedelta_kwargs",
            "_guess_time_format_for_array",
            "test_str_attribute",
            "test_col_level",
            "named_single_return",
            "test_date_col_as_index_col",
            "test_frame_join_tzaware",
            "test_is_datetimelike",
            "test_legacy_offset_warnings",
            "test_categorical_shift_fill_value",
            "test_header_multi_index_common_format3",
            "_set_values",
            "test_memory_usage",
            "test_unit_with_numeric",
            "test_index_name",
            "datetime_series",
            "_set_names",
            "time_from_missing",
            "test_closed_min_max_datetime",
            "test_legend_name",
            "_is_index_col",
            "test_weekly_upsample",
            "test_basics_with_nan",
            "_filter_indexer_tolerance",
            "test_frame_loc_callable",
            "_convert_to_style",
            "_get_annual_rule",
            "time_transform_multi_key3",
            "test_frame_describe_tupleindex",
            "read_table",
            "recode_from_groupby",
            "test_period_with_agg",
            "test_num_string_disambiguation",
            "test_dti_tz_constructors",
            "test_plot_bar",
            "_disallow_scalar_only_bool_ops",
            "is_type_factory",
            "test_to_string_format_na",
            "test_is_scalar_pandas_containers",
            "test_nan",
            "test_dti_snap",
            "test_infer_from_tdi",
            "test_assert_numpy_array_equal_value_mismatch2",
            "test_float_arithemtic",
            "test_dt64arr_add_sub_tick_DateOffset_smoke",
            "test_frame_mi_access_returns_frame",
            "test_apply_broadcast_deprecated",
            "test_initial_warning",
            "test_tricky_container",
            "test_different_nans_as_float64",
            "time_divide",
            "test_assign_index_sequences",
            "test_concat_mixed_objs",
            "_decorate_ticks",
            "test_set_dataframe_column_ns_dtype",
            "to_tuples",
            "test_is_monotonic_na",
            "time_iso8601_format",
            "test_can_hold_na_valid",
            "test_iloc_setitem_list_of_lists",
            "test_cut_read_only",
            "test_categorical_warnings_and_errors",
            "write_data",
            "time_is_month_end",
            "_infer_columns",
            "test_getitem_iloc",
            "time_groupby_extra_cat_nosort",
            "_engine",
            "test_complex_fixed",
            "test_api_mi_raises",
            "_asof_by_function",
            "test_pivot_table_with_nans",
            "test_nanosecond_resample_error",
            "test_bar_align_single_column",
            "nancov",
            "test_outer_join_indexer2",
            "test_dti_shift_int",
            "_center_window",
            "test_single_common_level",
            "tzname",
            "test_cummax_datetime64",
            "test_positional_take",
            "test_complex_series_error",
            "_outer_indexer",
            "has_duplicates",
            "test_partial_slice_daily",
            "test_constructor_coercion_signed_to_unsigned",
            "test_binary_ufunc_drops_series_name",
            "test_constructor_with_null",
            "test_timestamp_compare_with_early_datetime",
            "test_unary_in_array",
            "test_from_arrays_index_series_timedelta",
            "test_slice_float",
            "write_legacy_pickles",
            "validate",
            "test_take_na_empty",
            "write",
            "test_frame_align_aware",
            "test_mi_data_columns",
            "time_loop",
            "test_multi_char_sep_quotes",
            "test_empty_str_methods_to_frame",
            "test_combined_up_downsampling_of_irregular",
            "test_ncols",
            "test_join_utc_convert",
            "visit",
            "test_repr_mixed_big",
            "test_setitem_series_int64",
            "_next_opening_time",
            "test_to_csv_from_csv_categorical",
            "test_cython_group_transform_cumprod",
            "test_generate_cday",
            "is_open",
            "test_get_loc_nan",
            "block",
            "test_int_types",
            "_parsed_string_to_bounds",
            "time_timedelta_nanoseconds",
            "test_local_variable_with_in",
            "test_dti_business_repr",
            "test_delitem_corner",
            "test_union_with_DatetimeIndex",
            "to_stata",
            "test_getitem_category_type",
            "test_clip_with_na_args",
            "test_concat_series_name_npscalar_tuple",
            "is_old_version",
            "_subtype_with_str",
            "consensus_name_attr",
            "test_read_table",
            "test_to_datetime_YYYYMMDD",
            "test_groupby_multi_timezone",
            "test_mangle_dupe_cols_false",
            "_format_coord",
            "test_subplots_ts_share_axes",
            "test_pct_change_shift_over_nas",
            "test_numeric_column_names",
            "df_duplicates",
            "test_unique_tuples",
            "test_normalize_tz_local",
            "makeDateIndex",
            "_interpolate_scipy_wrapper",
            "getitem_block",
            "no_returns",
            "str_replace",
            "test_date_parser_resolution_if_not_ns",
            "_maybe_utc_convert",
            "test_join_hierarchical_mixed",
            "test_numpy_err_state_is_default",
            "test_categorical_dtype_chunksize_explicit_categories",
            "win_types_special",
            "check",
            "test_inf_parsing",
            "_str_extract_noexpand",
            "test_inconsistent_return_type",
            "test_iloc_row",
            "_assert_xtickslabels_visibility",
            "test_minmax_tz",
            "test_indexing_with_datetimeindex_tz",
            "time_groupby_sum_booleans",
            "set_numexpr_threads",
            "test_arith_series_with_array",
            "_sparse_array_op",
            "test_is_nested_list_like_fails",
            "test_is_re_passes",
            "test_update",
            "test_join_left_sequence_non_unique_index",
            "test_numpy_ufuncs_basic",
            "test_multiindex_is_homogeneous_type",
            "test_boolean",
            "test_max_len_string_array",
            "_parse_date_columns",
            "_missing_double",
            "test_set_levels_with_iterable",
            "get_datevalue",
            "test_create_temp_directory",
            "test_interp_combo",
            "__eq__",
            "to_excel",
            "test_apply_frame_yield_constant",
            "check_nancorr_nancov_1d",
            "test_sub_datetime_compat",
            "test_dti_tz_localize_utc_conversion",
            "_assert_can_do_setop",
            "get_dtype_counts",
            "test_cummethods_bool",
            "test_get_get_value",
            "__matmul__",
            "test_mixed_array_float_int",
            "_make_index",
            "time_transform_mean",
            "test_view_Index",
            "test_values_asarray",
            "test_groupby_keys_same_size_as_index",
            "test_order",
            "test_constructor_float32",
            "test_matplotlib_backend_error",
            "test_categorical_nan_handling",
            "test_skiprows_ndarray",
            "set_engine_and_path",
            "test_datetimelike_frame",
            "test_timedelta_assignment",
            "test_reindex_empty_index",
            "_groupby_and_aggregate",
            "_unpickle_matrix_compat",
            "test_rank_naoption_raises",
            "pandasSQL_builder",
            "time_convert_post",
            "test_constructor_error",
            "show_versions",
            "parse_date_time",
            "dataframe",
            "test_concat_aligned_sort",
            "_get_cython_function",
            "time_ceil",
            "_wrap_results",
            "test_tdi_iadd_int",
            "test_series_equal",
            "test_construction_base_constructor",
            "test_cat_accessor_api",
            "test_truncate_out_of_bounds",
            "_process_columnname_subheader",
            "source_file_def_line",
            "test_pivot_table_margins_name_with_aggfunc_list",
            "test_rolling_min_resample",
            "_get_partial_string_timestamp_match_key",
            "test_constructor_from_categorical_with_unknown_dtype",
            "is_function_or_method",
            "from_items",
            "test_to_latex_float_format_no_fixed_width",
            "test_excel_passes_na",
            "test_readjson_chunks",
            "empty_returns",
            "test_astype_categories_deprecation_raises",
            "test_gb_apply_list_of_unequal_len_arrays",
            "replace",
            "test_to_csv_escapechar",
            "test_dataframe_categorical_with_nan",
            "test_series_slice_partial",
            "_validate_names",
            "_getitem_axis",
            "reorder_arrays",
            "encoding",
            "test_categorial_assigning_ops",
            "test_drop_level_nonunique_datetime",
            "test_bad_class",
            "check_result_type",
            "test_xs_duplicates",
            "union_categoricals",
            "test_is_unique_monotonic",
            "test_categorical_index_repr_timedelta_ordered",
            "_evaluate_numexpr",
            "test_getitem_zerodim_np_array",
            "test_merge_different_column_key_names",
            "time_reindex_level",
            "test_y_listlike",
            "str_match",
            "get_expects",
            "to_manager",
            "test_union_freq_both_none",
            "test_unique_data_ownership",
            "map",
            "register_writer",
            "test_name",
            "test_from_dict",
            "test_pindex_slice_index",
            "_is_line_empty",
            "test_combine_first_mixed_bug",
            "test_with_duplicates_no_on",
            "_make_accessor",
            "test_to_timestamp_tz_arg",
            "str_count",
            "df_ref",
            "read_sas",
            "test_groupby_preserves_sort",
            "test_to_html_formatters",
            "time_datetime_field_day",
            "_constructor_sliced",
            "test_interp_scipy_basic",
            "test_df_series_secondary_legend",
            "test_frame_loc_callable_mixture",
            "stack",
            "test_raises_on_non_datetimelike_index",
            "_validate_dt64_dtype",
            "_encode_complex",
            "test_index_names_multiple_nones",
            "test_getitem_fancy",
            "period_break",
            "safe_sort",
            "two_linebreaks_between_sections",
            "_is_label_or_level_reference",
            "test_built_in_round",
            "test_constructor_arrays_and_scalars",
            "test_getitem_boolean_object",
            "_maybe_coerce_indexer",
            "test_set_column_names_in_parameter",
            "test_get_indexer_same_categories_different_order",
            "time_sortlevel_one",
            "_parse_no_numpy",
            "test_regex_replace_list_mixed_inplace",
            "test_bar_bad_align_raises",
            "test_set_index_makes_timeseries",
            "clip_upper",
            "test_reduce",
            "test_as_array_datetime",
            "test_interpolate_invalid_float_limit",
            "test_getitem_setitem_slice_bug",
            "test__has_infs",
            "test_getitem_regression",
            "test_constructor_no_coercion",
            "test_replace_pure_bool_with_string_no_op",
            "_comp_method_FRAME",
            "test_interpolate_time_raises_for_non_timeseries",
            "test_emptylike_constructor",
            "visit_Str",
            "test_constructor_list_of_namedtuples",
            "test_stata_doc_examples",
            "test_extract_expand_True",
            "_min_fitting_element",
            "test_convert_numeric_uint64_nan_values",
            "test_indexing_with_datetime_tz",
            "test_get_nan_multiple",
            "_f3_mapping",
            "take_nd",
            "test_apply_to_empty_series",
            "_noarg_wrapper",
            "test_select_dtypes_exclude_include_using_list_like",
            "raw_frame",
            "test_to_period_microsecond",
            "test_reindex_categorical",
            "test_to_csv_sparse_dataframe",
            "test_timedelta64_ops_nat",
            "test_corr_cov_independent_index_column",
            "nontemporal_method",
            "run",
            "test_to_datetime_now",
            "test_loc_multiindex_labels",
            "test_no_order",
            "test_ctor_reindex",
            "time_get",
            "test_iat_invalid_args",
            "_translate_key",
            "test_unstack_fill_frame",
            "test_at_with_tz",
            "test_writer_117",
            "_get_suffix_prefix",
            "_check_logical_ops",
            "check_floor_division",
            "test_NaT_cast",
            "test_callable_usecols",
            "test_frame_getitem_setitem_multislice",
            "test_hist_df_kwargs",
            "test_replace_dict_tuple_list_ordering_remains_the_same",
            "__finalize__",
            "test_month_range_union_tz_pytz",
            "test_is_timedelta64_ns_dtype",
            "test_append_empty_dataframe",
            "test_read_write_dta13",
            "test_pivot_table_values_key_error",
            "check_fun_data",
            "_get_closing_time",
            "_ensure_localized",
            "_agg_by_level",
            "test_set_closed",
            "test_partial_slice_doesnt_require_monotonicity",
            "test_reset_index_right_dtype",
            "test_all_invalid_plot_data",
            "test_from_index",
            "test_is_extension_array_dtype",
            "safe_import",
            "test_format_explicit",
            "test_set_dtype_nans",
            "fill_zeros",
            "time",
            "make_nancomp",
            "test_equals_categoridcal_unordered",
            "test_to_html_with_id",
            "test_assert_idxminmax_raises",
            "test_getitem_fancy_slice_integers_step",
            "test_merge_on_int_array",
            "test_concat_NaT_dataframes_all_NaT_axis_1",
            "test_override_inferred_closed",
            "test_smaller_Raises_Value",
            "_convert_to_style_kwargs",
            "test_var_std",
            "test_difference_name_preservation",
            "test_slice_locs_dup_numeric",
            "test_expanding_cov_pairwise",
            "test_missing_required_dependency",
            "_has_valid_setitem_indexer",
            "indices",
            "test_maybe_promote_int_with_int",
            "test_very_wide_info_repr",
            "test_excel_cell_error_na",
            "test_union_categoricals_nan",
            "test_repr_chop_threshold",
            "test_loc_getitem_frame",
            "test_categorical_categories",
            "test_require_integers",
            "test_hist",
            "test_to_csv_gcs",
            "_zero_out_fperr",
            "test_construction_empty_with_bool_categories",
            "is_float_dtype",
            "test_conv_daily",
            "test_unstack_non_unique_index_names",
            "test_get_indexer_categorical_time",
            "test_pi_sub_intarray",
            "test_sparse_accessor_updates_on_inplace",
            "test_subclass_unstack",
            "iterrows",
            "test_allow_exact_matches_and_tolerance_nearest",
            "test_asfreq_combined",
            "test_order_compat",
            "time_any",
            "test_series_partial_set_with_name",
            "test_min_max",
            "test_to_sql",
            "extract",
            "next_monday",
            "test_cat_accessor_no_new_attributes",
            "indent",
            "test_to_string_buffer_all_unicode",
            "test_sum_inf",
            "rsub",
            "test_dataframe_dummies_with_na",
            "test_constructor_year_and_quarter",
            "init_no_clipboard",
            "testMult2",
            "test_thousands_macau_stats",
            "_period_array_cmp",
            "test_to_dict_numeric_names",
            "test_dti_shift_tzaware",
            "test_name_error_exprs",
            "_time_to_micros",
            "test_get_indexer_nearest_error",
            "test_operators_datetimelike_with_timezones",
            "test_nested_exception",
            "test_constructor_dict_of_iterators",
            "test_cython_transform_series",
            "_hash_categories",
            "jsonl_file",
            "max_level_test_input_data",
            "_assert_not_frame_equal_both",
            "test_dropna_corner",
            "test_tz_dateutil",
            "test_expanding_cov_diff_index",
            "test_where_datetime_conversion",
            "test_setitem_different_unordered_raises",
            "test_to_perioddelta",
            "encode_decode",
            "test_read_table_absent_raises",
            "test_na_levels",
            "test_boundary_float",
            "test_precision_finer_than_offset",
            "test_index_equal_values_mismatch",
            "time_split",
            "test_to_html_round_column_headers",
            "_is_na_fill_value",
            "append_to_multiple",
            "test_dti_tz_localize_errors_deprecation",
            "test_construction_list_tuples_nan",
            "test_temporary_table",
            "test_basic_drop_first",
            "test_set_index_custom_label_hashable_iterable",
            "test_getitem_setitem_datetime_tz_dateutil",
            "test_axis_limits",
            "to_frame",
            "test_reindex_lvl_preserves_type_if_target_is_empty_list_or_array",
            "test_fancy",
            "test_multiindex_slicers_datetimelike",
            "makeRangeIndex",
            "test_setitem_with_unaligned_tz_aware_datetime_column",
            "time_from_int",
            "test_compare_timedelta_series",
            "test_usecols_str",
            "test_intersection_different_type_base",
            "test_bins_monotonic_not_overflowing",
            "_reindex_index",
            "test_to_records_dtype",
            "test_pi_ops_nat",
            "test_dataframe_categorical_ordered_observed_sort",
            "test_unique_na_fill",
            "test_setitem_series_datetime64",
            "test_join_inner",
            "frame2",
            "test_sort_index_inplace",
            "_get_merge_keys",
            "test_equals_op_multiindex_identify",
            "test_usecols_out_of_bounds",
            "test_resample_consistency",
            "test_loc_getitem_dups",
            "test_to_csv_from_csv_w_some_infs",
            "test_getitem_day",
            "test_max_nan_bug",
            "get_sys_info",
            "test_create_categorical",
            "time_itertuples_raw_tuples_to_list",
            "maybe_dispatch_ufunc_to_dunder_op",
            "__getattr__",
            "test_rolling_consistency",
            "test_stringify_path_pathlib",
            "test_take_bad_bounds_raises",
            "test_get_level_values_int_with_na",
            "test_set_none",
            "test_constructor_tuples_datetimes",
            "test_dt64arr_iadd_timedeltalike_scalar",
            "test_crosstab_margins",
            "test_mod_timedelta64_nat",
            "test_combineFunc",
            "test_read_chunksize_with_index",
            "_holder",
            "test_to_timestamp_pi_nat",
            "test_preserve_on_ordered_ops",
            "test_max_map_len",
            "test_readonly_axis_blosc",
            "test_odict",
            "test_date_range_normalize",
            "npoints",
            "_round_frac",
            "test_merge_left_notempty_right_empty",
            "test_interpolate_corners",
            "test_setitem_always_copy",
            "astype1",
            "test_repr_html_float",
            "time_frame_mask_floats",
            "_create_method",
            "get_attrs",
            "data_missing_for_sorting",
            "test_concat_series",
            "test_loc_getitem_list_with_fail",
            "test_full_file",
            "compare_series_dt_tz",
            "test_non_space_filler",
            "_range_from_fields",
            "test_append_series",
            "test_dti_shift_freqs",
            "test_read_with_parse_dates_invalid_type",
            "test_area_colors",
            "_is_unique",
            "_raw_hex_id",
            "test_binops_pow",
            "float_frame_int_kind",
            "test_comment_default",
            "test_constructor_dict_order_by_values",
            "_na_map",
            "test_update_datetime_tz",
            "test_values_duplicates",
            "test_get_indexer_invalid",
            "test_astype_cast_object_int_fail",
            "test_aggregate_str_func",
            "from_arrays",
            "test_ngroup_mi",
            "test_map_fallthrough",
            "test_comparators",
            "test_where_bug_mixed",
            "test_complex_table",
            "is_iterator",
            "test_tight_layout",
            "test_sort_index_different_sortorder",
            "test_asfreq_near_zero_weekly",
            "test_merge_datatype_error_raises",
            "_validate_skipfooter_arg",
            "test_check_label_or_level_ambiguity_series_axis1_error",
            "test_unstack_preserve_types",
            "has_table",
            "test_compare_scalar",
            "test_union_sort_other_empty_sort",
            "test_offset_n",
            "test_series_set_tz_timestamp",
            "test_shift_months",
            "set_labels",
            "test_clip_mixed_numeric",
            "test_apply_no_name_column_conflict",
            "_get_numeric_engines",
            "test_empty_groups_corner",
            "_resampler_for_grouping",
            "_get_multiindex_indexer",
            "test_constructor_scalar",
            "test_highlight_max",
            "_rolling_window",
            "test_labels_out_of_bound",
            "teardown",
            "test_dropna_tz_aware_datetime",
            "test_df_bool_mul_int",
            "test_pie_df",
            "test_frame_tz_localize",
            "test_non_callable_aggregates",
            "test_with_na_groups",
            "test_pivot_multi_values",
            "test_neq",
            "empty_series",
            "test_Minute",
            "_maybe_convert_to_int_keys",
            "test_apply_with_string_funcs",
            "get_loc_level",
            "test_take_filling_all_nan",
            "_maybe_convert_i8",
            "test_basic_types",
            "test_ndarray",
            "test_hashtable_large_sizehint",
            "is_valid_dtype_n_method",
            "test_set_index_preserve_categorical_dtype",
            "_convert_and_box_cache",
            "lag_plot",
            "test_annually_infer",
            "test_set_categories",
            "test_sort_index_level",
            "test_series_comparison_scalars",
            "test_iloc_array_not_mutating_negative_indices",
            "test_groupby_with_timezone_selection",
            "test_skip_bad_lines",
            "simple_period_range_series",
            "test_constructor_mrecarray",
            "test_order_with_freq",
            "test_dataframe_metadata",
            "test_invalid_delegation",
            "interpolate_2d",
            "_check_ne_builtin_clash",
            "_take_without_fill",
            "test_scatter_matrix_axis",
            "test_column_contains_raises",
            "skip_if_np_lt",
            "test_nans_skipna",
            "test_loc_getitem_duplicates_multiindex_empty_indexer",
            "test_parsers_iso8601_leading_space",
            "test_allow_exact_matches_and_tolerance_forward",
            "test_where_unobserved_categories",
            "test_dti_timestamp_fields",
            "test_skip_sum_object_raises",
            "_cython_transform",
            "__iter__",
            "mask_missing",
            "_repr_fits_vertical_",
            "test_reopen_handle",
            "test_describe_datetime_columns",
            "test_frame_setitem_timestamp",
            "test_warn_bad_lines",
            "test_logical_compat",
            "test_categorical_index",
            "test_difference_sort",
            "test_doesnt_contain_all_the_things",
            "test_loc_index",
            "test_cat_accessor",
            "run_frame",
            "test_dti_sub_int",
            "test_date_parse_failure",
            "test_hash_vs_equality",
            "test_hist_kwargs",
            "test_block_deprecated",
            "_make_stat_function_ddof",
            "test_assert_not_almost_equal_inf",
            "test_where_bug_transposition",
            "test_datetime64_tz_fillna",
            "test_partition_index",
            "_assert_frame_equal",
            "test_set_value_by_index",
            "test_constructor_with_data",
            "time_read_store_table",
            "assert_sp_series_equal",
            "test_regex_replace_series_of_regexes",
            "get_upcast_box",
            "month_roll",
            "test_iloc_getitem_multiple_items",
            "test_tseries_indices_frame",
            "test_value_counts_categorical_not_ordered",
            "select_as_multiple",
            "test_chunks_have_consistent_numerical_type",
            "test_setitem_ambig",
            "test_replace_compiled_regex",
            "test_type_promotion",
            "test_skiprows_by_index_inference",
            "test_nonoverlapping_monotonic",
            "test_to_latex_longtable",
            "test_meta_parameter_not_modified",
            "test_maybe_indices_to_slice_left_edge",
            "test_infer_index_col",
            "time_concat_empty_left",
            "_check_pairwise_moment",
            "test_update_dtype",
            "peakmem_fixed",
            "time_from_pydatetime",
            "test_mul_td64arr",
            "test_td64arr_div_numeric_array",
            "test_invalid_file_buffer_class",
            "test_loc_listlike",
            "test_to_latex_multiindex_names",
            "test_downsample_across_dst_weekly",
            "test_ts_area_lim",
            "test_basic_categorical",
            "new_func_with_deprecation",
            "test_fwf_comment",
            "test_merge_inner_join_empty",
            "test_setitem_dtype_upcast",
            "to_sql",
            "test_custom_comment_char",
            "test_array16",
            "test_apply_numeric_coercion_when_datetime",
            "slice",
            "test_from_spmatrix",
            "delegate_names",
            "test_set_none_nan",
            "time_match",
            "test_period_index_length",
            "test_to_datetime_format_YYYYMMDD_overflow",
            "test_gap_upsample",
            "test_bool_operators_with_nas",
            "_aggregate_series_fast",
            "test_moment_functions_zero_length_pairwise",
            "_binop",
            "test_iteration_preserves_nanoseconds",
            "test_partial_setting",
            "test_round_trip_current",
            "test_try_aggregate_non_existing_column",
            "test_compress_group_combinations",
            "time_itertuples_raw_tuples",
            "test_to_json_period_index",
            "time_endswith",
            "truncate",
            "test_first_last_max_min_on_time_data",
            "test_intelligently_handle_join_key",
            "test_nunique_with_object",
            "test_invalid_origins",
            "test_scikit_learn",
            "test_convert_numeric_uint64_nan",
            "test_query_with_nested_special_character",
            "test_resample_basic",
            "test_isin_level_kwarg",
            "test_apply_transform",
            "test_generate",
            "test_append_concat_tz_dateutil",
            "test_ewma_nan_handling",
            "buffer_put_lines",
            "test_read_sql",
            "test_handle_overlap_arbitrary_key",
            "test_quarterly_infer",
            "_is_boolean",
            "test_reindex_multi_categorical_time",
            "test_plot_outofbounds_datetime",
            "test_setitem_with_unaligned_sparse_value",
            "test_subclass_align_combinations",
            "_is_level_reference",
            "_get_row",
            "test_slice_duplicate_monotonic",
            "test_intersect",
            "take",
            "test_df_use_case",
            "test_indexing_zerodim_np_array",
            "test_dti_cmp_tdi_tzawareness",
            "data_label",
            "test_crosstab_with_empties",
            "test_make_block_boundary",
            "test_where_subset_compare_with_applymap",
            "testFixRaw",
            "test_complex_mixed_table",
            "_format_labels",
            "test_fillna_categorical_raise",
            "time_string_get_loc",
            "_check_op_float",
            "test_pivot_table_nocols",
            "time_itertuples",
            "_nanpercentile_1d",
            "test_get_indexer",
            "test_has_comprehensive_tests",
            "_process_columnlist_subheader",
            "test_blocks_compat_GH9037",
            "consolidate",
            "test_to_datetime_tz_psycopg2",
            "test_numeric_dtypes",
            "test_bad_arg_length_max_value_single",
            "test_dtype_on_categorical_dates",
            "time_isin_few_different",
            "get_keywords",
            "test_to_html_filename",
            "test_immutable",
            "test_ix_multi_take_nonint_index",
            "test_hist_df_coord",
            "tests_empty_df_rolling",
            "parameter_mismatches",
            "test_roundtrip",
            "float_frame_fill2",
            "test_difference_type",
            "test_valid_deprecated",
            "test_constructor_no_data_string_type",
            "to_hierarchical",
            "test_agg_lambda_with_timezone",
            "test_cat_accessor_updates_on_inplace",
            "test_plot_accessor_updates_on_inplace",
            "assert_onOffset",
            "test_query_with_unnamed_multiindex",
            "test_alias_to_unit_raises",
            "test_margin_dropna",
            "test_td64arr_div_tdlike_scalar",
            "test_int_array",
            "is_interval_dtype",
            "test_reindex_method",
            "test_write_variable_label_errors",
            "test_concat_empty_series_dtypes",
            "test_set_levels_codes_names_bad_input",
            "test_construction_from_string_errors",
            "test_categorical_nan_only_columns",
            "result",
            "test_astype_from_categorical",
            "f",
            "test_loc_series",
            "test_set_attribute",
            "test_resample_incompat_freq",
            "test_constructor_series",
            "time_reindex_axis0",
            "test_describe",
            "_make_sorted_values_labels",
            "_take_new_index",
            "test_loc_setitem_frame",
            "test_format_integer_names",
            "test_to_coo_bad_partition_small_union",
            "test_multiindex_unique",
            "_gotitem",
            "test_size_groupby_all_null",
            "test_keys_ignore_hdf_softlink",
            "has_resolvers",
            "test_fwf_for_uint8",
            "interval_range",
            "test_get_group_empty_bins",
            "test_to_dict_invalid_orient",
            "test_td_from_repr_roundtrip",
            "test_list_mixed",
            "test_read_json_table_orient_raises",
            "test_transpose_non_default_axes",
            "indexer_at_time",
            "test_setitem_index_int64",
            "test_empty_groups",
            "_get_colors",
            "test_misc_coverage",
            "test_summary_deprecated",
            "time_read_stata",
            "test_Hour",
            "test_loc_iterable",
            "time_rank_int",
            "test_max_valid",
            "test_ufunc_fallback",
            "test_assert_almost_equal_numbers_with_zeros",
            "test_transpose_tzaware_2col_single_tz",
            "test_assign_dependent_old_python",
            "test_na_values",
            "test_handle_join_key_pass_array",
            "test_apply_broadcast",
            "test_crosstab_with_numpy_size",
            "_sub_datelike",
            "test_utc_box_timestamp_and_localize",
            "time_intersection_one_duplicate",
            "test_constructor_with_dtype",
            "generate_indices",
            "test_lookup_mixed",
            "unpack",
            "test_where_object",
            "isAnchored",
            "test_with_local_timezone_dateutil",
            "test_metadata_propagation_indiv",
            "test_verify_integrity_deprecated",
            "test_tz_setter_raises",
            "assert_stat_op_api",
            "test_ellipsis",
            "test_bool_array",
            "test_merge_nosort",
            "test_day_not_in_month_ignore",
            "test_datetime64formatter_hoursecond",
            "test_series_constructor_with_dtype",
            "_allow_na_ops",
            "test_quarterly_negative_ordinals",
            "test_raw32",
            "test_assert_almost_equal_dict_like_object",
            "test_parr_cmp_pi_mismatched_freq_raises",
            "test_fillna_inplace",
            "index_subclass_makers_generator",
            "_check_bool_result",
            "test_transform_select_columns",
            "test_argmax_axis_invalid",
            "_check_percentile",
            "test_div_zero",
            "test_concat_bug_2972",
            "test_value_counts_preserves_tz",
            "test_resample_bms_2752",
            "test_repr_corner",
            "test_iloc_getitem_list_int",
            "np_datetime64_compat",
            "_process_parse_dates_argument",
            "test_construct_with_different_start_end_string_format",
            "test_import_optional",
            "time_qcut_datetime",
            "visit_Compare",
            "test_array_copy",
            "test_conflicting_excel_engines",
            "_get_sorted_data",
            "missing_metadata",
            "highlight_max",
            "_check_comments",
            "ntemps",
            "test_greater_Raises_Type",
            "test_assert_almost_equal_value_mismatch3",
            "_maybe_make_multi_index_columns",
            "test_append_sorts",
            "test_constructor_period",
            "_na_for_min_count",
            "validate_args",
            "test_combine_first_dt_tz_values",
            "time_frame_nth_any",
            "test_tolerance_tz",
            "getTimeSeriesData",
            "time_dayofweek",
            "test_corr_sanity",
            "test_setitem_fancy_scalar",
            "test_frame",
            "in_ipython_frontend",
            "test_numpy_squeeze",
            "test_skip_initial_space",
            "test_resample_nonexistent_time_bin_edge",
            "test_getitem_setitem_periodindex",
            "test_info_memory",
            "test_getitem_setitem_ix_bool_keyerror",
            "test_maybe_promote_any_with_timedelta64",
            "test_df_div_zero_series_does_not_commute",
            "axisinfo",
            "_convert_datetime_to_stata_type",
            "format_object_attrs",
            "test_rank_modify_inplace",
            "test_index_equal_level_values_mismatch",
            "test_read_chunksize_jagged_names",
            "test_localize_pydatetime_dt_types",
            "time_fillna",
            "test_merge_na_keys",
            "test_extension_array_cross_section_converts",
            "_from_name",
            "test_where_array_like",
            "test_corr_non_numeric",
            "test_constructor_manager_resize",
            "test_frame_datetime64_handling_groupby",
            "test_merge_join_categorical_multiindex",
            "test_scalar_ops_from_sequence_raises",
            "test_construct_with_different_string_format",
            "test_to_csv_multi_index",
            "test_constructor_bool_fill_value",
            "test_index_false_to_json_table",
            "test_getitem_index",
            "test_multiindex_header",
            "test_get_bool_data",
            "test_from_tzaware_object_array",
            "test_where_index_timedelta64",
            "test_timestamp_repr_pre1900",
            "test_index_false_error_to_json",
            "time_is_quarter_start",
            "zero",
            "test_usecols_with_whitespace",
            "test_to_period_tz_warning",
            "test_dataframe_dummies_preserve_categorical_dtype",
            "test_loc_getitem_lowerdim_corner",
            "autocorr",
            "test_backfill",
            "api_doc",
            "resample_method",
            "_any_not_none",
            "testUnsignedInt",
            "_process_page_meta",
            "time_partition",
            "set_testing_mode",
            "_result_type_many",
            "__reduce__",
            "test_bar_log_no_subplots",
            "no_infinitive",
            "test_shift_categorical",
            "test_sparse_int",
            "test_interp_datetime64",
            "from_frame",
            "test_unstack_unused_levels",
            "test_barely_out_of_bounds",
            "test_cast_scalar_to_array",
            "test_bar_align_mid_vmax",
            "test_coercion_with_loc_and_series",
            "test_multiple_date_col_named_index_compat",
            "test_fillna_length_mismatch",
            "_add_legend_handle",
            "time_dt_accessor_time",
            "_get_block_manager_axis",
            "test_frame_on2",
            "test_frame_negate",
            "test_left_join_multi_index",
            "test_groupby_wrong_multi_labels",
            "check_bool_indexer",
            "test_tdi_add_int",
            "test_header_multi_index_common_format1",
            "test_groupby_extension_apply",
            "test_group_var_generic_2d_some_nan",
            "test_3d_fill_nonna",
            "combine_first",
            "unstack",
            "test_bad_min_fname_arg_count",
            "validate_col",
            "asi8",
            "test_query_compare_column_type",
            "test_write_append_mode_raises",
            "test_array_numpy_except",
            "test_dti_add_intarray_no_freq",
            "test_float_max",
            "test_pivot_margins_name_unicode",
            "test_2000",
            "test_custom_na_values",
            "_get_standard_colors",
            "test_series_agg_multikey",
            "test_empty_with_multi_index_pass_dtype",
            "test_frame_getitem_not_sorted2",
            "test_allow_exact_matches_and_tolerance",
            "peakmem_itertuples_raw_start",
            "time_check_concat",
            "_values_for_argsort",
            "test_apply_bad_labels",
            "_union_indexes",
            "difference",
            "test_set_value",
            "test_large_multiindex_error",
            "test_non_unique_idvars",
            "test_query_doesnt_pickup_local",
            "_to_sql_empty",
            "test_list",
            "test_map_type_inference",
            "_str_extract_frame",
            "test_td64arr_add_datetime64_nat",
            "test_integer_array_constructor",
            "test_to_records_dt64",
            "_format_data",
            "test_to_excel_multiindex_dates",
            "iris",
            "test_concatlike_dtypes_coercion",
            "any_string_method",
            "test_partial_set_empty_frame_empty_consistencies",
            "test_to_json_float_index",
            "test_apply_scaler_on_date_time_index_aware_series",
            "test_set_index_period",
            "test_closed_left_corner",
            "test_order_hashes_different",
            "nanall",
            "test_error_with_zero_monthends",
            "_reduce",
            "test_nanstd",
            "test_date_range_timezone_str_argument",
            "create_description",
            "test_setitem_same_but_unordered",
            "test_millisecond_repr",
            "test_loc_getitem_across_dst",
            "_validate_frequency",
            "_execute_create",
            "test_constructor_invariant",
            "visit_Slice",
            "test_intersection_zero_length",
            "drop_table",
            "test_errorbar_asymmetrical",
            "test_forward_by",
            "test_consistency_with_tz_aware_scalar",
            "test_constructor_imaginary",
            "test_arith_series_with_scalar",
            "missing_params",
            "test_fy5253qtr_onoffset_nearest",
            "_list_to_arrays",
            "test_diff_mixed_dtype",
            "test_partial_set_empty_frame_empty_copy_assignment",
            "test_basic",
            "test_series_bin_grouper",
            "test_info_memory_usage",
            "time_f_ordered",
            "time_quantile",
            "time_floor",
            "test_compression_warns_when_decompress_caches_zlib",
            "test_dti_tz_convert_utc_to_local_no_modify",
            "test_rolling_max_resample",
            "method",
            "test_shift_non_empty_array",
            "test_query_None",
            "test_compare_zerodim",
            "test_parr_cmp_pi",
            "test_bar_align_mid_all_neg",
            "test_invalid_file_buffer_mock",
            "test_set_index_datetime",
            "test_cythonized_aggers",
            "test_get_level_number_integer",
            "test_constructor_mismatched_codes_levels",
            "test_numeric_op_scalar",
            "test_array_ufunc_series_defer",
            "_check_roundtrip_table",
            "df_cross_compat",
            "register_extension_dtype",
            "pivot_table",
            "test_get_indexer_backfill",
            "validate_tz_from_dtype",
            "test_encode_numeric_overflow",
            "test_setitem_series_bool",
            "test_argsort_preserve_name",
            "test_detect_console_encoding_fallback_to_default",
            "build_string",
            "columns",
            "test_get_agg_axis",
            "test_no_color_bar",
            "test_shift2",
            "test_guess_datetime_format_invalid_inputs",
            "test_mixed_index_not_contains",
            "test_select_dtypes_datetime_with_tz",
            "test_td_sub_nat",
            "test_fillna_frame",
            "test_read_csv_wrong_num_columns",
            "test_compression",
            "test_bad_deprecate_kwarg",
            "test_isin_nan_not_pypy",
            "test_unstack_to_series",
            "test_scalar_conversion",
            "test_cython_group_transform_algos",
            "test_set_name_methods",
            "test_to_numpy_copy",
            "test_date_format_raises",
            "test_get_rule_month",
            "test_interp_nan_idx",
            "test_sequence_like_with_categorical",
            "time_convert_string_seconds",
            "process_axes",
            "to_timestamp",
            "test_dti_add_int",
            "test_mpl2_color_cycle_str",
            "test_float_truncation",
            "test_ts_plot_with_tz",
            "test_filter_and_transform_with_non_unique_float_index",
            "test_fwf_colspecs_none",
            "test_eof_has_eol",
            "time_slice_step",
            "time_boolean_rows",
            "test_date_nanos",
            "read_sparse_intindex",
            "test_to_sql_append",
            "test_concatlike_common_period_mixed_dt_to_object",
            "test_concat_keys_with_none",
            "test_array_multiindex_raises",
            "test_boolean_context_compat",
            "test_setitem_multiple_partial",
            "test_validate_indices_low",
            "test_concat_different_fill_value",
            "test_get_freq_roundtrip2",
            "test_get_schema_create_table",
            "__floordiv__",
            "test_keyword_arg",
            "_get_period_range_edges",
            "test_td64arr_mod_tdscalar",
            "test_concat_copy",
            "test_rsplit",
            "test_string_index_repr_with_unicode_option",
            "test_datetime_indexing",
            "test_date_query_with_attribute_access",
            "test_truncate_copy",
            "test_concat_NaT_dataframes_all_NaT_axis_0",
            "test_frame_tz_convert",
            "test_to_offset_invalid",
            "test_pad_nan",
            "test_repr_bool_fails",
            "test_select_dtypes_exclude_using_scalars",
            "test_simple_cmp_ops",
            "test_axis_alias",
            "test_datetimeindex_sub_timestamp_overflow",
            "test_frame_dict_constructor_datetime64_1680",
            "test_to_datetime_parse_timezone_malformed",
            "test_constructor_orient",
            "test_pi_comp_period",
            "test_grouper_index_types",
            "test_empty_timeseries_reductions_return_nat",
            "test_assert_almost_equal_object",
            "test_ix_multi_take",
            "test_repr_matches",
            "test_values_multiindex_datetimeindex",
            "test_bar_align_mid_nans",
            "_is_numeric",
            "test_fails_ampersand",
            "test_index_convert_to_datetime_array",
            "test_excel_raise_error_on_multiindex_columns_and_no_index",
            "test_getitem_bool_index_all",
            "test_constructor_overflow_int64",
            "test_setitem_other_callable",
            "test_multiindex_get_loc",
            "_getitem_lowerdim",
            "pack",
            "test_infer_dtype_from_int_scalar",
            "numeric_idx",
            "test_apply_args",
            "has_invalid_return_type",
            "numeric_as_float",
            "assert_datetime_array_equal",
            "test_components",
            "_repr_fits_horizontal_",
            "test_resample_dtype_coerceion",
            "_set_binner",
            "_complevel",
            "test_apply_standard_nonunique",
            "is_term",
            "test_get_dummies_duplicate_columns",
            "test_dti_with_timedelta64_data_deprecation",
            "test_nonzero",
            "test_infer_datetimelike_array_nan_nat_like",
            "test_subplots_multiple_axes",
            "test_pairs",
            "_sanitize_and_check",
            "test_iloc_getitem_slice",
            "test_styler_to_excel",
            "is_datetime_arraylike",
            "test_df_mod_zero_int",
            "test_extract_single_group_returns_frame",
            "series_of_dtype_all_na",
            "test_operators_empty_int_corner",
            "test_select_dtypes_include_using_list_like",
            "test_bad_generic_functions",
            "time_union",
            "test_can_set_locale_invalid_set",
            "visit_BoolOp",
            "test_unique_id",
            "_should_fill",
            "test_partial_set_invalid",
            "assert_label_values",
            "test_css_relative_font_size",
            "test_ffill",
            "test_comparison_with_unknown_scalars",
            "register_converter_cb",
            "test_date_and_index",
            "test_iter_box",
            "ceil",
            "test_parse_dates_column_list",
            "_try_import",
            "test_float64_unit_conversion",
            "nansem",
            "cumcount",
            "test_dt64arr_add_timedeltalike_scalar",
            "_get_indices",
            "test_custom_value_name",
            "test_smallerEqual_Raises_Value",
            "test_grouper_creation_bug",
            "test_rolling_std",
            "test_concat_bug_1719",
            "_assert_where_conversion",
            "test_comment_empty_line",
            "test_hash_array",
            "test_constructor_nanosecond",
            "time_pandas_dtype_invalid",
            "read_html",
            "test_eq",
            "test_from_categorical_dtype_identity",
            "_assert_not_frame_equal",
            "test_asfreq_fill_value",
            "test_encode_string_conversion",
            "test_pi_add_iadd_int",
            "test_concat_empty_and_non_empty_series_regression",
            "test_stack_mixed_levels",
            "test_cast_1d_array_invalid_scalar",
            "test_setitem_mask_aligned",
            "test_read_gbq_with_deprecated_kwargs",
            "test_infer_dtype_datetime",
            "test_interp_bad_method",
            "test_dti_tz_convert_dst",
            "test_plot_scatter",
            "test_set_ops_error_cases",
            "test_properties_minutely",
            "time_join_dataframe_index_multi",
            "test_ordered_api",
            "test_to_timedelta_box_deprecated",
            "_reindex_axis",
            "test_andrews_curves",
            "queryables",
            "test_from_codes_with_dtype_raises",
            "test_findall",
            "test_cdaterange",
            "test_unary_functions",
            "test_drop_duplicates_categorical_non_bool",
            "time_zfill",
            "test_join_segfault",
            "tests_indexing_with_sparse",
            "_clip_with_one_bound",
            "test_duplicate_int_indexing",
            "test_partial_slice_hourly",
            "_write_header",
            "test_nested_flattens",
            "time_interpolate_some_good",
            "test_merge_series",
            "test_equals_op_index_vs_mi_same_length",
            "getMixedTypeDict",
            "test_corr_invalid_method",
            "test_repr_is_valid_construction_code",
            "test_under_specified",
            "test_same_object_is_in",
            "cvalues",
            "_read_bytes",
            "test_reconstruction_index",
            "_check_inplace_setting",
            "time_iloc",
            "_sub_period_array",
            "test_dti_add_sub_nonzero_mth_offset",
            "test_bins_not_overlapping_from_interval_index",
            "test_fillna_iterable_category",
            "test_iteration_preserves_tz",
            "_set_subtyp",
            "test_lower_upper",
            "test_identical_stubnames",
            "test_where_bug",
            "test_valid_month_attributes",
            "tail",
            "get_atom_string",
            "test_astype_bool",
            "_get_ax_layer",
            "test_bool_indexing",
            "test_unit",
            "time_ix",
            "versions_from_parentdir",
            "test_isnull_for_inf_deprecated",
            "test_count_non_nulls",
            "frame_with_period_index",
            "df_cat",
            "test_map_dictlike",
            "test_describe_empty_categorical_column",
            "test_ceil_floor_edge",
            "time_frame_date_formatting",
            "_bins_to_cuts",
            "test_loc_slicing",
            "test_Microsecond",
            "test_resample_string_kwargs",
            "test_range_closed_with_tz_aware_start_end",
            "test_grouped_box_layout",
            "test_to_int_index",
            "test_replace_value_is_none",
            "test_setitem_empty",
            "match",
            "test_groupby_apply_none_first",
            "test_dialect_conflict_except_delimiter",
            "_values",
            "check_result",
            "attrs",
            "test_unique_index_series",
            "test_pass_dtype",
            "_wrap_transformed_output",
            "test_frame_timeseries_to_records",
            "test_cumsum_corner",
            "ohlc",
            "test_intersect_equal_sort",
            "test_as_json_table_type_categorical_dtypes",
            "_sphinx_build",
            "assert_all",
            "test_maybe_infer_to_datetimelike_ser_construct",
            "test_stats_mixed_type",
            "_assert",
            "test_first_last_tz",
            "test_boolean_selection",
            "_maybe_localize_point",
            "test_group_var_constant",
            "test_comment_arg",
            "assert_copy",
            "time_nested_dict_index_columns",
            "is_platform_little_endian",
            "test_import_error_message",
            "test_parr_add_sub_td64_nat",
            "dups",
            "time_add_timedeltas",
            "test_repr_unicode",
            "test_rolling_max_gh6297",
            "time_lookup_ix",
            "test_get_values_deprecated",
            "test_mixed_arithmetic",
            "test_usecols_with_names",
            "test_dti_sub_tdi",
            "_setop",
            "test_gz_lineend",
            "test_count_object",
            "test_rdivmod_offset",
            "test_parametrized_factorize_na_value_default",
            "test_microsecond_repr",
            "test_where_dataframe_col_match",
            "time_different_str_functions",
            "test_set_item_nan",
            "test_to_pydatetime_nonzero_nano",
            "test_numpy_array_equal_unicode",
            "time_to_date",
            "_where",
            "closed",
            "test_tdi_mul_int_array_zerodim",
            "test_resample_to_period_monthly_buglet",
            "peakmem_itertuples_raw_to_list",
            "test_include_na",
            "test_value_counts_period",
            "test_describe_bool_frame",
            "test_constructor_iterator",
            "test_dti_tz_localize_pass_dates_to_utc",
            "test_bar_barwidth_position_int",
            "has_column_names",
            "left_multi",
            "latex",
            "test_rename_signature",
            "test_usage_via_getsizeof",
            "s_whitelist_fixture",
            "test_get_indexer_with_interval",
            "test_constructor_warns",
            "test_multi_index_unnamed",
            "test_td_mul_nat",
            "wrap_arithmetic_op",
            "test_dti_tdi_numeric_ops",
            "is_lexsorted",
            "test_bins_from_interval_index",
            "_clear_item_cache",
            "_add_deprecation_prefixes",
            "test_categorical_series_repr_datetime_ordered",
            "test_convert_objects_leave_decimal_alone",
            "test_an_exception_in_objecthook2",
            "ne_lt_2_6_9",
            "time_join_dataframe_index_single_key_small",
            "test_date_range_negative_freq",
            "dirpath",
            "test_bin8",
            "test_select_with_many_inputs",
            "_construct_dataframe",
            "test_downcast_invalid_cast",
            "test_copy_and_deepcopy",
            "test_groupby_multiindex_tuple",
            "build_components",
            "test_simple",
            "test_union_coverage",
            "test_from_items_deprecation",
            "test_reset_index_drop_errors",
            "test_isna_extension_array",
            "test_equals_numeric",
            "test_to_datetime_parse_tzname_or_tzoffset",
            "test_td64arr_sub_period",
            "test_from_datetime64_freq_changes",
            "test_group_var_generic_2d_all_finite",
            "test_apply_describe_bug",
            "test_astype_mixed_float",
            "test_cached_range_bug",
            "test_update_ctx_flatten_multi_traliing_semi",
            "build_table_schema",
            "time_sort_values",
            "test_repr_no_warning",
            "test_parsers_iso8601_invalid_offset_invalid",
            "__iadd__",
            "test_tdi_mul_float_series",
            "_get_default_locs",
            "test_irreg_hf",
            "_make_comparison_op",
            "time_dayofyear",
            "to_perioddelta",
            "time_normalize",
            "test_dti_construction_univalent",
            "test_equals_operator",
            "test_dataframe_constructor",
            "test_create_index_existing_name",
            "test_rolling_functions_window_non_shrinkage_binary",
            "test_loc_with_scalar",
            "test_mgr_locs",
            "test_is_period_deprecated",
            "_remove_spaces_column_name",
            "cut",
            "test_replace_swapping_bug",
            "ncols",
            "_get_distinct_objs",
            "time_join",
            "test_data_frame_size_after_to_json",
            "test_slice_float64",
            "test_stringify_columns",
            "set_value",
            "is_leap_year",
            "test_parr_cmp_period_scalar2",
            "test_apply_mixed_dtype_corner",
            "test_to_csv_headers",
            "test_multiindex_negative_level",
            "_maybe_to_categorical",
            "test_clip_against_list_like",
            "idx_cols_multi",
            "test_scalar_na_logical_ops_corners",
            "test_to_datetime_utc_true",
            "test_na_trailing_columns",
            "time_query_datetime_column",
            "_is_sub",
            "test_maybe_convert_timedelta",
            "_load_obj",
            "maybe_iterable_to_list",
            "need_slice",
            "test_invalid_compression",
            "test_astype_period",
            "safe_cast",
            "_has_bool_dtype",
            "test_constructor_bool",
            "test_multi_nan_indexing",
            "test_loc_setitem_with_existing_dst",
            "test_mode",
            "_consolidate_key",
            "test_column_format",
            "test_merge_non_unique_index_many_to_many",
            "test_categorical_repr_period",
            "_check_op",
            "test_categorical_dtype_utf16",
            "test_header_and_index_no_types",
            "test_categorical_consistency",
            "test_offset_corner_case",
            "_dir_deletions",
            "test_mangles_multi_index",
            "test_rename_nocopy",
            "_to_sql_method_callable",
            "test_setitem_with_tz",
            "test_format_percentiles",
            "test_minmax_nat_series",
            "test_select_dtypes_duplicate_columns",
            "assert_level_reference",
            "test_strftime",
            "test_int64_overflow_issues",
            "test_single_char_leading_whitespace",
            "single_level_multiindex",
            "test_integer_array_plot",
            "_adjust_to_origin",
            "test_tsplot",
            "time_and",
            "test_fillna_raises",
            "test_overlaps_invalid_type",
            "test_reset_index",
            "_has_complex_internals",
            "forbid_nonstring_types",
            "test_tab_complete_warning",
            "test_dt64arr_add_sub_parr",
            "test_iloc_setitem_int_multiindex_series",
            "test_divmod_offset",
            "test_write_cells_merge_styled",
            "test_quantile_nat",
            "test_read_columns",
            "test_errorbar_scatter",
            "_has_complex_date_col",
            "check_compound_invert_op",
            "test_autocorrelation_plot",
            "test_tzlocal_repr",
            "test_basics_nanos",
            "variable_labels",
            "_make_logical_function",
            "_maybe_check_integrity",
            "test_option_context_scope",
            "returns",
            "test_filter_bytestring",
            "_transform_index",
            "_run_os",
            "test_line_area_stacked",
            "_validate_header_arg",
            "test_subclass_empty_repr",
            "test_set_index_cast_datetimeindex",
            "test_nanops_independent_of_mask_param",
            "test_shift_dst",
            "test_apply_yield_list",
            "test_period_dt64_round_trip",
            "is_numeric",
            "_pop_header_name",
            "downcast",
            "_transaction_test",
            "test_no_right",
            "test_insert_index_float64",
            "test_groupby_extension_no_sort",
            "test_getitem_setitem_integer_slice_keyerrors",
            "test_time_field_bug",
            "test_period_astype_to_timestamp",
            "test_td64arr_sub_offset_array",
            "test_constructor_datetime64arr",
            "writable",
            "_test_data2_zero",
            "test_bool_array_logical",
            "test_append_empty_preserve_name",
            "test_format_percentiles_integer_idx",
            "test_timestamp_to_datetime",
            "test_append_to_multiple_dropna_false",
            "test_constructor_from_index_series_timedelta",
            "test_short_format_converters",
            "test_sort_index_name",
            "test_frame_equal_shape_mismatch",
            "test_to_html_basic_alignment",
            "test_xs_view",
            "select_as_coordinates",
            "test_interval_index",
            "asof_locs",
            "test_info_duplicate_columns",
            "test_hash_tuples",
            "test_bools",
            "test_uint64_factorize",
            "test_period_compat",
            "test_rename",
            "test_compression_utf16_encoding",
            "multiindex_year_month_day_dataframe_random_data",
            "test_detect_chained_assignment",
            "test_where_callable",
            "test_groupby_withnull",
            "get_reindexed_values",
            "test_path_localpath_hdfstore",
            "test_constructor_ndarray_copy",
            "factorize",
            "test_rdiv_zero_compat",
            "transform",
            "test_categorical_index_repr_period",
            "_test_small_strings_no_warn",
            "test_constructor_dict_cast",
            "test_omit_nuisance",
            "method_wo_docstrings",
            "time_drop_duplicates",
            "test_no_pairwise_with_self",
            "time_info",
            "test_replace_categorical",
            "_get_period_bins",
            "test_colaliases",
            "_set_encoding",
            "test_monthly_upsample",
            "_convert_cell",
            "test_sparse_series",
            "_inferred_type_levels",
            "test_constructor_object_dtype",
            "test_to_native_types",
            "andrews_curves",
            "test_join_nonunique",
            "series_of_dtype",
            "test_map_bug_1677",
            "test_categorical_repr_unicode",
            "test_dtype_all_columns",
            "test_expanding_cov",
            "test_groupby_multiindex_not_lexsorted",
            "test_isna_datetime",
            "test_maybe_convert_i8_numeric",
            "test_stat_op_calc",
            "strftime",
            "test_tz_aware_scalar_comparison",
            "test_infer_from_tdi_mismatch",
            "test_align_multiindex",
            "test_usecols_diff_positional_str_columns_order",
            "test_custom_var_and_value_name",
            "test_numpy_dtype",
            "test_datetimetz_dtype",
            "test_n",
            "test_transpose_get_view",
            "test_evenly_divisible_with_no_extra_bins",
            "to_latex",
            "test_million_record_attribute_error",
            "time_read_sql_table_column",
            "time_rfind",
            "test_map_with_non_function_missing_values",
            "test_decode_extreme_numbers",
            "generate_range",
            "test_select_empty_where",
            "test_small_strings_no_warn_blosc",
            "test_scalar_with_index_infer_dtype",
            "test_pi_sub_intlike",
            "test_hide_columns_single_level",
            "test_td64arr_mul_tdlike_scalar_raises",
            "test_clear",
            "test_read_zipped_json",
            "create_tempfile",
            "_add_logical_methods",
            "_fast_union",
            "test_rolling_var",
            "test_comprehensive",
            "test_timestamp_to_datetime_dateutil",
            "test_dataframe_dummies_prefix_dict",
            "_clear_buffer",
            "test_td64arr_add_sub_numeric_arr_invalid",
            "_add_table",
            "test_dti_add_intarray_tick",
            "time_float_int_str_lines",
            "test_td_rsub_nat",
            "read_array",
            "makeDataFrame",
            "test_really_large_in_arr_consistent",
            "test_opening_time",
            "test_grouper_multilevel_freq",
            "test_converters_euro_decimal_format",
            "test_repr_max_rows",
            "test_float_index",
            "test_sparse_reindex",
            "test_dt64arr_add_sub_float",
            "test_drop",
            "test_transform_numeric_ret",
            "test_grouped_box_multiple_axes",
            "test_decimal_rows",
            "update_info",
            "test_rank_first_pct",
            "test_pandas_array_dtype",
            "test_errors",
            "boxplot",
            "test_try_coerce_arg",
            "_is_convertible_to_td",
            "test_constructor_maskedrecarray_dtype",
            "four_level_index_dataframe",
            "color_to_excel",
            "time_asof_nan_single",
            "test_floating_tuples",
            "test_get_set_boolean_different_order",
            "test_dti_time",
            "test_constructor_dtypes_datetime",
            "test_partial_data",
            "test_merge_indexes_and_columns_lefton_righton",
            "_disabled",
            "test_5",
            "test_logical_typeerror_with_non_valid",
            "time_pairwise",
            "format_signature",
            "test_to_excel_unicode_filename",
            "test_overlaps_disjoint",
            "test_map_with_string_constructor",
            "test_values",
            "test_array_basic",
            "test_to_datetime_unparseable_ignore",
            "test_nanstd_roundoff",
            "is_datetimelike_v_numeric",
            "test_transform_length",
            "test_zero_length_input_index",
            "test_mul_index",
            "see_also",
            "test_truediv",
            "test_fillna_fill_other",
            "test_from_values_or_dtype_raises",
            "test_constructor_wrong_precision_raises",
            "test_to_html_multiindex_max_cols",
            "test_frame_datetime64_pre1900_repr",
            "test_margins_dtype",
            "test_iloc_non_integer_raises",
            "is_view",
            "overlaps",
            "column_data_lengths",
            "time_add_overflow_arr_rev",
            "lstrip",
            "test_to_dict_timestamp",
            "test_to_csv_stdout_file",
            "test_time_musec",
            "test_setitem_frame_upcast",
            "_pad_bytes_new",
            "tips_file",
            "test_get_indexer_nearest_decreasing",
            "test_to_datetime_unit",
            "test_is_not_object_type",
            "test_pass_function",
            "_get_frame_op_default_axis",
            "test_nan_str_index",
            "test_period_str_to_code",
            "time_read_json_lines_concat",
            "test_add_sub_timedeltalike_invalid",
            "_validate_format",
            "test_rolling_functions_window_non_shrinkage",
            "test_outer",
            "legend_title",
            "time_transform_multi_key2",
            "test_downcast_conversion_nan",
            "classes",
            "_get_grouper",
            "test_categorical_repr",
            "test_concatlike_same_dtypes",
            "time_series_nth_any",
            "test_regex_replace_scalar_inplace",
            "test_apply_frame_to_series",
            "is_transposed",
            "test_rotation",
            "test_single_backtick_variable_query",
            "pct_change",
            "test_empty_like",
            "test_int_float_union_dtype",
            "test_to_csv_line_terminators",
            "test_constructor_sequence_like",
            "_replot_ax",
            "get_is_dtype_funcs",
            "test_seriesgroupby_observed_apply_dict",
            "test_business_end_year_alias",
            "test_get_nan",
            "test_groupby_nonstring_columns",
            "_repr_latex_",
            "_get_na_values",
            "test_select_iterator_complete_8014",
            "_maybe_add_join_keys",
            "test_setitem_mulit_index",
            "test_dropna",
            "time_multi_int_count",
            "test_comparison_invalid",
            "test_sort_ascending_list",
            "get_utc_offset_hours",
            "time_frame_duplicated_wide",
            "test_dt64arr_sub_timedeltalike_scalar",
            "test_sparse_series_pad_backfill_limit",
            "test_tz_localize_errors_deprecation",
            "get_level_values",
            "test_shift_across_dst",
            "test_take_mixed_type",
            "all_mixed",
            "main",
            "test_path_local_path",
            "test_cython_agg_return_dict",
            "_repr_data_resource_",
            "test_mixed_dtypes_remain_object_array",
            "test_iloc_setitem",
            "time_store_info",
            "_wrap_generic_output",
            "test_groupby_list_infer_array_like",
            "test_frame_empty_mixedtype",
            "test_multi_key_multiple_functions",
            "int_frame",
            "test_constructor_dict_nan_tuple_key",
            "test_to_coo_text_names_integer_row_levels_sort",
            "test_overlaps_nested",
            "tests_skip_nuisance",
            "test_series_describe_multikey",
            "count",
            "test_squeeze",
            "_add_numeric_methods_binary",
            "is_callable",
            "test_is_scalar_builtin_scalars",
            "test_quote_char_basic",
            "test_tz_localize_convert_copy_inplace_mutate",
            "test_bar_center",
            "test_take_fill_value",
            "test_week_of_month_frequency",
            "test_between_time_raises",
            "test_array_like",
            "_create_data",
            "_prefix",
            "time_wrap",
            "test_decode_null_character",
            "test_groupby_level_index_names",
            "test_concat_odered_dict",
            "time_assign_with_setitem",
            "test_no_index",
            "_assert_can_do_op",
            "_get_single_group_name",
            "timedelta64_dtype",
            "test_numeric_arr_mul_tdscalar",
            "test_set_columns",
            "setup_driver",
            "time_series_dot",
            "test_bar_nan",
            "test_sqlite_type_mapping",
            "test_numpy_minmax_datetime64",
            "test_scalar_float",
            "test_nanvar_ddof",
            "test_td64arr_rmul_numeric_array",
            "test_is_boolean",
            "test_foobar",
            "generate_blob",
            "run_transaction",
            "test_gb_key_len_equal_axis_len",
            "test_array_timedelta_floordiv",
            "test_holidays",
            "test_to_timestamp_pi_mult",
            "time_func",
            "test_idxminmax_with_inf",
            "test_setitem_boolean_column",
            "test_union2",
            "test_construction_interval",
            "test_apply",
            "nansum",
            "_get_concat_axis",
            "test_fails_pipe",
            "test_eq_with_self",
            "test_regression_whitelist_methods",
            "test_from_scipy_correct_ordering",
            "test_parse_trim_buffers",
            "_process_columnattributes_subheader",
            "test_union_dataframe_index",
            "test_logical_ops_empty_frame",
            "test_insert_nat",
            "test_fill_value_when_combine_const",
            "_try_coerce_and_cast_result",
            "test_get_calendar",
            "rmul",
            "test_take_warns",
            "test_loc_getitem_label",
            "test_raise_on_passed_int_dtype_with_nas",
            "test_no_new_globals",
            "is_numeric_v_string_like",
            "test_length_zero",
            "test_str_to_bytes_raises",
            "test_usecols_with_parse_dates3",
            "test_insert_index_timedelta64",
            "_grouped_plot_by_column",
            "test_duplicated_with_misspelled_column_name",
            "test_integer_array_constructor_copy",
            "test_freq_setter_errors",
            "test_pct_change_periods_freq",
            "test_np_array_usecols",
            "test_nansum_buglet",
            "test_replace_input_formats_scalar",
            "time_categorical_series_is_monotonic_decreasing",
            "flatten",
            "test_dataframe_from_series",
            "_get_string_slice",
            "test_constructor_index_mismatch",
            "test_decimal_decode_test_precise",
            "test_integer_series_size",
            "nlargest",
            "float_string_frame",
            "test_constructor_regular",
            "test_groupby_multiple_key",
            "data",
            "create_axes",
            "ax",
            "test_date_unit",
            "offset_types",
            "test_non_convertable_values",
            "test_concatlike_common_coerce_to_pandas_object",
            "nested_to_record",
            "time_frame_sort_values",
            "get_values",
            "_write",
            "test_retain_index_attributes2",
            "makeFloatIndex",
            "test_from_records_empty_with_nonempty_fields_gh3682",
            "test_convert_dti_to_series",
            "test_compare_unordered_different_order",
            "apply_broadcast",
            "all_boolean_reductions",
            "test_to_datetime_utc_true_with_series_tzaware_string",
            "test_dtype_equal_strict",
            "get_dtype_kinds",
            "__dir__",
            "test_slice_locs_na_raises",
            "test_with_large_max_level",
            "test_arrmap",
            "freq",
            "deep_nested",
            "test_to_records_floats",
            "time_to_datetime_format_DD_MM_YYYY",
            "test_smallerEqual",
            "_get_info",
            "test_as_blocks",
            "test_read_chunks_117",
            "_assert_series_equal_both",
            "test_from_json_to_json_table_dtypes",
            "test_null_quote_char",
            "step",
            "_filter_special_cases",
            "test_factorized_sort_ordered",
            "_get_axis",
            "check_arbitrary",
            "test_constructor_ordered_dict_conflicting_orders",
            "_reconstruct_object",
            "test_sort_index_level_mixed",
            "test_offset_timedelta64_arg",
            "test_unequal_categorical_comparison_raises_type_error",
            "_construct_axes_from_arguments",
            "test_is_datetime64tz_dtype",
            "test_boxplot_legacy3",
            "test_merge_type",
            "_addsub_int_array",
            "test_constructor_incompat_freq",
            "test_timestamp_and_label",
            "test_out_of_bounds_string",
            "test_iterable_object_and_category",
            "test_argument_types",
            "_generate_4_axes_via_gridspec",
            "getSeriesData",
            "time_min_trivial",
            "_format_native_types",
            "test_resample_timedelta_values",
            "test_series_compression_defaults_to_infer",
            "test_get_chunk_passed_chunksize",
            "_add_datetime_arraylike",
            "get_commit_info",
            "test_empty_with_index_pass_dtype",
            "test_index_label_overlaps_location",
            "test_to_xarray_index_types",
            "time_from_codes_all_int8",
            "_multi_take",
            "test_parr_add_iadd_parr_raises",
            "test_regex_replace_dict_nested",
            "test_merge_right_vs_left",
            "test_dti_slicing",
            "test_misc",
            "test_readonly_axis_zlib",
            "time_dict_with_timestamp_offsets",
            "assert_sp_frame_equal",
            "_apply_to_column_groupbys",
            "legacy_packer",
            "maybe_convert_platform_interval",
            "constructor",
            "test_dti_drop_dont_lose_tz",
            "test_dt_accessor_invalid",
            "_postprocess_for_cut",
            "test_replace_convert",
            "test_drop_by_str_label",
            "_hashed_values",
            "time_pandas_dtype",
            "test_loc_general",
            "test_bins_from_interval_index_doc_example",
            "test_reindex_name_remains",
            "__contains__",
            "test_constructor_timestamp",
            "test_where_invalid_input_multiple",
            "test_getitem_slice",
            "test_group_var_generic_1d_flat_labels",
            "time_getitem_label_slice",
            "test_get_indexer_same_categories_same_order",
            "test_clipboard_copy_tabs_default",
            "_ftype",
            "test_describe_option",
            "formatting_values",
            "test_read_only_source",
            "_side_expander",
            "test_reindex_objects",
            "test_fillna_positive_limit",
            "test_dt64arr_add_timestamp_raises",
            "test_stack_names_and_numbers",
            "test_combine_first_timezone",
            "test_ragged_median",
            "test_mean_mixed_datetime_numeric",
            "test_to_coo_duplicate_index_entries",
            "test_getitem_slice_not_sorted",
            "test_usecols_index_col_conflict2",
            "test_agg_cython_table",
            "test_deferred_with_groupby",
            "test_nat",
            "hash_array",
            "test_time_change_xlim",
            "box_df_fail",
            "is_nested_list_like",
            "test_setitem_frame_invalid_length",
            "test_deprecated_values",
            "test_period_array_readonly_object",
            "test_to_html_multi_indexes_index_false",
            "test_x_string_values_ticks",
            "test_set_index_raise_on_type",
            "time_different_python_functions_multicol",
            "test_roll_convention",
            "test_deprecate_is_copy",
            "time_apply_ref_by_name",
            "test_infer_dtype_from_period",
            "one",
            "index_names",
            "test_holidays_within_dates",
            "test_unicode_column_name",
            "test_resample_rounding",
            "test_fillna_invalid_value",
            "test_contains_nat",
            "test_index_types",
            "dispatch_to_series",
            "time_read_store_mixed",
            "test_comparisons",
            "test_transform_fast",
            "orientation",
            "time_sortlevel_zero",
            "_factorize_array",
            "is_datelike",
            "set_name",
            "_flatten_visible",
            "test_iloc_getitem_bool_diff_len",
            "test_from_records_nones",
            "test_overlapping_columns_error_message",
            "test_dict_numpy_float",
            "__deepcopy__",
            "test_period_array_raises",
            "read_index_node",
            "test_boolean_compare_transpose_tzindex_with_dst",
            "test_tokenize_CR_with_quoting",
            "test_fontsize_set_correctly",
            "test_pivot_with_list_like_values_nans",
            "test_corr_int_and_boolean",
            "test_grouper_column_and_index",
            "test_css_none_absent",
            "test_td_sub_pytimedelta",
            "test_td_sub_td64_nat",
            "test_pickle_compat_0_14_1",
            "time_overflow",
            "as_series",
            "test_is_dict_like_duck_type",
            "time_translate",
            "add_special_arithmetic_methods",
            "test_ngroup_series_matches_frame",
            "test_variable_width_unicode",
            "test_cmov_window_corner",
            "rands_array",
            "test_tshift",
            "test_non_iso_strings_with_tz_offset",
            "test_resample_how",
            "test_boxplot_return_type_legacy",
            "test_secondary_logy",
            "is_number",
            "test_is_level_reference_series_simple_axis0",
            "test_open_args",
            "test_unicode_index",
            "set_uuid",
            "test_dti_with_offset_series",
            "test_unordered_different_categories_raises",
            "_constructor",
            "test_mixed_index_contains",
            "test_init_non_pandas",
            "test_level_preserve_order",
            "test_join_self_unique",
            "_take_with_fill",
            "_get_agg_axis",
            "_chk_truncate",
            "test_duplicated_large",
            "test_mul_int_series",
            "timezone_frame",
            "test_filter_out_all_groups",
            "to_series",
            "test_loc_and_at_with_categorical_index",
            "test_binary_ops_align",
            "test_skew",
            "mismatched_freq",
            "test_dataframe_dummies_prefix_list",
            "test_boundary_integer",
            "test_crosstab_non_aligned",
            "_parse_dtype_strict",
            "nancorr",
            "_check_data",
            "test_no_mode",
            "test_get_level_values_all_na",
            "validate_argsort_with_ascending",
            "_get_single_indexer",
            "test_setitem_loc_scalar_single",
            "time_itertuples_raw_start",
            "_find_valid_index",
            "test_setitem_sequence_broadcasts",
            "sanitize_index",
            "test_deprecated_from_api_types",
            "test_get_indexer_nearest",
            "test_dti_custom_business_repr",
            "test_deprecate_no_docstring",
            "test_assert_almost_equal_iterable_length_mismatch",
            "is_numeric_mixed_type",
            "float_frame_fill2_dense",
            "test_bar_bottom_left",
            "test_assert_extension_array_equal_dtype_mismatch",
            "test_index_false_from_json_to_json",
            "test_frame_double_encoded_labels",
            "test_pi_add_timedeltalike_mismatched_freq_hourly",
            "test_constructor_series_copy",
            "test_slice_integer",
            "test_reconstruct_sort",
            "test_reader_list_skiprows",
            "test_merge_take_missing_values_from_index_of_other_dtype",
            "test_getitem_multiple",
            "_is_builtin_func",
            "test_nested_period_index_subscript_expression",
            "time_to_pydatetime",
            "test_previous_friday",
            "test_rank_na_option",
            "test_to_csv_withcommas",
            "next_monday_or_tuesday",
            "test_comp_nat",
            "time_col_select_lambda_sum",
            "_make_stat_function",
            "test_basic_subset_columns",
            "test_range_slice_day",
            "test_str_cat_categorical",
            "test_boxplot_empty_column",
            "write_to_compressed",
            "time_strip",
            "test_query_by_text_obj",
            "test_fancy_getitem_int_labels",
            "test_operators_corner",
            "_make_wrapper",
            "test_astype_int",
            "read_gbq",
            "test_cache_keys_are_distinct_for_pytz_vs_dateutil",
            "test_caption",
            "test_dtype_with_converters",
            "private_classes",
            "test_all_apply",
            "_setitem_with_indexer",
            "allow_in_pandas",
            "test_describe_percentiles_integer_idx",
            "test_transform_method_name",
            "test_cut_return_intervals",
            "test_signed_downcast",
            "test_read_csv_local",
            "test_stack_mixed_level",
            "test_file_handle",
            "_replace_pandas_items",
            "test_detect_console_encoding_from_stdout_stdin",
            "test_string_io",
            "test_periods",
            "test_set_properties_subset",
            "df_mixed_floats",
            "test_loc_getitem_nested_indexer",
            "test_replace_datetime",
            "test_range_edges",
            "test_to_html_truncate_multi_index",
            "test_rename_errors",
            "test_repr_dtype",
            "_check_text_labels",
            "test_concat_categorical_multi_coercion",
            "test_slicing_datetimes",
            "test_timestamp_compare",
            "test_sort_index",
            "get_offset",
            "test_skipfooter",
            "get_dtypes",
            "get_new_values",
            "test_tz_dtype_matches",
            "test_join_level_corner_case",
            "file_path_to_url",
            "_extract_multi_indexer_columns",
            "test_raise_if_period_index",
            "_process_columnsize_subheader",
            "test_set_dtype_same",
            "test_no_copy_blocks",
            "test_two_backtick_variables_expr",
            "test_dti_business_getitem",
            "test_df_legend_labels",
            "test_to_string_unicode_three",
            "test_categorical_unexpected_categories",
            "test_offset_mul_ndarray",
            "time_division",
            "test_extract_index_one_two_groups",
            "s3_resource",
            "is_indexed",
            "test_index_convert_to_datetime_array_explicit_pytz",
            "parameter_capitalization",
            "test_reader_special_dtypes",
            "test_nansum",
            "test_calendar",
            "test_just_na",
            "test_period_cons_combined",
            "test_fillna_limit_and_value",
            "test_diff_float_n",
            "test_skipinitialspace",
            "test_margins_no_values_two_rows",
            "test_zfill",
            "_do_date_conversions",
            "test_categorical_delegations",
            "test_unsupported_dtype",
            "time_sparse_series_to_coo",
            "test_constructor_corner",
            "unique_nulls_fixture",
            "test_repeat_freqstr",
            "test_set_axis_inplace_axes",
            "test_datetime_with_timezone_roundtrip",
            "test_missing_minp_zero",
            "test_round_frac",
            "recode_for_groupby",
            "test_s3_fails",
            "_get_cacher",
            "_unconvert_string_array",
            "_add_numeric_operations",
            "_get_lbllist",
            "_replace_locals",
            "test__get_dtype_fails",
            "test_format_missing",
            "test_whitespace_regex_separator",
            "test_set_column_scalar_with_ix",
            "_alias_to_class",
            "test_empty_object",
            "_get_empty_meta",
            "_get_new_axes",
            "nkeys",
            "_is_py3_complex_incompat",
            "test_not_hashable",
            "test_astype_with_exclude_string",
            "test_constructor_from_frame_series_freq",
            "test_aggregate_with_nat",
            "test_constructor_dtypes_to_float64",
            "test_td_add_sub_one_day_ten_seconds",
            "test_query_python",
            "test_ufunc_args",
            "time_timedelta_days",
            "test_as_json_table_type_categorical_data",
            "test_axis_dates",
            "test_unordered_ts",
            "test_syntax_error_exprs",
            "test_plot_fails_when_ax_differs_from_figure",
            "test_invalid_kind",
            "test_rank2",
            "test_registered",
            "test_full_file_with_spaces",
            "fillna",
            "test_periods_number_check",
            "test_td_div_nan",
            "test_as_index",
            "test_period_dtype_mismatch",
            "_concat",
            "time_read_csv_cached",
            "test_first_nan_kept",
            "test_homogenize",
            "test_where_with_bool_data",
            "time_plot_andrews_curves",
            "_get_index_names",
            "test_same_ordering",
            "test_none_delimiter",
            "test_non_int_header",
            "test_numpy_ufuncs_other",
            "test_consistency_name",
            "test_transform_absent_categories",
            "test_numeric_conversions",
            "test_operators_combine",
            "nanskew",
            "test_unicode_problem_decoding_as_ascii",
            "test_expanding_consistency",
            "time_frame_nonunique_unequal",
            "test_align_float",
            "test_validate_indices_empty",
            "test_ismethods",
            "testRollback2",
            "test_frequency_is_original",
            "_reorder_for_extension_array_stack",
            "_skip_if_no_akima",
            "test_assert_almost_equal_null",
            "test_encode_time_conversion_dateutil",
            "test_constructor_from_dense_series",
            "test_logical_ops_int_frame",
            "test_intersection_equal_sort_true",
            "test_interp_nonmono_raise",
            "series_and_frame",
            "blank_lines",
            "test_concat_tuple_keys",
            "intersection",
            "test_to_block_index",
            "test_ignore_downcast_neg_to_unsigned",
            "test_pivot",
            "test_td64arr_rfloordiv_tdlike_scalar",
            "test_neg_freq",
            "test_categorical_equal_object_override",
            "test_filter_multi_column_df",
            "test_pivot_table_with_iterator_values",
            "test_drop_and_dropna_caching",
            "init_windows_clipboard",
            "test_where_timedelta_coerce",
            "test_invalid_date_conversion",
            "__rmatmul__",
            "test_dtype_per_column",
            "test_hist_by_no_extra_plots",
            "test_css_side_shorthands",
            "time_add",
            "test_register",
            "test_is_dict_like_passes",
            "mixed_float2",
            "test_nested_object_record_path",
            "test_metadata_immutable",
            "test_td64arr_sub_timestamp_raises",
            "time_full_product",
            "time_asof_single",
            "nanstd",
            "test_take_positive_no_warning",
            "test_attr_expression",
            "test_startswith",
            "test_closed",
            "test_invalid_url",
            "test_tz_convert_and_localize",
            "test_construction_with_mixed",
            "test_shift_gh8083",
            "test_validate_all_ignore_deprecated",
            "test_compat_replace",
            "test_basic_regular",
            "_items_overlap_with_suffix",
            "time_contains",
            "memory_usage",
            "test_map_compat",
            "is_monotonic_decreasing",
            "test_result_type_error",
            "test_ndim",
            "test_encode",
            "test_validate_sum_initial",
            "test_nanmean",
            "_add_comparison_methods",
            "test_corrwith_matches_corrcoef",
            "test_groupby_grouper_f_sanity_checked",
            "test_setitem_ndarray_3d",
            "__round__",
            "test_constructor_field_arrays",
            "time_tz",
            "test_loc_getitem_duplicates_multiindex_non_scalar_type_object",
            "test_nat_methods_nat",
            "test_versioning",
            "test_equals_block_order_different_dtypes",
            "_concat_rangeindex_same_dtype",
            "test_take_raises",
            "is_mixed",
            "test_agg_relabel_with_level",
            "test_get_values_deprecation",
            "test_dense_repr",
            "test_empty_tables",
            "_add_datetimelike_methods",
            "test_int_internal",
            "test_get_numeric_data_preserve_dtype",
            "test_na_values_dict_col_index",
            "test_basic_upsample",
            "fast_xs",
            "test_intersection_empty",
            "test_undefined_func",
            "write_cells",
            "_make_flex_doc",
            "visit_Name",
            "test_execute_fail",
            "test_constructor_dtypes_to_timedelta",
            "test_at_to_fail",
            "two_paragraph_multi_line",
            "zip_frames",
            "testRollforward1",
            "test_index_col_is_true",
            "test_non_ascii_key",
            "test_strange_column_corruption_issue",
            "test_reductions",
            "test_regex_replace_str_to_numeric",
            "test_parsing_different_timezone_offsets",
            "_tag",
            "test_dti_constructor_years_only",
            "test_cross_engine_pa_fp",
            "table",
            "test_unstack_swaplevel_sortlevel",
            "float_frame_dense",
            "test_dict_complex",
            "_convert_for_op",
            "test_from_product_iterator",
            "method_source",
            "test_join_str_datetime",
            "test_timezone_comparaison_bug",
            "test_separating_character",
            "test_set_name_attribute",
            "test_execute_sql",
            "test_partial_set_empty_frame_set_series",
            "get_value_maybe_box",
            "test_inplace_clip",
            "test_valid_tick_attributes",
            "test_from_records_set_index_name",
            "test_same_name_but_underscores",
            "test_get_pad_indexer",
            "test_set_change_dtype_slice",
            "test_tseries_select_index_column",
            "_check_for_invalid_keys",
            "test_replace_input_formats_listlike",
            "test_td_add_timedeltalike_object_dtype_array",
            "time_frame_drop_dups_int",
            "test_insert_column_bug_4032",
            "test_where_tz_values",
            "test_query_string_scalar_variable",
            "get_year_end",
            "test_df_flex_cmp_constant_return_types",
            "construct_1d_ndarray_preserving_na",
            "test_append_dtypes",
            "test_shift_duplicate_columns",
            "test_invalid_table_attrs",
            "test_max",
            "label_info",
            "test_no_dummy_key_names",
            "_preparse",
            "filter",
            "set_version",
            "test_pos_numeric",
            "test_comparison_operators_with_nas",
            "test_astype_nansafe",
            "test_to_records_with_unicode_index",
            "test_td_add_offset",
            "test_len_specialised",
            "test_getitem_with_listlike",
            "test_sparse_frame",
            "test_combine_from_sequence_raises",
            "test_pivot_multi_functions",
            "test_dont_convert_dateutil_utc_to_pytz_utc",
            "test_to_excel_timedelta",
            "test_pivot_index_none",
            "test_constructor_frame_copy",
            "rtruediv",
            "time_constructor",
            "test_constructor_categorical_with_coercion",
            "test_filter_mixed_df",
            "new_func_wrong_docstring",
            "test_timedelta_cut_roundtrip",
            "_get_index",
            "test_empty_prod",
            "get_new_columns",
            "test_astype_categoricaldtype",
            "_to_sql_fail",
            "test_to_csv_list_entries",
            "test_divmod_array",
            "test_max_min_non_numeric",
            "test_to_string_multindex_header",
            "time_nlargest_one_column",
            "test_from_records_columns_not_modified",
            "test_isin_with_i8",
            "test_backend_is_not_module",
            "validate_min_itemsize",
            "test_filter_has_access_to_grouped_cols",
            "assert_interval_array_equal",
            "test_top_level_method",
            "test_grouping_is_iterable",
            "remove_na",
            "test_assert_numpy_array_equal_shape_mismatch",
            "time_join_non_unique_equal",
            "test_divmod_invalid",
            "test_pi_add_timedeltalike_tick_gt1",
            "decode",
            "test_is_dtype_from_name",
            "test_append_to_another",
            "_check_ticks_props",
            "test_nuiscance_columns",
            "test_getitem_multilevel_index_tuple_not_sorted",
            "test_format",
            "test_series_indexing_multiple",
            "start_shift",
            "test_datetime",
            "test_map_dict_subclass_with_missing",
            "test_preserve_categorical_dtype",
            "test_cmp_series_period_series_mixed_freq",
            "test_repr_roundtrip",
            "time_merge_2intkey",
            "test_out_of_range_double",
            "lexsort_depth",
            "test_setitem_with_sparse_value",
            "test_data_after_quote",
            "test_ordered_none_default_deprecated",
            "test_stat_unexpected_keyword",
            "test_groupby_with_timegrouper",
            "test_pi_add_sub_timedeltalike_freq_mismatch_annual",
            "time_max",
            "teardown_class",
            "test_check_compatible_with",
            "test_ewm_consistency",
            "_convert_datetimelike_to_object",
            "test_numeric_arr_rdiv_tdscalar",
            "test_to_csv_bug",
            "test_dti_astype_asobject_tzinfos",
            "test_write_ignoring_index",
            "test_freq_group_match",
            "test_from_categorical_dtype_both",
            "time_shallow_copy",
            "test_to_excel_multiindex_cols",
            "desc_first_letter_lowercase",
            "test_eq_attribute",
            "test_hour",
            "test_select_dtypes_bad_datetime64",
            "test_fast_apply",
            "github_url",
            "test_difference_sort_special",
            "_get_quarterly_rule",
            "_try_convert_types",
            "set_pos",
            "test_stale_cached_series_bug_473",
            "test_empty_na_values_no_default_with_index",
            "time_thousands",
            "_is_mixed_type",
            "_ensure_has_len",
            "test_reindex",
            "test_construction_with_tz_and_tz_aware_dti",
            "test_bad_stream_exception",
            "test_tuple_index",
            "test_no_warning",
            "test_crosstab_unsorted_order",
            "_get_ordinal_range",
            "test_dti_iadd_tdi",
            "test_dti_intersection",
            "test_get_loc2",
            "test_duplicate_raises",
            "test_concat",
            "_get_unstack_items",
            "test_numpy_scalar_complex",
            "rstjinja",
            "test_asobject_deprecated",
            "test_groupby_args",
            "test_iteritems_names",
            "_recode_for_categories",
            "test_axis_classmethods",
            "test_disallow_set_ops",
            "time_concat_series",
            "from_intervals",
            "time_count_level_multi",
            "test_display_dict",
            "good_imports",
            "test_qcut_specify_quantiles",
            "test_na_value_dict",
            "time_expanding",
            "_get_private_key_path",
            "_evaluate_usecols",
            "_set_value",
            "test_fillna_limit_pad",
            "deregister",
            "test_real_imag_deprecated",
            "test_constructor_more",
            "_prepare_pandas",
            "test_intersect_nosort",
            "test_reversed_logical_ops_with_index",
            "makeCustomDataframe",
            "test_nat_methods_raise",
            "test_flex_method_equivalence",
            "test_exit_status_for_validate_all_json",
            "get_mgr_concatenation_plan",
            "test_empty_frame_roundtrip",
            "test_pi_cmp_period",
            "test_getitem_list_of_columns",
            "test_mpl_nopandas",
            "next_workday",
            "test_auto_conversion",
            "test_datetimetz_dtype_mismatch",
            "test_pos_raises",
            "test_errorbar_plot",
            "create_for_block",
            "radd",
            "description",
            "test_maybe_promote_any_with_string",
            "test_encode_hook",
            "test_append_with_timezones_pytz",
            "test_td_mul_nan",
            "_reset_cache",
            "test_td_sub_timedeltalike_object_dtype_array",
            "test_xs_level",
            "test_rjust",
            "get_authors",
            "test_fancy_setitem",
            "test_decode_invalid_array",
            "test_from_codes",
            "test_concat_categorical_tz",
            "_isnan",
            "test_date_parsing",
            "external_values",
            "_safe_dtype_assert",
            "_take_2d_multi_object",
            "test_iterator_with_string_io",
            "test_frame_set_name_single",
            "test_pad_width",
            "test_value_counts_datetime",
            "test_pickle_round_trip",
            "test_rename_axis_supported",
            "test_getitem_setitem_ix_duplicates",
            "test_get_period_range_edges",
            "test_td_rfloordiv_timedeltalike_scalar",
            "test_less_precise",
            "select_coords",
            "test_assert_numpy_array_equal_value_mismatch3",
            "test_dti_tz_conversion_freq",
            "time2num",
            "test_to_datetime_dt64s_out_of_bounds",
            "test_repr_html",
            "test_categorical_with_stata_missing_values",
            "test_dt64tz_series_sub_dtitz",
            "test_concat_axis1",
            "test_conv_read_write",
            "_get_interval_closed_bounds",
            "_axes",
            "test_period_constructor_offsets",
            "test_incorrect_type_array",
            "test_dt64_data_invalid",
            "time_apply_np_mean",
            "test_medium_complex_frame_alignment",
            "test_total_seconds_precision",
            "test_contiguous_boolean_preserve_freq",
            "month",
            "_process_page_metadata",
            "test_agg_cast_results_dtypes",
            "reorder_levels",
            "test_set_index_timezone",
            "test_min_max_series",
            "time_plot_regular_compat",
            "test_update_dtype_string",
            "test_nanosecond_field",
            "test_non_obj_dtype",
            "_obj_with_exclusions",
            "test_assign_bad",
            "test_setting_fill_value_fillna_still_works",
            "test_series_map_box_timedelta",
            "three_group",
            "time_min",
            "test_td64arr_add_str_invalid",
            "test_mask_edge_case_1xN_frame",
            "tz_to_dtype",
            "test_interp_timedelta64",
            "test_query_undefined_local",
            "__pos__",
            "test_series_tz_localize_empty",
            "time_read_sql_table_all",
            "_assert_frame_equal_both",
            "_inner_indexer",
            "data_for_twos",
            "maybe_droplevels",
            "stack_multiple",
            "test_series_getitem_returns_scalar",
            "test_sparse_with_compression",
            "compare_frame_cat_onecol",
            "test_rdiv_zero",
            "test_constructor_dict_order",
            "test_empty_str_methods",
            "test_parsers_quarterly_with_freq_error",
            "round_trip_localpath",
            "test_apply_without_copy",
            "test_downcast_booleans",
            "test_dti_business_getitem_matplotlib_hackaround",
            "test_series_frame_commutativity",
            "test_python_engine",
            "test_secondary_frame",
            "_compare_local_to_utc",
            "set_axis",
            "_rebuild_blknos_and_blklocs",
            "test_astimezone",
            "test_droplevel",
            "time_vector_slice",
            "_ensure_decoded",
            "test_union_sort_other_incomparable_true",
            "test_dti_with_timezone_repr",
            "is_platform_windows",
            "read_json",
            "test_groupby_series_indexed_differently",
            "test_dims",
            "test_infer_dtype_from_complex",
            "test_assign",
            "test_widths",
            "time_concat",
            "_f4",
            "test_header_multi_index_common_format2",
            "_load_iris_view",
            "time_isin_short_series_long_values",
            "_replace_coerce",
            "test_method_delegation",
            "test_fifth_week_of_month",
            "test_rename_multiindex",
            "_multiindex",
            "test_datetimeindex_highprecision",
            "test_greaterEqual_Raises_Value",
            "test_malformed_chunks",
            "test_mode_datetime",
            "test_text_color_threshold",
            "test_comparison_object_array",
            "deprecate_option",
            "bdate_range",
            "test_repr_name_iterable_indexable",
            "test_format_timedelta_ticks_wide",
            "test_converters_corner_with_nans",
            "sum",
            "_is_datelike_mixed_type",
            "testArray",
            "_adorn_subplots",
            "test_invalid_origins_tzinfo",
            "maybe_infer_tz",
            "_make_legend",
            "test_intersect_empty",
            "test_dti_tz_localize_nonexistent_shift_invalid",
            "random_letters",
            "test_dates_invalid_column",
            "test_scalar_integer",
            "test_dt64arr_isub_timedeltalike_scalar",
            "test_encode_recursion_max",
            "test_cython_api2",
            "test_ix_general",
            "test_with_s3_url",
            "test_nonunique_contains",
            "test_get_indexer_methods",
            "test_logical_with_nas",
            "test_from_codes_with_categorical_categories",
            "test_get_year_end",
            "test_concat_single_with_key",
            "time_frame_getitem_single_column_label",
            "test_getitems_slice_multi",
            "test_infer_datetimelike_array_mixed",
            "test_resolves_class_name",
            "test_take_invalid_kwargs",
            "test_rollback",
            "test_assert_numpy_array_equal_value_mismatch1",
            "test_backend_is_correct",
            "test_cached_data",
            "test_no_mlk_before_1986",
            "time_nsmallest",
            "test_to_datetime_out_of_bounds_with_format_arg",
            "test_append_concat_tz",
            "_reindex_indexer",
            "test_fillna_limit_backfill",
            "test_is_datetime64_dtype",
            "test_block_internal",
            "test_background_gradient",
            "test_ragged_sum",
            "test_freq_str",
            "test_join_on_pass_vector",
            "test_line_colors",
            "test_label",
            "str_wrap",
            "any_int_dtype",
            "test_iloc_getitem_labelled_frame",
            "test_indexing_sliced",
            "test_cut_not_1d_arg"
          ],
          "functions_name_co_evolved_modified_file": [
            "time_get_dummies",
            "time_startswith",
            "time_rpartition",
            "time_endswith",
            "time_contains",
            "time_join",
            "time_pad",
            "time_count",
            "time_translate",
            "time_findall",
            "time_encode_decode",
            "time_partition",
            "time_replace",
            "time_rsplit",
            "time_split",
            "time_strip",
            "time_lstrip",
            "time_rstrip",
            "setup",
            "time_match",
            "time_rfind",
            "time_extract",
            "time_find",
            "time_normalize"
          ],
          "functions_name_co_evolved_all_files": [
            "check_funs",
            "check_for_ordered",
            "test_to_records_dict_like",
            "test_truncate_ndots",
            "test_apply_iteration",
            "test_join_on_series_buglet",
            "time_merge_ordered",
            "test_spam_url",
            "test_equality",
            "test_wide_repr_multiindex_cols",
            "test_to_latex_format",
            "test_td64arr_mod_int",
            "test_rank_empty_group",
            "test_set_index_pass_arrays",
            "test_inf_na_values_with_int_index",
            "test_pivot_no_values",
            "test_datetime64tz_aware",
            "select",
            "ordered",
            "test_groupby_bool_aggs",
            "test_long_strings",
            "_handle_lowerdim_multi_index_axis0",
            "_box_func",
            "test_loc_multiindex_missing_label_raises",
            "test_nbytes_integer",
            "test_merge_on_extension_array",
            "test_upsampling_ohlc",
            "_sqlalchemy_type",
            "test_dt64arr_add_sub_DateOffsets",
            "period_index",
            "test_datetime64formatter_yearmonth",
            "test_groupby_with_hier_columns",
            "test_same_len_hash_collisions",
            "test_from_coo",
            "in_interactive_session",
            "test_to_json_compression",
            "test_omit_nuisance_python_multiple",
            "test_format_timedelta_ticks_narrow",
            "_transform_should_cast",
            "_build_xpath_expr",
            "test_interp_unlimited",
            "test_usecols_with_parse_dates2",
            "from_range",
            "test_loc_getitem_label_list",
            "drop_duplicates",
            "test_dti_equals_with_tz",
            "test_numpy_type_funcs",
            "test_match",
            "test_set_index_pass_arrays_duplicate",
            "test_split_blank_string",
            "test_multilevel_name_print",
            "_format_datetime64",
            "test_first_last_tz_multi_column",
            "test_to_csv_from_csv2",
            "test_columns_dtypes",
            "test_set_index_cast",
            "test_comparison_flex_alignment",
            "test_dataframe_constructor_with_dtype",
            "assert_class_equal",
            "_convert_axes",
            "test_name_printing",
            "test_dataframe_dummies_subset",
            "__next__",
            "is_datetime_or_timedelta_dtype",
            "test_setitem_single_column_mixed_datetime",
            "get_sheet_by_index",
            "test_frame_equal_index_mismatch",
            "test_empty_constructor",
            "test_frame_non_unique_index",
            "_infer_types",
            "test_query_with_partially_named_multiindex",
            "test_replace",
            "test_drop_preserve_names",
            "test_rolling_sum",
            "_get_axis_resolvers",
            "test_categorical_conversion",
            "test_numpy_take",
            "test_date_export_formats",
            "test_ragged_max",
            "test_asarray_datetime64",
            "test_iterator2",
            "test_query_with_named_multiindex",
            "test_3",
            "test_failing_subscript_with_name_error",
            "test_union_misc",
            "test_read_with_parse_dates_scalar_non_bool",
            "test_regex_replace_list_to_scalar",
            "test_td64arr_add_sub_float",
            "test_convert_nested",
            "_get_errorbars",
            "_add_series_only_operations",
            "_check_for_default_values",
            "validate_ordered",
            "test_take_allow_fill",
            "test_frame_equal_block_mismatch",
            "test_cmov_window_na_min_periods",
            "test_conversions",
            "test_column_select_via_attr",
            "test_partially_invalid_plot_data",
            "test_str_accessor_no_new_attributes",
            "test_merge_index_singlekey_inner",
            "test_right_outer_join",
            "test_left_outer_join",
            "test_ensure_platform_int",
            "get_series_na",
            "test_parse_dates_implicit_first_col",
            "test_grouper_iter",
            "test_partial_setting_mixed_dtype",
            "sequence_to_dt64ns",
            "test_intersection_non_monotonic_non_unique",
            "mixed_int_frame",
            "test_lookup_nan",
            "test_nan_irregular_index",
            "test_multi_function_flexible_mix",
            "test_frame_to_time_stamp",
            "get_locator",
            "_time_shift",
            "_generate_marginal_results_without_values",
            "header_style",
            "test_encoding_latin1_118",
            "test_constructor_freq_mult",
            "test_tdi_total_seconds",
            "test_set_index_append_to_multiindex",
            "test_copy_name",
            "test_grouper_getting_correct_binner",
            "_read",
            "test_reindex_level",
            "storable",
            "test_reader_dtype",
            "test_read_map_header",
            "test_series_map_box_timestamps",
            "test_at_time_raises",
            "is_dtype",
            "test_boolean_indexing_mixed",
            "_get_object_parser",
            "test_difference_incomparable_true",
            "test_reindex_dtype",
            "test_missing_right_by",
            "_skew_kurt_wrap",
            "argmin",
            "test_interp_limit_bad_direction",
            "test_date_range_int64_overflow_non_recoverable",
            "test_date_range_timestamp_equiv_from_datetime_instance",
            "test_group_selection_cache",
            "ensure_categorical",
            "_get_nearest_indexer",
            "_set_categories",
            "test_complex",
            "test_to_records_with_Mapping_type",
            "test_to_string_without_index",
            "test_complex_series_frame_alignment",
            "get_random_path",
            "tsplot",
            "_typ",
            "test_pi_sub_isub_pi",
            "test_get_loc_closed",
            "time_parse_iso8601_no_tz",
            "test_dataframe_dummies_drop_first_with_na",
            "_replace_nans",
            "clip_lower",
            "time_series_timedeltas",
            "test_set_option_multiple",
            "compat_props",
            "test_nearest",
            "test_resample_with_nat",
            "test_value_counts_normalized",
            "test_extractall_no_matches",
            "test_to_string_line_width",
            "test_get_attr",
            "_load_test1_data",
            "test_constructor_bad_file",
            "test_arith_ops_df_compat",
            "to_feather",
            "test_xs_loc_equality",
            "test_set_value_resize",
            "test_update_from_non_df",
            "pytest_addoption",
            "test_replace_multiple",
            "test_binop_typecasting",
            "str_slice_replace",
            "test_getitem_simple",
            "_parse_errorbars",
            "test_apply_multi_index",
            "test_closed_median_quantile",
            "test_to_string_left_justify_cols",
            "test_astype_str_compat",
            "test_cmov_window_frame",
            "test_take_bounds",
            "_format_datetime64_dateonly",
            "test_filter_single_column_df",
            "_verify_integrity",
            "write_index",
            "test_maybe_promote_datetimetz_with_any_numpy_dtype",
            "_assert_insert_conversion",
            "test_concat_bug_3602",
            "test_nat_ops",
            "test_array_equivalent_compat",
            "test_pct_max_many_rows",
            "test_mixed_index_at_iat_loc_iloc_dataframe",
            "test_invalid_xy_args_dup_cols",
            "test_construction_not_supported",
            "test_add_string",
            "test_sort_nat",
            "test_iloc_getitem_array",
            "_get_opstr",
            "test_td64arr_add_td64_array",
            "test_iso_conversion",
            "test_reset_index_name",
            "test_query_scope",
            "test_apply_out_of_range",
            "test_euro_decimal_format",
            "_write_map",
            "test_fancy_slice_partial",
            "test_getitem_boolean_empty",
            "test_pindex_fieldaccessor_nat",
            "test_dti_date",
            "_get_op_name",
            "test_merge_incompat_infer_boolean_object",
            "time_series_datetimeindex_repr",
            "test_agg_period_index",
            "test_frame_mixedtype_orient",
            "test_cython_with_timestamp_and_nat",
            "test_as_index_series_return_frame",
            "test_join_multi",
            "test_set_levels_categorical",
            "_is_multi_agg_with_relabel",
            "test_mean",
            "test_closed_one_entry_groupby",
            "test_dti_tz_localize_nonexistent_raise_coerce",
            "test_build_table_schema",
            "read_index",
            "test_set_categories_inplace",
            "zip_html",
            "test_where_other",
            "_partial_tup_index",
            "_check_bar_alignment",
            "tz_localize",
            "test_groupby_dtype_inference_empty",
            "from_codes",
            "construct_from_string",
            "test_round_nonunique_categorical",
            "test_warns_non_roundtrippable_names",
            "test_join_append_timedeltas",
            "test_split",
            "test_to_hdf_with_object_column_names",
            "test_get_loc_bad_tolerance_raises",
            "test_identical",
            "nankurt",
            "_make_selectors",
            "test_get_filepath_or_buffer_with_buffer",
            "test_repeat",
            "test_fake_qtconsole_repr_html",
            "time_float_int_lines",
            "is_categorical",
            "test_agg_reduce",
            "_apply_loffset",
            "test_df_arith_2d_array_rowlike_broadcasts",
            "test_sub_delta",
            "test_date_range_out_of_bounds",
            "test_value_counts_bins",
            "_from_selection",
            "test_reindex_positional_warns",
            "test_lines_with_compression",
            "dataframe_with_duplicate_index",
            "is_interval",
            "test_unit_ignore_keeps_name",
            "_get_group_keys",
            "test_hash",
            "test_cython_agg_boolean",
            "test_loc_axis_arguments",
            "sortlevel",
            "test_dti_custom_getitem_matplotlib_hackaround",
            "test_join_index_mixed",
            "dot",
            "_check_parser",
            "test_value_counts_int",
            "test_maybe_indices_to_slice_middle",
            "build_fill",
            "test_str_uses_object",
            "test_rmod_invalid",
            "test_series_tz_convert",
            "test_tdi_sub_dt64_array",
            "_convert_to_indexer",
            "_from_sequence",
            "test_seriesgroupby_name_attr",
            "test_str_bool_series_indexing",
            "_addsub_offset_array",
            "test_at_time_errors",
            "test_read_csv_buglet_4x_multi_index2",
            "test_two_backtick_variables_query",
            "time_on_int",
            "test_contains_dunder",
            "test_pi_comp_period_nat",
            "test_unsorted_index",
            "test_css_to_excel_good_colors",
            "test_multiindex_period_datetime",
            "test_keys",
            "test_default_handler_numpy_unsupported_dtype",
            "_check_promote",
            "test_parse_public_s3_bucket_chunked_python",
            "_evaluate_with_timedelta_like",
            "_read_old_header",
            "test_calendar_roundtrip_issue",
            "test_localized_at_time_between_time",
            "test_matmul",
            "test_is_all_dates",
            "test_timedelta_mode",
            "test_label_overflow",
            "test_hash_collisions",
            "test_basic_downsample",
            "test_append_series_dict",
            "end_time",
            "read_coordinates",
            "test_combine_add",
            "test_to_records_with_multindex",
            "test_groupby_multiindex_missing_pair",
            "test_format_with_name_time_info",
            "test_secondary_bar_frame",
            "test_setitem_invalidates_datetime_index_freq",
            "test_bar_barwidth_position",
            "generate_filter_op",
            "_check_op_integer",
            "test_at",
            "test_resample_to_quarterly",
            "test_store_timezone",
            "test_range_misspecified",
            "test_expanding_func",
            "time_series_categorical",
            "_bool_method_SERIES",
            "test_register_writer",
            "swaplevel",
            "ex",
            "test_info_wide",
            "_format_value",
            "test_add_iadd_timedeltalike_annual",
            "test_bar_align_left_0points",
            "_check_thousands",
            "test_reset_index_range",
            "test_dt64arr_sub_datetime64_not_ns",
            "test_take_na_value_other_decimal",
            "test_to_csv_write_to_open_file",
            "test_is_float_dtype",
            "test_getitem_scalar",
            "_flex_method_SERIES",
            "test_to_string_with_formatters",
            "test_sub_single_tz",
            "time_chained_indexing",
            "test_sort_index_level_and_column_label",
            "test_agg_ser_multi_key",
            "_rows_to_cols",
            "cummin",
            "test_sub_n_gt_1_offsets",
            "test_categorical_concat_append",
            "test_replace_str_to_str_chain",
            "test_frame_setitem",
            "time_reindex_missing",
            "codes",
            "test_constructor_ragged",
            "test_cumcount_mi",
            "test_rw_nthreads",
            "test_if_scatterplot_colorbar_affects_xaxis_visibility",
            "test_concat_sorts_index",
            "test_concat_ignore_index",
            "test_constructor_keyword",
            "test_split_no_pat_with_nonzero_n",
            "test_isna_isnull",
            "df_duplabels",
            "df",
            "test_buffer_rd_bytes",
            "test_dropna_no_nan",
            "test_tz_convert_nat",
            "test_groupby_dict_mapping",
            "_validate_td64_dtype",
            "test_reindex_preserves_name_if_target_is_list_or_ndarray",
            "test_read_hdf_iterator",
            "test_allow_exact_matches_forward",
            "test1_index",
            "test_duplicate_argument",
            "test_replace_mixed_types",
            "_cast_values_for_fillna",
            "test_union_bug_1745",
            "test_subclassed_melt",
            "unconvert",
            "_validate_index_level",
            "test_concat_datetime_timezone",
            "test_extractall_single_group_with_quantifier",
            "test_generic",
            "test_astype_idempotent",
            "test_add_datetimelike_and_dti",
            "on_right",
            "test_getitem_unordered_dup",
            "test_bar_align_mid_axis_none",
            "_align_core",
            "test_str_for_named_is_name",
            "format_date_labels",
            "test_nth_column_order",
            "from_spmatrix",
            "test_corr_callable_method",
            "test_iloc_getitem_neg_int",
            "test_iso_8601_strings_with_different_offsets",
            "test_loc_getitem_dups2",
            "test_date_index_query_with_NaT",
            "test_multiple_header_rows",
            "test_frame_getitem_not_sorted",
            "test_roundtrip_pickle_with_tz",
            "test_na_actions_categorical",
            "test_maybe_promote_float_with_int",
            "test_astype_to_incorrect_datetimelike",
            "check_setitem_lengths",
            "test_categorical_dtype_latin1",
            "test_nanall",
            "test_apply_categorical_with_nan_values",
            "_convert_to_font",
            "test_groupby_level",
            "testStrictUnicodePack",
            "testRollforward2",
            "justify",
            "test_constructor_single_value",
            "_background_gradient",
            "test_eval_resolvers_as_list",
            "test_setslice",
            "test_describe_empty_object",
            "coerce_to_target_dtype",
            "test_css_to_excel_multiple",
            "test_indexing",
            "test_resample_empty_series",
            "test_merge_on_multikey",
            "load_iris_data",
            "var",
            "to_ea_dtypes",
            "test_pivot_with_interval_index",
            "run_binary",
            "_summary",
            "test_index_ctor_infer_periodindex",
            "test_categorical_comparisons",
            "test_index_subclass_constructor_wrong_kwargs",
            "test_join_multi_to_multi",
            "test_partition_to_dataframe",
            "test_to_csv_from_csv_w_all_infs",
            "_process_date_conversion",
            "test_fillna_raise",
            "test_datetime_nan_mask",
            "test_drop_column",
            "_selection_list",
            "_read_value_labels",
            "test_tdarr_div_length_mismatch",
            "build_kwargs",
            "test_nested_dict_construction",
            "test_rank_avg_even_vals",
            "to_period",
            "_process_columntext_subheader",
            "test_whitespace_preservation",
            "_handle_date_column",
            "test_ix_deprecation",
            "test__bn_ok_dtype",
            "test_concat_empty_series_dtypes_roundtrips",
            "test_getslice_tuple",
            "test_put_string_index",
            "test_join_many_non_unique_index",
            "_argminmax_wrap",
            "test_to_string_with_datetime64_monthformatter",
            "test_where_setitem_invalid",
            "_maybe_convert_index",
            "_stop",
            "test_constructor_from_index_series_period",
            "test_consistent_names",
            "test_info_categorical",
            "test_downsample_non_unique",
            "register",
            "test_td64arr_with_offset_series",
            "test_map_with_categorical_series",
            "_check_grid_settings",
            "from_records",
            "test_to_timestamp",
            "test_is_empty",
            "test_quantile_interpolation_dtype",
            "test_interpolate_invalid_nonpositive_limit",
            "_setup_subplots",
            "test_datetime_fractional_seconds",
            "test_td_add_sub_numeric_raises",
            "test_extension_array",
            "test_from_freq_recreate_from_data",
            "double_blank_lines",
            "test_is_numeric_v_string_like",
            "_finalize",
            "test_series_ix_getitem_fancy",
            "decons_group_index",
            "test_read_excel_chunksize",
            "test_setitem_iloc_scalar_multiple_homogoneous",
            "test_compression_blosc",
            "test_replace_aware",
            "test_rank_average_pct",
            "test_ops_properties_basic",
            "test_isAnchored",
            "test_write_bytes",
            "_compute_grand_margin",
            "test_axis_share_x",
            "test_frame_from_records_utc",
            "_from_factorized",
            "test_repr_set",
            "test_resample_base_with_timedeltaindex",
            "test_iterator",
            "test_cython_agg_empty_buckets_nanops",
            "test_empty_field_eof",
            "_args_adjust",
            "_check_comparison_ops",
            "_importers",
            "_get_call_args",
            "test_groupby_as_index_cython",
            "test_usecols_index_col_conflict",
            "test_returned_dtype",
            "test_join_on",
            "test_dt_accessor_api",
            "test_dti_tz_localize_nonexistent_shift",
            "test_select_with_dups",
            "test_tdi_add_timestamp_nat_masking",
            "test_handle_empty_objects",
            "test_new_empty_index",
            "create_index",
            "test_add_offset",
            "count_empty_vals",
            "test_aggfuncs",
            "test_replace_method",
            "test_left_outer_join_bug",
            "test_resample_apply_with_additional_args",
            "test_equals",
            "_reindex_with_indexers",
            "_sanitize_column",
            "wrap_results_for_axis",
            "test_fillna_float64",
            "test_ignore_display_max_colwidth",
            "test_from_arrays_index_series_categorical",
            "interpolate_1d",
            "test_deepcopy_empty",
            "test_astype",
            "test_get",
            "test_multiindex_slicers_edges",
            "test_interpolate_non_ts",
            "test_where_none",
            "_format_header",
            "_make_skipna_wrapper",
            "test_multi_index_naming_not_all_at_beginning",
            "_check_box_return_type",
            "_interpolate_with_fill",
            "test_setitem_na",
            "_is_memory_usage_qualified",
            "test_range_with_millisecond_resolution",
            "test_reader_converters",
            "test_dt_round_tz",
            "test_td64arr_mul_int_series",
            "test_constructor_dict_input",
            "test_dataframe_dummies_prefix_sep_bad_length",
            "test_conv_weekly_legacy",
            "test_subclass_unstack_multi",
            "test_add_series_with_period_index",
            "test_css_absolute_font_size",
            "test_astype_cannot_cast",
            "_reindex_multi",
            "test_reset_index_multiindex_columns",
            "test_float_subtype",
            "offset",
            "_get_binner_for_time",
            "_apply",
            "test_binary_ufunc_with_array",
            "test_loc_name",
            "test_dti_reset_index_round_trip",
            "_formatter_func",
            "_convert_1d",
            "test_parallel_coordinates",
            "test_naive_aware_conflicts",
            "_make_plot_keywords",
            "test_identity",
            "_get_valid_sqlite_name",
            "test_max_bin_len",
            "parametrize_fixture_doc",
            "test_reindex_with_nans",
            "test_constructor_list_of_series_aligned_index",
            "test_decode_pairs_hook",
            "test_to_excel_periodindex",
            "time_write_store_table_wide",
            "_write_table",
            "test_drop_by_str_label_errors_ignore",
            "test_select_dtypes_include_using_scalars",
            "_set_codes",
            "test_intervals",
            "test_to_coo_text_names_integer_row_levels_nosort",
            "test_update_raise_bad_parameter",
            "_write_strls",
            "test_drop_multiindex_not_lexsorted",
            "test_validate_n_error",
            "_ixs",
            "test_table_mixed_dtypes",
            "groupby",
            "test_astype_cast_nan_inf_int",
            "test_from_sequence_dtype",
            "test_parr_cmp_period_scalar",
            "test_replace_list",
            "test_raises_on_usecols_names_mismatch",
            "test_roundtrip_tz_aware_index",
            "test_constructor_ordered_dict_preserve_order",
            "test_td_sub_timedelta64",
            "test_comparison_object_numeric_nas",
            "test_agg_consistency",
            "test_coordinates",
            "test_basic_frame_series_alignment",
            "test_in_numeric_groupby",
            "test_pivot_table",
            "test_offset_freqstr",
            "_create_sql_schema",
            "test_NaT_scalar",
            "_raise_on_incompatible",
            "test_empty_with_multi_index",
            "test_multi",
            "test_dti_tz_localize_roundtrip",
            "remove_categories",
            "maybe_downcast_to_dtype",
            "test_overwrite_warns",
            "test_frame_no_datetime64_dtype",
            "check_cython_extensions",
            "is_integer",
            "_apply_filter",
            "test_allow_exact_matches_and_tolerance2",
            "time_sum",
            "write_result",
            "_list_of_series_to_arrays",
            "test_period_immutable",
            "test_query_builtin",
            "test_bad_url_protocol",
            "test_excel_sep_warning",
            "test_apply_categorical",
            "test_xs_level_series",
            "test_rowspan_at_end_of_row",
            "test_copy_delim_warning",
            "test_dti_shift_localized",
            "test_nonfile_writing",
            "test_corrwith_with_objects",
            "test_numpy_minmax_timedelta64",
            "reindex",
            "test_to_latex_no_header",
            "test_timedelta64_analytics",
            "test_agg_multiple_functions_maintain_order",
            "nanargmin",
            "_write_data",
            "_join_compat",
            "test_items",
            "test_constructor_ordereddict",
            "test_wide_repr_wide_columns",
            "test_join_on_singlekey_list",
            "test_intersection_difference",
            "test_readbytes",
            "_get_dummies_1d",
            "test_merge_all_na_column",
            "test_kind_both_ways",
            "test_allow_exact_matches_and_tolerance3",
            "test_iteration",
            "test_nanosecond_index_access",
            "test_dates_display",
            "test_bar_categorical",
            "test_pickle",
            "test_construct_DataFrame_with_sp_series",
            "test_constructor_simple_new_empty",
            "test_broadcast",
            "test_column_dups_indexing2",
            "test_categorical_concat_preserve",
            "test_concat_same_type_different_freq",
            "test_ceil",
            "test_date_query_with_non_date",
            "test_setitem_datetimelike_with_inference",
            "test_to_csv_with_mix_columns",
            "test_ensure_categorical",
            "assert_frame_equal",
            "test_dups_index",
            "_convert_to_number_format",
            "test_add_prefix_suffix",
            "test_statsmodels",
            "setup_ops",
            "test_area_lim",
            "test_frame_inferred",
            "test_constructor_categorical_dtype",
            "test_timestamp_to_datetime_tzoffset",
            "test_datetime_assignment_with_NaT_and_diff_time_units",
            "_expand_colspan_rowspan",
            "test_copy_names",
            "test_datetime_NaT",
            "test_getitem",
            "test_pivot_table_categorical",
            "test_dtype_and_names_error",
            "test_ufunc",
            "test_constructor_cast_object",
            "test_select_dtypes_include_exclude_using_scalars",
            "_fill_mi_header",
            "is_dict_like",
            "eval",
            "test_factorize_repeated",
            "test_sort_index_and_reconstruction",
            "test_multiple_functions_tuples_and_non_tuples",
            "test_parse_dates_list",
            "test_datetime64tz_fillna_round_issue",
            "test_keyword_as_column_names",
            "check_modulus",
            "test_slice_specialised",
            "test_iloc_getitem_invalid_scalar",
            "test_concat_empty_series",
            "test_applymap_subset",
            "test_apply_bug",
            "test_query",
            "test_to_datetime_errors_ignore_utc_true",
            "test_update_nan",
            "_format_header_mi",
            "test_tz_convert_unsorted",
            "test_rename_set_name",
            "test_transform_with_non_scalar_group",
            "test_resample_as_freq_with_subperiod",
            "test_crosstab_errors",
            "test_where_ordered_differs_rasies",
            "hash_tuple",
            "test_to_numpy_alias",
            "_convert",
            "raw",
            "background_gradient",
            "test_pie_series",
            "test_filter_series",
            "test_dt_namespace_accessor",
            "test_interp_leading_nans",
            "maybe_infer_freq",
            "test_maybe_mangle_lambdas_named",
            "_prep_values",
            "test_rolling_cov_pairwise",
            "test_constructor_Series_copy_bug",
            "test_div_td64arr",
            "test_east_asian_unicode_series",
            "test_read_nokey_table",
            "_trim_excel_header",
            "test_path_pathlib",
            "to_html",
            "_convert_bin_to_datelike_type",
            "test_to_csv_float32_nanrep",
            "test_at_and_iat_get",
            "test_asfreq_near_zero",
            "test_secondary_kde",
            "time_asfreq",
            "test_align_int_fill_bug",
            "test_more_na_comparisons",
            "test_unstack_fill_frame_object",
            "test_rename_inplace",
            "test_frame_iloc_callable_setitem",
            "nanpercentile",
            "test_to_frame_expanddim",
            "test_from_frame_valid_names",
            "time_transform_multi_key4",
            "dates",
            "test_get_complex",
            "_get_level_number",
            "test_to_timestamp_out_of_bounds",
            "test_append_numpy_bug_1681",
            "test_concat_multiindex_dfs_with_deepcopy",
            "test_read_array_header",
            "test_scalar_error",
            "makeTimedeltaIndex",
            "test_round_invalid_arg",
            "start_blank_lines",
            "time_read_csv_dayfirst",
            "test_getitem_int_dtype",
            "test_kde_df",
            "test_options_auto",
            "test_1000_sep",
            "test_to_string_truncate_indices",
            "combine_concat_plans",
            "test_binops_level",
            "test_unsupported",
            "test_loc_setitem_slice",
            "test_parsers_time",
            "test_from_tdi",
            "test_to_string_no_header",
            "_parse_float_vec",
            "test_api_per_dtype",
            "test_merge_left_empty_right_notempty",
            "time_query_store_table",
            "test_default_handler",
            "test_combine_first_align_nan",
            "test_math_floordiv",
            "test_encode_array_of_doubles",
            "test_preserve_metadata",
            "test_rolling_axis_sum",
            "is_datetimelike",
            "time_frame_assign_timeseries_index",
            "test_to_sql_fail",
            "test_from_arrays_index_series_datetimetz",
            "pad",
            "right",
            "to_timedelta",
            "test_construct_timestamp_near_dst",
            "test_asfreq_keep_index_name",
            "peakmem_float",
            "test_to_records_with_unicode_column_names",
            "test_wide_repr_unicode",
            "test_file_url",
            "test_fillna_series",
            "test_concat_categoricalindex",
            "read_msgpack",
            "test_notna_dtype",
            "test_categorical_concat",
            "test_bigint",
            "__neg__",
            "test_set_codes",
            "test_intersection_base",
            "test_multi_thread_path_multipart_read_csv",
            "test_loc_uint64",
            "test_is_dtype",
            "test_arith_mixed",
            "test_corr",
            "test_subplots_timeseries",
            "test_is_scipy_sparse",
            "_aggregate_series_pure_python",
            "test_query_index_with_name",
            "test_to_hdf_errors",
            "test_if_exists",
            "test_rank_apply",
            "_check_mixed_int",
            "get_result",
            "test_tdi_isub_int",
            "_find_non_overlapping_monotonic_bounds",
            "test_align_fill_method",
            "test_already_underscore_variable",
            "test_union_dt_as_obj",
            "test_skiprows_int",
            "test_large_dataframe_indexing",
            "randu",
            "test_resampler_is_iterable",
            "_check_ew",
            "test_unsortable",
            "test_categorical_from_codes",
            "test_read_non_existant",
            "test_freq_name_separation",
            "test_fillna_method_doesnt_change_orig",
            "test_end_time",
            "test_header_multi_index_common_format_malformed2",
            "test_construction_errors",
            "test_columns_multiindex_modified",
            "test_to_period_tz_utc_offset_consistency",
            "test_apply_series_to_frame",
            "test_categorical_equality",
            "_validate_sort_keyword",
            "test_agg_relabel_other_raises",
            "_data_to_frame",
            "test_generic_errors",
            "test_non_monotonic",
            "_get_names",
            "test_diff_timedelta",
            "test_usecols_with_parse_dates4",
            "read_metadata",
            "_validate_key",
            "test_round_trip_exception_",
            "test_value_counts_dup",
            "test_only_one_obj_hook",
            "test_is_unique",
            "test_is_level_or_label_reference_df_simple",
            "test_constructor_categorical_valid",
            "infer_dtype_from_array",
            "test_inplace_ops_alignment",
            "test_pi_sub_pdnat",
            "testPackBytes",
            "test_to_csv_dtnat",
            "test_constructor_mixed_dict_and_Series",
            "test_bool_same_index",
            "test_pindex_multiples",
            "_intersection_unique",
            "test_empty_with_reversed_multi_index",
            "test_hist_legacy",
            "test_time",
            "apply_empty_result",
            "read_multi_index",
            "test_compact_numerical_values",
            "test_contains_nan",
            "_where_numexpr",
            "test_setitem_index_object",
            "test_concat_axis1_different_fill",
            "testPack",
            "test_pprint",
            "_evaluate_standard",
            "test_Second",
            "read_csv",
            "_get_codes_for_sorting",
            "test_perf_min",
            "nonzero",
            "test_constructor_dtypes_timedelta",
            "test_constructor_dict_multiindex",
            "_tick_comp",
            "test_boolean_cmp",
            "test_periodindex",
            "test_cython_right_outer_join",
            "test_from_tuples_with_tuple_label",
            "_trim_zeros_float",
            "add_flex_arithmetic_methods",
            "test_quote_char_various",
            "test_concat_named_keys",
            "test_reindex_frame_add_nat",
            "test_set_axis_inplace",
            "test_xs_corner",
            "test_infs_n_nans",
            "_list_of_dict_to_arrays",
            "test_loc_getitem_bool",
            "onOffset",
            "init_dict",
            "test_numpy_array_complex",
            "test_pivot_periods",
            "test_sum_prod_nanops",
            "test_pi_sub_period_nat",
            "test_replace_mixed_types_with_string",
            "test_copy_blocks",
            "test_axis_aliases",
            "test_groupby_with_timegrouper_methods",
            "test_to_string_format_inf",
            "_check_decimal",
            "str_find",
            "test_groupby_groups_periods",
            "test_excel_table_sheet_by_index",
            "test_astype_datetime64",
            "test_categorical_sorting",
            "test_series_pos",
            "test_asfreq_ts",
            "test_left_join_index_preserve_order",
            "test_get_backfill_indexer",
            "test_int32_overflow",
            "update_kwargs",
            "test_nonzero_base",
            "test_concat_NaT_series",
            "test_describe_categorical",
            "test_decode_big_escape",
            "test_negative_log",
            "test_tdi_cmp_str_invalid",
            "visit_Div",
            "test_join_inner_multiindex",
            "test_assignment_in_query",
            "_close_conn",
            "merge_ordered",
            "test_categorical_repr_period_ordered",
            "assert_array_dicts_equal",
            "test_daily",
            "test_dti_add_tdi",
            "test_append_with_timezones_dateutil",
            "test_append_many",
            "_slice",
            "test_fillna_int",
            "test_group_fill_methods",
            "test_pandas_datareader",
            "_gen_eval_kwargs",
            "test_overlaps_na",
            "test_to_coo_bad_partition_nonnull_intersection",
            "test_concat_columns",
            "test_frame_fillna_limit",
            "test_filter_maintains_ordering",
            "maybe_cythonize",
            "test_to_datetime_other_datetime64_units",
            "read_pickle",
            "test_to_sql_index_label_multiindex",
            "test_repr_with_unicode_data",
            "test_merge_empty_frame",
            "test_slice_to_array_conversion",
            "test_eq_with_str",
            "_format_regular_rows",
            "test_deprecated_numpy_func_call",
            "_needs_reindex_multi",
            "test_both_offset_observance_raises",
            "test_at_fill_value",
            "maybe_upcast_putmask",
            "_search_replace_num_columns",
            "test_css_to_excel_bad_colors",
            "test_delimit_whitespace",
            "test_105",
            "_default_locale_getter",
            "test_difference",
            "test_recreate_from_data",
            "test_not_all_none",
            "test_series_given_mismatched_index_raises",
            "test_to_frame",
            "_dispatch",
            "test_disallow_setting_tz",
            "test_set_frame_overwrite_object",
            "test_standardize_mapping",
            "_datetime_to_stata_elapsed_vec",
            "test_sort_nan",
            "test_stack_timezone_aware_values",
            "test_roundtrip_thru_setitem",
            "test_merge_misspecified",
            "test_color_single_series_list",
            "test_pickle_path_localpath",
            "check_alignment",
            "test_unicode_print",
            "test_df_subplots_patterns_minorticks",
            "test_append_different_columns_types_raises",
            "test_loc",
            "test_index_tab_completion",
            "test_scalar_from_string",
            "test_subclassed_apply",
            "_unconvert_index",
            "test_td64arr_pow_invalid",
            "_get_rename_function",
            "test_quantile_datetime",
            "test_to_html_border",
            "test_parse_all_fields",
            "test_value_counts_categorical_ordered",
            "test_level_with_tuples",
            "_insert_strls",
            "test_unstack_nan_index",
            "test_ewma",
            "test_cov",
            "test_text_color_threshold_raises",
            "_getitem_iterable",
            "test_ngroup_cumcount_pair",
            "construction_error",
            "test_take",
            "test_loc_setitem_consistency_slice_column_len",
            "test_groupby_mean_no_overflow",
            "test_index_mixed_closed",
            "_get_all_lines",
            "test_to_string_float_na_spacing",
            "test_vars_work_with_multiindex",
            "test_to_datetime_format_weeks",
            "test_plot_scatter_with_categorical_data",
            "test_dayfirst",
            "test_fill_corner",
            "update_pr",
            "test_interp_inplace_row",
            "remove_unused_categories",
            "test_different_number_of_cols",
            "test_eng_float_formatter",
            "_sub_datetime_arraylike",
            "test_period_mean",
            "test_tz_localize_errors_coerce",
            "_getitem_nested_tuple",
            "_get_consensus_names",
            "test_pi_ops_array_int",
            "test_td64arr_add_offset_array",
            "test_stack_preserve_categorical_dtype_values",
            "test_agg_callables",
            "df1",
            "test_readjson_chunks_multiple_empty_lines",
            "test_constructor_categorical_string",
            "_format_header_regular",
            "run_cmd",
            "test_corrwith_series",
            "local_name",
            "test_aggregate_api_consistency",
            "nargsort",
            "test_unstack_group_index_overflow",
            "_get_repr",
            "_get_root",
            "test_info_memory_usage_deep_pypy",
            "test_loc_setitem_consistency",
            "test_swapcase",
            "test_constructor_list_str",
            "test_add_different_nans",
            "test_can_hold_identifiers",
            "test_left_join_index_multi_match_multiindex",
            "time_iteritems",
            "test_diff_datetime_axis0",
            "assert_timedelta_array_equal",
            "test_arith_flex_frame_mixed",
            "test_raises_attribute_error",
            "assert_raises_regex",
            "df_compat",
            "test_setitem_chained_no_consolidate",
            "get_slice",
            "test_merge_nocopy",
            "__invert__",
            "_write_variable_types",
            "right_multi",
            "test_nearest_by",
            "pprint_hits",
            "test_radviz",
            "test_frame_info_encoding",
            "test_unpack_ext_type",
            "test_outer_join_indexer",
            "test_astype_column_metadata",
            "test_read_missing_key_close_store",
            "test_date_range_timestamp_equiv",
            "_from_categorical_dtype",
            "test_if_hexbin_xaxis_label_is_visible",
            "test_concat_period_other_series",
            "test_retain_index_attributes",
            "test_pass_args_kwargs",
            "test_usecols_name_length_conflict",
            "build_font",
            "_non_reducing_slice",
            "test_no_keep_default_na_dict_na_values",
            "test_single_vars_work_with_multiindex",
            "test_value_vars_types",
            "test_take_filling_fill_value",
            "test_categorical_category_dtype",
            "_convert_grouper",
            "test_logical_ops_label_based",
            "test_banklist",
            "test_pos_object",
            "test_is_bool",
            "is_bool_dtype",
            "test_consistency",
            "_coerce_method",
            "test_monotonic_on",
            "test_join_on_fails_with_different_column_counts",
            "test_get_timestamp_range_edges",
            "test_numeric_like_ops",
            "test_nancorr_pearson",
            "test_array_not_registered",
            "time_multi_int_nunique",
            "test_fillna_mixed_float",
            "_format_hierarchical_rows",
            "test_to_html_multiindex_index_false",
            "test_typ",
            "make_empty",
            "test_on_float",
            "_upsample_others",
            "test_repr_truncation_column_size",
            "has_info_repr",
            "test_decode_hook",
            "set",
            "test_multi_func",
            "test_to_string_index_formatter",
            "set_atom",
            "backtick_quote_name_with_no_spaces",
            "test_read_writer_table",
            "test_readjson_invalid_chunksize",
            "test_reindex_boolean",
            "test_notna_notnull",
            "test_apply_datetimetz",
            "test_rank_methods_series",
            "test_complex_across_dimensions_fixed",
            "test_loc_getitem",
            "test_mutate_groups",
            "test_append_concat_tz_explicit_pytz",
            "test_line_comment",
            "test_frame_timeseries_column",
            "test_getitem_boolean",
            "test_convert_pandas_type_to_json_field_datetime",
            "test_sortlevel_not_sort_remaining",
            "test_other_dtypes_for_array",
            "test_basic_no_by",
            "test_frame_setitem_copy_no_write",
            "test_create_and_drop_table",
            "test_constructor_dtypes_to_categorical",
            "_write_value_labels",
            "test_set_levels",
            "test_iloc_setitem_with_scalar_index",
            "test_append_same_columns_type",
            "_convert_to_line_delimits",
            "test_append_to_multiple",
            "test_dt64_mean",
            "test_pi_add_sub_timedeltalike_freq_mismatch_daily",
            "test_getitem_slice_fill_value",
            "test_index",
            "test_catch_oob",
            "test_min_max_categorical",
            "_get_column_repeat",
            "test_value_counts_inferred",
            "test_categorical_nan_equality",
            "test_dropna_multiple_axes",
            "test_categorical_repr_timedelta_ordered",
            "test_agg_namedtuple",
            "test_fillna_datelike",
            "test_to_excel_multiindex",
            "test_to_html_with_classes",
            "test_dtypes",
            "test_asfreq",
            "test_fixed_offset_tz",
            "test_sparsea_max_row_truncated",
            "test_constructor_nan",
            "test_searchsorted",
            "test_read_csv_dataframe",
            "cd_and_set_engine",
            "test_shift_nat",
            "test_where_other_categorical",
            "test_corr_kendall",
            "new_func",
            "test_categorical_dtype_chunksize_infer_categories",
            "_create_sp_series",
            "_arr_to_str",
            "_maybe_cast_indexed",
            "test_encode_decode",
            "test_rolling_min",
            "test_read_dta2",
            "nearest",
            "test_integer_thousands",
            "test_pie_df_nan",
            "ftype",
            "isin",
            "_prepare_data",
            "tz_replacer",
            "test_td64arr_mul_too_short_raises",
            "_make_parser_function",
            "test_loc_setitem_frame_multiples",
            "test_resample_weekly_all_na",
            "hist_series",
            "test_reindex_nan",
            "test_bar_align_zero_pos_and_neg",
            "test_upsample_with_limit",
            "_codes_to_ints",
            "test_gold_canyon",
            "test_ragged_mean",
            "_from_derivatives",
            "test_pass_TimedeltaIndex_to_index",
            "_make_field_arrays",
            "test_apply_none",
            "test_setitem_datetime_coercion",
            "test_repr_min_rows",
            "biggie_df_fixture",
            "_validate_usecols_arg",
            "test_mangled",
            "test_str_attribute_raises",
            "test_read_from_file_url",
            "test_fwf_thousands",
            "test_to_string_int_formatting",
            "test_expand_user_normal_path",
            "test_loc_setitem_consistency_empty",
            "test_only_1dim_accepted",
            "test_column_in",
            "_validate_read_indexer",
            "test_wrap",
            "test_to_datetime_infer_datetime_format_series_with_nans",
            "test_skiprows_slice_short",
            "test_construction_with_alt_tz_localize",
            "test_dti_convert_tz_aware_datetime_datetime",
            "_maybe_mask_result",
            "_add_nat",
            "convert_to_index_sliceable",
            "time_large_get_loc_warm",
            "disallow",
            "test_donot_drop_nonevalues",
            "test_date_range_timestamp_equiv_dateutil",
            "test_dti_constructor_static_tzinfo",
            "test_diff_datetime_axis1",
            "test_normalize_nat",
            "test_to_string_float_format",
            "test_agg_structs_dataframe",
            "test_getitem_setitem_fancy_exceptions",
            "test_pickle_preserve_name",
            "cov",
            "create_index_with_nan",
            "test_parse_date_time_multi_level_column_name",
            "test_maybe_promote_any_with_datetime64",
            "test_getitem_ix_mixed_integer",
            "test_parse_dates_custom_euro_format",
            "test_mul_float_series",
            "test_isin_df_dupe_values",
            "_have_mixed_levels",
            "_maybe_coerce_merge_keys",
            "test_usecols_list",
            "test_index_resolvers_come_after_columns_with_the_same_name",
            "test_union_categoricals_empty",
            "test_float_scalar",
            "_check_engine",
            "time_floats_with_int_idex_lines",
            "_check_timedeltalike_freq_compat",
            "test_dataframe_dtypes",
            "test_excelwriter_fspath",
            "time_merge_cat",
            "test_unsortedindex_doc_examples",
            "test_to_html_with_col_space_units",
            "test_start_stop_multiple",
            "ljust",
            "test_replace_with_empty_dictlike",
            "_write_hierarchical_rows",
            "test_no_header",
            "_formatter",
            "test_set_group_name",
            "test_select_dtypes_bad_arg_raises",
            "test_is_numeric_dtype",
            "test_apply_with_mixed_types",
            "str_index",
            "test_dropna_categorical_interval_index",
            "test_sum_nanops_timedelta",
            "test_to_datetime_box_deprecated",
            "test_datetime_units",
            "test_constructor_infer_period",
            "time_copy_function_multi_col",
            "test_dtype_conversion",
            "invert",
            "test_union_categorical_same_categories_different_order",
            "test_frame_column_inplace_sort_exception",
            "_get_cython_table_params",
            "is_string_dtype",
            "test_constructor_with_naive_string_and_datetimetz_dtype",
            "_simple_ts",
            "test_overwrite_node",
            "test_consolidate_ordering_issues",
            "test_reindex_single_named_indexer",
            "series_generator",
            "test_date_format_frame",
            "test_where_error",
            "validate_inferred_freq",
            "test_values_lcd",
            "iget",
            "test_pi_offset_errors",
            "test_merge_incompat_dtypes_error",
            "test_rmod_timedelta64",
            "test_constructor_dict_order_insertion",
            "test_implicit_label",
            "str_contains",
            "test_print_none_width",
            "test_frame_setitem_multi_column",
            "test_assignment",
            "test_hypothesis_delimited_date",
            "_get_dtypes",
            "test_to_latex_specified_header",
            "test_mod_invalid",
            "_maybe_to_dense",
            "test_objarr_add_str",
            "test_header_multi_index",
            "test_cummin_datetime64",
            "test_select_bad_cols",
            "test_exit_status_errors_for_validate_all",
            "test_indicator",
            "_highlight_extrema",
            "test_escaped_table_name",
            "test_concat_sparse_dense_cols",
            "join",
            "test_crossed_dtypes_weird_corner",
            "write_metadata",
            "test_missing_raises",
            "is_exists",
            "test_add_integer",
            "test_extractall_same_as_extract",
            "_combine_series_frame",
            "test_apply_chunk_view",
            "maybe_expression",
            "test_iloc_getitem_int",
            "date_format",
            "test_add_offset_nat",
            "test_grouping_ndarray",
            "test_series_with_dtype",
            "test_maybe_promote_any_with_bool",
            "test_is_full",
            "test_str_vs_repr",
            "test_importcheck_thread_safety",
            "test_categorical_margins",
            "test_categorical_preserves_tz",
            "test_tz_dtype_mismatch_raises",
            "test_arith_flex_frame",
            "test_shift_dtype",
            "test_assert_numpy_array_equal_value_mismatch6",
            "test_multiindex_column_lookup",
            "_delegate_property_set",
            "_assert_setitem_index_conversion",
            "test_categorical_with_nan_consistency",
            "_apply_meta",
            "test_float_array_comparison",
            "test_properties_hourly",
            "test_groupby_level_no_obs",
            "test_replace_series_no_regex",
            "test_concat_tz_frame",
            "test_duplicated_drop_duplicates",
            "write_block_index",
            "test_is_leap_year",
            "_expand_elements",
            "test_td_floordiv_timedeltalike_array",
            "test_error_on_using_partition_cols_and_partition_on",
            "construct_array_type",
            "test_divmod_numeric",
            "test_get_indexer_strings",
            "test_constructor_ndarray",
            "test_ix_multiindex_missing_label_raises",
            "time_chained_cmp",
            "test_hist_kde",
            "test_path_path_lib",
            "test_validate_bool_args",
            "test_getitem_get",
            "_get_vars",
            "test_arith_getitem_commute",
            "test_basic_drop_first_one_level",
            "test_from_pandas_array",
            "test_intersect_identical",
            "test_multi_assign",
            "test_merge_on_ints_floats_warning",
            "validate_attr",
            "test_take_fill_value_datetime",
            "test_equals_different_blocks",
            "test_observed_groups",
            "nanmean",
            "test_fy5253_last_onoffset",
            "return_type",
            "test_get_loc_interval",
            "test_astype_unicode",
            "test_interp_multiIndex",
            "_check_stat_op",
            "new_func_no_docstring",
            "_validate_integer",
            "test_finder_daily",
            "test_from_product_empty_two_levels",
            "test_sub_object",
            "_get_objs_combined_axis",
            "test_dti_sub_offset_index",
            "test_from_product_datetimeindex",
            "test_partition_cols_supported",
            "detect_console_encoding",
            "rmod",
            "test_loc_getitem_int",
            "test_from_records_tuples_generator",
            "_check_ndim",
            "__nonzero__",
            "test_table",
            "test_apply_series_on_date_time_index_aware_series",
            "test_interpolate",
            "_concat_index_asobject",
            "_doc_parms",
            "test_constructor_with_timedelta_window",
            "test_to_html_truncate",
            "test_isin_level_kwarg_bad_level_raises",
            "test_apply_with_args_kwds",
            "test_series_getitem_corner_generator",
            "test_to_basic",
            "test_other_datetime_unit",
            "test_woy_boundary",
            "_get_column_name_list",
            "test_take_empty",
            "test_partition_series",
            "test_xarray",
            "test_hash_error",
            "atomize",
            "test_timedelta64_conversions",
            "test_multiindex_roundtrip",
            "needs_i8_conversion",
            "test_default_color_cycle",
            "_unstack",
            "test_addition_subtraction_types",
            "test_cummin_timedelta64",
            "test_to_latex_escape",
            "test_compression_roundtrip",
            "test_resample_size",
            "__array__",
            "make_block",
            "test_read_dta3",
            "test_difference_identity",
            "timedelta_index",
            "test_order_of_appearance",
            "test_to_html",
            "test_timedelta64_equal_timedelta_supported_ops",
            "build_alignment",
            "test_apply_series_yield_constant",
            "test_to_latex_multiindex_nans",
            "test_parallel",
            "test_to_datetime_unprocessable_input",
            "test_arg_passthru",
            "test_td64arr_sub_NaT",
            "dispatch_to_extension_op",
            "test_skiprows_infield_quote",
            "test_methods",
            "test_conv_business",
            "test_reindex_nearest",
            "wide_multi_index",
            "test_tdi_addsub_integer_array_no_freq",
            "test_utc_z_designator",
            "time_read_uint64_na_values",
            "test_numpy_reduction",
            "test_options_py",
            "test_secondary_bar",
            "test_constructor_from_unknown_type",
            "test_unexpected_kwargs_raises",
            "test_raises_for_invalid_attribute_name",
            "test_labels",
            "intframe",
            "test_table_values_dtypes_roundtrip",
            "render",
            "test_objects",
            "test_reindex_axes",
            "test_accessor_works",
            "test_xcompat",
            "has_horizontally_truncated_repr",
            "_add_datetimelike_scalar",
            "test_skiprows_set",
            "test_nunique_with_empty_series",
            "test_comparison_different_length",
            "_select_options",
            "test_dataframe_dummies_prefix_bad_length",
            "test_series_plot_color_kwargs",
            "test_is_string_like_dtype",
            "test_where",
            "test_from_records_misc_brokenness",
            "test_select_columns_in_where",
            "test_read_excel_nrows_greater_than_nrows_in_file",
            "test_round_dst_border_nonexistent",
            "test_getname_categorical_accessor",
            "test_unstack_categorical",
            "test_fillna_mixed_type",
            "set_atom_complex",
            "test_is_integer",
            "test_int_df",
            "test_constructor_freq_combined",
            "_harmonize_columns",
            "read_feather",
            "test_mangle_series_groupby",
            "test_interp_limit_to_ends",
            "test_map_with_tuples_mi",
            "test_productsales",
            "test_transform_dtype",
            "test_timedelta_ops",
            "test_method_on_bytes",
            "_add_delta_tdi",
            "_parse",
            "_define_paths",
            "test_join_unconsolidated",
            "test_float_precision_round_trip_with_text",
            "_get_numeric_data",
            "test_mul_datelike_raises",
            "assert_numpy_array_equal",
            "_managle_lambda_list",
            "test_single_line",
            "nanargmax",
            "test_merge_common",
            "array",
            "test_bar_align_mid_pos_and_neg",
            "_create_dtype_data",
            "test_setitem_expand_columns",
            "_check_colors",
            "test_conv_secondly",
            "test_put_mixed_type",
            "test_getitem_list_duplicates",
            "test_rw_use_threads",
            "test_bar_align_zero_nans",
            "test_not_equals_object",
            "mixed_float",
            "_compute_plot_data",
            "_get_metadata_path",
            "test_option_no_warning",
            "test_reorder_categories",
            "test_filter_enforces_scalarness",
            "add_categories",
            "test_concat_multiple_frames_dtypes",
            "test_extension_type",
            "test_to_html_multiindex_sparsify",
            "test_div_equiv_binop",
            "_check_columns",
            "test_construction_index_with_mixed_timezones_with_NaT",
            "test_direct_arith_with_series_returns_not_implemented",
            "test_constructor_string",
            "test_unordered_compare_equal",
            "test_string_categorical_index_repr",
            "time_read_special_date",
            "test_convert",
            "test_deprecate_order",
            "get_indexer_non_unique",
            "test_boxplot_vertical",
            "idx_dup",
            "check_ops_properties",
            "test_to_csv_moar",
            "examples",
            "test_where_complex",
            "_is_sup",
            "_parse_thead_tbody_tfoot",
            "test_cast_on_putmask",
            "test_sort_values_frame",
            "_unstack_multiple",
            "test_replace_series",
            "test_td64arr_add_sub_numeric_scalar_invalid",
            "makeMissingCustomDataframe",
            "_try_aggregate_string_function",
            "test_rename_axis_inplace",
            "test_subplots_sharex_axes_existing_axes",
            "test_setitem_clears_freq",
            "test_lookup_bool",
            "fp",
            "test_astype_categorical_to_categorical",
            "test_iloc_slice_fill_value",
            "test_mode_intoverflow",
            "test_options_get_engine",
            "test_is_extension_type",
            "test_getitem_setitem_float_labels",
            "_create_comparison_method",
            "mixed_float_frame",
            "test_nbytes",
            "time_read_store",
            "prod",
            "test_get_loc_single_level",
            "test_parse_public_s3_bucket_python",
            "_highlight_null",
            "test_infer_objects",
            "test_at_time_between_time_datetimeindex",
            "test_properties_secondly",
            "_groups_or_na_fun",
            "test_valid_join_keys",
            "test_index_equal_values_too_far",
            "test_value_counts_datetime64",
            "maybe_set_size",
            "test_as_json_table_type_date_data",
            "test_nanmin",
            "test_dti_tz_localize_ambiguous_times",
            "test_comp_ops_df_compat",
            "crosstab",
            "read_hdf",
            "test_margins_no_values_two_row_two_cols",
            "test_series_broadcasting",
            "test_dates",
            "_create_arithmetic_method",
            "test_loc_multiindex_indexer_none",
            "test_excel_sheet_size",
            "test_dropna_intervals",
            "test_apply_corner",
            "test_timezone_comparaison_assert",
            "test_nancorr_kendall",
            "test_constructor_name",
            "test_nbytes_block",
            "item",
            "test_deprecate_wrong_docstring",
            "test_nyse_wsj_commas_table",
            "test_join_dups",
            "test_constructor_empty_with_string_dtype",
            "test_interp_all_good",
            "test_parse_failure_unseekable",
            "test_pi_sub_isub_timedeltalike_hourly",
            "clip",
            "month_position_check",
            "test_copy_from_callable_insertion_method",
            "test_timestamp_timetz_equivalent_with_datetime_tz",
            "test_get_label_or_level_values_df_duplabels",
            "test_is_mixed_dtype",
            "test_invalid_double_precision",
            "test_slice_locs_indexerror",
            "test_transform_datetime_to_timedelta",
            "test_unpack_buffer",
            "test_divmod_series",
            "config_prefix",
            "test_bfill",
            "test_agg_timezone_round_trip",
            "test_isna_lists",
            "test_fspath",
            "test_logical_ops_df_compat",
            "test_rename_by_series",
            "_unpickle_series_compat",
            "_from_ordinal",
            "test_repr_large",
            "_asof_function",
            "test_series_index_name",
            "test_rolling",
            "test_merge_categorical",
            "test_more_flexible_frame_multi_function",
            "test_join_with_period_index",
            "get",
            "set_atom_timedelta64",
            "test_with_tz",
            "test_construction_with_categorical_index",
            "_badobj_wrap",
            "parse",
            "_should_parse_dates",
            "_use_inf_as_na",
            "has_vertically_truncated_repr",
            "test_rolling_axis_count",
            "_has_infs",
            "test_take_fill_value_with_timezone",
            "_in_travis_environment",
            "_from_sequence_of_strings",
            "test_empty_lines",
            "test_date_time",
            "test_diff",
            "test_nanosecond_timestamp",
            "_to_sql",
            "test_date_range_timestamp_equiv_explicit_pytz",
            "test_read_dta18",
            "test_line_area_nan_df",
            "test_database_uri_string",
            "radviz",
            "test_astype_with_tz",
            "validate_periods",
            "test_combineSeries",
            "test_excel_multiindex_index",
            "test_error",
            "_convert_tuple",
            "categorical_index",
            "_has_valid_positional_setitem_indexer",
            "test_append_missing_column_proper_upcast",
            "test_divmod",
            "test_api_per_method",
            "test_get_indexer_non_unique",
            "time_add_overflow_b_mask_nan",
            "test_dti_add_series",
            "test_index_equal_values_close",
            "test_fillna_downcast",
            "test__isfinite",
            "_check_plot_works",
            "_delegate_property_get",
            "as_ordered",
            "get_names_from_index",
            "test_ix_weird_slicing",
            "test_resample_anchored_monthstart",
            "test_tuples_have_na",
            "test_arg_for_errors_in_astype",
            "test_put_compression_blosc",
            "test_isin_multiIndex",
            "reindex_like",
            "test_resample_nunique_preserves_column_level_names",
            "test_not_string",
            "test_skip_row_with_quote",
            "test_handle_dict_return_value",
            "time_timedelta_plus_datetime",
            "_make_fixed_width",
            "_test_moments_consistency",
            "test_setitem_clear_caches",
            "test_floating_misc",
            "_get_nobs",
            "test_datetime_time",
            "test_categorical_category_dtype_unsorted",
            "set_default_names",
            "get_cmdclass",
            "_write_file_close_tag",
            "test_resample_upsample",
            "test_nunique",
            "test_negative_non_tick_frequency_descending_dates",
            "test_converter_index_col_bug",
            "time_different_numpy_functions",
            "test_annual_upsample_cases",
            "test_meta_name_conflict",
            "test_setitem_None",
            "test_categorial_datetimelike",
            "test_get_datevalue",
            "test_1d_fill_nonna",
            "test_asfreq_non_unique",
            "test_mi_falsey_name",
            "test_quantile_box",
            "astype",
            "is_full_slice",
            "test_join_non_int_index",
            "test_frame_getitem_setitem_boolean",
            "load_reduce",
            "to_hdf",
            "test_replicate_describe",
            "test_shift",
            "test_get_standard_colors_no_appending",
            "test_numpy_compress",
            "time_convert_direct",
            "test_series_constructor_coerce_data_to_extension_dtype_raises",
            "test_shift_empty",
            "test_to_csv_unicode",
            "concat",
            "test_series_constructor",
            "test_swapaxes",
            "_convert_to_side",
            "_check_align_fill",
            "test_tuple_warns",
            "test_from_codes_with_nan_code",
            "_write_regular_rows",
            "_prep_index",
            "test_constructor_start_end_with_tz",
            "get_versions",
            "test_clip_with_datetimes",
            "test_weeks_onoffset",
            "_block_shape",
            "indexables",
            "test_concat_tz_series_with_datetimelike",
            "test_raises_on_dtype_object",
            "test_contains_moar",
            "test_ix_empty_list_indexer_is_ok",
            "test_td64arr_div_td64nat",
            "testPackUnicode",
            "_next_line",
            "test_union_not_cacheable",
            "_set_tz",
            "test_per_axis_per_level_doc_examples",
            "test_to_datetime_with_space_in_series",
            "_dir_additions",
            "test_dt_timetz_accessor",
            "corr",
            "test_setitem_frame_float",
            "test_dti_constructor_with_fixed_tz",
            "dtype_format_for_platform",
            "_unstack_extension_series",
            "test_tuple_correct_keyerror",
            "test_fancy_getitem_slice_mixed",
            "test_multiindex_setitem",
            "html",
            "test_array_equivalent",
            "test_name_repr_generic",
            "test_round_30min",
            "_dtype_to_stata_type",
            "highlight_null",
            "author_missing_data",
            "test_df_add_2d_array_rowlike_broadcasts",
            "time_read_json_lines",
            "parse_table_schema",
            "_class_to_alias",
            "test_rule_code",
            "_set_with",
            "test_ax_plot",
            "test_resolution_string",
            "test_interpolate_akima",
            "test_to_numpy",
            "test_nunique_with_timegrouper",
            "test_to_csv_mixed",
            "_validate_date_like_dtype",
            "test_density",
            "test_unstack_fill_frame_period",
            "test_adjoin_unicode",
            "test_nat_handling",
            "test_readonly_axis_zlib_to_sql",
            "set_ordered",
            "test_categorical_ordering",
            "get_rule_code_suffix",
            "test_codes_immutable",
            "test_repr_tuples",
            "test_empty_sequence_concat",
            "_align_frame",
            "test_timegrouper_with_reg_groups",
            "test_negative_skiprows",
            "test_strip_lstrip_rstrip_args",
            "test_get_loc_length_one_interval",
            "categories",
            "_downsample",
            "test_constructor_dict_of_tuples",
            "_get_prev_label",
            "test_compression_zlib",
            "test_corner_cases",
            "test_take_fill_valid",
            "_skip_if_not_us_locale",
            "test_to_latex_multindex_header",
            "test_dataframe_box_false",
            "_offset_str",
            "test_apply_empty_infer_type",
            "test_encoding",
            "test_getitem_with_duplicates_indices",
            "test_asfreq_MS",
            "test_period_cons_mult",
            "test_to_datetime_bijective",
            "test_pivot_index_with_nan",
            "test_datetime64_with_index",
            "test_mixed_freq_irregular_first_df",
            "_convert_listlike",
            "_init_dict",
            "test_fy5253_nearest_onoffset",
            "_count_level",
            "test_read_from_s3_url",
            "test_to_string_complex_float_formatting",
            "test_set_index_custom_label_type_raises",
            "test_iloc_sparse_propegate_fill_value",
            "test_bad_apply_shape",
            "_read_header",
            "scatter",
            "set_codes",
            "test_fast_unique_multiple_list_gen_sort",
            "_infer_compression",
            "itemsize",
            "test_resample_anchored_ticks",
            "test_underlying_data_conversion",
            "idx",
            "test_pivot_table_multiple",
            "test_pivot_dtypes",
            "_add_numeric_methods_add_sub_disabled",
            "test_ewmcorr_pairwise",
            "test_factorize_nan",
            "test_df_add_td64_columnwise",
            "test_unsupported_other",
            "test_translate",
            "test_sort_nat_values_in_int_column",
            "test_msgpacks_legacy",
            "test_reindex_doesnt_preserve_type_if_target_is_empty_index",
            "test_roundtrip_chunksize",
            "test_compare_unknown_type",
            "test_pipe_tuple",
            "_get_default_writer",
            "test_series_getitem_indexing_errors",
            "test_series_operators",
            "test_to_coo_bad_ilevel",
            "test_dti_shift_near_midnight",
            "test_constructor_scalar_inference",
            "test_setattr_column",
            "test_ngroup_groupby_not_col",
            "_set_labels",
            "time_read_uint64",
            "test_nth_multi_index_as_expected",
            "test_freq_conversion",
            "_maybe_resample",
            "test_nonunicode_nonascii_alignment",
            "test_extract_series",
            "visit_Module",
            "test_boxplot_series",
            "testFixMap",
            "test_plot_figsize_and_title",
            "test_astype_cast_object_int",
            "_open_file_binary_write",
            "test_time_loc",
            "test_con_string_import_error",
            "test_categorical_series_repr_datetime",
            "_generate_range_overflow_safe_signed",
            "test_setitem_tuple",
            "get_corr_func",
            "test_to_datetime_overflow",
            "test_rollforward",
            "test_validation",
            "test_td64arr_add_intlike",
            "test_unary_ops",
            "test_frame_any_all_group",
            "cumsum",
            "_where_standard",
            "test_slice_consolidate_invalidate_item_cache",
            "test_to_latex_midrule_location",
            "test_split_maxsplit",
            "test_single_mgr_ctor",
            "test_array_list",
            "test_json_normalize_errors",
            "test_frame_nonprintable_bytes",
            "test_factorize_dst",
            "test_expand_user",
            "test_to_timestamp_1703",
            "test_index_unique",
            "test_to_datetime_infer_datetime_format_consistent_format",
            "test_groupby_transform_rename",
            "test_duplicate_level_names_access_raises",
            "_data",
            "test_start_time",
            "test_offset",
            "_subplots",
            "df2",
            "test_agg_nested_dicts",
            "test_nanany",
            "test_get_group",
            "test_timestamp_constructor_near_dst_boundary",
            "test_dtype_on_merged_different",
            "test_getitem_listlike",
            "test_compare_series_interval_keyword",
            "_combine_lines",
            "test_empty_nonzero",
            "test_reindex_items",
            "test_join_multiindex_leftright",
            "test_concat_categorical_empty",
            "test_constructor_same",
            "_insert_index",
            "test_unit_consistency",
            "test_to_latex_multiindex",
            "test_drop_names",
            "test_mixed_type_suffix",
            "_get_freq",
            "test_ngroup_descending",
            "pprint_thing",
            "test_parse_public_s3_bucket_nrows_python",
            "register_index_accessor",
            "test_hist_df_with_nonnumerics",
            "test_comparison_tzawareness_compat",
            "test_skip_group_keys",
            "test_compression_warning",
            "test_rolling_quantile_interpolation_options",
            "test_parse_date_all_fields",
            "test_default_date_conversion",
            "test_infer_output_shape_columns",
            "_unbox_scalar",
            "test_repr_html_wide",
            "test_constructor_unsortable",
            "test_formatting_values_deprecated",
            "test_duplicate_column_name",
            "test_ragged_apply",
            "simple_date_range_series",
            "test_maybe_mangle_lambdas_args",
            "test_iloc_getitem_dups",
            "test_tfoot_read",
            "test_minmax_timedelta64",
            "__ne__",
            "sort",
            "test_pi_add_offset_n_gt1",
            "test_get_level_values_box",
            "test_apply_corner_cases",
            "test_df_div_zero_int",
            "test_multitype_list_index_access",
            "test_float_comparison_bin_op",
            "test_repr_np_nat_with_object",
            "test_to_datetime_tz",
            "test_nonunique_raises",
            "sparse_reindex",
            "test_replace_int_to_int_chain",
            "test_dti_take_dont_lose_meta",
            "test_datetime_invalid_scalar",
            "test_dataframe_constructor_from_dict",
            "test_pairwise_with_self",
            "time_rank_ties",
            "test_groupby_grouper",
            "test_from_records_decimal",
            "test_mixed_freq_second_millisecond",
            "time_replace",
            "test_as_json_table_type_date_dtypes",
            "test_to_csv_defualt_encoding",
            "test_slice_locs_negative_step",
            "test_accessor_raises",
            "test_dti_custom_business_summary_dateutil",
            "signature_parameters",
            "test_constructor_spindex_dtype",
            "_get_layout",
            "test_assignment_fails",
            "test_unstack_bool",
            "test_tz_convert_corner",
            "test_tdi_add_overflow",
            "test_constructor_dict_timedelta_index",
            "test_casefold",
            "test_interpolate_timedelta_index",
            "test_from_arrays",
            "diff",
            "test_slice_locs_not_sorted",
            "test_default_handler_raises",
            "test_categories",
            "test_rename_axis_mapper",
            "visit_Subscript",
            "data_missing",
            "test_multi_index_header",
            "test_resample_dup_index",
            "test_at_time",
            "_parse_metadata",
            "test_scalar_comparison_tzawareness",
            "test_validate_ordered",
            "test_align_nocopy",
            "test_series_negate",
            "_bar",
            "test_to_integer_array_inferred_dtype",
            "test_concat_dataframe_keys_bug",
            "test_to_html_float_format_no_fixed_width",
            "test_str_cat_align_mixed_inputs",
            "test_get_dummies",
            "test_to_sql_index_label",
            "test_empty_dtype_coerce",
            "_is_dtype_compat",
            "_create_consistency_data",
            "test_rhs_alignment",
            "test_from_resampling_area_line_mixed",
            "test_rolling_apply",
            "hist",
            "test_replace_unicode_with_number",
            "test_interpolate_pchip",
            "test_swapped_columns",
            "test_with_kwargs",
            "pytables_hdf5_file",
            "test_pivot_table_not_series",
            "_get_offset_day",
            "test_attribute_access",
            "test_series_from_json_to_json",
            "test_mixed_depth_drop",
            "test_whitespace_lines",
            "test_dictwrapper_getattr",
            "test_unique",
            "extract_index",
            "test_astype_duplicate_col",
            "test_assert_produces_warning_honors_filter",
            "test_construction_dti_with_mixed_timezones",
            "test_nanvar_all_finite",
            "test_join_sort",
            "test_boxplot_return_type",
            "test_dt_accessor_api_for_categorical",
            "test_select_dtypes",
            "apply_raw",
            "test_suppress_error_output",
            "test_inf",
            "test_invalid_terms",
            "test_constructor_from_categorical_with_dtype",
            "test_read_expands_user_home_dir",
            "test_unstack_preserve_dtypes",
            "test_nan_fullcolumn",
            "test_unicode_encoding",
            "test_datelike",
            "test_tdi_shift_empty",
            "has_level_label",
            "test_incorrect_type_nested_map",
            "test_union_categoricals_sort_false",
            "test_masked_setitem",
            "test_read_duplicate_index_implicit",
            "test_pairwise_with_series",
            "test_store_datetime_mixed",
            "all_index_generator",
            "test_round",
            "abs",
            "test_corr_pearson",
            "test_setitem_listlike",
            "pivot",
            "_get_fmtlist",
            "_add_timedeltalike_scalar",
            "test_unicode",
            "assert_series_equal",
            "_cat_compare_op",
            "rfind",
            "test_to_csv_dups_cols",
            "test_interp_basic",
            "is_terminal",
            "test_reindex_bool_pad",
            "_check_method",
            "test_date_range_with_tz",
            "test_conv_annual",
            "spmatrix",
            "test_to_csv_from_csv1",
            "test_export",
            "_setup_build_doc",
            "examples_errors",
            "test_from_tuples_iterator",
            "test_multi_index_names",
            "reindex_axis",
            "test_symmetric_difference",
            "test_read_table_columns",
            "_scalar_from_string",
            "test_hide_single_index",
            "test_sparse_mi_max_row",
            "test_to_sql_series",
            "maybe_convert_dtype",
            "test_filter_corner",
            "test_listlike_setitem",
            "test_merge_on_datetime64tz_empty",
            "test_nanosecond_getitem_setitem_with_tz",
            "makePeriodIndex",
            "test_nsmallest",
            "test_sparse_frame_fillna_limit",
            "test_uuid",
            "test_get_dummies_all_sparse",
            "str_get",
            "_write_sortlist",
            "test_fromValue",
            "test_iloc_getitem_slice_dups",
            "test_frame_groupby_columns",
            "test_dict_compat",
            "_convert_to_ndarrays",
            "test_categorical_dtype_high_cardinality_numeric",
            "test_nested_scope",
            "test_read_write_dta10",
            "test_isna",
            "to_time",
            "time_write_store_table",
            "get_test_data",
            "_setup_axes",
            "test_exponents_without_eng_prefix",
            "rank",
            "test_no_na_values_no_keep_default",
            "gen_binary_data",
            "test_nan_to_nat_conversions",
            "test_same_tz_min_max_axis_1",
            "setup",
            "test_performance_warning_for_poor_alignment",
            "test_dataframe_dummies_prefix_str",
            "test_get_callable_name",
            "test_subclass_sparse_transpose",
            "make_invalid_op",
            "to_string",
            "_write_col_header",
            "test_maybe_promote_any_numpy_dtype_with_datetimetz",
            "test_constructor_list_like",
            "is_na",
            "test_excel_stop_iterator",
            "test_series_named_agg_duplicates_raises",
            "test_max_rows_eq_one",
            "test_spline",
            "_validate_indexer",
            "test_datetime_invalid_index",
            "test_constructor_datetime64arr_ok",
            "_join_unicode",
            "time_col_select_numpy_sum",
            "test_at_and_iat_set",
            "test_render_empty_dfs",
            "test_pivot_with_tuple_of_values",
            "test_frame_from_json_bad_data",
            "test_invalid_origin",
            "_get_op_result_fill_value",
            "test_difference_sort_incomparable",
            "test_generate_bins",
            "base",
            "test_objarr_radd_str",
            "test_ser_flex_cmp_return_dtypes_empty",
            "_get_fill_indexer",
            "test_concat_mixed_dtypes",
            "test_to_datetime_dt64s",
            "test_loc_coerceion",
            "test_c_engine",
            "test_path",
            "test_check_many_exprs",
            "_is_sqlalchemy_connectable",
            "test_duplicated_do_not_fail_on_wide_dataframes",
            "test_setitem_corner",
            "_isna_new",
            "test_count",
            "test_assert_almost_equal_shape_mismatch_override",
            "time_parse_today",
            "test_groupby_resample_api",
            "holidays",
            "time_period_constructor",
            "skip_numpy_object",
            "test_unstack_fill_frame_datetime",
            "test_kde_kwargs",
            "test_mean_datetimelike",
            "test_constructor_interval",
            "test_numpy_round_nan",
            "test_assert_extension_array_equal_non_extension_array",
            "test_timegrouper_apply_return_type_value",
            "test_column_dups2",
            "test_union_categoricals_sort",
            "test_map_dict_subclass_without_missing",
            "test_transform_casting",
            "test_astype_str_float",
            "test_repr_roundtrip_raises",
            "time_query_datetime_index",
            "_run_test",
            "__hash__",
            "test_interpolate_from_derivatives",
            "test_from_categorical_dtype_ordered",
            "init_osx_clipboard",
            "dtype_str",
            "rpartition",
            "test_setitem_datetimeindex_tz",
            "test_ignore_empty_rows_when_inferring_header",
            "test_mode_str_obj",
            "test_table_styles",
            "test_style_by_column",
            "_minmax",
            "test_week_of_month_infer",
            "test_multigroup",
            "is_copy",
            "test_int_name_format",
            "test_setitem_frame_mixed",
            "test_datetime_understood",
            "get_node",
            "time_from_iso_format",
            "test_constructor_name_unhashable",
            "test_resample_entirly_nat_window",
            "test_where_series_datetime64",
            "test_agg_over_numpy_arrays",
            "from_tuples",
            "test_rank_args_missing",
            "test_multiindex_slicers_non_unique",
            "test_rename_bug",
            "test_not_all_defaults",
            "test_mode_mixeddtype",
            "test_astype_specific_casting",
            "test_set_index_custom_label_type",
            "test_constructor_dtype_timedelta64",
            "test_time_zone_aware_index",
            "test_transpose",
            "test_timestamp",
            "setup_cache",
            "assert_index_parameters",
            "test_get_loc_multiple_dtypes",
            "test_loc_frame",
            "test_ops_series",
            "test_to_timestamp_mult",
            "test_indexing_doesnt_change_class",
            "test_resample_loffset_arg_type",
            "test_infer_dtype_timedelta",
            "test_set_ContextManager",
            "test_datetime64_ops_nat",
            "test_resample_fill_missing",
            "test_groupby_multiindex_categorical_datetime",
            "test_detect_string_na",
            "test_as_frame_columns",
            "test_slice_can_reorder_not_uniquely_indexed",
            "make_block_same_class",
            "test_equal",
            "test_type_coercion_at_construction",
            "_transform",
            "test_at_iat_coercion",
            "test_closed_empty",
            "test_frame_setitem_view_direct",
            "convert_from_missing_indexer_tuple",
            "test_append",
            "test_empty_series_add_sub",
            "test_get_group_grouped_by_tuple",
            "test_dt_round_tz_ambiguous",
            "test_spss_umlauts",
            "test_value_array_record_prefix",
            "test_is_datetimelike_array_all_nan_nat_like",
            "sample",
            "test_iloc",
            "test_merge_datatype_categorical_error_raises",
            "test_parse_tz_aware",
            "test_dropna_frame",
            "test_fillna_timedelta",
            "convert",
            "test_constructor_datetime_outofbound",
            "test_isna_numpy_nat",
            "_sub_nat",
            "test_simple_expr",
            "test_sort_index_multicolumn",
            "test_interleave_non_unique_cols",
            "test_mixed_timezone_series_ops_object",
            "test_to_string_no_index",
            "test_construction_quarter",
            "test_grouped_hist_legacy2",
            "test_maybe_promote_int_with_float",
            "test_merge_right_index_right",
            "test_regex_idempotency",
            "test_to_records_datetimeindex_with_tz",
            "test_constructor_mixed_dtypes",
            "test_fancy_getitem",
            "test_series_non_unique_index",
            "test_corr_constant",
            "metadata",
            "test_cross_type_arithmetic",
            "test_type_error_multiindex",
            "_cython_operation",
            "test_select_dtypes_typecodes",
            "test_frame_series_agg_multiple_levels",
            "time_series_int",
            "test_date_index_query_with_NaT_duplicates",
            "test_shift_corner_cases",
            "deprecated",
            "rule_code",
            "test_reindex_series_add_nat",
            "_stringify_path",
            "test_frame_loc_callable_setitem",
            "test_inplace_return_self",
            "to_arrays",
            "test_pivot_table_aggfunc_scalar_dropna",
            "test_replace_tzinfo",
            "test_quarterly_resampling",
            "_arith_method_FRAME",
            "test_series_align_aware",
            "test_as_json_table_type_string_data",
            "test_replace_naive",
            "test_constructor_freq_mult_dti_compat",
            "as_matrix",
            "test_constructor_from_items",
            "test_passed_bar_colors",
            "test_merge_on_index_with_more_values",
            "test_comparison_flex_alignment_fill",
            "test_detect_console_encoding_fallback_to_locale",
            "is_any_int_dtype",
            "test_cumcount_groupby_not_col",
            "import_optional_dependency",
            "_coo_to_sparse_series",
            "test_logscales",
            "test_object",
            "df_none",
            "test_to_excel_multiindex_nan_label",
            "test_query_with_string_columns",
            "_to_original_callable",
            "nanmedian",
            "test_to_csv_date_format",
            "test_boxplot_colors",
            "should_show_dimensions",
            "test_right",
            "test_dataframe_nested",
            "test_math_div",
            "test_complex_cmp_ops",
            "test_td_rdiv_timedeltalike_scalar",
            "test_do_not_mangle_na_values",
            "test_unordered_same",
            "test_construct_from_string",
            "_get_axis_name",
            "test_from_spmatrix_raises",
            "_join_multiline",
            "test_invalid_total_length_max_length_one",
            "test_sum_overflow",
            "test_append_hierarchical",
            "assert_period_array_equal",
            "test_integer_positional_indexing",
            "test_from_product_index_series_categorical",
            "test_ngroup_distinct",
            "_print_as_set",
            "test_fails_on_no_datetime_index",
            "test_groupby_as_index_apply",
            "test_series_invert",
            "test_api_for_categorical",
            "test_get_numeric_data_extension_dtype",
            "set_locale",
            "test_unicode_dta_118",
            "test_tz_is_utc",
            "test_mixed_freq_alignment",
            "time_startswith",
            "test__get_dtype_sparse",
            "test_explicit_conversions",
            "test_floats",
            "time_pad",
            "test_interpolate_spline_invalid_order",
            "test_crosstab_with_categorial_columns",
            "test_interp_raise_on_all_object_dtype",
            "test_order_aggregate_multiple_funcs",
            "is_signed_integer_dtype",
            "test_loc_multiindex_incomplete",
            "test_datelike_mode",
            "__enter__",
            "kde",
            "test_hongkong_tz_convert",
            "test_take_filling",
            "_need_convert",
            "test_examples4",
            "test_custom_business_day_freq",
            "_to_str_columns",
            "test_copy_name2",
            "test_date_range_localize",
            "test_builtins_apply",
            "test_int_array_comparison",
            "_create_sp_frame",
            "run_command",
            "_get_series_result_type",
            "_describe_option",
            "test_dt64arr_aware_sub_dt64ndarray_raises",
            "test_kind",
            "test_parr_ops_errors",
            "test_partial_string_timestamp_multiindex",
            "test_no_args_raises",
            "test_dot",
            "test_unstack_timezone_aware_values",
            "test_aaa_group_order",
            "test_read_csv_buglet_4x_multi_index",
            "_try_coerce_args",
            "_hash_scalar",
            "_check_is_partition",
            "float_frame",
            "time_nlargest_two_columns",
            "test_read_clipboard_infer_excel",
            "test_from_array_deprecated",
            "time_findall",
            "_generate_body",
            "test_tuple_warns_unhashable",
            "test_repr_embedded_ndarray",
            "test_timedelta_plot",
            "test_xs_level_eq_2",
            "test_dti_cmp_nat_behaves_like_float_cmp_nan",
            "_set_axis",
            "test_difference_sort_special_true",
            "_to_safe_for_reshape",
            "test_1",
            "test_slice_bounds_empty",
            "_concat_same_type",
            "index",
            "test_astype_assignment_with_dups",
            "test_agg_item_by_item_raise_typeerror",
            "test_intersection_equal",
            "test_drop_level",
            "test_intersection_bug",
            "test_group_var_large_inputs",
            "test_same_name_scoping",
            "test_difference_incomparable",
            "test_invalid_xy_args",
            "test_repr_big",
            "test_rank_descending",
            "test_to_object_array_width",
            "test_invalid_index_types",
            "test_resample_irregular_sparse",
            "test_comparison",
            "peakmem_read_json_lines",
            "test_empty_with_mangled_column_pass_dtype_by_indexes",
            "test_compare_len1_raises",
            "test_repr_name_coincide",
            "test_convert_pandas_type_to_json_field_float",
            "test_sort_column_level_and_index_label",
            "test_to_period_quarterlyish",
            "test_from_list_dtype",
            "test_pivot_datetime_tz",
            "hist_frame",
            "test_basic_drop_first_NA",
            "test_frame_describe_multikey",
            "test_len",
            "df_main_dtypes",
            "test_duplicate_multiindex_codes",
            "test_concat_tz_series",
            "test_bool_ops_raise_on_arithmetic",
            "test_to_datetime_barely_out_of_bounds",
            "test_filter_against_workaround",
            "test_read_csv_chunked_download",
            "_format_space",
            "test_constructor_nano",
            "_wrap_joined_index",
            "test_from_product",
            "test_apply_keep_sparse_dtype",
            "test_merge_on_ints_floats",
            "_get_ax_legend",
            "test_validate_stat_keepdims",
            "test_inplace_ops_identity2",
            "test_dti_representation_to_series",
            "test_repr_truncation",
            "test_constructor_nat",
            "test_assert_almost_equal_unicode",
            "test_spline_extrapolate",
            "validate_categories",
            "test_from_iterator",
            "test_multi_index_no_level_names_implicit",
            "test_multiindex_symmetric_difference",
            "test_freq_infer_raises",
            "test_promote_datetime_date",
            "test_get_value",
            "get_indexers_list",
            "test_get_indexer2",
            "test_append_list_of_series_dicts",
            "test_empty_string_raises",
            "test_numpy_argmax_deprecated",
            "test_array_interface",
            "test_is_non_overlapping_monotonic",
            "test_dti_construction_nonexistent_endpoint",
            "test_agg_dict_parameter_cast_result_dtypes",
            "_end_apply_index",
            "test_register_option",
            "test_old_import_warns",
            "test_is_scalar_numpy_arrays",
            "test_construction_outofbounds",
            "test_unstack_multiple_hierarchical",
            "test_coercion_with_setitem_and_dataframe",
            "test_to_html_justify",
            "test_to_period_nofreq",
            "test_getitem_dupe_cols",
            "test_groupby_reindex_inside_function",
            "test_to_html_with_empty_string_label",
            "test_cummax",
            "initialize_options",
            "test_compat",
            "test_convert_dates",
            "test_date_boolean",
            "test_encoding_non_utf8_multichar_sep",
            "test_mixed_depth_pop",
            "test_rolling_corr_cov",
            "iteritems",
            "test_categorical_zeroes",
            "test_resample_empty_dataframe",
            "test_bar_align_mid_vmin_vmax_clipping",
            "_get_resampler",
            "test_join_mixed_non_unique_index",
            "test_as_index_series_column_slice_raises",
            "test_mod_timedelta64",
            "test_value_counts",
            "test_mask_with_boolean_raises",
            "test_sort_values_na_position",
            "test_dti_summary",
            "test_bool_uint",
            "test_interp_limit_forward",
            "test_merge_by_col_tz_aware",
            "_concat_compat",
            "test_from_sparse_dtype",
            "test_rounding",
            "test_raise_on_find_unsupported_value",
            "_shallow_copy",
            "_values_for_factorize",
            "is_datetime64_ns_dtype",
            "labels",
            "name",
            "asof",
            "test_get_dummies_dont_sparsify_all_columns",
            "test_parse_integers_above_fp_precision",
            "test_uint64_overflow",
            "lexsort_indexer",
            "test_ops_ndarray",
            "test_period_array_freq_mismatch",
            "test_reindex_level_partial_selection",
            "test_get_offset_name",
            "_get_data_from_filepath",
            "_aggregate_generic",
            "time_pivot_table_categorical",
            "_apply_columns",
            "test_CategoricalAccessor_categorical_deprecation",
            "test_unstack_level_name",
            "test_frame_select",
            "test_resample_dst_anchor",
            "concat_same_type",
            "test_loc_duplicates",
            "test_compare_custom_object",
            "test_read_hdf_generic_buffer_errors",
            "test_concat_period_multiple_freq_series",
            "putmask",
            "test_sort_datetimes",
            "copy",
            "test_pickle_v0_15_2",
            "_create_join_index",
            "test_td_rsub_mixed_most_timedeltalike_object_dtype_array",
            "test_finder_monthly",
            "_can_use_numexpr",
            "is_signed_integer",
            "resample",
            "test_stack_mixed_dtype",
            "test_iloc_setitem_dups",
            "test_set_index",
            "test_get_item",
            "test_custom_repr",
            "test_has_duplicates",
            "test_series_add_tz_mismatch_converts_to_utc_duplicate",
            "test_dti_add_offset_index",
            "test_drop_labels_or_levels_series",
            "test_getitem_with_datestring_with_UTC_offset",
            "test_constructor_mix_series_nonseries",
            "test_subplots_timeseries_y_axis",
            "test_mixed_type_join_with_suffix",
            "test_fillna_datetime64tz",
            "test_nan_to_missing_value",
            "test_multiby_indexed",
            "test_resample_axis1",
            "test_negate_lt_eq_le",
            "test_to_datetime_utc_true_with_series_single_value",
            "test_parse_time_quarter_with_dash_error",
            "test_nan_stays_float",
            "boxplot_frame_groupby",
            "test_rename_positional",
            "test_bins_not_monotonic",
            "test_to_datetime_cache_scalar",
            "test_as_array_datetime_tz",
            "test_add_sub_nat",
            "test_resample_dtype_preservation",
            "cat_safe",
            "test_set_incompatible_types",
            "test_intersection_name_preservation2",
            "test_assign_dependent",
            "test_parsers_quarter_invalid",
            "_assert_tzawareness_compat",
            "test_pi_cmp_nat",
            "test_unique_ordered",
            "test_bad_engine_raises",
            "has_expanded_repr",
            "test_resample_ohlc",
            "test_sub_offset",
            "test_unstack_fill",
            "test_margins_dtype_len",
            "test_append_new_columns",
            "test_where_tz",
            "test_excel_010_hemstring",
            "set_files",
            "test_integer_arithmetic",
            "test_dups_fancy_indexing",
            "test_rank_tie_methods_on_infs_nans",
            "test_groupby_nat_exclude",
            "test_dt64_mul_div_numeric_invalid",
            "_write_cell",
            "test_get_schema2",
            "test_is_overlapping_endpoints",
            "test_replace2",
            "test_convert_infs",
            "test_slicing_directly",
            "test_to_hierarchical",
            "test_subclass_align",
            "describe",
            "test_rename_objects",
            "_string_data_error",
            "check_pow",
            "test_secondary_y_mixed_freq_ts_xlim",
            "test_series_add_tz_mismatch_converts_to_utc",
            "test_xs",
            "test_dataframe_insert_column_all_na",
            "test_set_categories_rename_less",
            "test_index_tolerance",
            "test_str_cat_raises_intuitive_error",
            "insert_statement",
            "test_tz_localize_ambiguous",
            "test_iloc_getitem_neg_int_can_reach_first_index",
            "test_append_empty_frame_to_series_with_dateutil_tz",
            "test_mixed_integer",
            "test_different",
            "test_construction_from_replaced_timestamps_with_dst",
            "test_multiindex_objects",
            "test_to_csv_string_with_lf",
            "_update_inplace",
            "peakmem_read_json_lines_concat",
            "is_",
            "test_datetime_with_tz_dtypes",
            "test_to_string_name",
            "testRaw",
            "test_set_reset",
            "split_and_operate",
            "test_period_index_date_overflow",
            "len",
            "find_common_type",
            "test_constructor_single_str",
            "test_rank_args",
            "test_character_overlap",
            "nunique",
            "test_timestamp_tz_localize_nonexistent_shift_invalid",
            "test_prod_numpy16_bug",
            "test_align_nested_unary_op",
            "test_copy_index_name_checking",
            "_is_deprecated",
            "test_title",
            "test_put_compression",
            "_check_for_locals",
            "test_read_one_empty_col_with_header",
            "test_quantile_interpolation",
            "time_comment",
            "array_equivalent",
            "inferred_type",
            "_reindex_columns",
            "whitelist_method_generator",
            "test_to_hdf_multiindex_extension_dtype",
            "test_merging_with_bool_or_int_cateorical_column",
            "test_setitem_same_ordered_rasies",
            "_validate_freq",
            "test_joins",
            "narrow_multi_index",
            "test_pytables_native_read",
            "random_state",
            "test_frame_iloc_callable",
            "decons_obs_group_ids",
            "test_csv_to_string",
            "test_from_records_bad_index_column",
            "test_value_counts_unique_nunique_null",
            "_use_dynamic_x",
            "should_store",
            "test_to_html_multiindex_odd_even_truncate",
            "test_color_and_style_arguments",
            "_apply_index_days",
            "test_slice_locs_with_interval",
            "test_invalid_logscale",
            "test_fancy_index_int_labels_exceptions",
            "set_levels",
            "test_filter",
            "test_max_str_len",
            "test_from_product_empty_three_levels",
            "test_should_cache",
            "test_weekly_resample_buglet",
            "_get_hashtable_algo",
            "test_from_buffer",
            "test_replace_with_empty_list",
            "_set_formats_and_types",
            "_border_style",
            "test_union_categoricals_ordered",
            "test_groupby_return_type",
            "test_sql_open_close",
            "maybe_color_bp",
            "_maybe_null_out",
            "test_int64_overflow_moar",
            "test_subtype_integer",
            "test_dti_to_pydatetime",
            "test_weekofmonth_onoffset",
            "test_slicing_and_getting_ops",
            "test_anchored_lowercase_buglet",
            "test_none_coercion_loc_and_dataframe",
            "test_cumprod",
            "test_is_list_like",
            "test_parse_delimited_date_swap",
            "data_orientation",
            "test_extract_expand_False",
            "test_normalize",
            "test_read_data_list",
            "test_expanding_count",
            "test_to_dict_index_not_unique_with_index_orient",
            "_cython_agg_blocks",
            "test_date_index_query",
            "test_construct_timestamp_preserve_original_frequency",
            "test_join_self",
            "test_series_to_categorical",
            "test_reindex_multi",
            "_write_formats",
            "test_drop_by_numeric_label_raises_missing_keys",
            "test_ix_assign_column_mixed",
            "test_cast_j_int",
            "test_ser_flex_cmp_return_dtypes",
            "test_apply_issues",
            "_set_default_format",
            "test_simple_in_ops",
            "repeat",
            "test_count_nonnumeric_types",
            "_preprocess_data",
            "test_read_csv_gcs",
            "test_ix_multi_take_multiindex",
            "add_suffix",
            "_maybe_match_name",
            "test_series_getitem_multiindex_xs_by_label",
            "test_no_cast",
            "read_axes",
            "test_categorical_order",
            "test_get_indexer_array",
            "view",
            "test_constructor_datelike_coercion",
            "test_header_names_backward_compat",
            "test_on_specialized_type",
            "time_unique_seconds_and_unit",
            "test_assert_numpy_array_equal_value_mismatch4",
            "mdiffs",
            "test_constructor_timedelta",
            "test_na_values_with_cache",
            "set_kind",
            "test_record_prefix",
            "test_timedelta_conversions",
            "read_data",
            "test_getitem_datetime",
            "test_setitem_iloc_scalar_single",
            "_hashed_indexing_key",
            "_format_multicolumn",
            "test_tolerance",
            "test_astype_conversion",
            "test_groupby_2d_malformed",
            "_parser_dispatch",
            "test_drop_not_lexsorted",
            "test_hist_single_row",
            "test_partial_boolean_frame_indexing",
            "get_group_index_sorter",
            "default_index",
            "test_to_string_header",
            "test_replace_series_datetime_datetime",
            "colorconverter",
            "test_constructor_dtype_str_na_values",
            "test_replace_series_dict",
            "test_closed_min_max_minp",
            "test_boolean_indexing",
            "test_get_schema",
            "test_pivot_with_tz",
            "test_pivot_empty",
            "empty_value",
            "_convert_params",
            "test_astype_empty_constructor_equality",
            "test_getitem_overload",
            "setitem",
            "_convert_key",
            "get_expected_pow_result",
            "test_getitem_negative_out_of_bounds",
            "test_overflow_on_construction",
            "test_flush",
            "test_bar_align_mid_all_pos",
            "_check_cython_group_transform_cumulative",
            "test_filter_with_axis_in_groupby",
            "test_hashtable_factorize",
            "test_concat_categorical",
            "test_timeseries_preepoch",
            "test_merge_join_different_levels",
            "_prep_window",
            "test_create_table",
            "test_object_array_eq_ne",
            "test_concat_inner_join_empty",
            "test_ragged_count",
            "test_any_all_extra",
            "df_ambig",
            "test_intersection2",
            "_get_cythonized_result",
            "_get_axis_number",
            "test_append_with_different_block_ordering",
            "test_symmetric_difference_mi",
            "test_append_different_columns",
            "generate_table",
            "test_to_dense",
            "test_setitem_fancy_mixed_2d",
            "test_no_legend",
            "test_infer_s3_compression",
            "test_basic_frame_alignment",
            "test_set_index_pass_single_array",
            "test_astype_object_tz",
            "_get_overlap_public_nat_methods",
            "test_timedelta_ops_with_missing_values",
            "test_constructor_sanitize",
            "test_read_csv_no_index_name",
            "test_drop_table",
            "time_from_unit",
            "_apply_style_colors",
            "_post_plot_logic_common",
            "test_bday_near_overflow",
            "apply_index",
            "test_searchsorted_monotonic",
            "test_freq_setter_deprecated",
            "test_keep_default_na",
            "test_search_sorted_datetime64_list",
            "test_categorical_dtype",
            "test_replace_for_new_dtypes",
            "test_find_nan",
            "assert_almost_equal",
            "test_to_timestamp_tz_arg_dateutil",
            "reset_testing_mode",
            "test_format_sparse_display",
            "test_get_default",
            "test_merge_two_empty_df_no_division_error",
            "test_merge_nan_right",
            "test_ewmcov",
            "test_ser_cmp_result_names",
            "test_setitem_float_labels",
            "expected_html",
            "test_no_header_prefix",
            "test_unstack_bug",
            "test_regex_replace_dict_nested_gh4115",
            "test_as_json_table_type_int_data",
            "test_simple_normalize_with_separator",
            "test_frame_loc_callable_labels",
            "test_aggregate_with_nat_size",
            "test_repr_truncates_terminal_size",
            "test_set",
            "test_binary_ops",
            "test_multilevel_consolidate",
            "test_isin_dict",
            "test_rename_set_name_inplace",
            "generate_value_label",
            "_check_column_names",
            "validate_indices",
            "test_concat_different_kind",
            "_fill",
            "test_combine_first_with_asymmetric_other",
            "test_select",
            "test_str_cat_align_indexed",
            "_parse_suffix",
            "test_stack_ints",
            "test_missing",
            "test_set_change_dtype",
            "test_constructor_with_datetime_tz",
            "test_remove",
            "test_last_raises",
            "test_store_datetime_fractional_secs",
            "test_info_memory_usage_bug_on_multiindex",
            "test_infer_output_shape_listlike_columns",
            "test_std_var_pass_ddof",
            "test_interpolate_index_values",
            "test_big_print",
            "test_pyint_engine",
            "test_observed_groups_with_nan",
            "test_datetime_cut_roundtrip",
            "_set_name",
            "test_bar_log_subplots",
            "test_count_with_datetimelike",
            "has_doubly_truncated_repr",
            "test_handle_overlap",
            "test_extractall_stringindex",
            "_normalize",
            "test_reindex_corner",
            "time_from_np_timedelta",
            "test_is_monotonic",
            "test_nargsort",
            "_convert_to_fill",
            "parameter_desc",
            "test_nd_raises",
            "test_observed_perf",
            "test_maybe_mangle_lambdas_passthrough",
            "_assert_same_contents",
            "round_trip_pickle",
            "test_excel_read_buffer",
            "test_usecols_subset_names_mismatch_orig_columns",
            "line",
            "astype_nansafe",
            "test_convert_accepts_unicode",
            "test_concat_bug",
            "test_uses_first_kind",
            "groups",
            "test_unicode_longer_encoded",
            "test_drop_nonunique",
            "_set_ticks_props",
            "kind",
            "period_range",
            "test_combine_first_timedelta",
            "test_ExcelWriter_dispatch",
            "test_decode_from_unicode",
            "test_conversion",
            "test_merge_equal_cat_dtypes2",
            "test_number_mode",
            "test_series_partial_set_period",
            "test_join_index_series",
            "test_apply_reduce_Series",
            "_decide_output_index",
            "test_sparse_frame_unstack",
            "test_groupby_whitelist",
            "__rtruediv__",
            "test_infer_dtype_all_nan_nat_like",
            "recons_labels",
            "test_binops",
            "test_dti_tz_localize_bdate_range",
            "test_reset_index_multiindex_col",
            "time_write_store_mixed",
            "test_monthly",
            "test_fillna_nat",
            "test_series_at",
            "test_groupby_apply_identity",
            "first",
            "test_datetime_count",
            "test_crosstab_dup_index_names",
            "__init__",
            "test_td64arr_div_td64_ndarray",
            "test_constructor_with_index",
            "time_groupby_apply_dict_return",
            "_do_select_columns",
            "test_frame_mixed_depth_get",
            "test_array_numpy_labelled",
            "test_lower_int_prec_count",
            "test_store_index_name_numpy_str",
            "test_skiprows_slice",
            "adjoin",
            "tz_convert",
            "test_n_error",
            "check_binary_arith_op",
            "test_crosstab_dropna",
            "test_2d_datetime64",
            "get_indexer_for",
            "_cast_to_stata_types",
            "test_merge_non_unique_period_index",
            "_handle_truncated_float_vec",
            "test_value_counts_with_nan",
            "test_series_loc_getitem_fancy",
            "test_duplicate_meta_data",
            "test_wide_repr_wide_long_columns",
            "test_method_signatures",
            "test_compare_2100",
            "makeTimeSeries",
            "test_set_index_nan",
            "test_nonnumeric_exclude",
            "test_to_dict",
            "test_groupby_levels_and_columns",
            "_restrict_to_columns",
            "test_compare_timedelta_ndarray",
            "autocorrelation_plot",
            "test_rename_mi",
            "test_series_tz_localize_nonexistent",
            "test_subtype_datetimelike",
            "test_dict_entries",
            "test_timedelta_invalid_key",
            "test_split_noargs",
            "dt64arr_to_periodarr",
            "cartesian_product_for_groupers",
            "test_no_overlap_more_informative_error",
            "_infer_daily_rule",
            "test_intersection_monotonic",
            "test_basic_names",
            "test_chained_union",
            "test_catch_too_many_names",
            "_na_ok_dtype",
            "test_path_pathlib_hdfstore",
            "test_as_json_table_type_int_dtypes",
            "test_delete_slice",
            "test_view_with_args_object_array_raises",
            "empty_index",
            "check_array",
            "test_replace_doesnt_replace_without_regex",
            "get_result_as_array",
            "apply_wraps",
            "test_get_loc_nat",
            "test_unstack_period_series",
            "test_good_class",
            "test_at_time_tz",
            "test_tdi_shift_nonstandard_freq",
            "test_maxbuffersize_bufferfull",
            "test_converters",
            "test_quantile_raises",
            "test_timeseries_periodindex",
            "register_option",
            "test_moment_functions_zero_length",
            "test_drop_tz_aware_timestamp_across_dst",
            "test_nan_string",
            "test_categorical_series_repr_timedelta",
            "test_all_offset_classes",
            "test_compare_hour01",
            "test_to_timedelta_invalid",
            "_convert_obj",
            "test_union_categorical",
            "test_union_sort_other_empty",
            "encode",
            "test_slice",
            "test_info_max_cols",
            "test_usecols_int",
            "test_nat_converters",
            "test_round_issue",
            "tokenize_string",
            "test_tdi_sub_integer_array",
            "_check_compatible_with",
            "test_constructor_from_series_freq",
            "test_to_coo_integer_names_integer_row_levels_nosort",
            "test_conv_hourly",
            "test_duplicates",
            "get_api_items",
            "test_merge_on_datetime64tz",
            "test_alias_to_unit_bad_alias_raises",
            "test_none_comparison",
            "test_partial_set_empty_series",
            "test_from_frame_invalid_names",
            "test_seaborn",
            "_get_val_at",
            "simple_frame",
            "test_cant_fill_missing_dups",
            "use_inf_as_na_cb",
            "test_stack_datetime_column_multiIndex",
            "test_pass_array",
            "test_duplicated_drop_duplicates_index",
            "test_cast_NA_to_bool_raises_error",
            "test_period_nat_comp",
            "test_round_nonstandard_freq",
            "test_pivot_number_of_levels_larger_than_int32",
            "flags",
            "test_astype_extension_dtypes",
            "test_parsers_nat",
            "test_apply_concat_preserve_names",
            "get_level_lengths",
            "is_unsigned_integer",
            "time_groupby_ordered_nosort",
            "test_spline_smooth",
            "test_excel_date_datetime_format",
            "test_repr_html_long_multiindex",
            "test_fwf_regression",
            "test_field_access_localize",
            "test_binary_ufunc_other_types",
            "test_to_json_categorical_index",
            "test_index_type_coercion",
            "test_concat_series_partial_columns_names",
            "test_shallow_nested",
            "test_iter_python_types_datetime",
            "test_usecols",
            "test_take_categorical",
            "test_partial_slicing_with_multiindex",
            "test_apply_non_numpy_dtype",
            "check_results",
            "test_to_csv_new_dupe_cols",
            "test_insert_benchmark",
            "test_skiprows_slice_long",
            "to_native_types",
            "test_from_inferred_categories",
            "test_properties",
            "s_main_dtypes",
            "test_representation",
            "test_boundary_datetimelike",
            "test_pipe_failures",
            "test_groupby_function_tuple_1677",
            "test_multiple_ouput_binary_ufuncs",
            "test_select_dtypes_not_an_attr_but_still_valid_dtype",
            "test_excel_multiindex_columns_and_index_true",
            "_assert_not_almost_equal",
            "test_td64arr_add_offset_index",
            "test_file_like",
            "test_drop_duplicates_categorical_bool",
            "test_many_columns",
            "test_reading_all_sheets",
            "assert_range_equal",
            "test_append_dtype_coerce",
            "_generate_range",
            "check_fun",
            "test_invalid_type_for_operator_raises",
            "__setstate__",
            "test_mean_excludeds_datetimes",
            "test_maybe_promote_dimensions",
            "test_concat_aligned_sort_does_not_raise",
            "__rsub__",
            "test_td_op_timedelta_timedeltalike_array",
            "test_map_with_dict_or_series",
            "test_astype_uint",
            "test_same_categories_different_order",
            "get_op_from_name",
            "test_invalid_parser",
            "test_loc_with_overlap",
            "_convert_can_do_setop",
            "test_map_na_exclusion",
            "test_plot_kwargs",
            "test_integers",
            "_from_inferred_categories",
            "test_read_hdf_series_mode_r",
            "test_query_syntax_error",
            "barh",
            "init_ndarray",
            "test_align_series",
            "test_tdi_shift_minutes",
            "test_set_index_raise_keys",
            "test_dti_cmp_datetimelike",
            "is_datetimelike_v_object",
            "check_simple_cmp_op",
            "test_concat_join_axes_deprecated",
            "to_offset",
            "validate_pep8",
            "test_iso_8601_strings_same_offset_no_box",
            "test_inner_join",
            "test_convert_strl_name_swap",
            "test_unstack_multiple_no_empty_columns",
            "test_east_asian_unicode_false",
            "test_is_datetime64_ns_dtype",
            "test_transform_doesnt_clobber_ints",
            "test_usecols_excel_range_str",
            "test_to_jsonl",
            "date_range_frame",
            "test_describe_tz_values",
            "test_constructor_nonnan",
            "test_td64arr_div_tdlike_scalar_with_nat",
            "test_repr_html_wide_multiindex_cols",
            "test_frame_from_json_nones",
            "test_convert_no_arg_error",
            "_mpl_version",
            "test_to_csv_na_rep",
            "_get_counts",
            "test_ExcelWriter_dispatch_raises",
            "_check_box_coord",
            "test_resample_equivalent_offsets",
            "test_replace_with_single_list",
            "test_axis_share_y",
            "test_categorical_margins_category",
            "_cython_agg_general",
            "test_to_dict_index_dtypes",
            "test_from_sparse_dtype_fill_value",
            "test_round_daily",
            "test_tick_rdiv",
            "ffill",
            "test_msgpack_period_freq",
            "test_subclass_stack_multi_mixed",
            "test_output_significant_digits",
            "test_read_table_index_col",
            "test_parse_date_time",
            "test_pivot_table_multi",
            "ip",
            "test_reorder_levels",
            "test_bins",
            "test_timegrouper_apply_return_type_series",
            "_grouped_hist",
            "randu_array",
            "test_constructor_categorical",
            "test_consolidate_inplace",
            "test_timtetonum_accepts_unicode",
            "test_timedelta64_operations_with_timedeltas",
            "test_to_html_index",
            "_set_endianness",
            "test_combine_first_dt64",
            "test_constructor_numpy_scalar",
            "test_second",
            "_check_align",
            "_apply_window",
            "test_index_convert_to_datetime_array_dateutil",
            "test_read_csv_handles_boto_s3_object",
            "test_set_option_uneven_args",
            "test_is_float",
            "_aggregate_named",
            "test_assert_numpy_array_equal_shape_mismatch_override",
            "merge_pr",
            "_arith_method_SPARSE_SERIES",
            "teardown_method",
            "test_as_json_table_type_float_dtypes",
            "test_concat_categorical_coercion_nan",
            "test_write_with_index",
            "_check_holiday_results",
            "test_categorical_concat_dtypes",
            "test_escapable_characters",
            "test_tz_localize_nonexistent",
            "test_construction_from_string",
            "test_median",
            "get_duplicates",
            "test_set_value_keeps_names",
            "test_operation_on_NaT",
            "create_single_mgr",
            "test_index_with_nan",
            "test_iteration_over_chunksize",
            "query",
            "test_mode_dropna",
            "test_bar_align_left_axis_none",
            "test_filter_and_transform_with_multiple_non_unique_int_index",
            "test_write_column_multiindex",
            "test_replace_dst_border",
            "_maybe_eval",
            "test_selection_api_validation",
            "test_reader_seconds",
            "test_resample_reresample",
            "transpose",
            "test_td64arr_sub_td64_array",
            "test_index_and_on_parameters_confusion",
            "network",
            "test_constructor_timestamp_near_dst",
            "test_unstack_unused_level",
            "test_corr_rank",
            "get_resampler_for_grouping",
            "test_multiindex_assignment",
            "test_finder_annual",
            "test_maybe_convert_numeric_post_floatify_nan",
            "test_invalid_numexpr_version",
            "read_spss",
            "test_to_csv_float_format",
            "test_annual_upsample",
            "test_interp_ignore_all_good",
            "test_join_index",
            "_get_cell_value",
            "test_get_dummies_with_name_dummy",
            "_preprocess_for_cut",
            "test_maxbuffersize",
            "test_left_join_index_multi_match",
            "test_constructor_iso",
            "should_cache",
            "test_to_records_with_categorical",
            "test_get_schema_dtypes",
            "test_bad_version",
            "state_data",
            "test_simple_records",
            "test_convertable_values",
            "is_floating",
            "test_basic_right_index",
            "test_use_bottleneck",
            "test_both_style_and_color",
            "test_td_add_td",
            "test_join_does_not_recur",
            "_convert_string_array",
            "test_drop_by_str_label_raises_missing_keys",
            "test_monotonic",
            "test_metadata_propagation",
            "_from_values_or_dtype",
            "asarray_tuplesafe",
            "test_nanargmax",
            "_parse_td",
            "test_tuple_union_bug",
            "to_csv",
            "test_groupby_empty_list_raises",
            "convert_json_field_to_pandas_type",
            "test_drop_with_ignore_errors",
            "test_capitalize",
            "test_compare_invalid",
            "test_decode_floating_point",
            "test_object_comparisons",
            "test_td64arr_floordiv_tdlike_scalar",
            "test_reindex_axis_style",
            "test_min_max_numeric_only",
            "test_read_write_reread_dta15",
            "test_construction_index_with_mixed_timezones",
            "test_round_mixed_type",
            "test_corr_spearman",
            "compare_element",
            "test_contains",
            "_highlight_handler",
            "test_constructor_with_non_normalized_pytz",
            "mframe",
            "_open_browser",
            "datetime_index",
            "test_float_array",
            "pandas_dtype",
            "test_frame_multi_key_function_list",
            "test_annual",
            "test_large_value_conversion",
            "test_pad_stable_sorting",
            "test_hide_columns_mult_levels",
            "get_indexer",
            "test_floor",
            "test_astype_extension_dtypes_1d",
            "test_to_csv_unicode_index_col",
            "test_engine_type",
            "test_setitem_series_timedelta64",
            "time_join_dataframe_index_shuffle_key_bigger_sort",
            "test_tdi_isub_timedeltalike",
            "test_nth_nan_in_grouper",
            "test_chunksize_read",
            "test_dti_isub_tdi",
            "test_assignment_column",
            "test_constructor_coerce",
            "test_filter_and_transform_with_non_unique_string_index",
            "test_flex_binary_frame",
            "test_to_string_mixed",
            "test_fillna_dtype_conversion",
            "insert_data",
            "get_numeric_mat",
            "time_iso8601_format_no_sep",
            "test_multiple_date_cols_index",
            "test_td64_series_astype_object",
            "test_zero",
            "time_left_outer_join_index",
            "test_hashtable_unique",
            "_arith_method_SPARSE_ARRAY",
            "test_to_csv_compression",
            "write_file",
            "test_series_named_agg",
            "test_transform_broadcast",
            "test_loc_getitem_int_slice",
            "test_group_name_available_in_inference_pass",
            "julian_dates",
            "test_multi_index_no_level_names",
            "test_fill_value_reindex_coerces_float_int",
            "test_get_indexer_nearest_listlike_tolerance",
            "test_groupby_multi_corner",
            "test_info_duplicate_columns_shows_correct_dtypes",
            "test_to_csv_quoting",
            "test_resample_anchored_multiday",
            "_is_potential_multi_index",
            "_maybe_cast_slice_bound",
            "test_overlapping_names",
            "test_fillna_datetime_columns",
            "test_constructor_dict_dont_upcast",
            "test_month_range_union_tz_dateutil",
            "test_query_index_without_name",
            "get_ftype_counts",
            "duplicated",
            "_check_numeric_ops",
            "test_get_indexer_with_NA_values",
            "test_align_frame",
            "time_baseline",
            "test_timestamp_tz_localize",
            "test_rolling_skew_edge_cases",
            "test_read_excel_nrows",
            "invalid_comparison",
            "_validate_specification",
            "test_yy_format_with_year_first",
            "test_get_indexer_pad",
            "test_astype_timedelta64",
            "left",
            "test_get_level_values_na",
            "test_pivot_string_func_vs_func",
            "test_dti_with_period_data_raises",
            "test_matplotlib_formatters",
            "test_rangeindex_fallback_coercion_bug",
            "_three_digit_exp",
            "coerce_to_array",
            "test_examples2",
            "test_set_name",
            "_alert_malformed",
            "test_level_get_group",
            "test_sas_buffer_format",
            "objects_to_datetime64ns",
            "test_set_categories_private",
            "test_to_html_escaped",
            "validate_one",
            "test_concat_order",
            "test_from_product_empty_one_level",
            "to_json",
            "droplevel",
            "test_multi_index_naming",
            "test_infer_tz_compat",
            "test_arg_tz_ns_unit",
            "test_to_timedelta",
            "check_round_trip",
            "test_resample_base",
            "_set_levels",
            "test_expanding_cov_pairwise_diff_length",
            "test_assert_almost_equal_value_mismatch4",
            "test_categorical_pivot_index_ordering",
            "test_sniff_delimiter_encoding",
            "test_partial_slice",
            "test_loc_getitem_duplicates_multiindex_missing_indexers",
            "test_uint64_type_handling",
            "test_numpy_ufuncs",
            "time_frame_nth",
            "test_downsample_across_dst",
            "test_index_col_with_unnamed",
            "test_missing_value_generator",
            "makeMissingDataframe",
            "test_constructor_pass_nan_nat",
            "test_constructor_data_aware_dtype_naive",
            "test_timedelta64_dtype_array_returned",
            "test_finder_monthly_long",
            "test_intersection_name_preservation",
            "test_to_timestamp_preserve_name",
            "test_multi_line_expression",
            "test_ops_series_period",
            "test_get_set_value_no_partial_indexing",
            "maybe_convert_platform",
            "detect_colspecs",
            "test_groupby_non_arithmetic_agg_int_like_precision",
            "test_store_multiindex",
            "test_to_timestamp_quarterly_bug",
            "test_xs_integer_key",
            "test_agg_must_agg",
            "_check_moment_func",
            "test_default_delimiter",
            "time_categorical_level",
            "test_encoding_options",
            "test_expanding_quantile",
            "_validate_parse_dates_arg",
            "_save_header",
            "_next_iter_line",
            "test_operators_none_as_na",
            "test_dti_tz_convert_hour_overflow_dst_timestamps",
            "test_loc_getitem_label_array_like",
            "test_enable_data_resource_formatter",
            "time_read_store_table_wide",
            "_drop_labels_or_levels",
            "test_pi_add_timedeltalike_minute_gt1",
            "test_tz_convert_roundtrip",
            "id_func",
            "mmap_file",
            "test_replace_dtypes",
            "test_td_rsub_offset",
            "section_titles",
            "test_dt_accessor_updates_on_inplace",
            "test_applymap_box",
            "test_seriesgroupby_observed_true",
            "test_ix_loc_setitem_consistency",
            "test_ns_index",
            "decompress_file",
            "test_integer_with_zeros",
            "check_nancorr_nancov_2d",
            "test_date_range_bms_bug",
            "__str__",
            "test_custom_asserts",
            "test_subclass_iterrows",
            "test_multiby",
            "test_integer",
            "test_dataframe_dummies_with_categorical",
            "test_constructor_no_precision_warns",
            "test_to_coo",
            "test_multiple_date_col_custom",
            "test_pad_fillchar",
            "create_pandas_abc_type",
            "test_concat_NaT_series_dataframe_all_NaT",
            "_split_line",
            "test_datetime_outofbounds_scalar",
            "test_cache_updating",
            "test_non_array_raises",
            "test_maybe_promote_datetimetz_with_datetimetz",
            "test_dt64arr_naive_sub_dt64ndarray",
            "_get_space_character_free_column_resolvers",
            "test_StringIO",
            "test_gcs_not_present_exception",
            "test_mixing_naive_tzaware_raises",
            "pandas_type",
            "pprint_thing_encoded",
            "get_atom_coltype",
            "test_chunksize_read_type",
            "test_replace_truthy",
            "test_pivot_timegrouper",
            "test_clipboard_copy_strings",
            "test_from_records_duplicates",
            "write_sparse_intindex",
            "__setattr__",
            "time_groupby_sort",
            "test_iterrows_corner",
            "test_stringified_slice_with_tz",
            "test_nanosecond_string_parsing",
            "check_extension",
            "_get_sqlite_column_type",
            "test_ix_duplicate_returns_series",
            "test_read_with_where_tz_aware_index",
            "test_numeric_compat2",
            "test_complibs_default_settings",
            "custom_dialect",
            "test_skip_rows_bug",
            "test_endswith",
            "_unstack_frame",
            "test_asfreq_combined_pi",
            "test_get_level_lengths_un_sorted",
            "test_update_deprecation",
            "test_nth_empty",
            "test_series_box_timestamp",
            "test_ngroup_matches_cumcount",
            "test_conv_quarterly",
            "test_generator_warnings",
            "test_cython_agg_nothing_to_agg",
            "test_donot_overwrite_index_name",
            "test_consistent_coerce_for_shapes",
            "_isna_old",
            "test_display_format",
            "test_freq_validation_with_nat",
            "_eval_single_bin",
            "test_col_substring_of_stubname",
            "test_is_equal_dtype",
            "_get_subheader_index",
            "test_map_int",
            "test_assign_order",
            "test_thorough_mangle_names",
            "test_iterator_stop_on_chunksize",
            "_make_labels",
            "strip",
            "test_reading_multiple_specific_sheets",
            "time_getitem_slice",
            "test_timeseries_repr_object_dtype",
            "test_hasnans_unchached_for_series",
            "_convert_listlike_indexer",
            "_get_time_stamp",
            "test_multiindex_name",
            "test_reindex_pad",
            "float_frame_fill0",
            "test_binary_ufunc_with_index",
            "test_dtypes_are_correct_after_column_slice",
            "assert_offset_equal",
            "_set_dtype",
            "test_combine_le",
            "test_td64arr_mul_td64arr_raises",
            "test_replace_regex_metachar",
            "test_asarray_homogenous",
            "test_array_unboxes",
            "test_1000_sep_with_decimal",
            "test_slice_non_numeric",
            "test_different_nans",
            "test_df_div_zero_array",
            "test_contains_top_level",
            "test_loc_getitem_array",
            "test_read_write_reread_dta14",
            "test_pindex_qaccess",
            "test_multiby_heterogeneous_types",
            "test_get_offset",
            "test_setitem_chained_setfault",
            "chck_ncols",
            "test_transform_coercion",
            "test_copy_method_kwargs",
            "test_stack_order_with_unsorted_levels",
            "_has_valid_tuple",
            "_reconstruct_data",
            "test_from_to_scipy_object",
            "test_ewmcorr",
            "test_is_string_dtype",
            "test_get_axis",
            "test_nonsense_func",
            "test_spline_interpolation",
            "test_Millisecond",
            "check_comprehensiveness",
            "test_set_index_directly",
            "test_from_tuples_empty",
            "parse_results",
            "dtype",
            "test_query_multiindex_get_index_resolvers",
            "time_transform_ufunc_max",
            "searchsorted",
            "test_get_indexer_with_int_and_float",
            "test_fillna_consistency",
            "test_readonly_axis_blosc_to_sql",
            "test_pad_backfill_object_segfault",
            "rewrite_axis_style_signature",
            "test_merge",
            "test_replace_datetimetz",
            "format_array",
            "_flex_binary_moment",
            "test_chained_cmp_and_in",
            "validate_operand",
            "test_invalid_parse_delimited_date",
            "time_scalar_function_single_col",
            "test_intercept_builtin_sum",
            "test_ewmvar",
            "_restore_dropped_levels_multijoin",
            "time_get_dummies",
            "test_int_to_datetime_format_YYYYMMDD_typeerror",
            "makeCustomIndex",
            "test_constructor_range_based_deprecated_different_freq",
            "test_to_csv_doublequote",
            "assert_is_valid_plot_return_object",
            "test_to_latex_with_formatters",
            "_executable_exists",
            "test_geopandas",
            "time_count",
            "test_value_counts_dtypes",
            "test_to_string_unicode_two",
            "test_read_excel_skiprows_list",
            "open",
            "test_nanprod",
            "test_td64arr_rfloordiv_tdscalar_explicit",
            "test_getitem_setitem_datetime_tz_pytz",
            "ensure_str",
            "test_constructor_mixed",
            "test_drop_duplicates_NA_for_take_all",
            "test_loc_setitem_dups",
            "test_pivot_columns_lexsorted",
            "test_na_values_na_filter_override",
            "test_hist_secondary_legend",
            "test_constructor_unsigned_dtype_overflow",
            "test_rank_dense_method",
            "_comp_method_SERIES",
            "test_categorical_index_repr_datetime_ordered",
            "test_kde_colors",
            "test_plot_xy",
            "test_rank_min_pct",
            "test_frame_basic_dtypes",
            "test_timezones_fixed",
            "_get_column_names_and_types",
            "test_timedelta_range",
            "test_tzlocal_maybe_get_tz",
            "_wrap_applied_output",
            "test_apply_with_mutated_index",
            "test_get_numeric_data",
            "_adjust_dates_anchored",
            "test_asarray_tz_naive",
            "test_agg",
            "test_get_level_lengths",
            "dtypes",
            "nth",
            "test_date_range_fy5252",
            "test_format_pre_1900_dates",
            "corrwith",
            "parse_all_fields",
            "test_str",
            "test_getitem_setitem_integers",
            "_offset",
            "test_union3",
            "test_encode_decode_errors",
            "test_is_sparse",
            "test_asarray_tz_aware",
            "test_timestamp_equality_different_timezones",
            "test_timestamp_to_datetime_explicit_dateutil",
            "test_unstack_odd_failure",
            "test_downcast",
            "test_pipe",
            "test_drop_by_numeric_label_errors_ignore",
            "_bool_agg",
            "is_list_like",
            "test_repr_summary",
            "test_multiple_open_close",
            "test_nat_operations",
            "test_unary_operators",
            "time_large_get_loc",
            "test_mixed_dtype",
            "_get_compressed_labels",
            "test_allow_exact_matches",
            "test_crosstab_multiple",
            "test_overflow",
            "register_dataframe_accessor",
            "all",
            "build_border",
            "test_loc_setitem_datetime",
            "_bank_data",
            "test_custom_var_name",
            "test_fill_value_reindex",
            "test_sort_values_inplace",
            "test_timestamp_tz_localize_nonexistent_raise",
            "test_agg_apply_corner",
            "soft_convert_objects",
            "lookup",
            "test_invalid_dtype",
            "_check_isinstance",
            "test_categorical_index_repr_datetime",
            "test_truncate_with_different_dtypes",
            "test_other_timedelta_unit",
            "test_overlaps_interval",
            "test_frame_empty",
            "test_file_handle_mmap",
            "test_object_dtype_ok",
            "test_pass_spec_to_storer",
            "test_pi_sub_period",
            "test_equal_but_different",
            "test_no_na_filter_on_index",
            "test_pad_require_monotonicity",
            "_shallow_copy_with_infer",
            "test_to_weekly_resampling",
            "test_reindex_columns_method",
            "test_float_trim_zeros",
            "get_value",
            "test_categorical",
            "test_filter_multiple_timestamp",
            "test_to_timestamp_repr_is_code",
            "assert_framelist_equal",
            "_test_all_offsets",
            "test_pi_add_sub_timedeltalike_freq_mismatch_monthly",
            "test_dataframe_compression_defaults_to_infer",
            "test_merge_index_singlekey_right_vs_left",
            "_check_accum_op",
            "test_chunksize_with_compression",
            "nanany",
            "test_join_float64_float32",
            "time_lambda_sum",
            "test_str_cat_mixed_inputs",
            "test_unsortedindex",
            "test_hist_df_legacy",
            "test_apply_typecast_fail",
            "test_drop_col_still_multiindex",
            "test_sqlalchemy_type_mapping",
            "test_ohlc_5min",
            "time_by_object",
            "test_regex_replace_list_obj",
            "test_bool_ops_warn_on_arithmetic",
            "test_join_on_fails_with_wrong_object_type",
            "test_grouping_grouper",
            "test_copy_tzaware",
            "test_fillna_categorical",
            "test_rank_object_raises",
            "validate_bool_kwarg",
            "test_bin32",
            "test_casemethods",
            "test_1700",
            "test_loc_slice",
            "_assert_all_na",
            "_internal_get_values",
            "test_infer_freq",
            "test_concat_tz_series_tzlocal",
            "test_ops_notimplemented",
            "test_array_reshaped",
            "test_zip_error_invalid_zip",
            "test_class_ops_pytz",
            "test_getitem_pydatetime_tz",
            "test_value_counts_nat",
            "test_loc_getitem_bool_diff_len",
            "test_drop_tuple",
            "test_adjoin",
            "test_read_write_dta11",
            "test_take_fill_value_new_raises",
            "maybe_cast_item",
            "testPackUTF32",
            "trim_join_unit",
            "test_unbox_scalar",
            "test_variable_labels",
            "test_concat_sparse_dense",
            "test_unique_label_indices",
            "test_describe_with_tz",
            "test_mask_with_boolean",
            "test_mul_int_array",
            "test_range_slice",
            "test_append_with_empty_string",
            "is_period_arraylike",
            "test_transpose_tzaware_2col_mixed_tz",
            "time_write_store_table_mixed",
            "test_rank_2d_tie_methods",
            "test_index_name_retained",
            "test_duplicated_subset",
            "test_subset",
            "test_date_range_timestamp_equiv_explicit_dateutil",
            "test_flex_binary_moment",
            "test_repr_categorical_dates_periods",
            "test_loc_getitem_label_out_of_range",
            "test_int_int",
            "median",
            "test_loc_empty_list_indexer_is_ok",
            "unary_fns_for_ne",
            "test_frame_apply_dont_convert_datetime64",
            "test_weekmask",
            "test_astype_category",
            "test_frame_setitem_ix",
            "time_series_align_left_monotonic",
            "get_console_size",
            "test_groupby_sort_multiindex_series",
            "test_astype_object_with_nat",
            "test_wide_repr",
            "write_array",
            "test_sharey_and_ax",
            "test_timestamp_in_columns",
            "test_iso_constructor_raises",
            "test_single_variable",
            "test_multi_line_expression_not_inplace",
            "test_xs_setting_with_copy_error_multiple",
            "test_nanstd_nans",
            "_convert_tolerance",
            "test_sparse_max_row",
            "test_to_latex",
            "test_preserve_empty_rows",
            "test_timestamp_constructor_tz_utc",
            "is_unsigned_integer_dtype",
            "sparse",
            "test_bool_ops_with_constants",
            "_grouped_plot",
            "test_frame_datetime64_duplicated",
            "test_query_with_nested_strings",
            "test_v12_compat",
            "test_concat_tz_not_aligned",
            "test_resample_single_group",
            "test_groupby_extension_transform",
            "test_skip_rows_blank",
            "test_rank_dense_pct",
            "test_binop_other",
            "test_CategoricalAccessor_index_deprecation",
            "test_setitem_raises",
            "_get_listlike_indexer",
            "epoch_1960",
            "_groupby_and_merge",
            "test_seriesgroupby_observed_false_or_none",
            "applymap",
            "test_validate_any_all_out_keepdims_raises",
            "test_reindex_int",
            "test_an_exception_in_objecthook1",
            "test_tdi_round",
            "test_deep_skip_rows",
            "get_table",
            "select_dtypes",
            "test_utf8_bom",
            "test_bad_reduce_raises",
            "test_date_query_with_NaT",
            "_get_wom_rule",
            "test_banklist_no_match",
            "test_from_values_or_dtype",
            "test_from_frame_dtype_fidelity",
            "test_rolling_mean",
            "test_convert_json_field_to_pandas_type",
            "set_categories",
            "test_show_null_counts",
            "_create_sp_tsseries",
            "test_constructor_iterable",
            "run_series",
            "test_format_date_axis",
            "test_query_non_str",
            "test_read_write_dta12",
            "test_asfreq_mult_pi",
            "test_td64_df_add_int_frame",
            "is_gcs_url",
            "is_platform_mac",
            "test_timestamp_multiindex_indexer",
            "test_get_indexer_length_one_interval",
            "_combine_match_columns",
            "test_subplots_timeseries_y_axis_not_supported",
            "_add_delegate_accessors",
            "use_numexpr",
            "test_string_factorize",
            "test_invalid_dtype_error",
            "test_transactions",
            "testSimpleValue",
            "test_series_frame_radd_bug",
            "test_as_array_int_bool",
            "get_callable_name",
            "format",
            "test_rowspan_only_rows",
            "test_dti_iadd_int",
            "real",
            "test_datetimeindex_sub_datetimeindex_overflow",
            "test_usecols_dtypes",
            "_maybe_update_cacher",
            "test_union_name_preservation",
            "test_preserve_dtypes",
            "test_large_mi_dataframe_indexing",
            "test_replace_simple_nested_dict_with_nonexistent_value",
            "test_scalar",
            "_repr_html_",
            "get_loc",
            "test_to_latex_multiindex_dupe_level",
            "test_url",
            "get_group_index",
            "test_ufunc_compat",
            "test_equals_op_mismatched_multiindex_raises",
            "test_dont_modify_colors",
            "_arith_method_SERIES",
            "test_astype_datetime64tz",
            "test_reset_index_datetime",
            "test_ndarray_compat_properties",
            "test_groupby_extension_agg",
            "test_fallback_singular",
            "test_parse_public_s3_bucket_chunked",
            "test_take_series",
            "validate_window_func",
            "test_catch_infinite_loop",
            "_getitem_tuple",
            "test_rcParams_bar_colors",
            "test_take_misc",
            "test_add_timestamp_raises",
            "test_string_slice",
            "_set_ticklabels",
            "test_frame_describe_unstacked_format",
            "test_td_add_mixed_timedeltalike_object_dtype_array",
            "shape",
            "test_dataframe",
            "test_get_loc_duplicates",
            "test_name_repr",
            "test_to_csv_string_array_ascii",
            "test_merge_on_extension_array_duplicates",
            "_print_cline",
            "test_concat_numerical_names",
            "test_tseries_indices_series",
            "test_read_json_large_numbers",
            "test_merge_index_types",
            "test_high_freq",
            "test_to_period_monthish",
            "test_constructor_from_items_scalars",
            "test_read_jsonl",
            "_left_join_on_index",
            "partition",
            "test_api_compat",
            "test_tdi_shift_hours",
            "test_grouped_hist_layout",
            "test_all_any",
            "test_drop_duplicates_for_take_all",
            "test_unexpected_keyword",
            "test_drop_non_empty_list",
            "test_boxplot_axis_limits",
            "_check_basic_constructor",
            "__getstate__",
            "test_int_index",
            "bool",
            "_get_next_label",
            "_invalid_indexer",
            "test_read_csv_low_memory_no_rows_with_index",
            "test_numpy_argsort",
            "tostring",
            "test_period_deprecated_freq",
            "test_set_frame_expand_extension_with_regular",
            "test_now",
            "homogenize",
            "test_sub_dti_dti",
            "test_basic_left_index_right_index",
            "assert_stat_op_calc",
            "test_concat_rename_index",
            "test_align_mixed_type",
            "test_groupby_apply_return_empty_chunk",
            "_get_all_tables",
            "time_multiby",
            "_validate_freeze_panes",
            "test_logical_ops_invalid",
            "_get_lines",
            "time_dup_string_dates_and_format",
            "test_map_defaultdict",
            "_get_credentials",
            "test_groupby_as_index_agg",
            "sanitize_array",
            "test_constructor_empty",
            "test_binary_ops_docs",
            "test_query_lex_compare_strings",
            "test_expanding_corr_pairwise",
            "test_internal_null_byte",
            "test_to_timedelta_float",
            "test_really_large_in_arr",
            "pp_options_list",
            "sem",
            "test_datetime_bool",
            "test_default_encoding",
            "time_write_excel",
            "test_getitem_dataframe",
            "test_agg_with_datetime_index_list_agg_func",
            "test_slice_keep_name",
            "_get_data_label",
            "test_today",
            "test_frame_mi_access_returns_series",
            "test_info_memory_usage_deep_not_pypy",
            "test_comment_header",
            "_values_for_rank",
            "test_hist_layout_with_by",
            "test_to_html_decimal",
            "test_to_string_specified_header",
            "test_to_string_float_formatting",
            "test_where_with_numeric_data_and_other",
            "test_where_axis",
            "test_transform_and_agg_err",
            "test_to_timestamp_pi_combined",
            "test_boxplot_subplots_return_type",
            "test_subtype_float",
            "_count_rows",
            "make_mixed_dataframe_v2",
            "test_sum",
            "test_hexbin_with_c",
            "test_rolling_quantile",
            "test_query_single_element_booleans",
            "_make_engine",
            "test_dt64arr_add_sub_relativedelta_offsets",
            "test_separator_date_conflict",
            "test_setitem_expand_with_extension",
            "put",
            "test_mod_zero",
            "slice_locs",
            "test_bool_ops_column_name_dtype",
            "test_dateindex_conversion",
            "test_to_datetime_fixed_offset",
            "_align_core_single_unary_op",
            "test_unique_level",
            "time_pivot_table",
            "_stack_arrays",
            "test_divmod_ndarray",
            "test_ptp",
            "test_to_string_with_datetime64_hourformatter",
            "test_xs_values",
            "test_inconsistent_number_of_rows",
            "test_str8",
            "info",
            "test_join_multiindex",
            "cat",
            "_add_redirects",
            "cumprod",
            "test_str_label_slicing_with_negative_step",
            "time_merge_object",
            "test_where_raises",
            "test_roll_qtr_day_not_mod_unequal",
            "test_dti_tz_convert_hour_overflow_dst",
            "test_internal_eof_byte_to_file",
            "test_mixed_freq_irreg_period",
            "test_array_object_dtype",
            "_constructor_expanddim",
            "_align_series",
            "test_fillna_datetime",
            "test_resample_single_period_timedelta",
            "is_boolean",
            "test_concat_sparse_dense_rows",
            "test_irreg_dtypes",
            "test_date_tz",
            "test_dti_business_summary_pytz",
            "do_setup",
            "dispatch_to_index_op",
            "test_to_datetime_default",
            "test_parsers_timestring",
            "test_sort_index_na_position_with_categories",
            "test_to_datetime_cache_series",
            "test_pivot_no_level_overlap",
            "test_dti_custom_business_summary",
            "test_slice_locs_not_contained",
            "test_is_period",
            "test_select_iterator",
            "test_from_custom_template",
            "test_add_extension_scalar",
            "test_pickle_freq",
            "test_unpack_bytearray",
            "_bn_ok_dtype",
            "as_sparse_array",
            "test_unimplemented_dtypes_table_columns",
            "test_loc_scalar",
            "test_last_week_of_month_on_offset",
            "test_apply_box",
            "test_to_datetime_different_offsets",
            "test_timedelta64",
            "test_basic_setitem_with_labels",
            "test_logical_ops_bool_frame",
            "test_integer_thousands_alt",
            "test_header_not_enough_lines",
            "test_invert",
            "compress",
            "test_convert_dates_infer",
            "cartesian_product",
            "test_repr_array",
            "test_reindex_api_equivalence",
            "test_read_excel_blank",
            "test_timedelta",
            "test_cumcount_empty",
            "test_mean_corner",
            "test_drop_duplicates_tuple",
            "test_where_index_datetime",
            "test_construct_from_string_raises",
            "test_EA_types",
            "_reindex_output",
            "test_join_left",
            "test_exceptions",
            "test_mean_datetimelike_numeric_only_false",
            "test_categorical_writing",
            "test_self_join_multiple_categories",
            "test_ops_series_timedelta",
            "reset_display_options",
            "test_4d_ndarray_fails",
            "test_qcut_binning_issues",
            "test_dti_add_tick_tzaware",
            "test_rowwise_alt",
            "test_rank_tie_methods",
            "assert_categorical_equal",
            "test_pivot_table_with_margins_set_margin_name",
            "test_construction_with_conversions",
            "_parse_subtype",
            "test_i8",
            "_reset_cacher",
            "slice_indexer",
            "test_crosstab_ndarray",
            "test_line_colors_and_styles_subplots",
            "_check_implicitly_registered",
            "test_apply_empty",
            "test_frame_mi_access",
            "test_read_json_table_dtype_raises",
            "_do_convert_categoricals",
            "test_pivot_preserve_dtypes",
            "_get_stacked_values",
            "test_align",
            "test_ops_nat_mixed_datetime64_timedelta64",
            "test_concat_keys_specific_levels",
            "test_to_period_millisecond",
            "test_computer_sales_page",
            "test_concat_datetime_datetime64_frame",
            "test_pi_sub_isub_timedeltalike_daily",
            "test_setitem_with_tz_dst",
            "test_dt64_series_add_mixed_tick_DateOffset",
            "test_join_multi_multi",
            "test_bar_edge",
            "_concat_objects",
            "test_scipy_compat",
            "concatenate_block_managers",
            "test_index_false_to_json_split",
            "test_sort_index_categorical_index",
            "is_type_compatible",
            "test_drop_duplicates_series_vs_dataframe",
            "test_append_with_timedelta",
            "__setitem__",
            "test_dropna_empty",
            "test_quantile_nan",
            "test_arith_flex_frame_corner",
            "test_complex_sorting",
            "test_groupby_agg_observed_true_single_column",
            "test_to_datetime_dtarr",
            "test_missing_args_or_kwargs",
            "test_sub_offset_nat",
            "test_setitem_cast",
            "get_slice_bound",
            "_is_cached",
            "test_coercion_with_loc",
            "test_set_value_with_index_dtype_change",
            "test_from_arrays_empty",
            "_format_col",
            "assert_attr_equal",
            "test_bounds_with_different_units",
            "test_fillna_invalid_method",
            "test_join_on_inner",
            "_get_xticks",
            "test_multiple_date_col_multiple_index_compat",
            "_try_cast",
            "test_minmax_period",
            "test_dst",
            "_get_with",
            "test_secondary_legend",
            "infer_dtype_from_object",
            "size_to_pt",
            "test_xy_args_integer",
            "get_commit_vitals",
            "time_read_hdf",
            "test_tdi_mul_int_array",
            "test_kde_missing_vals",
            "column_types",
            "test_parse_header_of_non_string_column",
            "test_replace_string_with_number",
            "test_repr_dimensions",
            "test_repr_no_backslash",
            "test_period_set_index_reindex",
            "test_read_sql_delegate",
            "values",
            "test_to_series_with_arguments",
            "test_resample_group_info",
            "test_to_xarray",
            "test_read_excel_nrows_non_integer_parameter",
            "test_crosstab_margins_set_margin_name",
            "test_loc_preserve_names",
            "test_setitem_iloc_scalar_mixed",
            "test_consistency_for_boxed",
            "add_imports",
            "test_read_sql_view",
            "test_corrwith_index_union",
            "_stack_multi_columns",
            "test_from_scipy_fillna",
            "test_freq",
            "test_round_trip",
            "test_df_flex_cmp_constant_return_types_empty",
            "test_plot_submethod_works",
            "makeMultiIndex",
            "test_sparse_series_round_trip2",
            "test_to_latex_no_bold_rows",
            "test_astype_copies",
            "test_slice_keeps_name",
            "_read_sql_iris_parameter",
            "test_dt64arr_sub_timestamp",
            "area",
            "test_constructor_list_of_derived_dicts",
            "test_days_neg",
            "__new__",
            "test_intersection",
            "test_setitem_boolean",
            "test_multiindex_set_index",
            "test_modulo2",
            "expanding",
            "test_subplots",
            "test_getitem_label_list_with_missing",
            "test_cdaterange_weekmask",
            "time_transform_multi_key1",
            "test_series_box_timedelta",
            "_cast_types",
            "test_observed_codes_remap",
            "test_getitem_bool_index_single",
            "test_all_custom_freq",
            "last",
            "test_aggregate_normal",
            "test_na_values_with_dtype_str_and_na_filter",
            "_value_formatter",
            "test_where_numeric_with_string",
            "test_index_namedtuple",
            "test_week_of_month_fake",
            "test_long",
            "test_nanvar",
            "test_isinf_scalar",
            "time_query_store_table_wide",
            "test_line_area_nan_series",
            "test_astype_dict_like",
            "test_datetime64_tz_dropna",
            "test_timestamp_constructed_by_date_and_tz",
            "_transform_fast",
            "df_strings",
            "test_td64arr_add_int_series_invalid",
            "datapath",
            "test_pivot_with_list_like_values",
            "test_take_fill",
            "check_keys_split",
            "test_usecols_relative_to_names",
            "test_constructor_maskedarray_nonfloat",
            "test_set_index_append",
            "test_apply_to_timedelta",
            "_skip_if_no_private_key_path",
            "test_assign_columns",
            "first_line_ends_in_dot",
            "test_small_strings_no_warn_zlib",
            "test_deprecated_fastpath",
            "get_series",
            "convert_value",
            "assert_bool_op_api",
            "_reverse_indexer",
            "_check_expanding",
            "test_value_labels_iterator",
            "test_frame_ctor_datetime64_column",
            "test_value_counts_uint64",
            "test_dt64arr_add_mixed_offset_array",
            "test_difference_freq",
            "_getitem_multilevel",
            "mixed_type_frame",
            "_get_label_or_level_values",
            "__array_ufunc__",
            "test_value_counts_unique_nunique",
            "test_loc_listlike_dtypes",
            "test_excessively_long_string",
            "apply",
            "time_write_store_table_dc",
            "time_frame_plot",
            "isna",
            "validate_metadata",
            "cummax",
            "test_to_latex_filename",
            "test_tab_completion_with_categorical",
            "to_gbq",
            "read_fwf",
            "test_str_cat_wrong_dtype_raises",
            "test_boolean_context_compat2",
            "test_dti_tz_localize_tzlocal",
            "test_df_gridspec_patterns",
            "test_read_chunks_columns",
            "test_apply_nanoseconds",
            "test_concat_datetimeindex_freq",
            "test_series_pad_backfill_limit",
            "test_constructor_invalid",
            "get_filepath_or_buffer",
            "test_read_xlrd_book",
            "testMap",
            "test_stat_operators_attempt_obj_array",
            "test_index_col_named",
            "test_from_inferred_categories_coerces",
            "time_from_string",
            "test_categorical_dtype_single",
            "test_concat_empty_dataframe_dtypes",
            "test_constructor_list_of_dicts",
            "test_setitem_with_different_tz",
            "_reindex_axes",
            "test_fill_consistency",
            "test_default_index",
            "test_idxmax",
            "_minmax_wrap",
            "test_as_array_float",
            "test_replace_moar",
            "testFixArray",
            "mix_ab",
            "_check_join",
            "time_set_index",
            "test_timestamp_tz_localize_nonexistent_NaT",
            "test_to_html_with_no_bold",
            "test_concat_multiindex_with_tz",
            "test_ngroup",
            "test_constructor_invalid_quarters",
            "test_arith_frame_with_scalar",
            "test_indexing_assignment_dict_already_exists",
            "test_can_serialize_dates",
            "test_prod",
            "test_resample_empty_dtypes",
            "test_non_cython_api",
            "test_constructor_fromordinal",
            "test_isin",
            "test_tdi_mul_int_series",
            "testIgnoreErrorsPack",
            "test_to_sql_replace",
            "test_concat_timedelta64_block",
            "test_columns_dtypes_invalid",
            "test_resample_anchored_intraday",
            "test_rolling_max",
            "test_append_to_multiple_dropna",
            "test_concat_keys_levels_no_overlap",
            "test_indexing_over_size_cutoff",
            "test_has_duplicates_from_tuples",
            "_scalar_data_error",
            "test_concat_period_series",
            "scipy_sem",
            "test_weird_nested_json",
            "test_comparisons_coverage",
            "test_cross_engine_fp_pa",
            "test_groupby_first_datetime64",
            "test_datetimeindex_constructor_misc",
            "test_cmov_window_special_linear_range",
            "parsed_114",
            "test_indexing_mixed_frame_bug",
            "_maybe_downcast",
            "test_td_add_pytimedelta",
            "test_constructor_sparse_dtype_str",
            "mixed_int",
            "_check_binary_ew",
            "test_indexing_dtypes_on_empty",
            "_justify",
            "test_dt64arr_add_sub_td64_nat",
            "time_pivot_table_agg",
            "_reset_group_selection",
            "test_td64arr_div_int",
            "to_dict",
            "test_constructor_int_dtype_float",
            "test_setitem_different_tz_raises",
            "test_timedelta64_operations_with_DateOffset",
            "test_factorize_tuple_list",
            "test_pi_add_iadd_timedeltalike_M",
            "test_to_datetime_today",
            "as_unordered",
            "test_invalid_date_kwarg_with_string_input",
            "yields",
            "test_shift_dtype_fill_value",
            "test_excel_roundtrip_indexname",
            "test_api_compat_before_use",
            "test_rank",
            "test_from_weekly_resampling",
            "test_arith_non_pandas_object",
            "test_combine_generic",
            "test_dti_cmp_object_dtype",
            "test_filter_bad_shapes",
            "_handle_shared_axes",
            "test_to_timedelta_via_apply",
            "deprecate_kwarg",
            "test_to_records_index_name",
            "prune",
            "test_concat_multiindex_with_keys",
            "test_float_same_index_comparison",
            "test_setattr_warnings",
            "_daily_finder",
            "test_compression_size_fh",
            "_get_time_delta_bins",
            "shift",
            "test_string",
            "as_json_table_type",
            "prep_ndarray",
            "test_replace_series_datetime_tz",
            "_node_not_implemented",
            "test_period_cons_weekly",
            "_get_formatted_values",
            "_get_plot_backend",
            "is_sequence",
            "test_bar_align_zero_axis_none",
            "_check_mixed_float",
            "_astype",
            "_trim_zeros_complex",
            "test_asfreq_corner",
            "test_append_concat",
            "test_float_index_to_mixed",
            "_info_repr",
            "test_constructor_column_duplicates",
            "test_constructor_timedelta_window_and_minperiods",
            "test_constructor_tz_mixed_data",
            "_get_ind",
            "_get_center_of_mass",
            "test_concat_datetime64_block",
            "test_select_dtypes_str_raises",
            "test_isna_for_inf",
            "test_mixed_freq_hf_first",
            "test_iloc_non_unique_indexing",
            "test_insert",
            "test_cython_fail_agg",
            "test_unique_index",
            "_engine_type",
            "test_set_index_verify_integrity",
            "test_constructor_fromarraylike",
            "test_boxplot",
            "rands",
            "test_to_latex_multicolumnrow",
            "test_merge_datetime64tz_with_dst_transition",
            "test_numpy_array_equal_copy_flag",
            "test_reset_index_multiindex_nan",
            "insert",
            "_validate_color_args",
            "test_constructor_errors",
            "replace_list",
            "test_publishes",
            "test_sparse_series_fillna_limit",
            "test_list_grouper_with_nat",
            "left_df",
            "test_symmetric_difference_non_index",
            "time_by_int",
            "test_replace_bool_with_string",
            "test_numpy_argmin_deprecated",
            "test_groupby_nonobject_dtype",
            "test_droplevel_list",
            "test_slice_replace",
            "time_modulo",
            "test_subdays_neg",
            "test_repr_truncates_terminal_size_full",
            "test_is_monotonic_decreasing",
            "test_agg_compat",
            "test_legacy_table_fixed_format_read_py2",
            "test_deprecate_option",
            "test_td_sub_offset",
            "test_convert_non_hashable",
            "test_setitem_mixed_datetime",
            "test_rolling_kurt_edge_cases",
            "test_reconstruct_remove_unused",
            "render_pep440",
            "test_publishes_not_implemented",
            "validate_expanding_func",
            "test_read_from_http_url",
            "test_set_index_dst",
            "test_skiprows_inference",
            "_make_min_count_stat_function",
            "test_getitem_setitem_ix_negative_integers",
            "time_delta_int_tstamp_lines",
            "test_min_periods",
            "test_join_many",
            "test_fillna_dict_series",
            "test_dti_constructor_numpy_timeunits",
            "test_factorize_tz",
            "test_datetime_date",
            "construct_1d_object_array_from_listlike",
            "test_filter_dropna_with_empty_groups",
            "test_union_bug_1730",
            "test_stack_sparse_frame",
            "test_append_some_nans",
            "test_modf",
            "test_str_accessor_updates_on_inplace",
            "test_loc_getitem_label_slice",
            "test_to_csv_from_csv3",
            "multiindex_dataframe_random_data",
            "test_resample_upsampling_picked_but_not_correct",
            "test_drop_duplicates_with_duplicate_column_names",
            "test_td_construction_with_np_dtypes",
            "test_constructor_errors_tz",
            "test_to_datetime_utc_true_with_series_datetime_ns",
            "time_different_python_functions_singlecol",
            "test_prevent_casting",
            "test_period_ordinal_start_values",
            "test_lookup_raises",
            "test_repr_utcoffset",
            "test_regex_replace_numeric_to_object_conversion",
            "validate_data_columns",
            "test_loc_label_slicing",
            "test_repeat_range",
            "test_dti_repr_short",
            "test_dateoffset_misc",
            "current_packers_data",
            "test_join_many_mixed",
            "test_class_ops_dateutil",
            "test_compound_deprecated",
            "test_pi_add_offset_array",
            "skip_if_no_pandas_parser",
            "test_to_timedelta_on_missing_values",
            "test_bs4_version_fails",
            "time_add_overflow_both_arg_nan",
            "test_operators",
            "test_series_append_dst",
            "test_group_shift_with_null_key",
            "test_repr_nat",
            "test_invalid_separator",
            "test_fromDict",
            "test_read_from_pathlib_path",
            "test_stat_op_api",
            "test_resample_basic_grouper",
            "_pat_wrapper",
            "test_rank_methods_frame",
            "test_timestamp_compare_scalars",
            "test_view_asi8",
            "test_random_state",
            "test_groupby_as_index_series_scalar",
            "test_str_bool_return",
            "ensure_int_or_float",
            "test_groupby_mixed_type_columns",
            "test_date_parser_int_bug",
            "test_rolling_apply_mutability",
            "_simple_new",
            "_drop_axis",
            "time_parse_dateutil",
            "time_get_loc",
            "test_dti_tz_localize",
            "test_with_listlike_columns",
            "_trim_front",
            "test_where_subset",
            "test_rename_categories_dict",
            "setup_class",
            "_join_level",
            "test_monthly_resample_error",
            "test_decompression_regex_sep",
            "test_resample_nunique_with_date_gap",
            "test_loc_getitem_int_raises_exception",
            "test_compare_timedelta64_zerodim",
            "test_index_str_accessor_visibility",
            "read_index_legacy",
            "test_agg_api",
            "test_slice_with_negative_step",
            "test_datetime_categorical_comparison",
            "to_coo",
            "_get_simple_index",
            "test_any_none",
            "test_as_json_table_type_timedelta_dtypes",
            "test_period",
            "test_business_freq",
            "test_excelfile_fspath",
            "test_irregular_datetime",
            "make_axis_dummies",
            "_make_timestamp",
            "_check_for_bom",
            "test_spam_header",
            "test_write_fspath_hdf5",
            "test_series_append_aware",
            "_validate_where",
            "test_read_nrows",
            "test_read_one_empty_col_no_header",
            "test_replace_bool_with_string_no_op",
            "str_strip",
            "test__is_dtype_type_sparse",
            "test_xs_level_multiple",
            "test_parse_dates_empty_string",
            "_op_tests",
            "combine",
            "_process_single_doc",
            "test_get_loc_datetimelike_overlapping",
            "day_name",
            "test_round_invalid",
            "test_string_na_nat_conversion",
            "test_parse_public_s3_bucket",
            "_post_plot_logic",
            "test_to_html_timestamp",
            "test_mutability",
            "test_long_series",
            "test_to_csv_numpy_16_bug",
            "test_get_level_values",
            "_maybe_evaluate_binop",
            "assert_labels_dropped",
            "test_readjson_chunks_series",
            "__call__",
            "test_consolidate_datetime64",
            "test_to_hdf_with_min_itemsize",
            "_validate_for_numeric_unaryop",
            "to_numeric",
            "test_dictify",
            "test_any_all_np_func",
            "test_groupby_monotonic",
            "test_monotone_DTI_indexing_bug",
            "test_to_datetime_cache",
            "test_with_local_timezone_pytz",
            "get_storer",
            "test_csv_mixed_type",
            "test_cant_compare_tz_naive_w_aware",
            "test_s3_roundtrip",
            "test_select_dtypes_exclude_using_list_like",
            "test_nanvar_nans",
            "is_uniform_join_units",
            "test_append_records",
            "test_xs_with_duplicates",
            "test_constructor_complex_dtypes",
            "test_mutated",
            "test_closed_one_entry",
            "_tidy_repr",
            "test_stack_unstack_multiple",
            "test_bad_resolver_raises",
            "_get_frame_result_type",
            "test_negone_ordinals",
            "test_ragged_quantile",
            "test_reindex_with_datetimes",
            "test_view",
            "test_melt_missing_columns_raises",
            "test_replace_inplace",
            "test_to_csv_index_no_leading_comma",
            "is_freq_type",
            "test_columns_with_dups",
            "test_to_latex_bold_rows",
            "show_col_idx_names",
            "test_mixed_ops",
            "test_value_counts_datetime_tz",
            "test_datetimeindex_accessors",
            "test_invalid_plot_data",
            "test_partial_setting_with_datetimelike_dtype",
            "_convert_data",
            "test_nonexistent_path",
            "test_dialect_str",
            "test_nat_representations",
            "test_all_any_params",
            "str_pad",
            "test_groupby_datetime64_32_bit",
            "test_astype_to_same",
            "test_loc_multiindex_too_many_dims_raises",
            "test_boxplot_legacy1",
            "test_default_col_names",
            "test_slice_quarter",
            "test_bool_na_values",
            "test_utf16_bom_skiprows",
            "test_apply_mixed_datetimelike",
            "test_multiindex_contains_dropped",
            "test_nanmax",
            "test_set_levels_codes_directly",
            "_convert_bin_to_numeric_type",
            "test_mixed",
            "test_loc_getitem_label_list_fails",
            "format_type",
            "test_datetimeindex_union_join_empty",
            "str_extractall",
            "frame_of_index_cols",
            "test_resample_not_monotonic",
            "test_dt_conversion_preserves_name",
            "test_is_timedelta64_dtype",
            "test_processing_order",
            "tzframe",
            "test_slice_year",
            "test_freq_validation",
            "time_period_to_datetime",
            "test_center_ljust_rjust_fillchar",
            "_get_seek_variable_labels",
            "test_read_empty_dta",
            "test_fails_and",
            "test_east_asian_len",
            "test_operators_datetimelike",
            "test_fillna_dataframe",
            "test_to_excel_multiindex_no_write_index",
            "test_period_from_ordinal",
            "is_uniform_reindex",
            "_factorize_keys",
            "_set_group_selection",
            "test_to_sparse_preserve_multiindex_names_columns",
            "test_nonunique_assignment_1750",
            "check_compressed_urls",
            "use_numexpr_cb",
            "test_invalid_complib",
            "test_concatlike_common_period_diff_freq_to_object",
            "test_constructor_list_of_lists",
            "test_constructor_invalid_items_unused",
            "test_filter_out_no_groups",
            "test_store_index_name",
            "test_pct_change",
            "test_render_double",
            "test_all_not_none",
            "test_dt64_series_astype_object",
            "test_add_column_with_pandas_array",
            "test_compare_frame",
            "test_expanding_corr_diff_index",
            "test_td64arr_rmod_tdscalar",
            "test_applymap_subset_multiindex",
            "test_union_different_types",
            "test_parse_dates_combine",
            "skew",
            "test_xs_partial",
            "aggregate",
            "test_get_value_duplicates",
            "test_get_indexer_strings_raises",
            "test_multiple_date_col_timestamp_parse",
            "test_positional_take_unobserved",
            "test_write_row_by_row",
            "test_concat_tz_NaT",
            "test_convert_non_ns",
            "test_unpacker_hook_refcnt",
            "test_list_slice",
            "register_plotting_backend_cb",
            "test_stringify_path_localpath",
            "test_time_accessor",
            "__add__",
            "test_read_py2_hdf_file_in_py3",
            "density",
            "test_asfreq_resample_set_correct_freq",
            "test_dense_to_sparse",
            "test_nan_handling",
            "test_dataframe_dummies_drop_first_with_categorical",
            "test_names",
            "test_td_floordiv_null_scalar",
            "test_construction_caching",
            "test_rolling_median",
            "test_getitem_fill_value",
            "test_resample_tz_localized",
            "test_setting_with_copy_bug",
            "test_to_datetime_tz_pytz",
            "test_parse_nanoseconds_with_formula",
            "test_repr_column_name_unicode_truncation_bug",
            "test_sort",
            "test_get_loc_cast_bool",
            "_join_i8_wrapper",
            "test_union_bug_4564",
            "bar",
            "test_categorical_repr_datetime_ordered",
            "test_to_datetime_infer_datetime_format_inconsistent_format",
            "test_ix_setitem_out_of_bounds_axis_1",
            "test_apply_dict_depr",
            "test_stack",
            "time_replace_tz",
            "test_apply_multiindex_fail",
            "test_misc_example",
            "test_constructor_Series_differently_indexed",
            "apply_series_generator",
            "test_td_floordiv_numeric_series",
            "test_groupby_transform",
            "_convert_list_indexer",
            "test_ops",
            "test_parsers",
            "_series_name",
            "_is_dtype_type",
            "test_arg_for_errors_in_astype_dictlist",
            "categorical",
            "test_invalid_variable_labels",
            "is_sparse",
            "test_integer_values_and_tz_deprecated",
            "test_reindex_empty_series_tz_dtype",
            "test_sort_index_and_reconstruction_doc_example",
            "test_stringify_path_fspath",
            "hash_pandas_object",
            "doc_parameters",
            "xs",
            "test_parr_add_sub_datetime_scalar",
            "test_ix_categorical_index",
            "test_constructor_for_list_with_dtypes",
            "test_unique_na",
            "test_nan_multiple_containment",
            "test_set_index_drop_inplace",
            "test_constructor_strptime",
            "test_to_coo_text_names_text_row_levels_nosort",
            "test_2d_float32",
            "_sort_levels_monotonic",
            "test_any_all",
            "test_interp_limit",
            "test_mixed_freq_irregular_first",
            "_hash_categorical",
            "test_iloc_getitem_doc_issue",
            "test_drop_duplicates_inplace",
            "get_new_index",
            "test_append_mixed_dtypes",
            "test_unicode_repr_doesnt_raise",
            "test_nsmallest_nlargest",
            "create",
            "test_cut_pass_labels_compat",
            "test_duplicate_groupby_issues",
            "test_interp_rowwise",
            "time_melt_dataframe",
            "test_multiindex_columns_empty_level",
            "test_between_time",
            "df_letters",
            "test_constructor_range_based_deprecated",
            "test_series_append_aware_naive",
            "test_slicing",
            "test_duplicated",
            "test_delim_whitespace_custom_terminator",
            "data_for_sorting",
            "test_indexing_with_category",
            "test_float_index_non_scalar_assignment",
            "test_datetime_name_accessors",
            "test_read_hdf_errors",
            "assert_produces_warning",
            "test_agg_transform",
            "test_to_string_utf8_columns",
            "test_to_sql_method_multi",
            "ensure_index",
            "test_invalid_quantile_value",
            "test_duplicated_columns",
            "test_examples1",
            "test_grouped_box_return_type",
            "test_constructor_non_hashable_name",
            "_get_cells",
            "plot",
            "skip_if_no",
            "test_invalid_filtering",
            "test_constructor_spindex_dtype_scalar_broadcasts",
            "test_groupby_level_with_nas",
            "_index_name",
            "test_resample_with_timedeltas",
            "test_infer_dtype_bytes",
            "test_datetime_bin",
            "test_strip_lstrip_rstrip_mixed",
            "test_get_finder",
            "test_set_dtype_new_categories",
            "test_astype_with_view_mixed_float",
            "test_disallowed_nodes",
            "test_slice_locs_with_type_mismatch",
            "imag",
            "test_reader_closes_file",
            "test_mixed_freq_shared_ax",
            "test_to_datetime_format_YYYYMMDD",
            "determine_clipboard",
            "test_isin_empty",
            "test_set_reset_index",
            "test_date_range_unsigned_overflow_handling",
            "test_dti_shift_across_dst",
            "test_neg_numeric",
            "test_map_box",
            "test_timedeltas",
            "test_clip_types_and_nulls",
            "test_to_period",
            "test_doc_example",
            "align",
            "test_constructor_U",
            "test_usecols_with_single_byte_unicode_strings",
            "test_is_unique_interval",
            "test_loc_setitem_empty_append_raises",
            "test_nanops",
            "test_maybe_promote_bool_with_any",
            "test_timestamp_to_datetime_explicit_pytz",
            "interpolate",
            "test_does_not_convert_mixed_integer",
            "_convert_to_list_like",
            "test_getitem_fancy_2d",
            "test_pi_ops",
            "test_iloc_getitem_bool",
            "test_too_long",
            "test_select_dtypes_include_exclude_mixed_scalars_lists",
            "test_linspace_behavior",
            "validate_args_and_kwargs",
            "_process_rowsize_subheader",
            "invalidate_string_dtypes",
            "test_df_arith_2d_array_collike_broadcasts",
            "test_setitem_fancy_boolean",
            "test_to_excel_interval_no_labels",
            "test_colspecs",
            "setup_connect",
            "test_with_string_args",
            "test_shift_periods",
            "test_timetz_accessor",
            "property",
            "test_basic_regression",
            "test_is_overlapping",
            "test_series_ctor_datetime64",
            "test_type_promote_putmask",
            "_generate_multi_thread_dataframe",
            "test_reindex_fill_value",
            "test_is_strictly_monotonic_decreasing",
            "test_bar_subplots_center",
            "test_string_select",
            "test_wrap_aggregated_output_multindex",
            "test_from_records_dictlike",
            "_transform_item_by_item",
            "test_wom_len",
            "_format_axes",
            "test_constructor_maskedarray",
            "test_query_numexpr",
            "test_usecols_pass_non_existent_column",
            "time_floats_with_dt_index_lines",
            "test_reindex_indexer",
            "read_clipboard",
            "test_any_all_bool_only",
            "makeTimeDataFrame",
            "test_frame_from_json_precise_float",
            "test_constructor_positional",
            "test_concat_empty_and_non_empty_frame_regression",
            "test_schema",
            "center",
            "test_regex_replace_list_mixed",
            "test_to_datetime_format_microsecond",
            "test_getitem_dups_with_missing",
            "test_delta_to_tick",
            "test_construction_consistency",
            "test_compare_different_lengths",
            "test_groupby_sort_multi",
            "test_constructor_with_categorical_categories",
            "test_iadd_preserves_name",
            "equals",
            "test_from_frame",
            "test_legacy_datetimetz_object",
            "test_cumcount_dupe_index",
            "test_to_timestamp_to_period_astype",
            "test_parsers_timezone_minute_offsets_roundtrip",
            "test_complibs",
            "test_apply_ignore_failures",
            "test_to_excel_interval_labels",
            "rename",
            "test_all2",
            "_convert_scalar_indexer",
            "test_constructor_range",
            "test_large_series",
            "test_shift_nan",
            "test_unstack_number_of_levels_larger_than_int32",
            "test_dti_business_summary_dateutil",
            "test_read_s3_jsonl",
            "_read_new_header",
            "test_isin_nan_common_float64",
            "_on",
            "test_time_series_plot_color_kwargs",
            "test_no_exit_status_noerrors_for_validate_all",
            "is_file_like",
            "test_invalid_arguments",
            "test_groupby_groups_datetimeindex",
            "test_multiple_matches",
            "test_setitem_list_of_tuples",
            "test_east_asian_unicode_true",
            "test_subtraction_ops",
            "test_repr_max_seq_item_setting",
            "_generate_range_overflow_safe",
            "test_to_excel_float_format",
            "test_applymap_box_timestamps",
            "test_float_scalar_comparison",
            "test_nth_multi_index",
            "test_combineFrame",
            "test_reindex_axis",
            "test_multilevel_preserve_name",
            "quantile",
            "test_empty_csv_input",
            "test_groupby_multiple_columns",
            "test_get_duplicates",
            "time_align",
            "time_dup_seconds_and_unit",
            "test_fails_not",
            "test_to_dict_box_scalars",
            "test_to_excel_styleconverter",
            "time_series_string",
            "test_datetimeindex",
            "test_custom_grouper",
            "test_sniff_delimiter",
            "test_is_lexsorted",
            "test_insert_index_datetimes",
            "test_categorical_series_repr_period",
            "_enable_data_resource_formatter",
            "test_reduce_invalid",
            "test_nunique_preserves_column_level_names",
            "test_rolling_apply_with_pandas_objects",
            "test_from_tzaware_mixed_object_array",
            "test_setitem_fancy_1d",
            "infer_dtype_from_scalar",
            "test_constructor_dtype_list_data",
            "test_replace_invalid_kwarg",
            "_join_by_hand",
            "test_labels_deprecated",
            "test_conversion_float",
            "test_axis",
            "test_list_like_indexing",
            "test_sheets",
            "_cast_sparse_series_op",
            "test_group_ohlc",
            "test_constructor_explicit",
            "test_datetime64_fillna",
            "test_not_subperiod",
            "test_constructor_with_stringoffset",
            "_searchsorted_monotonic",
            "test_dt64arr_series_sub_tick_DateOffset",
            "get_writer",
            "test",
            "test_unsupported_type",
            "_check_label_or_level_ambiguity",
            "test_td_sub_td",
            "_iterate_column_groupbys",
            "_read_next_page",
            "test_allow_cmap",
            "test_multiindex_perf_warn",
            "time_parse_now",
            "test_construction_from_string_error_subtype",
            "test_functions_no_warnings",
            "test_parsers_iso8601_invalid",
            "test_take_preserve_name",
            "test_numpy_minmax_period",
            "test_business_freq_convert",
            "test_no_unnamed_index",
            "test_properties_annually",
            "test_rename_axis_style",
            "test_multiple_id_columns",
            "test_join_non_unique",
            "holds_integer",
            "test_combine_first_int",
            "test_hist_df",
            "test_more_than_one_ref",
            "time_merge_dataframe_integer_key",
            "compare",
            "_tables",
            "test_getitem_multi_tuple",
            "test_displayed_only",
            "test_from_codes_with_float",
            "time_datetime_field_normalize",
            "test_rank_inf",
            "test_groupby_transform_timezone_column",
            "test_ragged_min",
            "test_nonzero_single_element",
            "test_dt64arr_series_add_tick_DateOffset",
            "test_cmov_mean",
            "test_mismatched_timezone_raises",
            "_get_offset",
            "test_apply_dup_names_multi_agg",
            "test_join_multi_levels",
            "_map",
            "_get_values",
            "test_write_preserves_original",
            "test_from_dti",
            "test_update_dtype_errors",
            "test_period_cons_nat",
            "test_unsorted_index_lims",
            "test_index_groupby",
            "test_big_dates",
            "test_apply_trivial",
            "test_dataframe_dummies_prefix_sep",
            "test_is_level_reference_df_ambig",
            "test_read_hdf_open_store",
            "test_equals_op",
            "test_numeric_df_columns",
            "test_resample_ambiguous_time_bin_edge",
            "test_timezone_info",
            "test_to_html_render_links",
            "test_dateutil_tzoffset_support",
            "clean_checkout",
            "test_is_datetime_dtypes",
            "test_add_invalid",
            "test_crosstab_pass_values",
            "test_timedelta_other_units",
            "_repr_footer",
            "test_append_length0_frame",
            "test_reindex_base",
            "test_n_all_dtypes",
            "test_lookup_overflow",
            "test_set_labels_deprecated",
            "test_query_by_select_obj",
            "test_compress",
            "test_manualreset",
            "test_to_html_alignment_with_truncation",
            "test_bytes_exceed_2gb",
            "test_wide_repr_named",
            "get_pull_requests",
            "build_number_format",
            "test_iloc_getitem_labels",
            "test_take_axis_1",
            "test_single_element_ix_dont_upcast",
            "test_tuple_vars_fail_with_multiindex",
            "test_iloc_empty_list_indexer_is_ok",
            "_set_grouper",
            "test_remove_categories",
            "_assemble_from_unit_mappings",
            "test_to_csv_with_dst_transitions",
            "test_converters_no_implicit_conv",
            "test_resample_basic_from_daily",
            "test_pandas_gbq",
            "test_hist_kde_color",
            "test_between_time_axis_raises",
            "_create_missing_idx",
            "test_unstack_fill_frame_timedelta",
            "set_properties",
            "test_td64arr_div_nat_invalid",
            "_set_axis_name",
            "min",
            "qcut",
            "_flex_comp_method_FRAME",
            "test_values_consolidate",
            "time_parse_iso8601_tz",
            "test_tz_localize_ambiguous_bool",
            "test_equals_missing_values",
            "test_asfreq_mult",
            "test_multiple_date_col",
            "test_extractall_single_group",
            "test_decimals",
            "test_nat_comparison_tzawareness",
            "get_base_missing_value",
            "test_downsample_but_actually_upsampling",
            "walk",
            "test_construction_from_period",
            "_load_test3_data",
            "test_infer_compression_from_path",
            "test_unknown_attribute",
            "test_series_groupby_plotting_nominally_works",
            "test_doc_string",
            "_maybe_process_deprecations",
            "test_plot_single_color",
            "test_from_array_keeps_base",
            "test_frame_add_tz_mismatch_converts_to_utc",
            "test_double_quote",
            "_sub_period",
            "test_xs_setting_with_copy_error",
            "test_rolling_count",
            "test_frame_to_period",
            "_to_ordinalf",
            "test_asi8",
            "test_dti_ne_null_scalar",
            "test_compression_warns_when_decompress_caches_blosc",
            "time_from_components",
            "test_tab_completion",
            "test_constructor_with_nas",
            "test_binary_functions",
            "test_n_identical_values",
            "test_pivot_string_as_func",
            "_set_noconvert_columns",
            "test_from_arrays_different_lengths",
            "_adjust_binner_for_upsample",
            "test_usecols_with_unicode_strings",
            "test_to_csv_chunking",
            "test_build_series",
            "_write_body",
            "test_append_join_nondatetimeindex",
            "tips_df",
            "test_agg_dict_nested_renaming_depr",
            "test_tz_range_is_utc",
            "test_obj_none_preservation",
            "_delegate_method",
            "test_arithmetic_conversion",
            "test_constructor_cast_failure",
            "test_banklist_header",
            "test_qcut_return_intervals",
            "test_transform",
            "test_dt64arr_add_sub_period_scalar",
            "test_frame_select_complex",
            "test_unit_parser",
            "test_reduce_to_float",
            "test_asfreq_datetimeindex_empty_series",
            "length",
            "cbday_roll",
            "test_replace_preserves_nanos",
            "test_to_html_regression_GH6098",
            "test_string_indexing",
            "time_query_with_boolean_selection",
            "test_last_subset",
            "uint64_frame",
            "test_julian_round_trip",
            "test_append_multiple",
            "test_rolling_skew",
            "test_constructor_lists_to_object_dtype",
            "test_dt_accessor_no_new_attributes",
            "test_loc_non_unique",
            "testRollback1",
            "_isna_compat",
            "test_floor_and_ceil_functions_raise_error",
            "test_strl_latin1",
            "test_total_seconds_scalar",
            "test_union_noncomparable",
            "test_numpy_timedelta_scalar_indexing",
            "test_qcut_nat",
            "test_dt64arr_sub_NaT",
            "test_unnamed_columns",
            "test_dt64_overflow_masking",
            "test_datetimes",
            "_save_chunk",
            "test_is_",
            "test_dti_cmp_null_scalar_inequality",
            "test_resample_median_bug_1688",
            "time_series_dates",
            "_bool_arith_check",
            "highlight_min",
            "test_interp_limit_no_nans",
            "test_str_split",
            "test_cython_agg_frame_columns",
            "test_from_spmatrix_columns",
            "compute_expected",
            "test_all_none_exception",
            "test_dt64ser_cmp_date_invalid",
            "value_counts",
            "test_groupby_with_dst_time_change",
            "test_str_list_query_method",
            "test_loc_to_fail",
            "test_rolling_std_1obs",
            "box",
            "test_lhs_expression_subscript",
            "test_insert_missing",
            "test_constructor_copy",
            "test_loc_getitem_label_list_with_missing",
            "test_read_dta1",
            "test_mixed_index_assignment",
            "test_nan_data_with_int_dtype_raises_error",
            "test_partial_slice_second_precision",
            "test_mixed_underscores_and_spaces",
            "is_bool_indexer",
            "test_pairwise_with_other",
            "test_scientific_no_exponent",
            "test_read_dta4",
            "test_validate_inplace",
            "test_ext",
            "test_replace_with_dict_with_bool_keys",
            "na_cmp",
            "test_constructor_Series_named",
            "test_setitem_scalars_no_index",
            "test_replace_mixed",
            "test_bunched_yearends",
            "test_values_multiindex_periodindex",
            "test_astype_all",
            "test_unsupported_datetype",
            "test_sparse_pow_issue",
            "test_expanding_corr_pairwise_diff_length",
            "_join_non_unique",
            "test_select_dtypes_empty",
            "test_sort_index_multiindex",
            "test_sem",
            "test_fontsize",
            "test_maybe_mangle_lambdas_listlike",
            "test_loc_datetime_length_one",
            "arrays_for_binary_ufunc",
            "test_ngroup_respects_groupby_order",
            "test_take_mixed_numeric",
            "test_period_index_indexer",
            "test_npdiff",
            "test_remove_unused_nan",
            "test_to_latex_escape_special_chars",
            "test_no_mutate_but_looks_like",
            "write_legacy_file",
            "test_dti_union_mixed",
            "from_breaks",
            "test_margins_no_values_no_cols",
            "test_add_categories",
            "test_round_trip_preserve_multiindex_names",
            "test_dti_to_period",
            "test_empty_multi",
            "test_comparison_of_ordered_categorical_with_nan_to_scalar",
            "test_extension_array_cross_section",
            "_dtype_to_default_stata_fmt",
            "_parse_tables",
            "test_constructor_from_categorical_string",
            "_check_double_roundtrip",
            "test_series_nested",
            "test_objarr_radd_str_invalid",
            "update",
            "test_delitem_multiindex",
            "test_mixed_freq_regular_first",
            "tz",
            "test_ensure_int32",
            "test_left_merge_empty_dataframe",
            "time_multi_columns",
            "test_frame_on",
            "test_count_level_series",
            "_get_variable_labels",
            "test_to_period_tz",
            "test_take_fill_value_none_raises",
            "make_sparse",
            "test_read_nokey",
            "test_concatlike_datetimetz",
            "test_mixed_freq_lf_first",
            "test_agg_multiple_mixed_no_warning",
            "test_multifunc_select_col_integer_cols",
            "test_abs",
            "test_series_from_coo",
            "test_div_zero_inf_signs",
            "test_describe_categorical_columns",
            "test_map_tseries_indices_accsr_return_index",
            "test_agg_dict_renaming_deprecation",
            "test_pivot_dtaccessor",
            "bootstrap_plot",
            "test_groupby_boxplot_sharex",
            "test_tz",
            "test_date_range_linspacing_tz",
            "test_to_csv_quote_none",
            "test_astype_str_cast",
            "test_unstack",
            "visit_UnaryOp",
            "_get_na_rep",
            "test_regex_replace_scalar",
            "test_dup_datetime_index_plot",
            "test_resample_how_ohlc",
            "test_setitem_sequence_mismatched_length_raises",
            "test_dt64_series_add_intlike",
            "test_schema_support",
            "test_to_csv_write_to_open_file_with_newline_py3",
            "_get_label",
            "test_deprecated_to_sparse",
            "test_setops_preserve_freq",
            "test_td64arr_floordiv_int",
            "test_stable_descending_sort",
            "testSignedInt",
            "test_dti_tz_convert_trans_pos_plus_1__bug",
            "test_dataframe_numpy_labelled",
            "test_index_equal_values_less_close",
            "_get_comb_axis",
            "test_series_repr_nat",
            "test_on",
            "platform_name",
            "validate_axis_style_args",
            "_compare_other",
            "int_frame_const_col",
            "test_sort_index_intervalindex",
            "test_to_datetime_array_of_dt64s",
            "test_fillna_tzaware",
            "test_rank_mixed_frame",
            "test_weekmask_and_holidays",
            "_create_storer",
            "test_incorrect_dtype_raises",
            "test_groupby_boxplot_sharey",
            "_handle_usecols",
            "assert_bool_op_calc",
            "test_where_dt_tz_values",
            "test_trim",
            "_get_index_columns",
            "test_center_ljust_rjust",
            "test_reset_index_tz",
            "test_frame_pad_backfill_limit",
            "test_categorical_aggfunc",
            "test_corrwith_mixed_dtypes",
            "test_cummin_cummax",
            "test_dti_cmp_list",
            "test_dti_union_aware",
            "test_df_div_zero_df",
            "test_get_indexer_closed",
            "test_partial_set_empty_frame_row",
            "_is_convertible_to_index",
            "_zsqrt",
            "test_constructor_invalid_tz",
            "test_repeat_preserves_tz",
            "test_slice_integer_frame_getitem",
            "_conv",
            "test_nlargest",
            "test_tdi_sub_int",
            "test_subclass_stack_multi",
            "test_multiindex",
            "lreshape",
            "tests_datetimeindex_freq_issue",
            "test_chained_getitem_with_lists",
            "test_missing_minp_zero_variable",
            "test_comment_used",
            "_validate_dtype",
            "test_warning_case_insensitive_table_name",
            "test_ngroup_one_group",
            "test_isin_nan_common_object",
            "ensure_clean_store",
            "build_extensions",
            "test_interp_limit_area",
            "test_memory_leak",
            "_null_terminate",
            "test_nonetype_top_level_bottom_level",
            "test_iadd_string",
            "register_series_accessor",
            "test_drop_duplicates_NA",
            "test_to_json",
            "check_round_trip_frame",
            "test_resample_loffset_upsample",
            "test_nans_equal",
            "month_name",
            "test_ragged_std",
            "test_path_localpath",
            "test_tolerance_forward",
            "test_iloc_setitem_list",
            "test_duplicated_with_nas",
            "test_max_multi_index_display",
            "time_insert",
            "test_datetime_with_timezone",
            "test_groupby_agg_coercing_bools",
            "test_set_dtype_many",
            "_get_index_name",
            "_new_PeriodIndex",
            "test_python_docs_table",
            "_to_dict_of_blocks",
            "test_on_specialized_type_by_int",
            "test_setitem_cache_updating",
            "series",
            "test_from_records_to_records",
            "test_pivot_complex_aggfunc",
            "test_categorical_dtype_unsorted",
            "test_where_series",
            "test_reindex_no_type_preserve_target_empty_mi",
            "test_bootstrap_plot",
            "_generate_marginal_results",
            "test_set_index_after_mutation",
            "test_to_csv_string_array_utf8",
            "validate_take_with_convert",
            "test_pivot_with_non_observable_dropna",
            "test_tz_localize_errors_ambiguous",
            "_get_project_id",
            "test_categories_none_comparisons",
            "test_comparison_of_ordered_categorical_with_nan_to_listlike",
            "test_unicode_repr_issues",
            "test_usecols_implicit_index_col",
            "test_binary_operators",
            "test_int64_add_overflow",
            "test_list_float_complex",
            "_register_accessor",
            "test_is_datetime64_any_dtype",
            "test_concat_series_axis1",
            "_add_margins",
            "test_constructor_sparse_dtype",
            "test_assert_numpy_array_equal_class_mismatch",
            "test_api_default_format",
            "test_level_setting_resets_attributes",
            "format_dateaxis",
            "test_pi_sub_offset_array",
            "test_replace_dict_no_regex",
            "test_resample_loffset_count",
            "test_comparison_flex_basic",
            "test_indexing_unordered",
            "hash_tuples",
            "test_more_deeply_nested",
            "_maybe_dedup_names",
            "test_infer_freq_tz_transition_custom",
            "test_int64_factorize",
            "on_cols_multi",
            "_get_converter",
            "test_df_mod_zero_df",
            "test_concat_same_type",
            "setup_data",
            "test_mixed_offsets_with_native_datetime_raises",
            "test_info_repr_html",
            "test_grouped_hist_legacy",
            "test_missing_meta",
            "_clean_options",
            "test_partition_deprecation",
            "test_astype_categorical",
            "to_clipboard",
            "test_groupby_level_nonmulti",
            "_get_time_period_bins",
            "test_maybe_promote_object_with_any",
            "test_reindexing",
            "test_to_coo_text_names_text_row_levels_nosort_col_level_single",
            "test_get_unique",
            "test_qcut_include_lowest",
            "_dt_to_float_ordinal",
            "test_categorical_series_repr_timedelta_ordered",
            "test_euro_decimal",
            "test_non_contiguous",
            "nbytes",
            "test_is_bool_dtype",
            "_maybe_add_count",
            "test_write_lists_dict",
            "create_block",
            "test_operators_reverse_object",
            "create_msgpack_data",
            "test_nonetype_multiple_levels",
            "_check_generated_range",
            "time_datetime_field_year",
            "_clip_with_scalar",
            "melt",
            "test_is_scalar_builtin_nonscalars",
            "test_to_dense_preserve_name",
            "_maybe_transform_eq_ne",
            "test_infer_dtype_period",
            "test_rgb_tuple_color",
            "test_sparse_frame_pad_backfill_limit",
            "time_med_get_loc",
            "parallel_coordinates",
            "clean_interp_method",
            "test_multiindex_na_repr",
            "test_agg_relabel_non_identifier",
            "test_apply_broadcast_error",
            "test_usecols_regex_sep",
            "test_to_integer_array_dtype_keyword",
            "sequence_to_td64ns",
            "test_outer_join",
            "test_colspan_rowspan_copy_values",
            "test_setitem_callable",
            "test_to_html_with_index_names_false",
            "test_timestamp_tz_localize_nonexistent_shift",
            "test_springforward_singular",
            "simple",
            "_process_format_subheader",
            "_pprint_dict",
            "init_xsel_clipboard",
            "test_maybe_promote_datetimetz_with_na",
            "test_selection",
            "test_resample_with_only_nat",
            "time_transform_lambda_max",
            "test_regex_replace_list_obj_inplace",
            "test_complex_append",
            "test_td64arr_mul_int",
            "test_at_inside_string",
            "test_consistency_with_window",
            "test_join_level",
            "test_remove_unused_levels_large",
            "std",
            "test_default_dtype",
            "test_basic2",
            "test_pivot_table_aggfunc_dropna",
            "test_stack_multiple_bug",
            "_isna_ndarraylike",
            "test_tz_aware_asfreq",
            "dispatch_missing",
            "test_dialect",
            "skip_if_installed",
            "test_date_range_convenience_periods",
            "should_series_dispatch",
            "test_daterange_bug_456",
            "get_objs",
            "test_missing_public_nat_methods",
            "test_store_series_name",
            "test_deprecate_ok",
            "_check_expected_dtype",
            "test_string_no_dates",
            "test_rank_axis",
            "make_data",
            "test_groupby_non_arithmetic_agg_types",
            "test_expanding",
            "test_warns",
            "maybe_infer_dtype_type",
            "_is_valid_endpoint",
            "test_raise_from_object_hook",
            "test_filter_row_groups",
            "test_pi_sub_isub_offset",
            "test_constructor_no_data_index_order",
            "test_frame_invert",
            "_init_spmatrix",
            "test_dt64arr_timestamp_equality",
            "test_shift_no_freq",
            "test_concat_no_unnecessary_upcast",
            "test_how_lambda_functions",
            "test_concat_different_fill",
            "test_resample_quantile",
            "test_read_excel_blank_with_header",
            "test_partial_loc_missing",
            "test_div_int",
            "test_lag_plot",
            "test_concat_empty_series_timelike",
            "test_flat_stays_flat",
            "test_read_excel_bool_header_arg",
            "test_resample_to_timestamps",
            "test_container_shift",
            "test_combine_first",
            "test_shift_bool",
            "test_update_ctx",
            "test_query_long_float_literal",
            "test_non_sparse_raises",
            "test_invalid",
            "_get_join_indexers",
            "test_from_product_invalid_input",
            "data_for_grouping",
            "test_expand_frame_repr",
            "_make_concat_multiindex",
            "test_guess_datetime_format_with_dayfirst",
            "kurt",
            "test_expanding_axis",
            "time_mult",
            "test_series_tz_localize",
            "process_class_docstrings",
            "test_join_on_series",
            "test_constructor_invalid_frequency",
            "max",
            "test_parser",
            "test_stack_partial_multiIndex",
            "test_concat_multiple_tzs",
            "test_constructor_datetime64_tzformat",
            "generate_bins_generic",
            "test_round_dst_border_ambiguous",
            "test_complex_mixed_fixed",
            "test_constructor_dtype_str",
            "test_missing_trailing_delimiters",
            "test_where_with_one_style",
            "test_concat_same_type_invalid",
            "test_na_value_dict_multi_index",
            "read_parquet",
            "test_astype_raises",
            "test_readjson_each_chunk",
            "assert_check_nselect_boundary",
            "test_isnumeric",
            "test_grouping_string_repr",
            "test_groupby_timedelta_cython_count",
            "check_chained_cmp_op",
            "test_constructor_simple_new",
            "_get_properties",
            "git_pieces_from_vcs",
            "test_mixed_index_at_iat_loc_iloc_series",
            "_ensure_numeric",
            "_wrap_aggregated_output",
            "test_nanargmin",
            "_nanminmax",
            "_concat_same_dtype",
            "test_int_series_slicing",
            "test_loc_getitem_series",
            "test_tz_conversion_freq",
            "test_constructor_with_datetimes",
            "test_interpolate_piecewise_polynomial",
            "test_cmov_window_regular",
            "test_reindex_duplicate_target",
            "test_frame_group_ops",
            "test_from_records_lists_generator",
            "test_embedded_newline",
            "_evaluate",
            "test_disallow_python_keywords",
            "freqstr",
            "test_finder_hourly",
            "test_dti_to_pydatetime_fizedtz",
            "test_dialect_conflict_delimiter",
            "test_append_missing_cols",
            "test_constructor_error_msgs",
            "_get_exec",
            "test_rank_categorical",
            "test_groupby_function_rename",
            "test_setitem_fancy_2d",
            "check_nancomp",
            "test_stack_int_level_names",
            "test_days",
            "test_constructor_str_category",
            "test_unit_rounding",
            "test_pivot_table_categorical_observed_equal",
            "notna",
            "test_set_index_multiindexcolumns",
            "test_reindex_lvl_preserves_names_when_target_is_list_or_array",
            "test_centered_axis_validation",
            "maybe_convert_objects",
            "test_from_array",
            "_get_fill_value",
            "_get_values_tuple",
            "test_setitem_single_column_mixed",
            "_maybe_update_attributes",
            "time_reshape_pivot_time_series",
            "test_from_arrays_iterator",
            "test_large",
            "test_interp_raise_on_only_mixed",
            "test_apply_subset",
            "test_guess_datetime_format_for_array",
            "_ts_plot",
            "test_slice_float_get_set",
            "test_repr_html_mathjax",
            "time_crosstab_values",
            "test_validate_bool_kwarg_fail",
            "test_numpy_all",
            "_check_resolvers",
            "test_from_tuples",
            "test_sort2",
            "test_to_frame_dtype_fidelity",
            "generate_regular_range",
            "rename_axis",
            "test_xticklabels",
            "test_assign_multiple",
            "test_df_numeric_cmp_dt64_raises",
            "test_strobj_mode",
            "test_unsorted_index_xlim",
            "test_numeric_object_likes",
            "test_from_inferred_categories_sorts",
            "test_convert_objects_no_conversion",
            "test_dt_round",
            "test_datetime_other_units",
            "test_frame_dict_constructor_empty_series",
            "time_series_nth",
            "test_array_interface_tz",
            "test_get_loc_level",
            "test_usecols_relative_to_names2",
            "test_round_trip_equals",
            "_attempt_YYYYMMDD",
            "_preprocess_slice_or_indexer",
            "test_union_sort_other_incomparable",
            "test_fillna_tzaware_different_column",
            "test_extract_optional_groups",
            "test_update_nooverwrite",
            "test_df_arithmetic_subexpression",
            "_assert_take_fillable",
            "_write_value_label_names",
            "test_get_option",
            "test_append_frame_column_oriented",
            "test_frame_subclassing_and_slicing",
            "ydiffs",
            "test_encode_big_escape",
            "test_dropna_invalid_how_raises",
            "read",
            "test_factory",
            "test_basic_series_frame_alignment",
            "test_duplicated_keep",
            "_initialize_stacker",
            "test_fillna_series_method",
            "test_constructor_with_convert",
            "test_iter_object_try_string",
            "test_cummin",
            "test_nan_first_take_datetime",
            "test_getitem_callable",
            "style",
            "_coerce_scalar_to_timedelta_type",
            "test_loc_getitem_tuple_plus_slice",
            "test_single_quantile",
            "test_multiple_delimiters",
            "test_insert_index_object",
            "test_apply_with_reduce_empty",
            "_make_cum_function",
            "test_resample_datetime_values",
            "test_asm8",
            "test_iso8601_strings_mixed_offsets_with_naive",
            "test_getattr",
            "test_constructor_dtype_datetime64",
            "test_sparse_repr_after_set",
            "_warn_if_deprecated",
            "test_where_dups",
            "test_multiple_date_cols_int_cast",
            "test_dtype",
            "mean",
            "write_data_chunk",
            "test_join_on_fails_with_different_left_index",
            "_validate_monotonic",
            "_maybe_arg_null_out",
            "test_filter_regex_search",
            "test_interp_non_timedelta_index",
            "test_series_tz_convert_to_utc",
            "build_xlstyle",
            "test_write_index",
            "test_multiple_date_cols_chunked",
            "table_schema_cb",
            "test_values_boxed",
            "test_set_fill_value",
            "test_partition_on_supported",
            "test_depreciate_tz_and_tzinfo_in_datetime_input",
            "test_filter_unicode",
            "test_outer_join_sort",
            "test_factorized_sort",
            "test_invalid_arg",
            "test_pi_add_intarray",
            "test_minute",
            "test_sub",
            "test_sparse_bool",
            "test_auto_detect",
            "test_concat_NaT_dataframes",
            "test_dt64arr_add_td64_scalar",
            "test_mode_sortwarning",
            "test_regex_replace_dict_nested_non_first_character",
            "test_info_memory_usage_qualified",
            "test_execute",
            "test_td_add_timedelta64",
            "to_datetime",
            "time_infer_dst",
            "test_array_repr",
            "test_grouping_error_on_multidim_input",
            "test_td64arr_add_sub_tdi",
            "test_set_index_pass_multiindex",
            "_check_ax_scales",
            "between_time",
            "test_resample_categorical_data_with_timedeltaindex",
            "_get_formatted_column_labels",
            "test_asfreq_normalize",
            "floor",
            "_make_iris_table_metadata",
            "testPackFloat",
            "test_parallel_coordinates_with_sorted_labels",
            "HolidayCalendarFactory",
            "test_set_index_empty_column",
            "test_concat_categorical_ordered",
            "test_td64arr_add_timestamp",
            "test_bar_align_mid_vmin",
            "test_maybe_promote_string_with_any",
            "test_allow_exact_matches_nearest",
            "test_series_interpolate_method_values",
            "concatenate_join_units",
            "test_iat",
            "test_constructor_from_series",
            "test_frame_repr",
            "test_partial_slice_high_reso",
            "validate_multiindex",
            "test_line_plot_period_mlt_frame",
            "test_constructor_dict_of_ranges",
            "test_subplot_titles",
            "test_construction_with_ndarray",
            "test_header_multi_index_common_format_malformed1",
            "test_set_dtype_no_overlap",
            "test_isin_tuples",
            "test_no_keep_default_na_dict_na_values_diff_reprs",
            "test_nanvar_axis",
            "_onOffset",
            "test_mixed_array_comparison",
            "test_from_arrays_index_series_period",
            "test_to_sql_type_mapping",
            "test_groupby_head_tail",
            "_check_merge",
            "test_frame_getitem_multicolumn_empty_level",
            "test_to_dict_not_unique_warning",
            "test_rename_axis_none",
            "tshift",
            "test_asfreq_nat",
            "test_remove_unused_categories",
            "_test_compression_warns_when_decompress_caches",
            "is_full",
            "test_date_range_businesshour",
            "validate_minmax_axis",
            "unique",
            "visit_Attribute",
            "test_append_index",
            "test_timegrouper_with_reg_groups_freq",
            "test_dt64arr_add_sub_td64ndarray",
            "test_subclass_stack",
            "test_get_loc_tolerance_no_method_raises",
            "time_multi_count",
            "_set_option",
            "test_fillna_columns",
            "test_to_datetime_format_time",
            "test_different_nan_objects",
            "test_constructor_empty_list",
            "test_parse_dates_string",
            "is_extension_array_dtype",
            "test_str_cat",
            "test_frame_index_to_string",
            "_single_replace",
            "test_series_getitem_multiindex_xs",
            "test_bar_log",
            "test_drop_unique_and_non_unique_index",
            "_remove_whitespace",
            "test_equals_object",
            "test_contains_for_object_category",
            "test_get_loc_implicit_cast",
            "test_pop",
            "test_apply_ticks",
            "test_iloc_exceeds_bounds",
            "test_upsample_daily_business_daily",
            "assigner",
            "test_series_partial_set",
            "test_fy5253qtr_onoffset_last",
            "test_equals_op_multiindex",
            "test_read_from_py_localpath",
            "test_date_explicit_date_format",
            "test_replace_literal",
            "_map_values",
            "objects_to_td64ns",
            "test_to_datetime_list_of_integers",
            "test_from_json_to_json_table_index_and_columns",
            "git_versions_from_keywords",
            "test_comment_whitespace_delimited",
            "test_attrs",
            "time_convert_int",
            "test_apply_fill",
            "apply_standard",
            "test_comparison_protected_from_errstate",
            "test_series_fast_transform_date",
            "test_addition_ops",
            "test_column_multiindex",
            "test_df_grid_settings",
            "test_duplicate_keep_all_ties",
            "test_drop_dst_boundary",
            "test_filter_non_bool_raises",
            "test_register_by_default",
            "frame_apply",
            "test_setitem_series_datetime64tz",
            "_quarterly_finder",
            "_repr_categories_info",
            "_extend_blocks",
            "test_nan_interpolate",
            "_get_dtype",
            "test_pickle_compat_construction",
            "test_column_dups_operations",
            "test_sum_uint64_overflow",
            "test_info_shows_column_dtypes",
            "test_non_unique_moar",
            "test_tz_convert_utc_with_system_utc",
            "test_freq_offsets",
            "test_readjson_chunks_closes",
            "test_hist_layout",
            "test_join_outer",
            "test_binop_maybe_preserve_name",
            "test_np_sum",
            "test_shape",
            "test_to_datetime_format",
            "test_putmask_with_wrong_mask",
            "test_x_multiindex_values_ticks",
            "test_dups_fancy_indexing2",
            "test_quarterly_upsample",
            "test_local_syntax",
            "test_between",
            "write_multi_index",
            "test_empty",
            "time_to_sql_dataframe_column",
            "test_get_loc",
            "test_usecols_wrong_type",
            "test_finder_quarterly",
            "test_assert_numpy_array_equal_value_mismatch5",
            "test_drop_duplicates",
            "test_concatlike_datetimetz_to_object",
            "_decode_complex",
            "test_clip_against_series",
            "test_hist_colors",
            "test_quantile_axis_parameter",
            "_getitem_bool_array",
            "test_reasonable_key_error",
            "time_datetime_to_period",
            "test_merged_cell_custom_objects",
            "test_is_list_like_disallow_sets",
            "test_replace_integer_args",
            "test_math_sub",
            "end_blank_lines",
            "test_colspan_rowspan_1",
            "interp_methods_ind",
            "test_attr_wrapper",
            "test_apply_dict",
            "test_interleave",
            "test_bool_describe_in_mixed_frame",
            "test_frame_getitem_toplevel",
            "_get_time_bins",
            "add_methods",
            "test_subclassed_wide_to_long",
            "test_engineless_lookup",
            "test_constructor_floats",
            "test_alignment_non_pandas",
            "_ensure_data",
            "test_year_has_extra_week",
            "test_usecols_with_multi_byte_characters",
            "_field_accessor",
            "test_diff_axis",
            "test_astype_dispatches",
            "test_vector_resize",
            "test_to_frame_datetime_tz",
            "test_cmov_window",
            "test_escapechar",
            "get_sheet_data",
            "test_min",
            "test_hide_multiindex",
            "test_index_ctor_nat_result",
            "time_frame_sort_values_by_columns",
            "test_naive_datetimeindex_roundtrip",
            "test_subclass_unstack_multi_mixed",
            "test_reindex_preserves_tz_if_target_is_empty_list_or_array",
            "test_setitem_with_datetime_tz",
            "symmetric_difference",
            "test_empty_with_dup_column_pass_dtype_by_indexes",
            "_convert_object_array",
            "test_parr_add_sub_float_raises",
            "is_s3_url",
            "test_sparse_series_round_trip",
            "test_object_refcount_bug",
            "test_dataframe_utc_true",
            "test_astype_from_object",
            "evaluate",
            "test_from_dtype_from_float",
            "test_union_sort_other_incomparable_sort",
            "time_read_store_table_mixed",
            "create_block_manager_from_blocks",
            "test_callback",
            "conda_package_to_pip",
            "test_str_cat_special_cases",
            "test_groupby_one_row",
            "test_loc_multiindex_ints",
            "round_trip_pathlib",
            "test_where_warns",
            "test_concat_categorical_3elem_coercion",
            "_concat_sparse",
            "_consolidate",
            "test_constructor_list_of_series",
            "test_result_type",
            "test_apply_with_mixed_dtype",
            "test_summary",
            "test_options_fp",
            "test_sub_day",
            "assert_levels_dropped",
            "test_put",
            "test_df_add_flex_filled_mixed_dtypes",
            "_check_arg_length",
            "__getitem__",
            "test_read_local_jsonl",
            "test_duplicate_columns",
            "test_resample_daily_anchored",
            "test_default_handler_indirect",
            "test_operators_datetimelike_invalid",
            "test_freq_divides_end_in_nanos",
            "test_read_json_table_convert_axes_raises",
            "test_constructor_use_start_freq",
            "time_med_get_loc_warm",
            "test_rename_categories_series",
            "test_bool_flex_frame",
            "test_dti_constructor_small_int",
            "test_range_slice_outofbounds",
            "test_validate_median_initial",
            "to_msgpack",
            "_parse_thead_tr",
            "set_timezone",
            "test_fillna_period",
            "test_to_string_line_width_no_index",
            "test_resample_weekly_bug_1726",
            "test_loc_non_unique_memory_error",
            "test_parser_error_on_empty_header_row",
            "_compare_with_tz",
            "test_nunique_with_timegrouper_and_nat",
            "_interleaved_dtype",
            "test_repr_missing",
            "_getitem_frame",
            "test_write_variable_labels",
            "test_default_left_closed_label",
            "test_argmin_argmax",
            "_init_mgr",
            "test_chained_cmp_op",
            "test_pi_cmp_nat_mismatched_freq_raises",
            "ftypes",
            "test_merge_incompat_dtypes_are_ok",
            "test_dt64arr_sub_dtscalar",
            "test_floor_division",
            "test_constructor_numeric",
            "get_freq",
            "test_iloc_integer_locations",
            "test_xs_level_series_slice_not_implemented",
            "test_to_csv_quotechar",
            "test_astype_float",
            "test_empty_with_mangled_column_pass_dtype_by_names",
            "test_display_subset",
            "time_pivot_table_categorical_observed",
            "test_constructor_tz_or_tzinfo",
            "test_quantile_interpolation_datetime",
            "test_get_slice",
            "test_non_monotonic_reindex_methods",
            "test_setitem_frame_align",
            "test_plot_multiple_inferred_freq",
            "should_warn",
            "test_alignment",
            "test_isin_empty_datetimelike",
            "test_get_loc_outside_tolerance_raises",
            "test_groupby_groups_datetimeindex_tz",
            "strides",
            "test_constructor_dict_datetime64_index",
            "test_from_records_len0_with_columns",
            "test_concat_keys_and_levels",
            "test_ix_get_set_consistency",
            "test_series_ctor_plus_datetimeindex",
            "test_header_inferred_from_rows_with_only_th",
            "_combine_hash_arrays",
            "_sub_datetimelike_scalar",
            "test_isin_level_kwarg_bad_label_raises",
            "test_empty_df_expanding",
            "test_mask_callable",
            "test_unbalanced_quoting",
            "test_rolling_corr_pairwise",
            "test_groupby_cumprod",
            "test_tdi_ops_attributes",
            "test_frame_equal_columns_mismatch",
            "test_block_names",
            "test_labels_dtypes",
            "test_dti_constructor_preserve_dti_freq",
            "test_concat_different_extension_dtypes_upcasts",
            "test_agg_python_multiindex",
            "validate_rolling_func",
            "test_no_reference_cycle",
            "test_to_html_no_index_max_rows",
            "_sparse_series_to_coo",
            "test_constructor_sequence",
            "test_search_sorted_datetime64_scalar",
            "test_to_csv_multiindex",
            "test_round_subsecond",
            "test_nancorr",
            "test_resample_how_method",
            "nanprod",
            "test_tuples_with_name_string",
            "test_frame_indexing_single",
            "test_concatlike_datetimetz_short",
            "_normalize_keyword_aggregation",
            "test_reset_option_all",
            "test_rename_bug2",
            "test_order_without_freq",
            "test_from_records_with_index_data",
            "test_categorical_ordered_none_deprecated",
            "test_to_integer_array_float",
            "test_sort_index_nan",
            "time_scalar_function_multi_col",
            "_is_label_reference",
            "test_to_string_ascii_error",
            "test_convert_numeric_uint64",
            "_series_and_frame",
            "test_invalid_encoding",
            "time_searchsorted",
            "test_astype_str",
            "test_overlapping_datetime",
            "test_comment_skiprows_header",
            "test_frame_getitem_simple_key_error",
            "_get_version",
            "_create_table_setup",
            "test_where_index_datetimetz",
            "test_loc_with_slices",
            "test_tdi_add_dt64_array",
            "test_plot_offset_freq",
            "test_unstack_mixed_extension_types",
            "test_dst_transitions",
            "test_constructor_from_index_series_datetimetz",
            "test_mode_single",
            "test_add_matplotlib_datetime64",
            "test_shallow_copy_empty",
            "test_groupby_categorical_index_and_columns",
            "test_read_column",
            "test_drop_api_equivalence",
            "_filter_usecols",
            "test_raise_when_saving_timezones",
            "test_extract_expand_None",
            "_get_options_with_defaults",
            "get_validation_data",
            "_add_logical_methods_disabled",
            "test_raise_on_drop_duplicate_index",
            "test_index_cast_datetime64_other_units",
            "_convert_slice_indexer",
            "test_merge_datetime_index",
            "test_fillna_datetime64",
            "test_plot_scatter_with_c",
            "epochs",
            "test_invalid_raises",
            "rindex",
            "test_day_not_in_month_coerce",
            "test_constructor_dict",
            "test_sort_datetimelike",
            "_record_count",
            "test_highlight_null",
            "test_case_insensitive",
            "time_exact",
            "is_datetimetz",
            "test_apply_convert_objects",
            "_load_raw_sql",
            "test_to_datetime_with_non_exact",
            "_test_offset",
            "test_valid",
            "salaries_table",
            "set_atom_categorical",
            "test_transform_numeric_to_boolean",
            "test_pairlist",
            "test_concat_invalid_first_argument",
            "test_set_properties",
            "test_subdays",
            "test_xs_level0",
            "test_spam",
            "test_timestamp_add_timedelta_push_over_dst_boundary",
            "test_repr",
            "_pipe",
            "test_maybe_promote_any_numpy_dtype_with_na",
            "test_with_datetimelikes",
            "assert_extension_array_equal",
            "_step",
            "test_reindex_signature",
            "test_resample_frame_basic",
            "configure_tests",
            "_indicator_post_merge",
            "test_loffset_returns_datetimeindex",
            "_na_value",
            "test_groupby_with_small_elem",
            "test_groupby_agg_ohlc_non_first",
            "extended_summary",
            "test_no_keep_default_na_dict_na_scalar_values",
            "test_full_outer_join",
            "test_sort_index_reorder_on_ops",
            "test_iterator_read_too_much",
            "test_td_div_timedeltalike_scalar",
            "test_to_excel_output_encoding",
            "test_nth",
            "_to_sql_replace",
            "_parse_tbody_tr",
            "test_str_cat_name",
            "_maybe_cache",
            "test_empty_with_dup_column_pass_dtype_by_indexes_raises",
            "test_concat_series_axis1_same_names_ignore_index",
            "test_get_loc_raises_missized_tolerance",
            "classmethod",
            "_ensure_valid_index",
            "union",
            "test_cython_inner_join",
            "_get_index_factory",
            "test_td_constructor_value_error",
            "assert_index_equal",
            "test_categorical_index_preserver",
            "test_loc_slice_index_fill_value",
            "_try_coerce_result",
            "get_formatted_cells",
            "test_frame_datetime64_mixed_index_ctor_1681",
            "test_from_records_with_datetimes",
            "is_named_tuple",
            "_ensure_arraylike",
            "_repr_categories",
            "test_tz_localize_ambiguous_compat",
            "test_corrwith",
            "test_filter_out_all_groups_in_df",
            "test_date_format_series",
            "_import_deprmod",
            "test_copy_in_constructor",
            "_get_setitem_indexer",
            "test_bin16",
            "test_per_axis_per_level_getitem",
            "register_vcs_handler",
            "test_compare_2000",
            "float_frame_fill0_dense",
            "test_show_dimensions",
            "test_numeric_compat",
            "_indicator_pre_merge",
            "testIgnoreUnicodeErrors",
            "test_issue124",
            "test_resample_with_dst_time_change",
            "test_join_multi_empty_frames",
            "test_truncate",
            "test_string_slice_out_of_bounds",
            "test_interp_limit_direction",
            "test_between_time_formats",
            "test_loc_setitem_with_scalar_index",
            "test_constructor_dtype",
            "remove",
            "test_getitem_numeric_column_names",
            "test_maybe_convert_numeric_infinities",
            "np_array_datetime64_compat",
            "test_resample_same_freq",
            "test_correct_type_nested_array",
            "test_overflow_offset_raises",
            "ts",
            "test_append_preserve_index_name",
            "_try_convert_to_date",
            "test_sparse_mixed",
            "test_getitem_boolean_casting",
            "validate_dtype_freq",
            "_aggregate_multiple_funcs",
            "test_setitem_loc_scalar_mixed",
            "test_elementwise_comparison_warning",
            "test_convert_pandas_type_to_json_period_range",
            "get_locales",
            "test_invalid_engine",
            "construct_1d_arraylike_from_scalar",
            "test_combine_first_mixed",
            "test_nested_dict_frame_constructor",
            "test_update_ctx_flatten_multi",
            "test_is_scalar_numpy_array_scalars",
            "test_multi_index",
            "test_non_reducing_slice",
            "test_skiprows_xrange",
            "test_replace_tzinfo_equiv_tz_localize_none",
            "test_dt64arr_add_sub_DateOffset",
            "test_numpy_repeat",
            "test_getitem_ix_boolean_duplicates_multiple",
            "test_multiples",
            "_homogenize",
            "test_isin_against_series",
            "test_complex_raises",
            "bfill",
            "test_reset_index_with_datetimeindex_cols",
            "convert_values",
            "test_get_indexer_errors",
            "test_consolidate",
            "test_rank_signature",
            "time_series_describe",
            "test_pi_add_iadd_timedeltalike_daily",
            "test_intersect_equal_sort_true",
            "test_fake_inferred_business",
            "test_read_chunks_115",
            "test_constructor_name_hashable",
            "test_cant_or_shouldnt_cast",
            "test_astype_datetime",
            "test_non_reducing_slice_on_multiindex",
            "test_to_string_float_format_no_fixed_width",
            "_get_subplots",
            "test_difference_base",
            "test_get_X_columns",
            "test_td_floordiv_invalid_scalar",
            "_roundtrip",
            "test_bar_colors",
            "_td_array_cmp",
            "format_percentiles",
            "test_groupby_empty",
            "test_constructor_dtype_and_others_raises",
            "_check_setitem_copy",
            "test_multiindex_label_slicing_with_negative_step",
            "is_integer_dtype",
            "test_bar_ignore_index",
            "_aggregate",
            "test_int64_overflow",
            "test_extract_expand_unspecified",
            "test_first_last_nth",
            "test_inplace_ops_identity",
            "test_modify_values",
            "test_to_string_small_float_values",
            "test_repr_non_interactive",
            "test_merge_on_nans",
            "test_pad",
            "as_blocks",
            "test_mode_category",
            "test_with_duplicates",
            "test_quantile_invalid",
            "test_encode_array_in_array",
            "test_bar_stacked_center",
            "test_multiple_date_cols_with_header",
            "test_td64arr_add_timedeltalike",
            "test_series_indexing_single",
            "test_intersection_bug_1708",
            "time_write_hdf",
            "_monthly_finder",
            "test_full_format_converters",
            "test_equals_multi",
            "to_julian_date",
            "test_resample_float_base",
            "test_merge_non_unique_indexes",
            "test_left_merge_na_buglet",
            "asobject",
            "test_dti_custom_business_summary_pytz",
            "test_mixed_index_no_fallback",
            "test_to_html_truncation_index_false_max_rows",
            "_is_business_daily",
            "test_union_categorical_same_category",
            "test_cython_left_outer_join",
            "test_to_numpy_dtype",
            "test_insert_index_period",
            "test_constructor_unwraps_index",
            "test_out_of_range_float",
            "test_expanding_apply",
            "test_select_filter_corner",
            "test_get_loc_raises_object_nearest",
            "wide_to_long",
            "exception_matches",
            "test_transform_mixed_type",
            "test_thousands_macau_index_col",
            "test_walk",
            "test_concat_multiindex_rangeindex",
            "test_plot_fails_with_dupe_color_and_style",
            "read_excel",
            "test_demo",
            "test_where_datetime",
            "test_reset_option",
            "test_preserve_categories",
            "test_decons",
            "_build_option_description",
            "test_resample_with_pytz",
            "test_first_row_bom",
            "test_rolling_quantile_param",
            "test_quantile_axis_mixed",
            "test_pivot_integer_columns",
            "test_cmov_window_regular_missing_data",
            "_assert_setitem_series_conversion",
            "test_invalid_columns",
            "test_legacy_table_read_py2",
            "mode",
            "set_locs",
            "test_subplots_layout",
            "test_other_type_raises",
            "test_date_range_ambiguous_arguments",
            "_combine_match_index",
            "default_units",
            "test_cummax_timedelta64",
            "test_constructor_list_of_tuples",
            "test_grouped_plot_fignums",
            "test_ufunc_multiple_return_values",
            "test_is_timedelta",
            "test_construction_with_nat_and_tzlocal",
            "test_groupby_level_apply",
            "_read_page_header",
            "test_view_tz",
            "test_deprecated_dense_to_sparse",
            "test_split_with_name",
            "test_append_with_strings",
            "test_stubs",
            "test_int_indexing",
            "test_to_latex_multiindex_empty_name",
            "test_block_shape",
            "_insert_inaxis_grouper_inplace",
            "test_bad_docstrings",
            "test_dt_round_tz_nonexistent",
            "html_encoding_file",
            "test_line_plot_period_mlt_series",
            "test_bar_align_mid_vmin_vmax_wide",
            "test_divmod_zero",
            "_concat_datetime",
            "_prepare_categoricals",
            "backfill",
            "test_preserve_timedeltaindex_type",
            "test_argsort",
            "test_bar_user_colors",
            "test_getitem_partial_column_select",
            "test_get_standard_colors_random_seed",
            "_wrap_result",
            "str_get_dummies",
            "test_frame_from_json_to_json",
            "test_upsample_apply_functions",
            "test_rolling_quantile_np_percentile",
            "_assert_fillna_conversion",
            "_pprint_seq",
            "_resolve_name",
            "test_to_string",
            "test_multiindex_with_columns",
            "test_getitem_fancy_boolean",
            "test_duplicate_mi",
            "test_numpy_transpose",
            "_align_method_FRAME",
            "test_getitem_group_select",
            "test_frame_pos",
            "test_duplicate_ref_loc_failure",
            "ignore_xlrd_time_clock_warning",
            "test_rank_int",
            "test_truncated_float_support",
            "num_summary_lines",
            "test_constructor_with_generator",
            "test_duplicates_on_starter_columns",
            "test_getitem_ix_float_duplicates",
            "test_ensure_copied_data",
            "test_next",
            "test_drop_duplicates_metadata",
            "test_join_with_len0",
            "test_reduce_mixed_frame",
            "test_constructor_dict_nan_key",
            "check_cases",
            "test_mock_clipboard",
            "test_no_version_raises",
            "test_from_arrays_index_datetimelike_mixed",
            "test_series_truncate_datetimeindex_tz",
            "test_memorial_day",
            "test_resample_count",
            "test_make_block_same_class",
            "test_anchor_week_end_time",
            "test_categorical_repr_datetime",
            "test_secondary_upsample",
            "test_matplotlib_scatter_datetime64",
            "checked_add_with_arr",
            "test_index_col_named2",
            "time_find",
            "components",
            "test_no_values_attribute",
            "_get_cython_type_upcast",
            "test_justify",
            "string_series",
            "test_convert_json_field_to_pandas_type_raises",
            "test_ground_truth",
            "test_is_complex_dtype",
            "test_range_tz_pytz",
            "test_pi_add_sub_td64_array_non_tick_raises",
            "test_date_conversion_overflow",
            "test_construct_from_string_fill_value_raises",
            "_coerce_values",
            "infer_objects",
            "clean_fill_method",
            "test_getitem_pop_assign_name",
            "connect",
            "indexer_between_time",
            "ensure_clean",
            "test_iloc_frame",
            "test_bytes_io_input",
            "test_reindex_methods_nearest_special",
            "test_constructor_dtype_copy",
            "test_dti_tz_convert_to_utc",
            "test_read_inline_jsonl",
            "test_corr_nooverlap",
            "test_cumsum",
            "test_clip_against_unordered_columns",
            "test_coerce_of_invalid_datetimes",
            "test_to_integer_array_bool",
            "test_series_nat_conversion",
            "test_multi_line_expression_callable_local_variable_with_kwargs",
            "_join_monotonic",
            "add_tmp",
            "pa",
            "test_ops_np_scalar",
            "test_secondary_y_ts",
            "test_update_filtered",
            "test_to_html_multiindex",
            "time_read_sql_table_parse_dates",
            "test_foobar_skip",
            "_get_varlist",
            "test_negative_ordinals",
            "reset_index",
            "test_small_year_parsing",
            "test_groupby_count_dateparseerror",
            "test_equals_range",
            "test_missing_field",
            "test_series",
            "test_slice_with_zero_step_raises",
            "is_period",
            "test_insert_error_msmgs",
            "test_simple_bool_ops",
            "test_reflected_comparison_with_scalars",
            "test_sort_values",
            "test_tick_division",
            "_check_roundtrip",
            "get_locs",
            "test_set_frame_expand_regular_with_extension",
            "test_constructor_Series_named_and_columns",
            "test_astype_categorical_to_other",
            "has_non_verbose_info_repr",
            "test_astype_category_ordered_none_deprecated",
            "test_quantile_multi",
            "test_bad_arg_length_max_value_multiple",
            "_get_join_info",
            "test_difference_sort_incomparable_true",
            "_write_characteristics",
            "_isna_ndarraylike_old",
            "test_concat_sorts_columns",
            "test_arith_flex_series",
            "test_properties_weekly_legacy",
            "test_setitem_more",
            "test_safe_names_warning",
            "test_describe_timedelta_values",
            "test_dti_isub_int",
            "test_to_datetime_format_integer",
            "_from_fastpath",
            "test_fillna_bug",
            "test_slice_locs",
            "test_print",
            "test_read_procedure",
            "test_cython_agg_nothing_to_agg_with_dates",
            "test_vectorized_offset_addition",
            "test_frame_equal_unicode",
            "test_onOffset",
            "test_mixed_freq_regular_first_df",
            "test_uneven_lines_with_usecols",
            "test_dti_cmp_str",
            "test_usecols_with_parse_dates",
            "test_reindex_datetimeindexes_tz_naive_and_aware",
            "test_getitem_multi",
            "test_from_records_sequencelike",
            "test_apply_bad_return",
            "_unconvert_index_legacy",
            "test_to_dict_wide",
            "test_cumcount",
            "test_plain_axes",
            "test_compare_hour13",
            "test_subplots_dup_columns",
            "test_wrap_agg_out",
            "test_precision",
            "test_dataframe_duplicate_column_names",
            "test_ser_div_ser",
            "seed_df",
            "_expand_axes",
            "test_crosstab_normalize",
            "test_background_gradient_axis",
            "test_median_duplicate_columns",
            "test_find",
            "test_dt64tz_setitem_does_not_mutate_dti",
            "test_interp_various",
            "test_count_with_only_nans_in_first_group",
            "test_value_counts_unique",
            "test_itertuples",
            "test_partial_set",
            "test_factorize",
            "test_setitem_ndarray_1d",
            "test_intersect_str_dates",
            "test_string_slice_get_syntax",
            "test_parr_sub_pi_mismatched_freq",
            "test_to_latex_decimal",
            "delete",
            "test_mixed_integer_from_list",
            "test_tdi_rmul_arraylike",
            "next_bday",
            "_is_unorderable_exception",
            "test_range_tz_dateutil",
            "all_data",
            "test_2d_fill_nonna",
            "result_index",
            "test_with_dictlike_columns",
            "_stata_elapsed_date_to_datetime_vec",
            "test_dti_tz_convert_tzlocal",
            "test_math_add",
            "_can_hold_element",
            "test_is_sequence",
            "test_divmod_scalar",
            "test_comment_skiprows",
            "_reset_option",
            "test_series_groupby_value_counts",
            "test_constructor_with_embedded_frames",
            "test_none_coercion_mixed_dtypes",
            "test_dataframe_dummies_mix_default",
            "test_dataframe_dummies_all_obj",
            "test_empty_index_name_doesnt_display",
            "test_arithmetic_overflow",
            "test_getitem_setitem_boolean_misaligned",
            "test_full_file_with_spaces_and_missing",
            "test_to_string_dtype",
            "test_axis_share_xy",
            "test_set_index_raise_on_len",
            "test_constructor_nonhashable_names",
            "test_ops_consistency_on_empty",
            "_add_numeric_methods_disabled",
            "set_index",
            "_is_scalar_access",
            "test_parse_public_s3_bucket_nrows",
            "test_exit_status_for_validate_one",
            "test_pytables_native2_read",
            "_parse_tfoot_tr",
            "clean",
            "test_iterator_loop",
            "time_to_datetime_dayfirst",
            "test_column_dups_indexing",
            "test_to_datetime_iso8601_noleading_0s",
            "from_custom_template",
            "test_from_to_scipy",
            "test_stable_categorial",
            "test_groupsort_indexer",
            "time_join_dataframe_index_single_key_bigger",
            "test_rsplit_to_multiindex_expand",
            "test_dtypes_gh8722",
            "test_one_level_deep_flattens",
            "test_constructor_rec",
            "test_nan_selection_bug_4858",
            "test_agg_list_like_func",
            "test_union_categorical_unwrap",
            "run_arithmetic",
            "test_series_unnamed",
            "test_qcut",
            "test_series_partial_set_datetime",
            "test_convert_array_of_periods",
            "time_frame_drop_dups",
            "_skip_if_no_project_id",
            "test_frame_reset_index",
            "test_good_functions",
            "infer_freq",
            "test_timedelta_hash_equality",
            "test_ufunc_coercions",
            "test_plot",
            "test_tolerance_nearest",
            "test_constructor_cant_cast_period",
            "test_sort_non_lexsorted",
            "_convert_index",
            "_get_skiprows",
            "test_to_string_repr_unicode",
            "_check_file_or_buffer",
            "test_dt64ser_sub_datetime_dtype",
            "test_ops_error_str",
            "compare_index_period",
            "test_groupby_name_propagation",
            "test_header_with_index_col",
            "test_to_datetime_parse_timezone_keeps_name",
            "test_double_precision",
            "test_datetime_cut",
            "create_data",
            "test_pyarrow",
            "test_setindex",
            "test_groupby_aggregation_mixed_dtype",
            "test_isin_with_string_scalar",
            "test_value_vars",
            "test_combine_first_period",
            "_is_label_like",
            "test_convert_preserve_bool",
            "test_union_categoricals_ignore_order",
            "time_groupby_nosort",
            "classes_and_not_datetimelike",
            "test_to_object_array_tuples",
            "frame",
            "time_resample",
            "test_op",
            "_decode",
            "_construct",
            "_interp_limit",
            "test_categorical_no_compress",
            "test_sort_index_na_position",
            "write_to_version_file",
            "_generate_regular_range",
            "test_getitem_nat",
            "test_sorting_repr_8017",
            "test_droplevel_with_names",
            "test_concat_series_axis1_names_applied",
            "test_begin_year_alias",
            "read_block_index",
            "_is_compatible_with_other",
            "test_dict_numpy_complex",
            "test_construction_with_dtype",
            "test_deepcopy",
            "monotonic_index",
            "test_strip_lstrip_rstrip",
            "test_count_cross_type",
            "test_sort_index_level_by_name",
            "test_context",
            "visit_Assign",
            "_interleave",
            "test_integer_index_astype_datetime",
            "test_is_level_reference_series_axis1_error",
            "test_memory_map",
            "_get_take_nd_function",
            "test_map_dict_with_tuple_keys",
            "test_compare_1700",
            "_try_convert_data",
            "test_categorical_series_repr_period_ordered",
            "__repr__",
            "test_equality_invalid",
            "test_dt64arr_add_dt64ndarray_raises",
            "test_rich_comparison_with_unsupported_type",
            "test_parse_public_s3a_bucket",
            "_to_ijv",
            "test_range_tz_dst_straddle_pytz",
            "test_header_and_index_with_types",
            "test_uhf",
            "test_constructor_maskedarray_hardened",
            "test_iloc_duplicates",
            "_get_level_indexer",
            "test_sort_multi_index",
            "test_ragged_var",
            "_repr_attrs",
            "test_basic_left_by_right_by",
            "test_kde_colors_and_styles_subplots",
            "_ensure_datetimelike_to_i8",
            "test_index_col_label_error",
            "test_with_nan",
            "get_config_from_root",
            "_infer_tz_from_endpoints",
            "test_loc_str_slicing",
            "close",
            "test_astype_assignment",
            "test_implementation_limits",
            "test_float_suffix",
            "test_intercept_astype_object",
            "to_pickle",
            "test_append_misc",
            "test_align_mixed_float",
            "test_dict_float",
            "summary",
            "test_reading_all_sheets_with_blank",
            "test_maybe_promote_any_with_object",
            "test_comparison_tzawareness_compat_scalars",
            "test_categorical_index_repr_period_ordered",
            "test_tidy_repr",
            "test_constructor_dict_of_generators",
            "test_groupby_apply_all_none",
            "test_multi_iter_frame",
            "test_get_indexer_length_one",
            "test_non_unique_pickle",
            "read_stata",
            "test_rank_max_pct",
            "test_intra_day_conversion_factors",
            "test_day_not_in_month_raise",
            "_sql_type_name",
            "_get_fill_indexer_searchsorted",
            "_check_iris_loaded_frame",
            "test_margins",
            "test_basic_period_index_subscript_expression",
            "test_any_all_object",
            "test_td64arr_addsub_anchored_offset_arraylike",
            "test_lookup_basics",
            "check_reduce",
            "test_unstack_dtypes",
            "test_ufuncs_single_float",
            "test_date_range_multiplication_overflow",
            "right_df",
            "_copy",
            "test_default_fill_value_with_no_data",
            "reindex_indexer",
            "test_figsize",
            "dt64arr_cmp_non_datetime",
            "test_CategoricalAccessor_name_deprecation",
            "is_offsetlike",
            "test_getitem_ndarray_3d",
            "test_series_from_coo_incorrect_format_raises",
            "test_replace_gh5319",
            "test_pack_ext_type",
            "test_skip_rows_callable",
            "rjust",
            "test_skiprows_list",
            "test_cdaterange_weekmask_and_holidays",
            "test_concat_will_upcast",
            "object_series",
            "test_series_from_json_precise_float",
            "test_repr_chop_threshold_column_below",
            "test_read_timezone_information",
            "test_period_array_non_period_series_raies",
            "_filter_nodes",
            "_infer_fill_value",
            "test_ix_setitem_out_of_bounds_axis_0",
            "test_reindex_methods",
            "_get_format_datetime64",
            "test_setops_disallow_true",
            "test_fillna_copies",
            "test_invalid_file_not_written",
            "test_dt64_ser_cmp_date_warning",
            "test_df_mod_zero_array",
            "test_setitem_list",
            "test_aggregate_item_by_item",
            "test_tdi_shift_int",
            "test_subclass_sparse_to_frame",
            "test_rename_axis_raises",
            "test_numpy_compat",
            "test_end_year_alias",
            "test_nulls",
            "test_constructor_int_dtype_nan",
            "test_series_fillna_limit",
            "test_bool_types",
            "test_to_datetime_types",
            "test_bool_arith_expr",
            "test_bool_ops_fails_on_scalars",
            "test_color_empty_string",
            "test_numpy_any",
            "test_series_getitem_not_sorted",
            "test_astype_from_datetimelike_to_objectt",
            "test_dt_namespace_accessor_categorical",
            "test_missing_values",
            "test_stata_111",
            "test_empty_frame_dtypes_ftypes",
            "setup_import",
            "table_type_short",
            "test_header_and_one_column",
            "test_subclass_pivot",
            "test_merge_left_empty_right_empty",
            "test_to_csv_unicodewriter_quoting",
            "test_constructor_subclass_dict",
            "test_rank_desc_mix_nans_infs",
            "test_reindex_preserves_names_when_target_is_list_or_ndarray",
            "test_tz_standardize",
            "test_partial_slicing_dataframe",
            "test_skiprows_invalid",
            "_get_data_algo",
            "validate_read",
            "_validate_flavor",
            "test_dti_tz_localize_ambiguous_nat",
            "test_scalar_unary",
            "_return_parsed_timezone_results",
            "test_fillna_empty",
            "test_constructor_invalid_args",
            "_take",
            "test_upsample_sum",
            "test_mi_sparse_disabled",
            "test_numpy_func_call",
            "test_maybe_mangle_lambdas",
            "test_get_standard_colors_default_num_colors",
            "test_mixed_timedelta_datetime",
            "_get_level_lengths",
            "test_ragged_kurt",
            "take_invalid_kwargs",
            "test_arith_alignment_non_pandas_object",
            "_to_sql_save_index",
            "test_fields",
            "test_tdi_iadd_timedeltalike",
            "test_constructor_preserve_attr",
            "test_get_unique_index",
            "test_unstack_fill_frame_categorical",
            "time_subtract",
            "test_floordiv_zero",
            "test_datetime64_dtype_array_returned",
            "_slice_take_blocks_ax0",
            "where",
            "test_store_hierarchical",
            "_setitem_frame",
            "test_on_and_index",
            "_check_has_errorbars",
            "test_errorbar_with_partial_columns",
            "test_store_index_name_with_tz",
            "test_conv_minutely",
            "_zip_axes_from_type",
            "test_repr_html_long",
            "test_setitem_array",
            "rstrip",
            "_construct_axes_dict_for_slice",
            "test_grow_boundary_at_cap",
            "test_sparse_to_dense",
            "_process_subheader_pointers",
            "read_column",
            "_series",
            "_get_page_title",
            "validate_version",
            "_intersection_non_unique",
            "test_iloc_col",
            "_check_all_fields",
            "test_gzip_writing",
            "_construct_divmod_result",
            "test_tuple_categories",
            "test_consistent_format",
            "test_unstack_sparse_keyspace",
            "test_where_unsafe",
            "test_fillna_categorical_nan",
            "test_read_nrows_large",
            "test_usecols_diff_positional_int_columns_order",
            "test_is_offsetlike",
            "test_wide_repr_multiindex",
            "_combine_frame",
            "test_apply_nonuq",
            "test_as_json_table_type_bool_data",
            "test_iloc_mask",
            "test_index_ctor_infer_nat_dt_like",
            "test_td_sub_mixed_most_timedeltalike_object_dtype_array",
            "test_generated_op_names",
            "test_sub_fail",
            "test_select_as_multiple",
            "test_nanskew",
            "_get_sheet_name",
            "_partial_date_slice",
            "test_datetimeindex_from_empty_datetime64_array",
            "test_groupby_selection_with_methods",
            "_get_timestamp_range_edges",
            "test_setitem_series_object",
            "test_dt64arr_add_sub_offset_ndarray",
            "test_read_dta12",
            "test_period_cons_quarterly",
            "_read_sql_iris_named_parameter",
            "_do_convert_missing",
            "test_map_datetimetz",
            "test_construction_with_categorical_dtype",
            "test_apply_axis",
            "read_sql_query",
            "test_groupby_corner",
            "test_head_tail",
            "test_setitem_loc_scalar_multiple_homogoneous",
            "test_concat_categorical_coercion",
            "test_td_rfloordiv_invalid_scalar",
            "_make_table",
            "_is_single_block",
            "test_with_dictlike_columns_with_infer",
            "test_constructor_pi_nat",
            "test_array_hook",
            "test_transpose_object_to_tzaware_mixed_tz",
            "_convert_listlike_datetimes",
            "test_malformed_skipfooter",
            "get_engine",
            "time_read_uint64_neg_values",
            "start_time",
            "time_datetime_field_daysinmonth",
            "test_series_interpolate_intraday",
            "test_getitem_boolean_iadd",
            "test_swaplevel",
            "test_iat_fill_value",
            "test_dti_convert_datetime_list",
            "test_nanmedian",
            "method_returns_something",
            "test_append_raise",
            "test_xs_keep_level",
            "test_ngroup_dupe_index",
            "test_update_raise_on_overlap",
            "time_series_float",
            "test_pivot_integer_bug",
            "test_mixed_dtype_insert",
            "ewm",
            "_aggregate_item_by_item",
            "_indexed_same",
            "nsmallest",
            "test_neg_raises",
            "test_index_make_union",
            "test_construction_month",
            "test_valid_dt_with_missing_values",
            "test_where_align",
            "test_read_excel_multiindex",
            "test_dti_cmp_nat",
            "test_stack_unstack_preserve_names",
            "test_join_on_fails_with_different_right_index",
            "test_with_multi_index",
            "test_get_weeks",
            "test_drop_labels_or_levels_df",
            "test_date_range_span_dst_transition",
            "test_merge_copy",
            "get_kwargs_from_breaks",
            "test_str_query_method",
            "test_update_dtypes",
            "test_representation_to_series",
            "test_incorrect_type_map",
            "test_unpacker_ext_hook",
            "test_index_equal_levels_mismatch",
            "test_sas_read_no_format_or_extension",
            "test_nan_in_object_array",
            "test_quantile_interpolation_int",
            "test_excel_multindex_roundtrip",
            "__delitem__",
            "convert_missing_indexer",
            "read_query",
            "test_index_col_empty",
            "test_math_mult",
            "test_tdi_add_integer_array",
            "test_frame_non_unique_columns",
            "test_string_index_alias_tz_aware",
            "test_empty_print",
            "test_groupby_transform_with_nan_group",
            "_try_convert_to_int_index",
            "_validate",
            "TextParser",
            "test_between_time_axis",
            "test_groupby_multiindex_nat",
            "test_datetime_tz",
            "test_filter_nan_is_false",
            "time_rstrip",
            "_op_maker",
            "test_series_groupby_nunique",
            "test_constructor_infer_freq",
            "test_groupby_resample_on_api",
            "test_to_html_compat",
            "test_dt64_series_arith_overflow",
            "time_frame_drop_dups_na",
            "_make_reader",
            "test_rename_positional_named",
            "get_iterator",
            "test_plotting_with_float_index_works",
            "write_style",
            "test_ftypes",
            "test_astype_categoricaldtype_class_raises",
            "period_array",
            "test_to_latex_series",
            "resolve_name",
            "_get_handle",
            "is_monotonic",
            "test_str_max_colwidth",
            "test_unstack_level_binding",
            "test_construction_with_alt",
            "test_deprecation",
            "_put_str",
            "test_render",
            "test_concatlike_common_period",
            "test_unary_ufunc",
            "test_getitem_setitem_boolean_corner",
            "test_td64arr_add_sub_td64_nat",
            "test_pivot_tz_in_values",
            "test_no_pairwise_with_other",
            "test_series_getitem_duplicates_multiindex",
            "test_secondary_y",
            "test_float64index_slicing_bug",
            "render_templates",
            "test_illegal_names",
            "test_subtype_conversion",
            "test_mixed_string_strl",
            "first_valid_index",
            "_build_doc",
            "maybe_cast_to_datetime",
            "test_dtype_str",
            "_index_freq",
            "test_gcs_get_filepath_or_buffer",
            "test_astype_invalid_dtype",
            "test_compare_array",
            "test_nearest_upsample_with_limit",
            "test_resample_with_non_zero_base",
            "test_dti_shift_no_freq",
            "test_rename_axis_style_raises",
            "test_table_index_incompatible_dtypes",
            "test_extractall_errors",
            "test_setitem_corner2",
            "find",
            "test_tz_localize_pushes_out_of_bounds",
            "test_constructor_single_level",
            "data_repeated",
            "test_round_tzaware",
            "test_as_json_table_type_float_data",
            "is_monotonic_increasing",
            "test_constructor_broadcast_list",
            "test_on_offset",
            "test_to_datetime_with_apply",
            "test_to_datetime_coerce",
            "test_getitem_setitem_datetimeindex",
            "test_astype_object",
            "test_cdaterange_holidays",
            "test_pass_datetimeindex_to_index",
            "test_add",
            "test_valid_tolerance",
            "test_append_duplicates",
            "_convert_strls",
            "test_corrwith_kendall",
            "test_dask",
            "test_group_var_generic_1d",
            "from_dict",
            "test_to_string_length",
            "__array_wrap__",
            "test_setitem_list_not_dataframe",
            "test_frame_equal_row_order_mismatch",
            "test_first_last_valid",
            "validate_dataframe",
            "test_to_frame_resulting_column_order",
            "test_hist_no_overlap",
            "coerce_to_dtypes",
            "test_transform_function_aliases",
            "test_loc_setitem_corner",
            "test_range_closed_boundary",
            "test_split_to_dataframe",
            "test_intersection_equal_sort",
            "test_with_nested_series",
            "test_asfreq_datetimeindex",
            "test_getitem_median_slice_bug",
            "test_store_mixed",
            "masked_arith_op",
            "time_series_nth_all",
            "date_range",
            "test_read_excel_parse_dates",
            "_try_convert_dates",
            "test_replace_simple_nested_dict",
            "check_dtypes",
            "test_return_type",
            "test_arith_flex_frame_raise",
            "test_intersection_non_monotonic",
            "test_comment",
            "test_operators_frame",
            "test_copy_method",
            "swapaxes",
            "time_groupby_ordered_sort",
            "test_tolerance_float",
            "test_get_filepath_or_buffer_with_path",
            "test_min_max_empty",
            "test_basic_dtype",
            "test_join",
            "test_dti_representation",
            "test_constructor_with_win_type",
            "is_platform_linux",
            "test_dtype_coerceion",
            "meta",
            "test_bad_date_parse",
            "test_resample_extra_index_point",
            "test_years_only",
            "_dense_series_compare",
            "test_line_use_index_false",
            "test_resample_integerarray",
            "load_workbook",
            "test_apply_frame_concat_series",
            "test_ix_slicing_strings",
            "test_extractall",
            "_transform_general",
            "test_td64arr_add_sub_timestamp",
            "test_td_rfloordiv_timedeltalike_array",
            "test_transform_axis",
            "test_bar_align_left",
            "test_dt64arr_cmp_scalar_invalid",
            "test_td_add_datetimelike_scalar",
            "test_connectable_issue_example",
            "test_out_of_bounds_value",
            "test_is_strictly_monotonic_increasing",
            "test_sort_index_kind",
            "_get_marker_compat",
            "test_constructor_dict_block",
            "test_complex_across_dimensions",
            "test_groups",
            "test_resample_timegrouper",
            "test_astype_generic_timestamp_no_frequency",
            "_to_sql_append",
            "test_frame_indexing_multiple",
            "argsort",
            "_new_Index",
            "test_groupby_duplicated_column_errormsg",
            "drop",
            "test_dti_construction_ambiguous_endpoint",
            "test_excel_old_index_format",
            "test_hexbin_cmap",
            "test_pi_add_offset_n_gt1_not_divisible",
            "_get_unicode_name",
            "test_to_string_float_index",
            "test_nancorr_spearman",
            "_make_arithmetic_op",
            "test_scatter_colors",
            "test_properties_weekly",
            "test_interp_quad",
            "test_operators_timedelta64",
            "test_margins_no_values_one_row_one_col",
            "test_agg_datetimes_mixed",
            "test_cython_transform_frame",
            "test_comparisons_nat",
            "test_series_with_dtype_radd_timedelta",
            "_ensure_scope",
            "test_rsub_object",
            "pie",
            "test_no_rounding_occurs",
            "test_append_all_nans",
            "test_categorical_block_pickle",
            "test_empty_dataframe_groupby",
            "test_dti_add_intarray_non_tick",
            "test_subtraction_ops_with_tz",
            "test_loc_iloc_frame_single_dtype",
            "test_maybe_numeric_slice",
            "deprecate",
            "_write_variable_labels",
            "test_timedelta_fillna",
            "testStrictUnicodeUnpack",
            "test_neg_object",
            "test_to_timestamp_freq",
            "test_replace_with_no_overflowerror",
            "test_stack_level_name",
            "check_bool",
            "_convert_to_border",
            "test_encode_list_long_conversion",
            "test_construction_bday",
            "test_to_string_truncate_multilevel",
            "_check_axes_shape",
            "test_append_with_data_columns",
            "test_to_csv_single_level_multi_index",
            "time_no_exact",
            "test_constructor_periodindex",
            "format_timedelta_ticks",
            "test_pivot_table_dropna_categoricals",
            "test_dataframe_dummies_drop_first",
            "test_testing",
            "test_store_index_types",
            "test_concat_iterables",
            "test_encode_array_of_nested_arrays",
            "test_finder_minutely",
            "create_table_index",
            "test_applymap",
            "test_count_uses_size_on_exception",
            "test_groupby_blacklist",
            "test_pivot_duplicates",
            "_skip_if_no_scipy",
            "time_copy_overhead_single_col",
            "to_sparse",
            "test_epoch",
            "test_join_multi_levels2",
            "test_ops_frame_period",
            "test_parse_date_fields",
            "set_function_name",
            "test_transform_exclude_nuisance",
            "_get_format_timedelta64",
            "test_extension_array_labels",
            "test_sum_object",
            "test_getitem_setitem_boolean_multi",
            "get_labels_levels",
            "test_join_period_index",
            "test_mixed_comparison",
            "time_to_sql_dataframe",
            "test_constructor_dict_timedelta64_index",
            "snap",
            "test_bool_with_none",
            "test_where_unobserved_nan",
            "test_write_append_mode",
            "test_series_set_value",
            "_maybe_wrap_formatter",
            "test_groupby_max_datetime64",
            "test_banklist_url",
            "test_series_setitem",
            "test_loc_with_interval",
            "test_contiguous_mixed_data_table",
            "reorder_categories",
            "test_delete_raises",
            "check_single_invert_op",
            "time_subtract_datetimes",
            "_maybe_promote",
            "test_disallow_scalar_bool_ops",
            "test_multiindex_slice_first_level",
            "test_between_time_types",
            "test_lexsort_indexer",
            "test_stable_descending_multicolumn_sort",
            "test_empty_pass_dtype",
            "test_errorbar_timeseries",
            "test_array_i8_dtype",
            "test_nankurt",
            "test_object_factorize",
            "test_series_agg_multi_pure_python",
            "maybe_castable",
            "test_setitem_raises_incompatible_freq",
            "_is_dates_only",
            "sort_values",
            "test_categorical_index_repr_timedelta",
            "test_pandas_plots_register",
            "test_convert_pandas_type_to_json_field_int",
            "test_groupby_transform_with_datetimes",
            "test_match_findall_flags",
            "test_isin_nan_pypy",
            "test_time_series_plot_color_with_empty_kwargs",
            "test_rolling_std_neg_sqrt",
            "test_isin_df",
            "test_conv_weekly",
            "test_repr_binary_type",
            "test_modulus",
            "test_expanding_apply_args_kwargs",
            "test_bdays_and_open_boundaries",
            "test_write_missing_strings",
            "test_as_json_table_type_string_dtypes",
            "test_resolution",
            "test_iter",
            "mask_cmp_op",
            "test_loc_setitem_empty_append",
            "test_boolean_ops",
            "test_cat_on_filtered_index",
            "test_invalid_colormap",
            "test_reshaping_multi_index_categorical",
            "__sub__",
            "test_date_query_no_attribute_access",
            "test_get_offset_legacy",
            "test_missing_value_conversion",
            "test_asfreq_fillvalue",
            "test_complex_indexing_error",
            "test_read_sql_iris",
            "test_skipfooter_with_decimal",
            "time_wide_to_long_big",
            "test_groupby_groups_in_BaseGrouper",
            "test_datetime_timedelta_quantiles",
            "test_query_inplace",
            "test_invalid_unit",
            "test_get_label_or_level_values_df_ambig",
            "nanvar",
            "_convert_by",
            "test_basic_indexing",
            "test_time_overflow_for_32bit_machines",
            "test_to_string_na_rep",
            "_create_categorical",
            "test_xs_named_levels_axis_eq_1",
            "_get_footer",
            "test_addition_subtraction_preserve_frequency",
            "test_apply_use_categorical_name",
            "test_timedelta_arithmetic",
            "test_duplicated_nan_none",
            "get_hits",
            "test_non_sorted",
            "test_dti_tz_convert_compat_timestamp",
            "test_info_categorical_column",
            "test_9",
            "test_infer_types",
            "test_join_empty_bug",
            "_adjust_bin_edges",
            "test_has_duplicates_overflow",
            "test_pi_shift_ndarray",
            "_check_offsetfunc_works",
            "test_sortlevel_deterministic",
            "test_observed",
            "_write_varnames",
            "_add_numeric_methods_unary",
            "test_td64arr_sub_timedeltalike",
            "test_getitem_setitem_slice_integers",
            "test_sparse",
            "merge_asof",
            "test_range_slice_seconds",
            "test_write_multiindex",
            "test_pi_add_sub_td64_array_tick",
            "srcpath",
            "test_format_datetime_with_time",
            "test_resample_unequal_times",
            "_annual_finder",
            "test_get_label_or_level_values_series_axis0",
            "test_interp_limit_before_ends",
            "test_categorical_dtype_missing",
            "test_replace_callable",
            "any",
            "test_resample_ohlc_result",
            "skipif_32bit",
            "format_name",
            "test_join_multi_dtypes",
            "test_start_stop_table",
            "test_series_grouper",
            "test_pickle_v0_14_1",
            "_format_with_header",
            "test_nested_raises_on_local_self_reference",
            "normalize",
            "_execute_sql",
            "time_groupby_extra_cat_sort",
            "test_crosstab_single",
            "test_read_excel_squeeze",
            "test_df_add_2d_array_collike_broadcasts",
            "is_datetime64_any_dtype",
            "test_mi_sparse",
            "test_if_scatterplot_colorbars_are_next_to_parent_axes",
            "_sparse_series_op",
            "test_with_max_level",
            "_series_and_2d_ndarray",
            "test_set_option",
            "test_with_offset",
            "_get_row_repeat",
            "_has_plotted_object",
            "test_xs_missing_values_in_index",
            "test_basic_period_index_boolean_expression",
            "test_equals_categorical",
            "test_ignore_downcast_invalid_data",
            "test_regex_replace_dict_mixed",
            "test_rdivmod_invalid",
            "test_map_categorical",
            "test_concat_inner_sort",
            "test_is_hashable",
            "test_pie_nan",
            "is_numeric_dtype",
            "test_concat_dict",
            "test_simple_normalize",
            "test_compressed_urls",
            "test_properties_business",
            "test_any_all_level_axis_none_raises",
            "_gen_fill_zeros",
            "add_prefix",
            "test_count_level",
            "test_duplicated_on_empty_frame",
            "test_parse_public_s3n_bucket",
            "_format_attrs",
            "test_window_with_args",
            "test_constructor_compound_dtypes",
            "test_boolean_set_uncons",
            "test_frame_comparison",
            "test_unit_mixed",
            "test_groupby_transform_with_int",
            "test_notna",
            "_validate_for_numeric_binop",
            "test_detect_chained_assignment_warnings_filter_and_dupe_cols",
            "assert_sp_array_equal",
            "test_repr_unsortable",
            "test_set_axis_name_raises",
            "_parse_numpy",
            "to_parquet",
            "_maybe_get_mask",
            "test_dti_set_index_reindex",
            "test_stack_preserve_categorical_dtype",
            "test_set_axis_prior_to_deprecation_signature",
            "test_unknown_engine",
            "from_coo",
            "test_setitem_with_string_index",
            "create_mgr",
            "test_indexing_over_hashtable_size_cutoff",
            "test_merge_equal_cat_dtypes",
            "test_from_file",
            "test_fillna_col_reordering",
            "fetch",
            "test_td64arr_div_numeric_scalar",
            "_get_single_key",
            "test_setitem_multiindex",
            "test_abc_types",
            "test_is_scalar_pandas_scalars",
            "test_resample_nunique",
            "ensure_python_int",
            "read_sql",
            "na_value_for_dtype",
            "test_no_nonsense_name",
            "test_unicode_string_with_unicode",
            "test_int_bins_with_inf",
            "test_properties_monthly",
            "_maybe_rename_join",
            "make_block_array",
            "_decorate_axes",
            "test_insert_with_columns_dups",
            "time_pivot_table_margins",
            "test_no_new_locals",
            "setup_method",
            "test_select_iterator_many_empty_frames",
            "test_quarterly_dont_normalize",
            "_replace_booleans",
            "test_really_large_scalar",
            "test_concat_axis_parameter",
            "test_cast_1d_array_like_from_scalar_categorical",
            "test_simple_arith_ops",
            "test_value_labels_old_format",
            "_remove_empty_lines",
            "test_cmov_window_special",
            "test_maybe_indices_to_slice_right_edge",
            "test_repr_html_long_and_wide",
            "test_rename_mapper_multi",
            "test_construct_over_dst",
            "test_frame_setitem_copy_raises",
            "_check_visible",
            "_check_legend_labels",
            "test_constructor_with_tz",
            "test_sort_index_intervals",
            "test_frame_append_datetime64_col_other_units",
            "test_groupby_includes_fill_value",
            "test_make_time_series",
            "test_thead_without_tr",
            "test_contains_method",
            "test_lookup",
            "test_constructor_period_incompatible_frequency",
            "__rfloordiv__",
            "test_reset_index_with_intervals",
            "test_get_label_or_level_values_df_simple",
            "test_to_timestamp_tz_arg_dateutil_from_string",
            "test_fails_or",
            "is_string_like_dtype",
            "test_springforward_plural",
            "test_intersection_cases",
            "test_secondary_y_regular_ts_xlim",
            "_translate",
            "test_df_float_none_comparison",
            "test_at_time_axis",
            "test_objarr_add_invalid",
            "test_td64arr_sub_offset_index",
            "test_order_matters",
            "test_td_add_sub_ten_seconds",
            "test_align_series_combinations",
            "test_encode_list_conversion",
            "test_to_html_columns_arg",
            "test_sort_index_na_position_with_categories_raises",
            "test_dti_tz_localize_naive",
            "_isfinite",
            "_interpolate",
            "test_delete",
            "test_dti_tz_localize_ambiguous_infer",
            "test_to_csv_decimal",
            "test_iloc_setitem_series",
            "test_apply_modify_traceback",
            "test_all_nans",
            "set_clipboard",
            "test_ensure_index_mixed_closed_intervals",
            "cherry_pick",
            "test_from_records_empty",
            "test_dont_modify_rcParams",
            "test_exception_importable",
            "_plot",
            "_make_date_converter",
            "_plot_colorbar",
            "test_multi_iter",
            "test_max_level_with_records_path",
            "append",
            "test_subplots_warnings",
            "test_to_flat_index",
            "test_union_base",
            "rename_categories",
            "test_ts_plot_format_coord",
            "test_get_label_or_level_values_series_axis1_error",
            "test_float_series_rdiv_td64arr",
            "test_dont_clobber_name_column",
            "compute",
            "test_default_right_closed_label",
            "test_df_boolean_comparison_error",
            "test_parsers_dayfirst_yearfirst",
            "test_from_M8_structured",
            "group_info",
            "_write_to_group",
            "test_concat_different_columns_buggy",
            "test_on_float_by_int",
            "test_bday_overflow_error",
            "test_select_iterator_non_complete_8014",
            "write_tr",
            "test_concat_invalid",
            "test_join_index_mixed_overlap",
            "test_agg_relabel",
            "test_to_period_annualish",
            "test_multiple_agg_funcs",
            "get_empty_dtype_and_na",
            "test_dropIncompleteRows",
            "_merger",
            "groupings",
            "test_subclass_attr_err_propagation",
            "test_comparison_op_scalar",
            "test_resample_5minute",
            "test_with_mixed_tuples",
            "test_bad_kwarg",
            "test_shift_fill_value",
            "test_info_repr_max_cols",
            "test_constructor_generator",
            "test_ndarray_compat",
            "_rewrite_assign",
            "maybe_infer_to_datetimelike",
            "validate_groupby_func",
            "test_append_with_diff_col_name_types_raises_value_error",
            "test_format_sparse_config",
            "test_frame_select_complex2",
            "test_astype_asfreq",
            "_value_with_fmt",
            "test_unstack_period_frame",
            "test_streaming_s3_objects",
            "test_get_accessor_args",
            "test_MillisecondTimestampArithmetic",
            "test_from_categorical_dtype_categories",
            "test_to_csv_from_csv4",
            "test_namespace",
            "get_finder",
            "test_unique_datetimelike",
            "test_str_cat_all_na",
            "test_loc_index_fill_value",
            "test_integer_col_names",
            "time_cython_sum",
            "objSeries",
            "test_agg_misc",
            "test_is_datetime_or_timedelta_dtype",
            "test_dropEmptyRows",
            "test_hexbin_basic",
            "test_apply_differently_indexed",
            "_prep_binary",
            "test_groupby_resample_on_api_with_getitem",
            "test_datetimeindex_diff",
            "_compare_or_regex_search",
            "with_csv_dialect",
            "test_unbalanced",
            "_format_strings",
            "test_get_loc_raises_bad_label",
            "test_join_overlap",
            "test_timegrouper_get_group",
            "test_dt_accessor_datetime_name_accessors",
            "test_concat_with_group_keys",
            "test_from_arrays_tuples",
            "test_count_level_corner",
            "test_multi_thread_string_io_read_csv",
            "test_subclass_sparse_slice",
            "test_2",
            "test_xs_level_series_ymd",
            "get_root",
            "test_string_index_series_name_converted",
            "test_minimal_size_col",
            "hexbin",
            "_has_same_tz",
            "test_assigning_ops",
            "test_standard_colors",
            "show_row_idx_names",
            "test_offset_whole_year",
            "test_categorical_repr_timedelta",
            "time_multi_size",
            "test_scalar_non_numeric",
            "test_index_duplicate_periods",
            "assignment_not_inplace",
            "test_date_accessor",
            "test_td64arr_mul_tdscalar_invalid",
            "test_asfreq_bug",
            "test_version",
            "test_basic_names_raise",
            "test_operators_na_handling",
            "_make_plot",
            "test_series_grid_settings",
            "tests_merge_categorical_unordered_equal",
            "test_constructor_nan_dataframe",
            "test_ix_loc_consistency",
            "test_rename_errors_raises",
            "test_global_scope",
            "test_parse_failure_rewinds",
            "get_dummies",
            "test_array",
            "test_array_tz",
            "__doc__",
            "test_constructor_datetimes_with_nulls",
            "test_pipe_args",
            "test_getitem_list_periods",
            "test_onecolumn_of_integer",
            "write_legacy_msgpack",
            "test_query_default",
            "test_codes_dtypes",
            "test_map_counter",
            "test_date",
            "test_read_write_dta5",
            "test_repr_with_mi_nat",
            "test_filter_and_transform_with_non_unique_timestamp_index",
            "test_value_counts_datetime_outofbounds",
            "test_invalid_timestamp",
            "test_td64_mean",
            "test_parr_add_sub_dt64_array_raises",
            "test_rolling_kurt",
            "test_array_equivalent_str",
            "test_to_string_decimal",
            "test_constructor_mixed_tz",
            "test_loc_multi_tuple",
            "test_ragged_skew",
            "test_from_records_iterator",
            "test_assert_almost_equal_class_mismatch",
            "test_pi_ops_offset",
            "test_range_kwargs_deprecated",
            "test_string_repr_encoding",
            "test_Nanosecond",
            "test_indices_concatenation_order",
            "gen_series_formatting",
            "test_constant",
            "test_nat_parse",
            "test_ix_dup",
            "time_nsmallest_one_column",
            "boxplot_frame",
            "test_pi_sub_pi_with_nat",
            "test_nan_numeric",
            "test_write_dta6",
            "test_numexpr_builtin_raises",
            "test_astype_nan_raises",
            "test_to_datetime_infer_datetime_format_series_start_with_nans",
            "get_indexer_dict",
            "test_difference_empty_arg",
            "test_repr_html_ipython_config",
            "_calcsize",
            "test_split_to_multiindex_expand",
            "test_invalid_total_length_max_length_multiple",
            "test_rank_resets_each_group",
            "test_categorical_equality_strings",
            "test_parse_timezone",
            "visit_Call",
            "test_reindex_like",
            "test_iterrows_iso8601",
            "use_bottleneck_cb",
            "test_grouped_hist_multiple_axes",
            "test_nonnumeric_suffix",
            "test_to_csv_from_csv5",
            "validate_resampler_func",
            "test_set_axis_name_mi",
            "json_normalize",
            "test_pi_sub_isub_int",
            "_coerce_to_type",
            "test_identity_slice_returns_new_object",
            "test_api",
            "test_constructor_coverage",
            "add_ops",
            "test_other_columns",
            "_format_multirow",
            "_validate_fill_value",
            "squeeze",
            "test_groupby_multiindex_series_keys_len_equal_group_axis",
            "test_groupby_cum_skipna",
            "test_setitem",
            "_chunk_to_dataframe",
            "test_multifunc_sum_bug",
            "test_view_with_args",
            "test_td_div_numeric_scalar",
            "test_binary_ufunc_with_series",
            "test_csv_custom_parser",
            "test_fillna",
            "test_offset_deprecated",
            "time_extract",
            "test_is_string_array",
            "test_sample",
            "test_reindex_columns",
            "test_colspan_rowspan_both_not_1",
            "test_where_with_bool_data_and_other",
            "_style_to_xlwt",
            "test_empty_series_frame",
            "test_on_index_object",
            "nrows",
            "test_read_invalid_types_raises",
            "test_equality_generic",
            "test_examples3",
            "execute",
            "test_get_loc_msg",
            "time_groupby_nth_all",
            "test_roundtrip_indexlabels",
            "lines_json_df",
            "test_categorical_nans",
            "test_asof_datetime_partial",
            "test_series_getitem",
            "test_first_last_nth_dtypes",
            "_dt_array_cmp",
            "test_set_categories_many",
            "init_xclip_clipboard",
            "test_to_string_unicode_columns",
            "round",
            "all_packers_data",
            "test_resample_loffset",
            "test_pipe_tuple_error",
            "test_frame_operators",
            "test_none",
            "test_maybe_convert_objects_uint64",
            "test_astype_extension_dtypes_duplicate_col",
            "_skip_if_no_pchip",
            "test_arith_flex_zero_len_raises",
            "test_astype_mixed_type",
            "test_invalid_local_variable_reference",
            "test_delitem",
            "test_stack_multiple_out_of_bounds",
            "_sparsify",
            "test_merge_index_as_on_arg",
            "test_replace_period",
            "test_get_indexer_non_unique_with_int_and_float",
            "test_string_nas",
            "test_read_fspath_all",
            "validate_fillna_kwargs",
            "test_xlrd_version_fallback",
            "test_concat_different_columns_sort_warns",
            "test_agg_apply",
            "test_usecols_with_parse_dates_and_names",
            "test_empty_sum",
            "test_fillna_fill_value",
            "_unpickle_sparse_frame_compat",
            "test_wikipedia_states_table",
            "test_pivot_with_multiindex",
            "test_Easter",
            "_maybe_convert_timedelta",
            "_maybe_convert_usecols",
            "identical",
            "test_date_range_nat",
            "test_getitem_fancy_1d",
            "test_ngroup_empty",
            "test_latex_repr",
            "test_join_non_unique_period_index",
            "time_multiple_date",
            "_python_apply_general",
            "test_sort_values_categorical",
            "test_from_dict_columns_parameter",
            "test_inplace_mutation_resets_values",
            "test_first_subset",
            "test_getitem_partial_int",
            "test_invalid_suffixtype",
            "_get_monthly_rule",
            "_unpack_cycler",
            "test_to_datetime_on_datetime64_series",
            "test_idxmin",
            "test_fallback_success",
            "test_write_fspath_all",
            "test_from_frame_error",
            "time_write_store",
            "_validate_join_method",
            "test_imethods_with_dups",
            "test_extractall_same_as_extract_subject_index",
            "test_setitem_mask_broadcast",
            "test_set_ordered",
            "read_sql_table",
            "test_scalar_assignment",
            "test_interp_inplace",
            "timedelta_range",
            "test_ambiguous_width",
            "test_convert_objects",
            "time_on_int32",
            "test_constructor",
            "test_resample_how_callables",
            "makeUIntIndex",
            "_box_as_indexlike",
            "test_constructor_with_int_tz",
            "_start",
            "test_sort_index_duplicates",
            "test_to_period_quarterly",
            "size",
            "_putmask_smart",
            "test_pandas_dtypes",
            "test_registering_no_warning",
            "rolling",
            "test_dispatch_transform",
            "test_properties_daily",
            "test_multiple_aggregators_with_dict_api",
            "test_secondary_axis_font_size",
            "test_groupby_level_mapper",
            "test_iter_single_element",
            "assert_block_equal",
            "_agg_index",
            "test_is_number",
            "test_constructor_invalid_Z0_isostring",
            "test_aggregate_float64_no_int64",
            "test_series_add_aware_naive_raises",
            "file_filter",
            "_create_unary_method",
            "test_infer_objects_series",
            "test_replace_across_dst",
            "test_bigint_warning",
            "test_align_int",
            "_query_iterator",
            "test_reindex_preserves_type_if_target_is_empty_list_or_array",
            "testFixnum",
            "test_subclass",
            "zfill",
            "has_truncated_repr",
            "test_constructor_categorical_series",
            "test_resample_timestamp_to_period",
            "test_take2",
            "test_not_reflect_all_tables",
            "ravel",
            "test_append_different_columns_types",
            "test_period_cons_annual",
            "test_wrong_num_labels",
            "standardize_mapping",
            "test_constructor_range_dtype",
            "test_all",
            "update_dtype",
            "_get_formatted_index",
            "test_check_dtype",
            "test_agg_structs_series",
            "mask_zero_div_zero",
            "test_slice_month",
            "_load_test2_data",
            "test_dti_tz_localize_ambiguous_flags",
            "test_scalar_call_versus_list_call",
            "_get_level_values",
            "test_rename_categories",
            "test_multi_index_parse_dates",
            "test_join_indexes_and_columns_on",
            "test_replace_replacer_equals_replacement",
            "test_date_range_int64_overflow_stride_endpoint_different_signs",
            "test_to_csv_string_with_crlf",
            "test_stack_dropna",
            "test_filter_using_len",
            "test_rsplit_to_dataframe_expand",
            "_get_codes_for_values",
            "test_get_loc_scalar",
            "time_rsplit",
            "mgr",
            "test_series_tz_localize_ambiguous_bool",
            "test_transform_datetime_to_numeric",
            "test_getitem_setitem_tuple_plus_columns",
            "test_repr_max_columns_max_rows",
            "test_fillna_different_dtype",
            "time_lstrip",
            "test_eq_with_numpy_object",
            "test_float_array_different_kind",
            "test_messed_up_data",
            "test_get_loc_raises_object_tolerance",
            "test_scalar_with_mixed",
            "time_small_get_loc_warm",
            "test_create_table_index",
            "test_fillna_object",
            "_get_index_freq",
            "_get_complex_date_index",
            "test_read_excel_multiindex_empty_level",
            "test_reset_index_level",
            "test_pi_add_iadd_timedeltalike_hourly",
            "test_loc_slice_fill_value",
            "test_corrwith_index_intersection",
            "str_repeat",
            "test_set_index_names",
            "test_is_monotonic_increasing",
            "test_ops_datetimelike_align",
            "test_construction",
            "test_reindex_axis_style_raises",
            "test_sub_n_gt_1_ticks",
            "test_pow",
            "test_frame_to_dict_tz",
            "test_series_ret_bins",
            "test_tolist",
            "test_parse_date_column_with_empty_string",
            "test_is_scalar_numpy_zerodim_arrays",
            "test_conv_monthly",
            "test_drop_exception_raised",
            "test_groupby_with_single_column",
            "test_numpy_round",
            "test_slicing_doc_examples",
            "to_records",
            "test_nat_arithmetic_scalar",
            "_set_result_index_ordered",
            "test_by_int",
            "test_align_series_frame",
            "test_mixed_depth_insert",
            "test_info_repr",
            "test_repr_small",
            "versions_from_file",
            "_get_join_keys",
            "mix_abc",
            "test_to_datetime_today_now_unicode_bytes",
            "test_cr_delimited",
            "test_multi_line_expression_local_variable",
            "_reference_dates",
            "test_needs_i8_conversion",
            "test_transform_bug",
            "test_values_numeric_cols",
            "test_ewmvol",
            "_recast_datetimelike_result",
            "test_subtype_integer_errors",
            "mask",
            "test_nansem",
            "_compose",
            "test_to_datetime_utc",
            "test_to_csv",
            "test_argsort_stable",
            "test_mi_sparse_column_names",
            "test_datetime_tz_qcut",
            "test_from_csv",
            "test_apply_multikey_corner",
            "test_resample_timedelta_idempotency",
            "test_contains_with_nat",
            "time_read_csv",
            "test_merge_overlap",
            "time_encode_decode",
            "test_iloc_slice",
            "test_sharex_and_ax",
            "test_period_ops_offset",
            "test_parse_booleans",
            "validate_all",
            "test_boolean_index_empty_corner",
            "test_merge_suffix",
            "test_ewmcov_pairwise",
            "test_slice_locs_dup",
            "linkcode_resolve",
            "_remove_labels_from_axis",
            "test_numeric_only_flag",
            "test_scalar_raises",
            "test_multi_line_expression_callable_local_variable",
            "test_excel_table",
            "test_apply_attach_name",
            "test_frame_values_with_tz",
            "test_dti_tz_localize_nonexistent",
            "test_list_numpy_float_complex",
            "save",
            "test_indexing_ambiguity_bug_1678",
            "test_true_and_false_value_options",
            "test_operators_bitwise",
            "test_numpy_string_dtype",
            "test_agg_category_nansum",
            "test_tz_localize_errors_invalid_arg",
            "test_join_index_more",
            "test_basic_sort",
            "test_quantile_empty",
            "_add_series_or_dataframe_operations",
            "_akima_interpolate",
            "test_td_rfloordiv_null_scalar",
            "test_dti_eq_null_scalar",
            "_check_frame_ops",
            "test_interp_alt_scipy",
            "test_unicode_repr_level_names",
            "_join_multi",
            "test_merge_on_indexes",
            "is_null_slice",
            "take_2d_multi",
            "simple_multiindex_dataframe",
            "test_date_range_gen_error",
            "test_parse_ragged_csv",
            "_add_delta",
            "test_to_csv_no_index",
            "test_valid_allow_exact_matches",
            "_create_methods",
            "_get_data_as_items",
            "merge",
            "test_mode_timedelta",
            "test_copy",
            "m_offset",
            "test_resample_interpolate",
            "test_concat_multiindex_with_none_in_index_names",
            "_write_row_header",
            "_add_offset",
            "test_more_than_one_expression_raises",
            "maybe_cast_to_integer_array",
            "test_stack_unstack",
            "test_unicode_name_in_footer",
            "test_convert_pandas_type_to_json_field_categorical",
            "test_corrwith_spearman",
            "peakmem_int",
            "test_selection_by_datetimelike",
            "test_ctor_str_intraday",
            "test_getitem_seconds",
            "_maybe_restore_index_levels",
            "test_calendar_observance_dates",
            "compress_file",
            "test_mixed_datetime64",
            "ensure_clean_dir",
            "test_td64arr_sub_pi",
            "test_resample_segfault",
            "test_sheet_name",
            "test_datetime_tz_cut",
            "test_to_string_with_formatters_unicode",
            "plt",
            "test_kurt",
            "test_strings",
            "test_unordered_different_order_equal",
            "_try_cast_result",
            "_handle_hidden_tables",
            "test_multiple_tbody",
            "test_from_inferred_categories_dtype",
            "test_idxmin_idxmax_returns_int_types",
            "test_to_datetime_iso8601",
            "test_apply_without_aggregation",
            "_concat_categorical",
            "test_map",
            "test_as_json_table_type_bool_dtypes",
            "test_reindex_non_unique",
            "raise_assert_detail",
            "test_partition_with_name",
            "write_th",
            "test_config_prefix",
            "_is_type_compatible",
            "test_regular_min",
            "test_from_records_non_tuple",
            "fill_frame",
            "test_isin_dupe_self",
            "time_rpartition",
            "pytest_runtest_setup",
            "test_override_set_noconvert_columns",
            "test_join_right",
            "test_subclass_sparse_addition",
            "test_query_empty_string",
            "format_object_summary",
            "get_key",
            "to_dense",
            "test_constructor_not_sequence",
            "test_neg",
            "test_unit_m_y_deprecated",
            "test_merge_join_key_dtype_cast",
            "isiterable",
            "test_frame_groupby",
            "test_union",
            "test_rolling_median_resample",
            "set_atom_datetime64",
            "test_read_s3_with_hash_in_key",
            "test_skiprows_lineterminator",
            "time_multiply",
            "last_valid_index",
            "test_maybe_convert_i8_errors",
            "test_delevel_infer_dtype",
            "test_closed_uneven",
            "_join_index",
            "scatter_matrix",
            "test_resample_ohlc_dataframe",
            "_setup_dtype",
            "_workbook_class",
            "test_rolling_min_max_numeric_types",
            "_union",
            "test_iloc_getitem_frame",
            "test_get_schema_keys",
            "test_resample_groupby_with_label",
            "test_errors_param_filters_errors",
            "test_boxplot_legacy2",
            "time_format_YYYYMMDD",
            "dropna",
            "test_size",
            "test_mi_sparse_index_names",
            "_setitem_array",
            "test_fillna_preserves_tz",
            "test_reset_index_period",
            "test_header_multi_index_common_format_malformed3",
            "_get_slice_axis",
            "test_line_lim",
            "test_default_na_values",
            "test_iteritems",
            "write_td",
            "test_print_unicode_columns",
            "test_exponents_with_eng_prefix",
            "test_expanding_corr_cov",
            "search",
            "test_logical_ops_with_index",
            "test_single_backtick_variable_expr",
            "_get_ax_freq",
            "_read_strls",
            "test_td64arr_mul_numeric_scalar",
            "test_categorical_concat_gh7864",
            "is_non_overlapping_monotonic",
            "test_set_names_with_nlevel_1",
            "generate",
            "test_readjson_chunks_from_file",
            "test_datetime_likes",
            "test_where_different_freq_raises",
            "sql_schema",
            "test_to_html_truncation_index_false_max_cols",
            "test_basic_left_index",
            "test_error_iso_week_year",
            "_is_metadata_of",
            "test_works_on_valid_markup",
            "test_concat_astype_dup_col",
            "test_slice_locs_partial",
            "test_constructor_list_str_na",
            "test_precise_conversion",
            "_create_blocks",
            "test_astype_object2",
            "contains",
            "test_getitem_partial",
            "test_boolean_comparison",
            "test_date_range_timestamp_equiv_preserve_frequency",
            "asfreq",
            "test_join_on_tz_aware_datetimeindex",
            "time_setitem_period_column",
            "_any_pandas_objects",
            "form_blocks",
            "test_add_series_with_extension_array",
            "test_merge_on_periods",
            "test_non_string_na_values",
            "set_names",
            "at_time",
            "test_apply_index",
            "test_regex_replace_regex_list_to_numeric",
            "test_basic_getitem_with_labels",
            "init_klipper_clipboard",
            "_maybe_right_yaxis",
            "test_quantile",
            "test_align_mixed_int",
            "test_assert_almost_equal_edge_case_ndarrays",
            "_check_is_chained_assignment_possible",
            "test_truncate_nonsortedindex",
            "test_frame_append_datetime64_column",
            "test_line_label_none",
            "test_start_stop_fixed",
            "test_iat_setter_incompatible_assignment",
            "test_partial_set_empty_frame",
            "test_ufunc_at",
            "test_factorize_na_sentinel",
            "test_read_jsonl_unicode_chars",
            "valid",
            "current_pickle_data",
            "__sizeof__",
            "test_group_shift_with_fill_value",
            "test_pivot_table_dropna",
            "_assert_safe_casting",
            "test_logical_operators",
            "test_groupby_with_empty",
            "df_full",
            "test_to_csv_with_single_column",
            "test_partial_slice_minutely",
            "test_float_same_index",
            "test_cmp_dt64_arraylike_tznaive",
            "_get_counts_nanvar",
            "test_lookup_array",
            "test_getitem_dups",
            "test_assert_almost_equal_value_mismatch1",
            "_maybe_downcast_constants",
            "sort_index",
            "is_list_like_indexer",
            "test_getitem_sparse_column",
            "test_floordiv_div",
            "set_atom_string",
            "stack_sparse_frame",
            "test_apply_trivial_fail",
            "test_normalize_tz",
            "time_read_csv_python_engine",
            "test_setitem_change_dtype",
            "time_nsmallest_two_columns",
            "from_array",
            "test_first_raises",
            "set_atom_datetime64tz",
            "test_set_axis_name",
            "test_compare_zerodim_array",
            "test_object_series_ok",
            "time_first",
            "test_groupby_series_with_name",
            "test_fill_method_and_how_upsample",
            "test_any_datetime",
            "test_sub_period",
            "test_rolling_cov_offset",
            "test_basic_index",
            "_upsample",
            "test_filter_and_transform_with_non_unique_int_index",
            "test_tab_complete_ipython6_warning",
            "test_dti_custom_getitem",
            "test_latin_encoding",
            "test_transform_and_agg_error",
            "test_transpose_tzaware_1col_single_tz",
            "test_read_duplicate_index_explicit",
            "test_resample_across_dst",
            "test_itemsize",
            "test_numpy_array_float",
            "_replace_single",
            "convert_pandas_type_to_json_field",
            "test_per_axis_per_level_setitem",
            "test_col_level",
            "test_str_attribute",
            "test_date_col_as_index_col",
            "test_frame_join_tzaware",
            "test_categorical_shift_fill_value",
            "test_header_multi_index_common_format3",
            "_set_values",
            "test_memory_usage",
            "test_unit_with_numeric",
            "test_index_name",
            "datetime_series",
            "_set_names",
            "time_from_missing",
            "test_closed_min_max_datetime",
            "test_legend_name",
            "test_weekly_upsample",
            "test_basics_with_nan",
            "test_frame_loc_callable",
            "_convert_to_style",
            "_get_annual_rule",
            "time_transform_multi_key3",
            "test_frame_describe_tupleindex",
            "read_table",
            "recode_from_groupby",
            "test_period_with_agg",
            "test_num_string_disambiguation",
            "test_dti_tz_constructors",
            "test_plot_bar",
            "_disallow_scalar_only_bool_ops",
            "test_to_string_format_na",
            "test_nan",
            "test_dti_snap",
            "test_infer_from_tdi",
            "test_float_arithemtic",
            "test_dt64arr_add_sub_tick_DateOffset_smoke",
            "test_frame_mi_access_returns_frame",
            "test_initial_warning",
            "test_tricky_container",
            "test_different_nans_as_float64",
            "time_divide",
            "test_assign_index_sequences",
            "test_concat_mixed_objs",
            "test_set_dataframe_column_ns_dtype",
            "time_iso8601_format",
            "test_iloc_setitem_list_of_lists",
            "test_cut_read_only",
            "test_categorical_warnings_and_errors",
            "write_data",
            "_infer_columns",
            "time_groupby_extra_cat_nosort",
            "_engine",
            "test_complex_fixed",
            "test_api_mi_raises",
            "_asof_by_function",
            "test_pivot_table_with_nans",
            "test_nanosecond_resample_error",
            "test_bar_align_single_column",
            "nancov",
            "test_dti_shift_int",
            "_center_window",
            "test_single_common_level",
            "test_cummax_datetime64",
            "test_positional_take",
            "test_complex_series_error",
            "test_partial_slice_daily",
            "test_binary_ufunc_drops_series_name",
            "test_constructor_with_null",
            "test_timestamp_compare_with_early_datetime",
            "test_unary_in_array",
            "test_from_arrays_index_series_timedelta",
            "test_slice_float",
            "write_legacy_pickles",
            "validate",
            "test_take_na_empty",
            "write",
            "test_frame_align_aware",
            "test_mi_data_columns",
            "test_empty_str_methods_to_frame",
            "test_combined_up_downsampling_of_irregular",
            "test_join_utc_convert",
            "visit",
            "test_repr_mixed_big",
            "test_generate_cday",
            "test_get_loc_nan",
            "block",
            "test_int_types",
            "_parsed_string_to_bounds",
            "test_local_variable_with_in",
            "test_delitem_corner",
            "test_union_with_DatetimeIndex",
            "to_stata",
            "test_getitem_category_type",
            "test_clip_with_na_args",
            "test_concat_series_name_npscalar_tuple",
            "is_old_version",
            "test_to_datetime_YYYYMMDD",
            "test_groupby_multi_timezone",
            "test_mangle_dupe_cols_false",
            "test_subplots_ts_share_axes",
            "test_pct_change_shift_over_nas",
            "test_numeric_column_names",
            "df_duplicates",
            "test_normalize_tz_local",
            "makeDateIndex",
            "_interpolate_scipy_wrapper",
            "str_replace",
            "test_date_parser_resolution_if_not_ns",
            "_maybe_utc_convert",
            "test_join_hierarchical_mixed",
            "test_numpy_err_state_is_default",
            "test_categorical_dtype_chunksize_explicit_categories",
            "check",
            "test_inf_parsing",
            "_str_extract_noexpand",
            "test_inconsistent_return_type",
            "test_iloc_row",
            "test_minmax_tz",
            "test_indexing_with_datetimeindex_tz",
            "time_groupby_sum_booleans",
            "test_arith_series_with_array",
            "_sparse_array_op",
            "test_numpy_ufuncs_basic",
            "test_update",
            "test_join_left_sequence_non_unique_index",
            "test_max_len_string_array",
            "_missing_double",
            "test_set_levels_with_iterable",
            "get_datevalue",
            "test_interp_combo",
            "__eq__",
            "to_excel",
            "test_apply_frame_yield_constant",
            "check_nancorr_nancov_1d",
            "test_sub_datetime_compat",
            "test_dti_tz_localize_utc_conversion",
            "_assert_can_do_setop",
            "get_dtype_counts",
            "test_cummethods_bool",
            "test_get_get_value",
            "test_mixed_array_float_int",
            "_make_index",
            "time_transform_mean",
            "test_matplotlib_backend_error",
            "test_groupby_keys_same_size_as_index",
            "test_order",
            "test_categorical_nan_handling",
            "test_constructor_float32",
            "test_skiprows_ndarray",
            "set_engine_and_path",
            "test_datetimelike_frame",
            "test_timedelta_assignment",
            "test_reindex_empty_index",
            "_unpickle_matrix_compat",
            "test_rank_naoption_raises",
            "pandasSQL_builder",
            "test_constructor_error",
            "show_versions",
            "dataframe",
            "test_concat_aligned_sort",
            "_get_cython_function",
            "time_ceil",
            "_wrap_results",
            "test_tdi_iadd_int",
            "test_construction_base_constructor",
            "test_cat_accessor_api",
            "test_truncate_out_of_bounds",
            "_process_columnname_subheader",
            "test_pivot_table_margins_name_with_aggfunc_list",
            "test_rolling_min_resample",
            "_get_partial_string_timestamp_match_key",
            "test_constructor_from_categorical_with_unknown_dtype",
            "is_function_or_method",
            "from_items",
            "test_to_latex_float_format_no_fixed_width",
            "test_excel_passes_na",
            "test_readjson_chunks",
            "empty_returns",
            "test_astype_categories_deprecation_raises",
            "test_gb_apply_list_of_unequal_len_arrays",
            "replace",
            "test_to_csv_escapechar",
            "test_dataframe_categorical_with_nan",
            "_validate_names",
            "_getitem_axis",
            "reorder_arrays",
            "test_drop_level_nonunique_datetime",
            "test_categorial_assigning_ops",
            "test_bad_class",
            "check_result_type",
            "test_xs_duplicates",
            "union_categoricals",
            "test_categorical_index_repr_timedelta_ordered",
            "_evaluate_numexpr",
            "test_merge_different_column_key_names",
            "test_y_listlike",
            "get_expects",
            "to_manager",
            "test_union_freq_both_none",
            "map",
            "test_from_dict",
            "test_pindex_slice_index",
            "test_combine_first_mixed_bug",
            "test_with_duplicates_no_on",
            "test_to_timestamp_tz_arg",
            "df_ref",
            "read_sas",
            "test_groupby_preserves_sort",
            "time_datetime_field_day",
            "test_interp_scipy_basic",
            "test_df_series_secondary_legend",
            "test_frame_loc_callable_mixture",
            "stack",
            "test_raises_on_non_datetimelike_index",
            "_validate_dt64_dtype",
            "_encode_complex",
            "test_index_names_multiple_nones",
            "safe_sort",
            "_is_label_or_level_reference",
            "test_built_in_round",
            "test_constructor_arrays_and_scalars",
            "_maybe_coerce_indexer",
            "test_set_column_names_in_parameter",
            "test_get_indexer_same_categories_different_order",
            "test_reduce",
            "_parse_no_numpy",
            "test_regex_replace_list_mixed_inplace",
            "test_bar_bad_align_raises",
            "clip_upper",
            "test_as_array_datetime",
            "test__has_infs",
            "test_constructor_no_coercion",
            "test_replace_pure_bool_with_string_no_op",
            "_comp_method_FRAME",
            "test_interpolate_time_raises_for_non_timeseries",
            "test_emptylike_constructor",
            "test_stata_doc_examples",
            "test_constructor_list_of_namedtuples",
            "test_extract_expand_True",
            "test_convert_numeric_uint64_nan_values",
            "test_indexing_with_datetime_tz",
            "test_get_nan_multiple",
            "take_nd",
            "test_apply_to_empty_series",
            "_noarg_wrapper",
            "test_select_dtypes_exclude_include_using_list_like",
            "raw_frame",
            "test_to_period_microsecond",
            "test_reindex_categorical",
            "test_to_csv_sparse_dataframe",
            "test_timedelta64_ops_nat",
            "test_corr_cov_independent_index_column",
            "nontemporal_method",
            "run",
            "test_to_datetime_now",
            "test_loc_multiindex_labels",
            "test_unstack_fill_frame",
            "test_at_with_tz",
            "test_writer_117",
            "_get_suffix_prefix",
            "check_floor_division",
            "test_NaT_cast",
            "test_frame_getitem_setitem_multislice",
            "test_replace_dict_tuple_list_ordering_remains_the_same",
            "test_month_range_union_tz_pytz",
            "test_is_timedelta64_ns_dtype",
            "test_append_empty_dataframe",
            "test_read_write_dta13",
            "test_pivot_table_values_key_error",
            "check_fun_data",
            "_get_closing_time",
            "_ensure_localized",
            "test_partial_slice_doesnt_require_monotonicity",
            "test_reset_index_right_dtype",
            "test_all_invalid_plot_data",
            "test_from_index",
            "safe_import",
            "test_format_explicit",
            "test_set_dtype_nans",
            "fill_zeros",
            "make_nancomp",
            "test_equals_categoridcal_unordered",
            "test_to_html_with_id",
            "test_merge_on_int_array",
            "test_concat_NaT_dataframes_all_NaT_axis_1",
            "_convert_to_style_kwargs",
            "test_var_std",
            "test_difference_name_preservation",
            "test_expanding_cov_pairwise",
            "test_missing_required_dependency",
            "test_excel_cell_error_na",
            "indices",
            "test_very_wide_info_repr",
            "test_union_categoricals_nan",
            "test_repr_chop_threshold",
            "test_loc_getitem_frame",
            "test_categorical_categories",
            "test_hist",
            "test_to_csv_gcs",
            "_zero_out_fperr",
            "test_conv_daily",
            "test_unstack_non_unique_index_names",
            "test_get_indexer_categorical_time",
            "test_pi_sub_intarray",
            "test_subclass_unstack",
            "test_allow_exact_matches_and_tolerance_nearest",
            "test_asfreq_combined",
            "test_order_compat",
            "test_series_partial_set_with_name",
            "test_min_max",
            "test_to_sql",
            "test_cat_accessor_no_new_attributes",
            "indent",
            "test_to_string_buffer_all_unicode",
            "test_sum_inf",
            "test_dataframe_dummies_with_na",
            "test_constructor_year_and_quarter",
            "init_no_clipboard",
            "test_thousands_macau_stats",
            "_period_array_cmp",
            "test_to_dict_numeric_names",
            "test_dti_shift_tzaware",
            "test_name_error_exprs",
            "test_get_indexer_nearest_error",
            "test_operators_datetimelike_with_timezones",
            "test_nested_exception",
            "test_constructor_dict_of_iterators",
            "test_cython_transform_series",
            "_hash_categories",
            "jsonl_file",
            "max_level_test_input_data",
            "test_dropna_corner",
            "test_where_datetime_conversion",
            "test_setitem_different_unordered_raises",
            "test_na_levels",
            "test_boundary_float",
            "test_precision_finer_than_offset",
            "test_index_equal_values_mismatch",
            "time_split",
            "test_to_html_round_column_headers",
            "_is_na_fill_value",
            "append_to_multiple",
            "test_dti_tz_localize_errors_deprecation",
            "test_construction_list_tuples_nan",
            "test_temporary_table",
            "test_basic_drop_first",
            "test_set_index_custom_label_hashable_iterable",
            "test_getitem_setitem_datetime_tz_dateutil",
            "test_axis_limits",
            "to_frame",
            "test_reindex_lvl_preserves_type_if_target_is_empty_list_or_array",
            "test_multiindex_slicers_datetimelike",
            "test_setitem_with_unaligned_tz_aware_datetime_column",
            "test_usecols_str",
            "_reindex_index",
            "test_pi_ops_nat",
            "test_dataframe_categorical_ordered_observed_sort",
            "test_setitem_series_datetime64",
            "test_join_inner",
            "test_sort_index_inplace",
            "_get_merge_keys",
            "test_equals_op_multiindex_identify",
            "test_resample_consistency",
            "test_loc_getitem_dups",
            "test_to_csv_from_csv_w_some_infs",
            "test_getitem_day",
            "test_max_nan_bug",
            "get_sys_info",
            "test_create_categorical",
            "maybe_dispatch_ufunc_to_dunder_op",
            "__getattr__",
            "test_rolling_consistency",
            "test_stringify_path_pathlib",
            "test_take_bad_bounds_raises",
            "test_get_level_values_int_with_na",
            "test_constructor_tuples_datetimes",
            "test_dt64arr_iadd_timedeltalike_scalar",
            "test_crosstab_margins",
            "test_mod_timedelta64_nat",
            "test_combineFunc",
            "test_read_chunksize_with_index",
            "test_to_timestamp_pi_nat",
            "test_preserve_on_ordered_ops",
            "test_readonly_axis_blosc",
            "test_odict",
            "test_date_range_normalize",
            "test_merge_left_notempty_right_empty",
            "test_setitem_always_copy",
            "test_repr_html_float",
            "data_missing_for_sorting",
            "_create_method",
            "get_attrs",
            "test_concat_series",
            "test_non_space_filler",
            "_range_from_fields",
            "test_append_series",
            "test_dti_shift_freqs",
            "test_read_with_parse_dates_invalid_type",
            "test_area_colors",
            "_raw_hex_id",
            "float_frame_int_kind",
            "test_comment_default",
            "test_constructor_dict_order_by_values",
            "test_update_datetime_tz",
            "test_values_duplicates",
            "test_get_indexer_invalid",
            "test_aggregate_str_func",
            "from_arrays",
            "test_ngroup_mi",
            "test_map_fallthrough",
            "test_where_bug_mixed",
            "test_complex_table",
            "is_iterator",
            "test_sort_index_different_sortorder",
            "test_asfreq_near_zero_weekly",
            "test_merge_datatype_error_raises",
            "test_check_label_or_level_ambiguity_series_axis1_error",
            "test_unstack_preserve_types",
            "has_table",
            "test_union_sort_other_empty_sort",
            "test_series_set_tz_timestamp",
            "test_shift_months",
            "set_labels",
            "test_clip_mixed_numeric",
            "test_apply_no_name_column_conflict",
            "_get_numeric_engines",
            "test_empty_groups_corner",
            "_get_multiindex_indexer",
            "test_highlight_max",
            "test_constructor_scalar",
            "test_labels_out_of_bound",
            "test_dropna_tz_aware_datetime",
            "test_df_bool_mul_int",
            "test_pie_df",
            "test_frame_tz_localize",
            "test_non_callable_aggregates",
            "test_with_na_groups",
            "test_pivot_multi_values",
            "test_Minute",
            "_maybe_convert_to_int_keys",
            "get_loc_level",
            "test_take_filling_all_nan",
            "_maybe_convert_i8",
            "test_basic_types",
            "test_ndarray",
            "test_hashtable_large_sizehint",
            "is_valid_dtype_n_method",
            "test_set_index_preserve_categorical_dtype",
            "_convert_and_box_cache",
            "lag_plot",
            "test_annually_infer",
            "test_set_categories",
            "test_sort_index_level",
            "test_series_comparison_scalars",
            "test_iloc_array_not_mutating_negative_indices",
            "test_groupby_with_timezone_selection",
            "test_skip_bad_lines",
            "simple_period_range_series",
            "test_constructor_mrecarray",
            "test_order_with_freq",
            "test_dataframe_metadata",
            "test_invalid_delegation",
            "interpolate_2d",
            "_check_ne_builtin_clash",
            "_take_without_fill",
            "test_scatter_matrix_axis",
            "skip_if_np_lt",
            "test_loc_getitem_duplicates_multiindex_empty_indexer",
            "test_parsers_iso8601_leading_space",
            "test_allow_exact_matches_and_tolerance_forward",
            "test_where_unobserved_categories",
            "test_dti_timestamp_fields",
            "test_skip_sum_object_raises",
            "_cython_transform",
            "__iter__",
            "test_reopen_handle",
            "test_describe_datetime_columns",
            "test_frame_setitem_timestamp",
            "test_warn_bad_lines",
            "test_logical_compat",
            "test_categorical_index",
            "test_difference_sort",
            "test_loc_index",
            "run_frame",
            "test_date_parse_failure",
            "test_dti_sub_int",
            "test_hash_vs_equality",
            "test_hist_kwargs",
            "_make_stat_function_ddof",
            "test_datetime64_tz_fillna",
            "test_partition_index",
            "test_set_value_by_index",
            "time_read_store_table",
            "assert_sp_series_equal",
            "test_regex_replace_series_of_regexes",
            "month_roll",
            "test_iloc_getitem_multiple_items",
            "test_tseries_indices_frame",
            "test_value_counts_categorical_not_ordered",
            "select_as_multiple",
            "test_setitem_ambig",
            "test_replace_compiled_regex",
            "test_type_promotion",
            "test_skiprows_by_index_inference",
            "test_nonoverlapping_monotonic",
            "test_to_latex_longtable",
            "test_meta_parameter_not_modified",
            "test_maybe_indices_to_slice_left_edge",
            "test_infer_index_col",
            "test_update_dtype",
            "test_mul_td64arr",
            "test_td64arr_div_numeric_array",
            "test_loc_listlike",
            "test_to_latex_multiindex_names",
            "test_downsample_across_dst_weekly",
            "test_ts_area_lim",
            "test_basic_categorical",
            "test_fwf_comment",
            "test_merge_inner_join_empty",
            "test_setitem_dtype_upcast",
            "to_sql",
            "test_custom_comment_char",
            "test_apply_numeric_coercion_when_datetime",
            "test_from_spmatrix",
            "delegate_names",
            "test_set_none_nan",
            "time_match",
            "test_period_index_length",
            "test_to_datetime_format_YYYYMMDD_overflow",
            "test_gap_upsample",
            "test_bool_operators_with_nas",
            "_aggregate_series_fast",
            "test_moment_functions_zero_length_pairwise",
            "_binop",
            "test_iteration_preserves_nanoseconds",
            "test_partial_setting",
            "test_round_trip_current",
            "test_try_aggregate_non_existing_column",
            "test_compress_group_combinations",
            "test_to_json_period_index",
            "time_endswith",
            "truncate",
            "test_first_last_max_min_on_time_data",
            "test_intelligently_handle_join_key",
            "test_nunique_with_object",
            "test_invalid_origins",
            "test_scikit_learn",
            "test_convert_numeric_uint64_nan",
            "test_query_with_nested_special_character",
            "test_resample_basic",
            "test_isin_level_kwarg",
            "test_generate",
            "test_append_concat_tz_dateutil",
            "test_ewma_nan_handling",
            "buffer_put_lines",
            "test_handle_overlap_arbitrary_key",
            "test_quarterly_infer",
            "_is_boolean",
            "test_reindex_multi_categorical_time",
            "test_setitem_with_unaligned_sparse_value",
            "test_subclass_align_combinations",
            "_is_level_reference",
            "test_slice_duplicate_monotonic",
            "test_intersect",
            "take",
            "test_df_use_case",
            "test_dti_cmp_tdi_tzawareness",
            "test_crosstab_with_empties",
            "test_make_block_boundary",
            "test_where_subset_compare_with_applymap",
            "testFixRaw",
            "test_complex_mixed_table",
            "_format_labels",
            "test_fillna_categorical_raise",
            "time_string_get_loc",
            "test_pivot_table_nocols",
            "_nanpercentile_1d",
            "test_get_indexer",
            "test_blocks_compat_GH9037",
            "test_to_datetime_tz_psycopg2",
            "test_bad_arg_length_max_value_single",
            "test_dtype_on_categorical_dates",
            "test_to_html_filename",
            "test_ix_multi_take_nonint_index",
            "test_hist_df_coord",
            "parameter_mismatches",
            "test_roundtrip",
            "float_frame_fill2",
            "test_difference_type",
            "to_hierarchical",
            "test_agg_lambda_with_timezone",
            "test_cat_accessor_updates_on_inplace",
            "assert_onOffset",
            "test_query_with_unnamed_multiindex",
            "test_alias_to_unit_raises",
            "test_margin_dropna",
            "test_td64arr_div_tdlike_scalar",
            "test_int_array",
            "test_reindex_method",
            "test_write_variable_label_errors",
            "test_concat_empty_series_dtypes",
            "test_set_levels_codes_names_bad_input",
            "test_construction_from_string_errors",
            "test_categorical_nan_only_columns",
            "result",
            "test_astype_from_categorical",
            "f",
            "test_set_attribute",
            "test_resample_incompat_freq",
            "test_constructor_series",
            "test_describe",
            "_make_sorted_values_labels",
            "_take_new_index",
            "test_loc_setitem_frame",
            "test_format_integer_names",
            "test_to_coo_bad_partition_small_union",
            "test_multiindex_unique",
            "_gotitem",
            "test_size_groupby_all_null",
            "test_fwf_for_uint8",
            "interval_range",
            "test_td_from_repr_roundtrip",
            "test_to_dict_invalid_orient",
            "test_list_mixed",
            "test_read_json_table_orient_raises",
            "indexer_at_time",
            "test_misc_coverage",
            "_get_colors",
            "test_summary_deprecated",
            "test_Hour",
            "test_loc_iterable",
            "test_transpose_tzaware_2col_single_tz",
            "test_assign_dependent_old_python",
            "test_na_values",
            "test_handle_join_key_pass_array",
            "test_apply_broadcast",
            "test_crosstab_with_numpy_size",
            "test_utc_box_timestamp_and_localize",
            "test_constructor_with_dtype",
            "test_lookup_mixed",
            "unpack",
            "test_where_object",
            "isAnchored",
            "test_with_local_timezone_dateutil",
            "test_metadata_propagation_indiv",
            "test_verify_integrity_deprecated",
            "test_tz_setter_raises",
            "assert_stat_op_api",
            "test_ellipsis",
            "test_bool_array",
            "test_merge_nosort",
            "test_day_not_in_month_ignore",
            "test_datetime64formatter_hoursecond",
            "test_series_constructor_with_dtype",
            "_allow_na_ops",
            "test_quarterly_negative_ordinals",
            "test_assert_almost_equal_dict_like_object",
            "test_parr_cmp_pi_mismatched_freq_raises",
            "test_fillna_inplace",
            "index_subclass_makers_generator",
            "test_transform_select_columns",
            "_check_percentile",
            "test_div_zero",
            "test_concat_bug_2972",
            "test_value_counts_preserves_tz",
            "test_resample_bms_2752",
            "test_repr_corner",
            "test_iloc_getitem_list_int",
            "_process_parse_dates_argument",
            "test_construct_with_different_start_end_string_format",
            "visit_Compare",
            "test_conflicting_excel_engines",
            "missing_metadata",
            "highlight_max",
            "_check_comments",
            "test_assert_almost_equal_value_mismatch3",
            "test_append_sorts",
            "test_constructor_period",
            "_na_for_min_count",
            "test_combine_first_dt_tz_values",
            "time_frame_nth_any",
            "test_tolerance_tz",
            "getTimeSeriesData",
            "test_corr_sanity",
            "test_frame",
            "in_ipython_frontend",
            "test_numpy_squeeze",
            "test_skip_initial_space",
            "test_resample_nonexistent_time_bin_edge",
            "test_getitem_setitem_periodindex",
            "test_info_memory",
            "test_getitem_setitem_ix_bool_keyerror",
            "test_maybe_promote_any_with_timedelta64",
            "axisinfo",
            "_convert_datetime_to_stata_type",
            "format_object_attrs",
            "test_rank_modify_inplace",
            "test_index_equal_level_values_mismatch",
            "test_merge_na_keys",
            "test_extension_array_cross_section_converts",
            "_from_name",
            "test_where_array_like",
            "test_corr_non_numeric",
            "test_constructor_manager_resize",
            "test_frame_datetime64_handling_groupby",
            "test_merge_join_categorical_multiindex",
            "test_scalar_ops_from_sequence_raises",
            "test_to_csv_multi_index",
            "test_index_false_to_json_table",
            "test_getitem_index",
            "test_get_bool_data",
            "test_from_tzaware_object_array",
            "test_timestamp_repr_pre1900",
            "test_index_false_error_to_json",
            "test_usecols_with_whitespace",
            "test_to_period_tz_warning",
            "test_dataframe_dummies_preserve_categorical_dtype",
            "test_loc_getitem_lowerdim_corner",
            "test_backfill",
            "api_doc",
            "testUnsignedInt",
            "_process_page_meta",
            "time_partition",
            "set_testing_mode",
            "__reduce__",
            "test_bar_log_no_subplots",
            "test_shift_categorical",
            "test_sparse_int",
            "test_interp_datetime64",
            "test_unstack_unused_levels",
            "test_barely_out_of_bounds",
            "test_bar_align_mid_vmax",
            "test_multiple_date_col_named_index_compat",
            "_add_legend_handle",
            "test_frame_on2",
            "test_frame_negate",
            "test_left_join_multi_index",
            "test_groupby_wrong_multi_labels",
            "check_bool_indexer",
            "test_tdi_add_int",
            "test_header_multi_index_common_format1",
            "test_groupby_extension_apply",
            "test_group_var_generic_2d_some_nan",
            "test_3d_fill_nonna",
            "combine_first",
            "unstack",
            "validate_col",
            "asi8",
            "test_query_compare_column_type",
            "test_write_append_mode_raises",
            "test_dti_add_intarray_no_freq",
            "test_float_max",
            "test_pivot_margins_name_unicode",
            "test_2000",
            "test_custom_na_values",
            "_get_standard_colors",
            "test_empty_with_multi_index_pass_dtype",
            "test_frame_getitem_not_sorted2",
            "test_allow_exact_matches_and_tolerance",
            "test_apply_bad_labels",
            "_union_indexes",
            "difference",
            "test_set_value",
            "test_large_multiindex_error",
            "test_non_unique_idvars",
            "test_query_doesnt_pickup_local",
            "_to_sql_empty",
            "_str_extract_frame",
            "test_td64arr_add_datetime64_nat",
            "test_integer_array_constructor",
            "test_to_records_dt64",
            "_format_data",
            "test_to_excel_multiindex_dates",
            "iris",
            "test_concatlike_dtypes_coercion",
            "test_partial_set_empty_frame_empty_consistencies",
            "test_to_json_float_index",
            "test_apply_scaler_on_date_time_index_aware_series",
            "test_set_index_period",
            "test_closed_left_corner",
            "test_error_with_zero_monthends",
            "nanall",
            "test_nanstd",
            "_reduce",
            "test_date_range_timezone_str_argument",
            "create_description",
            "test_setitem_same_but_unordered",
            "test_millisecond_repr",
            "test_loc_getitem_across_dst",
            "_validate_frequency",
            "test_constructor_invariant",
            "test_intersection_zero_length",
            "drop_table",
            "test_forward_by",
            "test_consistency_with_tz_aware_scalar",
            "test_arith_series_with_scalar",
            "test_fy5253qtr_onoffset_nearest",
            "_list_to_arrays",
            "test_diff_mixed_dtype",
            "test_partial_set_empty_frame_empty_copy_assignment",
            "test_basic",
            "test_series_bin_grouper",
            "test_info_memory_usage",
            "time_quantile",
            "time_floor",
            "test_compression_warns_when_decompress_caches_zlib",
            "test_dti_tz_convert_utc_to_local_no_modify",
            "test_rolling_max_resample",
            "test_query_None",
            "test_compare_zerodim",
            "test_parr_cmp_pi",
            "test_bar_align_mid_all_neg",
            "test_set_index_datetime",
            "test_cythonized_aggers",
            "test_get_level_number_integer",
            "test_constructor_mismatched_codes_levels",
            "test_numeric_op_scalar",
            "_check_roundtrip_table",
            "df_cross_compat",
            "register_extension_dtype",
            "pivot_table",
            "test_get_indexer_backfill",
            "validate_tz_from_dtype",
            "test_detect_console_encoding_fallback_to_default",
            "build_string",
            "test_no_color_bar",
            "test_shift2",
            "test_select_dtypes_datetime_with_tz",
            "test_td_sub_nat",
            "test_fillna_frame",
            "test_compression",
            "test_bad_deprecate_kwarg",
            "test_isin_nan_not_pypy",
            "test_unstack_to_series",
            "test_scalar_conversion",
            "test_cython_group_transform_algos",
            "test_set_name_methods",
            "test_date_format_raises",
            "test_interp_nan_idx",
            "test_sequence_like_with_categorical",
            "test_mpl2_color_cycle_str",
            "process_axes",
            "to_timestamp",
            "test_dti_add_int",
            "test_float_truncation",
            "test_ts_plot_with_tz",
            "test_filter_and_transform_with_non_unique_float_index",
            "test_concatlike_common_period_mixed_dt_to_object",
            "test_to_sql_append",
            "read_sparse_intindex",
            "test_concat_keys_with_none",
            "test_array_multiindex_raises",
            "test_boolean_context_compat",
            "test_setitem_multiple_partial",
            "test_concat_different_fill_value",
            "test_get_schema_create_table",
            "__floordiv__",
            "test_keyword_arg",
            "_get_period_range_edges",
            "test_td64arr_mod_tdscalar",
            "test_concat_copy",
            "test_rsplit",
            "test_string_index_repr_with_unicode_option",
            "test_datetime_indexing",
            "test_date_query_with_attribute_access",
            "test_truncate_copy",
            "test_concat_NaT_dataframes_all_NaT_axis_0",
            "test_frame_tz_convert",
            "test_pad_nan",
            "test_repr_bool_fails",
            "test_select_dtypes_exclude_using_scalars",
            "test_simple_cmp_ops",
            "test_axis_alias",
            "test_datetimeindex_sub_timestamp_overflow",
            "test_frame_dict_constructor_datetime64_1680",
            "test_to_datetime_parse_timezone_malformed",
            "test_constructor_orient",
            "test_pi_comp_period",
            "test_grouper_index_types",
            "test_empty_timeseries_reductions_return_nat",
            "test_values_multiindex_datetimeindex",
            "test_bar_align_mid_nans",
            "_is_numeric",
            "test_fails_ampersand",
            "test_index_convert_to_datetime_array",
            "test_excel_raise_error_on_multiindex_columns_and_no_index",
            "test_getitem_bool_index_all",
            "test_constructor_overflow_int64",
            "test_multiindex_get_loc",
            "_getitem_lowerdim",
            "pack",
            "test_apply_args",
            "has_invalid_return_type",
            "numeric_as_float",
            "assert_datetime_array_equal",
            "test_components",
            "_repr_fits_horizontal_",
            "test_resample_dtype_coerceion",
            "test_apply_standard_nonunique",
            "test_get_dummies_duplicate_columns",
            "test_dti_with_timedelta64_data_deprecation",
            "test_nonzero",
            "test_infer_datetimelike_array_nan_nat_like",
            "test_subplots_multiple_axes",
            "test_pairs",
            "_sanitize_and_check",
            "test_iloc_getitem_slice",
            "test_styler_to_excel",
            "is_datetime_arraylike",
            "test_df_mod_zero_int",
            "test_extract_single_group_returns_frame",
            "test_operators_empty_int_corner",
            "test_select_dtypes_include_using_list_like",
            "test_bad_generic_functions",
            "visit_BoolOp",
            "test_unique_id",
            "test_partial_set_invalid",
            "assert_label_values",
            "test_css_relative_font_size",
            "test_ffill",
            "test_comparison_with_unknown_scalars",
            "test_date_and_index",
            "test_iter_box",
            "ceil",
            "test_parse_dates_column_list",
            "_try_import",
            "test_float64_unit_conversion",
            "nansem",
            "test_dt64arr_add_timedeltalike_scalar",
            "_get_indices",
            "test_custom_value_name",
            "test_grouper_creation_bug",
            "test_rolling_std",
            "test_concat_bug_1719",
            "_assert_where_conversion",
            "test_comment_empty_line",
            "read_html",
            "test_eq",
            "test_asfreq_fill_value",
            "test_encode_string_conversion",
            "test_pi_add_iadd_int",
            "test_stack_mixed_levels",
            "test_infer_dtype_datetime",
            "test_interp_bad_method",
            "test_dti_tz_convert_dst",
            "test_plot_scatter",
            "test_properties_minutely",
            "time_join_dataframe_index_multi",
            "test_ordered_api",
            "test_to_timedelta_box_deprecated",
            "test_andrews_curves",
            "queryables",
            "test_from_codes_with_dtype_raises",
            "test_findall",
            "test_cdaterange",
            "test_unary_functions",
            "test_drop_duplicates_categorical_non_bool",
            "test_join_segfault",
            "tests_indexing_with_sparse",
            "_clip_with_one_bound",
            "test_partial_slice_hourly",
            "_write_header",
            "test_nested_flattens",
            "test_merge_series",
            "test_equals_op_index_vs_mi_same_length",
            "getMixedTypeDict",
            "test_corr_invalid_method",
            "test_repr_is_valid_construction_code",
            "_read_bytes",
            "test_reconstruction_index",
            "_check_inplace_setting",
            "_sub_period_array",
            "test_dti_add_sub_nonzero_mth_offset",
            "test_iteration_preserves_tz",
            "_set_subtyp",
            "test_lower_upper",
            "test_identical_stubnames",
            "test_where_bug",
            "test_astype_bool",
            "_get_ax_layer",
            "test_unit",
            "versions_from_parentdir",
            "test_isnull_for_inf_deprecated",
            "test_count_non_nulls",
            "frame_with_period_index",
            "df_cat",
            "test_map_dictlike",
            "test_describe_empty_categorical_column",
            "time_frame_date_formatting",
            "_bins_to_cuts",
            "test_loc_slicing",
            "test_Microsecond",
            "test_resample_string_kwargs",
            "test_range_closed_with_tz_aware_start_end",
            "test_grouped_box_layout",
            "test_to_int_index",
            "test_groupby_apply_none_first",
            "test_setitem_empty",
            "match",
            "test_dialect_conflict_except_delimiter",
            "check_result",
            "test_pass_dtype",
            "_wrap_transformed_output",
            "test_frame_timeseries_to_records",
            "test_cumsum_corner",
            "ohlc",
            "test_intersect_equal_sort",
            "test_as_json_table_type_categorical_dtypes",
            "_sphinx_build",
            "test_boolean_selection",
            "test_group_var_constant",
            "test_first_last_tz",
            "_maybe_localize_point",
            "test_comment_arg",
            "assert_copy",
            "is_platform_little_endian",
            "dups",
            "time_add_timedeltas",
            "test_repr_unicode",
            "test_rolling_max_gh6297",
            "test_get_values_deprecated",
            "test_mixed_arithmetic",
            "test_usecols_with_names",
            "test_count_object",
            "test_dti_sub_tdi",
            "_setop",
            "test_gz_lineend",
            "test_microsecond_repr",
            "time_different_str_functions",
            "test_to_pydatetime_nonzero_nano",
            "test_numpy_array_equal_unicode",
            "_where",
            "test_tdi_mul_int_array_zerodim",
            "test_resample_to_period_monthly_buglet",
            "test_include_na",
            "test_value_counts_period",
            "test_describe_bool_frame",
            "test_dti_tz_localize_pass_dates_to_utc",
            "test_bar_barwidth_position_int",
            "left_multi",
            "latex",
            "test_rename_signature",
            "test_usage_via_getsizeof",
            "test_get_indexer_with_interval",
            "test_td_mul_nat",
            "test_multi_index_unnamed",
            "wrap_arithmetic_op",
            "test_dti_tdi_numeric_ops",
            "test_bins_from_interval_index",
            "_add_deprecation_prefixes",
            "test_categorical_series_repr_datetime_ordered",
            "test_convert_objects_leave_decimal_alone",
            "test_an_exception_in_objecthook2",
            "ne_lt_2_6_9",
            "time_join_dataframe_index_single_key_small",
            "test_date_range_negative_freq",
            "test_bin8",
            "test_select_with_many_inputs",
            "_construct_dataframe",
            "test_copy_and_deepcopy",
            "test_groupby_multiindex_tuple",
            "build_components",
            "test_simple",
            "test_union_coverage",
            "test_from_items_deprecation",
            "test_reset_index_drop_errors",
            "test_isna_extension_array",
            "test_to_datetime_parse_tzname_or_tzoffset",
            "test_td64arr_sub_period",
            "test_from_datetime64_freq_changes",
            "test_group_var_generic_2d_all_finite",
            "test_apply_describe_bug",
            "test_astype_mixed_float",
            "test_cached_range_bug",
            "test_update_ctx_flatten_multi_traliing_semi",
            "build_table_schema",
            "test_repr_no_warning",
            "test_parsers_iso8601_invalid_offset_invalid",
            "test_tdi_mul_float_series",
            "_get_default_locs",
            "test_irreg_hf",
            "_make_comparison_op",
            "test_dataframe_constructor",
            "to_perioddelta",
            "time_normalize",
            "test_dti_construction_univalent",
            "test_create_index_existing_name",
            "test_rolling_functions_window_non_shrinkage_binary",
            "test_mgr_locs",
            "cut",
            "test_replace_swapping_bug",
            "test_data_frame_size_after_to_json",
            "time_join",
            "test_slice_float64",
            "set_value",
            "test_parr_cmp_period_scalar2",
            "test_apply_mixed_dtype_corner",
            "test_to_csv_headers",
            "test_multiindex_negative_level",
            "test_clip_against_list_like",
            "idx_cols_multi",
            "test_scalar_na_logical_ops_corners",
            "test_to_datetime_utc_true",
            "test_na_trailing_columns",
            "time_query_datetime_column",
            "_is_sub",
            "test_maybe_convert_timedelta",
            "_load_obj",
            "need_slice",
            "test_invalid_compression",
            "test_astype_period",
            "safe_cast",
            "_has_bool_dtype",
            "test_constructor_bool",
            "test_multi_nan_indexing",
            "test_loc_setitem_with_existing_dst",
            "test_mode",
            "test_column_format",
            "test_merge_non_unique_index_many_to_many",
            "test_categorical_repr_period",
            "_check_op",
            "test_header_and_index_no_types",
            "test_rename_nocopy",
            "_to_sql_method_callable",
            "test_setitem_with_tz",
            "test_format_percentiles",
            "test_select_dtypes_duplicate_columns",
            "test_strftime",
            "test_int64_overflow_issues",
            "test_single_char_leading_whitespace",
            "single_level_multiindex",
            "test_integer_array_plot",
            "_adjust_to_origin",
            "test_tsplot",
            "time_and",
            "test_overlaps_invalid_type",
            "test_fillna_raises",
            "test_reset_index",
            "forbid_nonstring_types",
            "test_tab_complete_warning",
            "test_iloc_setitem_int_multiindex_series",
            "test_dt64arr_add_sub_parr",
            "test_write_cells_merge_styled",
            "test_quantile_nat",
            "test_read_columns",
            "test_errorbar_scatter",
            "_has_complex_date_col",
            "check_compound_invert_op",
            "test_autocorrelation_plot",
            "test_basics_nanos",
            "_make_logical_function",
            "_maybe_check_integrity",
            "test_option_context_scope",
            "returns",
            "test_filter_bytestring",
            "_transform_index",
            "test_line_area_stacked",
            "_validate_header_arg",
            "test_subclass_empty_repr",
            "test_set_index_cast_datetimeindex",
            "test_shift_dst",
            "test_period_dt64_round_trip",
            "is_numeric",
            "_pop_header_name",
            "downcast",
            "_transaction_test",
            "test_no_right",
            "test_insert_index_float64",
            "test_groupby_extension_no_sort",
            "test_time_field_bug",
            "test_period_astype_to_timestamp",
            "test_td64arr_sub_offset_array",
            "test_constructor_datetime64arr",
            "test_bool_array_logical",
            "test_append_empty_preserve_name",
            "test_format_percentiles_integer_idx",
            "test_timestamp_to_datetime",
            "test_append_to_multiple_dropna_false",
            "test_constructor_from_index_series_timedelta",
            "test_short_format_converters",
            "test_to_html_basic_alignment",
            "test_xs_view",
            "select_as_coordinates",
            "test_interval_index",
            "asof_locs",
            "test_info_duplicate_columns",
            "test_bools",
            "test_uint64_factorize",
            "test_period_compat",
            "test_rename",
            "test_compression_utf16_encoding",
            "multiindex_year_month_day_dataframe_random_data",
            "test_detect_chained_assignment",
            "test_where_callable",
            "get_reindexed_values",
            "test_path_localpath_hdfstore",
            "factorize",
            "test_rdiv_zero_compat",
            "transform",
            "test_categorical_index_repr_period",
            "_test_small_strings_no_warn",
            "test_constructor_dict_cast",
            "test_omit_nuisance",
            "test_replace_categorical",
            "_get_period_bins",
            "test_colaliases",
            "_set_encoding",
            "test_monthly_upsample",
            "_convert_cell",
            "test_sparse_series",
            "test_constructor_object_dtype",
            "test_to_native_types",
            "andrews_curves",
            "test_join_nonunique",
            "test_map_bug_1677",
            "test_categorical_repr_unicode",
            "test_dtype_all_columns",
            "test_groupby_multiindex_not_lexsorted",
            "test_isna_datetime",
            "test_stat_op_calc",
            "strftime",
            "test_tz_aware_scalar_comparison",
            "test_infer_from_tdi_mismatch",
            "test_align_multiindex",
            "test_usecols_diff_positional_str_columns_order",
            "test_custom_var_and_value_name",
            "test_datetimetz_dtype",
            "test_n",
            "test_evenly_divisible_with_no_extra_bins",
            "to_latex",
            "test_million_record_attribute_error",
            "time_rfind",
            "test_map_with_non_function_missing_values",
            "generate_range",
            "test_small_strings_no_warn_blosc",
            "test_pi_sub_intlike",
            "test_hide_columns_single_level",
            "test_td64arr_mul_tdlike_scalar_raises",
            "test_read_zipped_json",
            "_fast_union",
            "_add_logical_methods",
            "test_rolling_var",
            "test_comprehensive",
            "test_timestamp_to_datetime_dateutil",
            "test_dataframe_dummies_prefix_dict",
            "test_td64arr_add_sub_numeric_arr_invalid",
            "test_dti_add_intarray_tick",
            "time_float_int_str_lines",
            "test_td_rsub_nat",
            "read_array",
            "test_really_large_in_arr_consistent",
            "test_grouper_multilevel_freq",
            "test_converters_euro_decimal_format",
            "test_repr_max_rows",
            "test_sparse_reindex",
            "test_dt64arr_add_sub_float",
            "test_drop",
            "test_transform_numeric_ret",
            "test_grouped_box_multiple_axes",
            "test_decimal_rows",
            "update_info",
            "test_rank_first_pct",
            "test_errors",
            "boxplot",
            "test_try_coerce_arg",
            "test_constructor_maskedrecarray_dtype",
            "four_level_index_dataframe",
            "color_to_excel",
            "test_floating_tuples",
            "test_dti_time",
            "test_constructor_dtypes_datetime",
            "test_merge_indexes_and_columns_lefton_righton",
            "_disabled",
            "test_logical_typeerror_with_non_valid",
            "format_signature",
            "test_to_excel_unicode_filename",
            "test_map_with_string_constructor",
            "test_values",
            "test_array_basic",
            "test_to_datetime_unparseable_ignore",
            "is_datetimelike_v_numeric",
            "test_transform_length",
            "test_zero_length_input_index",
            "see_also",
            "test_truediv",
            "test_fillna_fill_other",
            "test_from_values_or_dtype_raises",
            "test_constructor_wrong_precision_raises",
            "test_to_html_multiindex_max_cols",
            "test_frame_datetime64_pre1900_repr",
            "test_margins_dtype",
            "test_iloc_non_integer_raises",
            "overlaps",
            "lstrip",
            "test_to_dict_timestamp",
            "test_to_csv_stdout_file",
            "test_time_musec",
            "test_setitem_frame_upcast",
            "_pad_bytes_new",
            "tips_file",
            "test_to_datetime_unit",
            "test_pass_function",
            "_get_frame_op_default_axis",
            "test_nan_str_index",
            "time_read_json_lines_concat",
            "_validate_format",
            "test_rolling_functions_window_non_shrinkage",
            "test_outer",
            "legend_title",
            "time_transform_multi_key2",
            "test_categorical_repr",
            "_get_grouper",
            "test_concatlike_same_dtypes",
            "time_series_nth_any",
            "test_regex_replace_scalar_inplace",
            "test_apply_frame_to_series",
            "test_single_backtick_variable_query",
            "pct_change",
            "test_to_csv_line_terminators",
            "test_constructor_sequence_like",
            "_replot_ax",
            "get_is_dtype_funcs",
            "test_seriesgroupby_observed_apply_dict",
            "test_business_end_year_alias",
            "test_get_nan",
            "_repr_latex_",
            "test_select_iterator_complete_8014",
            "_maybe_add_join_keys",
            "test_setitem_mulit_index",
            "test_dropna",
            "time_multi_int_count",
            "test_comparison_invalid",
            "test_sort_ascending_list",
            "test_dt64arr_sub_timedeltalike_scalar",
            "test_sparse_series_pad_backfill_limit",
            "test_tz_localize_errors_deprecation",
            "test_shift_across_dst",
            "test_take_mixed_type",
            "all_mixed",
            "main",
            "test_path_local_path",
            "test_cython_agg_return_dict",
            "_repr_data_resource_",
            "test_mixed_dtypes_remain_object_array",
            "_wrap_generic_output",
            "test_groupby_list_infer_array_like",
            "test_frame_empty_mixedtype",
            "test_multi_key_multiple_functions",
            "test_constructor_dict_nan_tuple_key",
            "test_to_coo_text_names_integer_row_levels_sort",
            "tests_skip_nuisance",
            "test_series_describe_multikey",
            "count",
            "test_squeeze",
            "_add_numeric_methods_binary",
            "test_is_scalar_builtin_scalars",
            "test_quote_char_basic",
            "test_tz_localize_convert_copy_inplace_mutate",
            "test_bar_center",
            "test_take_fill_value",
            "test_week_of_month_frequency",
            "test_between_time_raises",
            "test_array_like",
            "_create_data",
            "_prefix",
            "test_decode_null_character",
            "test_groupby_level_index_names",
            "test_concat_odered_dict",
            "test_no_index",
            "test_set_columns",
            "test_numeric_arr_mul_tdscalar",
            "setup_driver",
            "test_bar_nan",
            "test_sqlite_type_mapping",
            "test_numpy_minmax_datetime64",
            "test_scalar_float",
            "test_nanvar_ddof",
            "test_td64arr_rmul_numeric_array",
            "test_foobar",
            "generate_blob",
            "run_transaction",
            "test_gb_key_len_equal_axis_len",
            "test_array_timedelta_floordiv",
            "test_holidays",
            "test_to_timestamp_pi_mult",
            "test_idxminmax_with_inf",
            "test_setitem_boolean_column",
            "test_construction_interval",
            "test_apply",
            "nansum",
            "_get_concat_axis",
            "test_fails_pipe",
            "test_regression_whitelist_methods",
            "test_parse_trim_buffers",
            "_process_columnattributes_subheader",
            "test_union_dataframe_index",
            "test_logical_ops_empty_frame",
            "test_insert_nat",
            "test_fill_value_when_combine_const",
            "test_take_warns",
            "test_loc_getitem_label",
            "test_raise_on_passed_int_dtype_with_nas",
            "test_no_new_globals",
            "is_numeric_v_string_like",
            "test_length_zero",
            "test_str_to_bytes_raises",
            "test_usecols_with_parse_dates3",
            "test_insert_index_timedelta64",
            "_grouped_plot_by_column",
            "test_duplicated_with_misspelled_column_name",
            "test_integer_array_constructor_copy",
            "test_freq_setter_errors",
            "test_pct_change_periods_freq",
            "test_replace_input_formats_scalar",
            "_get_string_slice",
            "test_constructor_index_mismatch",
            "nlargest",
            "float_string_frame",
            "test_groupby_multiple_key",
            "data",
            "create_axes",
            "test_date_unit",
            "test_non_convertable_values",
            "test_concatlike_common_coerce_to_pandas_object",
            "nested_to_record",
            "time_frame_sort_values",
            "get_values",
            "_write",
            "test_retain_index_attributes2",
            "test_from_records_empty_with_nonempty_fields_gh3682",
            "test_convert_dti_to_series",
            "test_compare_unordered_different_order",
            "apply_broadcast",
            "test_to_datetime_utc_true_with_series_tzaware_string",
            "get_dtype_kinds",
            "test_slice_locs_na_raises",
            "test_with_large_max_level",
            "test_arrmap",
            "freq",
            "deep_nested",
            "time_to_datetime_format_DD_MM_YYYY",
            "test_as_blocks",
            "test_read_chunks_117",
            "test_from_json_to_json_table_dtypes",
            "_filter_special_cases",
            "test_factorized_sort_ordered",
            "check_arbitrary",
            "test_constructor_ordered_dict_conflicting_orders",
            "_reconstruct_object",
            "test_sort_index_level_mixed",
            "test_offset_timedelta64_arg",
            "_construct_axes_from_arguments",
            "test_is_datetime64tz_dtype",
            "test_boxplot_legacy3",
            "test_merge_type",
            "_addsub_int_array",
            "test_constructor_incompat_freq",
            "test_timestamp_and_label",
            "test_out_of_bounds_string",
            "test_iterable_object_and_category",
            "test_argument_types",
            "_format_native_types",
            "test_resample_timedelta_values",
            "test_series_compression_defaults_to_infer",
            "_add_datetime_arraylike",
            "get_commit_info",
            "test_empty_with_index_pass_dtype",
            "test_index_label_overlaps_location",
            "test_to_xarray_index_types",
            "_multi_take",
            "test_parr_add_iadd_parr_raises",
            "test_regex_replace_dict_nested",
            "test_merge_right_vs_left",
            "test_dti_slicing",
            "test_misc",
            "test_readonly_axis_zlib",
            "assert_sp_frame_equal",
            "_apply_to_column_groupbys",
            "constructor",
            "test_dt_accessor_invalid",
            "_postprocess_for_cut",
            "test_replace_convert",
            "_hashed_values",
            "test_loc_general",
            "test_bins_from_interval_index_doc_example",
            "test_reindex_name_remains",
            "__contains__",
            "test_constructor_timestamp",
            "test_group_var_generic_1d_flat_labels",
            "time_getitem_label_slice",
            "test_get_indexer_same_categories_same_order",
            "test_clipboard_copy_tabs_default",
            "_ftype",
            "test_describe_option",
            "formatting_values",
            "_side_expander",
            "test_reindex_objects",
            "test_dt64arr_add_timestamp_raises",
            "test_stack_names_and_numbers",
            "test_combine_first_timezone",
            "test_ragged_median",
            "test_mean_mixed_datetime_numeric",
            "test_to_coo_duplicate_index_entries",
            "test_getitem_slice_not_sorted",
            "test_usecols_index_col_conflict2",
            "test_deferred_with_groupby",
            "test_nat",
            "hash_array",
            "test_time_change_xlim",
            "is_nested_list_like",
            "test_setitem_frame_invalid_length",
            "test_period_array_readonly_object",
            "test_to_html_multi_indexes_index_false",
            "test_x_string_values_ticks",
            "test_set_index_raise_on_type",
            "time_different_python_functions_multicol",
            "time_apply_ref_by_name",
            "index_names",
            "test_unicode_column_name",
            "test_resample_rounding",
            "test_fillna_invalid_value",
            "test_contains_nat",
            "test_index_types",
            "dispatch_to_series",
            "time_read_store_mixed",
            "test_comparisons",
            "test_transform_fast",
            "orientation",
            "_factorize_array",
            "test_iloc_getitem_bool_diff_len",
            "test_from_records_nones",
            "test_overlapping_columns_error_message",
            "test_dict_numpy_float",
            "read_index_node",
            "test_boolean_compare_transpose_tzindex_with_dst",
            "test_tokenize_CR_with_quoting",
            "test_fontsize_set_correctly",
            "test_pivot_with_list_like_values_nans",
            "test_corr_int_and_boolean",
            "test_grouper_column_and_index",
            "test_td_sub_pytimedelta",
            "test_td_sub_td64_nat",
            "test_pickle_compat_0_14_1",
            "test_is_dict_like_duck_type",
            "time_translate",
            "add_special_arithmetic_methods",
            "test_ngroup_series_matches_frame",
            "test_variable_width_unicode",
            "test_cmov_window_corner",
            "rands_array",
            "test_tshift",
            "test_non_iso_strings_with_tz_offset",
            "test_resample_how",
            "test_boxplot_return_type_legacy",
            "test_is_level_reference_series_simple_axis0",
            "test_open_args",
            "test_unicode_index",
            "test_dti_with_offset_series",
            "test_unordered_different_categories_raises",
            "_take_with_fill",
            "_get_agg_axis",
            "_chk_truncate",
            "test_mul_int_series",
            "timezone_frame",
            "test_filter_out_all_groups",
            "to_series",
            "test_loc_and_at_with_categorical_index",
            "test_binary_ops_align",
            "test_skew",
            "test_dataframe_dummies_prefix_list",
            "test_crosstab_non_aligned",
            "_parse_dtype_strict",
            "nancorr",
            "test_get_level_values_all_na",
            "_get_single_indexer",
            "test_setitem_loc_scalar_single",
            "_find_valid_index",
            "sanitize_index",
            "test_deprecated_from_api_types",
            "test_get_indexer_nearest",
            "test_dti_custom_business_repr",
            "test_deprecate_no_docstring",
            "float_frame_fill2_dense",
            "test_index_false_from_json_to_json",
            "test_frame_double_encoded_labels",
            "test_pi_add_timedeltalike_mismatched_freq_hourly",
            "test_constructor_series_copy",
            "test_slice_integer",
            "test_reconstruct_sort",
            "test_merge_take_missing_values_from_index_of_other_dtype",
            "test_getitem_multiple",
            "test_nested_period_index_subscript_expression",
            "test_rank_na_option",
            "test_to_csv_withcommas",
            "test_comp_nat",
            "time_col_select_lambda_sum",
            "_make_stat_function",
            "test_basic_subset_columns",
            "test_range_slice_day",
            "test_str_cat_categorical",
            "test_boxplot_empty_column",
            "write_to_compressed",
            "time_strip",
            "test_query_by_text_obj",
            "test_operators_corner",
            "_make_wrapper",
            "test_astype_int",
            "read_gbq",
            "test_caption",
            "test_dtype_with_converters",
            "test_all_apply",
            "_setitem_with_indexer",
            "allow_in_pandas",
            "test_describe_percentiles_integer_idx",
            "test_cut_return_intervals",
            "test_read_csv_local",
            "test_stack_mixed_level",
            "test_file_handle",
            "_replace_pandas_items",
            "test_detect_console_encoding_from_stdout_stdin",
            "test_string_io",
            "test_periods",
            "test_set_properties_subset",
            "df_mixed_floats",
            "test_loc_getitem_nested_indexer",
            "test_replace_datetime",
            "test_range_edges",
            "test_to_html_truncate_multi_index",
            "test_rename_errors",
            "test_concat_categorical_multi_coercion",
            "test_slicing_datetimes",
            "test_timestamp_compare",
            "test_sort_index",
            "get_offset",
            "test_skipfooter",
            "get_new_values",
            "test_tz_dtype_matches",
            "test_join_level_corner_case",
            "file_path_to_url",
            "_extract_multi_indexer_columns",
            "_process_columnsize_subheader",
            "test_set_dtype_same",
            "test_no_copy_blocks",
            "test_two_backtick_variables_expr",
            "test_df_legend_labels",
            "test_to_string_unicode_three",
            "test_categorical_unexpected_categories",
            "test_extract_index_one_two_groups",
            "s3_resource",
            "test_index_convert_to_datetime_array_explicit_pytz",
            "test_reader_special_dtypes",
            "test_nansum",
            "test_calendar",
            "test_just_na",
            "test_period_cons_combined",
            "test_skipinitialspace",
            "test_diff_float_n",
            "test_margins_no_values_two_rows",
            "test_zfill",
            "_do_date_conversions",
            "test_categorical_delegations",
            "test_unsupported_dtype",
            "time_sparse_series_to_coo",
            "test_constructor_corner",
            "test_set_axis_inplace_axes",
            "test_datetime_with_timezone_roundtrip",
            "recode_for_groupby",
            "test_s3_fails",
            "_get_cacher",
            "_unconvert_string_array",
            "_add_numeric_operations",
            "_get_lbllist",
            "_replace_locals",
            "test_format_missing",
            "test_set_column_scalar_with_ix",
            "_get_empty_meta",
            "_get_new_axes",
            "_is_py3_complex_incompat",
            "test_astype_with_exclude_string",
            "test_not_hashable",
            "test_constructor_from_frame_series_freq",
            "test_aggregate_with_nat",
            "test_td_add_sub_one_day_ten_seconds",
            "test_query_python",
            "test_as_json_table_type_categorical_data",
            "test_axis_dates",
            "test_unordered_ts",
            "test_syntax_error_exprs",
            "test_plot_fails_when_ax_differs_from_figure",
            "test_invalid_kind",
            "test_rank2",
            "test_full_file_with_spaces",
            "fillna",
            "test_periods_number_check",
            "test_td_div_nan",
            "test_as_index",
            "time_read_csv_cached",
            "test_first_nan_kept",
            "test_homogenize",
            "_get_index_names",
            "test_same_ordering",
            "test_none_delimiter",
            "test_consistency_name",
            "test_numeric_conversions",
            "test_operators_combine",
            "nanskew",
            "test_unicode_problem_decoding_as_ascii",
            "test_expanding_consistency",
            "test_align_float",
            "test_ismethods",
            "testRollback2",
            "_skip_if_no_akima",
            "test_constructor_from_dense_series",
            "test_logical_ops_int_frame",
            "test_intersection_equal_sort_true",
            "test_interp_nonmono_raise",
            "test_concat_tuple_keys",
            "intersection",
            "test_to_block_index",
            "test_pivot",
            "test_td64arr_rfloordiv_tdlike_scalar",
            "test_neg_freq",
            "test_categorical_equal_object_override",
            "test_filter_multi_column_df",
            "test_pivot_table_with_iterator_values",
            "test_drop_and_dropna_caching",
            "init_windows_clipboard",
            "test_where_timedelta_coerce",
            "test_invalid_date_conversion",
            "test_dtype_per_column",
            "test_css_side_shorthands",
            "time_add",
            "test_register",
            "mixed_float2",
            "test_nested_object_record_path",
            "test_metadata_immutable",
            "test_td64arr_sub_timestamp_raises",
            "test_take_positive_no_warning",
            "nanstd",
            "test_attr_expression",
            "test_startswith",
            "test_closed",
            "test_invalid_url",
            "test_tz_convert_and_localize",
            "test_construction_with_mixed",
            "test_shift_gh8083",
            "test_validate_all_ignore_deprecated",
            "test_compat_replace",
            "test_basic_regular",
            "_items_overlap_with_suffix",
            "time_contains",
            "memory_usage",
            "test_map_compat",
            "is_monotonic_decreasing",
            "test_encode",
            "test_validate_sum_initial",
            "test_nanmean",
            "_add_comparison_methods",
            "test_corrwith_matches_corrcoef",
            "test_groupby_grouper_f_sanity_checked",
            "test_setitem_ndarray_3d",
            "test_constructor_field_arrays",
            "test_loc_getitem_duplicates_multiindex_non_scalar_type_object",
            "test_versioning",
            "_concat_rangeindex_same_dtype",
            "test_take_raises",
            "is_mixed",
            "test_agg_relabel_with_level",
            "test_empty_tables",
            "_add_datetimelike_methods",
            "test_int_internal",
            "test_get_numeric_data_preserve_dtype",
            "test_basic_upsample",
            "fast_xs",
            "test_intersection_empty",
            "test_undefined_func",
            "write_cells",
            "_make_flex_doc",
            "test_at_to_fail",
            "testRollforward1",
            "test_index_col_is_true",
            "test_non_ascii_key",
            "test_reductions",
            "test_parsing_different_timezone_offsets",
            "test_regex_replace_str_to_numeric",
            "_tag",
            "test_dti_constructor_years_only",
            "test_cross_engine_pa_fp",
            "table",
            "test_unstack_swaplevel_sortlevel",
            "test_dict_complex",
            "_convert_for_op",
            "test_from_product_iterator",
            "method_source",
            "test_join_str_datetime",
            "test_timezone_comparaison_bug",
            "test_separating_character",
            "test_set_name_attribute",
            "test_execute_sql",
            "test_partial_set_empty_frame_set_series",
            "get_value_maybe_box",
            "test_from_records_set_index_name",
            "test_same_name_but_underscores",
            "test_get_pad_indexer",
            "test_set_change_dtype_slice",
            "test_tseries_select_index_column",
            "_check_for_invalid_keys",
            "test_replace_input_formats_listlike",
            "test_td_add_timedeltalike_object_dtype_array",
            "test_insert_column_bug_4032",
            "test_where_tz_values",
            "test_query_string_scalar_variable",
            "test_df_flex_cmp_constant_return_types",
            "test_append_dtypes",
            "test_shift_duplicate_columns",
            "test_invalid_table_attrs",
            "test_max",
            "test_no_dummy_key_names",
            "_preparse",
            "filter",
            "set_version",
            "test_pos_numeric",
            "test_comparison_operators_with_nas",
            "test_astype_nansafe",
            "test_to_records_with_unicode_index",
            "test_td_add_offset",
            "test_getitem_with_listlike",
            "test_sparse_frame",
            "test_combine_from_sequence_raises",
            "test_pivot_multi_functions",
            "test_to_excel_timedelta",
            "test_pivot_index_none",
            "test_constructor_frame_copy",
            "test_constructor_categorical_with_coercion",
            "test_filter_mixed_df",
            "new_func_wrong_docstring",
            "test_timedelta_cut_roundtrip",
            "test_empty_prod",
            "get_new_columns",
            "test_astype_categoricaldtype",
            "_to_sql_fail",
            "test_to_csv_list_entries",
            "test_max_min_non_numeric",
            "test_to_string_multindex_header",
            "time_nlargest_one_column",
            "test_from_records_columns_not_modified",
            "test_isin_with_i8",
            "test_backend_is_not_module",
            "validate_min_itemsize",
            "test_filter_has_access_to_grouped_cols",
            "assert_interval_array_equal",
            "test_top_level_method",
            "remove_na",
            "test_divmod_invalid",
            "test_pi_add_timedeltalike_tick_gt1",
            "decode",
            "test_append_to_another",
            "_check_ticks_props",
            "test_nuiscance_columns",
            "test_getitem_multilevel_index_tuple_not_sorted",
            "test_series_indexing_multiple",
            "test_datetime",
            "test_map_dict_subclass_with_missing",
            "test_preserve_categorical_dtype",
            "test_cmp_series_period_series_mixed_freq",
            "test_repr_roundtrip",
            "test_out_of_range_double",
            "test_setitem_with_sparse_value",
            "test_data_after_quote",
            "test_ordered_none_default_deprecated",
            "test_stat_unexpected_keyword",
            "test_groupby_with_timegrouper",
            "test_pi_add_sub_timedeltalike_freq_mismatch_annual",
            "teardown_class",
            "test_check_compatible_with",
            "test_ewm_consistency",
            "_convert_datetimelike_to_object",
            "test_numeric_arr_rdiv_tdscalar",
            "test_to_csv_bug",
            "test_dti_astype_asobject_tzinfos",
            "test_write_ignoring_index",
            "test_from_categorical_dtype_both",
            "test_to_excel_multiindex_cols",
            "test_hour",
            "test_select_dtypes_bad_datetime64",
            "test_fast_apply",
            "github_url",
            "test_difference_sort_special",
            "_get_quarterly_rule",
            "_try_convert_types",
            "test_stale_cached_series_bug_473",
            "test_empty_na_values_no_default_with_index",
            "test_reindex",
            "test_bad_stream_exception",
            "test_construction_with_tz_and_tz_aware_dti",
            "test_crosstab_unsorted_order",
            "test_tuple_index",
            "test_no_warning",
            "_get_ordinal_range",
            "test_dti_iadd_tdi",
            "test_dti_intersection",
            "test_get_loc2",
            "test_concat",
            "rstjinja",
            "test_asobject_deprecated",
            "_recode_for_categories",
            "test_axis_classmethods",
            "test_disallow_set_ops",
            "from_intervals",
            "test_display_dict",
            "test_qcut_specify_quantiles",
            "test_na_value_dict",
            "_get_private_key_path",
            "_set_value",
            "test_fillna_limit_pad",
            "deregister",
            "test_constructor_more",
            "_prepare_pandas",
            "test_intersect_nosort",
            "makeCustomDataframe",
            "test_flex_method_equivalence",
            "test_exit_status_for_validate_all_json",
            "get_mgr_concatenation_plan",
            "test_empty_frame_roundtrip",
            "test_pi_cmp_period",
            "test_getitem_list_of_columns",
            "test_mpl_nopandas",
            "test_auto_conversion",
            "test_pos_raises",
            "test_errorbar_plot",
            "create_for_block",
            "test_encode_hook",
            "test_maybe_promote_any_with_string",
            "test_append_with_timezones_pytz",
            "test_td_mul_nan",
            "_reset_cache",
            "test_td_sub_timedeltalike_object_dtype_array",
            "test_xs_level",
            "get_authors",
            "test_fancy_setitem",
            "test_from_codes",
            "test_concat_categorical_tz",
            "_isnan",
            "test_date_parsing",
            "external_values",
            "test_frame_set_name_single",
            "test_pad_width",
            "test_value_counts_datetime",
            "test_pickle_round_trip",
            "test_rename_axis_supported",
            "test_getitem_setitem_ix_duplicates",
            "test_get_period_range_edges",
            "test_less_precise",
            "select_coords",
            "test_assert_numpy_array_equal_value_mismatch3",
            "test_dti_tz_conversion_freq",
            "time2num",
            "test_to_datetime_dt64s_out_of_bounds",
            "test_repr_html",
            "test_categorical_with_stata_missing_values",
            "test_dt64tz_series_sub_dtitz",
            "test_concat_axis1",
            "test_conv_read_write",
            "test_period_constructor_offsets",
            "test_incorrect_type_array",
            "test_dt64_data_invalid",
            "test_medium_complex_frame_alignment",
            "test_total_seconds_precision",
            "test_contiguous_boolean_preserve_freq",
            "_process_page_metadata",
            "test_agg_cast_results_dtypes",
            "reorder_levels",
            "test_set_index_timezone",
            "test_min_max_series",
            "test_update_dtype_string",
            "test_nanosecond_field",
            "_obj_with_exclusions",
            "test_assign_bad",
            "test_setting_fill_value_fillna_still_works",
            "test_series_map_box_timedelta",
            "three_group",
            "test_td64arr_add_str_invalid",
            "test_interp_timedelta64",
            "test_query_undefined_local",
            "__pos__",
            "test_series_tz_localize_empty",
            "stack_multiple",
            "test_series_getitem_returns_scalar",
            "test_sparse_with_compression",
            "test_empty_str_methods",
            "test_rdiv_zero",
            "test_constructor_dict_order",
            "round_trip_localpath",
            "test_apply_without_copy",
            "test_python_engine",
            "test_secondary_frame",
            "test_series_frame_commutativity",
            "set_axis",
            "test_astimezone",
            "test_droplevel",
            "_ensure_decoded",
            "test_union_sort_other_incomparable_true",
            "test_dti_with_timezone_repr",
            "is_platform_windows",
            "read_json",
            "test_groupby_series_indexed_differently",
            "test_assign",
            "test_widths",
            "test_header_multi_index_common_format2",
            "_load_iris_view",
            "_replace_coerce",
            "test_method_delegation",
            "test_fifth_week_of_month",
            "test_rename_multiindex",
            "_multiindex",
            "test_datetimeindex_highprecision",
            "test_malformed_chunks",
            "test_mode_datetime",
            "test_text_color_threshold",
            "test_comparison_object_array",
            "bdate_range",
            "test_repr_name_iterable_indexable",
            "test_format_timedelta_ticks_wide",
            "test_converters_corner_with_nans",
            "sum",
            "testArray",
            "_adorn_subplots",
            "test_invalid_origins_tzinfo",
            "maybe_infer_tz",
            "_make_legend",
            "test_dti_tz_localize_nonexistent_shift_invalid",
            "test_dates_invalid_column",
            "test_scalar_integer",
            "test_dt64arr_isub_timedeltalike_scalar",
            "test_cython_api2",
            "test_ix_general",
            "test_with_s3_url",
            "test_nonunique_contains",
            "test_get_year_end",
            "test_logical_with_nas",
            "test_from_codes_with_categorical_categories",
            "test_concat_single_with_key",
            "time_frame_getitem_single_column_label",
            "test_getitems_slice_multi",
            "test_take_invalid_kwargs",
            "test_rollback",
            "test_assert_numpy_array_equal_value_mismatch1",
            "test_backend_is_correct",
            "test_cached_data",
            "test_no_mlk_before_1986",
            "test_append_concat_tz",
            "_reindex_indexer",
            "test_fillna_limit_backfill",
            "test_block_internal",
            "test_background_gradient",
            "test_ragged_sum",
            "test_freq_str",
            "test_join_on_pass_vector",
            "test_line_colors",
            "test_label",
            "str_wrap",
            "test_iloc_getitem_labelled_frame",
            "test_indexing_sliced"
          ]
        },
        "file": {
          "file_name": "strings.py",
          "file_nloc": 118,
          "file_complexity": 45,
          "file_token_count": 1062,
          "file_before": "import warnings\n\nimport numpy as np\nfrom pandas import Series, DataFrame\nimport pandas.util.testing as tm\n\n\nclass Methods:\n\n    def setup(self):\n        self.s = Series(tm.makeStringIndex(10**5))\n\n    def time_center(self):\n        self.s.str.center(100)\n\n    def time_count(self):\n        self.s.str.count('A')\n\n    def time_endswith(self):\n        self.s.str.endswith('A')\n\n    def time_extract(self):\n        with warnings.catch_warnings(record=True):\n            self.s.str.extract('(\\\\w*)A(\\\\w*)')\n\n    def time_findall(self):\n        self.s.str.findall('[A-Z]+')\n\n    def time_find(self):\n        self.s.str.find('[A-Z]+')\n\n    def time_rfind(self):\n        self.s.str.rfind('[A-Z]+')\n\n    def time_get(self):\n        self.s.str.get(0)\n\n    def time_len(self):\n        self.s.str.len()\n\n    def time_join(self):\n        self.s.str.join(' ')\n\n    def time_match(self):\n        self.s.str.match('A')\n\n    def time_normalize(self):\n        self.s.str.normalize('NFC')\n\n    def time_pad(self):\n        self.s.str.pad(100, side='both')\n\n    def time_partition(self):\n        self.s.str.partition('A')\n\n    def time_rpartition(self):\n        self.s.str.rpartition('A')\n\n    def time_replace(self):\n        self.s.str.replace('A', '\\x01\\x01')\n\n    def time_translate(self):\n        self.s.str.translate({'A': '\\x01\\x01'})\n\n    def time_slice(self):\n        self.s.str.slice(5, 15, 2)\n\n    def time_startswith(self):\n        self.s.str.startswith('A')\n\n    def time_strip(self):\n        self.s.str.strip('A')\n\n    def time_rstrip(self):\n        self.s.str.rstrip('A')\n\n    def time_lstrip(self):\n        self.s.str.lstrip('A')\n\n    def time_title(self):\n        self.s.str.title()\n\n    def time_upper(self):\n        self.s.str.upper()\n\n    def time_lower(self):\n        self.s.str.lower()\n\n    def time_wrap(self):\n        self.s.str.wrap(10)\n\n    def time_zfill(self):\n        self.s.str.zfill(10)\n\n\nclass Repeat:\n\n    params = ['int', 'array']\n    param_names = ['repeats']\n\n    def setup(self, repeats):\n        N = 10**5\n        self.s = Series(tm.makeStringIndex(N))\n        repeat = {'int': 1, 'array': np.random.randint(1, 3, N)}\n        self.values = repeat[repeats]\n\n    def time_repeat(self, repeats):\n        self.s.str.repeat(self.values)\n\n\nclass Cat:\n\n    params = ([0, 3], [None, ','], [None, '-'], [0.0, 0.001, 0.15])\n    param_names = ['other_cols', 'sep', 'na_rep', 'na_frac']\n\n    def setup(self, other_cols, sep, na_rep, na_frac):\n        N = 10 ** 5\n        mask_gen = lambda: np.random.choice([True, False], N,\n                                            p=[1 - na_frac, na_frac])\n        self.s = Series(tm.makeStringIndex(N)).where(mask_gen())\n        if other_cols == 0:\n            # str.cat self-concatenates only for others=None\n            self.others = None\n        else:\n            self.others = DataFrame({i: tm.makeStringIndex(N).where(mask_gen())\n                                     for i in range(other_cols)})\n\n    def time_cat(self, other_cols, sep, na_rep, na_frac):\n        # before the concatenation (one caller + other_cols columns), the total\n        # expected fraction of rows containing any NaN is:\n        # reduce(lambda t, _: t + (1 - t) * na_frac, range(other_cols + 1), 0)\n        # for other_cols=3 and na_frac=0.15, this works out to ~48%\n        self.s.str.cat(others=self.others, sep=sep, na_rep=na_rep)\n\n\nclass Contains:\n\n    params = [True, False]\n    param_names = ['regex']\n\n    def setup(self, regex):\n        self.s = Series(tm.makeStringIndex(10**5))\n\n    def time_contains(self, regex):\n        self.s.str.contains('A', regex=regex)\n\n\nclass Split:\n\n    params = [True, False]\n    param_names = ['expand']\n\n    def setup(self, expand):\n        self.s = Series(tm.makeStringIndex(10**5)).str.join('--')\n\n    def time_split(self, expand):\n        self.s.str.split('--', expand=expand)\n\n    def time_rsplit(self, expand):\n        self.s.str.rsplit('--', expand=expand)\n\n\nclass Dummies:\n\n    def setup(self):\n        self.s = Series(tm.makeStringIndex(10**5)).str.join('|')\n\n    def time_get_dummies(self):\n        self.s.str.get_dummies('|')\n\n\nclass Encode:\n\n    def setup(self):\n        self.ser = Series(tm.makeUnicodeIndex())\n\n    def time_encode_decode(self):\n        self.ser.str.encode('utf-8').str.decode('utf-8')\n\n\nclass Slice:\n\n    def setup(self):\n        self.s = Series(['abcdefg', np.nan] * 500000)\n\n    def time_vector_slice(self):\n        # GH 2602\n        self.s.str[:5]\n",
          "file_after": "import warnings\n\nimport numpy as np\nfrom pandas import Series, DataFrame\nimport pandas.util.testing as tm\n\n\nclass Methods:\n    def setup(self):\n        self.s = Series(tm.makeStringIndex(10 ** 5))\n\n    def time_center(self):\n        self.s.str.center(100)\n\n    def time_count(self):\n        self.s.str.count(\"A\")\n\n    def time_endswith(self):\n        self.s.str.endswith(\"A\")\n\n    def time_extract(self):\n        with warnings.catch_warnings(record=True):\n            self.s.str.extract(\"(\\\\w*)A(\\\\w*)\")\n\n    def time_findall(self):\n        self.s.str.findall(\"[A-Z]+\")\n\n    def time_find(self):\n        self.s.str.find(\"[A-Z]+\")\n\n    def time_rfind(self):\n        self.s.str.rfind(\"[A-Z]+\")\n\n    def time_get(self):\n        self.s.str.get(0)\n\n    def time_len(self):\n        self.s.str.len()\n\n    def time_join(self):\n        self.s.str.join(\" \")\n\n    def time_match(self):\n        self.s.str.match(\"A\")\n\n    def time_normalize(self):\n        self.s.str.normalize(\"NFC\")\n\n    def time_pad(self):\n        self.s.str.pad(100, side=\"both\")\n\n    def time_partition(self):\n        self.s.str.partition(\"A\")\n\n    def time_rpartition(self):\n        self.s.str.rpartition(\"A\")\n\n    def time_replace(self):\n        self.s.str.replace(\"A\", \"\\x01\\x01\")\n\n    def time_translate(self):\n        self.s.str.translate({\"A\": \"\\x01\\x01\"})\n\n    def time_slice(self):\n        self.s.str.slice(5, 15, 2)\n\n    def time_startswith(self):\n        self.s.str.startswith(\"A\")\n\n    def time_strip(self):\n        self.s.str.strip(\"A\")\n\n    def time_rstrip(self):\n        self.s.str.rstrip(\"A\")\n\n    def time_lstrip(self):\n        self.s.str.lstrip(\"A\")\n\n    def time_title(self):\n        self.s.str.title()\n\n    def time_upper(self):\n        self.s.str.upper()\n\n    def time_lower(self):\n        self.s.str.lower()\n\n    def time_wrap(self):\n        self.s.str.wrap(10)\n\n    def time_zfill(self):\n        self.s.str.zfill(10)\n\n\nclass Repeat:\n\n    params = [\"int\", \"array\"]\n    param_names = [\"repeats\"]\n\n    def setup(self, repeats):\n        N = 10 ** 5\n        self.s = Series(tm.makeStringIndex(N))\n        repeat = {\"int\": 1, \"array\": np.random.randint(1, 3, N)}\n        self.values = repeat[repeats]\n\n    def time_repeat(self, repeats):\n        self.s.str.repeat(self.values)\n\n\nclass Cat:\n\n    params = ([0, 3], [None, \",\"], [None, \"-\"], [0.0, 0.001, 0.15])\n    param_names = [\"other_cols\", \"sep\", \"na_rep\", \"na_frac\"]\n\n    def setup(self, other_cols, sep, na_rep, na_frac):\n        N = 10 ** 5\n        mask_gen = lambda: np.random.choice([True, False], N, p=[1 - na_frac, na_frac])\n        self.s = Series(tm.makeStringIndex(N)).where(mask_gen())\n        if other_cols == 0:\n            # str.cat self-concatenates only for others=None\n            self.others = None\n        else:\n            self.others = DataFrame(\n                {i: tm.makeStringIndex(N).where(mask_gen()) for i in range(other_cols)}\n            )\n\n    def time_cat(self, other_cols, sep, na_rep, na_frac):\n        # before the concatenation (one caller + other_cols columns), the total\n        # expected fraction of rows containing any NaN is:\n        # reduce(lambda t, _: t + (1 - t) * na_frac, range(other_cols + 1), 0)\n        # for other_cols=3 and na_frac=0.15, this works out to ~48%\n        self.s.str.cat(others=self.others, sep=sep, na_rep=na_rep)\n\n\nclass Contains:\n\n    params = [True, False]\n    param_names = [\"regex\"]\n\n    def setup(self, regex):\n        self.s = Series(tm.makeStringIndex(10 ** 5))\n\n    def time_contains(self, regex):\n        self.s.str.contains(\"A\", regex=regex)\n\n\nclass Split:\n\n    params = [True, False]\n    param_names = [\"expand\"]\n\n    def setup(self, expand):\n        self.s = Series(tm.makeStringIndex(10 ** 5)).str.join(\"--\")\n\n    def time_split(self, expand):\n        self.s.str.split(\"--\", expand=expand)\n\n    def time_rsplit(self, expand):\n        self.s.str.rsplit(\"--\", expand=expand)\n\n\nclass Dummies:\n    def setup(self):\n        self.s = Series(tm.makeStringIndex(10 ** 5)).str.join(\"|\")\n\n    def time_get_dummies(self):\n        self.s.str.get_dummies(\"|\")\n\n\nclass Encode:\n    def setup(self):\n        self.ser = Series(tm.makeUnicodeIndex())\n\n    def time_encode_decode(self):\n        self.ser.str.encode(\"utf-8\").str.decode(\"utf-8\")\n\n\nclass Slice:\n    def setup(self):\n        self.s = Series([\"abcdefg\", np.nan] * 500000)\n\n    def time_vector_slice(self):\n        # GH 2602\n        self.s.str[:5]\n",
          "file_patch": "@@ -6,31 +6,30 @@ import pandas.util.testing as tm\n \n \n class Methods:\n-\n     def setup(self):\n-        self.s = Series(tm.makeStringIndex(10**5))\n+        self.s = Series(tm.makeStringIndex(10 ** 5))\n \n     def time_center(self):\n         self.s.str.center(100)\n \n     def time_count(self):\n-        self.s.str.count('A')\n+        self.s.str.count(\"A\")\n \n     def time_endswith(self):\n-        self.s.str.endswith('A')\n+        self.s.str.endswith(\"A\")\n \n     def time_extract(self):\n         with warnings.catch_warnings(record=True):\n-            self.s.str.extract('(\\\\w*)A(\\\\w*)')\n+            self.s.str.extract(\"(\\\\w*)A(\\\\w*)\")\n \n     def time_findall(self):\n-        self.s.str.findall('[A-Z]+')\n+        self.s.str.findall(\"[A-Z]+\")\n \n     def time_find(self):\n-        self.s.str.find('[A-Z]+')\n+        self.s.str.find(\"[A-Z]+\")\n \n     def time_rfind(self):\n-        self.s.str.rfind('[A-Z]+')\n+        self.s.str.rfind(\"[A-Z]+\")\n \n     def time_get(self):\n         self.s.str.get(0)\n@@ -39,43 +38,43 @@ class Methods:\n         self.s.str.len()\n \n     def time_join(self):\n-        self.s.str.join(' ')\n+        self.s.str.join(\" \")\n \n     def time_match(self):\n-        self.s.str.match('A')\n+        self.s.str.match(\"A\")\n \n     def time_normalize(self):\n-        self.s.str.normalize('NFC')\n+        self.s.str.normalize(\"NFC\")\n \n     def time_pad(self):\n-        self.s.str.pad(100, side='both')\n+        self.s.str.pad(100, side=\"both\")\n \n     def time_partition(self):\n-        self.s.str.partition('A')\n+        self.s.str.partition(\"A\")\n \n     def time_rpartition(self):\n-        self.s.str.rpartition('A')\n+        self.s.str.rpartition(\"A\")\n \n     def time_replace(self):\n-        self.s.str.replace('A', '\\x01\\x01')\n+        self.s.str.replace(\"A\", \"\\x01\\x01\")\n \n     def time_translate(self):\n-        self.s.str.translate({'A': '\\x01\\x01'})\n+        self.s.str.translate({\"A\": \"\\x01\\x01\"})\n \n     def time_slice(self):\n         self.s.str.slice(5, 15, 2)\n \n     def time_startswith(self):\n-        self.s.str.startswith('A')\n+        self.s.str.startswith(\"A\")\n \n     def time_strip(self):\n-        self.s.str.strip('A')\n+        self.s.str.strip(\"A\")\n \n     def time_rstrip(self):\n-        self.s.str.rstrip('A')\n+        self.s.str.rstrip(\"A\")\n \n     def time_lstrip(self):\n-        self.s.str.lstrip('A')\n+        self.s.str.lstrip(\"A\")\n \n     def time_title(self):\n         self.s.str.title()\n@@ -95,13 +94,13 @@ class Methods:\n \n class Repeat:\n \n-    params = ['int', 'array']\n-    param_names = ['repeats']\n+    params = [\"int\", \"array\"]\n+    param_names = [\"repeats\"]\n \n     def setup(self, repeats):\n-        N = 10**5\n+        N = 10 ** 5\n         self.s = Series(tm.makeStringIndex(N))\n-        repeat = {'int': 1, 'array': np.random.randint(1, 3, N)}\n+        repeat = {\"int\": 1, \"array\": np.random.randint(1, 3, N)}\n         self.values = repeat[repeats]\n \n     def time_repeat(self, repeats):\n@@ -110,20 +109,20 @@ class Repeat:\n \n class Cat:\n \n-    params = ([0, 3], [None, ','], [None, '-'], [0.0, 0.001, 0.15])\n-    param_names = ['other_cols', 'sep', 'na_rep', 'na_frac']\n+    params = ([0, 3], [None, \",\"], [None, \"-\"], [0.0, 0.001, 0.15])\n+    param_names = [\"other_cols\", \"sep\", \"na_rep\", \"na_frac\"]\n \n     def setup(self, other_cols, sep, na_rep, na_frac):\n         N = 10 ** 5\n-        mask_gen = lambda: np.random.choice([True, False], N,\n-                                            p=[1 - na_frac, na_frac])\n+        mask_gen = lambda: np.random.choice([True, False], N, p=[1 - na_frac, na_frac])\n         self.s = Series(tm.makeStringIndex(N)).where(mask_gen())\n         if other_cols == 0:\n             # str.cat self-concatenates only for others=None\n             self.others = None\n         else:\n-            self.others = DataFrame({i: tm.makeStringIndex(N).where(mask_gen())\n-                                     for i in range(other_cols)})\n+            self.others = DataFrame(\n+                {i: tm.makeStringIndex(N).where(mask_gen()) for i in range(other_cols)}\n+            )\n \n     def time_cat(self, other_cols, sep, na_rep, na_frac):\n         # before the concatenation (one caller + other_cols columns), the total\n@@ -136,52 +135,49 @@ class Cat:\n class Contains:\n \n     params = [True, False]\n-    param_names = ['regex']\n+    param_names = [\"regex\"]\n \n     def setup(self, regex):\n-        self.s = Series(tm.makeStringIndex(10**5))\n+        self.s = Series(tm.makeStringIndex(10 ** 5))\n \n     def time_contains(self, regex):\n-        self.s.str.contains('A', regex=regex)\n+        self.s.str.contains(\"A\", regex=regex)\n \n \n class Split:\n \n     params = [True, False]\n-    param_names = ['expand']\n+    param_names = [\"expand\"]\n \n     def setup(self, expand):\n-        self.s = Series(tm.makeStringIndex(10**5)).str.join('--')\n+        self.s = Series(tm.makeStringIndex(10 ** 5)).str.join(\"--\")\n \n     def time_split(self, expand):\n-        self.s.str.split('--', expand=expand)\n+        self.s.str.split(\"--\", expand=expand)\n \n     def time_rsplit(self, expand):\n-        self.s.str.rsplit('--', expand=expand)\n+        self.s.str.rsplit(\"--\", expand=expand)\n \n \n class Dummies:\n-\n     def setup(self):\n-        self.s = Series(tm.makeStringIndex(10**5)).str.join('|')\n+        self.s = Series(tm.makeStringIndex(10 ** 5)).str.join(\"|\")\n \n     def time_get_dummies(self):\n-        self.s.str.get_dummies('|')\n+        self.s.str.get_dummies(\"|\")\n \n \n class Encode:\n-\n     def setup(self):\n         self.ser = Series(tm.makeUnicodeIndex())\n \n     def time_encode_decode(self):\n-        self.ser.str.encode('utf-8').str.decode('utf-8')\n+        self.ser.str.encode(\"utf-8\").str.decode(\"utf-8\")\n \n \n class Slice:\n-\n     def setup(self):\n-        self.s = Series(['abcdefg', np.nan] * 500000)\n+        self.s = Series([\"abcdefg\", np.nan] * 500000)\n \n     def time_vector_slice(self):\n         # GH 2602\n",
          "files_name_in_blame_commit": [
            "test_index_col.py",
            "generate_legacy_storage_files.py",
            "offsets.py",
            "test_timedeltas.py",
            "scipy_sparse.py",
            "test_na_values.py",
            "_optional.py",
            "test_xlrd.py",
            "groupby.py",
            "datetimes.py",
            "parquet.py",
            "test_qcut.py",
            "style.py",
            "test_accessor.py",
            "join_merge.py",
            "test_sorted.py",
            "test_multilevel.py",
            "test_integrity.py",
            "timestamp.py",
            "test_holiday.py",
            "test_assert_extension_array_equal.py",
            "series_methods.py",
            "test_indexing_slow.py",
            "test_readlines.py",
            "find_commits_touching_func.py",
            "test_index_as_string.py",
            "test_config.py",
            "pandas_vb_common.py",
            "test_operators.py",
            "test_reshape.py",
            "resample.py",
            "test_assert_series_equal.py",
            "period.py",
            "test_read_fwf.py",
            "test_lib.py",
            "pickle_compat.py",
            "test_melt.py",
            "frame.py",
            "util.py",
            "test_json_table_schema.py",
            "_util.py",
            "test_ujson.py",
            "test_compat.py",
            "test_parse_dates.py",
            "test_validate.py",
            "test_eval.py",
            "test_reductions.py",
            "numeric.py",
            "test_multi_thread.py",
            "test_assert_numpy_array_equal.py",
            "test_subclass.py",
            "concat.py",
            "test_pandas.py",
            "test_offsets_properties.py",
            "test_format.py",
            "test_printing.py",
            "ops.py",
            "console.py",
            "test_api.py",
            "test_filters.py",
            "test_pytables.py",
            "test_xs.py",
            "test_datetime_index.py",
            "test_assert_categorical_equal.py",
            "inference.py",
            "test_contains.py",
            "test_parsing.py",
            "test_scalar_compat.py",
            "test_pickle.py",
            "versioneer.py",
            "test_sas7bdat.py",
            "test_rank.py",
            "test_asof.py",
            "test_missing.py",
            "test_normalize_date.py",
            "latex.py",
            "test_period_asfreq.py",
            "test_parse_iso8601.py",
            "test_xlsxwriter.py",
            "attrs_caching.py",
            "category.py",
            "test_observance.py",
            "_validators.py",
            "test_libsparse.py",
            "test_validate_args.py",
            "interval.py",
            "test_converter.py",
            "__init__.py",
            "test_join.py",
            "dtype.py",
            "tile.py",
            "test_merge_asof.py",
            "tools.py",
            "test_deprecate_kwarg.py",
            "test_spss.py",
            "test_indexing.py",
            "test_range.py",
            "table_schema.py",
            "test_normalize.py",
            "pickle.py",
            "test_extension.py",
            "_typing.py",
            "test_axis_select_reindex.py",
            "_xlrd.py",
            "test_to_from_scipy.py",
            "test_construct_from_scalar.py",
            "frozen.py",
            "test_sort_values_level_as_str.py",
            "test_sparse.py",
            "test_io.py",
            "test_libfrequencies.py",
            "test_numpy.py",
            "methods.py",
            "test_mangle_dupes.py",
            "merge.py",
            "test_to_latex.py",
            "test_localization.py",
            "test_header.py",
            "test_timedelta.py",
            "test_groupby.py",
            "test_html.py",
            "test_datetimes.py",
            "test_equivalence.py",
            "csvs.py",
            "setitem.py",
            "test_arithmetic.py",
            "test_expressions.py",
            "test_window.py",
            "sparse.py",
            "test_grouping.py",
            "test_dialect.py",
            "test_errors.py",
            "sasreader.py",
            "conftest.py",
            "bool.py",
            "holiday.py",
            "test_getitem.py",
            "test_register_accessor.py",
            "test_whitelist.py",
            "download_wheels.py",
            "test_assert_produces_warning.py",
            "test_validate_docstrings.py",
            "test_scalar.py",
            "expr.py",
            "test_quantile.py",
            "converter.py",
            "test_unpack_raw.py",
            "html.py",
            "series.py",
            "test_to_html.py",
            "test_validate_args_and_kwargs.py",
            "function.py",
            "test_seq.py",
            "test_comparisons.py",
            "stat_ops.py",
            "test_infer_datetimelike.py",
            "exceptions.py",
            "test_case.py",
            "test_pack.py",
            "test_period_index.py",
            "sas_xport.py",
            "test_upcast.py",
            "test_buffer.py",
            "test_construct_ndarray.py",
            "config.py",
            "test_aggregate.py",
            "test_sorting.py",
            "excel.py",
            "format.py",
            "test_astype.py",
            "_ranges.py",
            "generate_pip_deps_from_conda.py",
            "test_quoting.py",
            "test_converters.py",
            "test_backend.py",
            "setup.py",
            "test_mutate_columns.py",
            "test_timestamp.py",
            "test_downcast.py",
            "test_loc.py",
            "getitem.py",
            "test_partial_slicing.py",
            "test_yqm_offsets.py",
            "test_array_to_datetime.py",
            "test_interval_new.py",
            "test_css.py",
            "test_interval.py",
            "test_dtype.py",
            "test_bin_groupby.py",
            "algorithms.py",
            "test_limits.py",
            "indexing.py",
            "test_gbq.py",
            "_print_versions.py",
            "test_names.py",
            "test_skiprows.py",
            "accessor.py",
            "hashing.py",
            "test_timezones.py",
            "test_transform.py",
            "test_gcs.py",
            "test_fiscal.py",
            "eval.py",
            "test_obj.py",
            "test_datetime_values.py",
            "test_writers.py",
            "test_pivot.py",
            "test_block_internals.py",
            "test_except.py",
            "display.py",
            "gcs.py",
            "announce.py",
            "test_timegrouper.py",
            "test_construct_object_arr.py",
            "frame_methods.py",
            "test_time_grouper.py",
            "array_.py",
            "compat.py",
            "test_xport.py",
            "test_to_excel.py",
            "test_merge_ordered.py",
            "test_assert_almost_equal.py",
            "test_alter_index.py",
            "test_period_range.py",
            "test_get_set.py",
            "test_date_converters.py",
            "index.py",
            "test_setitem.py",
            "integer.py",
            "numpy_.py",
            "test_callable.py",
            "gil.py",
            "test_s3.py",
            "test_value_counts.py",
            "reduce.py",
            "test_take.py",
            "timeseries.py",
            "_version.py",
            "test_other.py",
            "test_cut.py",
            "test_series.py",
            "test_numpy_compat.py",
            "managers.py",
            "api.py",
            "test_unsupported.py",
            "pytables.py",
            "timedelta.py",
            "core.py",
            "test_merge_index_as_string.py",
            "test_misc.py",
            "binary_ops.py",
            "test_hist_method.py",
            "test_stata.py",
            "test_internals.py",
            "test_optional_dependency.py",
            "test_convert_to.py",
            "packers.py",
            "test_move.py",
            "test_base.py",
            "test_replace.py",
            "test_boxplot_method.py",
            "windows.py",
            "test_promote.py",
            "test_floats.py",
            "test_python_parser_only.py",
            "feather_format.py",
            "test_decimal.py",
            "test_style.py",
            "spss.py",
            "test_integer.py",
            "test_interval_tree.py",
            "test_frame.py",
            "test_setops.py",
            "_odfreader.py",
            "_decorators.py",
            "test_validate_kwargs.py",
            "contributors.py",
            "test_comment.py",
            "test_reindex.py",
            "_doctools.py",
            "test_conversion.py",
            "test_sql.py",
            "_test_decorators.py",
            "date_converters.py",
            "ctors.py",
            "test_ix.py",
            "json.py",
            "test_rendering.py",
            "test_safe_import.py",
            "test_constructors.py",
            "test_downstream.py",
            "test_inference.py",
            "test_iloc.py",
            "multiindex_object.py",
            "align.py",
            "test_construction.py",
            "test_resample_api.py",
            "test_function.py",
            "_base.py",
            "test_textreader.py",
            "engines.py",
            "test_assert_interval_array_equal.py",
            "test_readers.py",
            "test_slice.py",
            "test_subtype.py",
            "test_openpyxl.py",
            "test_unary_ops.py",
            "index_object.py",
            "base.py",
            "test_calendar.py",
            "_core.py",
            "dates.py",
            "test_partial_indexing.py",
            "pandas_logo.py",
            "test_nanops.py",
            "offset.py",
            "test_date_range.py",
            "test_nth.py",
            "test_assert_frame_equal.py",
            "test_json.py",
            "strings.py",
            "csv.py",
            "conf.py",
            "datetimelike.py",
            "timedeltas.py",
            "expressions.py",
            "test_offsets.py",
            "stata.py",
            "test_coercion.py",
            "gbq.py",
            "test_combine_concat.py",
            "scope.py",
            "test_concat.py",
            "rolling.py",
            "construction.py",
            "test_numeric.py",
            "check.py",
            "grouper.py",
            "melt.py",
            "test_chaining_and_caching.py",
            "test_copy.py",
            "test_util.py",
            "test_categorical.py",
            "test_bool.py",
            "test_alter_axes.py",
            "test_period.py",
            "test_network.py",
            "test_ufunc.py",
            "clipboards.py",
            "_misc.py",
            "s3.py",
            "test_drop.py",
            "test_to_csv.py",
            "test_label_or_level_utils.py",
            "multi.py",
            "msgpack.py",
            "replace.py",
            "test_timedelta_range.py",
            "test_generic.py",
            "test_xlwt.py",
            "test_multiindex.py",
            "test_datetime.py",
            "generic.py",
            "sas_constants.py",
            "cast.py",
            "test_usecols.py",
            "_depr_module.py",
            "parsers.py",
            "printing.py",
            "test_duplicates.py",
            "_xlsxwriter.py",
            "test_nat.py",
            "constructors.py",
            "css.py",
            "test_asfreq.py",
            "test_tools.py",
            "nanops.py",
            "chainmap.py",
            "test_ops.py",
            "test_arithmetics.py",
            "localization.py",
            "test_ticks.py",
            "blocks.py",
            "merge-pr.py",
            "test_c_parser_only.py",
            "test_datetime64.py",
            "test_resampler_grouper.py",
            "test_repr.py",
            "reshape.py",
            "test_object.py",
            "test_repr_info.py",
            "test_hashing.py",
            "test_eng_formatting.py",
            "test_clipboard.py",
            "test_common.py",
            "hist.py",
            "test_warnings.py",
            "test_category.py",
            "sas.py",
            "plotting.py",
            "test_nonunique_indexes.py",
            "frequencies.py",
            "test_compression.py",
            "test_assert_index_equal.py",
            "test_sequnpack.py",
            "test_frozen.py",
            "test_console.py",
            "test_indexing_engines.py",
            "test_algos.py",
            "test_parquet.py",
            "test_to_offset.py",
            "test_interval_range.py",
            "sas7bdat.py",
            "range.py",
            "test_boolean.py",
            "test_read_size.py",
            "test_federal.py",
            "test_cython.py",
            "boxplot.py",
            "pivot.py",
            "make.py",
            "print_skipped.py",
            "normalize.py",
            "test_merge.py",
            "test_apply.py",
            "_tester.py",
            "testing.py",
            "test_monotonic.py",
            "test_multi.py",
            "test_deprecate.py",
            "sorting.py",
            "test_set_ops.py",
            "test_freq_code.py",
            "apply.py",
            "accessors.py",
            "test_timedelta64.py",
            "validate_docstrings.py",
            "test_stat_reductions.py",
            "test_datetimelike.py",
            "test_packers.py",
            "test_dtypes.py",
            "test_analytics.py",
            "test_counting.py",
            "test_find_common_type.py",
            "test_query_eval.py",
            "test_types.py",
            "frame_ctor.py",
            "test_unpack.py",
            "hdf.py",
            "misc.py",
            "common.py",
            "test_timeseries.py",
            "test_partial.py",
            "config_init.py",
            "interface.py",
            "io.py",
            "categoricals.py",
            "reindex.py",
            "sql.py",
            "test_infer_dtype.py",
            "window.py",
            "array.py",
            "test_sas.py",
            "_openpyxl.py",
            "test_external_block.py",
            "indexing_engines.py",
            "categorical.py",
            "_xlwt.py",
            "test_ccalendar.py",
            "missing.py",
            "test_liboffsets.py",
            "test_feather.py",
            "test_newspec.py",
            "test_strings.py",
            "test_array.py",
            "test_odf.py",
            "test_formats.py",
            "test_constructor.py",
            "reshaping.py",
            "dtypes.py",
            "test_union_categoricals.py"
          ]
        }
      },
      "779aeacd4d1560b23df6f0e9d153c5452ad28759": {
        "commit": {
          "commit_id": "779aeacd4d1560b23df6f0e9d153c5452ad28759",
          "commit_message": "BUG: sets in str.cat (#23187)",
          "commit_author": "h-vetinari",
          "commit_date": "2018-10-22 23:10:07",
          "commit_parent": "18c5cfd6929d92fff3a77d0c898b2118b17d8a6a"
        },
        "function": {
          "function_name": "_get_series_list",
          "function_code_before": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Index, Series, DataFrame\n    idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, Series):\n        warn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and warn else others]\n        return (los, warn)\n    elif isinstance(others, Index):\n        warn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, warn)\n    elif isinstance(others, DataFrame):\n        warn = not others.index.equals(idx)\n        if ignore_index and warn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], warn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others):\n        others = list(others)\n        if all((is_list_like(x) for x in others)):\n            los = []\n            join_warn = False\n            depr_warn = False\n            while others:\n                nxt = others.pop(0)\n                if not (isinstance(nxt, (Series, Index)) or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)):\n                    depr_warn = True\n                if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, Index))\n                is_legal = no_deep and nxt.dtype == object or all((not is_list_like(x) for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, wnx) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                join_warn = join_warn or wnx\n            if depr_warn:\n                warnings.warn('list-likes other than Series, Index, or np.ndarray WITHIN another list-like are deprecated and will be removed in a future version.', FutureWarning, stacklevel=3)\n            return (los, join_warn)\n        elif all((not is_list_like(x) for x in others)):\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_code_after": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Index, Series, DataFrame\n    idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, Series):\n        warn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and warn else others]\n        return (los, warn)\n    elif isinstance(others, Index):\n        warn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, warn)\n    elif isinstance(others, DataFrame):\n        warn = not others.index.equals(idx)\n        if ignore_index and warn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], warn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others, allow_sets=False):\n        others = list(others)\n        if all((is_list_like(x, allow_sets=False) for x in others)):\n            los = []\n            join_warn = False\n            depr_warn = False\n            while others:\n                nxt = others.pop(0)\n                if not (isinstance(nxt, (Series, Index)) or (isinstance(nxt, np.ndarray) and nxt.ndim == 1)):\n                    depr_warn = True\n                if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, Index))\n                is_legal = no_deep and nxt.dtype == object or all((not is_list_like(x) for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, wnx) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                join_warn = join_warn or wnx\n            if depr_warn:\n                warnings.warn('list-likes other than Series, Index, or np.ndarray WITHIN another list-like are deprecated and will be removed in a future version.', FutureWarning, stacklevel=3)\n            return (los, join_warn)\n        elif all((not is_list_like(x) for x in others)):\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_before_start_line": 1942,
          "function_before_end_line": 2052,
          "function_after_start_line": 1942,
          "function_after_end_line": 2052,
          "function_before_token_count": 488,
          "function_after_token_count": 496,
          "functions_name_modified_file": [
            "str_replace",
            "str_endswith",
            "str_join",
            "str_decode",
            "match",
            "rsplit",
            "center",
            "find",
            "wrap",
            "str_encode",
            "str_get",
            "_get_single_group_name",
            "str_extract",
            "str_strip",
            "str_translate",
            "translate",
            "str_repeat",
            "_str_extract_noexpand",
            "lstrip",
            "_noarg_wrapper",
            "str_pad",
            "_make_accessor",
            "str_count",
            "extract",
            "rfind",
            "normalize",
            "__iter__",
            "str_find",
            "_map",
            "str_rsplit",
            "str_contains",
            "partition",
            "strip",
            "rjust",
            "slice_replace",
            "_na_map",
            "rindex",
            "str_slice",
            "rpartition",
            "repeat",
            "str_slice_replace",
            "decode",
            "index",
            "get",
            "ljust",
            "encode",
            "cat_core",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "_validate",
            "__getitem__",
            "_str_extract_frame",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_index",
            "str_extractall",
            "zfill",
            "str_startswith",
            "str_split",
            "_get_series_list",
            "str_findall",
            "copy",
            "split",
            "join",
            "pad",
            "get_dummies",
            "str_wrap",
            "_groups_or_na_fun",
            "contains",
            "str_match",
            "rstrip",
            "cat"
          ],
          "functions_name_all_files": [
            "test_get_dummies_with_name_dummy",
            "test_extractall_same_as_extract",
            "str_endswith",
            "test_extractall_single_group",
            "test_strip_lstrip_rstrip_args",
            "rsplit",
            "str_encode",
            "str_get",
            "test_extract_expand_None",
            "translate",
            "test_len",
            "lstrip",
            "test_replace_compiled_regex",
            "test_extractall_no_matches",
            "test_match_findall_flags",
            "str_pad",
            "_make_accessor",
            "str_count",
            "test_lower_upper",
            "test_str_cat_special_cases",
            "str_rsplit",
            "test_casemethods",
            "test_pipe_failures",
            "rjust",
            "test_iter",
            "rindex",
            "test_join",
            "str_slice",
            "test_strip_lstrip_rstrip_unicode",
            "test_get",
            "str_slice_replace",
            "test_encode_decode",
            "test_cat_on_filtered_index",
            "test_str_cat_categorical",
            "__getitem__",
            "test_capitalize",
            "test_split_no_pat_with_nonzero_n",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "test_extractall",
            "get_dummies",
            "test_extract_expand_unspecified",
            "test_rsplit_to_multiindex_expand",
            "test_extractall_same_as_extract_subject_index",
            "contains",
            "test_str_cat_raises_intuitive_error",
            "test_str_cat",
            "test_pad",
            "test_method_on_bytes",
            "test_more_replace",
            "test_match",
            "test_split_blank_string",
            "match",
            "test_contains",
            "test_extract_expand_True",
            "wrap",
            "test_contains_nan",
            "str_extract",
            "str_translate",
            "test_center_ljust_rjust_fillchar",
            "test_pad_width",
            "_noarg_wrapper",
            "test_rsplit",
            "test_more_contains",
            "test_extractall_single_group_with_quantifier",
            "test_empty_str_methods_to_frame",
            "test_swapcase",
            "test_replace_literal",
            "test_str_cat_raises",
            "test_strip_lstrip_rstrip_mixed",
            "test_iter_single_element",
            "test_translate",
            "partition",
            "test_wrap",
            "test_str_cat_align_mixed_inputs",
            "test_get_dummies",
            "_na_map",
            "test_title",
            "test_extract_index_one_two_groups",
            "test_str_cat_name",
            "test_center_ljust_rjust",
            "test_replace",
            "cat_core",
            "test_count",
            "test_index_str_accessor_visibility",
            "_validate",
            "test_split_noargs",
            "test_get_complex",
            "test_pad_fillchar",
            "zfill",
            "test_extract_series",
            "test_zfill",
            "test_extract_optional_groups",
            "_groups_or_na_fun",
            "test_find_nan",
            "str_replace",
            "str_join",
            "str_decode",
            "test_split_to_multiindex_expand",
            "test_replace_callable",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "test_iter_object_try_string",
            "test_strip_lstrip_rstrip_args_unicode",
            "test_empty_str_methods",
            "test_str_accessor_no_new_attributes",
            "test_encode_decode_errors",
            "test_partition_to_dataframe",
            "test_split",
            "test_split_maxsplit",
            "normalize",
            "test_partition_series",
            "test_strip_lstrip_rstrip",
            "str_find",
            "_map",
            "test_extract_single_group_returns_frame",
            "test_repeat",
            "slice_replace",
            "test_api",
            "rpartition",
            "decode",
            "test_rsplit_to_dataframe_expand",
            "ljust",
            "encode",
            "test_endswith",
            "test_slice",
            "test_split_with_name",
            "assert_series_or_index_equal",
            "test_slice_replace",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "test_partition_with_name",
            "test_str_cat_align_indexed",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "test_iter_empty",
            "test_extractall_errors",
            "center",
            "find",
            "test_ismethods",
            "test_string_slice_out_of_bounds",
            "str_repeat",
            "test_split_nan_expand",
            "test_extract_expand_False",
            "test_normalize",
            "__iter__",
            "test_extractall_stringindex",
            "test_find",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "test_get_complex_nested",
            "test_findall",
            "get",
            "test_string_slice_get_syntax",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "test_isnumeric",
            "str_split",
            "_get_series_list",
            "join",
            "test_str_cat_mixed_inputs",
            "str_wrap",
            "test_split_to_dataframe",
            "test_partition_index",
            "str_match",
            "test_index",
            "cat",
            "test_startswith"
          ],
          "functions_name_co_evolved_modified_file": [],
          "functions_name_co_evolved_all_files": [
            "test_str_cat_mixed_inputs"
          ]
        },
        "file": {
          "file_name": "strings.py",
          "file_nloc": 1784,
          "file_complexity": 288,
          "file_token_count": 7477,
          "file_before": "# -*- coding: utf-8 -*-\nimport numpy as np\n\nfrom pandas.compat import zip\nfrom pandas.core.dtypes.generic import ABCSeries, ABCIndex\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_object_dtype,\n    is_string_like,\n    is_list_like,\n    is_scalar,\n    is_integer,\n    is_re)\n\nimport pandas.core.common as com\nfrom pandas.core.algorithms import take_1d\nimport pandas.compat as compat\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.util._decorators import Appender\nimport re\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nimport warnings\nimport textwrap\nimport codecs\n\n_cpython_optimized_encoders = (\n    \"utf-8\", \"utf8\", \"latin-1\", \"latin1\", \"iso-8859-1\", \"mbcs\", \"ascii\"\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\n    \"utf-16\", \"utf-32\"\n)\n\n_shared_docs = dict()\n\n\ndef cat_core(list_of_columns, sep):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            if compat.PY2:\n                p_err = r'takes (no|(exactly|at (least|most)) ?\\d+) arguments?'\n            else:\n                p_err = (r'((takes)|(missing)) (?(2)from \\d+ to )?\\d+ '\n                         r'(?(3)required )positional arguments?')\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    counts : Series or Index\n        Same type as the calling object containing the integer counts.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : analogous, but stricter, relying on re.match instead of re.search\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40','40.0','41','41.0','35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\"This pattern has match groups. To actually get the\"\n                          \" groups, use str.extract.\", UserWarning,\n                          stacklevel=3)\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : string or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : string or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start\n    case : boolean, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : boolean, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\"case and flags cannot be set\"\n                                 \" when pat is a compiled regex\")\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\"Cannot use a compiled regex as replacement \"\n                             \"pattern with regex=False\")\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \"\n                             \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    \"\"\"\n    if is_scalar(repeats):\n        def rep(x):\n            try:\n                return compat.binary_type.__mul__(x, repeats)\n            except TypeError:\n                return compat.text_type.__mul__(x, repeats)\n\n        return _na_map(rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return compat.binary_type.__mul__(x, r)\n            except TypeError:\n                return compat.text_type.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : analogous, but less strict, relying on re.search instead of\n        re.match\n    extract : extract matched groups\n\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, compat.string_types):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, Index\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, Index):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object)\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object)\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n        .. versionadded:: 0.18.0\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : returns all matches (not just the first match)\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : returns first match only (not all matches)\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.iteritems():\n        if isinstance(subject, compat.string_types):\n\n            if not is_mi:\n                subject_key = (subject_key, )\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, compat.string_types):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group\n                            for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i, ))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n    index = MultiIndex.from_tuples(\n        index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index,\n                                        columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep='|'):\n    \"\"\"\n    Split each string in the Series by sep and return a frame of\n    dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : string, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    dummies : DataFrame\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n\n    See Also\n    --------\n    pandas.get_dummies\n    \"\"\"\n    arr = arr.fillna('')\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    -------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Pattern or regular expression.\n    flags : int, default 0\n        ``re`` module flags, e.g. `re.IGNORECASE` (default is 0, which means\n        no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side='left'):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``\n\n    Returns\n    -------\n    found : Series/Index of integer values\n    \"\"\"\n\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'find'\n    elif side == 'right':\n        method = 'rfind'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side='left'):\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'index'\n    elif side == 'right':\n        method = 'rindex'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side='left', fillchar=' '):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust: Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust: Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center: Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill:  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, compat.string_types):\n        msg = 'fillchar must be a character, not {0}'\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError('fillchar must be a character, not str')\n\n    if not is_integer(width):\n        msg = 'width must be of integer type, not {0}'\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == 'left':\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == 'right':\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == 'both':\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    replaced : Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = ''\n\n    def f(x):\n        if x[start:stop] == '':\n            local_stop = start\n        else:\n            local_stop = stop\n        y = ''\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side='both'):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\"\n    if side == 'both':\n        f = lambda x: x.strip(to_strip)\n    elif side == 'left':\n        f = lambda x: x.lstrip(to_strip)\n    elif side == 'right':\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line-width\n    expand_tabs : bool, optional\n        If true, tab characters will be expanded to spaces (default: True)\n    replace_whitespace : bool, optional\n        If true, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True)\n    drop_whitespace : bool, optional\n        If true, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True)\n    break_long_words : bool, optional\n        If true, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width. (default: True)\n    break_on_hyphens : bool, optional\n        If true, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words. (default: True)\n\n    Returns\n    -------\n    wrapped : Series/Index of objects\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    \"\"\"\n    kwargs['width'] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: '\\n'.join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table, deletechars=None):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`. Note that the optional\n    argument deletechars is only valid if you are using python 2. For python 3,\n    character deletion should be specified via the table argument.\n\n    Parameters\n    ----------\n    table : dict (python 3), str or None (python 2)\n        In python 3, table is a mapping of Unicode ordinals to Unicode\n        ordinals, strings, or None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n        In python 2, table is either a string of length 256 or None. If the\n        table argument is None, no translation is applied and the operation\n        simply removes the characters in deletechars. :func:`string.maketrans`\n        is a helper function for making translation tables.\n    deletechars : str, optional (python 2)\n        A string of characters to delete. This argument is only valid\n        in python 2.\n\n    Returns\n    -------\n    translated : Series/Index of objects\n    \"\"\"\n    if deletechars is None:\n        f = lambda x: x.translate(table)\n    else:\n        if compat.PY3:\n            raise ValueError(\"deletechars is not a valid argument for \"\n                             \"str.translate in python 3. You should simply \"\n                             \"specify character deletions in the table \"\n                             \"argument\")\n        f = lambda x: x.translate(table, deletechars)\n    return _na_map(f, arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    items : Series/Index of objects\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n               (1, 2, 3),\n               [\"a\", \"b\", \"c\"],\n               123, -456,\n               {1:\"Hello\", \"2\":\"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    NaN\n    dtype: object\n    \"\"\"\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    decoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef _noarg_wrapper(f, docstring=None, **kargs):\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError('Provide docstring')\n\n    return wrapper\n\n\ndef _pat_wrapper(f, flags=False, na=False, **kwargs):\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result)\n\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        from pandas.core.index import Index\n\n        if (isinstance(data, ABCSeries) and\n                not ((is_categorical_dtype(data.dtype) and\n                      is_object_dtype(data.values.categories)) or\n                     (is_object_dtype(data.dtype)))):\n            # it's neither a string series not a categorical series with\n            # strings inside the categories.\n            # this really should exclude all series with any non-string values\n            # (instead of test for object dtype), but that isn't practical for\n            # performance reasons until we have a str dtype (GH 9343)\n            raise AttributeError(\"Can only use .str accessor with string \"\n                                 \"values, which use np.object_ dtype in \"\n                                 \"pandas\")\n        elif isinstance(data, Index):\n            # can't use ABCIndex to exclude non-str\n\n            # see src/inference.pyx which can contain string values\n            allowed_types = ('string', 'unicode', 'mixed', 'mixed-integer')\n            if is_categorical_dtype(data.dtype):\n                inf_type = data.categories.inferred_type\n            else:\n                inf_type = data.inferred_type\n            if inf_type not in allowed_types:\n                message = (\"Can only use .str accessor with string values \"\n                           \"(i.e. inferred_type is 'string', 'unicode' or \"\n                           \"'mixed')\")\n                raise AttributeError(message)\n            if data.nlevels > 1:\n                message = (\"Can only use .str accessor with Index, not \"\n                           \"MultiIndex\")\n                raise AttributeError(message)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(self, result, use_codes=True,\n                     name=None, expand=None):\n\n        from pandas.core.index import Index, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            result = take_1d(result, self._orig.cat.codes)\n\n        if not hasattr(result, 'ndim') or not hasattr(result, 'dtype'):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = False if result.ndim == 1 else True\n\n        elif expand is True and not isinstance(self._orig, Index):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [x * max_len if len(x) == 0 or x[0] is np.nan\n                          else x for x in result]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, 'name', None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, Index):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # Once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Index, Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n\n        err_msg = ('others must be Series, Index, DataFrame, np.ndarrary or '\n                   'list-like (either containing only strings or containing '\n                   'only objects of type Series/Index/list-like/np.ndarray)')\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n        # index, *unless* ignore_index is set to True.\n        if isinstance(others, Series):\n            warn = not others.index.equals(idx)\n            # only reconstruct Series when absolutely necessary\n            los = [Series(others.values, index=idx)\n                   if ignore_index and warn else others]\n            return (los, warn)\n        elif isinstance(others, Index):\n            warn = not others.equals(idx)\n            los = [Series(others.values,\n                          index=(idx if ignore_index else others))]\n            return (los, warn)\n        elif isinstance(others, DataFrame):\n            warn = not others.index.equals(idx)\n            if ignore_index and warn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], warn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either one-dimensional list-likes or scalars\n            if all(is_list_like(x) for x in others):\n                los = []\n                join_warn = False\n                depr_warn = False\n                # iterate through list and append list of series for each\n                # element (which we check to be one-dimensional and non-nested)\n                while others:\n                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n\n                    # GH 21950 - DeprecationWarning\n                    # only allowing Series/Index/np.ndarray[1-dim] will greatly\n                    # simply this function post-deprecation.\n                    if not (isinstance(nxt, (Series, Index)) or\n                            (isinstance(nxt, np.ndarray) and nxt.ndim == 1)):\n                        depr_warn = True\n\n                    if not isinstance(nxt, (DataFrame, Series,\n                                            Index, np.ndarray)):\n                        # safety for non-persistent list-likes (e.g. iterators)\n                        # do not map indexed/typed objects; info needed below\n                        nxt = list(nxt)\n\n                    # known types for which we can avoid deep inspection\n                    no_deep = ((isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                               or isinstance(nxt, (Series, Index)))\n                    # nested list-likes are forbidden:\n                    # -> elements of nxt must not be list-like\n                    is_legal = ((no_deep and nxt.dtype == object)\n                                or all(not is_list_like(x) for x in nxt))\n\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, wnx = self._get_series_list(nxt,\n                                                     ignore_index=ignore_index)\n                    los = los + nxt\n                    join_warn = join_warn or wnx\n\n                if depr_warn:\n                    warnings.warn('list-likes other than Series, Index, or '\n                                  'np.ndarray WITHIN another list-like are '\n                                  'deprecated and will be removed in a future '\n                                  'version.', FutureWarning, stacklevel=3)\n                return (los, join_warn)\n            elif all(not is_list_like(x) for x in others):\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarrary or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : string or None, default None\n            If None, concatenates without any separator.\n        na_rep : string or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        concat : str or Series/Index of objects\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index\n        join : Join lists contained as elements in the Series/Index\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join=None, na_rep='-')\n        0    ad\n        1    ba\n        2    -e\n        3    dc\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, compat.string_types):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = ''\n\n        if isinstance(self._orig, Index):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, warn = self._get_series_list(others,\n                                                 ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError('All arrays must be same length, except '\n                                 'those having an index if `join` is not None')\n            else:\n                raise ValueError('If `others` contains arrays or lists (or '\n                                 'other list-likes without an index), these '\n                                 'must all be of the same length as the '\n                                 'calling Series/Index.')\n\n        if join is None and warn:\n            warnings.warn(\"A future version of pandas will perform index \"\n                          \"alignment when `others` is a Series/Index/\"\n                          \"DataFrame (or a list-like containing one). To \"\n                          \"disable alignment (the behavior before v.0.23) and \"\n                          \"silence this warning, use `.values` on any Series/\"\n                          \"Index/DataFrame in `others`. To enable alignment \"\n                          \"and silence this warning, pass `join='left'|\"\n                          \"'outer'|'inner'|'right'`. The future default will \"\n                          \"be `join='left'`.\", FutureWarning, stacklevel=2)\n\n        # if join is None, _get_series_list already force-aligned indexes\n        join = 'left' if join is None else join\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(others, axis=1,\n                            join=(join if join == 'inner' else 'outer'),\n                            keys=range(len(others)), copy=False)\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_core([x[not_masked] for x in all_cols],\n                                          sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [np.where(nm, na_rep, col)\n                        for nm, col in zip(na_masks, all_cols)]\n            result = cat_core(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_core(all_cols, sep)\n\n        if isinstance(self._orig, Index):\n            result = Index(result, name=self._orig.name)\n        else:  # Series\n            result = Series(result, index=data.index, name=self._orig.name)\n        return result\n\n    _shared_docs['str_split'] = (\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n     Series.str.split : Split strings around given separator/delimiter.\n     Series.str.rsplit : Splits string around given separator/delimiter,\n     starting from the right.\n     Series.str.join : Join lists contained as elements in the Series/Index\n     with passed delimiter.\n     str.split : Standard library version for split.\n     str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    \"https://docs.python.org/3/tutorial/index.html\", np.nan])\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n    \"\"\")\n\n    @Appender(_shared_docs['str_split'] % {\n        'side': 'beginning',\n        'method': 'split'})\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_split'] % {\n        'side': 'end',\n        'method': 'rsplit'})\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs['str_partition'] = (\"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    pat : str, default whitespace\n        String to split on.\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containining tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex(levels=[['X', 'Y'], [' '], ['123', '999']],\n               labels=[[0, 1], [0, 0], [0, 1]])\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\")\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'first',\n        'return': '3 elements containing the string itself, followed by two '\n                  'empty strings',\n        'also': 'rpartition : Split the string at the last occurrence of `sep`'\n    })\n    def partition(self, pat=' ', expand=True):\n        f = lambda x: x.partition(pat)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'last',\n        'return': '3 elements containing two empty strings, followed by the '\n                  'string itself',\n        'also': 'partition : Split the string at the first occurrence of `sep`'\n    })\n    def rpartition(self, pat=' ', expand=True):\n        f = lambda x: x.rpartition(pat)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(self._parent, pat, case=case, flags=flags, na=na,\n                              regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_match)\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result)\n\n    @copy(str_replace)\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(self._parent, pat, repl, n=n, case=case,\n                             flags=flags, regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    def pad(self, width, side='left', fillchar=' '):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs['str_pad'] = (\"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left and right',\n                                             method='center'))\n    def center(self, width, fillchar=' '):\n        return self.pad(width, side='both', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='right', method='ljust'))\n    def ljust(self, width, fillchar=' '):\n        return self.pad(width, side='right', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left', method='rjust'))\n    def rjust(self, width, fillchar=' '):\n        return self.pad(width, side='left', fillchar=fillchar)\n\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects\n\n        See Also\n        --------\n        Series.str.rjust: Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust: Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad: Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center: Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side='left', fillchar='0')\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        result = str_decode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs['str_strip'] = (r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None.\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index\n    Series.str.lstrip : Remove leading characters in Series/Index\n    Series.str.rstrip : Remove trailing characters in Series/Index\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\")\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left and right sides',\n                                               method='strip'))\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side='both')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left side',\n                                               method='lstrip'))\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='right side',\n                                               method='rstrip'))\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side='right')\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    def get_dummies(self, sep='|'):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(result, use_codes=(not self._is_categorical),\n                                 name=name, expand=True)\n\n    @copy(str_translate)\n    def translate(self, table, deletechars=None):\n        result = str_translate(self._parent, table, deletechars)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True)\n    startswith = _pat_wrapper(str_startswith, na=True)\n    endswith = _pat_wrapper(str_endswith, na=True)\n    findall = _pat_wrapper(str_findall, flags=True)\n\n    @copy(str_extract)\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs['find'] = (\"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['find'] %\n              dict(side='lowest', method='find',\n                   also='rfind : Return highest indexes in each strings'))\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['find'] %\n              dict(side='highest', method='rfind',\n                   also='find : Return lowest indexes in each strings'))\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub,\n                          start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    def normalize(self, form):\n        \"\"\"Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n        f = lambda x: unicodedata.normalize(form, compat.u_safe(x))\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs['index'] = (\"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['index'] %\n              dict(side='lowest', similar='find', method='index',\n                   also='rindex : Return highest indexes in each strings'))\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub,\n                           start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['index'] %\n              dict(side='highest', similar='rfind', method='rindex',\n                   also='index : Return lowest indexes in each strings'))\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub,\n                           start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    _shared_docs['len'] = (\"\"\"\n    Computes the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\")\n    len = _noarg_wrapper(len, docstring=_shared_docs['len'], dtype=int)\n\n    _shared_docs['casemethods'] = (\"\"\"\n    Convert strings in the Series/Index to %(type)s.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\")\n    _shared_docs['lower'] = dict(type='lowercase', method='lower')\n    _shared_docs['upper'] = dict(type='uppercase', method='upper')\n    _shared_docs['title'] = dict(type='titlecase', method='title')\n    _shared_docs['capitalize'] = dict(type='be capitalized',\n                                      method='capitalize')\n    _shared_docs['swapcase'] = dict(type='be swapcased', method='swapcase')\n    lower = _noarg_wrapper(lambda x: x.lower(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['lower'])\n    upper = _noarg_wrapper(lambda x: x.upper(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['upper'])\n    title = _noarg_wrapper(lambda x: x.title(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['title'])\n    capitalize = _noarg_wrapper(lambda x: x.capitalize(),\n                                docstring=_shared_docs['casemethods'] %\n                                _shared_docs['capitalize'])\n    swapcase = _noarg_wrapper(lambda x: x.swapcase(),\n                              docstring=_shared_docs['casemethods'] %\n                              _shared_docs['swapcase'])\n\n    _shared_docs['ismethods'] = (\"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters seperated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\")\n    _shared_docs['isalnum'] = dict(type='alphanumeric', method='isalnum')\n    _shared_docs['isalpha'] = dict(type='alphabetic', method='isalpha')\n    _shared_docs['isdigit'] = dict(type='digits', method='isdigit')\n    _shared_docs['isspace'] = dict(type='whitespace', method='isspace')\n    _shared_docs['islower'] = dict(type='lowercase', method='islower')\n    _shared_docs['isupper'] = dict(type='uppercase', method='isupper')\n    _shared_docs['istitle'] = dict(type='titlecase', method='istitle')\n    _shared_docs['isnumeric'] = dict(type='numeric', method='isnumeric')\n    _shared_docs['isdecimal'] = dict(type='decimal', method='isdecimal')\n    isalnum = _noarg_wrapper(lambda x: x.isalnum(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalnum'])\n    isalpha = _noarg_wrapper(lambda x: x.isalpha(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalpha'])\n    isdigit = _noarg_wrapper(lambda x: x.isdigit(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isdigit'])\n    isspace = _noarg_wrapper(lambda x: x.isspace(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isspace'])\n    islower = _noarg_wrapper(lambda x: x.islower(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['islower'])\n    isupper = _noarg_wrapper(lambda x: x.isupper(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isupper'])\n    istitle = _noarg_wrapper(lambda x: x.istitle(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['istitle'])\n    isnumeric = _noarg_wrapper(lambda x: compat.u_safe(x).isnumeric(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isnumeric'])\n    isdecimal = _noarg_wrapper(lambda x: compat.u_safe(x).isdecimal(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isdecimal'])\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_after": "# -*- coding: utf-8 -*-\nimport numpy as np\n\nfrom pandas.compat import zip\nfrom pandas.core.dtypes.generic import ABCSeries, ABCIndex\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.common import (\n    ensure_object,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_object_dtype,\n    is_string_like,\n    is_list_like,\n    is_scalar,\n    is_integer,\n    is_re)\n\nimport pandas.core.common as com\nfrom pandas.core.algorithms import take_1d\nimport pandas.compat as compat\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.util._decorators import Appender\nimport re\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nimport warnings\nimport textwrap\nimport codecs\n\n_cpython_optimized_encoders = (\n    \"utf-8\", \"utf8\", \"latin-1\", \"latin1\", \"iso-8859-1\", \"mbcs\", \"ascii\"\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\n    \"utf-16\", \"utf-32\"\n)\n\n_shared_docs = dict()\n\n\ndef cat_core(list_of_columns, sep):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    Parameters\n    ----------\n    list_of_columns : list of numpy arrays\n        List of arrays to be concatenated with sep;\n        these arrays may not contain NaNs!\n    sep : string\n        The separator string for concatenating the columns\n\n    Returns\n    -------\n    nd.array\n        The concatenation of list_of_columns with sep\n    \"\"\"\n    list_with_sep = [sep] * (2 * len(list_of_columns) - 1)\n    list_with_sep[::2] = list_of_columns\n    return np.sum(list_with_sep, axis=0)\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            if compat.PY2:\n                p_err = r'takes (no|(exactly|at (least|most)) ?\\d+) arguments?'\n            else:\n                p_err = (r'((takes)|(missing)) (?(2)from \\d+ to )?\\d+ '\n                         r'(?(3)required )positional arguments?')\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatibility with other string methods. Not used.\n\n    Returns\n    -------\n    counts : Series or Index\n        Same type as the calling object containing the integer counts.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Test if pattern or regex is contained within a string of a Series or Index.\n\n    Return boolean Series or Index based on whether a given pattern or regex is\n    contained within a string of a Series or Index.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence or regular expression.\n    case : bool, default True\n        If True, case sensitive.\n    flags : int, default 0 (no flags)\n        Flags to pass through to the re module, e.g. re.IGNORECASE.\n    na : default NaN\n        Fill value for missing values.\n    regex : bool, default True\n        If True, assumes the pat is a regular expression.\n\n        If False, treats the pat as a literal string.\n\n    Returns\n    -------\n    Series or Index of boolean values\n        A Series or Index of boolean values indicating whether the\n        given pattern is contained within the string of each element\n        of the Series or Index.\n\n    See Also\n    --------\n    match : analogous, but stricter, relying on re.match instead of re.search\n    Series.str.startswith : Test if the start of each string element matches a\n        pattern.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n\n    Examples\n    --------\n\n    Returning a Series of booleans using only a literal pattern.\n\n    >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])\n    >>> s1.str.contains('og', regex=False)\n    0    False\n    1     True\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning an Index of booleans using only a literal pattern.\n\n    >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])\n    >>> ind.str.contains('23', regex=False)\n    Index([False, False, False, True, nan], dtype='object')\n\n    Specifying case sensitivity using `case`.\n\n    >>> s1.str.contains('oG', case=True, regex=True)\n    0    False\n    1    False\n    2    False\n    3    False\n    4      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN` replaces NaN values\n    with `False`. If Series or Index does not contain NaN values\n    the resultant dtype will be `bool`, otherwise, an `object` dtype.\n\n    >>> s1.str.contains('og', na=False, regex=True)\n    0    False\n    1     True\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    Returning 'house' or 'dog' when either expression occurs in a string.\n\n    >>> s1.str.contains('house|dog', regex=True)\n    0    False\n    1     True\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Ignoring case sensitivity using `flags` with regex.\n\n    >>> import re\n    >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)\n    0    False\n    1    False\n    2     True\n    3    False\n    4      NaN\n    dtype: object\n\n    Returning any digit using regular expression.\n\n    >>> s1.str.contains('\\\\d', regex=True)\n    0    False\n    1    False\n    2    False\n    3     True\n    4      NaN\n    dtype: object\n\n    Ensure `pat` is a not a literal pattern when `regex` is set to True.\n    Note in the following example one might expect only `s2[1]` and `s2[3]` to\n    return `True`. However, '.0' as a regex matches any character\n    followed by a 0.\n\n    >>> s2 = pd.Series(['40','40.0','41','41.0','35'])\n    >>> s2.str.contains('.0', regex=True)\n    0     True\n    1     True\n    2    False\n    3     True\n    4    False\n    dtype: bool\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\"This pattern has match groups. To actually get the\"\n                          \" groups, use str.extract.\", UserWarning,\n                          stacklevel=3)\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : string or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : string or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start\n    case : boolean, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : boolean, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Series or Index of object\n        A copy of the object with all matching occurrences of `pat` replaced by\n        `repl`.\n\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\"case and flags cannot be set\"\n                                 \" when pat is a compiled regex\")\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\"Cannot use a compiled regex as replacement \"\n                             \"pattern with regex=False\")\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \"\n                             \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series or Index.\n\n    Parameters\n    ----------\n    repeats : int or sequence of int\n        Same value for all (int) or different value per (sequence).\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index of repeated string objects specified by\n        input parameter repeats.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n\n    Single int repeats string in Series\n\n    >>> s.str.repeat(repeats=2)\n    0    aa\n    1    bb\n    2    cc\n\n    Sequence of int repeats corresponding string in Series\n\n    >>> s.str.repeat(repeats=[1, 2, 3])\n    0      a\n    1     bb\n    2    ccc\n    \"\"\"\n    if is_scalar(repeats):\n        def rep(x):\n            try:\n                return compat.binary_type.__mul__(x, repeats)\n            except TypeError:\n                return compat.text_type.__mul__(x, repeats)\n\n        return _na_map(rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return compat.binary_type.__mul__(x, r)\n            except TypeError:\n                return compat.text_type.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com.values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : analogous, but less strict, relying on re.search instead of\n        re.match\n    extract : extract matched groups\n\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, compat.string_types):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, Index\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, Index):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object)\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object)\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    Extract capture groups in the regex `pat` as columns in a DataFrame.\n\n    For each subject string in the Series, extract groups from the\n    first match of regular expression `pat`.\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that\n        modify regular expression matching for things like case,\n        spaces, etc. For more details, see :mod:`re`.\n    expand : bool, default True\n        If True, return DataFrame with one column per capture group.\n        If False, return a Series/Index if there is one capture group\n        or DataFrame if there are multiple capture groups.\n\n        .. versionadded:: 0.18.0\n\n    Returns\n    -------\n    DataFrame or Series or Index\n        A DataFrame with one row for each subject string, and one\n        column for each group. Any capture group names in regular\n        expression pat will be used for column names; otherwise\n        capture group numbers will be used. The dtype of each result\n        column is always object, even when no match is found. If\n        ``expand=False`` and pat has only one capture group, then\n        return a Series (if subject is a Series) or Index (if subject\n        is an Index).\n\n    See Also\n    --------\n    extractall : returns all matches (not just the first match)\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = pd.Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._parent, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : str\n        Regular expression pattern with capturing groups.\n    flags : int, default 0 (no flags)\n        A ``re`` module flag, for example ``re.IGNORECASE``. These allow\n        to modify regular expression matching for things like case, spaces,\n        etc. Multiple flags can be combined with the bitwise OR operator,\n        for example ``re.IGNORECASE | re.MULTILINE``.\n\n    Returns\n    -------\n    DataFrame\n        A ``DataFrame`` with one row for each match, and one column for each\n        group. Its rows have a ``MultiIndex`` with first levels that come from\n        the subject ``Series``. The last level is named 'match' and indexes the\n        matches in each item of the ``Series``. Any capture group names in\n        regular expression pat will be used for column names; otherwise capture\n        group numbers will be used.\n\n    See Also\n    --------\n    extract : returns first match only (not all matches)\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = pd.Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.iteritems():\n        if isinstance(subject, compat.string_types):\n\n            if not is_mi:\n                subject_key = (subject_key, )\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, compat.string_types):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group\n                            for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i, ))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n    index = MultiIndex.from_tuples(\n        index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index,\n                                        columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep='|'):\n    \"\"\"\n    Split each string in the Series by sep and return a frame of\n    dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : string, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    dummies : DataFrame\n\n    Examples\n    --------\n    >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n\n    See Also\n    --------\n    pandas.get_dummies\n    \"\"\"\n    arr = arr.fillna('')\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - {\"\"})\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n        The list entries concatenated by intervening occurrences of the\n        delimiter.\n\n    Raises\n    -------\n    AttributeError\n        If the supplied Series contains neither strings nor lists.\n\n    Notes\n    -----\n    If any of the list items is not a string object, the result of the join\n    will be `NaN`.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Examples\n    --------\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat'],\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using a '-'. The lists containing object(s) of types other\n    than str will produce a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Pattern or regular expression.\n    flags : int, default 0\n        ``re`` module flags, e.g. `re.IGNORECASE` (default is 0, which means\n        no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side='left'):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``\n\n    Returns\n    -------\n    found : Series/Index of integer values\n    \"\"\"\n\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'find'\n    elif side == 'right':\n        method = 'rfind'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side='left'):\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'index'\n    elif side == 'right':\n        method = 'rindex'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side='left', fillchar=' '):\n    \"\"\"\n    Pad strings in the Series/Index up to width.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with character defined in `fillchar`.\n    side : {'left', 'right', 'both'}, default 'left'\n        Side from which to fill resulting string.\n    fillchar : str, default ' '\n        Additional character for filling, default is whitespace.\n\n    Returns\n    -------\n    Series or Index of object\n        Returns Series or Index with minimum number of char in object.\n\n    See Also\n    --------\n    Series.str.rjust: Fills the left side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='left')``.\n    Series.str.ljust: Fills the right side of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='right')``.\n    Series.str.center: Fills boths sides of strings with an arbitrary\n        character. Equivalent to ``Series.str.pad(side='both')``.\n    Series.str.zfill:  Pad strings in the Series/Index by prepending '0'\n        character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"caribou\", \"tiger\"])\n    >>> s\n    0    caribou\n    1      tiger\n    dtype: object\n\n    >>> s.str.pad(width=10)\n    0       caribou\n    1         tiger\n    dtype: object\n\n    >>> s.str.pad(width=10, side='right', fillchar='-')\n    0    caribou---\n    1    tiger-----\n    dtype: object\n\n    >>> s.str.pad(width=10, side='both', fillchar='-')\n    0    -caribou--\n    1    --tiger---\n    dtype: object\n    \"\"\"\n    if not isinstance(fillchar, compat.string_types):\n        msg = 'fillchar must be a character, not {0}'\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError('fillchar must be a character, not str')\n\n    if not is_integer(width):\n        msg = 'width must be of integer type, not {0}'\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == 'left':\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == 'right':\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == 'both':\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series or Index.\n\n    Parameters\n    ----------\n    start : int, optional\n        Start position for slice operation.\n    stop : int, optional\n        Stop position for slice operation.\n    step : int, optional\n        Step size for slice operation.\n\n    Returns\n    -------\n    Series or Index of object\n        Series or Index from sliced substring from original string object.\n\n    See Also\n    --------\n    Series.str.slice_replace : Replace a slice with a string.\n    Series.str.get : Return element at position.\n        Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\n        being the position.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"koala\", \"fox\", \"chameleon\"])\n    >>> s\n    0        koala\n    1          fox\n    2    chameleon\n    dtype: object\n\n    >>> s.str.slice(start=1)\n    0        oala\n    1          ox\n    2    hameleon\n    dtype: object\n\n    >>> s.str.slice(stop=2)\n    0    ko\n    1    fo\n    2    ch\n    dtype: object\n\n    >>> s.str.slice(step=2)\n    0      kaa\n    1       fx\n    2    caeen\n    dtype: object\n\n    >>> s.str.slice(start=0, stop=5, step=3)\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n\n    Equivalent behaviour to:\n\n    >>> s.str[0:5:3]\n    0    kl\n    1     f\n    2    cm\n    dtype: object\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    replaced : Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = ''\n\n    def f(x):\n        if x[start:stop] == '':\n            local_stop = start\n        else:\n            local_stop = stop\n        y = ''\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side='both'):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\"\n    if side == 'both':\n        f = lambda x: x.strip(to_strip)\n    elif side == 'left':\n        f = lambda x: x.lstrip(to_strip)\n    elif side == 'right':\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line-width\n    expand_tabs : bool, optional\n        If true, tab characters will be expanded to spaces (default: True)\n    replace_whitespace : bool, optional\n        If true, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True)\n    drop_whitespace : bool, optional\n        If true, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True)\n    break_long_words : bool, optional\n        If true, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width. (default: True)\n    break_on_hyphens : bool, optional\n        If true, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words. (default: True)\n\n    Returns\n    -------\n    wrapped : Series/Index of objects\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    \"\"\"\n    kwargs['width'] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: '\\n'.join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table, deletechars=None):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`. Note that the optional\n    argument deletechars is only valid if you are using python 2. For python 3,\n    character deletion should be specified via the table argument.\n\n    Parameters\n    ----------\n    table : dict (python 3), str or None (python 2)\n        In python 3, table is a mapping of Unicode ordinals to Unicode\n        ordinals, strings, or None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n        In python 2, table is either a string of length 256 or None. If the\n        table argument is None, no translation is applied and the operation\n        simply removes the characters in deletechars. :func:`string.maketrans`\n        is a helper function for making translation tables.\n    deletechars : str, optional (python 2)\n        A string of characters to delete. This argument is only valid\n        in python 2.\n\n    Returns\n    -------\n    translated : Series/Index of objects\n    \"\"\"\n    if deletechars is None:\n        f = lambda x: x.translate(table)\n    else:\n        if compat.PY3:\n            raise ValueError(\"deletechars is not a valid argument for \"\n                             \"str.translate in python 3. You should simply \"\n                             \"specify character deletions in the table \"\n                             \"argument\")\n        f = lambda x: x.translate(table, deletechars)\n    return _na_map(f, arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    items : Series/Index of objects\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n               (1, 2, 3),\n               [\"a\", \"b\", \"c\"],\n               123, -456,\n               {1:\"Hello\", \"2\":\"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    NaN\n    dtype: object\n    \"\"\"\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    decoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef _noarg_wrapper(f, docstring=None, **kargs):\n    def wrapper(self):\n        result = _na_map(f, self._parent, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError('Provide docstring')\n\n    return wrapper\n\n\ndef _pat_wrapper(f, flags=False, na=False, **kwargs):\n    def wrapper1(self, pat):\n        result = f(self._parent, pat)\n        return self._wrap_result(result)\n\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._parent, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._parent, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._parent = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        from pandas.core.index import Index\n\n        if (isinstance(data, ABCSeries) and\n                not ((is_categorical_dtype(data.dtype) and\n                      is_object_dtype(data.values.categories)) or\n                     (is_object_dtype(data.dtype)))):\n            # it's neither a string series not a categorical series with\n            # strings inside the categories.\n            # this really should exclude all series with any non-string values\n            # (instead of test for object dtype), but that isn't practical for\n            # performance reasons until we have a str dtype (GH 9343)\n            raise AttributeError(\"Can only use .str accessor with string \"\n                                 \"values, which use np.object_ dtype in \"\n                                 \"pandas\")\n        elif isinstance(data, Index):\n            # can't use ABCIndex to exclude non-str\n\n            # see src/inference.pyx which can contain string values\n            allowed_types = ('string', 'unicode', 'mixed', 'mixed-integer')\n            if is_categorical_dtype(data.dtype):\n                inf_type = data.categories.inferred_type\n            else:\n                inf_type = data.inferred_type\n            if inf_type not in allowed_types:\n                message = (\"Can only use .str accessor with string values \"\n                           \"(i.e. inferred_type is 'string', 'unicode' or \"\n                           \"'mixed')\")\n                raise AttributeError(message)\n            if data.nlevels > 1:\n                message = (\"Can only use .str accessor with Index, not \"\n                           \"MultiIndex\")\n                raise AttributeError(message)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(self, result, use_codes=True,\n                     name=None, expand=None):\n\n        from pandas.core.index import Index, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            result = take_1d(result, self._orig.cat.codes)\n\n        if not hasattr(result, 'ndim') or not hasattr(result, 'dtype'):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = False if result.ndim == 1 else True\n\n        elif expand is True and not isinstance(self._orig, Index):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [x * max_len if len(x) == 0 or x[0] is np.nan\n                          else x for x in result]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, 'name', None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, Index):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarray, list-like or list-like\n            of objects that are Series, Index or np.ndarray (1-dim)\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # Once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Index, Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n\n        err_msg = ('others must be Series, Index, DataFrame, np.ndarrary or '\n                   'list-like (either containing only strings or containing '\n                   'only objects of type Series/Index/list-like/np.ndarray)')\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n        # index, *unless* ignore_index is set to True.\n        if isinstance(others, Series):\n            warn = not others.index.equals(idx)\n            # only reconstruct Series when absolutely necessary\n            los = [Series(others.values, index=idx)\n                   if ignore_index and warn else others]\n            return (los, warn)\n        elif isinstance(others, Index):\n            warn = not others.equals(idx)\n            los = [Series(others.values,\n                          index=(idx if ignore_index else others))]\n            return (los, warn)\n        elif isinstance(others, DataFrame):\n            warn = not others.index.equals(idx)\n            if ignore_index and warn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], warn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others, allow_sets=False):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either one-dimensional list-likes or scalars\n            if all(is_list_like(x, allow_sets=False) for x in others):\n                los = []\n                join_warn = False\n                depr_warn = False\n                # iterate through list and append list of series for each\n                # element (which we check to be one-dimensional and non-nested)\n                while others:\n                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n\n                    # GH 21950 - DeprecationWarning\n                    # only allowing Series/Index/np.ndarray[1-dim] will greatly\n                    # simply this function post-deprecation.\n                    if not (isinstance(nxt, (Series, Index)) or\n                            (isinstance(nxt, np.ndarray) and nxt.ndim == 1)):\n                        depr_warn = True\n\n                    if not isinstance(nxt, (DataFrame, Series,\n                                            Index, np.ndarray)):\n                        # safety for non-persistent list-likes (e.g. iterators)\n                        # do not map indexed/typed objects; info needed below\n                        nxt = list(nxt)\n\n                    # known types for which we can avoid deep inspection\n                    no_deep = ((isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                               or isinstance(nxt, (Series, Index)))\n                    # nested list-likes are forbidden:\n                    # -> elements of nxt must not be list-like\n                    is_legal = ((no_deep and nxt.dtype == object)\n                                or all(not is_list_like(x) for x in nxt))\n\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, wnx = self._get_series_list(nxt,\n                                                     ignore_index=ignore_index)\n                    los = los + nxt\n                    join_warn = join_warn or wnx\n\n                if depr_warn:\n                    warnings.warn('list-likes other than Series, Index, or '\n                                  'np.ndarray WITHIN another list-like are '\n                                  'deprecated and will be removed in a future '\n                                  'version.', FutureWarning, stacklevel=3)\n                return (los, join_warn)\n            elif all(not is_list_like(x) for x in others):\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarrary or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            Index or np.ndarray (1-dim), then all elements will be unpacked and\n            must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : string or None, default None\n            If None, concatenates without any separator.\n        na_rep : string or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        concat : str or Series/Index of objects\n            If `others` is None, `str` is returned, otherwise a `Series/Index`\n            (same type as caller) of objects is returned.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index\n        join : Join lists contained as elements in the Series/Index\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join=None, na_rep='-')\n        0    ad\n        1    ba\n        2    -e\n        3    dc\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, compat.string_types):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n        if sep is None:\n            sep = ''\n\n        if isinstance(self._orig, Index):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            data = ensure_object(data)\n            na_mask = isna(data)\n            if na_rep is None and na_mask.any():\n                data = data[~na_mask]\n            elif na_rep is not None and na_mask.any():\n                data = np.where(na_mask, na_rep, data)\n            return sep.join(data)\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, warn = self._get_series_list(others,\n                                                 ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError('All arrays must be same length, except '\n                                 'those having an index if `join` is not None')\n            else:\n                raise ValueError('If `others` contains arrays or lists (or '\n                                 'other list-likes without an index), these '\n                                 'must all be of the same length as the '\n                                 'calling Series/Index.')\n\n        if join is None and warn:\n            warnings.warn(\"A future version of pandas will perform index \"\n                          \"alignment when `others` is a Series/Index/\"\n                          \"DataFrame (or a list-like containing one). To \"\n                          \"disable alignment (the behavior before v.0.23) and \"\n                          \"silence this warning, use `.values` on any Series/\"\n                          \"Index/DataFrame in `others`. To enable alignment \"\n                          \"and silence this warning, pass `join='left'|\"\n                          \"'outer'|'inner'|'right'`. The future default will \"\n                          \"be `join='left'`.\", FutureWarning, stacklevel=2)\n\n        # if join is None, _get_series_list already force-aligned indexes\n        join = 'left' if join is None else join\n\n        # align if required\n        if any(not data.index.equals(x.index) for x in others):\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(others, axis=1,\n                            join=(join if join == 'inner' else 'outer'),\n                            keys=range(len(others)), copy=False)\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        all_cols = [ensure_object(x) for x in [data] + others]\n        na_masks = np.array([isna(x) for x in all_cols])\n        union_mask = np.logical_or.reduce(na_masks, axis=0)\n\n        if na_rep is None and union_mask.any():\n            # no na_rep means NaNs for all rows where any column has a NaN\n            # only necessary if there are actually any NaNs\n            result = np.empty(len(data), dtype=object)\n            np.putmask(result, union_mask, np.nan)\n\n            not_masked = ~union_mask\n            result[not_masked] = cat_core([x[not_masked] for x in all_cols],\n                                          sep)\n        elif na_rep is not None and union_mask.any():\n            # fill NaNs with na_rep in case there are actually any NaNs\n            all_cols = [np.where(nm, na_rep, col)\n                        for nm, col in zip(na_masks, all_cols)]\n            result = cat_core(all_cols, sep)\n        else:\n            # no NaNs - can just concatenate\n            result = cat_core(all_cols, sep)\n\n        if isinstance(self._orig, Index):\n            result = Index(result, name=self._orig.name)\n        else:  # Series\n            result = Series(result, index=data.index, name=self._orig.name)\n        return result\n\n    _shared_docs['str_split'] = (\"\"\"\n    Split strings around given separator/delimiter.\n\n    Splits the string in the Series/Index from the %(side)s,\n    at the specified delimiter string. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    See Also\n    --------\n     Series.str.split : Split strings around given separator/delimiter.\n     Series.str.rsplit : Splits string around given separator/delimiter,\n     starting from the right.\n     Series.str.join : Join lists contained as elements in the Series/Index\n     with passed delimiter.\n     str.split : Standard library version for split.\n     str.rsplit : Standard library version for rsplit.\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is a regular sentence\",\n    \"https://docs.python.org/3/tutorial/index.html\", np.nan])\n\n    In the default setting, the string is split by whitespace.\n\n    >>> s.str.split()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    Without the `n` parameter, the outputs of `rsplit` and `split`\n    are identical.\n\n    >>> s.str.rsplit()\n    0                   [this, is, a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `n` parameter can be used to limit the number of splits on the\n    delimiter. The outputs of `split` and `rsplit` are different.\n\n    >>> s.str.split(n=2)\n    0                     [this, is, a regular sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    >>> s.str.rsplit(n=2)\n    0                     [this is a, regular, sentence]\n    1    [https://docs.python.org/3/tutorial/index.html]\n    2                                                NaN\n    dtype: object\n\n    The `pat` parameter can be used to split by other characters.\n\n    >>> s.str.split(pat = \"/\")\n    0                         [this is a regular sentence]\n    1    [https:, , docs.python.org, 3, tutorial, index...\n    2                                                  NaN\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns. If NaN is present, it is propagated throughout\n    the columns during the split.\n\n    >>> s.str.split(expand=True)\n                                                   0     1     2        3\n    0                                           this    is     a  regular\n    1  https://docs.python.org/3/tutorial/index.html  None  None     None\n    2                                            NaN   NaN   NaN      NaN \\\n\n                 4\n    0     sentence\n    1         None\n    2          NaN\n\n    For slightly more complex use cases like splitting the html document name\n    from a url, a combination of parameter settings can be used.\n\n    >>> s.str.rsplit(\"/\", n=1, expand=True)\n                                        0           1\n    0          this is a regular sentence        None\n    1  https://docs.python.org/3/tutorial  index.html\n    2                                 NaN         NaN\n    \"\"\")\n\n    @Appender(_shared_docs['str_split'] % {\n        'side': 'beginning',\n        'method': 'split'})\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_split'] % {\n        'side': 'end',\n        'method': 'rsplit'})\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._parent, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs['str_partition'] = (\"\"\"\n    Split the string at the %(side)s occurrence of `sep`.\n\n    This method splits the string at the %(side)s occurrence of `sep`,\n    and returns 3 elements containing the part before the separator,\n    the separator itself, and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    pat : str, default whitespace\n        String to split on.\n    expand : bool, default True\n        If True, return DataFrame/MultiIndex expanding dimensionality.\n        If False, return Series/Index.\n\n    Returns\n    -------\n    DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    Series.str.split : Split strings around given separators.\n    str.partition : Standard library version.\n\n    Examples\n    --------\n\n\n    >>> s = pd.Series(['Linda van der Berg', 'George Pitt-Rivers'])\n    >>> s\n    0    Linda van der Berg\n    1    George Pitt-Rivers\n    dtype: object\n\n    >>> s.str.partition()\n            0  1             2\n    0   Linda     van der Berg\n    1  George      Pitt-Rivers\n\n    To partition by the last space instead of the first one:\n\n    >>> s.str.rpartition()\n                   0  1            2\n    0  Linda van der            Berg\n    1         George     Pitt-Rivers\n\n    To partition by something different than a space:\n\n    >>> s.str.partition('-')\n                        0  1       2\n    0  Linda van der Berg\n    1         George Pitt  -  Rivers\n\n    To return a Series containining tuples instead of a DataFrame:\n\n    >>> s.str.partition('-', expand=False)\n    0    (Linda van der Berg, , )\n    1    (George Pitt, -, Rivers)\n    dtype: object\n\n    Also available on indices:\n\n    >>> idx = pd.Index(['X 123', 'Y 999'])\n    >>> idx\n    Index(['X 123', 'Y 999'], dtype='object')\n\n    Which will create a MultiIndex:\n\n    >>> idx.str.partition()\n    MultiIndex(levels=[['X', 'Y'], [' '], ['123', '999']],\n               labels=[[0, 1], [0, 0], [0, 1]])\n\n    Or an index with tuples with ``expand=False``:\n\n    >>> idx.str.partition(expand=False)\n    Index([('X', ' ', '123'), ('Y', ' ', '999')], dtype='object')\n    \"\"\")\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'first',\n        'return': '3 elements containing the string itself, followed by two '\n                  'empty strings',\n        'also': 'rpartition : Split the string at the last occurrence of `sep`'\n    })\n    def partition(self, pat=' ', expand=True):\n        f = lambda x: x.partition(pat)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'last',\n        'return': '3 elements containing two empty strings, followed by the '\n                  'string itself',\n        'also': 'partition : Split the string at the first occurrence of `sep`'\n    })\n    def rpartition(self, pat=' ', expand=True):\n        f = lambda x: x.rpartition(pat)\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._parent, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    def join(self, sep):\n        result = str_join(self._parent, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(self._parent, pat, case=case, flags=flags, na=na,\n                              regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_match)\n    def match(self, pat, case=True, flags=0, na=np.nan):\n        result = str_match(self._parent, pat, case=case, flags=flags, na=na)\n        return self._wrap_result(result)\n\n    @copy(str_replace)\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(self._parent, pat, repl, n=n, case=case,\n                             flags=flags, regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    def repeat(self, repeats):\n        result = str_repeat(self._parent, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    def pad(self, width, side='left', fillchar=' '):\n        result = str_pad(self._parent, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs['str_pad'] = (\"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left and right',\n                                             method='center'))\n    def center(self, width, fillchar=' '):\n        return self.pad(width, side='both', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='right', method='ljust'))\n    def ljust(self, width, fillchar=' '):\n        return self.pad(width, side='right', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left', method='rjust'))\n    def rjust(self, width, fillchar=' '):\n        return self.pad(width, side='left', fillchar=fillchar)\n\n    def zfill(self, width):\n        \"\"\"\n        Pad strings in the Series/Index by prepending '0' characters.\n\n        Strings in the Series/Index are padded with '0' characters on the\n        left of the string to reach a total string length  `width`. Strings\n        in the Series/Index with length greater or equal to `width` are\n        unchanged.\n\n        Parameters\n        ----------\n        width : int\n            Minimum length of resulting string; strings with length less\n            than `width` be prepended with '0' characters.\n\n        Returns\n        -------\n        Series/Index of objects\n\n        See Also\n        --------\n        Series.str.rjust: Fills the left side of strings with an arbitrary\n            character.\n        Series.str.ljust: Fills the right side of strings with an arbitrary\n            character.\n        Series.str.pad: Fills the specified sides of strings with an arbitrary\n            character.\n        Series.str.center: Fills boths sides of strings with an arbitrary\n            character.\n\n        Notes\n        -----\n        Differs from :meth:`str.zfill` which has special handling\n        for '+'/'-' in the string.\n\n        Examples\n        --------\n        >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])\n        >>> s\n        0      -1\n        1       1\n        2    1000\n        3      10\n        4     NaN\n        dtype: object\n\n        Note that ``10`` and ``NaN`` are not strings, therefore they are\n        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a\n        regular character and the zero is added to the left of it\n        (:meth:`str.zfill` would have moved it to the left). ``1000``\n        remains unchanged as it is longer than `width`.\n\n        >>> s.str.zfill(3)\n        0     0-1\n        1     001\n        2    1000\n        3     NaN\n        4     NaN\n        dtype: object\n        \"\"\"\n        result = str_pad(self._parent, width, side='left', fillchar='0')\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._parent, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._parent, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        result = str_decode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._parent, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs['str_strip'] = (r\"\"\"\n    Remove leading and trailing characters.\n\n    Strip whitespaces (including newlines) or a set of specified characters\n    from each string in the Series/Index from %(side)s.\n    Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    to_strip : str or None, default None.\n        Specifying the set of characters to be removed.\n        All combinations of this set of characters will be stripped.\n        If None then whitespaces are removed.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.strip : Remove leading and trailing characters in Series/Index\n    Series.str.lstrip : Remove leading characters in Series/Index\n    Series.str.rstrip : Remove trailing characters in Series/Index\n\n    Examples\n    --------\n    >>> s = pd.Series(['1. Ant.  ', '2. Bee!\\n', '3. Cat?\\t', np.nan])\n    >>> s\n    0    1. Ant.\n    1    2. Bee!\\n\n    2    3. Cat?\\t\n    3          NaN\n    dtype: object\n\n    >>> s.str.strip()\n    0    1. Ant.\n    1    2. Bee!\n    2    3. Cat?\n    3        NaN\n    dtype: object\n\n    >>> s.str.lstrip('123.')\n    0    Ant.\n    1    Bee!\\n\n    2    Cat?\\t\n    3       NaN\n    dtype: object\n\n    >>> s.str.rstrip('.!? \\n\\t')\n    0    1. Ant\n    1    2. Bee\n    2    3. Cat\n    3       NaN\n    dtype: object\n\n    >>> s.str.strip('123.!? \\n\\t')\n    0    Ant\n    1    Bee\n    2    Cat\n    3    NaN\n    dtype: object\n    \"\"\")\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left and right sides',\n                                               method='strip'))\n    def strip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side='both')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left side',\n                                               method='lstrip'))\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='right side',\n                                               method='rstrip'))\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._parent, to_strip, side='right')\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._parent, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    def get_dummies(self, sep='|'):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._parent\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(result, use_codes=(not self._is_categorical),\n                                 name=name, expand=True)\n\n    @copy(str_translate)\n    def translate(self, table, deletechars=None):\n        result = str_translate(self._parent, table, deletechars)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True)\n    startswith = _pat_wrapper(str_startswith, na=True)\n    endswith = _pat_wrapper(str_endswith, na=True)\n    findall = _pat_wrapper(str_findall, flags=True)\n\n    @copy(str_extract)\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs['find'] = (\"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['find'] %\n              dict(side='lowest', method='find',\n                   also='rfind : Return highest indexes in each strings'))\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['find'] %\n              dict(side='highest', method='rfind',\n                   also='find : Return lowest indexes in each strings'))\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._parent, sub,\n                          start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    def normalize(self, form):\n        \"\"\"Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n        f = lambda x: unicodedata.normalize(form, compat.u_safe(x))\n        result = _na_map(f, self._parent)\n        return self._wrap_result(result)\n\n    _shared_docs['index'] = (\"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['index'] %\n              dict(side='lowest', similar='find', method='index',\n                   also='rindex : Return highest indexes in each strings'))\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub,\n                           start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['index'] %\n              dict(side='highest', similar='rfind', method='rindex',\n                   also='index : Return lowest indexes in each strings'))\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._parent, sub,\n                           start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    _shared_docs['len'] = (\"\"\"\n    Computes the length of each element in the Series/Index. The element may be\n    a sequence (such as a string, tuple or list) or a collection\n    (such as a dictionary).\n\n    Returns\n    -------\n    Series or Index of int\n        A Series or Index of integer values indicating the length of each\n        element in the Series or Index.\n\n    See Also\n    --------\n    str.len : Python built-in function returning the length of an object.\n    Series.size : Returns the length of the Series.\n\n    Examples\n    --------\n    Returns the length (number of characters) in a string. Returns the\n    number of entries for dictionaries, lists or tuples.\n\n    >>> s = pd.Series(['dog',\n    ...                 '',\n    ...                 5,\n    ...                 {'foo' : 'bar'},\n    ...                 [2, 3, 5, 7],\n    ...                 ('one', 'two', 'three')])\n    >>> s\n    0                  dog\n    1\n    2                    5\n    3       {'foo': 'bar'}\n    4         [2, 3, 5, 7]\n    5    (one, two, three)\n    dtype: object\n    >>> s.str.len()\n    0    3.0\n    1    0.0\n    2    NaN\n    3    1.0\n    4    4.0\n    5    3.0\n    dtype: float64\n    \"\"\")\n    len = _noarg_wrapper(len, docstring=_shared_docs['len'], dtype=int)\n\n    _shared_docs['casemethods'] = (\"\"\"\n    Convert strings in the Series/Index to %(type)s.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\")\n    _shared_docs['lower'] = dict(type='lowercase', method='lower')\n    _shared_docs['upper'] = dict(type='uppercase', method='upper')\n    _shared_docs['title'] = dict(type='titlecase', method='title')\n    _shared_docs['capitalize'] = dict(type='be capitalized',\n                                      method='capitalize')\n    _shared_docs['swapcase'] = dict(type='be swapcased', method='swapcase')\n    lower = _noarg_wrapper(lambda x: x.lower(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['lower'])\n    upper = _noarg_wrapper(lambda x: x.upper(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['upper'])\n    title = _noarg_wrapper(lambda x: x.title(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['title'])\n    capitalize = _noarg_wrapper(lambda x: x.capitalize(),\n                                docstring=_shared_docs['casemethods'] %\n                                _shared_docs['capitalize'])\n    swapcase = _noarg_wrapper(lambda x: x.swapcase(),\n                              docstring=_shared_docs['casemethods'] %\n                              _shared_docs['swapcase'])\n\n    _shared_docs['ismethods'] = (\"\"\"\n    Check whether all characters in each string are %(type)s.\n\n    This is equivalent to running the Python string method\n    :meth:`str.%(method)s` for each element of the Series/Index. If a string\n    has zero characters, ``False`` is returned for that check.\n\n    Returns\n    -------\n    Series or Index of bool\n        Series or Index of boolean values with the same length as the original\n        Series/Index.\n\n    See Also\n    --------\n    Series.str.isalpha : Check whether all characters are alphabetic.\n    Series.str.isnumeric : Check whether all characters are numeric.\n    Series.str.isalnum : Check whether all characters are alphanumeric.\n    Series.str.isdigit : Check whether all characters are digits.\n    Series.str.isdecimal : Check whether all characters are decimal.\n    Series.str.isspace : Check whether all characters are whitespace.\n    Series.str.islower : Check whether all characters are lowercase.\n    Series.str.isupper : Check whether all characters are uppercase.\n    Series.str.istitle : Check whether all characters are titlecase.\n\n    Examples\n    --------\n    **Checks for Alphabetic and Numeric Characters**\n\n    >>> s1 = pd.Series(['one', 'one1', '1', ''])\n\n    >>> s1.str.isalpha()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s1.str.isnumeric()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    >>> s1.str.isalnum()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    Note that checks against characters mixed with any additional punctuation\n    or whitespace will evaluate to false for an alphanumeric check.\n\n    >>> s2 = pd.Series(['A B', '1.5', '3,000'])\n    >>> s2.str.isalnum()\n    0    False\n    1    False\n    2    False\n    dtype: bool\n\n    **More Detailed Checks for Numeric Characters**\n\n    There are several different but overlapping sets of numeric characters that\n    can be checked for.\n\n    >>> s3 = pd.Series(['23', '\u00b3', '\u2155', ''])\n\n    The ``s3.str.isdecimal`` method checks for characters used to form numbers\n    in base 10.\n\n    >>> s3.str.isdecimal()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isdigit`` method is the same as ``s3.str.isdecimal`` but also\n    includes special digits, like superscripted and subscripted digits in\n    unicode.\n\n    >>> s3.str.isdigit()\n    0     True\n    1     True\n    2    False\n    3    False\n    dtype: bool\n\n    The ``s.str.isnumeric`` method is the same as ``s3.str.isdigit`` but also\n    includes other characters that can represent quantities such as unicode\n    fractions.\n\n    >>> s3.str.isnumeric()\n    0     True\n    1     True\n    2     True\n    3    False\n    dtype: bool\n\n    **Checks for Whitespace**\n\n    >>> s4 = pd.Series([' ', '\\\\t\\\\r\\\\n ', ''])\n    >>> s4.str.isspace()\n    0     True\n    1     True\n    2    False\n    dtype: bool\n\n    **Checks for Character Case**\n\n    >>> s5 = pd.Series(['leopard', 'Golden Eagle', 'SNAKE', ''])\n\n    >>> s5.str.islower()\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n\n    >>> s5.str.isupper()\n    0    False\n    1    False\n    2     True\n    3    False\n    dtype: bool\n\n    The ``s5.str.istitle`` method checks for whether all words are in title\n    case (whether only the first letter of each word is capitalized). Words are\n    assumed to be as any sequence of non-numeric characters seperated by\n    whitespace characters.\n\n    >>> s5.str.istitle()\n    0    False\n    1     True\n    2    False\n    3    False\n    dtype: bool\n    \"\"\")\n    _shared_docs['isalnum'] = dict(type='alphanumeric', method='isalnum')\n    _shared_docs['isalpha'] = dict(type='alphabetic', method='isalpha')\n    _shared_docs['isdigit'] = dict(type='digits', method='isdigit')\n    _shared_docs['isspace'] = dict(type='whitespace', method='isspace')\n    _shared_docs['islower'] = dict(type='lowercase', method='islower')\n    _shared_docs['isupper'] = dict(type='uppercase', method='isupper')\n    _shared_docs['istitle'] = dict(type='titlecase', method='istitle')\n    _shared_docs['isnumeric'] = dict(type='numeric', method='isnumeric')\n    _shared_docs['isdecimal'] = dict(type='decimal', method='isdecimal')\n    isalnum = _noarg_wrapper(lambda x: x.isalnum(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalnum'])\n    isalpha = _noarg_wrapper(lambda x: x.isalpha(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalpha'])\n    isdigit = _noarg_wrapper(lambda x: x.isdigit(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isdigit'])\n    isspace = _noarg_wrapper(lambda x: x.isspace(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isspace'])\n    islower = _noarg_wrapper(lambda x: x.islower(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['islower'])\n    isupper = _noarg_wrapper(lambda x: x.isupper(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isupper'])\n    istitle = _noarg_wrapper(lambda x: x.istitle(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['istitle'])\n    isnumeric = _noarg_wrapper(lambda x: compat.u_safe(x).isnumeric(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isnumeric'])\n    isdecimal = _noarg_wrapper(lambda x: compat.u_safe(x).isdecimal(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isdecimal'])\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_patch": "@@ -1996,12 +1996,12 @@ class StringMethods(NoNewAttributesMixin):\n         elif isinstance(others, np.ndarray) and others.ndim == 2:\n             others = DataFrame(others, index=idx)\n             return ([others[x] for x in others], False)\n-        elif is_list_like(others):\n+        elif is_list_like(others, allow_sets=False):\n             others = list(others)  # ensure iterators do not get read twice etc\n \n             # in case of list-like `others`, all elements must be\n             # either one-dimensional list-likes or scalars\n-            if all(is_list_like(x) for x in others):\n+            if all(is_list_like(x, allow_sets=False) for x in others):\n                 los = []\n                 join_warn = False\n                 depr_warn = False\n",
          "files_name_in_blame_commit": [
            "strings.py",
            "test_strings.py"
          ]
        }
      },
      "ef019faa06f762c8c203985a11108731384b2dae": {
        "commit": {
          "commit_id": "ef019faa06f762c8c203985a11108731384b2dae",
          "commit_message": "Follow-up #20347: incorporate review about _get_series_list (#20923)",
          "commit_author": "h-vetinari",
          "commit_date": "2018-05-04 06:11:12",
          "commit_parent": "ec4609eecbd7fe4d46291b092bfe93f130b77ee5"
        },
        "function": {
          "function_name": "_get_series_list",
          "function_code_before": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        input : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, np.ndarray (1-dim) or list-like\n        ignore_index : boolean, default False\n            Determines whether to forcefully align with index of the caller\n\n        Returns\n        -------\n        tuple : (input transformed into list of Series,\n                 Boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Index, Series, DataFrame, isnull\n    idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, Series):\n        fu_wrn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and fu_wrn else others]\n        return (los, fu_wrn)\n    elif isinstance(others, Index):\n        fu_wrn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, fu_wrn)\n    elif isinstance(others, DataFrame):\n        fu_wrn = not others.index.equals(idx)\n        if ignore_index and fu_wrn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], fu_wrn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others):\n        others = list(others)\n        if all((is_list_like(x) for x in others)):\n            los = []\n            fu_wrn = False\n            while others:\n                nxt = others.pop(0)\n                if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, Index))\n                is_legal = no_deep and nxt.dtype == object or all((isinstance(x, compat.string_types) or (not is_list_like(x) and isnull(x)) or x is None for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, fwn) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                fu_wrn = fu_wrn or fwn\n            return (los, fu_wrn)\n        elif any((is_list_like(x) for x in others)) and any((not is_list_like(x) for x in others)):\n            raise TypeError(err_msg)\n        else:\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_code_after": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, np.ndarray (1-dim) or list-like\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Index, Series, DataFrame\n    idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, Series):\n        warn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and warn else others]\n        return (los, warn)\n    elif isinstance(others, Index):\n        warn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, warn)\n    elif isinstance(others, DataFrame):\n        warn = not others.index.equals(idx)\n        if ignore_index and warn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], warn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others):\n        others = list(others)\n        if all((is_list_like(x) for x in others)):\n            los = []\n            warn = False\n            while others:\n                nxt = others.pop(0)\n                if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, Index))\n                is_legal = no_deep and nxt.dtype == object or all((not is_list_like(x) for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, wnx) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                warn = warn or wnx\n            return (los, warn)\n        elif all((not is_list_like(x) for x in others)):\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_before_start_line": 1938,
          "function_before_end_line": 2030,
          "function_after_start_line": 1938,
          "function_after_end_line": 2033,
          "function_before_token_count": 477,
          "function_after_token_count": 432,
          "functions_name_modified_file": [
            "str_endswith",
            "rsplit",
            "str_encode",
            "str_get",
            "translate",
            "lstrip",
            "str_pad",
            "_make_accessor",
            "str_count",
            "str_rsplit",
            "rjust",
            "rindex",
            "str_slice",
            "str_slice_replace",
            "__getitem__",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "get_dummies",
            "contains",
            "match",
            "wrap",
            "str_extract",
            "str_translate",
            "_length_check",
            "_noarg_wrapper",
            "partition",
            "_na_map",
            "_validate",
            "_get_array_list",
            "zfill",
            "_groups_or_na_fun",
            "str_replace",
            "str_join",
            "str_decode",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "normalize",
            "str_find",
            "_map",
            "str_cat",
            "slice_replace",
            "rpartition",
            "decode",
            "ljust",
            "encode",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "center",
            "find",
            "str_repeat",
            "__iter__",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "get",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "str_split",
            "_get_series_list",
            "join",
            "str_wrap",
            "str_match",
            "cat"
          ],
          "functions_name_all_files": [
            "str_endswith",
            "rsplit",
            "str_encode",
            "str_get",
            "translate",
            "lstrip",
            "str_pad",
            "_make_accessor",
            "str_count",
            "str_rsplit",
            "rjust",
            "rindex",
            "str_slice",
            "str_slice_replace",
            "__getitem__",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "get_dummies",
            "contains",
            "match",
            "wrap",
            "str_extract",
            "str_translate",
            "_length_check",
            "_noarg_wrapper",
            "partition",
            "_na_map",
            "_validate",
            "_get_array_list",
            "zfill",
            "_groups_or_na_fun",
            "str_replace",
            "str_join",
            "str_decode",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "normalize",
            "str_find",
            "_map",
            "str_cat",
            "slice_replace",
            "rpartition",
            "decode",
            "ljust",
            "encode",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "center",
            "find",
            "str_repeat",
            "__iter__",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "get",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "str_split",
            "_get_series_list",
            "join",
            "str_wrap",
            "str_match",
            "cat"
          ],
          "functions_name_co_evolved_modified_file": [
            "cat"
          ],
          "functions_name_co_evolved_all_files": [
            "cat"
          ]
        },
        "file": {
          "file_name": "strings.py",
          "file_nloc": 1418,
          "file_complexity": 292,
          "file_token_count": 7570,
          "file_before": "import numpy as np\n\nfrom pandas.compat import zip\nfrom pandas.core.dtypes.generic import ABCSeries, ABCIndex\nfrom pandas.core.dtypes.missing import isna, notna\nfrom pandas.core.dtypes.common import (\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_object_dtype,\n    is_string_like,\n    is_list_like,\n    is_scalar,\n    is_integer,\n    is_re)\n\nimport pandas.core.common as com\nfrom pandas.core.algorithms import take_1d\nimport pandas.compat as compat\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.util._decorators import Appender\nimport re\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nimport warnings\nimport textwrap\nimport codecs\n\n_cpython_optimized_encoders = (\n    \"utf-8\", \"utf8\", \"latin-1\", \"latin1\", \"iso-8859-1\", \"mbcs\", \"ascii\"\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\n    \"utf-16\", \"utf-32\"\n)\n\n_shared_docs = dict()\n\n\ndef _get_array_list(arr, others):\n    \"\"\"\n    Auxiliary function for :func:`str_cat`\n\n    Parameters\n    ----------\n    arr : ndarray\n        The left-most ndarray of the concatenation\n    others : list, ndarray, Series\n        The rest of the content to concatenate. If list of list-likes,\n        all elements must be passable to ``np.asarray``.\n\n    Returns\n    -------\n    list\n        List of all necessary arrays\n    \"\"\"\n    from pandas.core.series import Series\n\n    if len(others) and isinstance(com._values_from_object(others)[0],\n                                  (list, np.ndarray, Series)):\n        arrays = [arr] + list(others)\n    else:\n        arrays = [arr, others]\n\n    return [np.asarray(x, dtype=object) for x in arrays]\n\n\ndef str_cat(arr, others=None, sep=None, na_rep=None):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    If `others` is specified, this function concatenates the Series/Index\n    and elements of `others` element-wise.\n    If `others` is not being passed then all values in the Series are\n    concatenated in a single string with a given `sep`.\n\n    Parameters\n    ----------\n    others : list-like, or list of list-likes, optional\n        List-likes (or a list of them) of the same length as calling object.\n        If None, returns str concatenating strings of the Series.\n    sep : string or None, default None\n        If None, concatenates without any separator.\n    na_rep : string or None, default None\n        If None, NA in the series are ignored.\n\n    Returns\n    -------\n    concat\n        ndarray containing concatenated results (if `others is not None`)\n        or str (if `others is None`)\n    \"\"\"\n    if sep is None:\n        sep = ''\n\n    if others is not None:\n        arrays = _get_array_list(arr, others)\n\n        n = _length_check(arrays)\n        masks = np.array([isna(x) for x in arrays])\n        cats = None\n\n        if na_rep is None:\n            na_mask = np.logical_or.reduce(masks, axis=0)\n\n            result = np.empty(n, dtype=object)\n            np.putmask(result, na_mask, np.nan)\n\n            notmask = ~na_mask\n\n            tuples = zip(*[x[notmask] for x in arrays])\n            cats = [sep.join(tup) for tup in tuples]\n\n            result[notmask] = cats\n        else:\n            for i, x in enumerate(arrays):\n                x = np.where(masks[i], na_rep, x)\n                if cats is None:\n                    cats = x\n                else:\n                    cats = cats + sep + x\n\n            result = cats\n\n        return result\n    else:\n        arr = np.asarray(arr, dtype=object)\n        mask = isna(arr)\n        if na_rep is None and mask.any():\n            if sep == '':\n                na_rep = ''\n            else:\n                return sep.join(arr[notna(arr)])\n        return sep.join(np.where(mask, na_rep, arr))\n\n\ndef _length_check(others):\n    n = None\n    for x in others:\n        try:\n            if n is None:\n                n = len(x)\n            elif len(x) != n:\n                raise ValueError('All arrays must be same length')\n        except TypeError:\n            raise ValueError('Must pass arrays containing strings to str_cat')\n    return n\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            if compat.PY2:\n                p_err = r'takes (no|(exactly|at (least|most)) ?\\d+) arguments?'\n            else:\n                p_err = (r'((takes)|(missing)) (?(2)from \\d+ to )?\\d+ '\n                         r'(?(3)required )positional arguments?')\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatability with other string methods. Not used.\n\n    Returns\n    -------\n    counts : Series or Index\n        Same type as the calling object containing the integer counts.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Return boolean Series/``array`` whether given pattern/regex is\n    contained in each string in the Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    regex : bool, default True\n        If True use re.search, otherwise use Python in operator\n\n    Returns\n    -------\n    contained : Series/array of boolean values\n\n    See Also\n    --------\n    match : analogous, but stricter, relying on re.match instead of re.search\n\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\"This pattern has match groups. To actually get the\"\n                          \" groups, use str.extract.\", UserWarning,\n                          stacklevel=3)\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : string or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : string or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start\n    case : boolean, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : boolean, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    replaced : Series/Index of objects\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\"case and flags cannot be set\"\n                                 \" when pat is a compiled regex\")\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\"Cannot use a compiled regex as replacement \"\n                             \"pattern with regex=False\")\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \"\n                             \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series/Index by indicated number\n    of times.\n\n    Parameters\n    ----------\n    repeats : int or array\n        Same value for all (int) or different value per (array)\n\n    Returns\n    -------\n    repeated : Series/Index of objects\n    \"\"\"\n    if is_scalar(repeats):\n\n        def rep(x):\n            try:\n                return compat.binary_type.__mul__(x, repeats)\n            except TypeError:\n                return compat.text_type.__mul__(x, repeats)\n\n        return _na_map(rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return compat.binary_type.__mul__(x, r)\n            except TypeError:\n                return compat.text_type.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com._values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    as_indexer\n        .. deprecated:: 0.21.0\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : analogous, but less strict, relying on re.search instead of\n        re.match\n    extract : extract matched groups\n\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    if (as_indexer is False) and (regex.groups > 0):\n        raise ValueError(\"as_indexer=False with a pattern with groups is no \"\n                         \"longer supported. Use '.str.extract(pat)' instead\")\n    elif as_indexer is not None:\n        # Previously, this keyword was used for changing the default but\n        # deprecated behaviour. This keyword is now no longer needed.\n        warnings.warn(\"'as_indexer' keyword was specified but is ignored \"\n                      \"(match now returns a boolean indexer by default), \"\n                      \"and will be removed in a future version.\",\n                      FutureWarning, stacklevel=3)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, compat.string_types):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, Index\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, Index):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object)\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object)\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat.\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    expand : bool, default True\n        * If True, return DataFrame.\n        * If False, return Series/Index/DataFrame.\n\n        .. versionadded:: 0.18.0\n\n    Returns\n    -------\n    DataFrame with one row for each subject string, and one column for\n    each group. Any capture group names in regular expression pat will\n    be used for column names; otherwise capture group numbers will be\n    used. The dtype of each result column is always object, even when\n    no match is found. If expand=False and pat has only one capture group,\n    then return a Series (if subject is a Series) or Index (if subject\n    is an Index).\n\n    See Also\n    --------\n    extractall : returns all matches (not just the first match)\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._data, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    Returns\n    -------\n    A DataFrame with one row for each match, and one column for each\n    group. Its rows have a MultiIndex with first levels that come from\n    the subject Series. The last level is named 'match' and indicates\n    the order in the subject. Any capture group names in regular\n    expression pat will be used for column names; otherwise capture\n    group numbers will be used.\n\n    See Also\n    --------\n    extract : returns first match only (not all matches)\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.iteritems():\n        if isinstance(subject, compat.string_types):\n\n            if not is_mi:\n                subject_key = (subject_key, )\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, compat.string_types):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group\n                            for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i, ))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n    index = MultiIndex.from_tuples(\n        index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index,\n                                        columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep='|'):\n    \"\"\"\n    Split each string in the Series by sep and return a frame of\n    dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : string, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    dummies : DataFrame\n\n    Examples\n    --------\n    >>> Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n\n    See Also\n    --------\n    pandas.get_dummies\n    \"\"\"\n    arr = arr.fillna('')\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - set([\"\"]))\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n\n    Notes\n    -----\n    If any of the lists does not contain string objects the result of the join\n    will be `NaN`.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Examples\n    --------\n\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat']\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using an '-', the lists containing object(s) of types other\n    than str will become a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Pattern or regular expression.\n    flags : int, default 0\n        ``re`` module flags, e.g. `re.IGNORECASE` (default is 0, which means\n        no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side='left'):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``\n\n    Returns\n    -------\n    found : Series/Index of integer values\n    \"\"\"\n\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'find'\n    elif side == 'right':\n        method = 'rfind'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side='left'):\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'index'\n    elif side == 'right':\n        method = 'rindex'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side='left', fillchar=' '):\n    \"\"\"\n    Pad strings in the Series/Index with an additional character to\n    specified side.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with spaces\n    side : {'left', 'right', 'both'}, default 'left'\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    padded : Series/Index of objects\n    \"\"\"\n\n    if not isinstance(fillchar, compat.string_types):\n        msg = 'fillchar must be a character, not {0}'\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError('fillchar must be a character, not str')\n\n    if not is_integer(width):\n        msg = 'width must be of integer type, not {0}'\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == 'left':\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == 'right':\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == 'both':\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n    \"\"\"\n    Split strings around given separator/delimiter.\n\n    Split each string in the caller's values by given\n    pattern, propagating NaN values. Equivalent to :meth:`str.split`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    See Also\n    --------\n    str.split : Standard library version of this method.\n    Series.str.get_dummies : Split each string into dummy variables.\n    Series.str.partition : Split string on a separator, returning\n        the before, separator, and after components.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\"])\n\n    By default, split will return an object of the same size\n    having lists containing the split elements\n\n    >>> s.str.split()\n    0           [this, is, good, text]\n    1    [but, this, is, even, better]\n    dtype: object\n    >>> s.str.split(\"random\")\n    0          [this is good text]\n    1    [but this is even better]\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns.\n\n    For Series object, output return type is DataFrame.\n\n    >>> s.str.split(expand=True)\n          0     1     2     3       4\n    0  this    is  good  text    None\n    1   but  this    is  even  better\n    >>> s.str.split(\" is \", expand=True)\n              0            1\n    0      this    good text\n    1  but this  even better\n\n    For Index object, output return type is MultiIndex.\n\n    >>> i = pd.Index([\"ba 100 001\", \"ba 101 002\", \"ba 102 003\"])\n    >>> i.str.split(expand=True)\n    MultiIndex(levels=[['ba'], ['100', '101', '102'], ['001', '002', '003']],\n           labels=[[0, 0, 0], [0, 1, 2], [0, 1, 2]])\n\n    Parameter `n` can be used to limit the number of splits in the output.\n\n    >>> s.str.split(\"is\", n=1)\n    0          [th,  is good text]\n    1    [but th,  is even better]\n    dtype: object\n    >>> s.str.split(\"is\", n=1, expand=True)\n            0                1\n    0      th     is good text\n    1  but th   is even better\n\n    If NaN is present, it is propagated throughout the columns\n    during the split.\n\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\", np.nan])\n    >>> s.str.split(n=3, expand=True)\n          0     1     2            3\n    0  this    is  good         text\n    1   but  this    is  even better\n    2   NaN   NaN   NaN          NaN\n    \"\"\"\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n    \"\"\"\n    Split each string in the Series/Index by the given delimiter\n    string, starting at the end of the string and working to the front.\n    Equivalent to :meth:`str.rsplit`.\n\n    Parameters\n    ----------\n    pat : string, default None\n        Separator to split on. If None, splits on whitespace\n    n : int, default -1 (all)\n        None, 0 and -1 will be interpreted as return all splits\n    expand : bool, default False\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : Series/Index or DataFrame/MultiIndex of objects\n    \"\"\"\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series/Index\n\n    Parameters\n    ----------\n    start : int or None\n    stop : int or None\n    step : int or None\n\n    Returns\n    -------\n    sliced : Series/Index of objects\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    replaced : Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = ''\n\n    def f(x):\n        if x[start:stop] == '':\n            local_stop = start\n        else:\n            local_stop = stop\n        y = ''\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side='both'):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\"\n    if side == 'both':\n        f = lambda x: x.strip(to_strip)\n    elif side == 'left':\n        f = lambda x: x.lstrip(to_strip)\n    elif side == 'right':\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line-width\n    expand_tabs : bool, optional\n        If true, tab characters will be expanded to spaces (default: True)\n    replace_whitespace : bool, optional\n        If true, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True)\n    drop_whitespace : bool, optional\n        If true, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True)\n    break_long_words : bool, optional\n        If true, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width. (default: True)\n    break_on_hyphens : bool, optional\n        If true, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words. (default: True)\n\n    Returns\n    -------\n    wrapped : Series/Index of objects\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    \"\"\"\n    kwargs['width'] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: '\\n'.join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table, deletechars=None):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`. Note that the optional\n    argument deletechars is only valid if you are using python 2. For python 3,\n    character deletion should be specified via the table argument.\n\n    Parameters\n    ----------\n    table : dict (python 3), str or None (python 2)\n        In python 3, table is a mapping of Unicode ordinals to Unicode\n        ordinals, strings, or None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n        In python 2, table is either a string of length 256 or None. If the\n        table argument is None, no translation is applied and the operation\n        simply removes the characters in deletechars. :func:`string.maketrans`\n        is a helper function for making translation tables.\n    deletechars : str, optional (python 2)\n        A string of characters to delete. This argument is only valid\n        in python 2.\n\n    Returns\n    -------\n    translated : Series/Index of objects\n    \"\"\"\n    if deletechars is None:\n        f = lambda x: x.translate(table)\n    else:\n        if compat.PY3:\n            raise ValueError(\"deletechars is not a valid argument for \"\n                             \"str.translate in python 3. You should simply \"\n                             \"specify character deletions in the table \"\n                             \"argument\")\n        f = lambda x: x.translate(table, deletechars)\n    return _na_map(f, arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    items : Series/Index of objects\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n               (1, 2, 3),\n               [\"a\", \"b\", \"c\"],\n               123, -456,\n               {1:\"Hello\", \"2\":\"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    NaN\n    dtype: object\n    \"\"\"\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    decoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef _noarg_wrapper(f, docstring=None, **kargs):\n    def wrapper(self):\n        result = _na_map(f, self._data, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError('Provide docstring')\n\n    return wrapper\n\n\ndef _pat_wrapper(f, flags=False, na=False, **kwargs):\n    def wrapper1(self, pat):\n        result = f(self._data, pat)\n        return self._wrap_result(result)\n\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._data, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._data, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._data = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        from pandas.core.index import Index\n\n        if (isinstance(data, ABCSeries) and\n                not ((is_categorical_dtype(data.dtype) and\n                      is_object_dtype(data.values.categories)) or\n                     (is_object_dtype(data.dtype)))):\n            # it's neither a string series not a categorical series with\n            # strings inside the categories.\n            # this really should exclude all series with any non-string values\n            # (instead of test for object dtype), but that isn't practical for\n            # performance reasons until we have a str dtype (GH 9343)\n            raise AttributeError(\"Can only use .str accessor with string \"\n                                 \"values, which use np.object_ dtype in \"\n                                 \"pandas\")\n        elif isinstance(data, Index):\n            # can't use ABCIndex to exclude non-str\n\n            # see src/inference.pyx which can contain string values\n            allowed_types = ('string', 'unicode', 'mixed', 'mixed-integer')\n            if is_categorical_dtype(data.dtype):\n                inf_type = data.categories.inferred_type\n            else:\n                inf_type = data.inferred_type\n            if inf_type not in allowed_types:\n                message = (\"Can only use .str accessor with string values \"\n                           \"(i.e. inferred_type is 'string', 'unicode' or \"\n                           \"'mixed')\")\n                raise AttributeError(message)\n            if data.nlevels > 1:\n                message = (\"Can only use .str accessor with Index, not \"\n                           \"MultiIndex\")\n                raise AttributeError(message)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(self, result, use_codes=True,\n                     name=None, expand=None):\n\n        from pandas.core.index import Index, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            result = take_1d(result, self._orig.cat.codes)\n\n        if not hasattr(result, 'ndim') or not hasattr(result, 'dtype'):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = False if result.ndim == 1 else True\n\n        elif expand is True and not isinstance(self._orig, Index):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [x * max_len if len(x) == 0 or x[0] is np.nan\n                          else x for x in result]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, 'name', None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, Index):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        input : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, np.ndarray (1-dim) or list-like\n        ignore_index : boolean, default False\n            Determines whether to forcefully align with index of the caller\n\n        Returns\n        -------\n        tuple : (input transformed into list of Series,\n                 Boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Index, Series, DataFrame, isnull\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n\n        err_msg = ('others must be Series, Index, DataFrame, np.ndarrary or '\n                   'list-like (either containing only strings or containing '\n                   'only objects of type Series/Index/list-like/np.ndarray)')\n\n        if isinstance(others, Series):\n            fu_wrn = not others.index.equals(idx)\n            los = [Series(others.values, index=idx)\n                   if ignore_index and fu_wrn else others]\n            return (los, fu_wrn)\n        elif isinstance(others, Index):\n            fu_wrn = not others.equals(idx)\n            los = [Series(others.values,\n                          index=(idx if ignore_index else others))]\n            return (los, fu_wrn)\n        elif isinstance(others, DataFrame):\n            fu_wrn = not others.index.equals(idx)\n            if ignore_index and fu_wrn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], fu_wrn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others):\n            others = list(others)  # ensure iterators do not get read twice etc\n            if all(is_list_like(x) for x in others):\n                los = []\n                fu_wrn = False\n                while others:\n                    nxt = others.pop(0)  # list-like as per check above\n                    # safety for iterators and other non-persistent list-likes\n                    # do not map indexed/typed objects; would lose information\n                    if not isinstance(nxt, (DataFrame, Series,\n                                            Index, np.ndarray)):\n                        nxt = list(nxt)\n\n                    # known types without deep inspection\n                    no_deep = ((isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                               or isinstance(nxt, (Series, Index)))\n                    # Nested list-likes are forbidden - elements of nxt must be\n                    # strings/NaN/None. Need to robustify NaN-check against\n                    # x in nxt being list-like (otherwise ambiguous boolean)\n                    is_legal = ((no_deep and nxt.dtype == object)\n                                or all((isinstance(x, compat.string_types)\n                                        or (not is_list_like(x) and isnull(x))\n                                        or x is None)\n                                       for x in nxt))\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, fwn = self._get_series_list(nxt,\n                                                     ignore_index=ignore_index)\n                    los = los + nxt\n                    fu_wrn = fu_wrn or fwn\n                return (los, fu_wrn)\n            # test if there is a mix of list-like and non-list-like (e.g. str)\n            elif (any(is_list_like(x) for x in others)\n                  and any(not is_list_like(x) for x in others)):\n                raise TypeError(err_msg)\n            else:  # all elements in others are _not_ list-like\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarrary or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            np.ndarray (1-dim) or list-like, then all elements will be unpacked\n            and must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : string or None, default None\n            If None, concatenates without any separator.\n        na_rep : string or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        concat : str if `other is None`, Series/Index of objects if `others is\n            not None`. In the latter case, the result will remain categorical\n            if the calling Series/Index is categorical.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join=None, na_rep='-')\n        0    ad\n        1    ba\n        2    -e\n        3    dc\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, compat.string_types):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n\n        if isinstance(self._orig, Index):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            result = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n            return self._wrap_result(result,\n                                     use_codes=(not self._is_categorical))\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, fu_wrn = self._get_series_list(others,\n                                                   ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError('All arrays must be same length, except '\n                                 'those having an index if `join` is not None')\n            else:\n                raise ValueError('If `others` contains arrays or lists (or '\n                                 'other list-likes without an index), these '\n                                 'must all be of the same length as the '\n                                 'calling Series/Index.')\n\n        if join is None and fu_wrn:\n            warnings.warn(\"A future version of pandas will perform index \"\n                          \"alignment when `others` is a Series/Index/\"\n                          \"DataFrame (or a list-like containing one). To \"\n                          \"disable alignment (the behavior before v.0.23) and \"\n                          \"silence this warning, use `.values` on any Series/\"\n                          \"Index/DataFrame in `others`. To enable alignment \"\n                          \"and silence this warning, pass `join='left'|\"\n                          \"'outer'|'inner'|'right'`. The future default will \"\n                          \"be `join='left'`.\", FutureWarning, stacklevel=2)\n\n        # align if required\n        if join is not None:\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(others, axis=1,\n                            join=(join if join == 'inner' else 'outer'),\n                            keys=range(len(others)))\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        # str_cat discards index\n        res = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n\n        if isinstance(self._orig, Index):\n            res = Index(res)\n        else:  # Series\n            res = Series(res, index=data.index)\n        return res\n\n    @copy(str_split)\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_rsplit)\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs['str_partition'] = (\"\"\"\n    Split the string at the %(side)s occurrence of `sep`, and return 3 elements\n    containing the part before the separator, the separator itself,\n    and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    pat : string, default whitespace\n        String to split on.\n    expand : bool, default True\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n\n    Examples\n    --------\n\n    >>> s = Series(['A_B_C', 'D_E_F', 'X'])\n    0    A_B_C\n    1    D_E_F\n    2        X\n    dtype: object\n\n    >>> s.str.partition('_')\n       0  1    2\n    0  A  _  B_C\n    1  D  _  E_F\n    2  X\n\n    >>> s.str.rpartition('_')\n         0  1  2\n    0  A_B  _  C\n    1  D_E  _  F\n    2          X\n    \"\"\")\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'first',\n        'return': '3 elements containing the string itself, followed by two '\n                  'empty strings',\n        'also': 'rpartition : Split the string at the last occurrence of `sep`'\n    })\n    def partition(self, pat=' ', expand=True):\n        f = lambda x: x.partition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'last',\n        'return': '3 elements containing two empty strings, followed by the '\n                  'string itself',\n        'also': 'partition : Split the string at the first occurrence of `sep`'\n    })\n    def rpartition(self, pat=' ', expand=True):\n        f = lambda x: x.rpartition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._data, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    def join(self, sep):\n        result = str_join(self._data, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(self._data, pat, case=case, flags=flags, na=na,\n                              regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_match)\n    def match(self, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n        result = str_match(self._data, pat, case=case, flags=flags, na=na,\n                           as_indexer=as_indexer)\n        return self._wrap_result(result)\n\n    @copy(str_replace)\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(self._data, pat, repl, n=n, case=case,\n                             flags=flags, regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    def repeat(self, repeats):\n        result = str_repeat(self._data, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    def pad(self, width, side='left', fillchar=' '):\n        result = str_pad(self._data, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs['str_pad'] = (\"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left and right',\n                                             method='center'))\n    def center(self, width, fillchar=' '):\n        return self.pad(width, side='both', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='right', method='ljust'))\n    def ljust(self, width, fillchar=' '):\n        return self.pad(width, side='right', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left', method='rjust'))\n    def rjust(self, width, fillchar=' '):\n        return self.pad(width, side='left', fillchar=fillchar)\n\n    def zfill(self, width):\n        \"\"\"\n        Filling left side of strings in the Series/Index with 0.\n        Equivalent to :meth:`str.zfill`.\n\n        Parameters\n        ----------\n        width : int\n            Minimum width of resulting string; additional characters will be\n            filled with 0\n\n        Returns\n        -------\n        filled : Series/Index of objects\n        \"\"\"\n        result = str_pad(self._data, width, side='left', fillchar='0')\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._data, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._data, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        result = str_decode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs['str_strip'] = (\"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index from %(side)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left and right sides',\n                                               method='strip'))\n    def strip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='both')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left side',\n                                               method='lstrip'))\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='right side',\n                                               method='rstrip'))\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='right')\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._data, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    def get_dummies(self, sep='|'):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._data\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(result, use_codes=(not self._is_categorical),\n                                 name=name, expand=True)\n\n    @copy(str_translate)\n    def translate(self, table, deletechars=None):\n        result = str_translate(self._data, table, deletechars)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True)\n    startswith = _pat_wrapper(str_startswith, na=True)\n    endswith = _pat_wrapper(str_endswith, na=True)\n    findall = _pat_wrapper(str_findall, flags=True)\n\n    @copy(str_extract)\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs['find'] = (\"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['find'] %\n              dict(side='lowest', method='find',\n                   also='rfind : Return highest indexes in each strings'))\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['find'] %\n              dict(side='highest', method='rfind',\n                   also='find : Return lowest indexes in each strings'))\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    def normalize(self, form):\n        \"\"\"Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n        f = lambda x: unicodedata.normalize(form, compat.u_safe(x))\n        result = _na_map(f, self._data)\n        return self._wrap_result(result)\n\n    _shared_docs['index'] = (\"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['index'] %\n              dict(side='lowest', similar='find', method='index',\n                   also='rindex : Return highest indexes in each strings'))\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['index'] %\n              dict(side='highest', similar='rfind', method='rindex',\n                   also='index : Return lowest indexes in each strings'))\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    _shared_docs['len'] = (\"\"\"\n    Compute length of each string in the Series/Index.\n\n    Returns\n    -------\n    lengths : Series/Index of integer values\n    \"\"\")\n    len = _noarg_wrapper(len, docstring=_shared_docs['len'], dtype=int)\n\n    _shared_docs['casemethods'] = (\"\"\"\n    Convert strings in the Series/Index to %(type)s.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\")\n    _shared_docs['lower'] = dict(type='lowercase', method='lower')\n    _shared_docs['upper'] = dict(type='uppercase', method='upper')\n    _shared_docs['title'] = dict(type='titlecase', method='title')\n    _shared_docs['capitalize'] = dict(type='be capitalized',\n                                      method='capitalize')\n    _shared_docs['swapcase'] = dict(type='be swapcased', method='swapcase')\n    lower = _noarg_wrapper(lambda x: x.lower(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['lower'])\n    upper = _noarg_wrapper(lambda x: x.upper(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['upper'])\n    title = _noarg_wrapper(lambda x: x.title(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['title'])\n    capitalize = _noarg_wrapper(lambda x: x.capitalize(),\n                                docstring=_shared_docs['casemethods'] %\n                                _shared_docs['capitalize'])\n    swapcase = _noarg_wrapper(lambda x: x.swapcase(),\n                              docstring=_shared_docs['casemethods'] %\n                              _shared_docs['swapcase'])\n\n    _shared_docs['ismethods'] = (\"\"\"\n    Check whether all characters in each string in the Series/Index\n    are %(type)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    is : Series/array of boolean values\n    \"\"\")\n    _shared_docs['isalnum'] = dict(type='alphanumeric', method='isalnum')\n    _shared_docs['isalpha'] = dict(type='alphabetic', method='isalpha')\n    _shared_docs['isdigit'] = dict(type='digits', method='isdigit')\n    _shared_docs['isspace'] = dict(type='whitespace', method='isspace')\n    _shared_docs['islower'] = dict(type='lowercase', method='islower')\n    _shared_docs['isupper'] = dict(type='uppercase', method='isupper')\n    _shared_docs['istitle'] = dict(type='titlecase', method='istitle')\n    _shared_docs['isnumeric'] = dict(type='numeric', method='isnumeric')\n    _shared_docs['isdecimal'] = dict(type='decimal', method='isdecimal')\n    isalnum = _noarg_wrapper(lambda x: x.isalnum(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalnum'])\n    isalpha = _noarg_wrapper(lambda x: x.isalpha(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalpha'])\n    isdigit = _noarg_wrapper(lambda x: x.isdigit(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isdigit'])\n    isspace = _noarg_wrapper(lambda x: x.isspace(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isspace'])\n    islower = _noarg_wrapper(lambda x: x.islower(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['islower'])\n    isupper = _noarg_wrapper(lambda x: x.isupper(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isupper'])\n    istitle = _noarg_wrapper(lambda x: x.istitle(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['istitle'])\n    isnumeric = _noarg_wrapper(lambda x: compat.u_safe(x).isnumeric(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isnumeric'])\n    isdecimal = _noarg_wrapper(lambda x: compat.u_safe(x).isdecimal(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isdecimal'])\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_after": "import numpy as np\n\nfrom pandas.compat import zip\nfrom pandas.core.dtypes.generic import ABCSeries, ABCIndex\nfrom pandas.core.dtypes.missing import isna, notna\nfrom pandas.core.dtypes.common import (\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_object_dtype,\n    is_string_like,\n    is_list_like,\n    is_scalar,\n    is_integer,\n    is_re)\n\nimport pandas.core.common as com\nfrom pandas.core.algorithms import take_1d\nimport pandas.compat as compat\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.util._decorators import Appender\nimport re\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nimport warnings\nimport textwrap\nimport codecs\n\n_cpython_optimized_encoders = (\n    \"utf-8\", \"utf8\", \"latin-1\", \"latin1\", \"iso-8859-1\", \"mbcs\", \"ascii\"\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\n    \"utf-16\", \"utf-32\"\n)\n\n_shared_docs = dict()\n\n\ndef _get_array_list(arr, others):\n    \"\"\"\n    Auxiliary function for :func:`str_cat`\n\n    Parameters\n    ----------\n    arr : ndarray\n        The left-most ndarray of the concatenation\n    others : list, ndarray, Series\n        The rest of the content to concatenate. If list of list-likes,\n        all elements must be passable to ``np.asarray``.\n\n    Returns\n    -------\n    list\n        List of all necessary arrays\n    \"\"\"\n    from pandas.core.series import Series\n\n    if len(others) and isinstance(com._values_from_object(others)[0],\n                                  (list, np.ndarray, Series)):\n        arrays = [arr] + list(others)\n    else:\n        arrays = [arr, others]\n\n    return [np.asarray(x, dtype=object) for x in arrays]\n\n\ndef str_cat(arr, others=None, sep=None, na_rep=None):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    If `others` is specified, this function concatenates the Series/Index\n    and elements of `others` element-wise.\n    If `others` is not being passed then all values in the Series are\n    concatenated in a single string with a given `sep`.\n\n    Parameters\n    ----------\n    others : list-like, or list of list-likes, optional\n        List-likes (or a list of them) of the same length as calling object.\n        If None, returns str concatenating strings of the Series.\n    sep : string or None, default None\n        If None, concatenates without any separator.\n    na_rep : string or None, default None\n        If None, NA in the series are ignored.\n\n    Returns\n    -------\n    concat\n        ndarray containing concatenated results (if `others is not None`)\n        or str (if `others is None`)\n    \"\"\"\n    if sep is None:\n        sep = ''\n\n    if others is not None:\n        arrays = _get_array_list(arr, others)\n\n        n = _length_check(arrays)\n        masks = np.array([isna(x) for x in arrays])\n        cats = None\n\n        if na_rep is None:\n            na_mask = np.logical_or.reduce(masks, axis=0)\n\n            result = np.empty(n, dtype=object)\n            np.putmask(result, na_mask, np.nan)\n\n            notmask = ~na_mask\n\n            tuples = zip(*[x[notmask] for x in arrays])\n            cats = [sep.join(tup) for tup in tuples]\n\n            result[notmask] = cats\n        else:\n            for i, x in enumerate(arrays):\n                x = np.where(masks[i], na_rep, x)\n                if cats is None:\n                    cats = x\n                else:\n                    cats = cats + sep + x\n\n            result = cats\n\n        return result\n    else:\n        arr = np.asarray(arr, dtype=object)\n        mask = isna(arr)\n        if na_rep is None and mask.any():\n            if sep == '':\n                na_rep = ''\n            else:\n                return sep.join(arr[notna(arr)])\n        return sep.join(np.where(mask, na_rep, arr))\n\n\ndef _length_check(others):\n    n = None\n    for x in others:\n        try:\n            if n is None:\n                n = len(x)\n            elif len(x) != n:\n                raise ValueError('All arrays must be same length')\n        except TypeError:\n            raise ValueError('Must pass arrays containing strings to str_cat')\n    return n\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            if compat.PY2:\n                p_err = r'takes (no|(exactly|at (least|most)) ?\\d+) arguments?'\n            else:\n                p_err = (r'((takes)|(missing)) (?(2)from \\d+ to )?\\d+ '\n                         r'(?(3)required )positional arguments?')\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatability with other string methods. Not used.\n\n    Returns\n    -------\n    counts : Series or Index\n        Same type as the calling object containing the integer counts.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Return boolean Series/``array`` whether given pattern/regex is\n    contained in each string in the Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    regex : bool, default True\n        If True use re.search, otherwise use Python in operator\n\n    Returns\n    -------\n    contained : Series/array of boolean values\n\n    See Also\n    --------\n    match : analogous, but stricter, relying on re.match instead of re.search\n\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\"This pattern has match groups. To actually get the\"\n                          \" groups, use str.extract.\", UserWarning,\n                          stacklevel=3)\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : string or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : string or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start\n    case : boolean, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : boolean, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    replaced : Series/Index of objects\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\"case and flags cannot be set\"\n                                 \" when pat is a compiled regex\")\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\"Cannot use a compiled regex as replacement \"\n                             \"pattern with regex=False\")\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \"\n                             \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series/Index by indicated number\n    of times.\n\n    Parameters\n    ----------\n    repeats : int or array\n        Same value for all (int) or different value per (array)\n\n    Returns\n    -------\n    repeated : Series/Index of objects\n    \"\"\"\n    if is_scalar(repeats):\n\n        def rep(x):\n            try:\n                return compat.binary_type.__mul__(x, repeats)\n            except TypeError:\n                return compat.text_type.__mul__(x, repeats)\n\n        return _na_map(rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return compat.binary_type.__mul__(x, r)\n            except TypeError:\n                return compat.text_type.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com._values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    as_indexer\n        .. deprecated:: 0.21.0\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : analogous, but less strict, relying on re.search instead of\n        re.match\n    extract : extract matched groups\n\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    if (as_indexer is False) and (regex.groups > 0):\n        raise ValueError(\"as_indexer=False with a pattern with groups is no \"\n                         \"longer supported. Use '.str.extract(pat)' instead\")\n    elif as_indexer is not None:\n        # Previously, this keyword was used for changing the default but\n        # deprecated behaviour. This keyword is now no longer needed.\n        warnings.warn(\"'as_indexer' keyword was specified but is ignored \"\n                      \"(match now returns a boolean indexer by default), \"\n                      \"and will be removed in a future version.\",\n                      FutureWarning, stacklevel=3)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, compat.string_types):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, Index\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, Index):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object)\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object)\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat.\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    expand : bool, default True\n        * If True, return DataFrame.\n        * If False, return Series/Index/DataFrame.\n\n        .. versionadded:: 0.18.0\n\n    Returns\n    -------\n    DataFrame with one row for each subject string, and one column for\n    each group. Any capture group names in regular expression pat will\n    be used for column names; otherwise capture group numbers will be\n    used. The dtype of each result column is always object, even when\n    no match is found. If expand=False and pat has only one capture group,\n    then return a Series (if subject is a Series) or Index (if subject\n    is an Index).\n\n    See Also\n    --------\n    extractall : returns all matches (not just the first match)\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._data, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    Returns\n    -------\n    A DataFrame with one row for each match, and one column for each\n    group. Its rows have a MultiIndex with first levels that come from\n    the subject Series. The last level is named 'match' and indicates\n    the order in the subject. Any capture group names in regular\n    expression pat will be used for column names; otherwise capture\n    group numbers will be used.\n\n    See Also\n    --------\n    extract : returns first match only (not all matches)\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.iteritems():\n        if isinstance(subject, compat.string_types):\n\n            if not is_mi:\n                subject_key = (subject_key, )\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, compat.string_types):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group\n                            for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i, ))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n    index = MultiIndex.from_tuples(\n        index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index,\n                                        columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep='|'):\n    \"\"\"\n    Split each string in the Series by sep and return a frame of\n    dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : string, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    dummies : DataFrame\n\n    Examples\n    --------\n    >>> Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n\n    See Also\n    --------\n    pandas.get_dummies\n    \"\"\"\n    arr = arr.fillna('')\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - set([\"\"]))\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n\n    Notes\n    -----\n    If any of the lists does not contain string objects the result of the join\n    will be `NaN`.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Examples\n    --------\n\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat']\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using an '-', the lists containing object(s) of types other\n    than str will become a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Pattern or regular expression.\n    flags : int, default 0\n        ``re`` module flags, e.g. `re.IGNORECASE` (default is 0, which means\n        no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side='left'):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``\n\n    Returns\n    -------\n    found : Series/Index of integer values\n    \"\"\"\n\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'find'\n    elif side == 'right':\n        method = 'rfind'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side='left'):\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'index'\n    elif side == 'right':\n        method = 'rindex'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side='left', fillchar=' '):\n    \"\"\"\n    Pad strings in the Series/Index with an additional character to\n    specified side.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with spaces\n    side : {'left', 'right', 'both'}, default 'left'\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    padded : Series/Index of objects\n    \"\"\"\n\n    if not isinstance(fillchar, compat.string_types):\n        msg = 'fillchar must be a character, not {0}'\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError('fillchar must be a character, not str')\n\n    if not is_integer(width):\n        msg = 'width must be of integer type, not {0}'\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == 'left':\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == 'right':\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == 'both':\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n    \"\"\"\n    Split strings around given separator/delimiter.\n\n    Split each string in the caller's values by given\n    pattern, propagating NaN values. Equivalent to :meth:`str.split`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    See Also\n    --------\n    str.split : Standard library version of this method.\n    Series.str.get_dummies : Split each string into dummy variables.\n    Series.str.partition : Split string on a separator, returning\n        the before, separator, and after components.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\"])\n\n    By default, split will return an object of the same size\n    having lists containing the split elements\n\n    >>> s.str.split()\n    0           [this, is, good, text]\n    1    [but, this, is, even, better]\n    dtype: object\n    >>> s.str.split(\"random\")\n    0          [this is good text]\n    1    [but this is even better]\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns.\n\n    For Series object, output return type is DataFrame.\n\n    >>> s.str.split(expand=True)\n          0     1     2     3       4\n    0  this    is  good  text    None\n    1   but  this    is  even  better\n    >>> s.str.split(\" is \", expand=True)\n              0            1\n    0      this    good text\n    1  but this  even better\n\n    For Index object, output return type is MultiIndex.\n\n    >>> i = pd.Index([\"ba 100 001\", \"ba 101 002\", \"ba 102 003\"])\n    >>> i.str.split(expand=True)\n    MultiIndex(levels=[['ba'], ['100', '101', '102'], ['001', '002', '003']],\n           labels=[[0, 0, 0], [0, 1, 2], [0, 1, 2]])\n\n    Parameter `n` can be used to limit the number of splits in the output.\n\n    >>> s.str.split(\"is\", n=1)\n    0          [th,  is good text]\n    1    [but th,  is even better]\n    dtype: object\n    >>> s.str.split(\"is\", n=1, expand=True)\n            0                1\n    0      th     is good text\n    1  but th   is even better\n\n    If NaN is present, it is propagated throughout the columns\n    during the split.\n\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\", np.nan])\n    >>> s.str.split(n=3, expand=True)\n          0     1     2            3\n    0  this    is  good         text\n    1   but  this    is  even better\n    2   NaN   NaN   NaN          NaN\n    \"\"\"\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n    \"\"\"\n    Split each string in the Series/Index by the given delimiter\n    string, starting at the end of the string and working to the front.\n    Equivalent to :meth:`str.rsplit`.\n\n    Parameters\n    ----------\n    pat : string, default None\n        Separator to split on. If None, splits on whitespace\n    n : int, default -1 (all)\n        None, 0 and -1 will be interpreted as return all splits\n    expand : bool, default False\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : Series/Index or DataFrame/MultiIndex of objects\n    \"\"\"\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series/Index\n\n    Parameters\n    ----------\n    start : int or None\n    stop : int or None\n    step : int or None\n\n    Returns\n    -------\n    sliced : Series/Index of objects\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    replaced : Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = ''\n\n    def f(x):\n        if x[start:stop] == '':\n            local_stop = start\n        else:\n            local_stop = stop\n        y = ''\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side='both'):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\"\n    if side == 'both':\n        f = lambda x: x.strip(to_strip)\n    elif side == 'left':\n        f = lambda x: x.lstrip(to_strip)\n    elif side == 'right':\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line-width\n    expand_tabs : bool, optional\n        If true, tab characters will be expanded to spaces (default: True)\n    replace_whitespace : bool, optional\n        If true, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True)\n    drop_whitespace : bool, optional\n        If true, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True)\n    break_long_words : bool, optional\n        If true, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width. (default: True)\n    break_on_hyphens : bool, optional\n        If true, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words. (default: True)\n\n    Returns\n    -------\n    wrapped : Series/Index of objects\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    \"\"\"\n    kwargs['width'] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: '\\n'.join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table, deletechars=None):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`. Note that the optional\n    argument deletechars is only valid if you are using python 2. For python 3,\n    character deletion should be specified via the table argument.\n\n    Parameters\n    ----------\n    table : dict (python 3), str or None (python 2)\n        In python 3, table is a mapping of Unicode ordinals to Unicode\n        ordinals, strings, or None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n        In python 2, table is either a string of length 256 or None. If the\n        table argument is None, no translation is applied and the operation\n        simply removes the characters in deletechars. :func:`string.maketrans`\n        is a helper function for making translation tables.\n    deletechars : str, optional (python 2)\n        A string of characters to delete. This argument is only valid\n        in python 2.\n\n    Returns\n    -------\n    translated : Series/Index of objects\n    \"\"\"\n    if deletechars is None:\n        f = lambda x: x.translate(table)\n    else:\n        if compat.PY3:\n            raise ValueError(\"deletechars is not a valid argument for \"\n                             \"str.translate in python 3. You should simply \"\n                             \"specify character deletions in the table \"\n                             \"argument\")\n        f = lambda x: x.translate(table, deletechars)\n    return _na_map(f, arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    items : Series/Index of objects\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n               (1, 2, 3),\n               [\"a\", \"b\", \"c\"],\n               123, -456,\n               {1:\"Hello\", \"2\":\"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    NaN\n    dtype: object\n    \"\"\"\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    decoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef _noarg_wrapper(f, docstring=None, **kargs):\n    def wrapper(self):\n        result = _na_map(f, self._data, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError('Provide docstring')\n\n    return wrapper\n\n\ndef _pat_wrapper(f, flags=False, na=False, **kwargs):\n    def wrapper1(self, pat):\n        result = f(self._data, pat)\n        return self._wrap_result(result)\n\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._data, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._data, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._data = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        from pandas.core.index import Index\n\n        if (isinstance(data, ABCSeries) and\n                not ((is_categorical_dtype(data.dtype) and\n                      is_object_dtype(data.values.categories)) or\n                     (is_object_dtype(data.dtype)))):\n            # it's neither a string series not a categorical series with\n            # strings inside the categories.\n            # this really should exclude all series with any non-string values\n            # (instead of test for object dtype), but that isn't practical for\n            # performance reasons until we have a str dtype (GH 9343)\n            raise AttributeError(\"Can only use .str accessor with string \"\n                                 \"values, which use np.object_ dtype in \"\n                                 \"pandas\")\n        elif isinstance(data, Index):\n            # can't use ABCIndex to exclude non-str\n\n            # see src/inference.pyx which can contain string values\n            allowed_types = ('string', 'unicode', 'mixed', 'mixed-integer')\n            if is_categorical_dtype(data.dtype):\n                inf_type = data.categories.inferred_type\n            else:\n                inf_type = data.inferred_type\n            if inf_type not in allowed_types:\n                message = (\"Can only use .str accessor with string values \"\n                           \"(i.e. inferred_type is 'string', 'unicode' or \"\n                           \"'mixed')\")\n                raise AttributeError(message)\n            if data.nlevels > 1:\n                message = (\"Can only use .str accessor with Index, not \"\n                           \"MultiIndex\")\n                raise AttributeError(message)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(self, result, use_codes=True,\n                     name=None, expand=None):\n\n        from pandas.core.index import Index, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            result = take_1d(result, self._orig.cat.codes)\n\n        if not hasattr(result, 'ndim') or not hasattr(result, 'dtype'):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = False if result.ndim == 1 else True\n\n        elif expand is True and not isinstance(self._orig, Index):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [x * max_len if len(x) == 0 or x[0] is np.nan\n                          else x for x in result]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, 'name', None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, Index):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        others : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, np.ndarray (1-dim) or list-like\n        ignore_index : boolean, default False\n            Determines whether to forcefully align others with index of caller\n\n        Returns\n        -------\n        tuple : (others transformed into list of Series,\n                 boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Index, Series, DataFrame\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n\n        err_msg = ('others must be Series, Index, DataFrame, np.ndarrary or '\n                   'list-like (either containing only strings or containing '\n                   'only objects of type Series/Index/list-like/np.ndarray)')\n\n        # Generally speaking, all objects without an index inherit the index\n        # `idx` of the calling Series/Index - i.e. must have matching length.\n        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n        # index, *unless* ignore_index is set to True.\n        if isinstance(others, Series):\n            warn = not others.index.equals(idx)\n            # only reconstruct Series when absolutely necessary\n            los = [Series(others.values, index=idx)\n                   if ignore_index and warn else others]\n            return (los, warn)\n        elif isinstance(others, Index):\n            warn = not others.equals(idx)\n            los = [Series(others.values,\n                          index=(idx if ignore_index else others))]\n            return (los, warn)\n        elif isinstance(others, DataFrame):\n            warn = not others.index.equals(idx)\n            if ignore_index and warn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], warn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others):\n            others = list(others)  # ensure iterators do not get read twice etc\n\n            # in case of list-like `others`, all elements must be\n            # either one-dimensional list-likes or scalars\n            if all(is_list_like(x) for x in others):\n                los = []\n                warn = False\n                # iterate through list and append list of series for each\n                # element (which we check to be one-dimensional and non-nested)\n                while others:\n                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n                    if not isinstance(nxt, (DataFrame, Series,\n                                            Index, np.ndarray)):\n                        # safety for non-persistent list-likes (e.g. iterators)\n                        # do not map indexed/typed objects; info needed below\n                        nxt = list(nxt)\n\n                    # known types for which we can avoid deep inspection\n                    no_deep = ((isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                               or isinstance(nxt, (Series, Index)))\n                    # nested list-likes are forbidden:\n                    # -> elements of nxt must not be list-like\n                    is_legal = ((no_deep and nxt.dtype == object)\n                                or all(not is_list_like(x) for x in nxt))\n\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, wnx = self._get_series_list(nxt,\n                                                     ignore_index=ignore_index)\n                    los = los + nxt\n                    warn = warn or wnx\n                return (los, warn)\n            elif all(not is_list_like(x) for x in others):\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarrary or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            np.ndarray (1-dim) or list-like, then all elements will be unpacked\n            and must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : string or None, default None\n            If None, concatenates without any separator.\n        na_rep : string or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        concat : str if `other is None`, Series/Index of objects if `others is\n            not None`. In the latter case, the result will remain categorical\n            if the calling Series/Index is categorical.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join=None, na_rep='-')\n        0    ad\n        1    ba\n        2    -e\n        3    dc\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, compat.string_types):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n\n        if isinstance(self._orig, Index):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            result = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n            return self._wrap_result(result,\n                                     use_codes=(not self._is_categorical))\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, warn = self._get_series_list(others,\n                                                 ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError('All arrays must be same length, except '\n                                 'those having an index if `join` is not None')\n            else:\n                raise ValueError('If `others` contains arrays or lists (or '\n                                 'other list-likes without an index), these '\n                                 'must all be of the same length as the '\n                                 'calling Series/Index.')\n\n        if join is None and warn:\n            warnings.warn(\"A future version of pandas will perform index \"\n                          \"alignment when `others` is a Series/Index/\"\n                          \"DataFrame (or a list-like containing one). To \"\n                          \"disable alignment (the behavior before v.0.23) and \"\n                          \"silence this warning, use `.values` on any Series/\"\n                          \"Index/DataFrame in `others`. To enable alignment \"\n                          \"and silence this warning, pass `join='left'|\"\n                          \"'outer'|'inner'|'right'`. The future default will \"\n                          \"be `join='left'`.\", FutureWarning, stacklevel=2)\n\n        # align if required\n        if join is not None:\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(others, axis=1,\n                            join=(join if join == 'inner' else 'outer'),\n                            keys=range(len(others)))\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        # str_cat discards index\n        res = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n\n        if isinstance(self._orig, Index):\n            res = Index(res)\n        else:  # Series\n            res = Series(res, index=data.index)\n        return res\n\n    @copy(str_split)\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_rsplit)\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs['str_partition'] = (\"\"\"\n    Split the string at the %(side)s occurrence of `sep`, and return 3 elements\n    containing the part before the separator, the separator itself,\n    and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    pat : string, default whitespace\n        String to split on.\n    expand : bool, default True\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n\n    Examples\n    --------\n\n    >>> s = Series(['A_B_C', 'D_E_F', 'X'])\n    0    A_B_C\n    1    D_E_F\n    2        X\n    dtype: object\n\n    >>> s.str.partition('_')\n       0  1    2\n    0  A  _  B_C\n    1  D  _  E_F\n    2  X\n\n    >>> s.str.rpartition('_')\n         0  1  2\n    0  A_B  _  C\n    1  D_E  _  F\n    2          X\n    \"\"\")\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'first',\n        'return': '3 elements containing the string itself, followed by two '\n                  'empty strings',\n        'also': 'rpartition : Split the string at the last occurrence of `sep`'\n    })\n    def partition(self, pat=' ', expand=True):\n        f = lambda x: x.partition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'last',\n        'return': '3 elements containing two empty strings, followed by the '\n                  'string itself',\n        'also': 'partition : Split the string at the first occurrence of `sep`'\n    })\n    def rpartition(self, pat=' ', expand=True):\n        f = lambda x: x.rpartition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._data, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    def join(self, sep):\n        result = str_join(self._data, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(self._data, pat, case=case, flags=flags, na=na,\n                              regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_match)\n    def match(self, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n        result = str_match(self._data, pat, case=case, flags=flags, na=na,\n                           as_indexer=as_indexer)\n        return self._wrap_result(result)\n\n    @copy(str_replace)\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(self._data, pat, repl, n=n, case=case,\n                             flags=flags, regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    def repeat(self, repeats):\n        result = str_repeat(self._data, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    def pad(self, width, side='left', fillchar=' '):\n        result = str_pad(self._data, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs['str_pad'] = (\"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left and right',\n                                             method='center'))\n    def center(self, width, fillchar=' '):\n        return self.pad(width, side='both', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='right', method='ljust'))\n    def ljust(self, width, fillchar=' '):\n        return self.pad(width, side='right', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left', method='rjust'))\n    def rjust(self, width, fillchar=' '):\n        return self.pad(width, side='left', fillchar=fillchar)\n\n    def zfill(self, width):\n        \"\"\"\n        Filling left side of strings in the Series/Index with 0.\n        Equivalent to :meth:`str.zfill`.\n\n        Parameters\n        ----------\n        width : int\n            Minimum width of resulting string; additional characters will be\n            filled with 0\n\n        Returns\n        -------\n        filled : Series/Index of objects\n        \"\"\"\n        result = str_pad(self._data, width, side='left', fillchar='0')\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._data, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._data, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        result = str_decode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs['str_strip'] = (\"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index from %(side)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left and right sides',\n                                               method='strip'))\n    def strip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='both')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left side',\n                                               method='lstrip'))\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='right side',\n                                               method='rstrip'))\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='right')\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._data, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    def get_dummies(self, sep='|'):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._data\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(result, use_codes=(not self._is_categorical),\n                                 name=name, expand=True)\n\n    @copy(str_translate)\n    def translate(self, table, deletechars=None):\n        result = str_translate(self._data, table, deletechars)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True)\n    startswith = _pat_wrapper(str_startswith, na=True)\n    endswith = _pat_wrapper(str_endswith, na=True)\n    findall = _pat_wrapper(str_findall, flags=True)\n\n    @copy(str_extract)\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs['find'] = (\"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['find'] %\n              dict(side='lowest', method='find',\n                   also='rfind : Return highest indexes in each strings'))\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['find'] %\n              dict(side='highest', method='rfind',\n                   also='find : Return lowest indexes in each strings'))\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    def normalize(self, form):\n        \"\"\"Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n        f = lambda x: unicodedata.normalize(form, compat.u_safe(x))\n        result = _na_map(f, self._data)\n        return self._wrap_result(result)\n\n    _shared_docs['index'] = (\"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['index'] %\n              dict(side='lowest', similar='find', method='index',\n                   also='rindex : Return highest indexes in each strings'))\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['index'] %\n              dict(side='highest', similar='rfind', method='rindex',\n                   also='index : Return lowest indexes in each strings'))\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    _shared_docs['len'] = (\"\"\"\n    Compute length of each string in the Series/Index.\n\n    Returns\n    -------\n    lengths : Series/Index of integer values\n    \"\"\")\n    len = _noarg_wrapper(len, docstring=_shared_docs['len'], dtype=int)\n\n    _shared_docs['casemethods'] = (\"\"\"\n    Convert strings in the Series/Index to %(type)s.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\")\n    _shared_docs['lower'] = dict(type='lowercase', method='lower')\n    _shared_docs['upper'] = dict(type='uppercase', method='upper')\n    _shared_docs['title'] = dict(type='titlecase', method='title')\n    _shared_docs['capitalize'] = dict(type='be capitalized',\n                                      method='capitalize')\n    _shared_docs['swapcase'] = dict(type='be swapcased', method='swapcase')\n    lower = _noarg_wrapper(lambda x: x.lower(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['lower'])\n    upper = _noarg_wrapper(lambda x: x.upper(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['upper'])\n    title = _noarg_wrapper(lambda x: x.title(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['title'])\n    capitalize = _noarg_wrapper(lambda x: x.capitalize(),\n                                docstring=_shared_docs['casemethods'] %\n                                _shared_docs['capitalize'])\n    swapcase = _noarg_wrapper(lambda x: x.swapcase(),\n                              docstring=_shared_docs['casemethods'] %\n                              _shared_docs['swapcase'])\n\n    _shared_docs['ismethods'] = (\"\"\"\n    Check whether all characters in each string in the Series/Index\n    are %(type)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    is : Series/array of boolean values\n    \"\"\")\n    _shared_docs['isalnum'] = dict(type='alphanumeric', method='isalnum')\n    _shared_docs['isalpha'] = dict(type='alphabetic', method='isalpha')\n    _shared_docs['isdigit'] = dict(type='digits', method='isdigit')\n    _shared_docs['isspace'] = dict(type='whitespace', method='isspace')\n    _shared_docs['islower'] = dict(type='lowercase', method='islower')\n    _shared_docs['isupper'] = dict(type='uppercase', method='isupper')\n    _shared_docs['istitle'] = dict(type='titlecase', method='istitle')\n    _shared_docs['isnumeric'] = dict(type='numeric', method='isnumeric')\n    _shared_docs['isdecimal'] = dict(type='decimal', method='isdecimal')\n    isalnum = _noarg_wrapper(lambda x: x.isalnum(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalnum'])\n    isalpha = _noarg_wrapper(lambda x: x.isalpha(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalpha'])\n    isdigit = _noarg_wrapper(lambda x: x.isdigit(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isdigit'])\n    isspace = _noarg_wrapper(lambda x: x.isspace(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isspace'])\n    islower = _noarg_wrapper(lambda x: x.islower(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['islower'])\n    isupper = _noarg_wrapper(lambda x: x.isupper(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isupper'])\n    istitle = _noarg_wrapper(lambda x: x.istitle(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['istitle'])\n    isnumeric = _noarg_wrapper(lambda x: compat.u_safe(x).isnumeric(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isnumeric'])\n    isdecimal = _noarg_wrapper(lambda x: compat.u_safe(x).isdecimal(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isdecimal'])\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_patch": "@@ -1943,21 +1943,21 @@ class StringMethods(NoNewAttributesMixin):\n \n         Parameters\n         ----------\n-        input : Series, DataFrame, np.ndarray, list-like or list-like of\n+        others : Series, DataFrame, np.ndarray, list-like or list-like of\n             objects that are either Series, np.ndarray (1-dim) or list-like\n         ignore_index : boolean, default False\n-            Determines whether to forcefully align with index of the caller\n+            Determines whether to forcefully align others with index of caller\n \n         Returns\n         -------\n-        tuple : (input transformed into list of Series,\n-                 Boolean whether FutureWarning should be raised)\n+        tuple : (others transformed into list of Series,\n+                 boolean whether FutureWarning should be raised)\n         \"\"\"\n \n         # once str.cat defaults to alignment, this function can be simplified;\n         # will not need `ignore_index` and the second boolean output anymore\n \n-        from pandas import Index, Series, DataFrame, isnull\n+        from pandas import Index, Series, DataFrame\n \n         # self._orig is either Series or Index\n         idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n@@ -1966,66 +1966,69 @@ class StringMethods(NoNewAttributesMixin):\n                    'list-like (either containing only strings or containing '\n                    'only objects of type Series/Index/list-like/np.ndarray)')\n \n+        # Generally speaking, all objects without an index inherit the index\n+        # `idx` of the calling Series/Index - i.e. must have matching length.\n+        # Objects with an index (i.e. Series/Index/DataFrame) keep their own\n+        # index, *unless* ignore_index is set to True.\n         if isinstance(others, Series):\n-            fu_wrn = not others.index.equals(idx)\n+            warn = not others.index.equals(idx)\n+            # only reconstruct Series when absolutely necessary\n             los = [Series(others.values, index=idx)\n-                   if ignore_index and fu_wrn else others]\n-            return (los, fu_wrn)\n+                   if ignore_index and warn else others]\n+            return (los, warn)\n         elif isinstance(others, Index):\n-            fu_wrn = not others.equals(idx)\n+            warn = not others.equals(idx)\n             los = [Series(others.values,\n                           index=(idx if ignore_index else others))]\n-            return (los, fu_wrn)\n+            return (los, warn)\n         elif isinstance(others, DataFrame):\n-            fu_wrn = not others.index.equals(idx)\n-            if ignore_index and fu_wrn:\n+            warn = not others.index.equals(idx)\n+            if ignore_index and warn:\n                 # without copy, this could change \"others\"\n                 # that was passed to str.cat\n                 others = others.copy()\n                 others.index = idx\n-            return ([others[x] for x in others], fu_wrn)\n+            return ([others[x] for x in others], warn)\n         elif isinstance(others, np.ndarray) and others.ndim == 2:\n             others = DataFrame(others, index=idx)\n             return ([others[x] for x in others], False)\n         elif is_list_like(others):\n             others = list(others)  # ensure iterators do not get read twice etc\n+\n+            # in case of list-like `others`, all elements must be\n+            # either one-dimensional list-likes or scalars\n             if all(is_list_like(x) for x in others):\n                 los = []\n-                fu_wrn = False\n+                warn = False\n+                # iterate through list and append list of series for each\n+                # element (which we check to be one-dimensional and non-nested)\n                 while others:\n-                    nxt = others.pop(0)  # list-like as per check above\n-                    # safety for iterators and other non-persistent list-likes\n-                    # do not map indexed/typed objects; would lose information\n+                    nxt = others.pop(0)  # nxt is guaranteed list-like by above\n                     if not isinstance(nxt, (DataFrame, Series,\n                                             Index, np.ndarray)):\n+                        # safety for non-persistent list-likes (e.g. iterators)\n+                        # do not map indexed/typed objects; info needed below\n                         nxt = list(nxt)\n \n-                    # known types without deep inspection\n+                    # known types for which we can avoid deep inspection\n                     no_deep = ((isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                                or isinstance(nxt, (Series, Index)))\n-                    # Nested list-likes are forbidden - elements of nxt must be\n-                    # strings/NaN/None. Need to robustify NaN-check against\n-                    # x in nxt being list-like (otherwise ambiguous boolean)\n+                    # nested list-likes are forbidden:\n+                    # -> elements of nxt must not be list-like\n                     is_legal = ((no_deep and nxt.dtype == object)\n-                                or all((isinstance(x, compat.string_types)\n-                                        or (not is_list_like(x) and isnull(x))\n-                                        or x is None)\n-                                       for x in nxt))\n+                                or all(not is_list_like(x) for x in nxt))\n+\n                     # DataFrame is false positive of is_legal\n                     # because \"x in df\" returns column names\n                     if not is_legal or isinstance(nxt, DataFrame):\n                         raise TypeError(err_msg)\n \n-                    nxt, fwn = self._get_series_list(nxt,\n+                    nxt, wnx = self._get_series_list(nxt,\n                                                      ignore_index=ignore_index)\n                     los = los + nxt\n-                    fu_wrn = fu_wrn or fwn\n-                return (los, fu_wrn)\n-            # test if there is a mix of list-like and non-list-like (e.g. str)\n-            elif (any(is_list_like(x) for x in others)\n-                  and any(not is_list_like(x) for x in others)):\n-                raise TypeError(err_msg)\n-            else:  # all elements in others are _not_ list-like\n+                    warn = warn or wnx\n+                return (los, warn)\n+            elif all(not is_list_like(x) for x in others):\n                 return ([Series(others, index=idx)], False)\n         raise TypeError(err_msg)\n \n@@ -2187,8 +2190,8 @@ class StringMethods(NoNewAttributesMixin):\n \n         try:\n             # turn anything in \"others\" into lists of Series\n-            others, fu_wrn = self._get_series_list(others,\n-                                                   ignore_index=(join is None))\n+            others, warn = self._get_series_list(others,\n+                                                 ignore_index=(join is None))\n         except ValueError:  # do not catch TypeError raised by _get_series_list\n             if join is None:\n                 raise ValueError('All arrays must be same length, except '\n@@ -2199,7 +2202,7 @@ class StringMethods(NoNewAttributesMixin):\n                                  'must all be of the same length as the '\n                                  'calling Series/Index.')\n \n-        if join is None and fu_wrn:\n+        if join is None and warn:\n             warnings.warn(\"A future version of pandas will perform index \"\n                           \"alignment when `others` is a Series/Index/\"\n                           \"DataFrame (or a list-like containing one). To \"\n",
          "files_name_in_blame_commit": [
            "strings.py"
          ]
        }
      },
      "f851699cf086ca7d6011061031c959bcc39d1e71": {
        "commit": {
          "commit_id": "f851699cf086ca7d6011061031c959bcc39d1e71",
          "commit_message": "API: str.cat will align on Series (#20347)",
          "commit_author": "h-vetinari",
          "commit_date": "2018-05-02 06:13:35",
          "commit_parent": "3471b9809b6432aaab9426864b8777630a19ec7d"
        },
        "function": {
          "function_name": "_get_series_list",
          "function_code_before": "",
          "function_code_after": "def _get_series_list(self, others, ignore_index=False):\n    \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        input : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, np.ndarray (1-dim) or list-like\n        ignore_index : boolean, default False\n            Determines whether to forcefully align with index of the caller\n\n        Returns\n        -------\n        tuple : (input transformed into list of Series,\n                 Boolean whether FutureWarning should be raised)\n        \"\"\"\n    from pandas import Index, Series, DataFrame, isnull\n    idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n    err_msg = 'others must be Series, Index, DataFrame, np.ndarrary or list-like (either containing only strings or containing only objects of type Series/Index/list-like/np.ndarray)'\n    if isinstance(others, Series):\n        fu_wrn = not others.index.equals(idx)\n        los = [Series(others.values, index=idx) if ignore_index and fu_wrn else others]\n        return (los, fu_wrn)\n    elif isinstance(others, Index):\n        fu_wrn = not others.equals(idx)\n        los = [Series(others.values, index=idx if ignore_index else others)]\n        return (los, fu_wrn)\n    elif isinstance(others, DataFrame):\n        fu_wrn = not others.index.equals(idx)\n        if ignore_index and fu_wrn:\n            others = others.copy()\n            others.index = idx\n        return ([others[x] for x in others], fu_wrn)\n    elif isinstance(others, np.ndarray) and others.ndim == 2:\n        others = DataFrame(others, index=idx)\n        return ([others[x] for x in others], False)\n    elif is_list_like(others):\n        others = list(others)\n        if all((is_list_like(x) for x in others)):\n            los = []\n            fu_wrn = False\n            while others:\n                nxt = others.pop(0)\n                if not isinstance(nxt, (DataFrame, Series, Index, np.ndarray)):\n                    nxt = list(nxt)\n                no_deep = isinstance(nxt, np.ndarray) and nxt.ndim == 1 or isinstance(nxt, (Series, Index))\n                is_legal = no_deep and nxt.dtype == object or all((isinstance(x, compat.string_types) or (not is_list_like(x) and isnull(x)) or x is None for x in nxt))\n                if not is_legal or isinstance(nxt, DataFrame):\n                    raise TypeError(err_msg)\n                (nxt, fwn) = self._get_series_list(nxt, ignore_index=ignore_index)\n                los = los + nxt\n                fu_wrn = fu_wrn or fwn\n            return (los, fu_wrn)\n        elif any((is_list_like(x) for x in others)) and any((not is_list_like(x) for x in others)):\n            raise TypeError(err_msg)\n        else:\n            return ([Series(others, index=idx)], False)\n    raise TypeError(err_msg)",
          "function_before_start_line": "",
          "function_before_end_line": "",
          "function_after_start_line": 1938,
          "function_after_end_line": 2030,
          "function_before_token_count": 0,
          "function_after_token_count": 477,
          "functions_name_modified_file": [
            "str_endswith",
            "rsplit",
            "str_encode",
            "str_get",
            "translate",
            "lstrip",
            "str_pad",
            "_make_accessor",
            "str_count",
            "str_rsplit",
            "rjust",
            "rindex",
            "str_slice",
            "str_slice_replace",
            "__getitem__",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "get_dummies",
            "contains",
            "match",
            "wrap",
            "str_extract",
            "str_translate",
            "_length_check",
            "_noarg_wrapper",
            "partition",
            "_na_map",
            "_validate",
            "_get_array_list",
            "zfill",
            "_groups_or_na_fun",
            "str_replace",
            "str_join",
            "str_decode",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "normalize",
            "str_find",
            "_map",
            "str_cat",
            "slice_replace",
            "rpartition",
            "decode",
            "ljust",
            "encode",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "center",
            "find",
            "str_repeat",
            "__iter__",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "get",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "str_split",
            "_get_series_list",
            "join",
            "str_wrap",
            "str_match",
            "cat"
          ],
          "functions_name_all_files": [
            "test_get_dummies_with_name_dummy",
            "test_extractall_same_as_extract",
            "str_endswith",
            "test_extractall_single_group",
            "test_strip_lstrip_rstrip_args",
            "rsplit",
            "str_encode",
            "str_get",
            "test_extract_expand_None",
            "translate",
            "test_len",
            "lstrip",
            "test_replace_compiled_regex",
            "test_extractall_no_matches",
            "test_match_findall_flags",
            "str_pad",
            "_make_accessor",
            "str_count",
            "test_lower_upper",
            "test_str_cat_special_cases",
            "str_rsplit",
            "test_casemethods",
            "test_pipe_failures",
            "rjust",
            "test_iter",
            "rindex",
            "test_join",
            "str_slice",
            "test_strip_lstrip_rstrip_unicode",
            "test_get",
            "str_slice_replace",
            "test_encode_decode",
            "test_cat_on_filtered_index",
            "test_str_cat_categorical",
            "__getitem__",
            "test_capitalize",
            "test_split_no_pat_with_nonzero_n",
            "__init__",
            "_pat_wrapper",
            "slice",
            "extractall",
            "str_extractall",
            "test_extractall",
            "get_dummies",
            "test_extract_expand_unspecified",
            "test_rsplit_to_multiindex_expand",
            "test_extractall_same_as_extract_subject_index",
            "contains",
            "test_str_cat_raises_intuitive_error",
            "test_str_cat",
            "test_pad",
            "test_method_on_bytes",
            "test_more_replace",
            "test_match",
            "test_split_blank_string",
            "match",
            "test_cat",
            "test_contains",
            "test_extract_expand_True",
            "wrap",
            "test_contains_nan",
            "str_extract",
            "str_translate",
            "test_center_ljust_rjust_fillchar",
            "_length_check",
            "test_pad_width",
            "_noarg_wrapper",
            "test_rsplit",
            "test_more_contains",
            "test_extractall_single_group_with_quantifier",
            "test_empty_str_methods_to_frame",
            "test_swapcase",
            "test_replace_literal",
            "test_strip_lstrip_rstrip_mixed",
            "test_iter_single_element",
            "test_translate",
            "partition",
            "test_wrap",
            "test_str_cat_align_mixed_inputs",
            "test_get_dummies",
            "_na_map",
            "test_title",
            "test_extract_index_one_two_groups",
            "test_center_ljust_rjust",
            "test_replace",
            "test_count",
            "test_index_str_accessor_visibility",
            "_validate",
            "test_split_noargs",
            "_get_array_list",
            "test_get_complex",
            "test_pad_fillchar",
            "zfill",
            "test_extract_series",
            "test_zfill",
            "test_extract_optional_groups",
            "_groups_or_na_fun",
            "test_find_nan",
            "str_replace",
            "str_join",
            "str_decode",
            "test_split_to_multiindex_expand",
            "test_replace_callable",
            "_get_single_group_name",
            "str_strip",
            "_str_extract_noexpand",
            "test_iter_object_try_string",
            "test_strip_lstrip_rstrip_args_unicode",
            "test_empty_str_methods",
            "test_str_accessor_no_new_attributes",
            "test_encode_decode_errors",
            "test_partition_to_dataframe",
            "test_split",
            "test_split_maxsplit",
            "normalize",
            "test_partition_series",
            "test_strip_lstrip_rstrip",
            "str_find",
            "_map",
            "test_extract_single_group_returns_frame",
            "str_cat",
            "test_repeat",
            "slice_replace",
            "test_api",
            "rpartition",
            "decode",
            "test_rsplit_to_dataframe_expand",
            "ljust",
            "encode",
            "test_endswith",
            "test_slice",
            "test_split_with_name",
            "assert_series_or_index_equal",
            "test_slice_replace",
            "str_index",
            "str_startswith",
            "split",
            "str_findall",
            "copy",
            "pad",
            "test_partition_with_name",
            "test_str_cat_align_indexed",
            "extract",
            "rfind",
            "_str_extract_frame",
            "rstrip",
            "test_iter_empty",
            "test_extractall_errors",
            "center",
            "find",
            "test_ismethods",
            "test_string_slice_out_of_bounds",
            "str_repeat",
            "test_split_nan_expand",
            "test_extract_expand_False",
            "test_normalize",
            "__iter__",
            "test_extractall_stringindex",
            "test_find",
            "str_contains",
            "strip",
            "index",
            "repeat",
            "test_get_complex_nested",
            "test_findall",
            "get",
            "test_string_slice_get_syntax",
            "_wrap_result",
            "str_get_dummies",
            "replace",
            "test_isnumeric",
            "str_split",
            "_get_series_list",
            "join",
            "test_str_cat_mixed_inputs",
            "str_wrap",
            "test_split_to_dataframe",
            "test_partition_index",
            "str_match",
            "test_index",
            "cat",
            "test_startswith"
          ],
          "functions_name_co_evolved_modified_file": [
            "__init__",
            "str_cat",
            "_length_check",
            "_validate",
            "cat"
          ],
          "functions_name_co_evolved_all_files": [
            "__init__",
            "test_str_cat_categorical",
            "test_method_on_bytes",
            "test_str_cat_align_mixed_inputs",
            "test_str_cat_mixed_inputs",
            "test_str_cat",
            "test_cat",
            "test_str_cat_special_cases",
            "test_empty_str_methods",
            "test_str_cat_align_indexed",
            "str_cat",
            "test_cat_on_filtered_index",
            "test_str_cat_raises_intuitive_error",
            "_length_check",
            "_validate",
            "cat",
            "assert_series_or_index_equal"
          ]
        },
        "file": {
          "file_name": "strings.py",
          "file_nloc": 1424,
          "file_complexity": 297,
          "file_token_count": 7615,
          "file_before": "import numpy as np\n\nfrom pandas.compat import zip\nfrom pandas.core.dtypes.generic import ABCSeries, ABCIndex\nfrom pandas.core.dtypes.missing import isna, notna\nfrom pandas.core.dtypes.common import (\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_object_dtype,\n    is_string_like,\n    is_list_like,\n    is_scalar,\n    is_integer,\n    is_re)\n\nimport pandas.core.common as com\nfrom pandas.core.algorithms import take_1d\nimport pandas.compat as compat\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.util._decorators import Appender\nimport re\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nimport warnings\nimport textwrap\nimport codecs\n\n_cpython_optimized_encoders = (\n    \"utf-8\", \"utf8\", \"latin-1\", \"latin1\", \"iso-8859-1\", \"mbcs\", \"ascii\"\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\n    \"utf-16\", \"utf-32\"\n)\n\n_shared_docs = dict()\n\n\ndef _get_array_list(arr, others):\n    \"\"\"\n    Auxiliary function for :func:`str_cat`\n\n    Parameters\n    ----------\n    arr : ndarray\n        The left-most ndarray of the concatenation\n    others : list, ndarray, Series\n        The rest of the content to concatenate. If list of list-likes,\n        all elements must be passable to ``np.asarray``.\n\n    Returns\n    -------\n    list\n        List of all necessary arrays\n    \"\"\"\n    from pandas.core.series import Series\n\n    if len(others) and isinstance(com._values_from_object(others)[0],\n                                  (list, np.ndarray, Series)):\n        arrays = [arr] + list(others)\n    else:\n        arrays = [arr, others]\n\n    return [np.asarray(x, dtype=object) for x in arrays]\n\n\ndef str_cat(arr, others=None, sep=None, na_rep=None):\n    \"\"\"\n    Concatenate strings in the Series/Index with given separator.\n\n    If `others` is specified, this function concatenates the Series/Index\n    and elements of `others` element-wise.\n    If `others` is not being passed then all values in the Series are\n    concatenated in a single string with a given `sep`.\n\n    Parameters\n    ----------\n    others : list-like, or list of list-likes, optional\n        List-likes (or a list of them) of the same length as calling object.\n        If None, returns str concatenating strings of the Series.\n    sep : string or None, default None\n        If None, concatenates without any separator.\n    na_rep : string or None, default None\n        If None, NA in the series are ignored.\n\n    Returns\n    -------\n    concat : Series/Index of objects or str\n\n    See Also\n    --------\n    split : Split each string in the Series/Index\n\n    Examples\n    --------\n    When not passing `other`, all values are concatenated into a single\n    string:\n\n    >>> s = pd.Series(['a', 'b', np.nan, 'c'])\n    >>> s.str.cat(sep=' ')\n    'a b c'\n\n    By default, NA values in the Series are ignored. Using `na_rep`, they\n    can be given a representation:\n\n    >>> pd.Series(['a', 'b', np.nan, 'c']).str.cat(sep=' ', na_rep='?')\n    'a b ? c'\n\n    If `others` is specified, corresponding values are\n    concatenated with the separator. Result will be a Series of strings.\n\n    >>> pd.Series(['a', 'b', 'c']).str.cat(['A', 'B', 'C'], sep=',')\n    0    a,A\n    1    b,B\n    2    c,C\n    dtype: object\n\n    Also, you can pass a list of list-likes.\n\n    >>> pd.Series(['a', 'b']).str.cat([['x', 'y'], ['1', '2']], sep=',')\n    0    a,x,1\n    1    b,y,2\n    dtype: object\n    \"\"\"\n    if sep is None:\n        sep = ''\n\n    if others is not None:\n        arrays = _get_array_list(arr, others)\n\n        n = _length_check(arrays)\n        masks = np.array([isna(x) for x in arrays])\n        cats = None\n\n        if na_rep is None:\n            na_mask = np.logical_or.reduce(masks, axis=0)\n\n            result = np.empty(n, dtype=object)\n            np.putmask(result, na_mask, np.nan)\n\n            notmask = ~na_mask\n\n            tuples = zip(*[x[notmask] for x in arrays])\n            cats = [sep.join(tup) for tup in tuples]\n\n            result[notmask] = cats\n        else:\n            for i, x in enumerate(arrays):\n                x = np.where(masks[i], na_rep, x)\n                if cats is None:\n                    cats = x\n                else:\n                    cats = cats + sep + x\n\n            result = cats\n\n        return result\n    else:\n        arr = np.asarray(arr, dtype=object)\n        mask = isna(arr)\n        if na_rep is None and mask.any():\n            if sep == '':\n                na_rep = ''\n            else:\n                return sep.join(arr[notna(arr)])\n        return sep.join(np.where(mask, na_rep, arr))\n\n\ndef _length_check(others):\n    n = None\n    for x in others:\n        try:\n            if n is None:\n                n = len(x)\n            elif len(x) != n:\n                raise ValueError('All arrays must be same length')\n        except TypeError:\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n    return n\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            if compat.PY2:\n                p_err = r'takes (no|(exactly|at (least|most)) ?\\d+) arguments?'\n            else:\n                p_err = (r'((takes)|(missing)) (?(2)from \\d+ to )?\\d+ '\n                         r'(?(3)required )positional arguments?')\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatability with other string methods. Not used.\n\n    Returns\n    -------\n    counts : Series or Index\n        Same type as the calling object containing the integer counts.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Return boolean Series/``array`` whether given pattern/regex is\n    contained in each string in the Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    regex : bool, default True\n        If True use re.search, otherwise use Python in operator\n\n    Returns\n    -------\n    contained : Series/array of boolean values\n\n    See Also\n    --------\n    match : analogous, but stricter, relying on re.match instead of re.search\n\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\"This pattern has match groups. To actually get the\"\n                          \" groups, use str.extract.\", UserWarning,\n                          stacklevel=3)\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : string or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : string or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start\n    case : boolean, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : boolean, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    replaced : Series/Index of objects\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\"case and flags cannot be set\"\n                                 \" when pat is a compiled regex\")\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\"Cannot use a compiled regex as replacement \"\n                             \"pattern with regex=False\")\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \"\n                             \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series/Index by indicated number\n    of times.\n\n    Parameters\n    ----------\n    repeats : int or array\n        Same value for all (int) or different value per (array)\n\n    Returns\n    -------\n    repeated : Series/Index of objects\n    \"\"\"\n    if is_scalar(repeats):\n\n        def rep(x):\n            try:\n                return compat.binary_type.__mul__(x, repeats)\n            except TypeError:\n                return compat.text_type.__mul__(x, repeats)\n\n        return _na_map(rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return compat.binary_type.__mul__(x, r)\n            except TypeError:\n                return compat.text_type.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com._values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    as_indexer\n        .. deprecated:: 0.21.0\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : analogous, but less strict, relying on re.search instead of\n        re.match\n    extract : extract matched groups\n\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    if (as_indexer is False) and (regex.groups > 0):\n        raise ValueError(\"as_indexer=False with a pattern with groups is no \"\n                         \"longer supported. Use '.str.extract(pat)' instead\")\n    elif as_indexer is not None:\n        # Previously, this keyword was used for changing the default but\n        # deprecated behaviour. This keyword is now no longer needed.\n        warnings.warn(\"'as_indexer' keyword was specified but is ignored \"\n                      \"(match now returns a boolean indexer by default), \"\n                      \"and will be removed in a future version.\",\n                      FutureWarning, stacklevel=3)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, compat.string_types):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, Index\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, Index):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object)\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object)\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat.\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    expand : bool, default True\n        * If True, return DataFrame.\n        * If False, return Series/Index/DataFrame.\n\n        .. versionadded:: 0.18.0\n\n    Returns\n    -------\n    DataFrame with one row for each subject string, and one column for\n    each group. Any capture group names in regular expression pat will\n    be used for column names; otherwise capture group numbers will be\n    used. The dtype of each result column is always object, even when\n    no match is found. If expand=False and pat has only one capture group,\n    then return a Series (if subject is a Series) or Index (if subject\n    is an Index).\n\n    See Also\n    --------\n    extractall : returns all matches (not just the first match)\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._data, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    Returns\n    -------\n    A DataFrame with one row for each match, and one column for each\n    group. Its rows have a MultiIndex with first levels that come from\n    the subject Series. The last level is named 'match' and indicates\n    the order in the subject. Any capture group names in regular\n    expression pat will be used for column names; otherwise capture\n    group numbers will be used.\n\n    See Also\n    --------\n    extract : returns first match only (not all matches)\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.iteritems():\n        if isinstance(subject, compat.string_types):\n\n            if not is_mi:\n                subject_key = (subject_key, )\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, compat.string_types):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group\n                            for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i, ))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n    index = MultiIndex.from_tuples(\n        index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index,\n                                        columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep='|'):\n    \"\"\"\n    Split each string in the Series by sep and return a frame of\n    dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : string, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    dummies : DataFrame\n\n    Examples\n    --------\n    >>> Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n\n    See Also\n    --------\n    pandas.get_dummies\n    \"\"\"\n    arr = arr.fillna('')\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - set([\"\"]))\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n\n    Notes\n    -----\n    If any of the lists does not contain string objects the result of the join\n    will be `NaN`.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Examples\n    --------\n\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat']\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using an '-', the lists containing object(s) of types other\n    than str will become a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Pattern or regular expression.\n    flags : int, default 0\n        ``re`` module flags, e.g. `re.IGNORECASE` (default is 0, which means\n        no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side='left'):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``\n\n    Returns\n    -------\n    found : Series/Index of integer values\n    \"\"\"\n\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'find'\n    elif side == 'right':\n        method = 'rfind'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side='left'):\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'index'\n    elif side == 'right':\n        method = 'rindex'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side='left', fillchar=' '):\n    \"\"\"\n    Pad strings in the Series/Index with an additional character to\n    specified side.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with spaces\n    side : {'left', 'right', 'both'}, default 'left'\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    padded : Series/Index of objects\n    \"\"\"\n\n    if not isinstance(fillchar, compat.string_types):\n        msg = 'fillchar must be a character, not {0}'\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError('fillchar must be a character, not str')\n\n    if not is_integer(width):\n        msg = 'width must be of integer type, not {0}'\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == 'left':\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == 'right':\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == 'both':\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n    \"\"\"\n    Split strings around given separator/delimiter.\n\n    Split each string in the caller's values by given\n    pattern, propagating NaN values. Equivalent to :meth:`str.split`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    See Also\n    --------\n    str.split : Standard library version of this method.\n    Series.str.get_dummies : Split each string into dummy variables.\n    Series.str.partition : Split string on a separator, returning\n        the before, separator, and after components.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\"])\n\n    By default, split will return an object of the same size\n    having lists containing the split elements\n\n    >>> s.str.split()\n    0           [this, is, good, text]\n    1    [but, this, is, even, better]\n    dtype: object\n    >>> s.str.split(\"random\")\n    0          [this is good text]\n    1    [but this is even better]\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns.\n\n    For Series object, output return type is DataFrame.\n\n    >>> s.str.split(expand=True)\n          0     1     2     3       4\n    0  this    is  good  text    None\n    1   but  this    is  even  better\n    >>> s.str.split(\" is \", expand=True)\n              0            1\n    0      this    good text\n    1  but this  even better\n\n    For Index object, output return type is MultiIndex.\n\n    >>> i = pd.Index([\"ba 100 001\", \"ba 101 002\", \"ba 102 003\"])\n    >>> i.str.split(expand=True)\n    MultiIndex(levels=[['ba'], ['100', '101', '102'], ['001', '002', '003']],\n           labels=[[0, 0, 0], [0, 1, 2], [0, 1, 2]])\n\n    Parameter `n` can be used to limit the number of splits in the output.\n\n    >>> s.str.split(\"is\", n=1)\n    0          [th,  is good text]\n    1    [but th,  is even better]\n    dtype: object\n    >>> s.str.split(\"is\", n=1, expand=True)\n            0                1\n    0      th     is good text\n    1  but th   is even better\n\n    If NaN is present, it is propagated throughout the columns\n    during the split.\n\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\", np.nan])\n    >>> s.str.split(n=3, expand=True)\n          0     1     2            3\n    0  this    is  good         text\n    1   but  this    is  even better\n    2   NaN   NaN   NaN          NaN\n    \"\"\"\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n    \"\"\"\n    Split each string in the Series/Index by the given delimiter\n    string, starting at the end of the string and working to the front.\n    Equivalent to :meth:`str.rsplit`.\n\n    Parameters\n    ----------\n    pat : string, default None\n        Separator to split on. If None, splits on whitespace\n    n : int, default -1 (all)\n        None, 0 and -1 will be interpreted as return all splits\n    expand : bool, default False\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : Series/Index or DataFrame/MultiIndex of objects\n    \"\"\"\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series/Index\n\n    Parameters\n    ----------\n    start : int or None\n    stop : int or None\n    step : int or None\n\n    Returns\n    -------\n    sliced : Series/Index of objects\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    replaced : Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = ''\n\n    def f(x):\n        if x[start:stop] == '':\n            local_stop = start\n        else:\n            local_stop = stop\n        y = ''\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side='both'):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\"\n    if side == 'both':\n        f = lambda x: x.strip(to_strip)\n    elif side == 'left':\n        f = lambda x: x.lstrip(to_strip)\n    elif side == 'right':\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line-width\n    expand_tabs : bool, optional\n        If true, tab characters will be expanded to spaces (default: True)\n    replace_whitespace : bool, optional\n        If true, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True)\n    drop_whitespace : bool, optional\n        If true, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True)\n    break_long_words : bool, optional\n        If true, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width. (default: True)\n    break_on_hyphens : bool, optional\n        If true, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words. (default: True)\n\n    Returns\n    -------\n    wrapped : Series/Index of objects\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    \"\"\"\n    kwargs['width'] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: '\\n'.join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table, deletechars=None):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`. Note that the optional\n    argument deletechars is only valid if you are using python 2. For python 3,\n    character deletion should be specified via the table argument.\n\n    Parameters\n    ----------\n    table : dict (python 3), str or None (python 2)\n        In python 3, table is a mapping of Unicode ordinals to Unicode\n        ordinals, strings, or None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n        In python 2, table is either a string of length 256 or None. If the\n        table argument is None, no translation is applied and the operation\n        simply removes the characters in deletechars. :func:`string.maketrans`\n        is a helper function for making translation tables.\n    deletechars : str, optional (python 2)\n        A string of characters to delete. This argument is only valid\n        in python 2.\n\n    Returns\n    -------\n    translated : Series/Index of objects\n    \"\"\"\n    if deletechars is None:\n        f = lambda x: x.translate(table)\n    else:\n        if compat.PY3:\n            raise ValueError(\"deletechars is not a valid argument for \"\n                             \"str.translate in python 3. You should simply \"\n                             \"specify character deletions in the table \"\n                             \"argument\")\n        f = lambda x: x.translate(table, deletechars)\n    return _na_map(f, arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    items : Series/Index of objects\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n               (1, 2, 3),\n               [\"a\", \"b\", \"c\"],\n               123, -456,\n               {1:\"Hello\", \"2\":\"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    NaN\n    dtype: object\n    \"\"\"\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    decoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef _noarg_wrapper(f, docstring=None, **kargs):\n    def wrapper(self):\n        result = _na_map(f, self._data, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError('Provide docstring')\n\n    return wrapper\n\n\ndef _pat_wrapper(f, flags=False, na=False, **kwargs):\n    def wrapper1(self, pat):\n        result = f(self._data, pat)\n        return self._wrap_result(result)\n\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._data, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._data, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n        self._data = data.cat.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        from pandas.core.index import Index\n\n        if (isinstance(data, ABCSeries) and\n                not ((is_categorical_dtype(data.dtype) and\n                      is_object_dtype(data.values.categories)) or\n                     (is_object_dtype(data.dtype)))):\n            # it's neither a string series not a categorical series with\n            # strings inside the categories.\n            # this really should exclude all series with any non-string values\n            # (instead of test for object dtype), but that isn't practical for\n            # performance reasons until we have a str dtype (GH 9343)\n            raise AttributeError(\"Can only use .str accessor with string \"\n                                 \"values, which use np.object_ dtype in \"\n                                 \"pandas\")\n        elif isinstance(data, Index):\n            # can't use ABCIndex to exclude non-str\n\n            # see src/inference.pyx which can contain string values\n            allowed_types = ('string', 'unicode', 'mixed', 'mixed-integer')\n            if data.inferred_type not in allowed_types:\n                message = (\"Can only use .str accessor with string values \"\n                           \"(i.e. inferred_type is 'string', 'unicode' or \"\n                           \"'mixed')\")\n                raise AttributeError(message)\n            if data.nlevels > 1:\n                message = (\"Can only use .str accessor with Index, not \"\n                           \"MultiIndex\")\n                raise AttributeError(message)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(self, result, use_codes=True,\n                     name=None, expand=None):\n\n        from pandas.core.index import Index, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            result = take_1d(result, self._orig.cat.codes)\n\n        if not hasattr(result, 'ndim') or not hasattr(result, 'dtype'):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = False if result.ndim == 1 else True\n\n        elif expand is True and not isinstance(self._orig, Index):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [x * max_len if len(x) == 0 or x[0] is np.nan\n                          else x for x in result]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, 'name', None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, Index):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    @copy(str_cat)\n    def cat(self, others=None, sep=None, na_rep=None):\n        data = self._orig if self._is_categorical else self._data\n        result = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n        return self._wrap_result(result, use_codes=(not self._is_categorical))\n\n    @copy(str_split)\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_rsplit)\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs['str_partition'] = (\"\"\"\n    Split the string at the %(side)s occurrence of `sep`, and return 3 elements\n    containing the part before the separator, the separator itself,\n    and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    pat : string, default whitespace\n        String to split on.\n    expand : bool, default True\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n\n    Examples\n    --------\n\n    >>> s = Series(['A_B_C', 'D_E_F', 'X'])\n    0    A_B_C\n    1    D_E_F\n    2        X\n    dtype: object\n\n    >>> s.str.partition('_')\n       0  1    2\n    0  A  _  B_C\n    1  D  _  E_F\n    2  X\n\n    >>> s.str.rpartition('_')\n         0  1  2\n    0  A_B  _  C\n    1  D_E  _  F\n    2          X\n    \"\"\")\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'first',\n        'return': '3 elements containing the string itself, followed by two '\n                  'empty strings',\n        'also': 'rpartition : Split the string at the last occurrence of `sep`'\n    })\n    def partition(self, pat=' ', expand=True):\n        f = lambda x: x.partition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'last',\n        'return': '3 elements containing two empty strings, followed by the '\n                  'string itself',\n        'also': 'partition : Split the string at the first occurrence of `sep`'\n    })\n    def rpartition(self, pat=' ', expand=True):\n        f = lambda x: x.rpartition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._data, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    def join(self, sep):\n        result = str_join(self._data, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(self._data, pat, case=case, flags=flags, na=na,\n                              regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_match)\n    def match(self, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n        result = str_match(self._data, pat, case=case, flags=flags, na=na,\n                           as_indexer=as_indexer)\n        return self._wrap_result(result)\n\n    @copy(str_replace)\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(self._data, pat, repl, n=n, case=case,\n                             flags=flags, regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    def repeat(self, repeats):\n        result = str_repeat(self._data, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    def pad(self, width, side='left', fillchar=' '):\n        result = str_pad(self._data, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs['str_pad'] = (\"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left and right',\n                                             method='center'))\n    def center(self, width, fillchar=' '):\n        return self.pad(width, side='both', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='right', method='ljust'))\n    def ljust(self, width, fillchar=' '):\n        return self.pad(width, side='right', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left', method='rjust'))\n    def rjust(self, width, fillchar=' '):\n        return self.pad(width, side='left', fillchar=fillchar)\n\n    def zfill(self, width):\n        \"\"\"\n        Filling left side of strings in the Series/Index with 0.\n        Equivalent to :meth:`str.zfill`.\n\n        Parameters\n        ----------\n        width : int\n            Minimum width of resulting string; additional characters will be\n            filled with 0\n\n        Returns\n        -------\n        filled : Series/Index of objects\n        \"\"\"\n        result = str_pad(self._data, width, side='left', fillchar='0')\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._data, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._data, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        result = str_decode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs['str_strip'] = (\"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index from %(side)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left and right sides',\n                                               method='strip'))\n    def strip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='both')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left side',\n                                               method='lstrip'))\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='right side',\n                                               method='rstrip'))\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='right')\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._data, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    def get_dummies(self, sep='|'):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._data\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(result, use_codes=(not self._is_categorical),\n                                 name=name, expand=True)\n\n    @copy(str_translate)\n    def translate(self, table, deletechars=None):\n        result = str_translate(self._data, table, deletechars)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True)\n    startswith = _pat_wrapper(str_startswith, na=True)\n    endswith = _pat_wrapper(str_endswith, na=True)\n    findall = _pat_wrapper(str_findall, flags=True)\n\n    @copy(str_extract)\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs['find'] = (\"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['find'] %\n              dict(side='lowest', method='find',\n                   also='rfind : Return highest indexes in each strings'))\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['find'] %\n              dict(side='highest', method='rfind',\n                   also='find : Return lowest indexes in each strings'))\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    def normalize(self, form):\n        \"\"\"Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n        f = lambda x: unicodedata.normalize(form, compat.u_safe(x))\n        result = _na_map(f, self._data)\n        return self._wrap_result(result)\n\n    _shared_docs['index'] = (\"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['index'] %\n              dict(side='lowest', similar='find', method='index',\n                   also='rindex : Return highest indexes in each strings'))\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['index'] %\n              dict(side='highest', similar='rfind', method='rindex',\n                   also='index : Return lowest indexes in each strings'))\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    _shared_docs['len'] = (\"\"\"\n    Compute length of each string in the Series/Index.\n\n    Returns\n    -------\n    lengths : Series/Index of integer values\n    \"\"\")\n    len = _noarg_wrapper(len, docstring=_shared_docs['len'], dtype=int)\n\n    _shared_docs['casemethods'] = (\"\"\"\n    Convert strings in the Series/Index to %(type)s.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\")\n    _shared_docs['lower'] = dict(type='lowercase', method='lower')\n    _shared_docs['upper'] = dict(type='uppercase', method='upper')\n    _shared_docs['title'] = dict(type='titlecase', method='title')\n    _shared_docs['capitalize'] = dict(type='be capitalized',\n                                      method='capitalize')\n    _shared_docs['swapcase'] = dict(type='be swapcased', method='swapcase')\n    lower = _noarg_wrapper(lambda x: x.lower(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['lower'])\n    upper = _noarg_wrapper(lambda x: x.upper(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['upper'])\n    title = _noarg_wrapper(lambda x: x.title(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['title'])\n    capitalize = _noarg_wrapper(lambda x: x.capitalize(),\n                                docstring=_shared_docs['casemethods'] %\n                                _shared_docs['capitalize'])\n    swapcase = _noarg_wrapper(lambda x: x.swapcase(),\n                              docstring=_shared_docs['casemethods'] %\n                              _shared_docs['swapcase'])\n\n    _shared_docs['ismethods'] = (\"\"\"\n    Check whether all characters in each string in the Series/Index\n    are %(type)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    is : Series/array of boolean values\n    \"\"\")\n    _shared_docs['isalnum'] = dict(type='alphanumeric', method='isalnum')\n    _shared_docs['isalpha'] = dict(type='alphabetic', method='isalpha')\n    _shared_docs['isdigit'] = dict(type='digits', method='isdigit')\n    _shared_docs['isspace'] = dict(type='whitespace', method='isspace')\n    _shared_docs['islower'] = dict(type='lowercase', method='islower')\n    _shared_docs['isupper'] = dict(type='uppercase', method='isupper')\n    _shared_docs['istitle'] = dict(type='titlecase', method='istitle')\n    _shared_docs['isnumeric'] = dict(type='numeric', method='isnumeric')\n    _shared_docs['isdecimal'] = dict(type='decimal', method='isdecimal')\n    isalnum = _noarg_wrapper(lambda x: x.isalnum(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalnum'])\n    isalpha = _noarg_wrapper(lambda x: x.isalpha(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalpha'])\n    isdigit = _noarg_wrapper(lambda x: x.isdigit(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isdigit'])\n    isspace = _noarg_wrapper(lambda x: x.isspace(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isspace'])\n    islower = _noarg_wrapper(lambda x: x.islower(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['islower'])\n    isupper = _noarg_wrapper(lambda x: x.isupper(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isupper'])\n    istitle = _noarg_wrapper(lambda x: x.istitle(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['istitle'])\n    isnumeric = _noarg_wrapper(lambda x: compat.u_safe(x).isnumeric(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isnumeric'])\n    isdecimal = _noarg_wrapper(lambda x: compat.u_safe(x).isdecimal(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isdecimal'])\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_after": "import numpy as np\n\nfrom pandas.compat import zip\nfrom pandas.core.dtypes.generic import ABCSeries, ABCIndex\nfrom pandas.core.dtypes.missing import isna, notna\nfrom pandas.core.dtypes.common import (\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_object_dtype,\n    is_string_like,\n    is_list_like,\n    is_scalar,\n    is_integer,\n    is_re)\n\nimport pandas.core.common as com\nfrom pandas.core.algorithms import take_1d\nimport pandas.compat as compat\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.util._decorators import Appender\nimport re\nimport pandas._libs.lib as lib\nimport pandas._libs.ops as libops\nimport warnings\nimport textwrap\nimport codecs\n\n_cpython_optimized_encoders = (\n    \"utf-8\", \"utf8\", \"latin-1\", \"latin1\", \"iso-8859-1\", \"mbcs\", \"ascii\"\n)\n_cpython_optimized_decoders = _cpython_optimized_encoders + (\n    \"utf-16\", \"utf-32\"\n)\n\n_shared_docs = dict()\n\n\ndef _get_array_list(arr, others):\n    \"\"\"\n    Auxiliary function for :func:`str_cat`\n\n    Parameters\n    ----------\n    arr : ndarray\n        The left-most ndarray of the concatenation\n    others : list, ndarray, Series\n        The rest of the content to concatenate. If list of list-likes,\n        all elements must be passable to ``np.asarray``.\n\n    Returns\n    -------\n    list\n        List of all necessary arrays\n    \"\"\"\n    from pandas.core.series import Series\n\n    if len(others) and isinstance(com._values_from_object(others)[0],\n                                  (list, np.ndarray, Series)):\n        arrays = [arr] + list(others)\n    else:\n        arrays = [arr, others]\n\n    return [np.asarray(x, dtype=object) for x in arrays]\n\n\ndef str_cat(arr, others=None, sep=None, na_rep=None):\n    \"\"\"\n    Auxiliary function for :meth:`str.cat`\n\n    If `others` is specified, this function concatenates the Series/Index\n    and elements of `others` element-wise.\n    If `others` is not being passed then all values in the Series are\n    concatenated in a single string with a given `sep`.\n\n    Parameters\n    ----------\n    others : list-like, or list of list-likes, optional\n        List-likes (or a list of them) of the same length as calling object.\n        If None, returns str concatenating strings of the Series.\n    sep : string or None, default None\n        If None, concatenates without any separator.\n    na_rep : string or None, default None\n        If None, NA in the series are ignored.\n\n    Returns\n    -------\n    concat\n        ndarray containing concatenated results (if `others is not None`)\n        or str (if `others is None`)\n    \"\"\"\n    if sep is None:\n        sep = ''\n\n    if others is not None:\n        arrays = _get_array_list(arr, others)\n\n        n = _length_check(arrays)\n        masks = np.array([isna(x) for x in arrays])\n        cats = None\n\n        if na_rep is None:\n            na_mask = np.logical_or.reduce(masks, axis=0)\n\n            result = np.empty(n, dtype=object)\n            np.putmask(result, na_mask, np.nan)\n\n            notmask = ~na_mask\n\n            tuples = zip(*[x[notmask] for x in arrays])\n            cats = [sep.join(tup) for tup in tuples]\n\n            result[notmask] = cats\n        else:\n            for i, x in enumerate(arrays):\n                x = np.where(masks[i], na_rep, x)\n                if cats is None:\n                    cats = x\n                else:\n                    cats = cats + sep + x\n\n            result = cats\n\n        return result\n    else:\n        arr = np.asarray(arr, dtype=object)\n        mask = isna(arr)\n        if na_rep is None and mask.any():\n            if sep == '':\n                na_rep = ''\n            else:\n                return sep.join(arr[notna(arr)])\n        return sep.join(np.where(mask, na_rep, arr))\n\n\ndef _length_check(others):\n    n = None\n    for x in others:\n        try:\n            if n is None:\n                n = len(x)\n            elif len(x) != n:\n                raise ValueError('All arrays must be same length')\n        except TypeError:\n            raise ValueError('Must pass arrays containing strings to str_cat')\n    return n\n\n\ndef _na_map(f, arr, na_result=np.nan, dtype=object):\n    # should really _check_ for NA\n    return _map(f, arr, na_mask=True, na_value=na_result, dtype=dtype)\n\n\ndef _map(f, arr, na_mask=False, na_value=np.nan, dtype=object):\n    if not len(arr):\n        return np.ndarray(0, dtype=dtype)\n\n    if isinstance(arr, ABCSeries):\n        arr = arr.values\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr, dtype=object)\n    if na_mask:\n        mask = isna(arr)\n        try:\n            convert = not all(mask)\n            result = lib.map_infer_mask(arr, f, mask.view(np.uint8), convert)\n        except (TypeError, AttributeError) as e:\n            # Reraise the exception if callable `f` got wrong number of args.\n            # The user may want to be warned by this, instead of getting NaN\n            if compat.PY2:\n                p_err = r'takes (no|(exactly|at (least|most)) ?\\d+) arguments?'\n            else:\n                p_err = (r'((takes)|(missing)) (?(2)from \\d+ to )?\\d+ '\n                         r'(?(3)required )positional arguments?')\n\n            if len(e.args) >= 1 and re.search(p_err, e.args[0]):\n                raise e\n\n            def g(x):\n                try:\n                    return f(x)\n                except (TypeError, AttributeError):\n                    return na_value\n\n            return _map(g, arr, dtype=dtype)\n        if na_value is not np.nan:\n            np.putmask(result, mask, na_value)\n            if result.dtype == object:\n                result = lib.maybe_convert_objects(result)\n        return result\n    else:\n        return lib.map_infer(arr, f)\n\n\ndef str_count(arr, pat, flags=0):\n    \"\"\"\n    Count occurrences of pattern in each string of the Series/Index.\n\n    This function is used to count the number of times a particular regex\n    pattern is repeated in each of the string elements of the\n    :class:`~pandas.Series`.\n\n    Parameters\n    ----------\n    pat : str\n        Valid regular expression.\n    flags : int, default 0, meaning no flags\n        Flags for the `re` module. For a complete list, `see here\n        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.\n    **kwargs\n        For compatability with other string methods. Not used.\n\n    Returns\n    -------\n    counts : Series or Index\n        Same type as the calling object containing the integer counts.\n\n    Notes\n    -----\n    Some characters need to be escaped when passing in `pat`.\n    eg. ``'$'`` has a special meaning in regex and must be escaped when\n    finding this literal character.\n\n    See Also\n    --------\n    re : Standard library module for regular expressions.\n    str.count : Standard library version, without regular expression support.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])\n    >>> s.str.count('a')\n    0    0.0\n    1    0.0\n    2    2.0\n    3    2.0\n    4    NaN\n    5    0.0\n    6    1.0\n    dtype: float64\n\n    Escape ``'$'`` to find the literal dollar sign.\n\n    >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])\n    >>> s.str.count('\\$')\n    0    1\n    1    0\n    2    1\n    3    2\n    4    2\n    5    0\n    dtype: int64\n\n    This is also available on Index\n\n    >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')\n    Int64Index([0, 0, 2, 1], dtype='int64')\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    f = lambda x: len(regex.findall(x))\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):\n    \"\"\"\n    Return boolean Series/``array`` whether given pattern/regex is\n    contained in each string in the Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    regex : bool, default True\n        If True use re.search, otherwise use Python in operator\n\n    Returns\n    -------\n    contained : Series/array of boolean values\n\n    See Also\n    --------\n    match : analogous, but stricter, relying on re.match instead of re.search\n\n    \"\"\"\n    if regex:\n        if not case:\n            flags |= re.IGNORECASE\n\n        regex = re.compile(pat, flags=flags)\n\n        if regex.groups > 0:\n            warnings.warn(\"This pattern has match groups. To actually get the\"\n                          \" groups, use str.extract.\", UserWarning,\n                          stacklevel=3)\n\n        f = lambda x: bool(regex.search(x))\n    else:\n        if case:\n            f = lambda x: pat in x\n        else:\n            upper_pat = pat.upper()\n            f = lambda x: upper_pat in x\n            uppered = _na_map(lambda x: x.upper(), arr)\n            return _na_map(f, uppered, na, dtype=bool)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_startswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the start of each string element matches a pattern.\n\n    Equivalent to :meth:`str.startswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the start of each string element.\n\n    See Also\n    --------\n    str.startswith : Python standard library string method.\n    Series.str.endswith : Same as startswith, but tests the end of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])\n    >>> s\n    0     bat\n    1    Bear\n    2     cat\n    3     NaN\n    dtype: object\n\n    >>> s.str.startswith('b')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.startswith('b', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.startswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_endswith(arr, pat, na=np.nan):\n    \"\"\"\n    Test if the end of each string element matches a pattern.\n\n    Equivalent to :meth:`str.endswith`.\n\n    Parameters\n    ----------\n    pat : str\n        Character sequence. Regular expressions are not accepted.\n    na : object, default NaN\n        Object shown if element tested is not a string.\n\n    Returns\n    -------\n    Series or Index of bool\n        A Series of booleans indicating whether the given pattern matches\n        the end of each string element.\n\n    See Also\n    --------\n    str.endswith : Python standard library string method.\n    Series.str.startswith : Same as endswith, but tests the start of string.\n    Series.str.contains : Tests if string element contains a pattern.\n\n    Examples\n    --------\n    >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])\n    >>> s\n    0     bat\n    1    bear\n    2     caT\n    3     NaN\n    dtype: object\n\n    >>> s.str.endswith('t')\n    0     True\n    1    False\n    2    False\n    3      NaN\n    dtype: object\n\n    Specifying `na` to be `False` instead of `NaN`.\n\n    >>> s.str.endswith('t', na=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    dtype: bool\n    \"\"\"\n    f = lambda x: x.endswith(pat)\n    return _na_map(f, arr, na, dtype=bool)\n\n\ndef str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):\n    r\"\"\"\n    Replace occurrences of pattern/regex in the Series/Index with\n    some other string. Equivalent to :meth:`str.replace` or\n    :func:`re.sub`.\n\n    Parameters\n    ----------\n    pat : string or compiled regex\n        String can be a character sequence or regular expression.\n\n        .. versionadded:: 0.20.0\n            `pat` also accepts a compiled regex.\n\n    repl : string or callable\n        Replacement string or a callable. The callable is passed the regex\n        match object and must return a replacement string to be used.\n        See :func:`re.sub`.\n\n        .. versionadded:: 0.20.0\n            `repl` also accepts a callable.\n\n    n : int, default -1 (all)\n        Number of replacements to make from start\n    case : boolean, default None\n        - If True, case sensitive (the default if `pat` is a string)\n        - Set to False for case insensitive\n        - Cannot be set if `pat` is a compiled regex\n    flags : int, default 0 (no flags)\n        - re module flags, e.g. re.IGNORECASE\n        - Cannot be set if `pat` is a compiled regex\n    regex : boolean, default True\n        - If True, assumes the passed-in pattern is a regular expression.\n        - If False, treats the pattern as a literal string\n        - Cannot be set to False if `pat` is a compiled regex or `repl` is\n          a callable.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    replaced : Series/Index of objects\n\n    Raises\n    ------\n    ValueError\n        * if `regex` is False and `repl` is a callable or `pat` is a compiled\n          regex\n        * if `pat` is a compiled regex and `case` or `flags` is set\n\n    Notes\n    -----\n    When `pat` is a compiled regex, all flags should be included in the\n    compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled\n    regex will raise an error.\n\n    Examples\n    --------\n    When `pat` is a string and `regex` is True (the default), the given `pat`\n    is compiled as a regex. When `repl` is a string, it replaces matching\n    regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are\n    left as is:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)\n    0    bao\n    1    baz\n    2    NaN\n    dtype: object\n\n    When `pat` is a string and `regex` is False, every `pat` is replaced with\n    `repl` as with :meth:`str.replace`:\n\n    >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)\n    0    bao\n    1    fuz\n    2    NaN\n    dtype: object\n\n    When `repl` is a callable, it is called on every `pat` using\n    :func:`re.sub`. The callable should expect one positional argument\n    (a regex object) and return a string.\n\n    To get the idea:\n\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)\n    0    <_sre.SRE_Match object; span=(0, 1), match='f'>oo\n    1    <_sre.SRE_Match object; span=(0, 1), match='f'>uz\n    2                                                  NaN\n    dtype: object\n\n    Reverse every lowercase alphabetic word:\n\n    >>> repl = lambda m: m.group(0)[::-1]\n    >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)\n    0    oof 123\n    1    rab zab\n    2        NaN\n    dtype: object\n\n    Using regex groups (extract second group and swap case):\n\n    >>> pat = r\"(?P<one>\\w+) (?P<two>\\w+) (?P<three>\\w+)\"\n    >>> repl = lambda m: m.group('two').swapcase()\n    >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)\n    0    tWO\n    1    bAR\n    dtype: object\n\n    Using a compiled regex with flags\n\n    >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)\n    >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')\n    0    foo\n    1    bar\n    2    NaN\n    dtype: object\n\n    \"\"\"\n\n    # Check whether repl is valid (GH 13438, GH 15055)\n    if not (is_string_like(repl) or callable(repl)):\n        raise TypeError(\"repl must be a string or callable\")\n\n    is_compiled_re = is_re(pat)\n    if regex:\n        if is_compiled_re:\n            if (case is not None) or (flags != 0):\n                raise ValueError(\"case and flags cannot be set\"\n                                 \" when pat is a compiled regex\")\n        else:\n            # not a compiled regex\n            # set default case\n            if case is None:\n                case = True\n\n            # add case flag, if provided\n            if case is False:\n                flags |= re.IGNORECASE\n        if is_compiled_re or len(pat) > 1 or flags or callable(repl):\n            n = n if n >= 0 else 0\n            compiled = re.compile(pat, flags=flags)\n            f = lambda x: compiled.sub(repl=repl, string=x, count=n)\n        else:\n            f = lambda x: x.replace(pat, repl, n)\n    else:\n        if is_compiled_re:\n            raise ValueError(\"Cannot use a compiled regex as replacement \"\n                             \"pattern with regex=False\")\n        if callable(repl):\n            raise ValueError(\"Cannot use a callable replacement when \"\n                             \"regex=False\")\n        f = lambda x: x.replace(pat, repl, n)\n\n    return _na_map(f, arr)\n\n\ndef str_repeat(arr, repeats):\n    \"\"\"\n    Duplicate each string in the Series/Index by indicated number\n    of times.\n\n    Parameters\n    ----------\n    repeats : int or array\n        Same value for all (int) or different value per (array)\n\n    Returns\n    -------\n    repeated : Series/Index of objects\n    \"\"\"\n    if is_scalar(repeats):\n\n        def rep(x):\n            try:\n                return compat.binary_type.__mul__(x, repeats)\n            except TypeError:\n                return compat.text_type.__mul__(x, repeats)\n\n        return _na_map(rep, arr)\n    else:\n\n        def rep(x, r):\n            try:\n                return compat.binary_type.__mul__(x, r)\n            except TypeError:\n                return compat.text_type.__mul__(x, r)\n\n        repeats = np.asarray(repeats, dtype=object)\n        result = libops.vec_binop(com._values_from_object(arr), repeats, rep)\n        return result\n\n\ndef str_match(arr, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n    \"\"\"\n    Determine if each string matches a regular expression.\n\n    Parameters\n    ----------\n    pat : string\n        Character sequence or regular expression\n    case : boolean, default True\n        If True, case sensitive\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n    na : default NaN, fill value for missing values.\n    as_indexer\n        .. deprecated:: 0.21.0\n\n    Returns\n    -------\n    Series/array of boolean values\n\n    See Also\n    --------\n    contains : analogous, but less strict, relying on re.search instead of\n        re.match\n    extract : extract matched groups\n\n    \"\"\"\n    if not case:\n        flags |= re.IGNORECASE\n\n    regex = re.compile(pat, flags=flags)\n\n    if (as_indexer is False) and (regex.groups > 0):\n        raise ValueError(\"as_indexer=False with a pattern with groups is no \"\n                         \"longer supported. Use '.str.extract(pat)' instead\")\n    elif as_indexer is not None:\n        # Previously, this keyword was used for changing the default but\n        # deprecated behaviour. This keyword is now no longer needed.\n        warnings.warn(\"'as_indexer' keyword was specified but is ignored \"\n                      \"(match now returns a boolean indexer by default), \"\n                      \"and will be removed in a future version.\",\n                      FutureWarning, stacklevel=3)\n\n    dtype = bool\n    f = lambda x: bool(regex.match(x))\n\n    return _na_map(f, arr, na, dtype=dtype)\n\n\ndef _get_single_group_name(rx):\n    try:\n        return list(rx.groupindex.keys()).pop()\n    except IndexError:\n        return None\n\n\ndef _groups_or_na_fun(regex):\n    \"\"\"Used in both extract_noexpand and extract_frame\"\"\"\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n    empty_row = [np.nan] * regex.groups\n\n    def f(x):\n        if not isinstance(x, compat.string_types):\n            return empty_row\n        m = regex.search(x)\n        if m:\n            return [np.nan if item is None else item for item in m.groups()]\n        else:\n            return empty_row\n    return f\n\n\ndef _str_extract_noexpand(arr, pat, flags=0):\n    \"\"\"\n    Find groups in each string in the Series using passed regular\n    expression. This function is called from\n    str_extract(expand=False), and can return Series, DataFrame, or\n    Index.\n\n    \"\"\"\n    from pandas import DataFrame, Index\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n\n    if regex.groups == 1:\n        result = np.array([groups_or_na(val)[0] for val in arr], dtype=object)\n        name = _get_single_group_name(regex)\n    else:\n        if isinstance(arr, Index):\n            raise ValueError(\"only one regex group is supported with Index\")\n        name = None\n        names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n        columns = [names.get(1 + i, i) for i in range(regex.groups)]\n        if arr.empty:\n            result = DataFrame(columns=columns, dtype=object)\n        else:\n            result = DataFrame(\n                [groups_or_na(val) for val in arr],\n                columns=columns,\n                index=arr.index,\n                dtype=object)\n    return result, name\n\n\ndef _str_extract_frame(arr, pat, flags=0):\n    \"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat. This function is called from\n    str_extract(expand=True), and always returns a DataFrame.\n\n    \"\"\"\n    from pandas import DataFrame\n\n    regex = re.compile(pat, flags=flags)\n    groups_or_na = _groups_or_na_fun(regex)\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n\n    if len(arr) == 0:\n        return DataFrame(columns=columns, dtype=object)\n    try:\n        result_index = arr.index\n    except AttributeError:\n        result_index = None\n    return DataFrame(\n        [groups_or_na(val) for val in arr],\n        columns=columns,\n        index=result_index,\n        dtype=object)\n\n\ndef str_extract(arr, pat, flags=0, expand=True):\n    r\"\"\"\n    For each subject string in the Series, extract groups from the\n    first match of regular expression pat.\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    expand : bool, default True\n        * If True, return DataFrame.\n        * If False, return Series/Index/DataFrame.\n\n        .. versionadded:: 0.18.0\n\n    Returns\n    -------\n    DataFrame with one row for each subject string, and one column for\n    each group. Any capture group names in regular expression pat will\n    be used for column names; otherwise capture group numbers will be\n    used. The dtype of each result column is always object, even when\n    no match is found. If expand=False and pat has only one capture group,\n    then return a Series (if subject is a Series) or Index (if subject\n    is an Index).\n\n    See Also\n    --------\n    extractall : returns all matches (not just the first match)\n\n    Examples\n    --------\n    A pattern with two groups will return a DataFrame with two columns.\n    Non-matches will be NaN.\n\n    >>> s = Series(['a1', 'b2', 'c3'])\n    >>> s.str.extract(r'([ab])(\\d)')\n         0    1\n    0    a    1\n    1    b    2\n    2  NaN  NaN\n\n    A pattern may contain optional groups.\n\n    >>> s.str.extract(r'([ab])?(\\d)')\n         0  1\n    0    a  1\n    1    b  2\n    2  NaN  3\n\n    Named groups will become column names in the result.\n\n    >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\\d)')\n      letter digit\n    0      a     1\n    1      b     2\n    2    NaN   NaN\n\n    A pattern with one group will return a DataFrame with one column\n    if expand=True.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=True)\n         0\n    0    1\n    1    2\n    2  NaN\n\n    A pattern with one group will return a Series if expand=False.\n\n    >>> s.str.extract(r'[ab](\\d)', expand=False)\n    0      1\n    1      2\n    2    NaN\n    dtype: object\n\n    \"\"\"\n    if not isinstance(expand, bool):\n        raise ValueError(\"expand must be True or False\")\n    if expand:\n        return _str_extract_frame(arr._orig, pat, flags=flags)\n    else:\n        result, name = _str_extract_noexpand(arr._data, pat, flags=flags)\n        return arr._wrap_result(result, name=name, expand=expand)\n\n\ndef str_extractall(arr, pat, flags=0):\n    r\"\"\"\n    For each subject string in the Series, extract groups from all\n    matches of regular expression pat. When each subject string in the\n    Series has exactly one match, extractall(pat).xs(0, level='match')\n    is the same as extract(pat).\n\n    .. versionadded:: 0.18.0\n\n    Parameters\n    ----------\n    pat : string\n        Regular expression pattern with capturing groups\n    flags : int, default 0 (no flags)\n        re module flags, e.g. re.IGNORECASE\n\n    Returns\n    -------\n    A DataFrame with one row for each match, and one column for each\n    group. Its rows have a MultiIndex with first levels that come from\n    the subject Series. The last level is named 'match' and indicates\n    the order in the subject. Any capture group names in regular\n    expression pat will be used for column names; otherwise capture\n    group numbers will be used.\n\n    See Also\n    --------\n    extract : returns first match only (not all matches)\n\n    Examples\n    --------\n    A pattern with one group will return a DataFrame with one column.\n    Indices with no matches will not appear in the result.\n\n    >>> s = Series([\"a1a2\", \"b1\", \"c1\"], index=[\"A\", \"B\", \"C\"])\n    >>> s.str.extractall(r\"[ab](\\d)\")\n             0\n      match\n    A 0      1\n      1      2\n    B 0      1\n\n    Capture group names are used for column names of the result.\n\n    >>> s.str.extractall(r\"[ab](?P<digit>\\d)\")\n            digit\n      match\n    A 0         1\n      1         2\n    B 0         1\n\n    A pattern with two groups will return a DataFrame with two columns.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n\n    Optional groups that do not match are NaN in the result.\n\n    >>> s.str.extractall(r\"(?P<letter>[ab])?(?P<digit>\\d)\")\n            letter digit\n      match\n    A 0          a     1\n      1          a     2\n    B 0          b     1\n    C 0        NaN     1\n\n    \"\"\"\n\n    regex = re.compile(pat, flags=flags)\n    # the regex must contain capture groups.\n    if regex.groups == 0:\n        raise ValueError(\"pattern contains no capture groups\")\n\n    if isinstance(arr, ABCIndex):\n        arr = arr.to_series().reset_index(drop=True)\n\n    names = dict(zip(regex.groupindex.values(), regex.groupindex.keys()))\n    columns = [names.get(1 + i, i) for i in range(regex.groups)]\n    match_list = []\n    index_list = []\n    is_mi = arr.index.nlevels > 1\n\n    for subject_key, subject in arr.iteritems():\n        if isinstance(subject, compat.string_types):\n\n            if not is_mi:\n                subject_key = (subject_key, )\n\n            for match_i, match_tuple in enumerate(regex.findall(subject)):\n                if isinstance(match_tuple, compat.string_types):\n                    match_tuple = (match_tuple,)\n                na_tuple = [np.NaN if group == \"\" else group\n                            for group in match_tuple]\n                match_list.append(na_tuple)\n                result_key = tuple(subject_key + (match_i, ))\n                index_list.append(result_key)\n\n    from pandas import MultiIndex\n    index = MultiIndex.from_tuples(\n        index_list, names=arr.index.names + [\"match\"])\n\n    result = arr._constructor_expanddim(match_list, index=index,\n                                        columns=columns)\n    return result\n\n\ndef str_get_dummies(arr, sep='|'):\n    \"\"\"\n    Split each string in the Series by sep and return a frame of\n    dummy/indicator variables.\n\n    Parameters\n    ----------\n    sep : string, default \"|\"\n        String to split on.\n\n    Returns\n    -------\n    dummies : DataFrame\n\n    Examples\n    --------\n    >>> Series(['a|b', 'a', 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  1  0  0\n    2  1  0  1\n\n    >>> Series(['a|b', np.nan, 'a|c']).str.get_dummies()\n       a  b  c\n    0  1  1  0\n    1  0  0  0\n    2  1  0  1\n\n    See Also\n    --------\n    pandas.get_dummies\n    \"\"\"\n    arr = arr.fillna('')\n    try:\n        arr = sep + arr + sep\n    except TypeError:\n        arr = sep + arr.astype(str) + sep\n\n    tags = set()\n    for ts in arr.str.split(sep):\n        tags.update(ts)\n    tags = sorted(tags - set([\"\"]))\n\n    dummies = np.empty((len(arr), len(tags)), dtype=np.int64)\n\n    for i, t in enumerate(tags):\n        pat = sep + t + sep\n        dummies[:, i] = lib.map_infer(arr.values, lambda x: pat in x)\n    return dummies, tags\n\n\ndef str_join(arr, sep):\n    \"\"\"\n    Join lists contained as elements in the Series/Index with passed delimiter.\n\n    If the elements of a Series are lists themselves, join the content of these\n    lists using the delimiter passed to the function.\n    This function is an equivalent to :meth:`str.join`.\n\n    Parameters\n    ----------\n    sep : str\n        Delimiter to use between list entries.\n\n    Returns\n    -------\n    Series/Index: object\n\n    Notes\n    -----\n    If any of the lists does not contain string objects the result of the join\n    will be `NaN`.\n\n    See Also\n    --------\n    str.join : Standard library version of this method.\n    Series.str.split : Split strings around given separator/delimiter.\n\n    Examples\n    --------\n\n    Example with a list that contains non-string elements.\n\n    >>> s = pd.Series([['lion', 'elephant', 'zebra'],\n    ...                [1.1, 2.2, 3.3],\n    ...                ['cat', np.nan, 'dog'],\n    ...                ['cow', 4.5, 'goat']\n    ...                ['duck', ['swan', 'fish'], 'guppy']])\n    >>> s\n    0        [lion, elephant, zebra]\n    1                [1.1, 2.2, 3.3]\n    2                [cat, nan, dog]\n    3               [cow, 4.5, goat]\n    4    [duck, [swan, fish], guppy]\n    dtype: object\n\n    Join all lists using an '-', the lists containing object(s) of types other\n    than str will become a NaN.\n\n    >>> s.str.join('-')\n    0    lion-elephant-zebra\n    1                    NaN\n    2                    NaN\n    3                    NaN\n    4                    NaN\n    dtype: object\n    \"\"\"\n    return _na_map(sep.join, arr)\n\n\ndef str_findall(arr, pat, flags=0):\n    \"\"\"\n    Find all occurrences of pattern or regular expression in the Series/Index.\n\n    Equivalent to applying :func:`re.findall` to all the elements in the\n    Series/Index.\n\n    Parameters\n    ----------\n    pat : string\n        Pattern or regular expression.\n    flags : int, default 0\n        ``re`` module flags, e.g. `re.IGNORECASE` (default is 0, which means\n        no flags).\n\n    Returns\n    -------\n    Series/Index of lists of strings\n        All non-overlapping matches of pattern or regular expression in each\n        string of this Series/Index.\n\n    See Also\n    --------\n    count : Count occurrences of pattern or regular expression in each string\n        of the Series/Index.\n    extractall : For each string in the Series, extract groups from all matches\n        of regular expression and return a DataFrame with one row for each\n        match and one column for each group.\n    re.findall : The equivalent ``re`` function to all non-overlapping matches\n        of pattern or regular expression in string, as a list of strings.\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])\n\n    The search for the pattern 'Monkey' returns one match:\n\n    >>> s.str.findall('Monkey')\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    On the other hand, the search for the pattern 'MONKEY' doesn't return any\n    match:\n\n    >>> s.str.findall('MONKEY')\n    0    []\n    1    []\n    2    []\n    dtype: object\n\n    Flags can be added to the pattern or regular expression. For instance,\n    to find the pattern 'MONKEY' ignoring the case:\n\n    >>> import re\n    >>> s.str.findall('MONKEY', flags=re.IGNORECASE)\n    0          []\n    1    [Monkey]\n    2          []\n    dtype: object\n\n    When the pattern matches more than one string in the Series, all matches\n    are returned:\n\n    >>> s.str.findall('on')\n    0    [on]\n    1    [on]\n    2      []\n    dtype: object\n\n    Regular expressions are supported too. For instance, the search for all the\n    strings ending with the word 'on' is shown next:\n\n    >>> s.str.findall('on$')\n    0    [on]\n    1      []\n    2      []\n    dtype: object\n\n    If the pattern is found more than once in the same string, then a list of\n    multiple strings is returned:\n\n    >>> s.str.findall('b')\n    0        []\n    1        []\n    2    [b, b]\n    dtype: object\n\n    \"\"\"\n    regex = re.compile(pat, flags=flags)\n    return _na_map(regex.findall, arr)\n\n\ndef str_find(arr, sub, start=0, end=None, side='left'):\n    \"\"\"\n    Return indexes in each strings in the Series/Index where the\n    substring is fully contained between [start:end]. Return -1 on failure.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n    side : {'left', 'right'}, default 'left'\n        Specifies a starting side, equivalent to ``find`` or ``rfind``\n\n    Returns\n    -------\n    found : Series/Index of integer values\n    \"\"\"\n\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'find'\n    elif side == 'right':\n        method = 'rfind'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_index(arr, sub, start=0, end=None, side='left'):\n    if not isinstance(sub, compat.string_types):\n        msg = 'expected a string object, not {0}'\n        raise TypeError(msg.format(type(sub).__name__))\n\n    if side == 'left':\n        method = 'index'\n    elif side == 'right':\n        method = 'rindex'\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    if end is None:\n        f = lambda x: getattr(x, method)(sub, start)\n    else:\n        f = lambda x: getattr(x, method)(sub, start, end)\n\n    return _na_map(f, arr, dtype=int)\n\n\ndef str_pad(arr, width, side='left', fillchar=' '):\n    \"\"\"\n    Pad strings in the Series/Index with an additional character to\n    specified side.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with spaces\n    side : {'left', 'right', 'both'}, default 'left'\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    padded : Series/Index of objects\n    \"\"\"\n\n    if not isinstance(fillchar, compat.string_types):\n        msg = 'fillchar must be a character, not {0}'\n        raise TypeError(msg.format(type(fillchar).__name__))\n\n    if len(fillchar) != 1:\n        raise TypeError('fillchar must be a character, not str')\n\n    if not is_integer(width):\n        msg = 'width must be of integer type, not {0}'\n        raise TypeError(msg.format(type(width).__name__))\n\n    if side == 'left':\n        f = lambda x: x.rjust(width, fillchar)\n    elif side == 'right':\n        f = lambda x: x.ljust(width, fillchar)\n    elif side == 'both':\n        f = lambda x: x.center(width, fillchar)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n\n    return _na_map(f, arr)\n\n\ndef str_split(arr, pat=None, n=None):\n    \"\"\"\n    Split strings around given separator/delimiter.\n\n    Split each string in the caller's values by given\n    pattern, propagating NaN values. Equivalent to :meth:`str.split`.\n\n    Parameters\n    ----------\n    pat : str, optional\n        String or regular expression to split on.\n        If not specified, split on whitespace.\n    n : int, default -1 (all)\n        Limit number of splits in output.\n        ``None``, 0 and -1 will be interpreted as return all splits.\n    expand : bool, default False\n        Expand the splitted strings into separate columns.\n\n        * If ``True``, return DataFrame/MultiIndex expanding dimensionality.\n        * If ``False``, return Series/Index, containing lists of strings.\n\n    Returns\n    -------\n    Series, Index, DataFrame or MultiIndex\n        Type matches caller unless ``expand=True`` (see Notes).\n\n    Notes\n    -----\n    The handling of the `n` keyword depends on the number of found splits:\n\n    - If found splits > `n`,  make first `n` splits only\n    - If found splits <= `n`, make all splits\n    - If for a certain row the number of found splits < `n`,\n      append `None` for padding up to `n` if ``expand=True``\n\n    If using ``expand=True``, Series and Index callers return DataFrame and\n    MultiIndex objects, respectively.\n\n    See Also\n    --------\n    str.split : Standard library version of this method.\n    Series.str.get_dummies : Split each string into dummy variables.\n    Series.str.partition : Split string on a separator, returning\n        the before, separator, and after components.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\"])\n\n    By default, split will return an object of the same size\n    having lists containing the split elements\n\n    >>> s.str.split()\n    0           [this, is, good, text]\n    1    [but, this, is, even, better]\n    dtype: object\n    >>> s.str.split(\"random\")\n    0          [this is good text]\n    1    [but this is even better]\n    dtype: object\n\n    When using ``expand=True``, the split elements will expand out into\n    separate columns.\n\n    For Series object, output return type is DataFrame.\n\n    >>> s.str.split(expand=True)\n          0     1     2     3       4\n    0  this    is  good  text    None\n    1   but  this    is  even  better\n    >>> s.str.split(\" is \", expand=True)\n              0            1\n    0      this    good text\n    1  but this  even better\n\n    For Index object, output return type is MultiIndex.\n\n    >>> i = pd.Index([\"ba 100 001\", \"ba 101 002\", \"ba 102 003\"])\n    >>> i.str.split(expand=True)\n    MultiIndex(levels=[['ba'], ['100', '101', '102'], ['001', '002', '003']],\n           labels=[[0, 0, 0], [0, 1, 2], [0, 1, 2]])\n\n    Parameter `n` can be used to limit the number of splits in the output.\n\n    >>> s.str.split(\"is\", n=1)\n    0          [th,  is good text]\n    1    [but th,  is even better]\n    dtype: object\n    >>> s.str.split(\"is\", n=1, expand=True)\n            0                1\n    0      th     is good text\n    1  but th   is even better\n\n    If NaN is present, it is propagated throughout the columns\n    during the split.\n\n    >>> s = pd.Series([\"this is good text\", \"but this is even better\", np.nan])\n    >>> s.str.split(n=3, expand=True)\n          0     1     2            3\n    0  this    is  good         text\n    1   but  this    is  even better\n    2   NaN   NaN   NaN          NaN\n    \"\"\"\n    if pat is None:\n        if n is None or n == 0:\n            n = -1\n        f = lambda x: x.split(pat, n)\n    else:\n        if len(pat) == 1:\n            if n is None or n == 0:\n                n = -1\n            f = lambda x: x.split(pat, n)\n        else:\n            if n is None or n == -1:\n                n = 0\n            regex = re.compile(pat)\n            f = lambda x: regex.split(x, maxsplit=n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_rsplit(arr, pat=None, n=None):\n    \"\"\"\n    Split each string in the Series/Index by the given delimiter\n    string, starting at the end of the string and working to the front.\n    Equivalent to :meth:`str.rsplit`.\n\n    Parameters\n    ----------\n    pat : string, default None\n        Separator to split on. If None, splits on whitespace\n    n : int, default -1 (all)\n        None, 0 and -1 will be interpreted as return all splits\n    expand : bool, default False\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : Series/Index or DataFrame/MultiIndex of objects\n    \"\"\"\n    if n is None or n == 0:\n        n = -1\n    f = lambda x: x.rsplit(pat, n)\n    res = _na_map(f, arr)\n    return res\n\n\ndef str_slice(arr, start=None, stop=None, step=None):\n    \"\"\"\n    Slice substrings from each element in the Series/Index\n\n    Parameters\n    ----------\n    start : int or None\n    stop : int or None\n    step : int or None\n\n    Returns\n    -------\n    sliced : Series/Index of objects\n    \"\"\"\n    obj = slice(start, stop, step)\n    f = lambda x: x[obj]\n    return _na_map(f, arr)\n\n\ndef str_slice_replace(arr, start=None, stop=None, repl=None):\n    \"\"\"\n    Replace a positional slice of a string with another value.\n\n    Parameters\n    ----------\n    start : int, optional\n        Left index position to use for the slice. If not specified (None),\n        the slice is unbounded on the left, i.e. slice from the start\n        of the string.\n    stop : int, optional\n        Right index position to use for the slice. If not specified (None),\n        the slice is unbounded on the right, i.e. slice until the\n        end of the string.\n    repl : str, optional\n        String for replacement. If not specified (None), the sliced region\n        is replaced with an empty string.\n\n    Returns\n    -------\n    replaced : Series or Index\n        Same type as the original object.\n\n    See Also\n    --------\n    Series.str.slice : Just slicing without replacement.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])\n    >>> s\n    0        a\n    1       ab\n    2      abc\n    3     abdc\n    4    abcde\n    dtype: object\n\n    Specify just `start`, meaning replace `start` until the end of the\n    string with `repl`.\n\n    >>> s.str.slice_replace(1, repl='X')\n    0    aX\n    1    aX\n    2    aX\n    3    aX\n    4    aX\n    dtype: object\n\n    Specify just `stop`, meaning the start of the string to `stop` is replaced\n    with `repl`, and the rest of the string is included.\n\n    >>> s.str.slice_replace(stop=2, repl='X')\n    0       X\n    1       X\n    2      Xc\n    3     Xdc\n    4    Xcde\n    dtype: object\n\n    Specify `start` and `stop`, meaning the slice from `start` to `stop` is\n    replaced with `repl`. Everything before or after `start` and `stop` is\n    included as is.\n\n    >>> s.str.slice_replace(start=1, stop=3, repl='X')\n    0      aX\n    1      aX\n    2      aX\n    3     aXc\n    4    aXde\n    dtype: object\n    \"\"\"\n    if repl is None:\n        repl = ''\n\n    def f(x):\n        if x[start:stop] == '':\n            local_stop = start\n        else:\n            local_stop = stop\n        y = ''\n        if start is not None:\n            y += x[:start]\n        y += repl\n        if stop is not None:\n            y += x[local_stop:]\n        return y\n\n    return _na_map(f, arr)\n\n\ndef str_strip(arr, to_strip=None, side='both'):\n    \"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index.\n\n    Parameters\n    ----------\n    to_strip : str or unicode\n    side : {'left', 'right', 'both'}, default 'both'\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\"\n    if side == 'both':\n        f = lambda x: x.strip(to_strip)\n    elif side == 'left':\n        f = lambda x: x.lstrip(to_strip)\n    elif side == 'right':\n        f = lambda x: x.rstrip(to_strip)\n    else:  # pragma: no cover\n        raise ValueError('Invalid side')\n    return _na_map(f, arr)\n\n\ndef str_wrap(arr, width, **kwargs):\n    r\"\"\"\n    Wrap long strings in the Series/Index to be formatted in\n    paragraphs with length less than a given width.\n\n    This method has the same keyword parameters and defaults as\n    :class:`textwrap.TextWrapper`.\n\n    Parameters\n    ----------\n    width : int\n        Maximum line-width\n    expand_tabs : bool, optional\n        If true, tab characters will be expanded to spaces (default: True)\n    replace_whitespace : bool, optional\n        If true, each whitespace character (as defined by string.whitespace)\n        remaining after tab expansion will be replaced by a single space\n        (default: True)\n    drop_whitespace : bool, optional\n        If true, whitespace that, after wrapping, happens to end up at the\n        beginning or end of a line is dropped (default: True)\n    break_long_words : bool, optional\n        If true, then words longer than width will be broken in order to ensure\n        that no lines are longer than width. If it is false, long words will\n        not be broken, and some lines may be longer than width. (default: True)\n    break_on_hyphens : bool, optional\n        If true, wrapping will occur preferably on whitespace and right after\n        hyphens in compound words, as it is customary in English. If false,\n        only whitespaces will be considered as potentially good places for line\n        breaks, but you need to set break_long_words to false if you want truly\n        insecable words. (default: True)\n\n    Returns\n    -------\n    wrapped : Series/Index of objects\n\n    Notes\n    -----\n    Internally, this method uses a :class:`textwrap.TextWrapper` instance with\n    default settings. To achieve behavior matching R's stringr library str_wrap\n    function, use the arguments:\n\n    - expand_tabs = False\n    - replace_whitespace = True\n    - drop_whitespace = True\n    - break_long_words = False\n    - break_on_hyphens = False\n\n    Examples\n    --------\n\n    >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])\n    >>> s.str.wrap(12)\n    0             line to be\\nwrapped\n    1    another line\\nto be\\nwrapped\n    \"\"\"\n    kwargs['width'] = width\n\n    tw = textwrap.TextWrapper(**kwargs)\n\n    return _na_map(lambda s: '\\n'.join(tw.wrap(s)), arr)\n\n\ndef str_translate(arr, table, deletechars=None):\n    \"\"\"\n    Map all characters in the string through the given mapping table.\n    Equivalent to standard :meth:`str.translate`. Note that the optional\n    argument deletechars is only valid if you are using python 2. For python 3,\n    character deletion should be specified via the table argument.\n\n    Parameters\n    ----------\n    table : dict (python 3), str or None (python 2)\n        In python 3, table is a mapping of Unicode ordinals to Unicode\n        ordinals, strings, or None. Unmapped characters are left untouched.\n        Characters mapped to None are deleted. :meth:`str.maketrans` is a\n        helper function for making translation tables.\n        In python 2, table is either a string of length 256 or None. If the\n        table argument is None, no translation is applied and the operation\n        simply removes the characters in deletechars. :func:`string.maketrans`\n        is a helper function for making translation tables.\n    deletechars : str, optional (python 2)\n        A string of characters to delete. This argument is only valid\n        in python 2.\n\n    Returns\n    -------\n    translated : Series/Index of objects\n    \"\"\"\n    if deletechars is None:\n        f = lambda x: x.translate(table)\n    else:\n        if compat.PY3:\n            raise ValueError(\"deletechars is not a valid argument for \"\n                             \"str.translate in python 3. You should simply \"\n                             \"specify character deletions in the table \"\n                             \"argument\")\n        f = lambda x: x.translate(table, deletechars)\n    return _na_map(f, arr)\n\n\ndef str_get(arr, i):\n    \"\"\"\n    Extract element from each component at specified position.\n\n    Extract element from lists, tuples, or strings in each element in the\n    Series/Index.\n\n    Parameters\n    ----------\n    i : int\n        Position of element to extract.\n\n    Returns\n    -------\n    items : Series/Index of objects\n\n    Examples\n    --------\n    >>> s = pd.Series([\"String\",\n               (1, 2, 3),\n               [\"a\", \"b\", \"c\"],\n               123, -456,\n               {1:\"Hello\", \"2\":\"World\"}])\n    >>> s\n    0                        String\n    1                     (1, 2, 3)\n    2                     [a, b, c]\n    3                           123\n    4                          -456\n    5    {1: 'Hello', '2': 'World'}\n    dtype: object\n\n    >>> s.str.get(1)\n    0        t\n    1        2\n    2        b\n    3      NaN\n    4      NaN\n    5    Hello\n    dtype: object\n\n    >>> s.str.get(-1)\n    0      g\n    1      3\n    2      c\n    3    NaN\n    4    NaN\n    5    NaN\n    dtype: object\n    \"\"\"\n    def f(x):\n        if isinstance(x, dict):\n            return x.get(i)\n        elif len(x) > i >= -len(x):\n            return x[i]\n        return np.nan\n    return _na_map(f, arr)\n\n\ndef str_decode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Decode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in\n    python3.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    decoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_decoders:\n        # CPython optimized implementation\n        f = lambda x: x.decode(encoding, errors)\n    else:\n        decoder = codecs.getdecoder(encoding)\n        f = lambda x: decoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef str_encode(arr, encoding, errors=\"strict\"):\n    \"\"\"\n    Encode character string in the Series/Index using indicated encoding.\n    Equivalent to :meth:`str.encode`.\n\n    Parameters\n    ----------\n    encoding : str\n    errors : str, optional\n\n    Returns\n    -------\n    encoded : Series/Index of objects\n    \"\"\"\n    if encoding in _cpython_optimized_encoders:\n        # CPython optimized implementation\n        f = lambda x: x.encode(encoding, errors)\n    else:\n        encoder = codecs.getencoder(encoding)\n        f = lambda x: encoder(x, errors)[0]\n    return _na_map(f, arr)\n\n\ndef _noarg_wrapper(f, docstring=None, **kargs):\n    def wrapper(self):\n        result = _na_map(f, self._data, **kargs)\n        return self._wrap_result(result)\n\n    wrapper.__name__ = f.__name__\n    if docstring is not None:\n        wrapper.__doc__ = docstring\n    else:\n        raise ValueError('Provide docstring')\n\n    return wrapper\n\n\ndef _pat_wrapper(f, flags=False, na=False, **kwargs):\n    def wrapper1(self, pat):\n        result = f(self._data, pat)\n        return self._wrap_result(result)\n\n    def wrapper2(self, pat, flags=0, **kwargs):\n        result = f(self._data, pat, flags=flags, **kwargs)\n        return self._wrap_result(result)\n\n    def wrapper3(self, pat, na=np.nan):\n        result = f(self._data, pat, na=na)\n        return self._wrap_result(result)\n\n    wrapper = wrapper3 if na else wrapper2 if flags else wrapper1\n\n    wrapper.__name__ = f.__name__\n    if f.__doc__:\n        wrapper.__doc__ = f.__doc__\n\n    return wrapper\n\n\ndef copy(source):\n    \"Copy a docstring from another source function (if present)\"\n\n    def do_copy(target):\n        if source.__doc__:\n            target.__doc__ = source.__doc__\n        return target\n\n    return do_copy\n\n\nclass StringMethods(NoNewAttributesMixin):\n    \"\"\"\n    Vectorized string functions for Series and Index. NAs stay NA unless\n    handled otherwise by a particular method. Patterned after Python's string\n    methods, with some inspiration from R's stringr package.\n\n    Examples\n    --------\n    >>> s.str.split('_')\n    >>> s.str.replace('_', '')\n    \"\"\"\n\n    def __init__(self, data):\n        self._validate(data)\n        self._is_categorical = is_categorical_dtype(data)\n\n        # .values.categories works for both Series/Index\n        self._data = data.values.categories if self._is_categorical else data\n        # save orig to blow up categoricals to the right type\n        self._orig = data\n        self._freeze()\n\n    @staticmethod\n    def _validate(data):\n        from pandas.core.index import Index\n\n        if (isinstance(data, ABCSeries) and\n                not ((is_categorical_dtype(data.dtype) and\n                      is_object_dtype(data.values.categories)) or\n                     (is_object_dtype(data.dtype)))):\n            # it's neither a string series not a categorical series with\n            # strings inside the categories.\n            # this really should exclude all series with any non-string values\n            # (instead of test for object dtype), but that isn't practical for\n            # performance reasons until we have a str dtype (GH 9343)\n            raise AttributeError(\"Can only use .str accessor with string \"\n                                 \"values, which use np.object_ dtype in \"\n                                 \"pandas\")\n        elif isinstance(data, Index):\n            # can't use ABCIndex to exclude non-str\n\n            # see src/inference.pyx which can contain string values\n            allowed_types = ('string', 'unicode', 'mixed', 'mixed-integer')\n            if is_categorical_dtype(data.dtype):\n                inf_type = data.categories.inferred_type\n            else:\n                inf_type = data.inferred_type\n            if inf_type not in allowed_types:\n                message = (\"Can only use .str accessor with string values \"\n                           \"(i.e. inferred_type is 'string', 'unicode' or \"\n                           \"'mixed')\")\n                raise AttributeError(message)\n            if data.nlevels > 1:\n                message = (\"Can only use .str accessor with Index, not \"\n                           \"MultiIndex\")\n                raise AttributeError(message)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return self.slice(start=key.start, stop=key.stop, step=key.step)\n        else:\n            return self.get(key)\n\n    def __iter__(self):\n        i = 0\n        g = self.get(i)\n        while g.notna().any():\n            yield g\n            i += 1\n            g = self.get(i)\n\n    def _wrap_result(self, result, use_codes=True,\n                     name=None, expand=None):\n\n        from pandas.core.index import Index, MultiIndex\n\n        # for category, we do the stuff on the categories, so blow it up\n        # to the full series again\n        # But for some operations, we have to do the stuff on the full values,\n        # so make it possible to skip this step as the method already did this\n        # before the transformation...\n        if use_codes and self._is_categorical:\n            result = take_1d(result, self._orig.cat.codes)\n\n        if not hasattr(result, 'ndim') or not hasattr(result, 'dtype'):\n            return result\n        assert result.ndim < 3\n\n        if expand is None:\n            # infer from ndim if expand is not specified\n            expand = False if result.ndim == 1 else True\n\n        elif expand is True and not isinstance(self._orig, Index):\n            # required when expand=True is explicitly specified\n            # not needed when inferred\n\n            def cons_row(x):\n                if is_list_like(x):\n                    return x\n                else:\n                    return [x]\n\n            result = [cons_row(x) for x in result]\n            if result:\n                # propagate nan values to match longest sequence (GH 18450)\n                max_len = max(len(x) for x in result)\n                result = [x * max_len if len(x) == 0 or x[0] is np.nan\n                          else x for x in result]\n\n        if not isinstance(expand, bool):\n            raise ValueError(\"expand must be True or False\")\n\n        if expand is False:\n            # if expand is False, result should have the same name\n            # as the original otherwise specified\n            if name is None:\n                name = getattr(result, 'name', None)\n            if name is None:\n                # do not use logical or, _orig may be a DataFrame\n                # which has \"name\" column\n                name = self._orig.name\n\n        # Wait until we are sure result is a Series or Index before\n        # checking attributes (GH 12180)\n        if isinstance(self._orig, Index):\n            # if result is a boolean np.array, return the np.array\n            # instead of wrapping it into a boolean Index (GH 8875)\n            if is_bool_dtype(result):\n                return result\n\n            if expand:\n                result = list(result)\n                out = MultiIndex.from_tuples(result, names=name)\n                if out.nlevels == 1:\n                    # We had all tuples of length-one, which are\n                    # better represented as a regular Index.\n                    out = out.get_level_values(0)\n                return out\n            else:\n                return Index(result, name=name)\n        else:\n            index = self._orig.index\n            if expand:\n                cons = self._orig._constructor_expanddim\n                return cons(result, columns=name, index=index)\n            else:\n                # Must be a Series\n                cons = self._orig._constructor\n                return cons(result, name=name, index=index)\n\n    def _get_series_list(self, others, ignore_index=False):\n        \"\"\"\n        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n        into a list of Series (elements without an index must match the length\n        of the calling Series/Index).\n\n        Parameters\n        ----------\n        input : Series, DataFrame, np.ndarray, list-like or list-like of\n            objects that are either Series, np.ndarray (1-dim) or list-like\n        ignore_index : boolean, default False\n            Determines whether to forcefully align with index of the caller\n\n        Returns\n        -------\n        tuple : (input transformed into list of Series,\n                 Boolean whether FutureWarning should be raised)\n        \"\"\"\n\n        # once str.cat defaults to alignment, this function can be simplified;\n        # will not need `ignore_index` and the second boolean output anymore\n\n        from pandas import Index, Series, DataFrame, isnull\n\n        # self._orig is either Series or Index\n        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n\n        err_msg = ('others must be Series, Index, DataFrame, np.ndarrary or '\n                   'list-like (either containing only strings or containing '\n                   'only objects of type Series/Index/list-like/np.ndarray)')\n\n        if isinstance(others, Series):\n            fu_wrn = not others.index.equals(idx)\n            los = [Series(others.values, index=idx)\n                   if ignore_index and fu_wrn else others]\n            return (los, fu_wrn)\n        elif isinstance(others, Index):\n            fu_wrn = not others.equals(idx)\n            los = [Series(others.values,\n                          index=(idx if ignore_index else others))]\n            return (los, fu_wrn)\n        elif isinstance(others, DataFrame):\n            fu_wrn = not others.index.equals(idx)\n            if ignore_index and fu_wrn:\n                # without copy, this could change \"others\"\n                # that was passed to str.cat\n                others = others.copy()\n                others.index = idx\n            return ([others[x] for x in others], fu_wrn)\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = DataFrame(others, index=idx)\n            return ([others[x] for x in others], False)\n        elif is_list_like(others):\n            others = list(others)  # ensure iterators do not get read twice etc\n            if all(is_list_like(x) for x in others):\n                los = []\n                fu_wrn = False\n                while others:\n                    nxt = others.pop(0)  # list-like as per check above\n                    # safety for iterators and other non-persistent list-likes\n                    # do not map indexed/typed objects; would lose information\n                    if not isinstance(nxt, (DataFrame, Series,\n                                            Index, np.ndarray)):\n                        nxt = list(nxt)\n\n                    # known types without deep inspection\n                    no_deep = ((isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n                               or isinstance(nxt, (Series, Index)))\n                    # Nested list-likes are forbidden - elements of nxt must be\n                    # strings/NaN/None. Need to robustify NaN-check against\n                    # x in nxt being list-like (otherwise ambiguous boolean)\n                    is_legal = ((no_deep and nxt.dtype == object)\n                                or all((isinstance(x, compat.string_types)\n                                        or (not is_list_like(x) and isnull(x))\n                                        or x is None)\n                                       for x in nxt))\n                    # DataFrame is false positive of is_legal\n                    # because \"x in df\" returns column names\n                    if not is_legal or isinstance(nxt, DataFrame):\n                        raise TypeError(err_msg)\n\n                    nxt, fwn = self._get_series_list(nxt,\n                                                     ignore_index=ignore_index)\n                    los = los + nxt\n                    fu_wrn = fu_wrn or fwn\n                return (los, fu_wrn)\n            # test if there is a mix of list-like and non-list-like (e.g. str)\n            elif (any(is_list_like(x) for x in others)\n                  and any(not is_list_like(x) for x in others)):\n                raise TypeError(err_msg)\n            else:  # all elements in others are _not_ list-like\n                return ([Series(others, index=idx)], False)\n        raise TypeError(err_msg)\n\n    def cat(self, others=None, sep=None, na_rep=None, join=None):\n        \"\"\"\n        Concatenate strings in the Series/Index with given separator.\n\n        If `others` is specified, this function concatenates the Series/Index\n        and elements of `others` element-wise.\n        If `others` is not passed, then all values in the Series/Index are\n        concatenated into a single string with a given `sep`.\n\n        Parameters\n        ----------\n        others : Series, Index, DataFrame, np.ndarrary or list-like\n            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n            other list-likes of strings must have the same length as the\n            calling Series/Index, with the exception of indexed objects (i.e.\n            Series/Index/DataFrame) if `join` is not None.\n\n            If others is a list-like that contains a combination of Series,\n            np.ndarray (1-dim) or list-like, then all elements will be unpacked\n            and must satisfy the above criteria individually.\n\n            If others is None, the method returns the concatenation of all\n            strings in the calling Series/Index.\n        sep : string or None, default None\n            If None, concatenates without any separator.\n        na_rep : string or None, default None\n            Representation that is inserted for all missing values:\n\n            - If `na_rep` is None, and `others` is None, missing values in the\n              Series/Index are omitted from the result.\n            - If `na_rep` is None, and `others` is not None, a row containing a\n              missing value in any of the columns (before concatenation) will\n              have a missing value in the result.\n        join : {'left', 'right', 'outer', 'inner'}, default None\n            Determines the join-style between the calling Series/Index and any\n            Series/Index/DataFrame in `others` (objects without an index need\n            to match the length of the calling Series/Index). If None,\n            alignment is disabled, but this option will be removed in a future\n            version of pandas and replaced with a default of `'left'`. To\n            disable alignment, use `.values` on any Series/Index/DataFrame in\n            `others`.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        concat : str if `other is None`, Series/Index of objects if `others is\n            not None`. In the latter case, the result will remain categorical\n            if the calling Series/Index is categorical.\n\n        See Also\n        --------\n        split : Split each string in the Series/Index\n\n        Examples\n        --------\n        When not passing `others`, all values are concatenated into a single\n        string:\n\n        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n        >>> s.str.cat(sep=' ')\n        'a b d'\n\n        By default, NA values in the Series are ignored. Using `na_rep`, they\n        can be given a representation:\n\n        >>> s.str.cat(sep=' ', na_rep='?')\n        'a b ? d'\n\n        If `others` is specified, corresponding values are concatenated with\n        the separator. Result will be a Series of strings.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n        0    a,A\n        1    b,B\n        2    NaN\n        3    d,D\n        dtype: object\n\n        Missing values will remain missing in the result, but can again be\n        represented using `na_rep`\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n        0    a,A\n        1    b,B\n        2    -,C\n        3    d,D\n        dtype: object\n\n        If `sep` is not specified, the values are concatenated without\n        separation.\n\n        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n        0    aA\n        1    bB\n        2    -C\n        3    dD\n        dtype: object\n\n        Series with different indexes can be aligned before concatenation. The\n        `join`-keyword works as in other methods.\n\n        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n        >>> s.str.cat(t, join=None, na_rep='-')\n        0    ad\n        1    ba\n        2    -e\n        3    dc\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='left', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='outer', na_rep='-')\n        0    aa\n        1    b-\n        2    -c\n        3    dd\n        4    -e\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='inner', na_rep='-')\n        0    aa\n        2    -c\n        3    dd\n        dtype: object\n        >>>\n        >>> s.str.cat(t, join='right', na_rep='-')\n        3    dd\n        0    aa\n        4    -e\n        2    -c\n        dtype: object\n\n        For more examples, see :ref:`here <text.concatenate>`.\n        \"\"\"\n        from pandas import Index, Series, concat\n\n        if isinstance(others, compat.string_types):\n            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n\n        if isinstance(self._orig, Index):\n            data = Series(self._orig, index=self._orig)\n        else:  # Series\n            data = self._orig\n\n        # concatenate Series/Index with itself if no \"others\"\n        if others is None:\n            result = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n            return self._wrap_result(result,\n                                     use_codes=(not self._is_categorical))\n\n        try:\n            # turn anything in \"others\" into lists of Series\n            others, fu_wrn = self._get_series_list(others,\n                                                   ignore_index=(join is None))\n        except ValueError:  # do not catch TypeError raised by _get_series_list\n            if join is None:\n                raise ValueError('All arrays must be same length, except '\n                                 'those having an index if `join` is not None')\n            else:\n                raise ValueError('If `others` contains arrays or lists (or '\n                                 'other list-likes without an index), these '\n                                 'must all be of the same length as the '\n                                 'calling Series/Index.')\n\n        if join is None and fu_wrn:\n            warnings.warn(\"A future version of pandas will perform index \"\n                          \"alignment when `others` is a Series/Index/\"\n                          \"DataFrame (or a list-like containing one). To \"\n                          \"disable alignment (the behavior before v.0.23) and \"\n                          \"silence this warning, use `.values` on any Series/\"\n                          \"Index/DataFrame in `others`. To enable alignment \"\n                          \"and silence this warning, pass `join='left'|\"\n                          \"'outer'|'inner'|'right'`. The future default will \"\n                          \"be `join='left'`.\", FutureWarning, stacklevel=2)\n\n        # align if required\n        if join is not None:\n            # Need to add keys for uniqueness in case of duplicate columns\n            others = concat(others, axis=1,\n                            join=(join if join == 'inner' else 'outer'),\n                            keys=range(len(others)))\n            data, others = data.align(others, join=join)\n            others = [others[x] for x in others]  # again list of Series\n\n        # str_cat discards index\n        res = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n\n        if isinstance(self._orig, Index):\n            res = Index(res)\n        else:  # Series\n            res = Series(res, index=data.index)\n        return res\n\n    @copy(str_split)\n    def split(self, pat=None, n=-1, expand=False):\n        result = str_split(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_rsplit)\n    def rsplit(self, pat=None, n=-1, expand=False):\n        result = str_rsplit(self._data, pat, n=n)\n        return self._wrap_result(result, expand=expand)\n\n    _shared_docs['str_partition'] = (\"\"\"\n    Split the string at the %(side)s occurrence of `sep`, and return 3 elements\n    containing the part before the separator, the separator itself,\n    and the part after the separator.\n    If the separator is not found, return %(return)s.\n\n    Parameters\n    ----------\n    pat : string, default whitespace\n        String to split on.\n    expand : bool, default True\n        * If True, return DataFrame/MultiIndex expanding dimensionality.\n        * If False, return Series/Index.\n\n    Returns\n    -------\n    split : DataFrame/MultiIndex or Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n\n    Examples\n    --------\n\n    >>> s = Series(['A_B_C', 'D_E_F', 'X'])\n    0    A_B_C\n    1    D_E_F\n    2        X\n    dtype: object\n\n    >>> s.str.partition('_')\n       0  1    2\n    0  A  _  B_C\n    1  D  _  E_F\n    2  X\n\n    >>> s.str.rpartition('_')\n         0  1  2\n    0  A_B  _  C\n    1  D_E  _  F\n    2          X\n    \"\"\")\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'first',\n        'return': '3 elements containing the string itself, followed by two '\n                  'empty strings',\n        'also': 'rpartition : Split the string at the last occurrence of `sep`'\n    })\n    def partition(self, pat=' ', expand=True):\n        f = lambda x: x.partition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @Appender(_shared_docs['str_partition'] % {\n        'side': 'last',\n        'return': '3 elements containing two empty strings, followed by the '\n                  'string itself',\n        'also': 'partition : Split the string at the first occurrence of `sep`'\n    })\n    def rpartition(self, pat=' ', expand=True):\n        f = lambda x: x.rpartition(pat)\n        result = _na_map(f, self._data)\n        return self._wrap_result(result, expand=expand)\n\n    @copy(str_get)\n    def get(self, i):\n        result = str_get(self._data, i)\n        return self._wrap_result(result)\n\n    @copy(str_join)\n    def join(self, sep):\n        result = str_join(self._data, sep)\n        return self._wrap_result(result)\n\n    @copy(str_contains)\n    def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):\n        result = str_contains(self._data, pat, case=case, flags=flags, na=na,\n                              regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_match)\n    def match(self, pat, case=True, flags=0, na=np.nan, as_indexer=None):\n        result = str_match(self._data, pat, case=case, flags=flags, na=na,\n                           as_indexer=as_indexer)\n        return self._wrap_result(result)\n\n    @copy(str_replace)\n    def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):\n        result = str_replace(self._data, pat, repl, n=n, case=case,\n                             flags=flags, regex=regex)\n        return self._wrap_result(result)\n\n    @copy(str_repeat)\n    def repeat(self, repeats):\n        result = str_repeat(self._data, repeats)\n        return self._wrap_result(result)\n\n    @copy(str_pad)\n    def pad(self, width, side='left', fillchar=' '):\n        result = str_pad(self._data, width, side=side, fillchar=fillchar)\n        return self._wrap_result(result)\n\n    _shared_docs['str_pad'] = (\"\"\"\n    Filling %(side)s side of strings in the Series/Index with an\n    additional character. Equivalent to :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    width : int\n        Minimum width of resulting string; additional characters will be filled\n        with ``fillchar``\n    fillchar : str\n        Additional character for filling, default is whitespace\n\n    Returns\n    -------\n    filled : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left and right',\n                                             method='center'))\n    def center(self, width, fillchar=' '):\n        return self.pad(width, side='both', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='right', method='ljust'))\n    def ljust(self, width, fillchar=' '):\n        return self.pad(width, side='right', fillchar=fillchar)\n\n    @Appender(_shared_docs['str_pad'] % dict(side='left', method='rjust'))\n    def rjust(self, width, fillchar=' '):\n        return self.pad(width, side='left', fillchar=fillchar)\n\n    def zfill(self, width):\n        \"\"\"\n        Filling left side of strings in the Series/Index with 0.\n        Equivalent to :meth:`str.zfill`.\n\n        Parameters\n        ----------\n        width : int\n            Minimum width of resulting string; additional characters will be\n            filled with 0\n\n        Returns\n        -------\n        filled : Series/Index of objects\n        \"\"\"\n        result = str_pad(self._data, width, side='left', fillchar='0')\n        return self._wrap_result(result)\n\n    @copy(str_slice)\n    def slice(self, start=None, stop=None, step=None):\n        result = str_slice(self._data, start, stop, step)\n        return self._wrap_result(result)\n\n    @copy(str_slice_replace)\n    def slice_replace(self, start=None, stop=None, repl=None):\n        result = str_slice_replace(self._data, start, stop, repl)\n        return self._wrap_result(result)\n\n    @copy(str_decode)\n    def decode(self, encoding, errors=\"strict\"):\n        result = str_decode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    @copy(str_encode)\n    def encode(self, encoding, errors=\"strict\"):\n        result = str_encode(self._data, encoding, errors)\n        return self._wrap_result(result)\n\n    _shared_docs['str_strip'] = (\"\"\"\n    Strip whitespace (including newlines) from each string in the\n    Series/Index from %(side)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    stripped : Series/Index of objects\n    \"\"\")\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left and right sides',\n                                               method='strip'))\n    def strip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='both')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='left side',\n                                               method='lstrip'))\n    def lstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['str_strip'] % dict(side='right side',\n                                               method='rstrip'))\n    def rstrip(self, to_strip=None):\n        result = str_strip(self._data, to_strip, side='right')\n        return self._wrap_result(result)\n\n    @copy(str_wrap)\n    def wrap(self, width, **kwargs):\n        result = str_wrap(self._data, width, **kwargs)\n        return self._wrap_result(result)\n\n    @copy(str_get_dummies)\n    def get_dummies(self, sep='|'):\n        # we need to cast to Series of strings as only that has all\n        # methods available for making the dummies...\n        data = self._orig.astype(str) if self._is_categorical else self._data\n        result, name = str_get_dummies(data, sep)\n        return self._wrap_result(result, use_codes=(not self._is_categorical),\n                                 name=name, expand=True)\n\n    @copy(str_translate)\n    def translate(self, table, deletechars=None):\n        result = str_translate(self._data, table, deletechars)\n        return self._wrap_result(result)\n\n    count = _pat_wrapper(str_count, flags=True)\n    startswith = _pat_wrapper(str_startswith, na=True)\n    endswith = _pat_wrapper(str_endswith, na=True)\n    findall = _pat_wrapper(str_findall, flags=True)\n\n    @copy(str_extract)\n    def extract(self, pat, flags=0, expand=True):\n        return str_extract(self, pat, flags=flags, expand=expand)\n\n    @copy(str_extractall)\n    def extractall(self, pat, flags=0):\n        return str_extractall(self._orig, pat, flags=flags)\n\n    _shared_docs['find'] = (\"\"\"\n    Return %(side)s indexes in each strings in the Series/Index\n    where the substring is fully contained between [start:end].\n    Return -1 on failure. Equivalent to standard :meth:`str.%(method)s`.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of integer values\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['find'] %\n              dict(side='lowest', method='find',\n                   also='rfind : Return highest indexes in each strings'))\n    def find(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['find'] %\n              dict(side='highest', method='rfind',\n                   also='find : Return lowest indexes in each strings'))\n    def rfind(self, sub, start=0, end=None):\n        result = str_find(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    def normalize(self, form):\n        \"\"\"Return the Unicode normal form for the strings in the Series/Index.\n        For more information on the forms, see the\n        :func:`unicodedata.normalize`.\n\n        Parameters\n        ----------\n        form : {'NFC', 'NFKC', 'NFD', 'NFKD'}\n            Unicode form\n\n        Returns\n        -------\n        normalized : Series/Index of objects\n        \"\"\"\n        import unicodedata\n        f = lambda x: unicodedata.normalize(form, compat.u_safe(x))\n        result = _na_map(f, self._data)\n        return self._wrap_result(result)\n\n    _shared_docs['index'] = (\"\"\"\n    Return %(side)s indexes in each strings where the substring is\n    fully contained between [start:end]. This is the same as\n    ``str.%(similar)s`` except instead of returning -1, it raises a ValueError\n    when the substring is not found. Equivalent to standard ``str.%(method)s``.\n\n    Parameters\n    ----------\n    sub : str\n        Substring being searched\n    start : int\n        Left edge index\n    end : int\n        Right edge index\n\n    Returns\n    -------\n    found : Series/Index of objects\n\n    See Also\n    --------\n    %(also)s\n    \"\"\")\n\n    @Appender(_shared_docs['index'] %\n              dict(side='lowest', similar='find', method='index',\n                   also='rindex : Return highest indexes in each strings'))\n    def index(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='left')\n        return self._wrap_result(result)\n\n    @Appender(_shared_docs['index'] %\n              dict(side='highest', similar='rfind', method='rindex',\n                   also='index : Return lowest indexes in each strings'))\n    def rindex(self, sub, start=0, end=None):\n        result = str_index(self._data, sub, start=start, end=end, side='right')\n        return self._wrap_result(result)\n\n    _shared_docs['len'] = (\"\"\"\n    Compute length of each string in the Series/Index.\n\n    Returns\n    -------\n    lengths : Series/Index of integer values\n    \"\"\")\n    len = _noarg_wrapper(len, docstring=_shared_docs['len'], dtype=int)\n\n    _shared_docs['casemethods'] = (\"\"\"\n    Convert strings in the Series/Index to %(type)s.\n\n    Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    Series/Index of objects\n\n    See Also\n    --------\n    Series.str.lower : Converts all characters to lowercase.\n    Series.str.upper : Converts all characters to uppercase.\n    Series.str.title : Converts first character of each word to uppercase and\n        remaining to lowercase.\n    Series.str.capitalize : Converts first character to uppercase and\n        remaining to lowercase.\n    Series.str.swapcase : Converts uppercase to lowercase and lowercase to\n        uppercase.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lower', 'CAPITALS', 'this is a sentence', 'SwApCaSe'])\n    >>> s\n    0                 lower\n    1              CAPITALS\n    2    this is a sentence\n    3              SwApCaSe\n    dtype: object\n\n    >>> s.str.lower()\n    0                 lower\n    1              capitals\n    2    this is a sentence\n    3              swapcase\n    dtype: object\n\n    >>> s.str.upper()\n    0                 LOWER\n    1              CAPITALS\n    2    THIS IS A SENTENCE\n    3              SWAPCASE\n    dtype: object\n\n    >>> s.str.title()\n    0                 Lower\n    1              Capitals\n    2    This Is A Sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.capitalize()\n    0                 Lower\n    1              Capitals\n    2    This is a sentence\n    3              Swapcase\n    dtype: object\n\n    >>> s.str.swapcase()\n    0                 LOWER\n    1              capitals\n    2    THIS IS A SENTENCE\n    3              sWaPcAsE\n    dtype: object\n    \"\"\")\n    _shared_docs['lower'] = dict(type='lowercase', method='lower')\n    _shared_docs['upper'] = dict(type='uppercase', method='upper')\n    _shared_docs['title'] = dict(type='titlecase', method='title')\n    _shared_docs['capitalize'] = dict(type='be capitalized',\n                                      method='capitalize')\n    _shared_docs['swapcase'] = dict(type='be swapcased', method='swapcase')\n    lower = _noarg_wrapper(lambda x: x.lower(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['lower'])\n    upper = _noarg_wrapper(lambda x: x.upper(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['upper'])\n    title = _noarg_wrapper(lambda x: x.title(),\n                           docstring=_shared_docs['casemethods'] %\n                           _shared_docs['title'])\n    capitalize = _noarg_wrapper(lambda x: x.capitalize(),\n                                docstring=_shared_docs['casemethods'] %\n                                _shared_docs['capitalize'])\n    swapcase = _noarg_wrapper(lambda x: x.swapcase(),\n                              docstring=_shared_docs['casemethods'] %\n                              _shared_docs['swapcase'])\n\n    _shared_docs['ismethods'] = (\"\"\"\n    Check whether all characters in each string in the Series/Index\n    are %(type)s. Equivalent to :meth:`str.%(method)s`.\n\n    Returns\n    -------\n    is : Series/array of boolean values\n    \"\"\")\n    _shared_docs['isalnum'] = dict(type='alphanumeric', method='isalnum')\n    _shared_docs['isalpha'] = dict(type='alphabetic', method='isalpha')\n    _shared_docs['isdigit'] = dict(type='digits', method='isdigit')\n    _shared_docs['isspace'] = dict(type='whitespace', method='isspace')\n    _shared_docs['islower'] = dict(type='lowercase', method='islower')\n    _shared_docs['isupper'] = dict(type='uppercase', method='isupper')\n    _shared_docs['istitle'] = dict(type='titlecase', method='istitle')\n    _shared_docs['isnumeric'] = dict(type='numeric', method='isnumeric')\n    _shared_docs['isdecimal'] = dict(type='decimal', method='isdecimal')\n    isalnum = _noarg_wrapper(lambda x: x.isalnum(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalnum'])\n    isalpha = _noarg_wrapper(lambda x: x.isalpha(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isalpha'])\n    isdigit = _noarg_wrapper(lambda x: x.isdigit(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isdigit'])\n    isspace = _noarg_wrapper(lambda x: x.isspace(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isspace'])\n    islower = _noarg_wrapper(lambda x: x.islower(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['islower'])\n    isupper = _noarg_wrapper(lambda x: x.isupper(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['isupper'])\n    istitle = _noarg_wrapper(lambda x: x.istitle(),\n                             docstring=_shared_docs['ismethods'] %\n                             _shared_docs['istitle'])\n    isnumeric = _noarg_wrapper(lambda x: compat.u_safe(x).isnumeric(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isnumeric'])\n    isdecimal = _noarg_wrapper(lambda x: compat.u_safe(x).isdecimal(),\n                               docstring=_shared_docs['ismethods'] %\n                               _shared_docs['isdecimal'])\n\n    @classmethod\n    def _make_accessor(cls, data):\n        cls._validate(data)\n        return cls(data)\n",
          "file_patch": "@@ -65,7 +65,7 @@ def _get_array_list(arr, others):\n \n def str_cat(arr, others=None, sep=None, na_rep=None):\n     \"\"\"\n-    Concatenate strings in the Series/Index with given separator.\n+    Auxiliary function for :meth:`str.cat`\n \n     If `others` is specified, this function concatenates the Series/Index\n     and elements of `others` element-wise.\n@@ -84,42 +84,9 @@ def str_cat(arr, others=None, sep=None, na_rep=None):\n \n     Returns\n     -------\n-    concat : Series/Index of objects or str\n-\n-    See Also\n-    --------\n-    split : Split each string in the Series/Index\n-\n-    Examples\n-    --------\n-    When not passing `other`, all values are concatenated into a single\n-    string:\n-\n-    >>> s = pd.Series(['a', 'b', np.nan, 'c'])\n-    >>> s.str.cat(sep=' ')\n-    'a b c'\n-\n-    By default, NA values in the Series are ignored. Using `na_rep`, they\n-    can be given a representation:\n-\n-    >>> pd.Series(['a', 'b', np.nan, 'c']).str.cat(sep=' ', na_rep='?')\n-    'a b ? c'\n-\n-    If `others` is specified, corresponding values are\n-    concatenated with the separator. Result will be a Series of strings.\n-\n-    >>> pd.Series(['a', 'b', 'c']).str.cat(['A', 'B', 'C'], sep=',')\n-    0    a,A\n-    1    b,B\n-    2    c,C\n-    dtype: object\n-\n-    Also, you can pass a list of list-likes.\n-\n-    >>> pd.Series(['a', 'b']).str.cat([['x', 'y'], ['1', '2']], sep=',')\n-    0    a,x,1\n-    1    b,y,2\n-    dtype: object\n+    concat\n+        ndarray containing concatenated results (if `others is not None`)\n+        or str (if `others is None`)\n     \"\"\"\n     if sep is None:\n         sep = ''\n@@ -174,7 +141,7 @@ def _length_check(others):\n             elif len(x) != n:\n                 raise ValueError('All arrays must be same length')\n         except TypeError:\n-            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n+            raise ValueError('Must pass arrays containing strings to str_cat')\n     return n\n \n \n@@ -1833,7 +1800,9 @@ class StringMethods(NoNewAttributesMixin):\n     def __init__(self, data):\n         self._validate(data)\n         self._is_categorical = is_categorical_dtype(data)\n-        self._data = data.cat.categories if self._is_categorical else data\n+\n+        # .values.categories works for both Series/Index\n+        self._data = data.values.categories if self._is_categorical else data\n         # save orig to blow up categoricals to the right type\n         self._orig = data\n         self._freeze()\n@@ -1859,7 +1828,11 @@ class StringMethods(NoNewAttributesMixin):\n \n             # see src/inference.pyx which can contain string values\n             allowed_types = ('string', 'unicode', 'mixed', 'mixed-integer')\n-            if data.inferred_type not in allowed_types:\n+            if is_categorical_dtype(data.dtype):\n+                inf_type = data.categories.inferred_type\n+            else:\n+                inf_type = data.inferred_type\n+            if inf_type not in allowed_types:\n                 message = (\"Can only use .str accessor with string values \"\n                            \"(i.e. inferred_type is 'string', 'unicode' or \"\n                            \"'mixed')\")\n@@ -1962,11 +1935,298 @@ class StringMethods(NoNewAttributesMixin):\n                 cons = self._orig._constructor\n                 return cons(result, name=name, index=index)\n \n-    @copy(str_cat)\n-    def cat(self, others=None, sep=None, na_rep=None):\n-        data = self._orig if self._is_categorical else self._data\n-        result = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n-        return self._wrap_result(result, use_codes=(not self._is_categorical))\n+    def _get_series_list(self, others, ignore_index=False):\n+        \"\"\"\n+        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input\n+        into a list of Series (elements without an index must match the length\n+        of the calling Series/Index).\n+\n+        Parameters\n+        ----------\n+        input : Series, DataFrame, np.ndarray, list-like or list-like of\n+            objects that are either Series, np.ndarray (1-dim) or list-like\n+        ignore_index : boolean, default False\n+            Determines whether to forcefully align with index of the caller\n+\n+        Returns\n+        -------\n+        tuple : (input transformed into list of Series,\n+                 Boolean whether FutureWarning should be raised)\n+        \"\"\"\n+\n+        # once str.cat defaults to alignment, this function can be simplified;\n+        # will not need `ignore_index` and the second boolean output anymore\n+\n+        from pandas import Index, Series, DataFrame, isnull\n+\n+        # self._orig is either Series or Index\n+        idx = self._orig if isinstance(self._orig, Index) else self._orig.index\n+\n+        err_msg = ('others must be Series, Index, DataFrame, np.ndarrary or '\n+                   'list-like (either containing only strings or containing '\n+                   'only objects of type Series/Index/list-like/np.ndarray)')\n+\n+        if isinstance(others, Series):\n+            fu_wrn = not others.index.equals(idx)\n+            los = [Series(others.values, index=idx)\n+                   if ignore_index and fu_wrn else others]\n+            return (los, fu_wrn)\n+        elif isinstance(others, Index):\n+            fu_wrn = not others.equals(idx)\n+            los = [Series(others.values,\n+                          index=(idx if ignore_index else others))]\n+            return (los, fu_wrn)\n+        elif isinstance(others, DataFrame):\n+            fu_wrn = not others.index.equals(idx)\n+            if ignore_index and fu_wrn:\n+                # without copy, this could change \"others\"\n+                # that was passed to str.cat\n+                others = others.copy()\n+                others.index = idx\n+            return ([others[x] for x in others], fu_wrn)\n+        elif isinstance(others, np.ndarray) and others.ndim == 2:\n+            others = DataFrame(others, index=idx)\n+            return ([others[x] for x in others], False)\n+        elif is_list_like(others):\n+            others = list(others)  # ensure iterators do not get read twice etc\n+            if all(is_list_like(x) for x in others):\n+                los = []\n+                fu_wrn = False\n+                while others:\n+                    nxt = others.pop(0)  # list-like as per check above\n+                    # safety for iterators and other non-persistent list-likes\n+                    # do not map indexed/typed objects; would lose information\n+                    if not isinstance(nxt, (DataFrame, Series,\n+                                            Index, np.ndarray)):\n+                        nxt = list(nxt)\n+\n+                    # known types without deep inspection\n+                    no_deep = ((isinstance(nxt, np.ndarray) and nxt.ndim == 1)\n+                               or isinstance(nxt, (Series, Index)))\n+                    # Nested list-likes are forbidden - elements of nxt must be\n+                    # strings/NaN/None. Need to robustify NaN-check against\n+                    # x in nxt being list-like (otherwise ambiguous boolean)\n+                    is_legal = ((no_deep and nxt.dtype == object)\n+                                or all((isinstance(x, compat.string_types)\n+                                        or (not is_list_like(x) and isnull(x))\n+                                        or x is None)\n+                                       for x in nxt))\n+                    # DataFrame is false positive of is_legal\n+                    # because \"x in df\" returns column names\n+                    if not is_legal or isinstance(nxt, DataFrame):\n+                        raise TypeError(err_msg)\n+\n+                    nxt, fwn = self._get_series_list(nxt,\n+                                                     ignore_index=ignore_index)\n+                    los = los + nxt\n+                    fu_wrn = fu_wrn or fwn\n+                return (los, fu_wrn)\n+            # test if there is a mix of list-like and non-list-like (e.g. str)\n+            elif (any(is_list_like(x) for x in others)\n+                  and any(not is_list_like(x) for x in others)):\n+                raise TypeError(err_msg)\n+            else:  # all elements in others are _not_ list-like\n+                return ([Series(others, index=idx)], False)\n+        raise TypeError(err_msg)\n+\n+    def cat(self, others=None, sep=None, na_rep=None, join=None):\n+        \"\"\"\n+        Concatenate strings in the Series/Index with given separator.\n+\n+        If `others` is specified, this function concatenates the Series/Index\n+        and elements of `others` element-wise.\n+        If `others` is not passed, then all values in the Series/Index are\n+        concatenated into a single string with a given `sep`.\n+\n+        Parameters\n+        ----------\n+        others : Series, Index, DataFrame, np.ndarrary or list-like\n+            Series, Index, DataFrame, np.ndarray (one- or two-dimensional) and\n+            other list-likes of strings must have the same length as the\n+            calling Series/Index, with the exception of indexed objects (i.e.\n+            Series/Index/DataFrame) if `join` is not None.\n+\n+            If others is a list-like that contains a combination of Series,\n+            np.ndarray (1-dim) or list-like, then all elements will be unpacked\n+            and must satisfy the above criteria individually.\n+\n+            If others is None, the method returns the concatenation of all\n+            strings in the calling Series/Index.\n+        sep : string or None, default None\n+            If None, concatenates without any separator.\n+        na_rep : string or None, default None\n+            Representation that is inserted for all missing values:\n+\n+            - If `na_rep` is None, and `others` is None, missing values in the\n+              Series/Index are omitted from the result.\n+            - If `na_rep` is None, and `others` is not None, a row containing a\n+              missing value in any of the columns (before concatenation) will\n+              have a missing value in the result.\n+        join : {'left', 'right', 'outer', 'inner'}, default None\n+            Determines the join-style between the calling Series/Index and any\n+            Series/Index/DataFrame in `others` (objects without an index need\n+            to match the length of the calling Series/Index). If None,\n+            alignment is disabled, but this option will be removed in a future\n+            version of pandas and replaced with a default of `'left'`. To\n+            disable alignment, use `.values` on any Series/Index/DataFrame in\n+            `others`.\n+\n+            .. versionadded:: 0.23.0\n+\n+        Returns\n+        -------\n+        concat : str if `other is None`, Series/Index of objects if `others is\n+            not None`. In the latter case, the result will remain categorical\n+            if the calling Series/Index is categorical.\n+\n+        See Also\n+        --------\n+        split : Split each string in the Series/Index\n+\n+        Examples\n+        --------\n+        When not passing `others`, all values are concatenated into a single\n+        string:\n+\n+        >>> s = pd.Series(['a', 'b', np.nan, 'd'])\n+        >>> s.str.cat(sep=' ')\n+        'a b d'\n+\n+        By default, NA values in the Series are ignored. Using `na_rep`, they\n+        can be given a representation:\n+\n+        >>> s.str.cat(sep=' ', na_rep='?')\n+        'a b ? d'\n+\n+        If `others` is specified, corresponding values are concatenated with\n+        the separator. Result will be a Series of strings.\n+\n+        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')\n+        0    a,A\n+        1    b,B\n+        2    NaN\n+        3    d,D\n+        dtype: object\n+\n+        Missing values will remain missing in the result, but can again be\n+        represented using `na_rep`\n+\n+        >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')\n+        0    a,A\n+        1    b,B\n+        2    -,C\n+        3    d,D\n+        dtype: object\n+\n+        If `sep` is not specified, the values are concatenated without\n+        separation.\n+\n+        >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')\n+        0    aA\n+        1    bB\n+        2    -C\n+        3    dD\n+        dtype: object\n+\n+        Series with different indexes can be aligned before concatenation. The\n+        `join`-keyword works as in other methods.\n+\n+        >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])\n+        >>> s.str.cat(t, join=None, na_rep='-')\n+        0    ad\n+        1    ba\n+        2    -e\n+        3    dc\n+        dtype: object\n+        >>>\n+        >>> s.str.cat(t, join='left', na_rep='-')\n+        0    aa\n+        1    b-\n+        2    -c\n+        3    dd\n+        dtype: object\n+        >>>\n+        >>> s.str.cat(t, join='outer', na_rep='-')\n+        0    aa\n+        1    b-\n+        2    -c\n+        3    dd\n+        4    -e\n+        dtype: object\n+        >>>\n+        >>> s.str.cat(t, join='inner', na_rep='-')\n+        0    aa\n+        2    -c\n+        3    dd\n+        dtype: object\n+        >>>\n+        >>> s.str.cat(t, join='right', na_rep='-')\n+        3    dd\n+        0    aa\n+        4    -e\n+        2    -c\n+        dtype: object\n+\n+        For more examples, see :ref:`here <text.concatenate>`.\n+        \"\"\"\n+        from pandas import Index, Series, concat\n+\n+        if isinstance(others, compat.string_types):\n+            raise ValueError(\"Did you mean to supply a `sep` keyword?\")\n+\n+        if isinstance(self._orig, Index):\n+            data = Series(self._orig, index=self._orig)\n+        else:  # Series\n+            data = self._orig\n+\n+        # concatenate Series/Index with itself if no \"others\"\n+        if others is None:\n+            result = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n+            return self._wrap_result(result,\n+                                     use_codes=(not self._is_categorical))\n+\n+        try:\n+            # turn anything in \"others\" into lists of Series\n+            others, fu_wrn = self._get_series_list(others,\n+                                                   ignore_index=(join is None))\n+        except ValueError:  # do not catch TypeError raised by _get_series_list\n+            if join is None:\n+                raise ValueError('All arrays must be same length, except '\n+                                 'those having an index if `join` is not None')\n+            else:\n+                raise ValueError('If `others` contains arrays or lists (or '\n+                                 'other list-likes without an index), these '\n+                                 'must all be of the same length as the '\n+                                 'calling Series/Index.')\n+\n+        if join is None and fu_wrn:\n+            warnings.warn(\"A future version of pandas will perform index \"\n+                          \"alignment when `others` is a Series/Index/\"\n+                          \"DataFrame (or a list-like containing one). To \"\n+                          \"disable alignment (the behavior before v.0.23) and \"\n+                          \"silence this warning, use `.values` on any Series/\"\n+                          \"Index/DataFrame in `others`. To enable alignment \"\n+                          \"and silence this warning, pass `join='left'|\"\n+                          \"'outer'|'inner'|'right'`. The future default will \"\n+                          \"be `join='left'`.\", FutureWarning, stacklevel=2)\n+\n+        # align if required\n+        if join is not None:\n+            # Need to add keys for uniqueness in case of duplicate columns\n+            others = concat(others, axis=1,\n+                            join=(join if join == 'inner' else 'outer'),\n+                            keys=range(len(others)))\n+            data, others = data.align(others, join=join)\n+            others = [others[x] for x in others]  # again list of Series\n+\n+        # str_cat discards index\n+        res = str_cat(data, others=others, sep=sep, na_rep=na_rep)\n+\n+        if isinstance(self._orig, Index):\n+            res = Index(res)\n+        else:  # Series\n+            res = Series(res, index=data.index)\n+        return res\n \n     @copy(str_split)\n     def split(self, pat=None, n=-1, expand=False):\n",
          "files_name_in_blame_commit": [
            "strings.py",
            "test_strings.py"
          ]
        }
      }
    }
  }
}